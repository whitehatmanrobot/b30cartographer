alizeRouter();
    }
    LeaveCriticalSection(&g_csRouterHeadCritSect);


    //Delete InprocServer32 key
    lRetVal = RegDeleteKey(HKEY_LOCAL_MACHINE, pwszDllKey);
    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //Delete key and all its subkeys.
    lRetVal = RegDeleteKey(HKEY_LOCAL_MACHINE, pwszClsidKey);
    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //Now unregister provider binder from Root Binder.
    //Cocreate Root Binder and get IRegisterProvider interface.
    hr = CoCreateInstance ( DBGUID_ROOTBINDER,
                            NULL,
                            CLSCTX_ALL,
                            __uuidof(IRegisterProvider),
                            (void **) &pRegisterProvider
                            );

    if (SUCCEEDED(hr))
    {
        // Unregister each provider with the root binder
        for ( PROUTER_ENTRY pProvider = g_pRouterHead;
              pProvider != NULL;
              pProvider=pProvider->pNext)
        {
            // Invalid provider ProgID? If so, continue with next provider
            if (NULL == pProvider->szProviderProgId)
                continue;

            pRegisterProvider->UnregisterProvider(
                    pProvider->szProviderProgId,
                    0,
                    CLSID_ADSI_BINDER);
        }
    

        // Unregister the type library
        
        iSize = GetSystemDirectoryW(pwTypeLibPath, MAX_PATH + 1);
        if(iSize == 0 || iSize > MAX_PATH + 1) {
            wcscpy(pwTypeLibPath, pwTypeLibraryName);
        }
        else {
            wcscat(pwTypeLibPath, L"\\");
            wcscat(pwTypeLibPath,pwTypeLibraryName);
        }    
        
        hr = LoadTypeLib(pwTypeLibPath, &pITypeLib);
        if (SUCCEEDED(hr)) {
            hr = pITypeLib->GetLibAttr(&pTLibAttr);
            if(SUCCEEDED(hr)) {
            
                hr = UnRegisterTypeLib(pTLibAttr->guid,
                                   pTLibAttr->wMajorVerNum,
                                   pTLibAttr->wMinorVerNum,
                                   pTLibAttr->lcid,
                                   pTLibAttr->syskind);
                pITypeLib->ReleaseTLibAttr(pTLibAttr);
            }

            pITypeLib->Release();
        }
    }

    
        

error:
    CoTaskMemFree(pwszClsid);

#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\oledscom.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       oledscom.h
//
//  Contents:   Active Directory COM Interfaces
//              - IDsOpen
//              - IDsObject
//              - IDsContainer
//              - IDsEnum
//              - IDsSchema
//              - IDsClass
//              - IDsAttribute
//              - (IDsSecurity needs to be defined)
//
// Note: Objects are:
//       DsObject: IDsOpen, IDsSecurity, IDsObject,
//                 and IDsContainer if object is a container (even if empty)
//       DsSchema: IDsOpen, IDsSecurity, IDsSchema
//       DsClass:  IDsOpen, IDsSecurity, IDsClass
//       DsAttribute: IDsOpen, IDsSecurity, IDsAttribute
//       DsEnum: IDsOpen
//
// So, every object supports IDsEnum and all but DsEnum supports IDsSecurity
//
// Note2: I thought about having DsObject support IDsClass for easy class
//        access, but I trashed that because of complexity.*
//        Similarlry, I thought about IDsSchema support for DsClass and
//        DsAttribute.  Same problem here.*
//        *SubNote: The object model would become a bit weird.  However,
//                  adding a function to the main interface to get the
//                  Class/Schema object might be useful.
//
//----------------------------------------------------------------------------

#ifndef __ADS_COM__
#define __ADS_COM__

#include <oledsapi.h>

/* Definition of interface: IDsOpen */

/*
  This interface should be used when you need to open some object or
  schema path.

  You can QI for it on any DS COM object
*/

#undef INTERFACE
#define INTERFACE IDsOpen

DECLARE_INTERFACE_(IDsOpen, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsOpen */

    STDMETHOD(OpenObject)(
        THIS_
        IN  LPWSTR lpszObjectPath,
        IN  LPWSTR lpszUsername,
        IN  LPWSTR lpszPassword,
        IN  DWORD dwAccess,
        IN  DWORD dwFlags,
        IN  REFIID riid,
        OUT void **ppADsObj
        ) PURE;

    STDMETHOD(OpenSchemaDatabase)(
        THIS_ 
        IN  LPWSTR lpszSchemaPath,
        IN  LPWSTR lpszUsername,
        IN  LPWSTR lpszPassword,
        IN  DWORD dwAccess,
        IN  DWORD dwFlags,
        OUT IDsSchema **ppDsSchema
        ) PURE;
};


/* Definition of interface: IDsObject */

/*
  This interface is only supported by actual DS object.  It should not be
  supported by schema entities.

  NOTE: The names for the methods below should be shortened some for 
        ease of use.

*/

#undef INTERFACE
#define INTERFACE IDsObject

DECLARE_INTERFACE_(IDsObject, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsObject*/

    STDMETHOD(GetObjectInformation)(
        THIS_
        OUT PDS_OBJECT_INFO pObjInfo
        ) PURE;

    STDMETHOD(GetObjectAttributes)(
        THIS_ 
        IN  PDS_STRING_LIST  pAttributeNames,
        OUT PDS_ATTRIBUTE_ENTRY *ppAttributeEntries,
        OUT PDWORD pdwNumAttributesReturned
        ) PURE;

    STDMETHOD(SetObjectAttributes)(
        THIS_
        IN  DWORD dwFlags,
        IN  PDS_ATTRIBUTE_ENTRY pAttributeEntries,
        IN  DWORD   dwNumAttributes,
        OUT PDWORD  pdwNumAttributesModified
        ) PURE;

    STDMETHOD(OpenSchemaDefinition)(
        THIS_
        OUT IDsSchema **ppDsSchema
        ) PURE;

};


/* Definition of interface: IDsContainer */

/*
  This interface should be supported by any container object.  Therefore,
  all objects should support this interface except for objects whose class 
  definitions prohibit them from containing anything.

  NOTE: Open, Create, and Delete accept any relative name, not just
        objects immediately under the container (i.e. from object
        "foo://bar", I can open "baz/foobar", which is really
        "foo://bar/baz/foobar").

        This funtionality allows me to open "@ADs!" and do all
        sorts of operations without having to browse!
        ("All the power comes to me." -- a guy in some movie,
         unfortunately, I don't know which guy or what movie.)
*/

#undef INTERFACE
#define INTERFACE IDsContainer

DECLARE_INTERFACE_(IDsContainer, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsContainer*/

    STDMETHOD(OpenEnum)(
        THIS_
        IN  DWORD dwFlags,
        IN  PDS_STRING_LIST pFilters,
        IN  PDS_STRING_LIST pDesiredAttrs,
        OUT IDsEnum **ppDsEnum
        ) PURE;

    STDMETHOD(OpenObject)(
        THIS_
        IN  LPWSTR lpszRelativeName,
        IN  IN  LPWSTR lpszUsername,
        IN  LPWSTR lpszPassword,
        IN  DWORD dwAccess,
        IN  DWORD dwFlags,
        IN  REFIID riid,
        OUT void **ppADsObj
        ) PURE;

    STDMETHOD(Create)(
        THIS_
        IN  LPWSTR lpszRelativeName,
        IN  LPWSTR lpszClass,
        IN  DWORD dwNumAttributes,
        IN  PDS_ATTRIBUTE_ENTRY pAttributeEntries
        ) PURE;

    STDMETHOD(Delete)(
        THIS_
        IN  LPWSTR lpszRDName,
        IN  LPWSTR lpszClassName
        ) PURE;

};


/* Definition of interface: IDsEnum */

/*
  $$$$ The notes below are very important!!! $$$$

  Note: *ppEnumInfo should be cast to PDS_OBJECT_INFO or LPWSTR depending
        on whether the enum was on objects or class/attributes
        (If this enum interface is used for other stuff, can use other
         castings as appropriate.)

  Note2: IDsEnum is only supported by enumeration objects that are created
         when an enumeration takes place.  These enumeration objects only
         support IUnknown, IDsOpen, and IDsEnum.  They cannot support any
         other IDs* interfaces.
*/

#undef INTERFACE
#define INTERFACE IDsEnum

DECLARE_INTERFACE_(IDsEnum, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsEnum */

    STDMETHOD(Next)(
        THIS_
        IN  DWORD dwRequested,         // 0xFFFFFFFF for just counting
        OUT PVOID *ppEnumInfo,         // NULL for no info (just counting)
        OUT LPDWORD lpdwReturned       // This would return the count
        ) PURE;

};


/* Definition of interface: IDsSchema */
#undef INTERFACE
#define INTERFACE IDsSchema

DECLARE_INTERFACE_(IDsSchema, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsSchema */

    STDMETHOD(OpenClass)(
        THIS_ 
        IN  LPWSTR lpszClass,
        IN  LPWSTR lpszUsername,
        IN  LPWSTR lpszPassword,
        IN  DWORD dwAccess,
        IN  DWORD dwFlags,
        OUT IDsClass **ppDsClass
        ) PURE;

    STDMETHOD(OpenAttribute)(
        THIS_ 
        IN  LPWSTR lpszAttribute,
        IN  LPWSTR lpszUsername,
        IN  LPWSTR lpszPassword,
        IN  DWORD dwAccess,
        IN  DWORD dwFlags,
        OUT IDsAttribute **ppDsAttribute
        ) PURE;

    STDMETHOD(OpenClassEnum)(
        THIS_
        OUT IDsEnum **ppDsEnum
        ) PURE;

    STDMETHOD(OpenAttributeEnum)(
        THIS_
        OUT IDsEnum **ppDsEnum
        ) PURE;

    STDMETHOD(CreateClass)(
        THIS_
        IN  PDS_CLASS_INFO pClassInfo
        ) PURE;

    STDMETHOD(CreateAttribute)(
        THIS_
        IN  PDS_ATTR_INFO pAttrInfo
        ) PURE;

    STDMETHOD(DeleteClass)(
        THIS_
        IN  LPWSTR lpszName,
        IN  DWORD dwFlags
        ) PURE;

    STDMETHOD(DeleteAttribute)(
        THIS_
        IN  LPWSTR lpszName,
        IN  DWORD dwFlags
        ) PURE;
};


/* Definition of interface: IDsClass */
#undef INTERFACE
#define INTERFACE IDsClass

DECLARE_INTERFACE_(IDsClass, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsClass */

    STDMETHOD(GetClassInfo)(
        THIS_
        OUT PDS_CLASS_INFO *ppClassInfo
        );

    STDMETHOD(ModifyClassInfo)(
        THIS_
        IN  PDS_CLASS_INFO pClassInfo
        ) PURE;

};


/* Definition of interface: IDsAttribute */
#undef INTERFACE
#define INTERFACE IDsAttribute

DECLARE_INTERFACE_(IDsAttribute, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IDsAttribute */

    STDMETHOD(GetAttributeInfo)(
        THIS_
        OUT PDS_ATTR_INFO *ppAttrInfo
        );

    STDMETHOD(ModifyAttributeInfo)(
        THIS_
        IN  PDS_ATTR_INFO pAttrInfo
        ) PURE;
};

#endif // __ADS_COM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\oledbutl.cxx ===
//-----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  oledbutl.cpp
//
//  Contents:
//
//
//  History:   07/10/96   RenatoB    Created, lifted  from EricJ code
//
//-----------------------------------------------------------------------------


// Includes
#include "oleds.hxx"

// All the '256's below should be 4 (the length of a pointer to a string). Because
// of a bug in the TempTable, this has been temporarily done.
//
// Note: Provider-specific types are returned as octet strings
//
MAPTYPE_STRUCT g_MapADsTypeToDBType[] = {
    {DBTYPE_NULL,                 0},         /* ADSTYPE_INVALID = 0,        */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_DN_STRING,          */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_CASE_EXACT_STRING,  */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_CASE_IGNORE_STRING, */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_PRINTABLE_STRING,   */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_NUMERIC_STRING,     */
    {DBTYPE_BOOL,                 2},         /* ADSTYPE_BOOLEAN,            */
    {DBTYPE_I4,                   4},         /* ADSTYPE_INTEGER,            */
    {DBTYPE_BYTES | DBTYPE_BYREF, 256},       /* ADSTYPE_OCTET_STRING,       */
    {DBTYPE_DATE,                 8},         /* ADSTYPE_UTC_TIME,           */
    {DBTYPE_VARIANT |DBTYPE_BYREF,16},        /* ADSTYPE_LARGE_INTEGER,      */
    {DBTYPE_BYTES | DBTYPE_BYREF, 256},       /* ADSTYPE_PROV_SPECIFIC       */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_OBJECT_CLASS,       */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_CASEIGNORE_LIST     */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_OCTET_LIST          */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_PATH                */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_POSTALADDRESS       */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_TIMESTAMP           */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_BACKLINK            */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_TYPEDNAME           */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_HOLD                */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_NETADDRESS          */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_REPLICAPOINTER      */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_FAXNUMBER           */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_EMAIL               */
    {DBTYPE_BYTES | DBTYPE_BYREF, 256},       /* ADSTYPE_NT_SECURITY_DESC    */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_UNKNOWN             */
    {DBTYPE_VARIANT |DBTYPE_BYREF,16},        /* ADSTYPE_DN_WITH_BINARY      */
    {DBTYPE_VARIANT |DBTYPE_BYREF,16}         /* ADSTYPE_DN_WITH_STRING      */
};

DWORD g_cMapADsTypeToDBType = (sizeof(g_MapADsTypeToDBType) /
                                sizeof(g_MapADsTypeToDBType[0]));

// The row object does not use IDirectorySearch when a direct bind or SELECT
// * happens. In this case, it uses IADs::Get. It is possible that a variant
// with VT_DISPATCH may be returned in this case - for ADSTYPE_NT_SECURITY_DESC
// DNWithBin or DNWithStr. In this case, they cannot be converted to any other
// DBTYPE. So, they will be returned as DBTYPE_VARIANT. 
MAPTYPE_STRUCT g_MapADsTypeToDBType2[] = {
    {DBTYPE_NULL,                 0},         /* ADSTYPE_INVALID = 0,        */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_DN_STRING,          */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_CASE_EXACT_STRING,  */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_CASE_IGNORE_STRING, */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_PRINTABLE_STRING,   */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_NUMERIC_STRING,     */
    {DBTYPE_BOOL,                 2},         /* ADSTYPE_BOOLEAN,            */
    {DBTYPE_I4,                   4},         /* ADSTYPE_INTEGER,            */
    {DBTYPE_BYTES | DBTYPE_BYREF, 256},       /* ADSTYPE_OCTET_STRING,       */
    {DBTYPE_DATE,                 8},         /* ADSTYPE_UTC_TIME,           */
    {DBTYPE_VARIANT,              16},        /* ADSTYPE_LARGE_INTEGER,      */
    {DBTYPE_BYTES | DBTYPE_BYREF, 256},       /* ADSTYPE_PROV_SPECIFIC       */
    {DBTYPE_WSTR | DBTYPE_BYREF,  256},       /* ADSTYPE_OBJECT_CLASS,       */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_CASEIGNORE_LIST     */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_OCTET_LIST          */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_PATH                */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_POSTALADDRESS       */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_TIMESTAMP           */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_BACKLINK            */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_TYPEDNAME           */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_HOLD                */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_NETADDRESS          */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_REPLICAPOINTER      */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_FAXNUMBER           */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_EMAIL               */
    {DBTYPE_BYTES | DBTYPE_BYREF, 256},       /* ADSTYPE_NT_SECURITY_DESC    */
    {DBTYPE_NULL,                 0},         /* ADSTYPE_UNKNOWN             */
    {DBTYPE_VARIANT,              16},        /* ADSTYPE_DN_WITH_BINARY      */
    {DBTYPE_VARIANT,              16}         /* ADSTYPE_DN_WITH_STRING      */
};

DWORD g_cMapADsTypeToDBType2 = (sizeof(g_MapADsTypeToDBType2) /
                                sizeof(g_MapADsTypeToDBType2[0]));

VARTYPE g_MapADsTypeToVarType[] = {
    VT_NULL,           /* ADSTYPE_INVALID = 0,        */
    VT_BSTR,           /* ADSTYPE_DN_STRING,          */
    VT_BSTR,           /* ADSTYPE_CASE_EXACT_STRING,  */
    VT_BSTR,           /* ADSTYPE_CASE_IGNORE_STRING, */
    VT_BSTR,           /* ADSTYPE_PRINTABLE_STRING,   */
    VT_BSTR,           /* ADSTYPE_NUMERIC_STRING,     */
    VT_BOOL,           /* ADSTYPE_BOOLEAN,            */
    VT_I4,             /* ADSTYPE_INTEGER,            */
    VT_UI1 | VT_ARRAY, /* ADSTYPE_OCTET_STRING,       */
    VT_DATE,           /* ADSTYPE_UTC_TIME,           */
    VT_DISPATCH,       /* ADSTYPE_LARGE_INTEGER,      */
    VT_UI1 | VT_ARRAY, /* ADSTYPE_PROV_SPECIFIC       */
    VT_BSTR,           /* ADSTYPE_OBJECT_CLASS        */
    VT_NULL,           /* ADSTYPE_CASEIGNORE_LIST     */
    VT_NULL,           /* ADSTYPE_OCTET_LIST          */
    VT_NULL,           /* ADSTYPE_PATH                */
    VT_NULL,           /* ADSTYPE_POSTALADDRESS       */
    VT_NULL,           /* ADSTYPE_TIMESTAMP           */
    VT_NULL,           /* ADSTYPE_BACKLINK            */
    VT_NULL,           /* ADSTYPE_TYPEDNAME           */
    VT_NULL,           /* ADSTYPE_HOLD                */
    VT_NULL,           /* ADSTYPE_NETADDRESS          */
    VT_NULL,           /* ADSTYPE_REPLICAPOINTER      */
    VT_NULL,           /* ADSTYPE_FAXNUMBER           */
    VT_NULL,           /* ADSTYPE_EMAIL               */
    VT_UI1 | VT_ARRAY, /* ADSTYPE_NT_SECURITY_DESC    */
    VT_NULL,           /* ADSTYPE_UNKNOWN             */
    VT_DISPATCH,       /* ADSTYPE_DN_WITH_BINARY      */
    VT_DISPATCH        /* ADSTYPE_DN_WITH_STRING      */
};

DWORD g_cMapADsTypeToVarType = (sizeof(g_MapADsTypeToVarType) /
                                sizeof(g_MapADsTypeToVarType[0]));


ADS_SEARCHPREF g_MapDBPropIdToSearchPref[] = {
    ADS_SEARCHPREF_ASYNCHRONOUS,
    ADS_SEARCHPREF_DEREF_ALIASES,
    ADS_SEARCHPREF_SIZE_LIMIT,
    ADS_SEARCHPREF_TIME_LIMIT,
    ADS_SEARCHPREF_ATTRIBTYPES_ONLY,
    ADS_SEARCHPREF_SEARCH_SCOPE,
    ADS_SEARCHPREF_TIMEOUT,
    ADS_SEARCHPREF_PAGESIZE,
    ADS_SEARCHPREF_PAGED_TIME_LIMIT,
    ADS_SEARCHPREF_CHASE_REFERRALS,
    ADS_SEARCHPREF_SORT_ON,
    ADS_SEARCHPREF_CACHE_RESULTS
};

DWORD g_cMapDBPropToSearchPref = (sizeof(g_MapDBPropIdToSearchPref) /
                                  sizeof(g_MapDBPropIdToSearchPref[0]));

//+---------------------------------------------------------------------------
//
//  Function:  CpAccessors2Rowset
//
//  Synopsis:  @ffunc Implements inheritance of Accessors. Copies to
//             a Rowset the accessors existing on the command
//
//             Called by:    CRowset::Finit
//             Called when:    At runtime.
//             Overridden:    No.  (Private)
//  Arguments:
//
//
//  Returns:    @rdesc HRESULT
//              @flag S_OK  | OK
//              @flag E_OUTOFMEMORY |could not get IMalloc
//              @flag E_FAIL| An accessor could not be created
//
//----------------------------------------------------------------------------

HRESULT
CpAccessors2Rowset(
    IAccessor     *pAccessorCommand, //@parm IN |Command's IAccessor
    IAccessor     *pAccessorRowset,  //@parm IN |Rowset's IAccessor
    ULONG          cAccessors,       //@parm IN |Count,Commnands accessors
    HACCESSOR      rgAccessors[],    //@parm IN |Array,Command's accessors
    CImpIAccessor  *pCAccessor       //accessor object of rowset
    )
{
    HRESULT         hr;
    IMalloc *       pMalloc = NULL;
    DBCOUNTITEM     cBindings;
    DBBINDING *     pBindings = NULL;
    DBBINDSTATUS *  prgBindStatus = NULL;
    ULONG           i,j;
    DBACCESSORFLAGS AccessorFlags;
    HACCESSOR       hAccessor;

    hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);
    BAIL_ON_FAILURE(hr);

    //for each of the command's accessors,
    // we create a Rowset accessor.
    // if anyone fails, return E_FAIL

    for (i=0; i<cAccessors; i++) {
        AccessorFlags = 0;
        hr=pAccessorCommand->GetBindings(
            rgAccessors[i],
            &AccessorFlags,
            &cBindings,
            &pBindings
            );

        // Not a valid accessor handle
        if (hr == DB_E_BADACCESSORHANDLE) {
            // Rowset will also inherit the bad accessor
            hr = pCAccessor->CreateBadAccessor();
            BAIL_ON_FAILURE( hr );

            continue;
        }
        BAIL_ON_FAILURE( hr );

        // Allocate memory for the Status values
        prgBindStatus = (DBBINDSTATUS*) pMalloc->Alloc((ULONG)(cBindings *
                                                       sizeof(DBBINDSTATUS)));

        if (NULL == prgBindStatus)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        hr=pAccessorRowset->CreateAccessor(
            AccessorFlags,
            cBindings,
            pBindings,
            0,
            &hAccessor,
            prgBindStatus
            );

        //
        // If CreateAccessor fails fixup DB_E_ERRORSOCCURRED
        //
        if (hr == DB_E_ERRORSOCCURRED) {
            // Fixup the HResult
            for(j=0; j < cBindings; j++) {
                switch (prgBindStatus[j])
                {
                    case DBBINDSTATUS_NOINTERFACE:
                        BAIL_ON_FAILURE( hr=E_NOINTERFACE );

                    case DBBINDSTATUS_BADBINDINFO:
                        BAIL_ON_FAILURE( hr=DB_E_BADBINDINFO );

                    case DBBINDSTATUS_BADORDINAL:
                        BAIL_ON_FAILURE( hr=DB_E_BADORDINAL );

                    case DBBINDSTATUS_BADSTORAGEFLAGS:
                        BAIL_ON_FAILURE( hr=DB_E_BADSTORAGEFLAGS );

                    case DBBINDSTATUS_UNSUPPORTEDCONVERSION:
                        BAIL_ON_FAILURE( hr=DB_E_UNSUPPORTEDCONVERSION );

                    case DBBINDSTATUS_MULTIPLESTORAGE:
                        BAIL_ON_FAILURE( hr=DB_E_MULTIPLESTORAGE );

                    case DBBINDSTATUS_OK:
                    default:
                        hr=E_FAIL;
                        break;
                }
            }
            // Should never be E_FAIL
            ADsAssert(hr != E_FAIL);
        }
        BAIL_ON_FAILURE( hr );

        if( pBindings )
            pMalloc->Free(pBindings);
        pBindings = NULL;

        if( prgBindStatus )
            pMalloc->Free(prgBindStatus);
        prgBindStatus = NULL;
    };

error:

    if (pMalloc)
    {
        if( pBindings )
            pMalloc->Free(pBindings);
        if( prgBindStatus )
            pMalloc->Free(prgBindStatus);
        pMalloc->Release();
    }

    RRETURN( hr );
}


HRESULT
GetDSInterface(
    LPWSTR lpszPath,
    CCredentials& Credentials,
    REFIID iid,
    void FAR * FAR * ppObject
    )
{
    HRESULT hr = E_FAIL;
    LPWSTR      lpszUserName=NULL, lpszPassword=NULL;
    DWORD       dwAuthFlags = 0;

    hr = Credentials.GetUserName(&lpszUserName);
    BAIL_ON_FAILURE( hr );

    hr = Credentials.GetPassword(&lpszPassword);
    BAIL_ON_FAILURE( hr );

    dwAuthFlags = Credentials.GetAuthFlags();

    hr = ADsOpenObject(
                        lpszPath,
                        lpszUserName,
                        lpszPassword,
                        dwAuthFlags,
                        iid,
                        ppObject
                        );

    if( INVALID_CREDENTIALS_ERROR(hr) )
        BAIL_ON_FAILURE( hr=DB_SEC_E_PERMISSIONDENIED );

    if( FAILED(hr) )
        BAIL_ON_FAILURE( hr=DB_E_NOTABLE );

error:

    if( lpszUserName )
        FreeADsMem(lpszUserName);

    if( lpszPassword )
    {
        SecureZeroMemory(lpszPassword, wcslen(lpszPassword) * sizeof(WCHAR));
        FreeADsMem(lpszPassword);
    }

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Function: GetCredentialsFromIAuthenticate
//
//  Synopsis: Gets credentials (user name, password) from IAuthenticate
//            interface pointer.
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
HRESULT GetCredentialsFromIAuthenticate(
        IAuthenticate *pAuthenticate,
        CCredentials& refCredentials
        )
{
    Assert(pAuthenticate);

    HRESULT hr = S_OK;
    HWND  hwnd;
    PWSTR pszUsername = NULL;
    PWSTR pszPassword = NULL;

    if (pAuthenticate->Authenticate(&hwnd, &pszUsername, &pszPassword) != S_OK)
        RRETURN(E_INVALIDARG);

    if ((hwnd != INVALID_HANDLE_VALUE) &&
        (hwnd != 0))
    {
        //don't know if and how to handle this case
        RRETURN(S_OK);
    }
    else
    {
        hr = refCredentials.SetUserName(pszUsername);
        if (SUCCEEDED(hr))
        {
            hr = refCredentials.SetPassword(pszPassword);
        }

        if (pszPassword)
        {
            SecureZeroMemory(pszPassword, wcslen(pszPassword) * sizeof(WCHAR));
            CoTaskMemFree(pszPassword);
        }
        if (pszUsername)
        {
            CoTaskMemFree(pszUsername);
        }
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:  RemoveWhiteSpaces
//
//  Synopsis:  Removes the leading and trailing white spaces
//
//  Arguments: pszText                  Text strings from which the leading
//                                      and trailing white spaces are to be
//                                      removed
//
//  Returns:    LPWSTR                  Pointer to the modified string
//
//  Modifies:
//
//  History:    08-15-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
LPWSTR
RemoveWhiteSpaces(LPWSTR pszText)
{
    LPWSTR pChar;

    if( !pszText )
        return( pszText );

    while(*pszText && iswspace(*pszText))
        pszText++;

    for(pChar = pszText + wcslen(pszText) - 1; pChar >= pszText; pChar--) {
        if( !iswspace(*pChar) )
            break;
        else
            *pChar = L'\0';
    }

    return pszText;
}

//+---------------------------------------------------------------------------
//
//  Function:  CanConvertHelper
//
//  Synopsis:  Helper that tells the consumer if the conversion is supported.
//
//  Arguments: DBTYPE wSrcType
//             DBTYPE wDstType
//
//  Returns:   HRESULT
//
//  Modifies:
//
//  History:    08-15-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
//
// Bitmask of supported conversions --
//      - src type is index into array,
//      - dst type is bit in that ULONG
//
static ULONG s_rgConvertBitmap[] =
{
                //       3 2 2 2 2 2 1 1 1 1 1 0 0 0 0 0.
                //               0 8 6 4 2 0 8 6 4 2 0 8 6 4 2 0.
                //      3 2 2 2 2 2 1 1 1 1 1 0 0 0 0 0.
                //              1 9 7 5 3 1 9 7 5 3 1 9 7 5 3 1.
                // DBTYPE_EMPTY
                0xe3bfd9ff,     //              11100011101111111101100111111111
                // DBTYPE_NULL
                0x60001002,     //              01100000000000000001000000000010
                // DBTYPE_I2
                0xdf9fd9ff,     //              11011111100111111101100111111111
                // DBTYPE_I4
                0xdfdfd9ff,     //              11011111110111111101100111111111
                // DBTYPE_R4
                0xdf9fd9ff,     //              11011111100111111101100111111111
                // DBTYPE_R8
                0xdf9fd9ff,     //              11011111100111111101100111111111
                // DBTYPE_CY
                0xc39fd97f,     //              11000011100111111101100101111111
                // DBTYPE_DATE
                0x7d9f99bf,     //              01111101100111111001100110111111
                // DBTYPE_BSTR
                0xffffd9ff,     //              11111111111111111101100111111111
                // DBTYPE_IDISPATCH
                0x4087fbff,     //              01000000100001111111101111111111
                // DBTYPE_ERROR
                0x01001500,     //              00000001000000000001010100000000
                // DBTYPE_BOOL
                0xc39fd9ff,     //              11000011100111111101100111111111
                // DBTYPE_VARIANT
                0xffffffff,     //              11111111111111111111111111111111
                // DBTYPE_IUNKNOWN
                0x00003203,     //              00000000000000000011001000000011
                // DBTYPE_DECIMAL
                0x9f9fd97f,     //              10011111100111111101100101111111
                // DBTYPE_I1
                0x9f9fd9ff,     //              10011111100111111101100111111111
                // DBTYPE_UI1
                0xdf9fd9ff,     //              11011111100111111101100111111111
                // DBTYPE_UI2
                0xdf9fd9ff,     //              11011111100111111101100111111111
                // DBTYPE_UI4
                0xdfdfd9ff,     //              11011111110111111101100111111111
                // DBTYPE_I8
                0x619fd13f,     //              01100001100111111101000100111111
                // DBTYPE_UI8
                0x619fd13f,     //              01100001100111111101000100111111
                // DBTYPE_GUID
                0x41a01103,     //              01000001101000000001000100000011
                // DBTYPE_BYTES
                0x41c4110b,     //              01000001110001000001000100001011
                // DBTYPE_STR
                0xffffd9ff,     //              11111111111111111101100111111111
                // DBTYPE_WSTR
                0xffffd9ff,     //              11111111111111111101100111111111
                // DBTYPE_NUMERIC
                0xc39fd97f,     //              11000011100111111101100101111111
                // DBTYPE_DBDATE
                0x3d801183,     //              00111101100000000001000110000011
                // DBTYPE_DBTIME
                0x3d801183,     //              00111101100000000001000110000011
                // DBTYPE_DBTIMESTAMP
                0x3d801183,     //              00111101100000000001000110000011
                // DBTYPE_FILETIME
                0x7d981183,     //              01111101100110000001000110000011
                // DBTYPE_PROPVARIANT
                0xffffffff,     //              11111111111111111111111111111111
                // DBTYPE_VARNUMERIC
                0x839fd97f,     //              10000011100111111101100101111111
};

static HRESULT IsLegalDBtype(DBTYPE);
static LONG    IndexDBTYPE(DBTYPE wType);

STDMETHODIMP
CanConvertHelper(
        DBTYPE          wSrcType,
        DBTYPE          wDstType,
        DBCONVERTFLAGS  dwConvertFlags
        )
{
    //
    // Check in-params and NULL out-params in case of error
    //
    if( (dwConvertFlags &
         ~(DBCONVERTFLAGS_ISLONG |
           DBCONVERTFLAGS_ISFIXEDLENGTH |
           DBCONVERTFLAGS_FROMVARIANT)) != DBCONVERTFLAGS_COLUMN )
        RRETURN( DB_E_BADCONVERTFLAG );

    //
    // Make sure that we check that the type is a variant if they say so
    //
    if( dwConvertFlags & DBCONVERTFLAGS_FROMVARIANT ) {
        DBTYPE  wVtType = wSrcType & VT_TYPEMASK;

        // Take out all of the Valid VT_TYPES (36 is VT_RECORD in VC 6)
        if( (wVtType > VT_DECIMAL && wVtType < VT_I1) ||
            ((wVtType > VT_LPWSTR && wVtType < VT_FILETIME) && wVtType !=36) ||
            (wVtType > VT_CLSID) )
            RRETURN( DB_E_BADTYPE );
    }

    //
    // Don't allow _ISLONG on fixed-length types
    //
    if( dwConvertFlags & DBCONVERTFLAGS_ISLONG ) {
        switch ( wSrcType & ~(DBTYPE_RESERVED|DBTYPE_VECTOR|DBTYPE_ARRAY|DBTYPE_BYREF) )
        {
        case DBTYPE_BYTES:
        case DBTYPE_STR:
        case DBTYPE_WSTR:
        case DBTYPE_VARNUMERIC:
            break;

        default:
            RRETURN( DB_E_BADCONVERTFLAG );
        }
    }

    // Check for valid types
    if( wSrcType > DBTYPE_DECIMAL )
    {
        if( FAILED(IsLegalDBtype(wSrcType)) )
            RRETURN( S_FALSE );
    }
    if( wDstType > DBTYPE_DECIMAL )
    {
        if( FAILED(IsLegalDBtype(wDstType)) )
            RRETURN( S_FALSE );
    }

    // Check for unsupported type modifiers
    if( (wSrcType & (DBTYPE_VECTOR|DBTYPE_ARRAY|DBTYPE_RESERVED)) ||
        (wDstType & (DBTYPE_VECTOR|DBTYPE_ARRAY|DBTYPE_RESERVED)) )
        RRETURN( S_FALSE );

    // Handle BYREF destination separately
    if( wDstType & DBTYPE_BYREF ) {
        // Turn off BYREF bit
        wDstType &= ~DBTYPE_BYREF;

        // We only allow BYREF destination for variable length types
        switch ( wDstType ) {
        case DBTYPE_BYTES:
        case DBTYPE_STR:
        case DBTYPE_WSTR:
        case DBTYPE_VARNUMERIC:
            break;

        default:
            // Fixed-length BYREFs are not supported
            RRETURN( S_FALSE );
        }
    }

    // Turn off BYREF bit
    wSrcType &= ~DBTYPE_BYREF;

    // Get the indices for the src and dst types
    LONG iSrc = IndexDBTYPE(wSrcType);
    ADsAssert(iSrc < NUMELEM(s_rgConvertBitmap)); // better not be larger than our array

    LONG iDst = IndexDBTYPE(wDstType);
    ADsAssert(iDst < (sizeof(ULONG) * 8) );       // or the number of bits in a ULONG

    // Make sure we have two supported types -- we don't support UDT
    if( iSrc < 0 || iDst < 0 )
        RRETURN( S_FALSE );

    // And do the lookup -- bit will be set if conversion supported
    if( s_rgConvertBitmap[iSrc] & (1 << iDst) )
        RRETURN( S_OK );

    // No bit, no support
    RRETURN( S_FALSE );
}


HRESULT IsLegalDBtype(DBTYPE dbtype)
{
    // NOTE: optimized for speed, rather than for maintainablity
    if( dbtype & (DBTYPE_VECTOR|DBTYPE_BYREF|DBTYPE_ARRAY|DBTYPE_RESERVED) )
        dbtype &= ~(DBTYPE_VECTOR|DBTYPE_BYREF|DBTYPE_ARRAY|DBTYPE_RESERVED);

    if( (dbtype >= DBTYPE_EMPTY && dbtype <= DBTYPE_DECIMAL) ||
        (dbtype >= DBTYPE_I1 && dbtype <= DBTYPE_UI8) ||
        dbtype == DBTYPE_GUID ||
        (dbtype >= DBTYPE_BYTES && dbtype <= DBTYPE_DBTIMESTAMP) ||
        (dbtype >= DBTYPE_FILETIME && dbtype <= DBTYPE_VARNUMERIC) )
        RRETURN( S_OK );

    RRETURN( DB_E_BADBINDINFO );
}


LONG IndexDBTYPE(DBTYPE wType)
{
    switch ( wType ) {
        case DBTYPE_EMPTY:      // 0
        case DBTYPE_NULL:       // 1
        case DBTYPE_I2:         // 2
        case DBTYPE_I4:         // 3
        case DBTYPE_R4:         // 4
        case DBTYPE_R8:         // 5
        case DBTYPE_CY:         // 6
        case DBTYPE_DATE:       // 7
        case DBTYPE_BSTR:       // 8
        case DBTYPE_IDISPATCH:  // 9
        case DBTYPE_ERROR:      // 10
        case DBTYPE_BOOL:       // 11
        case DBTYPE_VARIANT:    // 12
        case DBTYPE_IUNKNOWN:   // 13
        case DBTYPE_DECIMAL:    // 14
            // 0 - 14
            return (ULONG)wType;

        case DBTYPE_I1:         // 16
        case DBTYPE_UI1:        // 17
        case DBTYPE_UI2:        // 18
        case DBTYPE_UI4:        // 19
        case DBTYPE_I8:         // 20
        case DBTYPE_UI8:        // 21
            // 15 - 20
            return (ULONG)(wType - 1);

        case DBTYPE_GUID:       // 72
            // 21
            return 21;

        case DBTYPE_BYTES:      // 128
        case DBTYPE_STR:        // 129
        case DBTYPE_WSTR:       // 130
        case DBTYPE_NUMERIC:    // 131
            // 22 - 25
            return (ULONG)(wType - 106);

        case DBTYPE_DBDATE:     // 133
        case DBTYPE_DBTIME:     // 134
        case DBTYPE_DBTIMESTAMP:// 135
            // 26 - 28
            return (ULONG)(wType - 107);

        case DBTYPE_FILETIME:   // 64
             // 29
             return wType - 35;
        case DBTYPE_PROPVARIANT:// 138
        case DBTYPE_VARNUMERIC: // 139
             // 30 - 31
             return (ULONG)(wType - 108);
    }

    // No match
    return -1;
}

BYTE SetPrecision(DBTYPE dbType)
{
    switch(dbType)
    {
        case DBTYPE_I1:
        case DBTYPE_UI1:
            return 3;
        case DBTYPE_I2:
        case DBTYPE_UI2:
            return 5;
        case DBTYPE_I4:
        case DBTYPE_UI4:
            return 10;
        case DBTYPE_I8:
            return 19;
        case DBTYPE_UI8:
            return 20;
        case DBTYPE_R4:
            return 7;
        case DBTYPE_R8:
            return 15;
        case DBTYPE_CY:
            return 19;
        case DBTYPE_DECIMAL:
            return 29;
        case DBTYPE_NUMERIC:
            return 39;
        case DBTYPE_VARNUMERIC:
            return 255;
        default:
            return ((BYTE) (~0));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\oledsapi.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:       oledsapi.h
//
//  Contents:  Active Directory C API header
//
//----------------------------------------------------------------------------

#ifndef __ADS_API__
#define __ADS_API__

//////////
//
// Defines
//
//////////

#define DS_NOTHING    NULL          // ???
#define DS_EVERYTHING 0xFFFFFFFF    // ???

// missing a whole bunch...


//////////
//
// typedefs
//
//////////

// (syntax definitions need to be created in another file)

typedef DWORD OID;                  // To Be Determined (should not be DWORD)

typedef struct _ds_string_list {
    DWORD dwItems;
    LPWSTR Item[];
} DS_STRING_LIST, *PDS_STRING_LIST;

//
// Note: The struct below is returned when getting the last 
//       accessed/modified/etc times for some DS or Schema entity.
//       The members of this structure are pointers in case the particular
//       time information is not available or is not supported by the DS.
//
// Note2: A pointer to this struct is typically present in DS_*_INFO 
//        structures, in case no such info needs to be specified.
//        A user should pass in NULL for PDS_ACCESS_TIMES if it is
//        a member of some DS_*_INFO which is used as an IN parameter.
//

typedef struct _ds_access_times {
    PSYSTEMTIME pCreated;
    PSYSTEMTIME pLastAccess;
    PSYSTEMTIME pLastModified;
} DS_ACCESS_TIMES, *PDS_ACCESS_TIMES;

typedef struct _ds_object_info {
    OID Oid;
    LPWSTR lpszPath;
    LPWSTR lpszParent;
    LPWSTR lpszName;
    LPWSTR lpszClass;
    LPWSTR lpszSchema;
    PDS_ATTRIBUTE_ENTRY pAttributes;  // Usually NULL, but can be used on enum
    PDS_ACCESS_TIMES pAccessTimes;
} DS_OBJECT_INFO, *PDS_OBJECT_INFO;

typedef struct _ds_class_info {
    OID Oid;
    LPWSTR lpszName;
    PDS_STRING_LIST DerivedFrom;
    PDS_STRING_LIST CanContain;
    PDS_STRING_LIST NamingAttributes;    // What's the deal with this?
    PDS_STRING_LIST RequiredAttributes;
    PDS_STRING_LIST OptionalAttributes;
    BOOL fAbstract;
    PDS_ACCESS_TIMES pAccessTimes;
} DS_CLASS_INFO, *PDS_CLASS_INFO;

typedef struct _ds_attr_info {
    OID Oid;
    LPWSTR lpszName;
    DWORD  dwSyntaxId;
    BOOL   fMultivalued;
    //
    // Bug: Min/Max?  What else?
    //
    PDS_ACCESS_TIMES pAccessTimes;
} PDS_ATTR_INFO, *PDS_ATTR_INFO;

typedef struct _ds_attribute_value {
    DWORD   cbData;
    LPBYTE  lpData;
} DS_ATTRIBUTE_VALUE, *PDS_ATTRIBUTE_VALUE;

//
// NOTE: The dwOperation field is used only when writing attributes.
//       It describes how to write or if clearing the attribute is desired.
//       If clearing is specified, dwSyntaxId, lpValue, and dwNumValues are 
//       ignored.
//

typedef struct _ds_attribute_entry {
    LPWSTR lpszName;
    DWORD  dwSyntaxId;
    DWORD  dwNumValues;
    DWORD  dwOperation;                     // ADD, MODIFY, CLEAR ???
    PDS_ATTRIBUTE_VALUE lpValue;            // Array of values
    PDS_ACCESS_TIMES pAccessTimes;
} DS_ATTRIBUTE_ENTRY, *PDS_ATTRIBUTE_ENTRY;


//////////
//
// functions
//
//////////


//
// Memory functions
//

DWORD
WINAPI
DsBufferAlloc(
    OUT LPVOID *ppBuffer
    );

DWORD
WINAPI
DsBufferFree(
    IN  LPVOID pBuffer
    );

//
// The function below could go out and get kerberos tickets or whatever.
//
// dwType is just a hint in case the user prefers that the underlying 
// DS use a particular type of authentication...
//

DWORD
WINAPI
DsCredentialsOpen(
    IN  LPWSTR lpszUsername,
    IN  LPWSTR lpszPassword,
    IN  DWORD dwType,           // Like DS_CREDENTIALS_DEFAULT
                            // DS_CREDENTIALS_KRBV5, etc.???
    IN  DWORD dwFlags,          // What is this???
    OUT PHANDLE hCredentials
    );

DWORD
WINAPI
DsCredentialsClose(
    IN  HANDLE hCredentials
    );

//
// Good old open
//

// Note: if hRoot is NULL, lpszPath is full object path
//       otherwise, lpszPath is relative name from object w/hRoot handle 

DWORD
WINAPI
DsObjectOpen(
    IN  HANDLE hRoot,
    IN  LPWSTR lpszPath,
    IN  HANDLE hCredentials,  // NULL for process credentials
    IN  DWORD dwAccess,
    IN  DWORD dwFlags,
    OUT PHANDLE phDs
    );

//
// Note: Should we use single close (Object/Enum/Schema)???
//

DWORD
WINAPI
DsObjectClose(
    IN  HANDLE hDs
    );

//
// We need some stuff to operate on handles to get back binding info
// (this stuff comes in only when you do an open or when you refresh)
//


DWORD
WINAPI
DsObjectInfo(
    IN  HANDLE hDs,
    OUT PDS_OBJECT_INFO *ppObjectInfo
    );

//
// Read/Write Attributes
//

DWORD
WINAPI
DsObjectRead(
    IN  HANDLE hDs,
    IN  DWORD dwFlags,                  // ???
    IN  PDS_STRING_LIST pAttributeNames,
    OUT PDS_ATTRIBUTE_ENTRY *ppAttributeEntries,
    OUT LPDWORD lpdwNumAttributesReturned
    );

DWORD
WINAPI
DsObjectWrite(
    IN  HANDLE hDs,
    IN  DWORD dwNumAttributesToWrite,
    IN  PDS_ATTRIBUTE_ENTRY pAttributeEntries,
    OUT LPDWORD lpdwNumAttributesWritten
    );

//
// Create/Delete Objects
//

DWORD
WINAPI
DsObjectCreate(
    IN  HANDLE hDs,                            // Container
    IN  LPWSTR lpszRelativeName,
    IN  LPWSTR lpszClass,
    IN  DWORD dwNumAttributes,
    IN  PDS_ATTRIBUTE_ENTRY pAttributeEntries
    );

DWORD
WINAPI
DsObjectDelete(
    IN  HANDLE hDs,
    IN  LPWSTR lpszRelativeName,
    IN  LPWSTR lpszClass                     // Could be NULL if name unique??
    );

//
// Enumeration
//


DWORD
WINAPI
DsObjectEnumOpen(
    IN  HANDLE hDs,
    IN  DWORD dwFlags,                 // What is this? 
    IN  PDS_STRING_LIST pFilters,      // Classes wanted
    IN  PDS_STRING_LIST pDesiredAttrs, // Attrs wanted or NULL just for info
    OUT PHANDLE phEnum
    );

DWORD
WINAPI
DsObjectEnumNext(
    IN  HANDLE hEnum,
    IN  DWORD dwRequested,          // 0xFFFFFFFF for just counting
    OUT PDS_OBJECT_INFO *ppObjInfo, // NULL for no info (just counting)
    OUT LPDWORD lpdwReturned        // Actual number returned/counted
    );

DWORD
WINAPI
DsObjectEnumClose(
    IN  HANDLE hEnum
    );

//
// Schema stuff
//

//
// Note: The word "schema" below refers to the schema db and not to
//       a class definition.
//

DWORD
WINAPI
DsSchemaOpen(
    IN  HANDLE hSchema,    // NULL if opening schema db, 
                           // must be schema db handle otherwise
    IN  LPWSTR lpszPath,   // One of: path to schema,
                           //         class name,
                           //         attribute name
    IN  HANDLE hCredentials,
    IN  DWORD dwAccess,
    IN  DWORD dwFlags,     // DS_OPEN_SCHEMA = 0, DS_OPEN_CLASS, DS_OPEN_ATTR
    OUT PHANDLE ph         // handle to schema/class/attr depending on dwFlags
    );

DWORD
WINAPI
DsSchemaClose(
    IN  HANDLE hSchema
    );

//
// Can also create/delete schema databases (if DS allows it)???
//

DWORD
WINAPI
DsSchemaCreate(
    IN  LPWSTR lpszPath,
    IN  DWORD dwFlags          //???
    );

DWORD
WINAPI
DsSchemaDelete(
    IN  LPWSTR lpszPath,
    IN  DWORD dwFlags          //???
    );

//
// Schema Enumeration
//

//
// enum class/attribute names
//

DWORD
WINAPI
DsSchemaEnumOpen(
    IN  HANDLE hSchema,
    IN  DWORD dwFlags,          // DS_SCHEMA_ENUM_CLASS xor DS_SCHEMA_ENUM_ATTR
    OUT PHANDLE phEnum
    );

DWORD
WINAPI
DsSchemaEnumNext(
    IN  HANDLE hEnum,
    IN  DWORD dwRequested,        // Pass in 0xFFFFFFFF for just counting
    IN  LPWSTR *ppObjInfo,        // Pass in NULL for just counting
    OUT LPDWORD lpdwReturned      // This would return the count
    );

DWORD
WINAPI
DsSchemaEnumClose(
    IN  HANDLE hEnum
    );

//
// Class/Attribute Stuff
//

DWORD
WINAPI
DsSchemaClassCreate(
    IN  HANDLE hSchema,
    IN  PDS_CLASS_INFO pClassInfo // What do we do about naming attributes?
    );

DWORD
WINAPI
DsSchemaAttrCreate(
    IN  HANDLE hSchema,
    IN  PDS_ATTR_INFO pAttrInfo
    );

DWORD
WINAPI
DsSchemaClassDelete(
    IN  HANDLE hSchema,
    IN  LPWSTR lpszPath,
    IN  DWORD dwFlags          //???
    );

DWORD
WINAPI
DsSchemaAttrDelete(
    IN  HANDLE hSchema,
    IN  LPWSTR lpszPath,
    IN  DWORD dwFlags          //???
    );

DWORD
WINAPI
DsSchemaClassInfo(
    IN  HANDLE hClass,
    OUT PDS_CLASS_INFO *ppClassInfo
    );

DWORD
WINAPI
DsSchemaAttrInfo(
    IN  HANDLE hAttr,
    OUT PDS_ATTR_INFO *ppAttrInfo
    );

DWORD
WINAPI
DsSchemaClassModify(
    IN  HANDLE hSchema,
    IN  PDS_CLASS_INFO pClassInfo // What do we do about naming attributes?
    );

DWORD
WINAPI
DsSchemaAttrModify(
    IN  HANDLE hSchema,
    IN  PDS_ATTR_INFO pAttrInfo
    );

#endif // __ADS_API__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\path.cxx ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    path.cxx

Abstract:

    This file contains the PathCracker Functionality

Environment:

    User mode

Revision History:

    12/07/98 -felixw-
        Created it

--*/
#include "oleds.hxx"
#pragma hdrstop

DEFINE_IDispatch_Implementation(CPathname)

CPathname::CPathname():
    _pDispMgr(NULL),
    m_pPathnameProvider(NULL),
    _fNamingAttribute(TRUE),
    _dwEscaped(ADS_ESCAPEDMODE_DEFAULT)

/*++

Routine Description:

    Constructor for CPathname

Arguments:

Return Value:

    None

--*/

{
    ENLIST_TRACKING(CPathname);
    memset(&_PathObjectInfo,
           0x0,
           sizeof(PATH_OBJECTINFO));
    _PathObjectInfo.dwPathType = ADS_PATHTYPE_ROOTFIRST;
}


HRESULT
CPathname::CreatePathname(
    REFIID riid,
    void **ppvObj
    )

/*++

Routine Description:

    Create the pathname object

Arguments:

    riid - IID to query for
    ppvObj - object to be returned

Return Value:

    S_OK on success, error code otherwise

--*/

{
    CPathname * pPathname = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePathnameObject(&pPathname);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPathname->Release();

    RRETURN(hr);

error:
    delete pPathname;

    RRETURN(hr);
}


CPathname::~CPathname( )

/*++

Routine Description:

    Destructor for Pathname object

Arguments:

Return Value:

    None

--*/

{
    FreePathInfo(&_PathObjectInfo);
    delete _pDispMgr;
    if (m_pPathnameProvider) {
        m_pPathnameProvider->Release();
    }
}

STDMETHODIMP
CPathname::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsPathname *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPathname))
    {
        *ppv = (IADsPathname *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsPathname *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


HRESULT
CPathname::AllocatePathnameObject(
    CPathname ** ppPathname
    )

/*++

Routine Description:

    Allocate a pathname object

Arguments:

    ppPathname - constructed object

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    CPathname * pPathname = NULL;
    CDispatchMgr * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPathname = new CPathname();
    if (pPathname == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPathname,
                (IADsPathname *)pPathname,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPathname->_pDispMgr = pDispMgr;

    //
    // By default, the pathname is set to the LDAP provider
    //
    hr = ADsGetObject(L"LDAP:",
                      IID_IADsPathnameProvider,
                      (void**)&(pPathname->m_pPathnameProvider));
    BAIL_ON_FAILURE(hr);

    pPathname->_PathObjectInfo.ProviderName = AllocADsStr(L"LDAP");
    if (pPathname->_PathObjectInfo.ProviderName == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *ppPathname = pPathname;

    RRETURN(hr);

error:

    // so we will not try to delete it in the destructor
    if (pPathname)
        pPathname->_pDispMgr = NULL;

    delete pPathname;
    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CPathname::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsPathname)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

HRESULT
CPathname::SetAll(
        BSTR bstrADsPath
        )

/*++

Routine Description:

    Set the internal variables using the full ADSPath

Arguments:

    bstrADsPath - the passed in Full ADSPath

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    //
    // Freeing existing info
    //
    FreePathInfo(&_PathObjectInfo);

    //
    // Collecting new info
    //
    hr = m_pPathnameProvider->ParsePath(
                                bstrADsPath, 
                                ADS_PARSE_FULL,
                                &_PathObjectInfo);
    BAIL_ON_FAILURE(hr);

    RRETURN(hr);
error:
    FreePathInfo(&_PathObjectInfo);
    RRETURN(hr);
}

HRESULT
CPathname::GetNamespace(
        BSTR bstrADsPath, 
        PWSTR *ppszName
        )

/*++

Routine Description:

    Get a namespace from a full ADsPath

Arguments:

    bstrADsPath - passed in ADsPath
    ppszName - returned namespace, must be freed by caller

Return Value:

    S_OK on success, E_ADS_BAD_PATHNAME if the path is bad, error code 
    otherwise.

--*/

{
    DWORD dwPath = 0;               // Length of namespace
    BOOLEAN fFound = FALSE;
    PWSTR szPath = bstrADsPath;
    HRESULT hr = S_OK;

    while (*szPath) {
        if (*szPath == ':') {
            dwPath++;
            fFound = TRUE;
            break;
        }
        szPath++;
        dwPath++;
    }

    if (fFound) {
        *ppszName = (LPWSTR)AllocADsMem(sizeof(WCHAR) * (dwPath + 1));
        if (*ppszName == NULL) {
            hr = E_OUTOFMEMORY;
            goto error;
        }
    
        memcpy(*ppszName, bstrADsPath, (dwPath * sizeof(WCHAR)));
        (*ppszName)[dwPath] = '\0';
    }
    else {
        hr = E_ADS_BAD_PATHNAME;
    }

error:
    return hr;
}

 
STDMETHODIMP
CPathname::Set(
        BSTR bstrADsPath, 
        long dwSetType
        )

/*++

Routine Description:

    Set the path with the type specified

Arguments:
    bstrADsPath - the path to be set
    dwSetType - the type :
                       ADS_SETTYPE_FULL
                       ADS_SETTYPE_PROVIDER
                       ADS_SETTYPE_SERVER
                       ADS_SETTYPE_DN

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = E_FAIL;
    LPWSTR szPath = NULL;
    WCHAR* pszNamespace = NULL;
    LPWSTR pszName = NULL;
    IADsPathnameProvider    *pPathnameProvider = NULL;

    switch (dwSetType) {

        case ADS_SETTYPE_FULL:
            if ((bstrADsPath == NULL) || ((*bstrADsPath) == NULL)) {
                hr = E_INVALIDARG;
                goto error;
            }
            hr = GetNamespace(bstrADsPath, &pszName);
            BAIL_ON_FAILURE(hr);

            if ((_PathObjectInfo.ProviderName == NULL) || 
                (wcscmp(_PathObjectInfo.ProviderName, bstrADsPath) != 0)) {
                //
                // If provider not set, or if the provider is different
                // we reset the provider
                //
                pPathnameProvider = NULL;
                hr = ADsGetObject(pszName,
                                  IID_IADsPathnameProvider,
                                  (void**)&(pPathnameProvider));
                BAIL_ON_FAILURE(hr);

                if (pPathnameProvider) {
                    if (m_pPathnameProvider) {
                        m_pPathnameProvider->Release();
                    }
                    m_pPathnameProvider = pPathnameProvider;
                }
            }

            hr = SetAll(bstrADsPath);
            break;

        case ADS_SETTYPE_PROVIDER:

            if ((bstrADsPath == NULL) || ((*bstrADsPath) == NULL)) {
                hr = E_INVALIDARG;
                goto error;
            }
            //
            // If it is the same as the namespace that is stored inside already,
            // ignore it
            //
            if (_PathObjectInfo.ProviderName && 
                (wcscmp(_PathObjectInfo.ProviderName, bstrADsPath) == 0)) {
                hr = S_OK;
                break;
            }

            pszNamespace = new WCHAR[wcslen(bstrADsPath) + 2];      // ":" and \0
            if(!pszNamespace)
            {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            wcscpy(pszNamespace,bstrADsPath);
            wcscat(pszNamespace,L":");


            pPathnameProvider = NULL;
            hr = ADsGetObject(pszNamespace,
                              IID_IADsPathnameProvider,
                              (void**)&(pPathnameProvider));
            BAIL_ON_FAILURE(hr);

            if (pPathnameProvider) {
                if (m_pPathnameProvider) {
                    m_pPathnameProvider->Release();
                }
                m_pPathnameProvider = pPathnameProvider;
            }


            FreePathInfo(&_PathObjectInfo);
            _PathObjectInfo.ProviderName = AllocADsStr(bstrADsPath);
            if (_PathObjectInfo.ProviderName == NULL) {
                hr = E_OUTOFMEMORY;
                break;
            }

            hr = S_OK;
            break;

        case ADS_SETTYPE_SERVER:
            if (m_pPathnameProvider == NULL) {
                hr = E_ADS_BAD_PATHNAME;
                goto error;
            }
            if (_PathObjectInfo.ServerName) {
                FreeADsStr( _PathObjectInfo.ServerName);
                _PathObjectInfo.ServerName = NULL;
            }
            if (_PathObjectInfo.DisplayServerName) {
                FreeADsStr( _PathObjectInfo.DisplayServerName);
                _PathObjectInfo.DisplayServerName = NULL;
            }
            
            //
            // If the input path is not NULL, we'll set it to the new one. Or
            // else we will just ignore it 'cause it has been set to 0 earlier
            //
            if (bstrADsPath && (*bstrADsPath)) {
                _PathObjectInfo.ServerName = AllocADsStr(bstrADsPath);
                if (_PathObjectInfo.ServerName == NULL) {
                    hr = E_OUTOFMEMORY;
                    break;
                }

                _PathObjectInfo.DisplayServerName = AllocADsStr(bstrADsPath);
                if (_PathObjectInfo.DisplayServerName == NULL) {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            hr = S_OK;
            break;

        case ADS_SETTYPE_DN:
            {
                if (m_pPathnameProvider == NULL) {
                    hr = E_ADS_BAD_PATHNAME;
                    goto error;
                }

                //
                // Free the existing ones first
                //
                FreeObjInfoComponents(&_PathObjectInfo);
                _PathObjectInfo.dwPathType = 0;

                //
                // If the input path is not NULL, we'll set it to the new one. 
                // Or else we will just ignore it 'cause it has been set to 0 
                // earlier
                //
                if (bstrADsPath && (*bstrADsPath)) {
                    hr = m_pPathnameProvider->ParsePath(
                                                    bstrADsPath,
                                                    ADS_PARSE_DN, 
                                                    &_PathObjectInfo);
                    BAIL_ON_FAILURE(hr);
                }

                break;
            }

        default:
            hr = E_INVALIDARG;
            break;
    }

error:
    if (pszName) {
        FreeADsStr(pszName);
    }

    if(pszNamespace)
    {
        delete [] pszNamespace;
        pszNamespace = NULL;
    }



    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CPathname::SetDisplayType(
                    long lnSetType
                    )

/*++

Routine Description:

    Set the Display type of the Pathname object. It can either display the whole 
    string cn=xxx or just the value xxx.

Arguments:

    lnSetType - the passed in set type
            ADS_DISPLAY_FULL=1,
            ADS_DISPLAY_VALUE_ONLY=2

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    if (lnSetType == ADS_DISPLAY_FULL) {
        _fNamingAttribute = TRUE;
        RRETURN (S_OK);
    }
    else if (lnSetType == ADS_DISPLAY_VALUE_ONLY) {
        _fNamingAttribute = FALSE;
        RRETURN (S_OK);
    }
    RRETURN(E_INVALIDARG);
}


HRESULT CPathname::SetComponent(
                    DWORD cComponents,
                    BSTR *pbstrElement
                    )

/*++

Routine Description:

    Set an individual component in the pathname. For internal use only. 
    Not exposed.

Arguments:
    
    cComponents - the component number to be set
    pbstrElement - the return value

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    PWSTR szReturn = NULL;
    PATH_COMPONENT* pComponent = NULL;
    DWORD dwLength = 2; // for null termination and the equal sign

    if (_dwEscaped == ADS_ESCAPEDMODE_OFF_EX) {
        pComponent = _PathObjectInfo.ProvSpecComponentArray;
        if (pComponent[cComponents].szValue == NULL) {
            pComponent = _PathObjectInfo.ComponentArray;
        }
    }
    else if (_dwEscaped == ADS_ESCAPEDMODE_ON) {
        pComponent = _PathObjectInfo.DisplayComponentArray;
    }
    //
    // Either default or OFF, we do not turn on escaping
    //
    else {
        pComponent = _PathObjectInfo.ComponentArray;
    }

    //
    // allocate space for szReturn
    //
    if (pComponent[cComponents].szValue) {
        dwLength += wcslen(pComponent[cComponents].szValue);
    }
    if (pComponent[cComponents].szComponent) {
        dwLength += wcslen(pComponent[cComponents].szComponent);
    }
    szReturn = (PWSTR)AllocADsMem(sizeof(WCHAR) * dwLength);
    if (szReturn == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    szReturn[0] = NULL;

    if (_fNamingAttribute) {
        wcscat(szReturn, pComponent[cComponents].szComponent);
        if (pComponent[cComponents].szValue) {
            wcscat(szReturn,
                   TEXT("="));
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
    }
    else {
        if (pComponent[cComponents].szValue) {
            //
            // If value exist, only show display value
            //
            wcscat(szReturn,
                   pComponent[cComponents].szValue);
        }
        else {
            //
            // else value is only stored in Component
            //
            wcscat(szReturn,
                   pComponent[cComponents].szComponent);
        }
    }
    hr = ADsAllocString(szReturn, pbstrElement);

error:
    if (szReturn) {
        FreeADsMem(szReturn);
    }
    return hr;
}


STDMETHODIMP
CPathname::Retrieve(
            THIS_ long dwFormatType, 
            BSTR *pbstrADsPath
            )

/*++

Routine Description:

    Retrive the pathname as different formats

Arguments:

    dwFormatType - the input format type
    pbstrADsPath - the returned path

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;

    if (!pbstrADsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    switch (dwFormatType) {
        case ADS_FORMAT_SERVER:
            if (!_PathObjectInfo.DisplayServerName) {
                hr = E_ADS_BAD_PATHNAME;
                goto error;
            }
            hr = ADsAllocString(_PathObjectInfo.DisplayServerName, pbstrADsPath);
            break;

        case ADS_FORMAT_PROVIDER:
            if (!_PathObjectInfo.ProviderName) {
                hr = E_ADS_BAD_PATHNAME;    
                goto error;
            }
            hr = ADsAllocString(_PathObjectInfo.ProviderName, pbstrADsPath);
            break;
        default:
            //
            DWORD dwFlag = 0;
            if (_fNamingAttribute)
                dwFlag |= ADS_CONSTRUCT_NAMINGATTRIBUTE;
            hr = m_pPathnameProvider->ConstructPath(&_PathObjectInfo,
                                                    dwFormatType,
                                                    dwFlag,
                                                    _dwEscaped,
                                                    pbstrADsPath);
            BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CPathname::GetNumElements(
                    THIS_ long *pdwNumPathElements
                    )

/*++

Routine Description:

    Get the number of elements in the DN

Arguments:

    pdwNumPathElements - the number of elements

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;

    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    if (!pdwNumPathElements) {
        hr = E_INVALIDARG;
        goto error;
    }

    *pdwNumPathElements = _PathObjectInfo.NumComponents;
error:
    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CPathname::GetElement(
                THIS_ long dwElementIndex, 
                BSTR *pbstrElement
                )

/*++

Routine Description:

    Get a particular element using an index

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = E_FAIL;

    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    if (!pbstrElement) {
        hr = E_INVALIDARG;
        goto error;
    }

    if ((DWORD)dwElementIndex >= _PathObjectInfo.NumComponents) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_INDEX);
        goto error;
    }
    if (_PathObjectInfo.dwPathType != ADS_PATHTYPE_LEAFFIRST) {
        dwElementIndex = _PathObjectInfo.NumComponents - 1 - dwElementIndex;
    }
    hr = SetComponent(dwElementIndex,
                      pbstrElement);
error:
    RRETURN_EXP_IF_ERR(hr);
}




VOID MoveLastComponentToFront(
                    PPATH_OBJECTINFO pObjectInfo
                    )

/*++

Routine Description:

    Move the last component to the front. Used after adding leaf

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD cComponent;

    ADsAssert(pObjectInfo->NumComponents > 1);

    LPTSTR szComponentLast =
        pObjectInfo->ComponentArray[pObjectInfo->NumComponents-1].szComponent;
    LPTSTR szValueLast =
        pObjectInfo->ComponentArray[pObjectInfo->NumComponents-1].szValue;
    LPTSTR szDisplayComponentLast =
        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents-1].szComponent;
    LPTSTR szDisplayValueLast =
        pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents-1].szValue;
    LPTSTR szProvSpecComponentLast =
        pObjectInfo->ProvSpecComponentArray[pObjectInfo->NumComponents-1].szComponent;
    LPTSTR szProvSpecValueLast =
        pObjectInfo->ProvSpecComponentArray[pObjectInfo->NumComponents-1].szValue;

    for (cComponent=pObjectInfo->NumComponents-1;cComponent>=1;cComponent--) {
        pObjectInfo->ComponentArray[cComponent].szComponent =
                        pObjectInfo->ComponentArray[cComponent-1].szComponent;
        pObjectInfo->ComponentArray[cComponent].szValue =
                        pObjectInfo->ComponentArray[cComponent-1].szValue;
        pObjectInfo->DisplayComponentArray[cComponent].szComponent =
                        pObjectInfo->DisplayComponentArray[cComponent-1].szComponent;
        pObjectInfo->DisplayComponentArray[cComponent].szValue =
                        pObjectInfo->DisplayComponentArray[cComponent-1].szValue;
        pObjectInfo->ProvSpecComponentArray[cComponent].szComponent =
                        pObjectInfo->ProvSpecComponentArray[cComponent-1].szComponent;
        pObjectInfo->ProvSpecComponentArray[cComponent].szValue =
                        pObjectInfo->ProvSpecComponentArray[cComponent-1].szValue;
    }
    pObjectInfo->ComponentArray[0].szComponent = szComponentLast;
    pObjectInfo->ComponentArray[0].szValue = szValueLast;
    pObjectInfo->DisplayComponentArray[0].szComponent = szDisplayComponentLast;
    pObjectInfo->DisplayComponentArray[0].szValue = szDisplayValueLast;
    pObjectInfo->ProvSpecComponentArray[0].szComponent = szProvSpecComponentLast;
    pObjectInfo->ProvSpecComponentArray[0].szValue = szProvSpecValueLast;

    return;
}



HRESULT
RemoveFirstElement(
            PPATH_OBJECTINFO pObjectInfo
            )

/*++

Routine Description:

    Remove first element from the list

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD cComponent;

    if (pObjectInfo->NumComponents <= 0) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    FreeADsStr(pObjectInfo->ComponentArray[0].szComponent);
    FreeADsStr(pObjectInfo->ComponentArray[0].szValue);
    FreeADsStr(pObjectInfo->DisplayComponentArray[0].szComponent);
    FreeADsStr(pObjectInfo->DisplayComponentArray[0].szValue);
    if (pObjectInfo->ProvSpecComponentArray[0].szComponent)
        FreeADsStr(pObjectInfo->ProvSpecComponentArray[0].szComponent);
    if (pObjectInfo->ProvSpecComponentArray[0].szValue)
        FreeADsStr(pObjectInfo->ProvSpecComponentArray[0].szValue);

    for (cComponent = 0;cComponent < pObjectInfo->NumComponents - 1;cComponent++) {
        pObjectInfo->ComponentArray[cComponent].szComponent =
            pObjectInfo->ComponentArray[cComponent+1].szComponent;
        pObjectInfo->ComponentArray[cComponent].szValue =
            pObjectInfo->ComponentArray[cComponent+1].szValue;
        pObjectInfo->DisplayComponentArray[cComponent].szComponent =
            pObjectInfo->DisplayComponentArray[cComponent+1].szComponent;
        pObjectInfo->DisplayComponentArray[cComponent].szValue =
            pObjectInfo->DisplayComponentArray[cComponent+1].szValue;
        pObjectInfo->ProvSpecComponentArray[cComponent].szComponent =
            pObjectInfo->ProvSpecComponentArray[cComponent+1].szComponent;
        pObjectInfo->ProvSpecComponentArray[cComponent].szValue =
            pObjectInfo->ProvSpecComponentArray[cComponent+1].szValue;
    }
    pObjectInfo->ComponentArray[cComponent].szComponent = NULL;
    pObjectInfo->ComponentArray[cComponent].szValue = NULL;
    pObjectInfo->DisplayComponentArray[cComponent].szComponent = NULL;
    pObjectInfo->DisplayComponentArray[cComponent].szValue = NULL;
    pObjectInfo->ProvSpecComponentArray[cComponent].szComponent = NULL;
    pObjectInfo->ProvSpecComponentArray[cComponent].szValue = NULL;
    pObjectInfo->NumComponents--;

    RRETURN(S_OK);
}


STDMETHODIMP
CPathname::AddLeafElement(
                    THIS_ BSTR bstrLeafElement
                    )

/*++

Routine Description:

    Add a leaf element to the DN

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = E_FAIL;
    DWORD NumComponents;
    BOOL fStartAllocation = FALSE;

    PATH_OBJECTINFO ObjectInfoLocal;

    memset(&ObjectInfoLocal, 0, sizeof(PATH_OBJECTINFO));
    if ((bstrLeafElement == NULL) || ((*bstrLeafElement) == NULL)) {
        hr = E_INVALIDARG;
        goto error;
    }

    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    //
    // MAX size limitation exist in parser.cxx, so, it's not
    // worth to implement the inc in size dynamically
    //
    if ((_PathObjectInfo.NumComponents+1) > MAXCOMPONENTS ) {
        hr = E_NOTIMPL;
        goto error;
    }

    hr = m_pPathnameProvider->ParsePath(
                                bstrLeafElement,
                                ADS_PARSE_COMPONENT, 
                                (PPATH_OBJECTINFO)&ObjectInfoLocal
                                );
    BAIL_ON_FAILURE(hr);


    NumComponents = _PathObjectInfo.NumComponents;
    fStartAllocation = TRUE;

    if (ObjectInfoLocal.ComponentArray[0].szComponent) {
        _PathObjectInfo.ComponentArray[NumComponents].szComponent =
            AllocADsStr(ObjectInfoLocal.ComponentArray[0].szComponent);
        if (_PathObjectInfo.ComponentArray[NumComponents].szComponent == NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (ObjectInfoLocal.ComponentArray[0].szValue) {
        _PathObjectInfo.ComponentArray[NumComponents].szValue =
            AllocADsStr(ObjectInfoLocal.ComponentArray[0].szValue);
        if (_PathObjectInfo.ComponentArray[NumComponents].szValue== NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (ObjectInfoLocal.DisplayComponentArray[0].szComponent) {
        _PathObjectInfo.DisplayComponentArray[NumComponents].szComponent =
            AllocADsStr(ObjectInfoLocal.DisplayComponentArray[0].szComponent);
        if (_PathObjectInfo.DisplayComponentArray[NumComponents].szComponent == NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (ObjectInfoLocal.DisplayComponentArray[0].szValue) {
        _PathObjectInfo.DisplayComponentArray[NumComponents].szValue=
            AllocADsStr(ObjectInfoLocal.DisplayComponentArray[0].szValue);
        if (_PathObjectInfo.DisplayComponentArray[NumComponents].szValue== NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    if (ObjectInfoLocal.ProvSpecComponentArray[0].szComponent) {
        _PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent =
            AllocADsStr(ObjectInfoLocal.ProvSpecComponentArray[0].szComponent);
        if (_PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent == NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (ObjectInfoLocal.ProvSpecComponentArray[0].szValue) {
        _PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue =
            AllocADsStr(ObjectInfoLocal.ProvSpecComponentArray[0].szValue);
        if (_PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue== NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }


    _PathObjectInfo.NumComponents++;

    if (_PathObjectInfo.dwPathType == ADS_PATHTYPE_LEAFFIRST) {
        MoveLastComponentToFront(&_PathObjectInfo);
    }

    FreePathInfo(&ObjectInfoLocal);
    RRETURN(hr);
error:
    FreePathInfo(&ObjectInfoLocal);
    if (fStartAllocation) {
        if (_PathObjectInfo.ComponentArray[NumComponents].szComponent) {
            FreeADsStr(_PathObjectInfo.ComponentArray[NumComponents].szComponent);
            _PathObjectInfo.ComponentArray[NumComponents].szComponent = NULL;
        }
        if (_PathObjectInfo.ComponentArray[NumComponents].szValue) {
            FreeADsStr(_PathObjectInfo.ComponentArray[NumComponents].szValue);
            _PathObjectInfo.ComponentArray[NumComponents].szValue = NULL;
        }
        if (_PathObjectInfo.DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(_PathObjectInfo.DisplayComponentArray[NumComponents].szComponent);
            _PathObjectInfo.DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (_PathObjectInfo.DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(_PathObjectInfo.DisplayComponentArray[NumComponents].szValue);
            _PathObjectInfo.DisplayComponentArray[NumComponents].szValue = NULL;
        }
        if (_PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent) {
            FreeADsStr(_PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent);
            _PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent = NULL;
        }
        if (_PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue) {
            FreeADsStr(_PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue);
            _PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue = NULL;
        }
    }
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CPathname::RemoveLeafElement(void)

/*++

Routine Description:

    Remove the leaf element from the DN

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = E_FAIL;
    DWORD NumComponents;

    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    if (_PathObjectInfo.dwPathType == ADS_PATHTYPE_LEAFFIRST) {
        hr = RemoveFirstElement(&_PathObjectInfo);
    }
    else {
        if (_PathObjectInfo.NumComponents > 0) {
            _PathObjectInfo.NumComponents--;
            NumComponents = _PathObjectInfo.NumComponents;

            FreeADsStr(_PathObjectInfo.ComponentArray[NumComponents].szComponent);
            FreeADsStr(_PathObjectInfo.ComponentArray[NumComponents].szValue);
            FreeADsStr(_PathObjectInfo.DisplayComponentArray[NumComponents].szComponent);
            FreeADsStr(_PathObjectInfo.DisplayComponentArray[NumComponents].szValue);
            if (_PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent)
                FreeADsStr(_PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent);
            if (_PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue)
                FreeADsStr(_PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue);

            _PathObjectInfo.ComponentArray[NumComponents].szComponent = NULL;
            _PathObjectInfo.ComponentArray[NumComponents].szValue = NULL;
            _PathObjectInfo.DisplayComponentArray[NumComponents].szComponent = NULL;
            _PathObjectInfo.DisplayComponentArray[NumComponents].szValue = NULL;
            _PathObjectInfo.ProvSpecComponentArray[NumComponents].szComponent = NULL;
            _PathObjectInfo.ProvSpecComponentArray[NumComponents].szValue = NULL;
            hr = S_OK;
        }
    }
error:
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CPathname::CopyPath(THIS_ IDispatch **ppAdsPath)

/*++

Routine Description:

    Copy the pathname object and return a pointer to the new one

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = E_FAIL;
    IADsPathname *pPathname = NULL;
    BSTR bstrResult = NULL;
    DWORD dwLength;

    long lNameType;                 // Storage for old values
    DWORD dwEscaped;
    BOOL fValueChanged = FALSE;     // indicate whether value has been changed
    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    if (!ppAdsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    //
    // Storing the old values
    //
    dwEscaped = _dwEscaped;
    if (_fNamingAttribute) {
        lNameType = ADS_DISPLAY_FULL;
    }
    else {
        lNameType = ADS_DISPLAY_VALUE_ONLY;
    }

    //
    // Setting the type to 'show all' for retrieval
    //
    fValueChanged = TRUE;
    hr = SetDisplayType(ADS_DISPLAY_FULL);
    BAIL_ON_FAILURE(hr);

    hr = put_EscapedMode(ADS_ESCAPEDMODE_DEFAULT);
    BAIL_ON_FAILURE(hr);

    //
    // Retrieve path
    //
    hr = Retrieve(ADS_FORMAT_WINDOWS, &bstrResult);
    BAIL_ON_FAILURE(hr);

    //
    // This is a workaround for the namespace path that we return. We are 
    // currently getting 'LDAP://' back instead of 'LDAP:'. There are users who 
    // are dependent on this and thus we cannot change it to return 'LDAP://'.
    // The code below takes out the '//' if the path trails with '://' so that
    // the path is settable.
    //
    dwLength = wcslen(bstrResult);
    if (wcscmp((PWSTR)(&bstrResult[dwLength-3]),L"://") == 0) {
        bstrResult[dwLength-2] = NULL;
    }

    hr = CoCreateInstance(
                CLSID_Pathname,
                NULL,
                CLSCTX_ALL,
                IID_IADsPathname,
                (void**)&pPathname
                );
    BAIL_ON_FAILURE(hr);

    hr = pPathname->Set(bstrResult, ADS_SETTYPE_FULL);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->SetDisplayType(lNameType);
    BAIL_ON_FAILURE(hr);

    hr = pPathname->put_EscapedMode(dwEscaped);
    BAIL_ON_FAILURE(hr);

    *ppAdsPath = (IDispatch*)pPathname;
    pPathname = NULL;

error:
    if (fValueChanged) {
        SetDisplayType(lNameType);
        put_EscapedMode(dwEscaped);
    }
    if (pPathname) {
        pPathname->Release();
    }
    if (bstrResult) {
        SysFreeString(bstrResult);     
    }
    RRETURN_EXP_IF_ERR(hr);
}


void
CPathname::FreeObjInfoComponents(
                    PATH_OBJECTINFO *pObjectInfo
                    )

/*++

Routine Description:

    Free all the compoents in an objinfo

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;

    while (pObjectInfo->NumComponents > 0) {
        pObjectInfo->NumComponents--;
        NumComponents = pObjectInfo->NumComponents;

        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szComponent);
            pObjectInfo->ComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szValue);
            pObjectInfo->ComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(
                pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            pObjectInfo->DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            pObjectInfo->DisplayComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->ProvSpecComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ProvSpecComponentArray[NumComponents].szComponent);
            pObjectInfo->ProvSpecComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ProvSpecComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ProvSpecComponentArray[NumComponents].szValue);
            pObjectInfo->ProvSpecComponentArray[NumComponents].szValue = NULL;
        }
    }
}

void
CPathname::FreePathInfo(
                PPATH_OBJECTINFO pPathObjectInfo                
                )
{
    if (pPathObjectInfo->ProviderName) {
        FreeADsStr(pPathObjectInfo->ProviderName);
        pPathObjectInfo->ProviderName = NULL;
    }
    if (pPathObjectInfo->ServerName) {
        FreeADsStr(pPathObjectInfo->ServerName);
        pPathObjectInfo->ServerName = NULL;
    }
    if (pPathObjectInfo->DisplayServerName) {
        FreeADsStr(pPathObjectInfo->DisplayServerName);
        pPathObjectInfo->DisplayServerName = NULL;
    }
    FreeObjInfoComponents(pPathObjectInfo);
    pPathObjectInfo->dwPathType = ADS_PATHTYPE_ROOTFIRST;
}

HRESULT
CPathname::put_EscapedMode(
    long lEscaped
    )
{
    // parameter validation
    if(lEscaped < ADS_ESCAPEDMODE_DEFAULT || lEscaped > ADS_ESCAPEDMODE_OFF_EX)
    {
        return E_ADS_BAD_PARAMETER;
    }    

    _dwEscaped = lEscaped;
    return S_OK;
}

HRESULT
CPathname::get_EscapedMode(
    long *plEscaped
    )
{
    *plEscaped = _dwEscaped;
    return S_OK;
}

//+---------------------------------------------------------------------------
// Function:    CPathname::GetEscapedElement
//
// Synopsis:    Takes the input string, escapes it assuming it is an RDN
//            and returns the output.
//              The first cut will be empty as in input string = output
//            string. Once the code to do this is added please change this
//            comment appropriately.
//
// Arguments: lnReserved (= 0 for now),
//
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-10-98   AjayR         Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPathname::GetEscapedElement(
    LONG lnReserved,
    BSTR bstrInStr,
    BSTR* pbstrOutStr
    )
{
    HRESULT hr = S_OK;

    if (m_pPathnameProvider == NULL) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }

    hr = m_pPathnameProvider->GetEscapedElement(lnReserved,
                                                bstrInStr,
                                                pbstrOutStr);
error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\openobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  openobj.cxx
//
//  Contents:  ADs Wrapper Function to open an Active Directory object
//
//
//  History:   11-15-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop

extern PROUTER_ENTRY g_pRouterHead;
extern CRITICAL_SECTION g_csRouterHeadCritSect;

//+---------------------------------------------------------------------------
//  Function:  ADsOpenObject
//
//  Synopsis:
//
//  Arguments:  [LPWSTR lpszPathName]
//              [LPWSTR lpszUserName]
//              [LPWSTR lpszPassword]
//              [REFIID riid]
//              [void FAR * FAR * ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    07-12-96  krishnag Created.
//
//----------------------------------------------------------------------------
HRESULT
ADsOpenObject(
    LPCWSTR lpszPathName,
    LPCWSTR lpszUserName,
    LPCWSTR lpszPassword,
    DWORD  dwReserved,
    REFIID riid,
    void FAR * FAR * ppObject
    )
{
    IADsOpenDSObject FAR * pNamespace = NULL;
    IDispatch FAR *        pDispatch  = NULL;
    HRESULT hr = S_OK;
    GUID  NamespaceClsid;
    WCHAR* lpszProgId = NULL;

    if(!lpszPathName)
    {
        return E_FAIL;
    }
    
    lpszProgId = new WCHAR[wcslen(lpszPathName) + 1];
    if(!lpszProgId)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = CopyADsProgId(
               (LPWSTR)lpszPathName,
               lpszProgId
               );
    BAIL_ON_FAILURE( hr );

    hr = ADsGetCLSIDFromProgID(
            lpszProgId,
            &NamespaceClsid
            );
    BAIL_ON_FAILURE( hr );

    hr = CoCreateInstance(
                NamespaceClsid,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsOpenDSObject,
                (void **)&pNamespace
                );
    BAIL_ON_FAILURE( hr );

    hr = pNamespace->OpenDSObject(
                (LPWSTR)lpszPathName,
                (LPWSTR)lpszUserName,
                (LPWSTR)lpszPassword,
                (long)dwReserved,
                &pDispatch
                );
    BAIL_ON_FAILURE( hr );


    hr = pDispatch->QueryInterface(
                        riid,
                        ppObject
                        );

error:

    if( pDispatch )	{
        pDispatch->Release();
	}

    if( pNamespace ) {
        pNamespace->Release();
	}

    if(lpszProgId)
    {
        delete [] lpszProgId;
        lpszProgId = NULL;
    }

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//  Function:   CopyADsProgId
//
//  Synopsis:
//
//
//  Arguments:  [LPWSTR Path]
//              [LPWSTR szProgId]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    09-16-96  krishnag Created
//
//----------------------------------------------------------------------------
HRESULT
CopyADsProgId(
    LPWSTR Path,
    LPWSTR szProgId
    )
{
    LPWSTR pChar = NULL;

	if( !Path )
        return E_FAIL;

    pChar = szProgId;

    if( *Path == L'@' ) {
        while (*Path != L'!' &&  *Path != L'\0') {
            *pChar = *Path;
            pChar++;
            Path++;
        }

		if( *Path == L'\0' ) {
			//
			// couldn't find the terminating ! for the ProgID
			//
            return( E_FAIL );
		}
    }else {
        while (*Path != L':' && *Path != L'\0') {
            *pChar = *Path;
            pChar++;
            Path++;
        }

        if( *Path == L'\0' ) {
			//
			// couldn't find the terminating : for the ProgID
			//
            return( E_FAIL );
		}
    }

	*pChar = L'\0';
    return S_OK;
}


HRESULT
ADsGetCLSIDFromProgID(
    LPWSTR pszProgId,
    GUID * pClsid
    )
{

    //
    // Make sure the router has been initialized
    //
    EnterCriticalSection(&g_csRouterHeadCritSect);
    if (!g_pRouterHead) {
        g_pRouterHead = InitializeRouter();
    }
    LeaveCriticalSection(&g_csRouterHeadCritSect);


    PROUTER_ENTRY lpRouter = g_pRouterHead;

    while (lpRouter){

        if (!wcscmp(lpRouter->szProviderProgId, pszProgId)) {
            memcpy(pClsid, lpRouter->pNamespaceClsid, sizeof(CLSID));
            RRETURN(S_OK);

        }
        else if (!wcscmp(lpRouter->szAliases, pszProgId)) {

            //
            // Check Aliases
            //

            memcpy(pClsid, lpRouter->pNamespaceClsid, sizeof(CLSID));
            RRETURN(S_OK);
        }

        lpRouter = lpRouter->pNext;

    }

    RRETURN( E_ADS_BAD_PATHNAME );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\pathcf.cxx ===
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CPathnameCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CPathnameCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPathname::CreatePathname(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\router.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for ADs.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop


LPCWSTR lpszTopLevel = L"SOFTWARE\\Microsoft\\ADs";
LPCWSTR lpszProviders = L"Providers";

PROUTER_ENTRY
InitializeRouter()
{
    HKEY hTopLevelKey = NULL;
    HKEY hMapKey = NULL;
    HKEY hProviderKey = NULL;

    DWORD dwIndex = 0;
    WCHAR lpszProvider[MAX_PATH];
    DWORD dwchProvider = 0;
    WCHAR lpszNamespace[MAX_PATH];
    WCHAR lpszAliases[MAX_PATH];
    DWORD dwchNamespace = 0;
    DWORD dwchAliases = 0;
    PROUTER_ENTRY pRouterHead = NULL, pRouterEntry = NULL;
    LPCLSID pclsid = NULL;
    HRESULT hr;


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     lpszTopLevel,
                     0,
                     KEY_READ,
                     &hTopLevelKey
                     ) != ERROR_SUCCESS)
    {
        // must succeed
        goto CleanupAndExit;
    }

    if (RegOpenKeyEx(hTopLevelKey,
                     lpszProviders,
                     0,
                     KEY_READ,
                     &hMapKey
                     ) != ERROR_SUCCESS)

    {
        // must succeed; at least one provider from ADSI
        goto CleanupAndExit;

    }

    memset(lpszProvider, 0, sizeof(lpszProvider));
    
    //
    // Size has to be in number of TCHARS not in bytes.
    //
    dwchProvider = sizeof(lpszProvider)/sizeof(WCHAR);

    while(RegEnumKeyEx(hMapKey,
                     dwIndex++,  // + index even if last 1 bail out in mid loop
                     lpszProvider,
                     &dwchProvider,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hMapKey,
                         lpszProvider,
                         0,
                         KEY_READ,
                         &hProviderKey
                         ) != ERROR_SUCCESS)
        {
            //
            // if cannot read registry of 1 provider, continue with others;
            // especially since providers can be written outside ADSI
            //

            memset(lpszProvider, 0, sizeof(lpszProvider));
            dwchProvider = sizeof(lpszProvider)/sizeof(WCHAR);
            continue;
        }

        memset(lpszNamespace, 0, sizeof(lpszNamespace));
        dwchNamespace = sizeof(lpszNamespace);

        if (RegQueryValueEx(hProviderKey,
                            NULL,
                            NULL,
                            NULL,
                            (LPBYTE) lpszNamespace,
                            &dwchNamespace
                            ) != ERROR_SUCCESS)
        {
            //
            // if cannot read registry of 1 provider, continue with others;
            // especially since providers can be written outside ADSI
            //

            RegCloseKey(hProviderKey);
            hProviderKey = NULL;
            memset(lpszProvider, 0, sizeof(lpszProvider));
            dwchProvider = sizeof(lpszProvider)/sizeof(WCHAR);
            continue;
        }


        //
        // If Aliases value name is defined, get the values
        //

        memset(lpszAliases, 0, sizeof(lpszAliases));
        dwchAliases = sizeof(lpszAliases);

        RegQueryValueEx(hProviderKey,
                            L"Aliases",
                            NULL,
                            NULL,
                            (LPBYTE) lpszAliases,
                            &dwchAliases
                            );

        RegCloseKey(hProviderKey);
        hProviderKey = NULL;

        //
        // Generate CLSID from the ProgID
        //

        pclsid = (LPCLSID)LocalAlloc(LPTR,
                                     sizeof(CLSID));
        if (!pclsid) {

            //
            // if cannot read registry of 1 provider, continue with others;
            // especially since providers can be written outside ADSI
            //
            memset(lpszProvider, 0, sizeof(lpszProvider));
            dwchProvider = sizeof(lpszProvider)/sizeof(WCHAR);
            continue;
        }

        hr = CLSIDFromProgID(lpszNamespace, pclsid);

        if (FAILED(hr)) {
            LocalFree(pclsid);
        } else {
            if (pRouterEntry = (PROUTER_ENTRY)LocalAlloc(LPTR,
                                                       sizeof(ROUTER_ENTRY))){
                wcscpy(pRouterEntry->szProviderProgId, lpszProvider);
                wcscpy(pRouterEntry->szNamespaceProgId, lpszNamespace);
                wcscpy(pRouterEntry->szAliases, lpszAliases);
                pRouterEntry->pNamespaceClsid = pclsid;
                pRouterEntry->pNext = pRouterHead;
                pRouterHead = pRouterEntry;
            }
        }

        memset(lpszProvider, 0, sizeof(lpszProvider));
        dwchProvider = sizeof(lpszProvider)/sizeof(WCHAR);
    }

CleanupAndExit:
    if (hProviderKey) {
        RegCloseKey(hProviderKey);
    }
    if (hMapKey) {
        RegCloseKey(hMapKey);
    }

    if (hTopLevelKey) {
        RegCloseKey(hTopLevelKey);
    }

    return(pRouterHead);
}

void 
CleanupRouter(
    PROUTER_ENTRY pRouterHead
    )
{

    PROUTER_ENTRY pRouter = pRouterHead, pRouterNext = NULL;

    while (pRouter) {
        pRouterNext = pRouter->pNext;
        if (pRouter->pNamespaceClsid) {
            LocalFree(pRouter->pNamespaceClsid);
        }
        LocalFree(pRouter);

        pRouter = pRouterNext;
    }

    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\row.cxx ===
// Row.cxx : Implementation of CRow
#include "oleds.hxx"

#if (!defined(BUILD_FOR_NT40))
#include "atl.h"
#include "row.hxx"
#include "cstream.h"

HRESULT PackLargeInteger(LARGE_INTEGER *plargeint, PVARIANT pVarDestObject);
#define ARRAYSIZE(x)    sizeof((x))/sizeof((x)[0])

extern const WCHAR g_cwszSpecialColumnURL[] = L"RESOURCE_ABSOLUTE_PARSENAME";
extern const WCHAR g_cwszAdsPath[]                      = L"ADsPath";

//----------------------------------------------------------------------------
// Note on m_fIsTearOff and m_fGetColInfoFromRowset
//
// m_fIsTearOff is set to TRUE when the row is a tear-off from a rowset from 
// the client's point of view i.e, the client created a rowset and got a row
// off the rowset. Thus, a call to GetSourceRowset returns a rowset interface
// pointer only if m_fIsTearOff is TRUE. 
// m_fGetColInfoFromRowset is set to TRUE if the row should get the column
// info and the column values from the rowset. If FALSE, this information is 
// obtained through ADSI calls.
//
// There are 4 cases of interest.
//
// 1) The row is obtained directly from a command object using a query which
// doesn't specify "SELECT *" i.e, not all attributes are requested OR the row
// is obtained directly from a session object (defaults to no "SELECT *"). This 
// is implemented by actually creating a rowset and getting its first row.
// In this case m_fIsTearOff is FALSE, m_fGetColInfoFromRowset is
// TRUE and m_pSourceRowset is non-NULL. Thus, if the client called 
// GetSourceRowset on the row, no interface pointer is returned. However, there
// is a rowset backing up this row and this is used for getting column info and
// column values. 
//
// 2) The row is obtained directly from a command object using SELECT *
// as the query. In this case, m_fIsTearOff is FALSE, m_fGetColInfoFromRowset 
// is FALSE and m_pSourceRowset is non-NULL. Though m_pSourceRowset is 
// non-NULL, it is not used.
// 
// An alternative scheme would be to to call CSession::Bind directly in this 
// case which would obviate the need for keeping a rowset around.
//
// 3) The row is obtained from a rowset using GetRowFromHROW. In this case,
// m_fIsTearOff is TRUE. However, if the rowset was created from a command 
// object using a SELECT * query, then m_fGetColInfoFromRowset is FALSE.
// Otherwise, fGetColInfoFromRowset is TRUE. m_pSourceRowset is non-NULL.
//
// 4) The row is created using IBindResource::Bind. In this case, m_fIsTearOff 
// is FALSE, m_fGetColInfoFromRowset is FALSE and m_pSourceRowset is NULL.
//
// The following table summarizes the above 4 cases.
//
// m_fIsTearOff m_fGetColInfoFromRowset             Description
// ------------ -----------------------             ------------
//     T                T                   GetRowFromHROW, not SELECT *
//     F                F                   Row obtained from command object
//                                          using SELECT * OR 
//                                          Row got using IBindResource::Bind
//     T                F                   GetRowFromHROW, SELECT *
//     F                T                   Row obtained from command object
//                                          without a SELECT * query OR
//                                          Row obtained from session object 
//
// Every row object has a special URL column. The URL column (and any row
// columns that are not in the source rowset) should appear after all the
// source rowset columns.
//
// ADsPath needs to be treated as a special case. If m_fGetColInfoFromRowset
// is TRUE, then we will get the ADsPath just by using the rowset's copy
// of the column. However, if m_fGetColInfoFromRowset is FALSE, then
// the row should return ADsPath if it is a tear-off AND ADsPath is one of the 
// columns of the source rowset. This is required by the OLEDB spec
// since the row's columns should be a superset of the rowset's columns. 
// Currently, the only case where this would happen is a SELECT * query that
// requests a rowset and then a row is obtained from that rowset. In this case,
// the row adds ADsPath to the columns it returns. To be consistent, if a row  
// is obtained from a command object using a SELECT * query OR the row is
// obtained using IBindResource::Bind(), then ADsPath is added to the columns
// returned by the row.
//
//----------------------------------------------------------------------------
// 

//////////////////////////////////////////////////////////////////////////////
//helper functions
//
//+---------------------------------------------------------------------------
//
//  Function:  GetIDataConvert
//
//  Synopsis: Create OLE DB conversion library and store it in static.
//
//  Arguments:
//              [out] pointer to pointer to IDataConvert
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
HRESULT GetIDataConvert(IDataConvert** ppDataConvert)
{
    HRESULT                                                 hr = S_OK;
    auto_rel<IDataConvert> pIDataConvert;
    auto_rel<IDCInfo>                               pIDCInfo;
    DCINFO          rgInfo[] = {{DCINFOTYPE_VERSION, {VT_UI4, 0, 0, 0, 0x0200}}};
    
    ADsAssert(ppDataConvert);
    
    hr = CoCreateInstance(CLSID_OLEDB_CONVERSIONLIBRARY,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IDataConvert,
            (void **) &pIDataConvert);
    if (FAILED(hr))
        goto exit;
        
    // Tell data convert our OLE DB version
    hr = pIDataConvert->QueryInterface(IID_IDCInfo,
            (void **)&pIDCInfo);
    if( SUCCEEDED(hr) )
        hr = pIDCInfo->SetInfo(ARRAYSIZE(rgInfo), rgInfo);
        
    // auto_rel operator = does the release
    if( FAILED(hr) )
            pIDataConvert = NULL;
    
    if (pIDataConvert)
        pIDataConvert->AddRef();
    *ppDataConvert = pIDataConvert;

exit:
    RRETURN(hr);
}

/////////////////////////////////////////////////////////////////////////////
//Internal methods
//

//+---------------------------------------------------------------------------
//
//  Function: CRow::Initialize
//
//  Synopsis: Initializes a directly bound CRow object as opposed to a row
//            created from a rowset. See the other overloaded Initialize below.
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
STDMETHODIMP CRow::Initialize(PWSTR                     pwszURL,
                              IUnknown              *pSession,
                              IAuthenticate *pAuthenticate,
                              DWORD                 dwBindFlags,
                              BOOL                  fIsTearOff,
                              BOOL                  fGetColInfoFromRowset,
                              CCredentials          *pSessCreds,
                              bool                  fBind)
{
    HRESULT                 hr = S_OK;
    auto_leave              cs_auto_leave(m_autocs);
    DWORD                   fAuthFlags;
 
    //Make sure we have a valid session.
    ADsAssert(pSession);
    
	TRYBLOCK
    
		cs_auto_leave.EnterCriticalSection();
        
        m_dwBindFlags = dwBindFlags;
        m_objURL = pwszURL;
        m_pSession = pSession;
        m_pSession->AddRef();
        
        if (!fBind) //no need to bind. Just return.
            RRETURN(S_OK);

        m_fIsTearOff = fIsTearOff;
        m_fGetColInfoFromRowset = fGetColInfoFromRowset;
   
        // Any changes made below should also be made in the overloaded
        // Initialize() below for consistency.

        // Fix for 351040. Use explicit credentials first, then credentials in
        // session object, then default credentials. Credential in session
        // object will be the default credentials if we come in through the
        // binder. But, if IBindResource is obtained from the session object,
        // then the credentials may not be the default credentials. From ADO,
        // using Open without specifying an active connection causes the 
        // binder to be invoked. If an active connection is specified, then 
        // IBindResource is obtained from the session object.
       
        if(pAuthenticate)
        {
            hr = GetCredentialsFromIAuthenticate(pAuthenticate, 
                     m_objCredentials);
            if(FAILED(hr))
               BAIL_ON_FAILURE(E_INVALIDARG);

            fAuthFlags = m_objCredentials.GetAuthFlags();
            m_objCredentials.SetAuthFlags(fAuthFlags |
                        ADS_SECURE_AUTHENTICATION);

            hr = GetDSInterface(
                pwszURL,
                m_objCredentials,
                IID_IADs,
                (void **)&m_pADsObj
                );
        }

        if( (!pAuthenticate) || (INVALID_CREDENTIALS_ERROR(hr)) )
        // try credentials in session object
        {
            m_objCredentials = *pSessCreds;

            hr = GetDSInterface(
                pwszURL,
                m_objCredentials,
                IID_IADs,
                (void **)&m_pADsObj
                );
        }

        if(INVALID_CREDENTIALS_ERROR(hr))
        // try default credentials
        {
            CCredentials TmpCreds; // default credentials

            m_objCredentials = TmpCreds;
            fAuthFlags = m_objCredentials.GetAuthFlags();
            m_objCredentials.SetAuthFlags(fAuthFlags | 
                        ADS_SECURE_AUTHENTICATION);                        

            hr = GetDSInterface(
                pwszURL,
                m_objCredentials,
                IID_IADs,
                (void **)&m_pADsObj
                );
        }

        BAIL_ON_FAILURE(hr);
        
        //Get the Schema Root and store it in m_bstrSchemaRoot
        hr = GetSchemaRoot();
        BAIL_ON_FAILURE(hr);
        
        // Get the data. without the GetRestrictedColunInfo will no return column information.
        hr = m_pADsObj->GetInfo();
        BAIL_ON_FAILURE(hr);
        
	CATCHBLOCKBAIL(hr)    

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::Initialize
//
//  Synopsis: Initializes a row object that represents a row in a rowset as
//                        as opposed to a directly bound row object.
//            See the other overloaded Initialize above.
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
STDMETHODIMP CRow::Initialize(
                              PWSTR                   pwszURL,
                              IUnknown                *pSession,
                              IUnknown                *pSourceRowset,
                              HROW                    hRow,
                              PWSTR                   pwszUser,
                              PWSTR                   pwszPassword,
                              DWORD                   dwBindFlags,
                              BOOL                    fIsTearOff,
                              BOOL                    fGetColInfoFromRowset,
                              CRowProvider            *pRowProvider
                              )
{
    HRESULT                                 hr = S_OK;
    auto_leave                              cs_auto_leave(m_autocs);
    DWORD                                   fAuthFlags;
    auto_rel<IRowset>               pRowset;
    auto_rel<IColumnsInfo>  pRowsetColumnsInfo;
    
    //Make sure we have valid arguments
    ADsAssert(pSession);
    ADsAssert(pSourceRowset);
    ADsAssert(hRow != DB_NULL_HROW);
    
	TRYBLOCK
    
		cs_auto_leave.EnterCriticalSection();
        
        if (pRowProvider == NULL)
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        
        m_pRowProvider = pRowProvider;
        m_dwBindFlags = dwBindFlags;
        m_pSession = pSession;
        m_pSession->AddRef();
        m_pSourceRowset = pSourceRowset;
        m_hRow = hRow;
        m_fIsTearOff = fIsTearOff;
        m_fGetColInfoFromRowset = fGetColInfoFromRowset; 
        pSourceRowset->AddRef();
        
        //Get IRowset pointer
        hr = pSourceRowset->QueryInterface(__uuidof(IRowset),
            (void **)&pRowset);
        BAIL_ON_FAILURE(hr);
        
        //Get Rowset columns info and store it. Spec says a row's columns
        //are always a superset of those of the source rowset. To make
        //sure we return proper columns info from row object,
        //we need the rowset's column info.
        hr = pSourceRowset->QueryInterface(
            __uuidof(IColumnsInfo),
            (void **)&pRowsetColumnsInfo);
        BAIL_ON_FAILURE(hr);
        hr = pRowsetColumnsInfo->GetColumnInfo(
            &m_cSourceRowsetColumns,
            &m_pSourceRowsetColumnInfo,
            &m_pSourceRowsetStringsBuffer);
        BAIL_ON_FAILURE(hr);
        
        //Get username, password and authFlags from Credentials.
        hr = m_objCredentials.SetUserName(pwszUser);
        BAIL_ON_FAILURE(hr);
        hr = m_objCredentials.SetPassword(pwszPassword);
        BAIL_ON_FAILURE(hr);
        
        //Store the URL and AddRef row handle.
        m_objURL = pwszURL;
        hr = pRowset->AddRefRows(1, &m_hRow, NULL, NULL);
        BAIL_ON_FAILURE(hr);

        //check  if the column info is to be obtained thruogh ADSI
        if( !fGetColInfoFromRowset )
        {
             // code below should be consistent with the Initialize() call
             // (overloaded function above) used for direct binding

             DWORD fAuthFlags = m_objCredentials.GetAuthFlags();
             m_objCredentials.SetAuthFlags(fAuthFlags | 
                                           ADS_SECURE_AUTHENTICATION);

             hr = GetDSInterface(
                  pwszURL,
                  m_objCredentials,
                  IID_IADs,
                  (void **)&m_pADsObj
                  );

             BAIL_ON_FAILURE(hr);

            //Get the Schema Root and store it in m_bstrSchemaRoot
            hr = GetSchemaRoot();
            BAIL_ON_FAILURE(hr);

            // Get the data. without it GetRestrictedColunInfo will not return 
            // column info.
            hr = m_pADsObj->GetInfo();
            BAIL_ON_FAILURE(hr);            
        } 
	
	CATCHBLOCKBAIL(hr)

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::fMatchesMaskCriteria
//
//  Synopsis: Tells if the given column name matches any mask criteria
//            for column ids.
//
//  Returns:  true if matches, false otherwise
//----------------------------------------------------------------------------
bool CRow::fMatchesMaskCriteria(PWCHAR pwszColumnName,
                                ULONG cColumnIDMasks,
                                const DBID rgColumnIDMasks[  ])
{
    //if there are no masks, the name is a match.
    if (cColumnIDMasks == 0)
        return true;

    // if the name is a NULL string the name is not a match.
    if (NULL == pwszColumnName)
        return false;
    
    ULONG ulStrLen = 0;
    for (int j = 0; j < cColumnIDMasks; j++)
    {
        if( (rgColumnIDMasks[j].eKind != DBKIND_NAME) ||
            (NULL == rgColumnIDMasks[j].uName.pwszName) )
            continue;

        ulStrLen = wcslen(rgColumnIDMasks[j].uName.pwszName);
        if (_wcsnicmp(  rgColumnIDMasks[j].uName.pwszName,
            pwszColumnName,
            ulStrLen ) == 0)
        {
            // Matches criterion
            return true;
        }
    }
    //doesn't match.
    return false;
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::fMatchesMaskCriteria (OVERLOADED)
//
//  Synopsis: Tells if the given column id matches any mask criteria
//            for column ids.
//
//  Returns:  true if matches, false otherwise
//----------------------------------------------------------------------------
bool CRow::fMatchesMaskCriteria(DBID columnid,
                                ULONG cColumnIDMasks,
                                const DBID rgColumnIDMasks[  ])
{
    //if there are no masks, the name is a match.
    if (cColumnIDMasks == 0)
        return true;
    
    ULONG ulStrLen = 0;
    for (int j = 0; j < cColumnIDMasks; j++)
    {
        if (TRUE == CompareDBIDs(&columnid, &rgColumnIDMasks[j]))
        {
            // Matches criterion
            return true;
        }
    }
    //doesn't match.
    return false;
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::GetSchemaAttributes
//
//  Synopsis: Gets MultiValued and MaxRange Attributes of an ADS Property.
//                        Any of these can be NULL indicating the caller is not interested
//            in getting the attribute.
//
//  Returns:  HRESULT
//----------------------------------------------------------------------------
HRESULT CRow::GetSchemaAttributes(
                                  PWCHAR                  pwszColumnName,
                                  VARIANT_BOOL    *pfMultiValued,
                                  long                    *plMaxRange
                                  )
{
    HRESULT                                         hr = S_OK;
    auto_rel<IADsProperty>          pProperty;
    CComBSTR                                        bstrSchemaName;
    
    ADsAssert(m_bstrSchemaRoot.Length());
    ADsAssert(pwszColumnName != NULL);
    
    //Does the caller want at least one attribute?
    if (!pfMultiValued && !plMaxRange)
        return S_OK;
    
    //Append a '/' and property name to root schema name
    //to make the Schema ADsPath for this property.
    bstrSchemaName = m_bstrSchemaRoot;
    bstrSchemaName.Append(L"/");
    bstrSchemaName.Append(pwszColumnName);
    
    //Bind to the schema entry and get IADsProperty interface.
    hr = GetDSInterface(
        bstrSchemaName,
        m_objCredentials,
        __uuidof(IADsProperty),
        (void **)&pProperty
        );
    BAIL_ON_FAILURE(hr);
    
    if (pfMultiValued != NULL)
    {
        //Get multivalued attribute.
        hr = pProperty->get_MultiValued(pfMultiValued);
        BAIL_ON_FAILURE(hr);
    }
    
    // The following call get_MaxRange seems to create perf problems
    // because it apparently requires a round-trip to the server.
    // This is not critical and we cn live without asking
    // for max range here.
    
    //if (plMaxRange != NULL)
    //{
    //        //Get MaxSize attribute. Ignore error
    //        //since some properties may not have
    //        //this attribute set.
    //        pProperty->get_MaxRange(plMaxRange);
    //}
    
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::GetTypeAndSize
//
//  Synopsis: Gets the type and size of a property
//
//  Returns:  HRESULT
//----------------------------------------------------------------------------
HRESULT CRow::GetTypeAndSize(
                             ADSTYPE                      dwADsType,
                             CComBSTR&                    bstrPropName,
                             DBTYPE                               *pdbType,
                             ULONG                                *pulSize
                             )
{
    ADsAssert(pdbType != NULL);
    ADsAssert(pulSize != NULL);
    
    long                                    lAdsType = dwADsType;
    VARIANT_BOOL                    fMultiValued = VARIANT_FALSE;
    HRESULT                                 hr = S_OK;
    
    //Initialize out params
    *pdbType = DBTYPE_ERROR;
    *pulSize = ~0;
    
    hr = GetSchemaAttributes(bstrPropName, &fMultiValued, (long *)pulSize);
    BAIL_ON_FAILURE(hr);
    
    //Give our best shot at determining type and size.
    if (fMultiValued == VARIANT_TRUE)
        *pdbType = DBTYPE_BYREF | DBTYPE_VARIANT;
    else if  (lAdsType < g_cMapADsTypeToDBType2)
        *pdbType = g_MapADsTypeToDBType2[lAdsType].wType;
    else
        *pdbType = DBTYPE_ERROR;
    
    // If we could not determine the size from schema information,
    // set the size from the mapping table.
    if (*pulSize == ~0)
        *pulSize = g_MapADsTypeToDBType2[lAdsType].ulSize;
    
error:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::GetSchemaRoot
//
//  Synopsis: Gets the root schema path and stores it in m_bstrSchemaRoot
//
//  Returns:  HRESULT
//----------------------------------------------------------------------------
HRESULT CRow::GetSchemaRoot()
{
    HRESULT                 hr = S_OK;
    CComBSTR                bstrSchema;
    auto_rel<IADs>  pADsSchema;
    
    Assert(m_pADsObj.get());
    
    hr = m_pADsObj->get_Schema(&bstrSchema);
    BAIL_ON_FAILURE(hr);
    
    hr = GetDSInterface(
        bstrSchema,
        m_objCredentials,
        __uuidof(IADs),
        (void **)&pADsSchema
        );
    BAIL_ON_FAILURE(hr);
    
    hr = pADsSchema->get_Parent(&m_bstrSchemaRoot);
    BAIL_ON_FAILURE(hr);
    
error:
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::GetSourceRowsetColumns
//
//  Synopsis: Gets the requested column data from the source rowset.
//
//  Returns:  HRESULT
//----------------------------------------------------------------------------
HRESULT CRow::GetSourceRowsetColumns(
                                     ULONG cColumns,
                                     DBCOLUMNACCESS rgColumns[],
                                     ULONG *pcErrors )
{
    // Make sure there is a rowset backing this row (this doesn't imply that
    // the row is a tear-off (see comment at the beginning).
    ADsAssert(m_pSourceRowset.get() != NULL);
    ADsAssert(m_pRowProvider != NULL);
    ADsAssert(m_fGetColInfoFromRowset == TRUE);
    
    HRESULT                             hr = S_OK;
    auto_rel<IAccessor>         pAccessor;
    auto_rel<IRowset>       pRowset;
    auto_rel<IColumnsInfo>  pColumnsInfo;
    HACCESSOR                           hAccessor;
    ULONG                               iCol;
    ULONG                               ulRefCount = 0;
    DBBINDING               binding = {0};
    DBBINDSTATUS            bindStatus = {0};
    int                     iRowsetIndex;
    DBID                    dbidRowUrl = DBROWCOL_ROWURL;
    
    ADsAssert(pcErrors != NULL);
    
    *pcErrors = 0;
    hr = m_pSourceRowset->QueryInterface(&pRowset);
    BAIL_ON_FAILURE(hr);
    
    hr = m_pSourceRowset->QueryInterface(&pAccessor);
    BAIL_ON_FAILURE(hr);
    
    hr = m_pSourceRowset->QueryInterface(&pColumnsInfo);
    BAIL_ON_FAILURE(hr);
    
    for (iCol = 0; iCol < cColumns; iCol++)
    {
        rgColumns[iCol].dwStatus = DBSTATUS_S_OK;
        if( (rgColumns[iCol].pData != NULL) &&
                (!IgnorecbMaxLen(rgColumns[iCol].wType)) )
            ZeroMemory(rgColumns[iCol].pData, rgColumns[iCol].cbMaxLen);

        //Is this the special URL column.
        if(TRUE == CompareDBIDs(&dbidRowUrl, &rgColumns[iCol].columnid))
        {
            CComVariant varTemp;

            varTemp.Clear();
            varTemp = m_objURL;
            //Set max length of column. 256 is consistent with 2.0 code.
            rgColumns[iCol].cbDataLen = 256;
            rgColumns[iCol].dwStatus = DBSTATUS_S_OK;

            //Does the caller want pData?
            if (rgColumns[iCol].pData != NULL)
            {
                //Get IDataConvert interface pointer.
                auto_rel<IDataConvert> pDataConvert;
                hr = GetIDataConvert(&pDataConvert);

                if(SUCCEEDED(hr))
                    hr = pDataConvert->DataConvert(
                            DBTYPE_VARIANT,
                            rgColumns[iCol].wType,
                            sizeof(VARIANT),
                            &rgColumns[iCol].cbDataLen,
                            &varTemp,
                            rgColumns[iCol].pData,
                            rgColumns[iCol].cbMaxLen,
                            DBSTATUS_S_OK,
                            &rgColumns[iCol].dwStatus,
                            rgColumns[iCol].bPrecision,
                            rgColumns[iCol].bScale,
                            DBDATACONVERT_DEFAULT
                            );

                if(FAILED(hr)) 
                {
                    hr = S_OK;

                    // rgColumns[iCol].dwStatus already set above by 
                    // DataConvert().

                    (*pcErrors)++;
                    continue;
                }
            }
            continue; // on to next column
        }
        
        //Is this the bookmark column?
        if (rgColumns[iCol].columnid.eKind == DBKIND_GUID_PROPID &&
            rgColumns[iCol].columnid.uGuid.guid == DBCOL_SPECIALCOL &&
            rgColumns[iCol].columnid.uName.ulPropid == 2 )
        {
            iRowsetIndex = 0;  // bookmark is first column

        }
        else
        {
        
            // Is column id of DBKIND_NAME?
            if (rgColumns[iCol].columnid.eKind != DBKIND_NAME)
            {
                rgColumns[iCol].dwStatus = DBSTATUS_E_DOESNOTEXIST;
                (*pcErrors)++;
                continue;
            }
        
            iRowsetIndex = 0;
            hr = m_pRowProvider->GetIndex(
                pColumnsInfo,
                rgColumns[iCol].columnid.uName.pwszName,
                iRowsetIndex
            );
            if (FAILED(hr) || 0 == iRowsetIndex) // failure or name not found
            {
                hr = S_OK;
                if(FAILED(hr))
                    rgColumns[iCol].dwStatus = DBSTATUS_E_UNAVAILABLE;
                else
                    rgColumns[iCol].dwStatus = DBSTATUS_E_DOESNOTEXIST;
                (*pcErrors)++;
                continue;
            }
        } // else
        
        binding.dwPart = DBPART_VALUE;
        binding.obLength = 0;
        binding.bPrecision = rgColumns[iCol].bPrecision;
        binding.bScale = rgColumns[iCol].bScale;
        binding.pTypeInfo = 0;
        binding.pObject = NULL;
        binding.iOrdinal = iRowsetIndex;
        binding.cbMaxLen = rgColumns[iCol].cbMaxLen;
        binding.dwMemOwner = DBMEMOWNER_CLIENTOWNED;
        binding.wType =  rgColumns[iCol].wType;
        
        hr = pAccessor->CreateAccessor(
            DBACCESSOR_ROWDATA,
            1,
            &binding,
            0,
            &hAccessor,
            &bindStatus
            );
        if (FAILED(hr))
        {
            rgColumns[iCol].dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
            (*pcErrors)++;
            hr = S_OK;
            continue;
        }
       
        if(rgColumns[iCol].pData != NULL)
        { 
            hr = pRowset->GetData(m_hRow, hAccessor, rgColumns[iCol].pData);
            if (FAILED(hr))
            {
                rgColumns[iCol].dwStatus = StatusFromHRESULT(hr);
                (*pcErrors)++;
                hr = S_OK;
                pAccessor->ReleaseAccessor(hAccessor, &ulRefCount);
                continue;
            }
        }

        hr = pAccessor->ReleaseAccessor(hAccessor, &ulRefCount);

        // now get the status and length
        binding.dwPart = DBPART_LENGTH | DBPART_STATUS;
        binding.obStatus = FIELD_OFFSET(DBCOLUMNACCESS, dwStatus);
        binding.obLength = FIELD_OFFSET(DBCOLUMNACCESS, cbDataLen);

        hr = pAccessor->CreateAccessor(
                DBACCESSOR_ROWDATA,
                1,
                &binding,
                0,
                &hAccessor,
                &bindStatus
                );
        if (FAILED(hr))
        {
            rgColumns[iCol].dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
            (*pcErrors)++;
            hr = S_OK;
            continue;
        }

        hr = pRowset->GetData(m_hRow, hAccessor, &(rgColumns[iCol]));
        if (FAILED(hr))
        {
            rgColumns[iCol].dwStatus = StatusFromHRESULT(hr);
            (*pcErrors)++;
        }

        hr = pAccessor->ReleaseAccessor(hAccessor, &ulRefCount);
        // We have set the dwStatus to reflect any problems, so clear error.
        hr = S_OK;
    }
    
error:
    if (FAILED(hr))
    {
        for (iCol = 0; iCol < cColumns; iCol++)
            rgColumns[iCol].dwStatus = DBSTATUS_E_UNAVAILABLE;
        
        *pcErrors = cColumns;
    }
    
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CRow::StatusFromHRESULT
//
//  Synopsis: Gets DBSTATUS from a given HRESULT.
//
//  Returns:  DBSTATUS
//----------------------------------------------------------------------------
DBSTATUS CRow::StatusFromHRESULT(HRESULT hr)
{
    if (SUCCEEDED(hr))
        RRETURN(DBSTATUS_S_OK);

    switch(hr)
    {
        case (E_INVALIDARG):
            RRETURN(DBSTATUS_E_CANTCREATE);
            
        case (DB_E_BADACCESSORHANDLE):
        case (DB_E_BADACCESSORTYPE):
        case (DB_E_BADBINDINFO):
        case (DB_E_BADORDINAL):
        case (DB_E_BADSTORAGEFLAGS):
            RRETURN(DBSTATUS_E_CANTCONVERTVALUE);

        case (DB_E_UNSUPPORTEDCONVERSION):
            RRETURN(DBSTATUS_E_CANTCONVERTVALUE);

        case (DB_E_BADROWHANDLE):
        case (DB_E_DELETEDROW):
            RRETURN(DBSTATUS_E_UNAVAILABLE);

        default:
            RRETURN(DBSTATUS_E_BADSTATUS);
     }
}

//////////////////////////////////////////////////////////////////////////////
//ISupportErrorInfo
//
//+---------------------------------------------------------------------------
//
//  Function:  CRow::InterfaceSupportsErrorInfo
//
//  Synopsis: Given an interface ID, tells if that interface supports
//            the interface ISupportErrorInfo
//
//  Arguments:
//              REFIID riid
//
//  Returns:    HRESULT
//              S_OK             yes, the interface supports ISupportErrorInfo
//              S_FALSE                  no, the interface doesn't support it.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
        &IID_IRow,
            &IID_IColumnsInfo,
            &IID_IColumnsInfo2,
            &IID_IConvertType,
            &IID_IGetSession
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            RRETURN(S_OK);
    }
    RRETURN(S_FALSE);
}

//////////////////////////////////////////////////////////////////////////////
//IRow methods
//
//+---------------------------------------------------------------------------
//
//  Function:   CRow::GetColumns
//
//  Synopsis:   Gets Columns from a Row.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::GetColumns(
                              /* [in] */ DBORDINAL cColumns,
                              /* [size_is][out][in] */ DBCOLUMNACCESS rgColumns[ ])
{
    HRESULT                                         hr;
    DWORD                                           cErrors = 0;
    auto_leave                                      cs_auto_leave(m_autocs);
    int                                             i;
    DBID                                            dbidRowUrl = DBROWCOL_ROWURL;
    
    if ( cColumns == 0 )
    {
        // Nothing to do:
        RRETURN(S_OK);
    }
    
    if (!rgColumns)
        RRETURN(E_INVALIDARG);
    
	TRYBLOCK
    
		cs_auto_leave.EnterCriticalSection();
        
        // We must have a valid ADs object or a valid Source Rowset
        ADsAssert(m_pADsObj.get() || m_pSourceRowset.get());
    
        if( m_fGetColInfoFromRowset )    
        {
            ADsAssert(m_pSourceRowset.get() != NULL);
            hr = GetSourceRowsetColumns(cColumns, rgColumns, &cErrors);
        }
        else
        {
            //Get IDataConvert interface pointer.
            auto_rel<IDataConvert> pDataConvert;
            hr = GetIDataConvert(&pDataConvert);
            if (FAILED(hr))
                BAIL_ON_FAILURE(hr = DB_E_ERRORSOCCURRED);
            
            for (i = 0; i < cColumns; i++)
            {
                // DBKIND is DBKIND_NAME and null or zero length column name
                if ( rgColumns[i].columnid.eKind == DBKIND_NAME &&
                     (rgColumns[i].columnid.uName.pwszName == NULL ||
                      wcslen(rgColumns[i].columnid.uName.pwszName) == 0))
                {
                    rgColumns[i].dwStatus = DBSTATUS_E_DOESNOTEXIST;
                    cErrors++;
                    continue;
                }
                
                CComVariant varTemp;
                DBTYPE      propType = DBTYPE_VARIANT;
                
                varTemp.Clear();
                
                hr = S_OK;
                //Check if this is the special URL column or the ADsPath 
                //column. If so, assign the URL to varTemp and proceed to data 
                //conversion.
                if (  (rgColumns[i].columnid.eKind == DBKIND_NAME && 
                       _wcsicmp(rgColumns[i].columnid.uName.pwszName, g_cwszAdsPath) == 0) ||
                      (TRUE == CompareDBIDs(&dbidRowUrl, &rgColumns[i].columnid))
                   )
                     
                {
                    varTemp = m_objURL;
                    //Set max length of column.
                    //MaxLen=256 is consistent with 2.0 provider code.
                    rgColumns[i].cbDataLen = 256;
                }
                // check if this is the bookmark column
                else if (rgColumns[i].columnid.eKind == DBKIND_GUID_PROPID &&
                         rgColumns[i].columnid.uGuid.guid == DBCOL_SPECIALCOL &&
                         rgColumns[i].columnid.uName.ulPropid == 2 )
                {
                    UINT uBmk;

                    if( m_hRow != DB_NULL_HROW )
                    // get the bookmark associated with this row handle
                    {
                        auto_rel<IRowset> pRowset;
                        CRowset *pCRowset;
                        LONG lRow;
                        RBOOKMARK bmk;

                        hr = m_pSourceRowset->QueryInterface(__uuidof(IRowset),
                                   (void **)&pRowset);
                        if( SUCCEEDED(hr) )
                        {    
                            pCRowset = (CRowset *) ((IRowset *) pRowset);
                            lRow = pCRowset->HROWToRow(m_hRow);
                            bmk = pCRowset->RowToBmk(lRow);
           
                            uBmk = (UINT) bmk;
                        }
                    }
                    else // use any value for bookmark
                        uBmk = 0;
    
                    if( SUCCEEDED(hr) )
                    {
                        VARIANT vTmpVariant;

                        V_VT(&vTmpVariant) = VT_UI4;
                        V_UI4(&vTmpVariant) = uBmk;

                        varTemp = vTmpVariant;
                    }
                    // else we will fail below and continue to next iteration 
                }
                else if (rgColumns[i].columnid.eKind == DBKIND_NAME)
                {
                    //Find out if property is multivalued and its size.
                    VARIANT_BOOL    fMultiValued;
                    long                    lSize = ~0;
                    hr = GetSchemaAttributes(
                        rgColumns[i].columnid.uName.pwszName,
                        &fMultiValued,
                        &lSize
                        );
                    if (SUCCEEDED(hr))
                    {
                        // if security descriptor is requested as a variant,
                        // then we return a variant with an octet string
                        // inside. This would always be the case with ADO as
                        // it requests all columns as variants. If it is 
                        // requested as an octet string, we return an octet
                        // string. If it is  requested as some other 
                        // type from C++ (say DBTYPE_IDISPATCH), then we will
                        // call Get/GetEx and try to convert the resulting 
                        // variant to the appropriate type. Returning security
                        // descriptor as an octet string is much cheaper as
                        // there is no network traffic for ACE conversion.
                        if( (!_wcsicmp(rgColumns[i].columnid.uName.pwszName,
                                               NT_SEC_DESC_ATTR)) &&
                                      ((rgColumns[i].wType & DBTYPE_VARIANT) ||
                                        (rgColumns[i].wType & DBTYPE_BYTES)) )
                        {
                            hr = GetSecurityDescriptor(&rgColumns[i],
                                                       fMultiValued);
                            if(FAILED(hr)) 
                            {
                                // Clear error. Status has already been set
                                // in rgColumns[i]
                                hr = S_OK;
                                cErrors++;
                            }
                            
                            //Nothing more to do, continue with next column.
                            continue;
                        }
                            
                        if (fMultiValued)
                        {
                            //multi-valued column. Use GetEx.
                            hr = m_pADsObj->GetEx(
                                rgColumns[i].columnid.uName.pwszName,
                                &varTemp
                                );
                            
                            propType = DBTYPE_BYREF | DBTYPE_VARIANT;
                        }
                        else
                        {
                            //single-valued. Use Get.
                            hr = m_pADsObj->Get(
                                rgColumns[i].columnid.uName.pwszName,
                                &varTemp
                                );
                        }
                    }
                    
                    rgColumns[i].cbDataLen = lSize;
                }
                else
                {
                    rgColumns[i].dwStatus = DBSTATUS_E_UNAVAILABLE;
                    cErrors++;
                    continue;
                }
                
                if (FAILED(hr))
                {
                    //Clear error. dwStatus below will reflect
                    //the error for this column.
                    hr = S_OK;
                    
                    rgColumns[i].dwStatus = DBSTATUS_E_UNAVAILABLE;
                    
                    cErrors++; //Increment error count.
                    
                    //Nothing more to do, continue with next column.
                    continue;
                }
                
                //Does the caller want pData?
                if (rgColumns[i].pData != NULL)
                {
                    rgColumns[i].dwStatus = DBSTATUS_S_OK;
                    
                    //Convert data into requested type
                    if (propType == (DBTYPE_VARIANT | DBTYPE_BYREF)) //multi-valued
                    {
                        if( !(rgColumns[i].wType & DBTYPE_VARIANT) )
                        // can't convert a multi-valued attr. to anything else
                        {
                            rgColumns[i].dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
                            cErrors++;
                            continue;
                        }
                        else
                        {
                            DWORD dwRequiredLen;
                            PVARIANT pVar;

                            if((rgColumns[i].wType & (~DBTYPE_BYREF)) != 
                                                         DBTYPE_VARIANT)
                            {
                                // bad type
                                rgColumns[i].dwStatus =
                                        DBSTATUS_E_CANTCONVERTVALUE;
                                cErrors++;
                                continue;
                            }

                            if(rgColumns[i].wType & DBTYPE_BYREF)
                                dwRequiredLen = sizeof(VARIANT *);
                            else
                                dwRequiredLen = sizeof(VARIANT);

                            if(rgColumns[i].cbMaxLen < dwRequiredLen)
                            {
                                rgColumns[i].dwStatus =
                                    DBSTATUS_E_CANTCONVERTVALUE;
                                cErrors++;
                                continue;
                            }

                            if(rgColumns[i].wType & DBTYPE_BYREF)
                            { 
                                pVar = (PVARIANT)
                                          CoTaskMemAlloc(sizeof(VARIANT));
                                if (pVar == NULL)
                                {
                                    rgColumns[i].dwStatus = 
                                          DBSTATUS_E_CANTCREATE;
                                    cErrors++;
                                    continue;
                                }
                            }
                            else
                                pVar = (PVARIANT) rgColumns[i].pData;

                            VariantInit(pVar);
                            hr = VariantCopy(pVar, &varTemp);
                            if(FAILED(hr))
                            {
                                hr = S_OK;
                                rgColumns[i].dwStatus = DBSTATUS_E_CANTCREATE;
                                cErrors++;
                                if(rgColumns[i].wType & DBTYPE_BYREF)
                                    CoTaskMemFree(pVar); 
                                continue;
                            }

                            if(rgColumns[i].wType & DBTYPE_BYREF)
                            {
                                *(PVARIANT *)rgColumns[i].pData = pVar;
                                rgColumns[i].cbDataLen = sizeof(PVARIANT);
                            }
                            else
                                rgColumns[i].cbDataLen = sizeof(VARIANT);
                        }
                    }
                    else //single valued
                    {
                        hr = pDataConvert->DataConvert(
                            propType,
                            rgColumns[i].wType,
                            sizeof(VARIANT),
                            &rgColumns[i].cbDataLen,
                            &varTemp,
                            rgColumns[i].pData,
                            rgColumns[i].cbMaxLen,
                            DBSTATUS_S_OK,
                            &rgColumns[i].dwStatus,
                            rgColumns[i].bPrecision,
                            rgColumns[i].bScale,
                            DBDATACONVERT_DEFAULT
                            );
                    }
                    if (FAILED(hr))
                    {
                        hr = S_OK;
                        rgColumns[i].dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
                        cErrors++;
                    }
                }
            }
        }
	
	    CATCHBLOCKBAIL(hr)        
        
		if (cErrors == 0)
            RRETURN(S_OK);
        else if (cErrors < cColumns)
            RRETURN(DB_S_ERRORSOCCURRED);
        else
            RRETURN(DB_E_ERRORSOCCURRED);
        
error:
        RRETURN(hr);
        
}

//+---------------------------------------------------------------------------
//
//  Function:   CRow::GetSourceRowset
//
//  Synopsis:   Returns interface pointer on the Source Rowset from which this
//              Row was created.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::GetSourceRowset(
                                   /* [in] */ REFIID riid,
                                   /* [iid_is][out] */ IUnknown **ppRowset,
                                   /* [out] */ HROW *phRow)
                                   
{
    if (ppRowset == NULL && phRow == NULL)
        RRETURN(E_INVALIDARG);
    
    HRESULT         hr;
    auto_leave      cs_auto_leave(m_autocs);
    
    if (ppRowset)
        *ppRowset = NULL;
    if (phRow)
        *phRow = DB_NULL_HROW;
    
	TRYBLOCK
    
		cs_auto_leave.EnterCriticalSection();
        if( m_fIsTearOff )
        {
            ADsAssert(m_pSourceRowset.get());
            if (ppRowset)
            {
                hr = m_pSourceRowset->QueryInterface(riid, (void**)ppRowset);
                if (FAILED(hr))
                    BAIL_ON_FAILURE(hr = E_NOINTERFACE);
            }
            
            if (phRow)
            {
                // increment reference count of row handle

                auto_rel<IRowset> pRowset;

                hr = m_pSourceRowset->QueryInterface(__uuidof(IRowset),
                          (void **)&pRowset);
                BAIL_ON_FAILURE(hr);

                hr = pRowset->AddRefRows(1, &m_hRow, NULL, NULL);
                BAIL_ON_FAILURE(hr);

                *phRow = m_hRow;
            }
        }
        else
        {
            BAIL_ON_FAILURE(hr = DB_E_NOSOURCEOBJECT);
        }
	
	CATCHBLOCKBAIL(hr)    
    
	RRETURN(S_OK);
    
error:
    if(ppRowset && (*ppRowset != NULL))
    {
        (*ppRowset)->Release();
        *ppRowset = NULL;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CRow::Open
//
//  Synopsis:   Opens a column of a row and returns the requested
//              interface on it.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::Open(
                        /* [unique][in] */ IUnknown *pUnkOuter,
                        /* [in] */ DBID *pColumnID,
                        /* [in] */ REFGUID rguidColumnType,
                        /* [in] */ DWORD dwBindFlags,
                        /* [in] */ REFIID riid,
                        /* [iid_is][out] */ IUnknown **ppUnk)
{
    HRESULT                                 hr = S_OK;
    CComVariant                             varData;
    CComObject<CStreamMem>* pMemoryStream = NULL;
    auto_rel<IStream>               pStreamDelete;
    DBCOLUMNACCESS                  rgColumns[1];
    DBID                    dbidRowUrl = DBROWCOL_ROWURL;
    
	TRYBLOCK
    
		//General validation checks. dwBindFlags is reserved and must be 0.
        if (ppUnk == NULL || pColumnID == NULL || dwBindFlags != 0)
            RRETURN(E_INVALIDARG);

        *ppUnk = NULL;
       
        // columnID has to be URL, bookmark or DBKIND_NAME  
        if ((pColumnID->eKind != DBKIND_NAME) &&
            (FALSE == CompareDBIDs(&dbidRowUrl, pColumnID)) &&
            (!((pColumnID->eKind == DBKIND_GUID_PROPID) &&
               (pColumnID->uGuid.guid == DBCOL_SPECIALCOL) &&
               (pColumnID->uName.ulPropid == 2))
            )
           )
            RRETURN(DB_E_BADCOLUMNID);
        
        if ((pColumnID->eKind == DBKIND_NAME) &&
                (pColumnID->uName.pwszName == NULL))
            RRETURN(DB_E_BADCOLUMNID);
        
        if (pUnkOuter != NULL && !InlineIsEqualGUID(riid, IID_IUnknown))
            RRETURN(DB_E_NOAGGREGATION);
        
        //we don't support aggregation
        if (pUnkOuter != NULL)
            RRETURN(DB_E_NOAGGREGATION);
       
        // riid has to be one of the interfaces that can be QIed from
        // IStream, need not necessarily be IID_IStream 

        hr = CopyDBIDs(&rgColumns[0].columnid, pColumnID);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = DB_E_BADCOLUMNID);
        
        //fill relevant fields of rgColumns[0]
        rgColumns[0].wType = DBTYPE_VARIANT;
        rgColumns[0].pData = (VARIANT *)&varData;
        rgColumns[0].cbMaxLen = sizeof(VARIANT);
        
        //get column data
        hr = GetColumns(1, rgColumns);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = DB_E_BADCOLUMNID);

        if (rguidColumnType != DBGUID_STREAM)
            //we currently support only streams
            RRETURN(DB_E_OBJECTMISMATCH);
        
        //Check if the returned data is of type binary -
        //Note: ADSI returns binary data as type VT_ARRAY | VT_UI1.
        if (V_VT(&varData) != (VT_ARRAY | VT_UI1))
            BAIL_ON_FAILURE(hr = DB_E_OBJECTMISMATCH);
        
        hr = CComObject<CStreamMem>::CreateInstance(&pMemoryStream);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        
        //To make sure we delete the CStreamMem object in case we ecounter
        //errors after this point.
        pMemoryStream->AddRef();
        pStreamDelete = pMemoryStream;
        
        hr = pMemoryStream->Initialize(&varData, (IRow *)this, m_hRow);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = DB_E_OBJECTMISMATCH);
        
        hr = pMemoryStream->QueryInterface(riid, (void **)ppUnk);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = E_NOINTERFACE);
	
	CATCHBLOCKBAIL(hr);    

error:
    
    FreeDBID(&rgColumns[0].columnid);
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////////////////////
//IColumnsInfo2 : IColumnsInfo
//
//+---------------------------------------------------------------------------
//
//  Function:   CRow::GetColumnInfo
//
//  Synopsis:   returns column information on a row. Column 0 is the URL column.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::GetColumnInfo(
                                 /* [out][in] */ DBORDINAL *pcColumns,
                                 /* [size_is][size_is][out] */ DBCOLUMNINFO **prgInfo,
                                 /* [out] */ OLECHAR **ppStringsBuffer)
{
    if( pcColumns )
        *pcColumns = 0;
    
    if( prgInfo )
        *prgInfo = NULL;
    
    if( ppStringsBuffer )
        *ppStringsBuffer = NULL;
    
    if( !pcColumns || !prgInfo || !ppStringsBuffer )
        RRETURN( E_INVALIDARG );
    
    RRETURN(GetRestrictedColumnInfo (
        0,
        NULL,
        0,
        pcColumns,
        NULL,
        prgInfo,
        ppStringsBuffer
        ));
}

//+---------------------------------------------------------------------------
//
//  Function:   CRow::MapColumnIDs
//
//  Synopsis:   Maps column IDs
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::MapColumnIDs(
                                /* [in] */ DBORDINAL cColumnIDs,
                                /* [size_is][in] */ const DBID rgColumnIDs[  ],
                                /* [size_is][out] */ DBORDINAL rgColumns[  ])
{
	HRESULT hr;
	ULONG cValidCols = 0;
    
    //
    // check in-params and NULL out-params in case of error
    //
	if( cColumnIDs == 0 )
        RRETURN( S_OK );

    if( !rgColumnIDs || !rgColumns )
        RRETURN( E_INVALIDARG );

    //
	// Get the ColumnsInfo
	//
    DBORDINAL      ulColumns;
	DBCOLUMNINFO * rgColumnInfo = NULL;
	OLECHAR *	   pStringBuffer = NULL;

	hr=GetColumnInfo((DBORDINAL *)&ulColumns, &rgColumnInfo, &pStringBuffer);
	if( FAILED(hr) )
		RRETURN( hr );

    for(ULONG iCol=0; iCol < cColumnIDs; iCol++)
    {
        // Initialize the column ordinal to invalid column
        rgColumns[iCol] = DB_INVALIDCOLUMN;

        for (ULONG iOrdinal = 0; iOrdinal < ulColumns; iOrdinal++)
        {
            if (TRUE == CompareDBIDs( 
                                    &rgColumnIDs[iCol],
                                    &rgColumnInfo[iOrdinal].columnid))
            {
				rgColumns[iCol] = rgColumnInfo[iOrdinal].iOrdinal;
				cValidCols++;
				break;
			}
		}
	}

	//
	// Free the ColumnsInfo
	//
	if( rgColumnInfo )
		CoTaskMemFree(rgColumnInfo);

	if( pStringBuffer )
		CoTaskMemFree(pStringBuffer);

	//
	// Return the HRESULT
	//
	if( cValidCols == 0 )
        RRETURN( DB_E_ERRORSOCCURRED );
    else if( cValidCols < cColumnIDs )
        RRETURN( DB_S_ERRORSOCCURRED );
    else
        RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   CRow::GetRestrictedColumnInfo
//
//  Synopsis:   returns column information for those columns which match given
//                              mask criteria.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::GetRestrictedColumnInfo(
                                           /* [in] */ DBORDINAL cColumnIDMasks,
                                           /* [in] */ const DBID rgColumnIDMasks[  ],
                                           /* [in] */ DWORD dwFlags,
                                           /* [out][in] */ DBORDINAL *pcColumns,
                                           /* [size_is][size_is][out] */ DBID **prgColumnIDs,
                                           /* [size_is][size_is][out] */ DBCOLUMNINFO **prgColumnInfo,
                                           /* [out] */ OLECHAR **ppStringsBuffer)
{
    HRESULT                     hr = S_OK;
    ULONG                       ulNumColumns = 0, ulStartColumn;
    int                         iColumn = 0;
    int                         i = 0, j=0, iMask = 0;
    auto_leave                  cs_auto_leave(m_autocs);
    DWORD                       cMaxColumns ;
    auto_rel<IDirectoryObject>  pIDirObj;
    DBID                        bookMarkColid;
    bool                        bAddBookMark = false;

    
    //
    //      Zero the out params:
    //
    
    if (pcColumns)
        *pcColumns  = 0;
    
    if (prgColumnIDs)
        *prgColumnIDs   = NULL;
    
    if (prgColumnInfo)
        *prgColumnInfo  = NULL;
    
    if (ppStringsBuffer)
        *ppStringsBuffer = NULL;
    
    // Validate arguments.
    if ((dwFlags) || (pcColumns == NULL) || (ppStringsBuffer == NULL) )
        RRETURN( E_INVALIDARG);
    
    // Either column info or column ids should be available.
    if ((NULL == prgColumnIDs) && (NULL == prgColumnInfo))
        RRETURN( E_INVALIDARG);
    
    //Validate the mask
    if (cColumnIDMasks && !rgColumnIDMasks)
        RRETURN( E_INVALIDARG);
    
    for (iMask = 0; iMask < cColumnIDMasks; iMask++)
        if (S_FALSE == IsValidDBID(&rgColumnIDMasks[iMask]))
            RRETURN( DB_E_BADCOLUMNID );
        
	TRYBLOCK
    { 
		cs_auto_leave.EnterCriticalSection();
            
        // We must have a valid ADs object or a valid Source Rowset
        ADsAssert(m_pADsObj.get() || m_pSourceRowset.get());
            
        // Calculate maximum number of columns that we will return,
        // excluding the bookmark column. We will add bookmark later.
        if (m_fGetColInfoFromRowset)
        {
            ADsAssert(m_pSourceRowset.get() != NULL);

            // m_cSourceRowsetColumns includes the bookmark column.
            cMaxColumns = m_cSourceRowsetColumns - 1;
        }
        else
        {
            if(m_cMaxColumns != -1)
                cMaxColumns = m_cMaxColumns;
            else
            {
                hr = m_pADsObj->QueryInterface(__uuidof(IDirectoryObject),
                    (void**)&pIDirObj);
                BAIL_ON_FAILURE(hr);
                
                hr = pIDirObj->GetObjectAttributes(NULL, -1, &m_pAttrInfo,
                      &cMaxColumns);
                BAIL_ON_FAILURE(hr);
                
                // Add one for ADsPath. ADsPath is returned if the query was a 
                // SELECT * query (irrespective of whether the row was obtained
                // from a rowset or directly from a command object) OR if 
                // IBindResource::Bind was used to get the row.
                cMaxColumns += 1;
             
                m_cMaxColumns = cMaxColumns;
            }
        }

        // Add one for URL (for all rows)
        cMaxColumns++;
            
        BSTR                    bstrName;
        auto_prg<CComBSTR>      propStrings;
        auto_prg<DBTYPE>        propTypes;
        auto_prg<ULONG>         propSizes;
            
        propStrings = new CComBSTR[cMaxColumns];
          
        if (!propStrings)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
            
        // If client asked for columns info. allocate DBTYPE array
        if (prgColumnInfo)
        {
            propTypes = new DBTYPE[cMaxColumns];
            propSizes = new ULONG[cMaxColumns];
            if (!propTypes || !propSizes)
                BAIL_ON_FAILURE(E_OUTOFMEMORY);
        }
        
        int totalLen = 0;
        ulNumColumns = 0;
        BOOL fURLMatchesMask = FALSE; 

        if (m_fGetColInfoFromRowset)
        {
            ADsAssert(m_pSourceRowset.get() != NULL);

            // start with 1 because column # 0 in source rowset
            // is always a bookmark column.
            
            for (i = 1; i < m_cSourceRowsetColumns; i++)
            {
                //We need to check if this column matches mask criteria. Use
                // the column name for comparison since we should have a match
                // even if a substring of the column name is specified by the
                // client. Comparing column ID won't work in this case.
                // We know that all columns other than the bookmark (column 0)
                // are of type DBKIND_NAME. So we can access pwszName safely.
                if (fMatchesMaskCriteria(
                    m_pSourceRowsetColumnInfo[i].columnid.uName.pwszName,
                    cColumnIDMasks,
                    rgColumnIDMasks) == false)
                    continue;
                
                //matches the criteria, add to list and
                //update totalLen for strings buffer.
                propStrings[(int)ulNumColumns] =
                    m_pSourceRowsetColumnInfo[i].pwszName;
                totalLen += SysStringLen(propStrings[(int)ulNumColumns]) + 1;
                
                //add type and size to list if columninfo is requested.
                if (prgColumnInfo)
                {
                    propTypes[(int)ulNumColumns] =
                        m_pSourceRowsetColumnInfo[i].wType;
                    
                    propSizes[(int)ulNumColumns] =
                        m_pSourceRowsetColumnInfo[i].ulColumnSize;
                }
                
                ulNumColumns++;
            }

            // Finally, check if URL column is requested
            if (fMatchesMaskCriteria(DBROWCOL_ROWURL, cColumnIDMasks,
                       rgColumnIDMasks) == true)
            {
                //matches the criteria, add to list and
                //update totalLen for strings buffer.
                bstrName = SysAllocString(g_cwszAdsPath);
                propStrings[(int)ulNumColumns].Attach(bstrName);
                bstrName = NULL;
                totalLen += SysStringLen(propStrings[(int)ulNumColumns]) + 1;

                // we know the type and size of the URL column

                ulNumColumns++;
                fURLMatchesMask = TRUE;
            }
        }
        else
        {
            for (i = 0; i < cMaxColumns; i++)
            {
                if ((cMaxColumns-1) == i)  // special URL column
                {
                    if (fMatchesMaskCriteria(DBROWCOL_ROWURL, cColumnIDMasks,
                                   rgColumnIDMasks) == true)
                    {
                        bstrName = SysAllocString(g_cwszAdsPath);
                        fURLMatchesMask = TRUE;
                    }
                    else
                        continue;
                }
                else 
                {
                    if (0 == i)  //ADsPath
                        bstrName = SysAllocString(g_cwszAdsPath);
                    else
                    {
                        bstrName =SysAllocString(m_pAttrInfo[i-1].pszAttrName); 
                    }
                
                    // If property doesn't match
                    // mask criteria, continue with next property.
                
                    if (
                        (fMatchesMaskCriteria(bstrName,
                        cColumnIDMasks,
                        rgColumnIDMasks) == false)
                        )
                    {
                        SysFreeString(bstrName);
                        bstrName = NULL;
                        continue;
                    }
                } // else
                
                // OK Matches the criterion add to the list and
                // update toalLen for strings buffer.
                propStrings[(int)ulNumColumns].Attach(bstrName);
                bstrName = NULL;
                totalLen += SysStringLen(propStrings[(int)ulNumColumns]) + 1;
                
                //Get Type and size of column if ColumnInfo is requested.
                //For the special URL column and the ADsPath column, we already 
                //know the type.
                if ((i > 0) && (i < (cMaxColumns-1)) && (prgColumnInfo != NULL))
                {
                    hr = GetTypeAndSize(
                        m_pAttrInfo[i-1].dwADsType,
                        propStrings[(int)ulNumColumns],
                        &propTypes[(int)ulNumColumns],
                        &propSizes[(int)ulNumColumns]
                        );
                    BAIL_ON_FAILURE(hr);
                }
                
                // Increment number of columns count
                ulNumColumns++;
            }
        }
        
        if (ulNumColumns == 0)
            BAIL_ON_FAILURE(hr = DB_E_NOCOLUMN);
        
        //We will add a bookmark column to the list that we are going to return.
        bookMarkColid.eKind = DBKIND_GUID_PROPID;
        bookMarkColid.uGuid.guid = DBCOL_SPECIALCOL;
        bookMarkColid.uName.ulPropid = 2;
        
        if (fMatchesMaskCriteria(bookMarkColid, cColumnIDMasks, rgColumnIDMasks))
        {
            bAddBookMark = true;
            ulNumColumns += 1;
        }
        
        *pcColumns = ulNumColumns;
        
        // Does the caller want column IDS?
        if ( prgColumnIDs )
        {
            *prgColumnIDs =
                (DBID *) CoTaskMemAlloc( (ulNumColumns) * sizeof (DBID) );
            if (NULL == *prgColumnIDs)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            
            ZeroMemory ( *prgColumnIDs, (ulNumColumns) * sizeof (DBID));
        }
        
        // Does the caller want COLUMNINFO?
        if ( prgColumnInfo )
        {
            *prgColumnInfo  = (DBCOLUMNINFO *)
                CoTaskMemAlloc( (ulNumColumns) *  sizeof (DBCOLUMNINFO) );
            if (NULL == *prgColumnInfo)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            
            ZeroMemory ( *prgColumnInfo,
                (ulNumColumns)  * sizeof (DBCOLUMNINFO) );
        }
        
        // get the string buffer allocated.
        *ppStringsBuffer = (OLECHAR *)CoTaskMemAlloc(sizeof(OLECHAR)*totalLen);
        if (NULL ==*ppStringsBuffer)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        
        OLECHAR *pwChar = *ppStringsBuffer;
        
        //First fill bookmark column information.
        if (prgColumnIDs && bAddBookMark) 
        {
            (*prgColumnIDs)[0] = bookMarkColid;
        }
        
        if (prgColumnInfo && bAddBookMark)
        {
            (*prgColumnInfo)[0].pwszName                = NULL;
            (*prgColumnInfo)[0].pTypeInfo               = NULL;
            (*prgColumnInfo)[0].iOrdinal                = 0;
            (*prgColumnInfo)[0].ulColumnSize            = sizeof(ULONG);
            (*prgColumnInfo)[0].wType                   = DBTYPE_UI4;
            (*prgColumnInfo)[0].bPrecision              = 10;
            (*prgColumnInfo)[0].bScale                  = (BYTE) ~ 0;
            (*prgColumnInfo)[0].columnid.eKind          = DBKIND_GUID_PROPID;
            (*prgColumnInfo)[0].columnid.uGuid.guid     = DBCOL_SPECIALCOL;
            (*prgColumnInfo)[0].columnid.uName.ulPropid = 2;
            (*prgColumnInfo)[0].dwFlags                 = DBCOLUMNFLAGS_ISBOOKMARK |
                DBCOLUMNFLAGS_ISFIXEDLENGTH;
        }
        
        // Fill the rest of the columns.
        if (bAddBookMark)
            ulStartColumn = 1;
        else
            ulStartColumn = 0;
        
        for (iColumn= ulStartColumn, i = 0; iColumn < ulNumColumns; iColumn++, i++)
        {
            wcscpy(pwChar, propStrings[i]);
            
            //Is this the special URL column (has to be last column) 
            if( fURLMatchesMask && (iColumn == (ulNumColumns -1)) &&
                 (_wcsicmp(pwChar, g_cwszAdsPath)) == 0 )
            {
                if ( prgColumnIDs )
                {
                    // Add a new DBID for this column:
                    //
                    (*prgColumnIDs)[iColumn]    = DBROWCOL_ROWURL;
                }
                if ( prgColumnInfo )
                {
                    (*prgColumnInfo)[iColumn].pwszName     = pwChar;
                    (*prgColumnInfo)[iColumn].pTypeInfo    = NULL;
                    (*prgColumnInfo)[iColumn].iOrdinal     = iColumn;
                    (*prgColumnInfo)[iColumn].dwFlags      = DBCOLUMNFLAGS_ISROWURL;
                    //Rowset code sets ulColumnSize for Adspath to 256.
                    //We do the same thing for consistency.
                    (*prgColumnInfo)[iColumn].ulColumnSize = 256;
                    (*prgColumnInfo)[iColumn].wType        = DBTYPE_WSTR;
                    (*prgColumnInfo)[iColumn].bPrecision   = ~0;
                    (*prgColumnInfo)[iColumn].bScale       = ~0;
                    
                    (*prgColumnInfo)[iColumn].columnid     = DBROWCOL_ROWURL;
                }
            }
            // Is this the ADsPath column (if it has the name ADsPath and it
            // is not URL, it has to be the ADsPath column)
            else if(_wcsicmp(pwChar, g_cwszAdsPath) == 0)
            {
                if ( prgColumnIDs )
                {
                    // Add DBID for ADsPath
                    (*prgColumnIDs)[iColumn].eKind = DBKIND_NAME;
                    (*prgColumnIDs)[iColumn].uGuid.guid = GUID_NULL;
                    (*prgColumnIDs)[iColumn].uName.pwszName    = pwChar;
                }
                if ( prgColumnInfo )
                {
                    // Add a DBCOLUMNINFO for ADsPath

                    DBTYPE  wType = DBTYPE_WSTR | DBTYPE_BYREF;

                    (*prgColumnInfo)[iColumn].pwszName              = pwChar;
                    (*prgColumnInfo)[iColumn].pTypeInfo             = NULL;
                    (*prgColumnInfo)[iColumn].iOrdinal              = iColumn;

                    // OLEDB 2.0 code sets ulColumnsSize to 256 for ADsPath
                    (*prgColumnInfo)[iColumn].ulColumnSize          = 256; 
                    (*prgColumnInfo)[iColumn].wType                 = wType; 

                    // the code below has to be identical to the code in
                    // GetColumnsInfo2 in ccommand.cxx
                    wType = wType & (~DBTYPE_BYREF);
                    if( (wType == DBTYPE_STR)  ||
                        (wType == DBTYPE_WSTR) ||
                        (wType == DBTYPE_BYTES) )
                        (*prgColumnInfo)[iColumn].dwFlags =
                         DBCOLUMNFLAGS_ISNULLABLE;
                    else
                        (*prgColumnInfo)[iColumn].dwFlags =
                         DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_ISFIXEDLENGTH;


                    (*prgColumnInfo)[iColumn].bPrecision = SetPrecision(wType);

                    (*prgColumnInfo)[iColumn].bScale                = ~0;
                    (*prgColumnInfo)[iColumn].columnid.eKind    = DBKIND_NAME;
                    (*prgColumnInfo)[iColumn].columnid.uGuid.guid   = GUID_NULL;
                    (*prgColumnInfo)[iColumn].columnid.uName.pwszName= pwChar;
                }
            }
            else
            {
                if ( prgColumnIDs )
                {
                    // Add a new DBID for this column:
                    //
                    (*prgColumnIDs)[iColumn].eKind    = DBKIND_NAME;
                    (*prgColumnIDs)[iColumn].uGuid.guid = GUID_NULL;
                    (*prgColumnIDs)[iColumn].uName.pwszName    = pwChar;
                   
                }
                if ( prgColumnInfo )
                {
                    //      Add a new DBCOLUMNINFO for this column:
                    //
                    
                    DBTYPE  wType = propTypes[i];
                    
                    (*prgColumnInfo)[iColumn].pwszName              = pwChar;
                    (*prgColumnInfo)[iColumn].pTypeInfo             = NULL;
                    (*prgColumnInfo)[iColumn].iOrdinal              = iColumn;
                    (*prgColumnInfo)[iColumn].ulColumnSize          = propSizes[i];                                           ;
                    (*prgColumnInfo)[iColumn].wType                 = wType;
                    
                    // the code below has to be identical to the code in
                    // GetColumnsInfo2 in ccommand.cxx
                    wType = wType & (~DBTYPE_BYREF);
                    if( (wType == DBTYPE_STR)  ||
                        (wType == DBTYPE_WSTR) ||
                        (wType == DBTYPE_BYTES) )
                        (*prgColumnInfo)[iColumn].dwFlags = 
                         DBCOLUMNFLAGS_ISNULLABLE;
                    else
                        (*prgColumnInfo)[iColumn].dwFlags =
                         DBCOLUMNFLAGS_ISNULLABLE | DBCOLUMNFLAGS_ISFIXEDLENGTH; 

                    (*prgColumnInfo)[iColumn].bPrecision = SetPrecision(wType);
                    
                    (*prgColumnInfo)[iColumn].bScale                = ~0;
                    (*prgColumnInfo)[iColumn].columnid.eKind        = DBKIND_NAME;
                    (*prgColumnInfo)[iColumn].columnid.uGuid.guid   = GUID_NULL;
                    (*prgColumnInfo)[iColumn].columnid.uName.pwszName= pwChar;
                }
            }
            
            //Position the pointer in strings buffer
            //for writing next column name.
            pwChar += SysStringLen(propStrings[i]) + 1;
        }
	
    }		
	CATCHBLOCKBAIL(hr)    

	RRETURN(S_OK);
    
error:
    if ((prgColumnIDs) && (*prgColumnIDs))
    {
        CoTaskMemFree(*prgColumnIDs);
        *prgColumnIDs = NULL;
    }
    if ((prgColumnInfo) && (*prgColumnInfo))
    {
        CoTaskMemFree(*prgColumnInfo);
        *prgColumnInfo = NULL;
    }
    if ((ppStringsBuffer) && (*ppStringsBuffer))
    {
        CoTaskMemFree(*ppStringsBuffer);
        *ppStringsBuffer = NULL;
    }

    if (pcColumns)
        *pcColumns  = 0;

    RRETURN(hr);
}

/////////////////////////////////////////////////////////////////////////////
//IConvertType
//
//+---------------------------------------------------------------------------
//
//  Function:   CRow::ConvertType
//
//  Synopsis:   Converts one DBTYPE to another using data conversion library.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.0 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::CanConvert(
                              /* [in] */ DBTYPE wFromType,
                              /* [in] */ DBTYPE wToType,
                              /* [in] */ DBCONVERTFLAGS dwConvertFlags)
{
    auto_rel<IDataConvert> pDataConvert;
    
    HRESULT hr = GetIDataConvert(&pDataConvert);
    BAIL_ON_FAILURE(hr);
    
    ADsAssert(pDataConvert.get());

    if( dwConvertFlags & DBCONVERTFLAGS_PARAMETER ) // not allowed on row
        RRETURN( DB_E_BADCONVERTFLAG );

    if( (dwConvertFlags & (~(DBCONVERTFLAGS_ISLONG |
                            DBCONVERTFLAGS_ISFIXEDLENGTH |
                            DBCONVERTFLAGS_FROMVARIANT))) !=
                            DBCONVERTFLAGS_COLUMN )
        RRETURN( DB_E_BADCONVERTFLAG );

    if( dwConvertFlags & DBCONVERTFLAGS_ISLONG )
    {
        DBTYPE wType;

        wType = wFromType & (~(DBTYPE_BYREF | DBTYPE_ARRAY | DBTYPE_VECTOR));

        // wType has to be variable-length DBTYPE
        if( (wType != DBTYPE_STR) && (wType != DBTYPE_WSTR) &&
            (wType != DBTYPE_BYTES) && (wType != DBTYPE_VARNUMERIC) )
            RRETURN( DB_E_BADCONVERTFLAG );
    }

    if( dwConvertFlags & DBCONVERTFLAGS_FROMVARIANT )
    {
        DBTYPE dbTmpType, wVtType;

        wVtType = wFromType & VT_TYPEMASK;

        // Take out all of the Valid VT_TYPES (36 is VT_RECORD in VC 6)
        if( (wVtType > VT_DECIMAL && wVtType < VT_I1) ||
            ((wVtType > VT_LPWSTR && wVtType < VT_FILETIME) && wVtType !=36) ||
            (wVtType > VT_CLSID) )
            RRETURN( DB_E_BADTYPE );
    }

    RRETURN(pDataConvert->CanConvert(wFromType, wToType));
    
error:
    RRETURN(hr);
}

///////////////////////////////////////////////////////////////////////////////
//IGetSession
//
//+---------------------------------------------------------------------------
//
//  Function:   CRow::GetSession
//
//  Synopsis:   Gets the Session interface through which this row has been
//              created.
//
//  Returns:    HRESULT
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CRow::GetSession(
                              REFIID riid,
                              IUnknown **ppunkSession)
{
    if (ppunkSession == NULL)
        RRETURN(E_INVALIDARG);
    
    *ppunkSession = NULL;
    
    if (!m_pSession.get())
        RRETURN(DB_E_NOSOURCEOBJECT);
    
    HRESULT hr = m_pSession->QueryInterface(riid, (void**)ppunkSession);
    if (FAILED(hr))
        RRETURN(E_NOINTERFACE);
    
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// GetSecurityDescriptor
//
// Returns the security descriptor as an octet string.
//
//----------------------------------------------------------------------------
HRESULT CRow::GetSecurityDescriptor(
    DBCOLUMNACCESS *pColumn,
    BOOL fMultiValued
    )
{
    HRESULT hr;
    auto_rel<IDirectoryObject>  pIDirObj;
    PVARIANT pVariant = NULL, pVarArray = NULL;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    VARTYPE vType;
    DWORD dwRequiredLen;
    int iAttr, j;

    // multivalued attributes are always returned as variants. Single-valued
    // security descriptor has to be returned as either variant or octet 
    // string.
    if( ((pColumn->wType != (DBTYPE_VARIANT | DBTYPE_BYREF)) &&
        (pColumn->wType != DBTYPE_VARIANT)) && 
        (fMultiValued || ((fMultiValued == FALSE) && 
         (pColumn->wType != DBTYPE_BYTES) &&
         (pColumn->wType != (DBTYPE_BYTES | DBTYPE_BYREF)))) )
    {
        pColumn->dwStatus = DBSTATUS_E_CANTCONVERTVALUE;    
        BAIL_ON_FAILURE(hr = DB_E_CANTCONVERTVALUE);
    }

    pColumn->dwStatus = DBSTATUS_S_OK;
    pColumn->cbDataLen = 0;

    if(pColumn->pData == NULL) // client doesn't want any data returned
        RRETURN(S_OK);

    if(m_cMaxColumns == -1) // GetObjectAttributes has not been called
    {
        hr = m_pADsObj->QueryInterface(__uuidof(IDirectoryObject),
             (void**)&pIDirObj);
        BAIL_ON_FAILURE(hr);

        hr = pIDirObj->GetObjectAttributes(NULL, -1, &m_pAttrInfo,
            (DWORD *) &m_cMaxColumns);
        BAIL_ON_FAILURE(hr);

        m_cMaxColumns++; // include ADsPath
    }

    // get the index of security descriptor in the attribute array
    for(iAttr = 0; iAttr < (m_cMaxColumns-1); iAttr++)
        if(!_wcsicmp(m_pAttrInfo[iAttr].pszAttrName, NT_SEC_DESC_ATTR))
            break;

    if(iAttr == (m_cMaxColumns-1))
    {
        pColumn->dwStatus = DBSTATUS_E_UNAVAILABLE; 
        BAIL_ON_FAILURE(hr = DB_E_NOTFOUND);
    }

    ADsAssert(m_pAttrInfo[iAttr].dwADsType == ADSTYPE_NT_SECURITY_DESCRIPTOR);
 
    if(fMultiValued)
    {
        // check if the client has enough space to copy over the variant
        if(pColumn->wType & DBTYPE_BYREF)
            dwRequiredLen = sizeof(VARIANT *);
        else
            dwRequiredLen = sizeof(VARIANT);

        if(pColumn->cbMaxLen < dwRequiredLen)
        {
            pColumn->dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
            BAIL_ON_FAILURE(hr = DB_E_CANTCONVERTVALUE);
        }

        aBound.lLbound = 0;
        aBound.cElements = m_pAttrInfo[iAttr].dwNumValues;

        if(pColumn->wType & DBTYPE_BYREF)
        {
            pVariant = (PVARIANT) AllocADsMem(sizeof(VARIANT));
            if(NULL == pVariant)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        else
            pVariant = (PVARIANT) pColumn->pData;

        VariantInit(pVariant);

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
        if (aList == NULL)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);        

        hr = SafeArrayAccessData( aList, (void **) &pVarArray );
        BAIL_ON_FAILURE(hr);

        vType = g_MapADsTypeToVarType[m_pAttrInfo[iAttr].dwADsType];

        for (j=0; j<aBound.cElements; j++)
        {
            VariantInit(pVarArray+j);
            V_VT(pVarArray+j) = vType;

            hr = BinaryToVariant(
               m_pAttrInfo[iAttr].pADsValues[j].SecurityDescriptor.dwLength,
               m_pAttrInfo[iAttr].pADsValues[j].SecurityDescriptor.lpValue,
               pVarArray+j);

            if(FAILED(hr))
            {
                int k;

                for(k = 0; k < j; k++)
                    VariantClear(pVarArray+k);
            }

            BAIL_ON_FAILURE(hr);
        }

        SafeArrayUnaccessData( aList );

        V_VT((PVARIANT)pVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY((PVARIANT)pVariant) = aList;

        if(pColumn->wType & DBTYPE_BYREF)
            *(PVARIANT *)pColumn->pData = pVariant;

        pColumn->cbDataLen = sizeof(VARIANT); 
    }
    else // single valued
    {
        // check if the client has enough space to copy over the octet string 
        if(pColumn->wType & DBTYPE_VARIANT)
        {
            if(pColumn->wType & DBTYPE_BYREF)       
                dwRequiredLen = sizeof(VARIANT *);
            else
                dwRequiredLen = sizeof(VARIANT);
        }
        else if(pColumn->wType & DBTYPE_BYTES)
        {
            if(pColumn->wType & DBTYPE_BYREF)
                dwRequiredLen = sizeof(BYTE *);
            else
                dwRequiredLen =
                  m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.dwLength;
        }

        if(pColumn->cbMaxLen < dwRequiredLen)
        {
            pColumn->dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
            BAIL_ON_FAILURE(hr = DB_E_CANTCONVERTVALUE);
        }

        if(pColumn->wType & DBTYPE_VARIANT)
        {
            if(pColumn->wType & DBTYPE_BYREF)
            {
                pVariant = (PVARIANT) AllocADsMem(sizeof(VARIANT));
                if(NULL == pVariant)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
            else
                pVariant = (PVARIANT) pColumn->pData;

            VariantInit(pVariant);

            vType = g_MapADsTypeToVarType[m_pAttrInfo[iAttr].dwADsType];
            V_VT(pVariant) = vType;

            hr = BinaryToVariant(
               m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.dwLength,
               m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.lpValue,
               pVariant);
            BAIL_ON_FAILURE(hr);

            if(pColumn->wType & DBTYPE_BYREF)
                *(PVARIANT *)pColumn->pData = pVariant;

            pColumn->cbDataLen = sizeof(VARIANT);
        }
        else if(pColumn->wType & DBTYPE_BYTES)
        {
            if(pColumn->wType & DBTYPE_BYREF)
                *(BYTE **)pColumn->pData =
                   m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.lpValue;
            else
                memcpy(pColumn->pData,
                 m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.lpValue,
                 m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.dwLength); 

            pColumn->cbDataLen =
                 m_pAttrInfo[iAttr].pADsValues[0].SecurityDescriptor.dwLength;
        }
    }

    RRETURN(S_OK);

error:

    if(aList)
        SafeArrayDestroy(aList);
    if((pVariant) && (pColumn->wType & DBTYPE_BYREF))
        FreeADsMem(pVariant);

    RRETURN(hr);
}

//---------------------------------------------------------------------------
// IgnorecbMaxLen
//
// This function returns 1 if the cbMaxLen field of DBCOLUMNACCESS structure
// should be ignored and 0 otherwise. cbMaxLen should be ignored for fixed
// length data types and data types combined with DBTYPE_BYREF, DBTYPE_VECTOR
// and DBTYPE_ARRAY (page 107, OLEDB 2.0 spec)
//
//---------------------------------------------------------------------------
int CRow::IgnorecbMaxLen(DBTYPE wType)
{
    if( (wType & DBTYPE_BYREF) ||
        (wType & DBTYPE_VECTOR) ||
        (wType & DBTYPE_ARRAY) )
        return 1;

    wType &= ( (~DBTYPE_BYREF) & (~DBTYPE_VECTOR) & (~DBTYPE_ARRAY) );

    // check if it is a variable length data type
    if( (DBTYPE_STR == wType) ||
        (DBTYPE_BYTES == wType) ||
        (DBTYPE_WSTR == wType) ||
        (DBTYPE_VARNUMERIC == wType) )
        return 0;

    // must be fixed length data type
    return 1;
} 
 
//-----------------------------------------------------------------------------           

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\sec2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop


#define GetAce          ADSIGetAce

#define DeleteAce       ADSIDeleteAce

#define GetAclInformation       ADSIGetAclInformation

#define SetAclInformation       ADSISetAclInformation

#define IsValidAcl              ADSIIsValidAcl

#define InitializeAcl           ADSIInitializeAcl


extern HRESULT
ConvertSidToString(
    PSID pSid,
    LPWSTR   String
    );

DWORD
GetDomainDNSNameForDomain(
    LPWSTR pszDomainFlatName,
    BOOL fVerify,
    BOOL fWriteable,
    LPWSTR pszServerName,
    LPWSTR pszDomainDNSName
    );

//
// Helper routine.
//
PSID
ComputeSidFromAceAddress(
    LPBYTE pAce
    );

//+---------------------------------------------------------------------------
// Function:   GetLsaPolicyHandle - helper routine.
//
// Synopsis:   Returns the lsa policy handle to the server in question.
//          If a serverName is present we will first try that. If no servername
//          is present we will try and connect up to the default server for the
//          currently logged on user. If everything else fails, we will
//          connnect to the local machine (NULL server).
//
// Arguments:  pszServerName    - Name of targtet server/domain or NULL.
//             Credentials      - Credentials to use for the connection.
//                                Currently this is not used.
//             phLsaPolicy      -  Return ptr for lsa policy handle.
//
// Returns:    S_OK or any valid error code.
//
// Modifies:   phLsaPolicy.
//
//----------------------------------------------------------------------------
HRESULT
GetLsaPolicyHandle(
    LPWSTR pszServerName,
    CCredentials &Credentials,
    PLSA_HANDLE phLsaPolicy
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus = NO_ERROR;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    DWORD dwErr;
    DWORD dwLen = 0;
    LPWSTR pszServer = NULL;
    BOOL fNullServer = FALSE;
    LSA_OBJECT_ATTRIBUTES lsaObjectAttributes;
    LSA_UNICODE_STRING lsaSystemName;
    WCHAR szDomainName[MAX_PATH];
    WCHAR szServerName[MAX_PATH];

    memset(&lsaObjectAttributes, 0, sizeof(LSA_OBJECT_ATTRIBUTES));

    //
    // First most common case of serverless paths.
    //
    if (!pszServerName) {
        dwStatus = GetDomainDNSNameForDomain(
                 NULL,
                 FALSE, // do not force verify
                 FALSE, // does not need to be writable
                 szServerName,
                 szDomainName
                 );

        //
        // If we succeeded we will use the name returned,
        // otherwise we will go with NULL.
        //
        if (dwStatus == NO_ERROR) {
            pszServer = szServerName;
        } 
        else {
            fNullServer = TRUE;
        }
    } 
    else {
        pszServer = pszServerName;
    }

    if (pszServer) {
        dwLen = wcslen(pszServer);
    } 

    lsaSystemName.Buffer = pszServer;
    lsaSystemName.Length = dwLen * sizeof(WCHAR);
    lsaSystemName.MaximumLength = lsaSystemName.Length;

    //
    // First attempt at opening policy handle.
    //
    ntStatus = LsaOpenPolicy(
                   &lsaSystemName,
                   &lsaObjectAttributes,
                   POLICY_LOOKUP_NAMES,
                   phLsaPolicy
                   );

    if (ntStatus != STATUS_SUCCESS) {
        //
        // Irrespective of failure should retry if we have not already
        // tried with a NULL serverName.
        //
        if (!fNullServer) {
            fNullServer = TRUE;

            lsaSystemName.Buffer = NULL;
            lsaSystemName.Length = 0;
            lsaSystemName.MaximumLength = 0;
            ntStatus = LsaOpenPolicy(
                           &lsaSystemName,
                           &lsaObjectAttributes,
                           POLICY_LOOKUP_NAMES,
                           phLsaPolicy
                           );
        }

        hr = HRESULT_FROM_WIN32(
                 LsaNtStatusToWinError(ntStatus)
                 );
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetNamesFromSids - helper routine.
//
// Synopsis:   Simple helper routine that calls LsaLookupSids and if the
//          the error returned is ERROR_SOME_NOT_MAPPED, then the hr is
//          set S_OK.
//
// Arguments:  hLsaPolicy       -   LSA_HANDLE to do the lookup on.
//             pSidArray        -   Array of sid's top lookup.
//             dwSidCount       -   Number of sids to translate.
//             ppLsaRefDomList  -   Ret value for domain list.
//             ppLsaNames       -   Ret value for name list.
//
// Returns:    S_OK or any valid error code.
//
// Modifies:   n/a.
//
//----------------------------------------------------------------------------
HRESULT
GetNamesFromSids(
    LSA_HANDLE hLsaPolicy,
    PSID *pSidArray,
    DWORD dwSidCount,
    PLSA_REFERENCED_DOMAIN_LIST *ppLsaRefDomList,
    PLSA_TRANSLATED_NAME  *ppLsaNames
    )
{
    HRESULT hr = S_OK;
    NTSTATUS ntStatus;

    ntStatus = LsaLookupSids(
                   hLsaPolicy,
                   dwSidCount,
                   pSidArray,
                   ppLsaRefDomList,
                   ppLsaNames
                   );
    
    // even if the above call fails, we don't want to bail out since even if all the name resolving fails
    // we still want to try to use the stringlized sid
               
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetNamesForSidFromArray - helper routine.
//
// Synopsis:   Given the position of the ace and the retrun value from
//          LsaLookupSids, constructs the actual name of the trustee.
//
// Arguments:  dwAceNumber      -   Position of the ace in the array.
//             pLsaRefDoms      -   List of reference domains.
//             pLsaNames        -   List of LSA names.
//             ppszFriendlyName -   Return string pointer.
//
// Returns:    S_OK or any valid error code.
//
// Modifies:   n/a.
//
//----------------------------------------------------------------------------
HRESULT 
GetNameForSidFromArray(
    DWORD dwAceNumber,
    LSA_REFERENCED_DOMAIN_LIST *pLsaRefDoms,
    LSA_TRANSLATED_NAME *pLsaNames,
    LPWSTR * ppszFriendlyName
    )
{
    HRESULT hr = S_OK;
    DWORD dwLengthDomain;
    DWORD dwLengthName = 0;
    BOOL fDomainInvalid = FALSE;
    BOOL fNameInvalid = FALSE;
    LPWSTR pszName = NULL;

    *ppszFriendlyName = NULL;

    if (!pLsaNames) {
        RRETURN(hr = E_FAIL);
    }

    switch (pLsaNames[dwAceNumber].Use) {
    
    case SidTypeDomain:
        fNameInvalid = TRUE;
        break;
    
    case SidTypeInvalid:
        fNameInvalid = TRUE;
        fDomainInvalid = TRUE;
        break;
    
    case SidTypeUnknown:
        fNameInvalid = TRUE;
        fDomainInvalid = TRUE;
        break;

    case SidTypeWellKnownGroup:
        if (pLsaNames[dwAceNumber].DomainIndex < 0 ) {
            fDomainInvalid = TRUE;
        }
        break;

    default:
        //
        // Name and domain are valid.
        //
        fDomainInvalid = FALSE;
        fNameInvalid = FALSE;
    }

    if (!fNameInvalid) {
        dwLengthName = ((pLsaNames[dwAceNumber]).Name).Length + sizeof(WCHAR);
    }

    //
    // Process domain if valid.
    //
    if (!fDomainInvalid) {
        DWORD domainIndex = pLsaNames[dwAceNumber].DomainIndex;
        LSA_UNICODE_STRING lsaString;
        //
        // Need to make sure that the index is valid.
        //
        if (domainIndex > pLsaRefDoms->Entries) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

        lsaString = ((pLsaRefDoms->Domains)[domainIndex]).Name;

        //
        // Add sizeof(WCHAR) for the trailing \0.
        //
        dwLengthDomain = lsaString.Length + sizeof(WCHAR); 

        if (lsaString.Length > 0) {
            pszName = (LPWSTR) AllocADsMem( dwLengthDomain + dwLengthName);

            if (!pszName) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            memcpy(
                pszName,
                lsaString.Buffer,
                lsaString.Length
            );


        }
        
    }

    if (!fNameInvalid) {
        LSA_UNICODE_STRING lsaNameString = (pLsaNames[dwAceNumber]).Name;
        //
        // Length of pszName is zero if the group name is Everyone but
        // there is still a domain name component.
        //
        if (!fDomainInvalid 
            && pszName 
            && wcslen(pszName)
            ) {
            wcscat(pszName, L"\\");
        } else {
            pszName = (LPWSTR) AllocADsMem(dwLengthName);
            if (!pszName) {
                BAIL_ON_FAILURE (hr = E_OUTOFMEMORY);
            }
        }

        memcpy(
            fDomainInvalid ? pszName : (pszName + wcslen(pszName)),
            lsaNameString.Buffer,
            lsaNameString.Length
            );
    }

    *ppszFriendlyName = pszName;

    RRETURN(hr);

error:

    if (pszName) {
        FreeADsMem(pszName);
    }

    RRETURN(hr);
}

HRESULT
ConvertSecDescriptorToVariant(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    VARIANT * pVarSec,
    BOOL fNTDS
    )
{
    IADsSecurityDescriptor * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    LPWSTR pszGroup = NULL;
    LPWSTR pszOwner = NULL;

    BOOL fOwnerDefaulted = 0;
    BOOL fGroupDefaulted = 0;
    BOOL fDaclDefaulted = 0;
    BOOL fSaclDefaulted = 0;

    BOOL fSaclPresent = 0;
    BOOL fDaclPresent = 0;

    LPBYTE pOwnerSidAddress = NULL;
    LPBYTE pGroupSidAddress = NULL;
    LPBYTE pDACLAddress = NULL;
    LPBYTE pSACLAddress = NULL;

    DWORD dwRet = 0;

    VARIANT varDACL;
    VARIANT varSACL;

    HRESULT hr = S_OK;

    DWORD dwRevision = 0;
    WORD  wControl = 0;

    VariantInit(pVarSec);
    memset(&varSACL, 0, sizeof(VARIANT));
    memset(&varDACL, 0, sizeof(VARIANT));

    if (!pSecurityDescriptor) {
        RRETURN(E_FAIL);
    }


    //
    // Control & Revision
    //
    dwRet = GetSecurityDescriptorControl(
                        pSecurityDescriptor,
                        &wControl,
                        &dwRevision
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    //
    // Owner
    //
    dwRet = GetSecurityDescriptorOwner(
                        pSecurityDescriptor,
                        (PSID *)&pOwnerSidAddress,
                        &fOwnerDefaulted
                        );

    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pOwnerSidAddress) {
    	//
    	// For Owner and Group, we will convert the sid in old way without optimization
    	//
        hr = ConvertSidToFriendlyName2(        	
                    pszServerName,
                    Credentials,
                    pOwnerSidAddress,
                    &pszOwner,
                    fNTDS
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // Group
    //
    dwRet = GetSecurityDescriptorGroup(
                        pSecurityDescriptor,
                        (PSID *)&pGroupSidAddress,
                        &fOwnerDefaulted
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pGroupSidAddress) {
    	//
    	// For Owner and Group, we will convert the sid in old way without optimization
    	//
        hr = ConvertSidToFriendlyName2(
                    pszServerName,
                    Credentials,
                    pGroupSidAddress,
                    &pszGroup,
                    fNTDS
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // DACL
    //
    dwRet = GetSecurityDescriptorDacl(
                        pSecurityDescriptor,
                        &fDaclPresent,
                        (PACL*)&pDACLAddress,
                        &fDaclDefaulted
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pDACLAddress) {

        hr = ConvertACLToVariant(
                pszServerName,
                Credentials,
                (PACL)pDACLAddress,
                &varDACL,
                fNTDS
                );
        BAIL_ON_FAILURE(hr);
    }

    //
    // SACL
    //
    dwRet = GetSecurityDescriptorSacl(
                        pSecurityDescriptor,
                        &fSaclPresent,
                        (PACL *)&pSACLAddress,
                        &fSaclDefaulted
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pSACLAddress) {

        hr = ConvertACLToVariant(
                pszServerName,
                Credentials,
                (PACL)pSACLAddress,
                &varSACL,
                fNTDS
                );
        BAIL_ON_FAILURE(hr);
    }


    //
    // Construct an IADsSecurityDescriptor with the data
    // retrieved from the raw SD
    //
    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Owner(pszOwner);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Group(pszGroup);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Revision(dwRevision);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Control((DWORD)wControl);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_DiscretionaryAcl(V_DISPATCH(&varDACL));
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_SystemAcl(V_DISPATCH(&varSACL));
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

    //
    // Construct a VARIANT with the IADsSecurityDescriptor
    //
    V_VT(pVarSec) = VT_DISPATCH;
    V_DISPATCH(pVarSec) =  pDispatch;

error:
    VariantClear(&varSACL);
    VariantClear(&varDACL);

    if (pszOwner) {
        FreeADsStr(pszOwner);
    }

    if (pszGroup) {
        FreeADsStr(pszGroup);
    }


    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}


HRESULT
ConvertSidToFriendlyName(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PSID pSid,
    LPWSTR * ppszAccountName,
    BOOL fNTDS
    )
{
    HRESULT hr = S_OK;
    SID_NAME_USE eUse;
    WCHAR szAccountName[MAX_PATH];
    WCHAR szDomainName[MAX_PATH];
    WCHAR szServerName[MAX_PATH];
    DWORD dwLen = 0;
    DWORD dwRet = 0;

    LPWSTR pszAccountName = NULL;

    DWORD dwAcctLen = 0;
    DWORD dwDomainLen = 0;

#if 0
/**************************************************************

    //
    // parse Trustee and determine whether its NTDS or U2
    //

    if (fNTDS) {

        dwAcctLen = sizeof(szAccountName);
        dwDomainLen = sizeof(szDomainName);

        dwRet = LookupAccountSid(
                    pszServerName,
                    pSid,
                    szAccountName,
                    &dwAcctLen,
                    szDomainName,
                    &dwDomainLen,
                    (PSID_NAME_USE)&eUse
                    );

        //
        // Try with NULL server name if we have not already
        // done that for error cases.
        //
        if (!dwRet && pszServerName) {
            dwRet = LookupAccountSid(
                        NULL,
                        pSid,
                        szAccountName,
                        &dwAcctLen,
                        szDomainName,
                        &dwDomainLen,
                        (PSID_NAME_USE)&eUse
                        );
        }

        //
        // If using serverless paths, try it on the DC if it
        // failed (which will happen if we're trying to resolve
        // something like "BUILTIN\Print Operators" on a member
        // computer)
        //
        if (!dwRet && !pszServerName) {

            dwAcctLen = sizeof(szAccountName);
            dwDomainLen = sizeof(szDomainName);
            

            DWORD dwStatus = GetDomainDNSNameForDomain(
                                        NULL,
                                        FALSE, // don't force verify
                                        FALSE, // not writable
                                        szServerName,
                                        szDomainName
                                        );

            if (dwStatus == NO_ERROR) {

                dwRet = LookupAccountSid(
                            szServerName,
                            pSid,
                            szAccountName,
                            &dwAcctLen,
                            szDomainName,
                            &dwDomainLen,
                            (PSID_NAME_USE)&eUse
                            );

                //
                // If the lookup failed because the server was unavailable, try to get
                // the server again, this time forcing DsGetDcName to do rediscovery
                //
                if (!dwRet && (GetLastError() == RPC_S_SERVER_UNAVAILABLE)) {
                    
                    dwStatus = GetDomainDNSNameForDomain(
                                            NULL,
                                            TRUE, // force verify
                                            FALSE,// not writable
                                            szServerName,
                                            szDomainName
                                            );

                    if (dwStatus == NO_ERROR) {

                        dwRet = LookupAccountSid(
                                    szServerName,
                                    pSid,
                                    szAccountName,
                                    &dwAcctLen,
                                    szDomainName,
                                    &dwDomainLen,
                                    (PSID_NAME_USE)&eUse
                                    );
                    }
                }
            }
        }

        if (!dwRet) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }else {

            dwLen = wcslen(szAccountName) + wcslen(szDomainName) + 1 + 1;

            pszAccountName = (LPWSTR)AllocADsMem(dwLen * sizeof(WCHAR));
            if (!pszAccountName) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            if (szDomainName[0] && szAccountName[0]) {
                wsprintf(pszAccountName,L"%s\\%s",szDomainName, szAccountName);
            }else if (szAccountName[0]) {
                wsprintf(pszAccountName,L"%s", szAccountName);
            }

            *ppszAccountName = pszAccountName;

        }

    }else {
*****************************************************************/    
#endif
        
    if (!fNTDS) {

        hr = ConvertSidToU2Trustee(
                    pszServerName,
                    Credentials,
                    pSid,
                    szAccountName
                    );

        if (SUCCEEDED(hr)) {

            pszAccountName = AllocADsStr(szAccountName);
            if (!pszAccountName) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            *ppszAccountName = pszAccountName;

        }

    } 
    else {
        //
        // This is NTDS case where we need to stringize SID.
        //
        hr = E_FAIL;
    }


    if (FAILED(hr)) {

        hr = ConvertSidToString(
                    pSid,
                    szAccountName
                    );
        BAIL_ON_FAILURE(hr);
        pszAccountName = AllocADsStr(szAccountName);
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *ppszAccountName = pszAccountName;
    }


error:

    RRETURN(hr);
}

HRESULT
ConvertSidToFriendlyName2(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PSID pSid,
    LPWSTR * ppszAccountName,
    BOOL fNTDS
    )
{
    HRESULT hr = S_OK;
    SID_NAME_USE eUse;
    WCHAR szAccountName[MAX_PATH];
    WCHAR szDomainName[MAX_PATH];
    WCHAR szServerName[MAX_PATH];
    DWORD dwLen = 0;
    DWORD dwRet = 0;

    LPWSTR pszAccountName = NULL;

    DWORD dwAcctLen = 0;
    DWORD dwDomainLen = 0;


    //
    // parse Trustee and determine whether its NTDS or U2
    //

    if (fNTDS) {

        dwAcctLen = MAX_PATH;
        dwDomainLen = MAX_PATH;

        //
        // Servername is specified
        //
        if (pszServerName) {

            dwRet = LookupAccountSid(
                        pszServerName,
                        pSid,
                        szAccountName,
                        &dwAcctLen,
                        szDomainName,
                        &dwDomainLen,
                        (PSID_NAME_USE)&eUse
                        );
            
        }
        //
        // Servername not specified
        //
        else {

            //
            // If using serverless paths, try it first on the DC
            //                   

            DWORD dwStatus = GetDomainDNSNameForDomain(
                                        NULL,
                                        FALSE, // don't force verify
                                        FALSE, // not writable
                                        szServerName,
                                        szDomainName
                                        );

            if (dwStatus == NO_ERROR) {

                dwRet = LookupAccountSid(
                            szServerName,
                            pSid,
                            szAccountName,
                            &dwAcctLen,
                            szDomainName,
                            &dwDomainLen,
                            (PSID_NAME_USE)&eUse
                            );

                //
                // If the lookup failed because the server was unavailable, try to get
                // the server again, this time forcing DsGetDcName to do rediscovery
                //
                if (!dwRet && (GetLastError() == RPC_S_SERVER_UNAVAILABLE)) {
                    
                    dwStatus = GetDomainDNSNameForDomain(
                                            NULL,
                                            TRUE, // force verify
                                            FALSE,// not writable
                                            szServerName,
                                            szDomainName
                                        );

                    if (dwStatus == NO_ERROR) {
 
                        dwRet = LookupAccountSid(
                                    szServerName,
                                    pSid,
                                    szAccountName,
                                    &dwAcctLen,
                                    szDomainName,
                                    &dwDomainLen,
                                    (PSID_NAME_USE)&eUse
                                    );
                    }
                }
            }
        }

        //
        // At last try with NULL server name 
        //
        if (!dwRet) {
            
            dwAcctLen = MAX_PATH;
            dwDomainLen = MAX_PATH;
            
            dwRet = LookupAccountSid(
                        NULL,
                        pSid,
                        szAccountName,
                        &dwAcctLen,
                        szDomainName,
                        &dwDomainLen,
                        (PSID_NAME_USE)&eUse
                        );
        }

        if (!dwRet) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }else {

            dwLen = wcslen(szAccountName) + wcslen(szDomainName) + 1 + 1;

            pszAccountName = (LPWSTR)AllocADsMem(dwLen * sizeof(WCHAR));
            if (!pszAccountName) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            if (szDomainName[0] && szAccountName[0]) {
                wsprintf(pszAccountName,L"%s\\%s",szDomainName, szAccountName);
            }else if (szAccountName[0]) {
                wsprintf(pszAccountName,L"%s", szAccountName);
            }

            *ppszAccountName = pszAccountName;

        }

    }

    else {

        hr = ConvertSidToU2Trustee(
                    pszServerName,
                    Credentials,
                    pSid,
                    szAccountName
                    );

        if (SUCCEEDED(hr)) {

            pszAccountName = AllocADsStr(szAccountName);
            if (!pszAccountName) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            *ppszAccountName = pszAccountName;

        }

    } 
    

    if (FAILED(hr)) {

        hr = ConvertSidToString(
                    pSid,
                    szAccountName
                    );
        BAIL_ON_FAILURE(hr);
        pszAccountName = AllocADsStr(szAccountName);
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *ppszAccountName = pszAccountName;
    }


error:

    RRETURN(hr);
}



HRESULT
ConvertACLToVariant(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    PACL pACL,
    PVARIANT pvarACL,
    BOOL fNTDS
    )
{
    IADsAccessControlList * pAccessControlList = NULL;
    IDispatch * pDispatch = NULL;
    LPWSTR pszFriendlyName = NULL;

    VARIANT varAce;
    DWORD dwAclSize = 0;
    DWORD dwAclRevision = 0;
    DWORD dwAceCount = 0;

    ACL_SIZE_INFORMATION AclSize;
    ACL_REVISION_INFORMATION AclRevision;
    DWORD dwStatus = 0;

    DWORD i = 0;
    DWORD dwNewAceCount = 0;

    HRESULT hr = S_OK;
    LPBYTE pAceAddress = NULL;
    LSA_HANDLE hLsaPolicy = NULL;
    PLSA_REFERENCED_DOMAIN_LIST pLsaRefDomList = NULL;
    PLSA_TRANSLATED_NAME pLsaNames = NULL;

    PSID *pSidArray = NULL;


    memset(&AclSize, 0, sizeof(ACL_SIZE_INFORMATION));
    memset(&AclRevision, 0, sizeof(ACL_REVISION_INFORMATION));


    dwStatus = GetAclInformation(
                        pACL,
                        &AclSize,
                        sizeof(ACL_SIZE_INFORMATION),
                        AclSizeInformation
                        );
    //
    // Status should be nonzero for success
    //
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwStatus = GetAclInformation(
                        pACL,
                        &AclRevision,
                        sizeof(ACL_REVISION_INFORMATION),
                        AclRevisionInformation
                        );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwAceCount = AclSize.AceCount;
    dwAclRevision = AclRevision.AclRevision;

    VariantInit(pvarACL);

    hr = CoCreateInstance(
                CLSID_AccessControlList,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlList,
                (void **)&pAccessControlList
                );
    BAIL_ON_FAILURE(hr);


    // 
    // Do this only when we actually have ACE
    //
    if(dwAceCount > 0) {
    	

        //
        // Sid lookup can be optimized only for NT style SD's.
        // SiteServer style SD's will continue to be processed as before.
        //
        if (fNTDS) {
            //
            // To speed up the conversion of SID's to trustees, an array of
            // SID's to lookup is built and the whole array processed in one
            // shot. Then the result of the Lookup is used in contstructing
            // the individual ACE's.
            //
              	
            pSidArray = (PSID*) AllocADsMem(sizeof(PSID) * dwAceCount);
            if (!pSidArray) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        
            for (i = 0; i < dwAceCount; i++) {
                dwStatus = GetAce(pACL, i , (void **) &pAceAddress);
                if (!dwStatus) {
                    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
                }
    
                pSidArray[i] = ComputeSidFromAceAddress(pAceAddress);
    
                //
                // Sanity check we should always have valid data.
                //
                if (!pSidArray[i]) {
                    BAIL_ON_FAILURE(hr = E_FAIL);
                }
            }
    
            hr = GetLsaPolicyHandle(
                     pszServerName,
                     Credentials,
                     &hLsaPolicy
                 );
    
            //
            // Should we just convert to string SID's ?
            //
            BAIL_ON_FAILURE(hr);

            hr = GetNamesFromSids(
                     hLsaPolicy,
                     pSidArray,
                     dwAceCount,
                     &pLsaRefDomList,
                     &pLsaNames
                     );
            BAIL_ON_FAILURE(hr);

    	
        }

        for (i = 0; i < dwAceCount; i++) {

            if (pszFriendlyName) {
                FreeADsStr(pszFriendlyName);
                pszFriendlyName = NULL;
            }

            dwStatus = GetAce(pACL, i, (void **)&pAceAddress);

            //
            // Need to verify we got back the ace correctly.
            //
            if (!dwStatus) {
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
            }

            if(fNTDS) {
            	hr = GetNameForSidFromArray(
                         i,
                         pLsaRefDomList,
                         pLsaNames,
                         &pszFriendlyName
                         );
            }
        
            //
            // We can ignore the failure.
            // On failure pszFriendlyName is set to NULL in which case
            // we will convert to stringised sid format (for NTDS of course).
            //
            hr = ConvertAceToVariant(
                     pszServerName,
                     pszFriendlyName,
                     Credentials,
                     pAceAddress,
                     (PVARIANT)&varAce,
                     fNTDS
                     );
            //
            // If we cannot convert an ACE we should error out.
            //
            BAIL_ON_FAILURE(hr);
 
            hr = pAccessControlList->AddAce(V_DISPATCH(&varAce));

            VariantClear(&varAce);

            BAIL_ON_FAILURE(hr);

            dwNewAceCount++;

            
        }

    }

    pAccessControlList->put_AclRevision(dwAclRevision);

    pAccessControlList->put_AceCount(dwNewAceCount);


    hr = pAccessControlList->QueryInterface(
                        IID_IDispatch,
                        (void **)&pDispatch
                        );
    V_VT(pvarACL) = VT_DISPATCH;
    V_DISPATCH(pvarACL) = pDispatch;

error:

    if (pAccessControlList) {

        pAccessControlList->Release();
    }

    if (pszFriendlyName) {
        FreeADsStr(pszFriendlyName);
    }

    if (pLsaNames) {
        LsaFreeMemory(pLsaNames);
    }
    if (pLsaRefDomList) {
        LsaFreeMemory(pLsaRefDomList);
    }
    if (hLsaPolicy) {
        LsaClose(hLsaPolicy);
    }

    if(pSidArray) {
        FreeADsMem(pSidArray);
    }


    RRETURN(hr);
}



HRESULT
ConvertAceToVariant(
    LPWSTR pszServerName,
    LPWSTR pszTrusteeName,
    CCredentials& Credentials,
    PBYTE pAce,
    PVARIANT pvarAce,
    BOOL fNTDS
    )
{
    IADsAccessControlEntry * pAccessControlEntry = NULL;
    IDispatch * pDispatch = NULL;
    IADsAcePrivate *pPrivAce = NULL;

    DWORD dwAceType = 0;
    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    DWORD dwLenSid = 0;
    DWORD dwErr = 0;
    LPWSTR pszAccountName = NULL;
    PACE_HEADER pAceHeader = NULL;
    LPBYTE pSidAddress = NULL;
    LPBYTE pOffset = NULL;
    DWORD dwFlags = 0;

    GUID ObjectGUID;
    GUID InheritedObjectGUID;
    BSTR bstrObjectGUID = NULL;
    BSTR bstrInheritedObjectGUID = NULL;

    HRESULT hr = S_OK;

    VariantInit(pvarAce);

    hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (void **)&pAccessControlEntry
                );
    BAIL_ON_FAILURE(hr);

    pAceHeader = (ACE_HEADER *)pAce;


    dwAceType = pAceHeader->AceType;
    dwAceFlags = pAceHeader->AceFlags;
    dwAccessMask = *(PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        pSidAddress =  (LPBYTE)pAceHeader + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
        dwFlags = (DWORD)(*(PDWORD)pOffset);

        //
        // Now advance by the size of the flags
        //
        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(&ObjectGUID, pOffset, sizeof(GUID));

            hr = BuildADsGuid(ObjectGUID, &bstrObjectGUID);
            BAIL_ON_FAILURE(hr);

            pOffset += sizeof (GUID);

        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            memcpy(&InheritedObjectGUID, pOffset, sizeof(GUID));

            hr = BuildADsGuid(InheritedObjectGUID, &bstrInheritedObjectGUID);
            BAIL_ON_FAILURE(hr);

            pOffset += sizeof (GUID);

        }

        pSidAddress = pOffset;
        break;

    default:
        break;

    }

    if (pSidAddress) {
        //
        // Nt4 does not reset the last error correctly.
        //
        SetLastError(NO_ERROR);

        dwLenSid = GetLengthSid(pSidAddress);

        if ((dwErr = GetLastError()) != NO_ERROR) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
        }
    } 
    else {
        //
        // We should always have a valid sid address here.
        // Should we be bailing here ? Or for that matter,
        // should be bail on the default cluase of the switch ?
        //
        dwLenSid = 0;
    }

    //
    // Call the old function only if we could not resolve the name
    //
    if (!pszTrusteeName) {
        hr = ConvertSidToFriendlyName(
                pszServerName,
                Credentials,
                pSidAddress,
                &pszAccountName,
                fNTDS
                );
    } 

    if (FAILED(hr)){
        pszAccountName = AllocADsStr(L"Unknown Trustee");
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    //
    // Now set all the information in the Access Control Entry
    //

    hr = pAccessControlEntry->put_AccessMask(dwAccessMask);
    hr = pAccessControlEntry->put_AceFlags(dwAceFlags);
    hr = pAccessControlEntry->put_AceType(dwAceType);

    //
    // Extended ACE information
    //
    hr = pAccessControlEntry->put_Flags(dwFlags);

    if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Object Type GUID
        //
        hr = pAccessControlEntry->put_ObjectType(bstrObjectGUID);

    }

    if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Inherited Object Type GUID
        //

        hr = pAccessControlEntry->put_InheritedObjectType(
                 bstrInheritedObjectGUID
                 );
    }

    //
    // This is a string, so need to check the ecode. We use the
    // friendlyName if that was set and if not the pszAccountName.
    //
    hr = pAccessControlEntry->put_Trustee(
                                  pszTrusteeName ?
                                      pszTrusteeName :
                                      pszAccountName
                                  );
    BAIL_ON_FAILURE(hr);

    if (pSidAddress) {
        //
        // We should now put the SID on this ACE for quick reverse lookup.
        //
        hr = pAccessControlEntry->QueryInterface(
                 IID_IADsAcePrivate,
                 (void **)&pPrivAce
                 );
        
        if SUCCEEDED(hr) {


            hr = pPrivAce->putSid(
                     pSidAddress,
                     dwLenSid
                     );
        }
        //
        // No bail on failure here as it is not a critical failure
        //
    }

    hr = pAccessControlEntry->QueryInterface(
                IID_IDispatch,
                (void **)&pDispatch
                );
    BAIL_ON_FAILURE(hr);

    V_DISPATCH(pvarAce) =  pDispatch;
    V_VT(pvarAce) = VT_DISPATCH;

cleanup:

    if (pszAccountName) {
        FreeADsStr(pszAccountName);
    }

    if (pAccessControlEntry) {
        pAccessControlEntry->Release();
    }

    if (pPrivAce) {
        pPrivAce->Release();
    }

    if (bstrObjectGUID) {
        ADsFreeString(bstrObjectGUID);
    }

    if (bstrInheritedObjectGUID) {
        ADsFreeString(bstrInheritedObjectGUID);
    }

    RRETURN(hr);


error:

    if (pDispatch) {

        pDispatch->Release();

    }

    goto cleanup;
}


//+---------------------------------------------------------------------------
// Function:   ComputeSidFromAceAddress - helper routine.
//
// Synopsis:   Returns the pointer to the SID, given a ptr to an ACE.
//
// Arguments:  pAce              -  ptr to the ACE.
//
// Returns:    NULL on error or valid PSID.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
PSID
ComputeSidFromAceAddress(
    LPBYTE pAce
    )
{
    PSID pSidRetVal = NULL;
    PACE_HEADER pAceHeader = NULL;
    LPBYTE pOffset = NULL;
    DWORD dwAceType, dwAceFlags, dwAccessMask;
    DWORD dwFlags;

    pAceHeader = (ACE_HEADER *)pAce;

    dwAceType = pAceHeader->AceType;
    dwAceFlags = pAceHeader->AceFlags;
    dwAccessMask = *(PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        pSidRetVal =  (LPBYTE)pAceHeader 
                      + sizeof(ACE_HEADER)
                      + sizeof(ACCESS_MASK);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        pOffset = (LPBYTE)((LPBYTE)pAceHeader 
                           + sizeof(ACE_HEADER) 
                           + sizeof(ACCESS_MASK)
                           );
        dwFlags = (DWORD)(*(PDWORD)pOffset);

        //
        // Now advance by the size of the flags
        //
        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            pOffset += sizeof (GUID);

        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

            pOffset += sizeof (GUID);

        }

        pSidRetVal = pOffset;
        break;

    default:
        break;

    } // end of switch case.

    return pSidRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\sql\macro.h ===
#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }





















































=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\sql\lexer.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    lexer.cxx

Abstract:

    This module implements functions to recognize the tokens in the string
    repressentation of the search filter. The format of the search filter
    according to Minimal SQL grammar which is a subset of ANSI SQL 92. 

Author:

    Shankara Shastry [ShankSh]    13-Dec-1996

++*/

#include "lexer.hxx"
#include "macro.h"

DFA_STATE  CLexer::_pStateTable[MAX_DFA_STATES][MAX_CHAR_CLASSES] = gStateTable;

WCHAR CLexer::_pKeywordTable[][MAX_KEYWORD_LEN] = gKWTable;
DWORD CLexer::_pKW2Token[] = gKW2Token;

DWORD CLexer::_pCharClassTable[] = gCharClassTable;

//+---------------------------------------------------------------------------
// Function: CLexer
//
// Synopsis: Constructor: Allocate memory for the pattern and initialize
//
// Arguments: szBuffer: pattern
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer(
    LPWSTR szBuffer
    ):
                _ptr(NULL),
                _Buffer(NULL),
                _dwEndofString(0),
                _dwState(START_STATE),
                _lexeme()
{
    _bInitialized = FALSE;
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = (LPWSTR) AllocADsMem(
                            (wcslen(szBuffer)+1) * sizeof(WCHAR)
                            );
    if(_Buffer)
        wcscpy(_Buffer,
               szBuffer
               );
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function: GetNextToken
//
// Synopsis: Give the next valid token
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetNextToken(
    LPWSTR *ppszToken,
    LPDWORD pdwToken
    )
{
        HRESULT hr = S_OK;
    WCHAR wcNextChar;
    DWORD dwActionId;
    DFA_STATE dfaState;
    DWORD dwStartState = _dwState;
    // If there is no pattern
    if(!_ptr) {
        *pdwToken = TOKEN_END;
        RRETURN (S_OK);
    }

    // Start forming the lexeme.

    _lexeme.ResetLexeme();

    *ppszToken = NULL;
    *pdwToken = TOKEN_ERROR;

    while (_dwState != STATE_ERROR && _dwState < FINAL_STATES_BEGIN) {
        // Get the character class from the character and then index the
        // state table
        wcNextChar = NextChar();
        dwActionId = _pStateTable[_dwState][GetCharClass(wcNextChar)].
                        dwActionId;

        _dwState = _pStateTable[_dwState][GetCharClass(wcNextChar)].
                        dwNextState;

        if(_dwState == STATE_ERROR) {
            BAIL_ON_FAILURE (E_FAIL);
        }

        hr = PerformAction(_dwState,
                           wcNextChar,
                           dwActionId);
        BAIL_ON_FAILURE (hr);
    }

    _bInitialized = TRUE;
    
    if(*pdwToken == TOKEN_END)
        RRETURN (S_OK);

    *ppszToken = _lexeme.GetLexeme();
    *pdwToken = GetTokenFromState(_dwState);

    _dwStateSave = _dwState;
    
    _dwState = START_STATE;

    RRETURN (S_OK);

error:
    RRETURN (hr);
}

//+---------------------------------------------------------------------------
// Function: NextChar
//
// Synopsis: Returns the next chaarcter in the pattern
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function: GetCurrentToken
//
// Synopsis: Give the current valid token, and do not advance unless
//           it is the first token
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetCurrentToken(
    LPWSTR *ppszToken,
    LPDWORD pdwToken
    )
{
    if (!_bInitialized) {
        HRESULT hr;
        hr = GetNextToken(
                    ppszToken,
                    pdwToken
                    );
        return hr;
    } else {
        *ppszToken = _lexeme.GetLexeme();
        *pdwToken = GetTokenFromState(_dwStateSave);
        return (S_OK);
    }
}

//+---------------------------------------------------------------------------
// Function: PushbackChar
//
// Synopsis: Puts back a character to the unrecognised pattern
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

HRESULT
CLexer::PerformAction(
            DWORD dwCurrState,
            WCHAR wcCurrChar,
            DWORD dwActionId
            )
{
   HRESULT hr = S_OK;

   switch(dwActionId) {
       case ACTION_PUSHBACK_CHAR:
           PushbackChar();
           break;
       case ACTION_IGNORE_ESCAPECHAR:
           break;
       case ACTION_DEFAULT:
           hr = _lexeme.PushNextChar(wcCurrChar);
           BAIL_ON_FAILURE(hr);
           break;
   }

   if(_dwState >= FINAL_STATES_BEGIN)
       _lexeme.PushNextChar(L'\0');

error:
   RRETURN (hr);
}

//+---------------------------------------------------------------------------
// Function: CLexer::GetTokenFromState
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
inline DWORD
CLexer::GetTokenFromState(
            DWORD dwCurrState
            )
{
    DWORD dwToken = dwCurrState - FINAL_STATES_BEGIN;
    LPWSTR pszToken = _lexeme.GetLexeme();

    if(dwToken != TOKEN_USER_DEFINED_NAME) 
       return dwToken;

    for (int i=0; _pKeywordTable[i][0] != '\0'; i++) {
        if(!_wcsicmp(pszToken, _pKeywordTable[i]))
           return (_pKW2Token[i]);
    }

    return (TOKEN_USER_DEFINED_NAME);
}

//+---------------------------------------------------------------------------
// Function: ~CLexer
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    if( _Buffer )
        FreeADsMem (_Buffer);

}

//+---------------------------------------------------------------------------
// Function: CLexeme
//
// Synopsis: Constructor: Allocate memory for the pattern and initialize
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CLexeme::CLexeme(
    ):
        _dwMaxLength(0),
        _dwIndex(0)
{
    _pszLexeme = (LPWSTR) AllocADsMem(LEXEME_UNIT_LENGTH * sizeof(WCHAR));
    if(_pszLexeme)
        _dwMaxLength = LEXEME_UNIT_LENGTH;
}

//+---------------------------------------------------------------------------
// Function: ~CLexeme
//
// Synopsis: Destructor
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------

CLexeme::~CLexeme(
    )
{
    if(_pszLexeme)
        FreeADsMem(_pszLexeme);
}

//+---------------------------------------------------------------------------
// Function: PushNextChar
//
// Synopsis: Add the next character after making sure there is enough memory
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    07-09-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexeme::PushNextChar(
    WCHAR wcNextChar
    )
{
    HRESULT hr = S_OK;
    if(_dwIndex >= _dwMaxLength)
    {
        LPWSTR pszNewLexeme = (LPWSTR) ReallocADsMem(
                                    _pszLexeme,
                                    _dwMaxLength * sizeof(WCHAR),
                                    (_dwMaxLength + LEXEME_UNIT_LENGTH)* sizeof(WCHAR) 
                                    );
        if (!pszNewLexeme) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        _pszLexeme = pszNewLexeme;
        _dwMaxLength += LEXEME_UNIT_LENGTH;
    }

    _pszLexeme[_dwIndex++] = wcNextChar;

error:
    RRETURN (hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\var2sec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for nds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop

CRITICAL_SECTION g_StringsCriticalSection;
WCHAR g_szBuiltin[100];
WCHAR g_szNT_Authority[100];
WCHAR g_szAccountOperators[100];
WCHAR g_szPrintOperators[100];
WCHAR g_szBackupOperators[100];
WCHAR g_szServerOperators[100];
WCHAR g_szPreWindows2000[100];

BOOL g_fStringsLoaded = FALSE;

//
// Global variables for dynamically loaded fn's.
//
HANDLE g_hDllAdvapi32 = NULL;
BOOL g_fDllsLoaded = FALSE;

extern "C" {

    HRESULT
        ConvertSidToString(
            PSID pSid,
            LPWSTR   String
            );
}

DWORD
GetDomainDNSNameForDomain(
    LPWSTR pszDomainFlatName,
    BOOL fVerify,
    BOOL fWriteable,
    LPWSTR pszServerName,
    LPWSTR pszDomainDNSName
    );

#define GetAce          ADSIGetAce

#define AddAce          ADSIAddAce

#define DeleteAce       ADSIDeleteAce

#define GetAclInformation       ADSIGetAclInformation

#define SetAclInformation       ADSISetAclInformation

#define IsValidAcl              ADSIIsValidAcl

#define InitializeAcl           ADSIInitializeAcl

#define SetSecurityDescriptorControl    ADSISetControlSecurityDescriptor


#define SE_VALID_CONTROL_BITS ( SE_DACL_UNTRUSTED | \
                                SE_SERVER_SECURITY | \
                                SE_DACL_AUTO_INHERIT_REQ | \
                                SE_SACL_AUTO_INHERIT_REQ | \
                                SE_DACL_AUTO_INHERITED | \
                                SE_SACL_AUTO_INHERITED | \
                                SE_DACL_PROTECTED | \
                                SE_SACL_PROTECTED )

BOOL
EquivalentServers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    );


HRESULT
SecCreateSidFromArray (
    OUT PSID                        *PPSid,
    IN  PSID_IDENTIFIER_AUTHORITY   PSidAuthority,
    IN  UCHAR                       SubAuthorityCount,
    IN  ULONG                       SubAuthorities[],
    OUT PDWORD                      pdwSidSize
    );

HRESULT
ConvertStringToSid(
    IN  PWSTR       string,
    OUT PSID       *sid,
    OUT PDWORD     pdwSidSize    
    );

HRESULT
AddFilteredACEs(
    PACL         pAcl,
    DWORD        dwAclRevision,
    PACE_HEADER *ppAceHdr,
    DWORD        dwCountACEs,
    DWORD       *pdwAclPosition,
    BOOL         fInheritedACEs,
    BOOL         fDenyACEs,
    BOOL         fDenyObjectACEs,
    BOOL         fGrantACEs,
    BOOL         fGrantObjectACEs,
    BOOL         fAuditACEs
    );

//
// These wrapper functions are needed as some fn's need to
// be loaded dynamically as they are not available on NT4
//
#define SET_SD_CONTROL_API  "SetSecurityDescriptorControl"

// load library helper

HMODULE LoadLibraryHelper(
    LPTSTR pszFileName
    )
{
    const DWORD iSize = GetSystemDirectory(NULL, 0);
    TCHAR* buffer = NULL;
    DWORD dwTemp = 0;
    HMODULE handle = NULL;

    if(iSize == 0)
    {        
        goto error;
    }

    buffer = new TCHAR[iSize + _tcslen(__TEXT("\\")) + _tcslen(pszFileName)];  // iSize includes the NULL terminiator
    if(!buffer)
    {        
        goto error;
    }

    dwTemp = GetSystemDirectory(buffer, iSize);
    if(dwTemp == 0)
    {
        goto error;
    }

    _tcscat(buffer, __TEXT("\\"));
    _tcscat(buffer, pszFileName);

    handle = LoadLibrary(buffer);

error:

    if(buffer)
    {
        delete [] buffer;
        buffer = NULL;
    }
    return handle;    
        
}


//
// Helper that loads functions in advapi32.
//
PVOID LoadAdvapi32Function(CHAR *function)
{
    //
    // Since the strings critical section is only used in this file,
    // be fine just re-using it here.
    //
    if (!g_fDllsLoaded) {
        EnterCriticalSection(&g_StringsCriticalSection);
        if (!g_fDllsLoaded) {
            g_hDllAdvapi32 = LoadLibraryHelper(L"ADVAPI32.DLL");
            //
            // Even if this fails, there is nothing we can do.
            //
            g_fDllsLoaded = TRUE;
        }
        LeaveCriticalSection(&g_StringsCriticalSection);
    }

    if (g_hDllAdvapi32) {
        return((PVOID*) GetProcAddress((HMODULE) g_hDllAdvapi32, function));
    }

    return NULL;
}


typedef DWORD (*PF_SetSecurityDescriptorControl) (
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    );

//
// Wrapper function for the same.
//
DWORD SetSecurityDescriptorControlWrapper(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    )
{
    static PF_SetSecurityDescriptorControl pfSetSecDescControl = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfSetSecDescControl == NULL) {
        pfSetSecDescControl = (PF_SetSecurityDescriptorControl)
                                    LoadAdvapi32Function(SET_SD_CONTROL_API);
        f_LoadAttempted = TRUE;
    }

    if (pfSetSecDescControl != NULL) {
        return ((*pfSetSecDescControl)(
                      pSecurityDescriptor,
                      ControlBitsOfInterest,
                      ControlBitsToSet
                      )
                );
    }
    else {
        //
        // This will call the routine in acledit.cxx.
        // We should be in this codepath only in pre win2k
        // machines.
        //
        return SetSecurityDescriptorControl(
                   pSecurityDescriptor,
                   ControlBitsOfInterest,
                   ControlBitsToSet
                   );
    }

}

HRESULT
ConvertSecurityDescriptorToSecDes(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsSecurityDescriptor FAR * pSecDes,
    PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    PDWORD pdwSDLength,
    BOOL fNTDSType
    )
{
    HRESULT hr = S_OK;

    SECURITY_DESCRIPTOR AbsoluteSD;
    PSECURITY_DESCRIPTOR pRelative = NULL;
    BOOL Defaulted = FALSE;
    BOOL DaclPresent = FALSE;
    BOOL SaclPresent = FALSE;

    BOOL fDaclDefaulted = FALSE;
    BOOL fSaclDefaulted = FALSE;
    BOOL fOwnerDefaulted = FALSE;
    BOOL fGroupDefaulted = FALSE;

    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    DWORD   dwSDLength = 0;
    BOOL dwStatus = 0;

    DWORD dwControl = 0;
    DWORD dwRevision = 0;

    hr = pSecDes->get_Revision((long *)&dwRevision);
    BAIL_ON_FAILURE(hr);

    dwStatus = InitializeSecurityDescriptor (
                &AbsoluteSD,
                dwRevision
                );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = pSecDes->get_Control((long *)&dwControl);
    BAIL_ON_FAILURE(hr);


    dwStatus = SetSecurityDescriptorControlWrapper(
                    &AbsoluteSD,
                    SE_VALID_CONTROL_BITS,
                    (SECURITY_DESCRIPTOR_CONTROL) (dwControl & SE_VALID_CONTROL_BITS)
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetOwnerSecurityIdentifier(
                pszServerName,
                Credentials,
                pSecDes,
                &pOwnerSid,
                &fOwnerDefaulted,
                fNTDSType
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = SetSecurityDescriptorOwner(
                    &AbsoluteSD,
                    pOwnerSid,
                    fOwnerDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetGroupSecurityIdentifier(
                pszServerName,
                Credentials,
                pSecDes,
                &pGroupSid,
                &fGroupDefaulted,
                fNTDSType
                );
    BAIL_ON_FAILURE(hr);


    dwStatus = SetSecurityDescriptorGroup(
                    &AbsoluteSD,
                    pGroupSid,
                    fGroupDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = GetDacl(
            pszServerName,
            Credentials,
            pSecDes,
            &pDacl,
            &fDaclDefaulted,
            fNTDSType
            );
    BAIL_ON_FAILURE(hr);


    if (pDacl || fDaclDefaulted) {
        DaclPresent = TRUE;
    }

    //
    // This is a special case, basically the DACL is defaulted
    // and pDacl is NULL. In order for this to work correctly,
    // pDacl should be an empty ACL not null.
    //
    if (DaclPresent && !pDacl) {
        pDacl = (PACL) AllocADsMem(sizeof(ACL));
        if (!pDacl) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        dwStatus = InitializeAcl(
                       pDacl,
                       sizeof(ACL),
                       ACL_REVISION // this revision will work for NT4 and Win2k
                       );
        if (!dwStatus) {
            hr  = HRESULT_FROM_WIN32(GetLastError());
            BAIL_ON_FAILURE(hr);
        }
    }

    dwStatus = SetSecurityDescriptorDacl(
                    &AbsoluteSD,
                    DaclPresent,
                    pDacl,
                    fDaclDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetSacl(
            pszServerName,
            Credentials,
            pSecDes,
            &pSacl,
            &fSaclDefaulted,
            fNTDSType
            );
    BAIL_ON_FAILURE(hr);


    if (pSacl || fSaclDefaulted) {
        SaclPresent = TRUE;
    }

    dwStatus = SetSecurityDescriptorSacl(
                    &AbsoluteSD,
                    SaclPresent,
                    pSacl,
                    fSaclDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    dwSDLength = GetSecurityDescriptorLength(
                        &AbsoluteSD
                        );

    pRelative = AllocADsMem(dwSDLength);
    if (!pRelative) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if (!MakeSelfRelativeSD (&AbsoluteSD, pRelative, &dwSDLength)) {
        FreeADsMem(pRelative);

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    *ppSecurityDescriptor = pRelative;
    *pdwSDLength = dwSDLength;

cleanup:

    if (pDacl) {
        FreeADsMem(pDacl);
    }

    if (pSacl) {
        FreeADsMem(pSacl);
    }

    if (pOwnerSid) {
        FreeADsMem(pOwnerSid);
    }

    if (pGroupSid) {
        FreeADsMem(pGroupSid);
    }

    RRETURN(hr);

error:
    
    *ppSecurityDescriptor = NULL;
    *pdwSDLength = 0;

    goto cleanup;

}

HRESULT
GetOwnerSecurityIdentifier(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfOwnerDefaulted,
    BOOL fNTDSType
    )
{
    BSTR bstrOwner = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Owner(
                    &bstrOwner
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_OwnerDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrOwner && *bstrOwner) {

          hr = ConvertTrusteeToSid(
                    pszServerName,
                    Credentials,
                    bstrOwner,
                    ppSid,
                    &dwSidSize,
                    fNTDSType
                    );
          BAIL_ON_FAILURE(hr);
          *pfOwnerDefaulted = FALSE;
        }else {

            *ppSid = NULL;
            *pfOwnerDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfOwnerDefaulted = TRUE;
    }

error:

    if (bstrOwner) {
        ADsFreeString(bstrOwner);
    }

    RRETURN(hr);
}

HRESULT
GetGroupSecurityIdentifier(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfGroupDefaulted,
    BOOL fNTDSType
    )
{
    BSTR bstrGroup = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Group(
                    &bstrGroup
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_GroupDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrGroup && *bstrGroup) {

            hr = ConvertTrusteeToSid(
                    pszServerName,
                    Credentials,
                    bstrGroup,
                    ppSid,
                    &dwSidSize,
                    fNTDSType
                    );
            BAIL_ON_FAILURE(hr);
            *pfGroupDefaulted = FALSE;
        }else {
            *ppSid = NULL;
            *pfGroupDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfGroupDefaulted = TRUE;
    }

error:

    if (bstrGroup) {
        ADsFreeString(bstrGroup);
    }

    RRETURN(hr);

}

HRESULT
GetDacl(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppDacl,
    PBOOL pfDaclDefaulted,
    BOOL fNTDSType
    )
{
    IADsAccessControlList FAR * pDiscAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_DaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfDaclDefaulted = FALSE;
    }else {
        *pfDaclDefaulted = TRUE;
    }

    hr = pSecDes->get_DiscretionaryAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppDacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pDiscAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pszServerName,
                Credentials,
                pDiscAcl,
                ppDacl,
                fNTDSType
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pDiscAcl) {
        pDiscAcl->Release();
    }

    RRETURN(hr);
}


HRESULT
GetSacl(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppSacl,
    PBOOL pfSaclDefaulted,
    BOOL fNTDSType
    )
{
    IADsAccessControlList FAR * pSystemAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_SaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfSaclDefaulted = FALSE;
    }else {
        *pfSaclDefaulted = TRUE;
    }

    hr = pSecDes->get_SystemAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppSacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pSystemAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pszServerName,
                Credentials,
                pSystemAcl,
                ppSacl,
                fNTDSType
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pSystemAcl) {
        pSystemAcl->Release();
    }

    RRETURN(hr);
}

HRESULT
ConvertAccessControlListToAcl(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsAccessControlList FAR * pAccessList,
    PACL * ppAcl,
    BOOL fNTDSType
    )
{
    IUnknown * pUnknown = NULL;
    IEnumVARIANT * pEnumerator  = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD iAclPosition = 0;
    DWORD cReturned = 0;
    VARIANT varAce;

    DWORD dwAceCount = 0;

    IADsAccessControlEntry FAR * pAccessControlEntry = NULL;

    LPBYTE pTempAce = NULL;
    DWORD dwCount = 0;

    PACL pAcl = NULL;
    DWORD dwAclSize = 0;
    PACE_HEADER * ppAceHdr = NULL;

    DWORD dwRet = 0;
    DWORD dwAclRevision = 0;
    DWORD dwError = 0;

    //
    // Defines the canonical ordering of the ACEs.
    //
    struct AceOrderElement
        { 
        BOOL fInheritedACEs;
        BOOL fDenyACEs;
        BOOL fDenyObjectACEs;
        BOOL fGrantACEs;
        BOOL fGrantObjectACEs;
        BOOL fAuditACEs;
        } AceOrderSequence [] =
            {
              {FALSE, FALSE, FALSE, FALSE, FALSE, TRUE},
              {FALSE, TRUE,  FALSE, FALSE, FALSE, FALSE},
              {FALSE, FALSE, TRUE,  FALSE, FALSE, FALSE},
              {FALSE, FALSE, FALSE, TRUE,  FALSE, FALSE},
              {FALSE, FALSE, FALSE, FALSE, TRUE,  FALSE},

              {TRUE, FALSE, FALSE, FALSE, FALSE, TRUE},
              {TRUE, TRUE,  FALSE, FALSE, FALSE, FALSE},
              {TRUE, FALSE, TRUE,  FALSE, FALSE, FALSE},
              {TRUE, FALSE, FALSE, TRUE,  FALSE, FALSE},
              {TRUE, FALSE, FALSE, FALSE, TRUE,  FALSE}
            };

    DWORD dwAceOrderSequenceLen = sizeof(AceOrderSequence) / sizeof (AceOrderElement);


    hr = pAccessList->get_AceCount((long *)&dwAceCount);
    BAIL_ON_FAILURE(hr);


    hr = pAccessList->get__NewEnum(
                    &pUnknown
                    );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                        IID_IEnumVARIANT,
                        (void FAR * FAR *)&pEnumerator
                        );
    BAIL_ON_FAILURE(hr);



    ppAceHdr = (PACE_HEADER *)AllocADsMem(sizeof(PACE_HEADER)*dwAceCount);
    if (!ppAceHdr) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwAceCount; i++) {

        VariantInit(&varAce);

        hr = pEnumerator->Next(
                    1,
                    &varAce,
                    &cReturned
                    );

        //
        // Need to BAIL here as we could not convert an ACL.
        //
        BAIL_ON_FAILURE(hr);


        hr = (V_DISPATCH(&varAce))->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (void **)&pAccessControlEntry
                    );

        VariantClear(&varAce);
        
        BAIL_ON_FAILURE(hr);


        hr = ConvertAccessControlEntryToAce(
                    pszServerName,
                    Credentials,
                    pAccessControlEntry,
                    &(pTempAce),
                    fNTDSType
                    );

        if (pAccessControlEntry) {
            pAccessControlEntry->Release();
            pAccessControlEntry = NULL;
        }
        
        BAIL_ON_FAILURE(hr);



        *(ppAceHdr + dwCount) = (PACE_HEADER)pTempAce;

        
        

        dwCount++;
    }

    hr = ComputeTotalAclSize(ppAceHdr, dwCount, &dwAclSize);
    BAIL_ON_FAILURE(hr);

    pAcl = (PACL)AllocADsMem(dwAclSize);
    if (!pAcl) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = pAccessList->get_AclRevision((long *)&dwAclRevision);
    BAIL_ON_FAILURE(hr);


    dwRet  = InitializeAcl(
                    pAcl,
                    dwAclSize,
                    dwAclRevision
                    );
    if (!dwRet) {
        hr  = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    //
    // Add the ACEs in canonical ordering:
    //   All Explitic Audit
    //   All Explicit Deny
    //   All Explicit Object Deny
    //   All Explicit Allow
    //   All Explicit Object Allow
    //
    //   All Inherited Audit
    //   All Inherited Deny
    //   All Inherited Object Deny
    //   All Inherited Allow
    //   All Inherited Object Allow
    //

    for (i=0; i < dwAceOrderSequenceLen; i++) {

        hr = AddFilteredACEs(
                         pAcl,
                         dwAclRevision,
                         ppAceHdr,
                         dwCount,
                         &iAclPosition,
                         AceOrderSequence[i].fInheritedACEs,
                         AceOrderSequence[i].fDenyACEs,
                         AceOrderSequence[i].fDenyObjectACEs,
                         AceOrderSequence[i].fGrantACEs,
                         AceOrderSequence[i].fGrantObjectACEs,
                         AceOrderSequence[i].fAuditACEs
                         );
        BAIL_ON_FAILURE(hr);
    }

  
    *ppAcl = pAcl;



error:

    if (ppAceHdr) {
        for (i = 0; i < dwCount; i++) {
            if (*(ppAceHdr + i)) {

                FreeADsMem(*(ppAceHdr + i));
            }
        }

        FreeADsMem(ppAceHdr);
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }

    if(FAILED(hr) && pAcl)
    {
        FreeADsMem(pAcl);
    }


    RRETURN(hr);
}

/*
 * AddFilteredACEs
 *
 * Adds ACEs from ppAceHdr (of size dwCountACEs) to the ACL pAcl
 * (of revision dwAclRevision), starting at position *pdwAclPosition in
 * the ACL, based on the filter settings fInheritedACEs, fDenyACEs,
 * fGrantACEs, fDenyObjectACEs, fGrantObjectACEs, and fAuditACEs.
 *
 * On return, *pdwAclPosition is the position to continue adding
 * ACEs at.
 *
 */
HRESULT
AddFilteredACEs(
    PACL         pAcl,              // the ACL to add the ACEs to
    DWORD        dwAclRevision,     // the revision of the ACL
    PACE_HEADER *ppAceHdr,          // the ACEs to add
    DWORD        dwCountACEs,       // number of ACEs in ppAceHdr
    DWORD       *pdwAclPosition,    // starting(in)/ending(out) position
    BOOL         fInheritedACEs,    // include explicit or inherited ACEs?
    BOOL         fDenyACEs,         // include access-deny ACEs?
    BOOL         fDenyObjectACEs,   // include access-deny-object ACEs?
    BOOL         fGrantACEs,        // include access-grant ACEs?
    BOOL         fGrantObjectACEs,  // include access-grant-object ACEs?
    BOOL         fAuditACEs         // include audit ACEs?
    )
{
    HRESULT hr = S_OK;
    DWORD dwStatus;

    DWORD i;
    DWORD iAclPosition = *pdwAclPosition;
    BOOL  fAddIt;

    BOOL  fIsAceInherited;

    for (i = 0; i < dwCountACEs; i++) {

        //
        // Filter based on whether we're adding explicit or inherited ACEs
        //
        fIsAceInherited = (((*(ppAceHdr + i))->AceFlags) & INHERITED_ACE) ? TRUE : FALSE;

        if ( fIsAceInherited == fInheritedACEs) {

            fAddIt = FALSE;

            //
            // Filter based on ACE type
            //
            switch ((*(ppAceHdr + i))->AceType) {
                case ACCESS_ALLOWED_ACE_TYPE:
                    if (fGrantACEs) {
                        fAddIt = TRUE;
                    }
                    break;

                case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                    if (fGrantObjectACEs) {
                        fAddIt = TRUE;
                    }
                    break;

                case ACCESS_DENIED_ACE_TYPE:
                    if (fDenyACEs) {
                        fAddIt = TRUE;
                    }
                    break;
                
                case ACCESS_DENIED_OBJECT_ACE_TYPE:
                    if (fDenyObjectACEs) {
                        fAddIt = TRUE;
                    }
                    break;
                
                case SYSTEM_AUDIT_ACE_TYPE:
                case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
                    if (fAuditACEs) {
                        fAddIt = TRUE;
                    }
                    break;

                default:
                    BAIL_ON_FAILURE(hr = E_INVALIDARG);
                    break;
            }

            //
            // If the ACE met the criteria, add it to the ACL
            //
            if (fAddIt) {
                dwStatus = AddAce(
                                pAcl,
                                dwAclRevision,
                                iAclPosition++,
                                (LPBYTE)*(ppAceHdr + i),
                                (*(ppAceHdr + i))->AceSize
                                );
                                
                if (!dwStatus) {

                    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
                }
            }
        }
    }

error:

    *pdwAclPosition = iAclPosition;
    RRETURN(hr);
}
    

HRESULT
ConvertAccessControlEntryToAce(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    IADsAccessControlEntry * pAccessControlEntry,
    LPBYTE * ppAce,
    BOOL fNTDSType
    )
{

    DWORD dwAceType = 0;
    HRESULT hr = S_OK;
    BSTR bstrTrustee = NULL;
    PSID pSid = NULL;
    DWORD dwSidSize = 0;

    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    DWORD dwAceSize = 0;
    LPBYTE pAce = NULL;
    PACCESS_MASK pAccessMask = NULL;
    PSID pSidAddress = NULL;

    PUSHORT pCompoundAceType = NULL;
    DWORD dwCompoundAceType = 0;

    PACE_HEADER pAceHeader = NULL;

    LPBYTE pOffset = NULL;

    BSTR bstrObjectTypeClsid = NULL;
    BSTR bstrInheritedObjectTypeClsid = NULL;

    GUID ObjectTypeGUID;
    GUID InheritedObjectTypeGUID;
    PULONG pFlags;
    DWORD dwFlags = 0;
    BOOL fLookupTrustee = TRUE;
    BOOL fSidValid = FALSE;
    IADsAcePrivate *pPrivAce = NULL;

    hr = pAccessControlEntry->get_AceType((LONG *)&dwAceType);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_Trustee(&bstrTrustee);
    BAIL_ON_FAILURE(hr);

    //
    // We need to see if we can use a cached SID here.
    //
    hr = pAccessControlEntry->QueryInterface(
             IID_IADsAcePrivate,
             (void **)&pPrivAce
             );
    
    if (SUCCEEDED(hr)) {
        //
        // See if the SID is valid and if so try and retrieve it.
        //
        hr = pPrivAce->isSidValid(&fSidValid);
        if (SUCCEEDED(hr) && fSidValid) {
            
            hr = pPrivAce->getSid(
                     &pSid,
                     &dwSidSize
                     );

            if (SUCCEEDED(hr)) {
                fLookupTrustee = FALSE;
            }
        }

    }


    if (fLookupTrustee) {

        hr = ConvertTrusteeToSid(
                 pszServerName,
                 Credentials,
                 bstrTrustee,
                 &pSid,
                 &dwSidSize,
                 fNTDSType
                 );
    }

    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AceFlags((long *)&dwAceFlags);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AccessMask((long *)&dwAccessMask);
    BAIL_ON_FAILURE(hr);


    //
    // we will compensateby adding the entire ACE size
    //

    dwAceSize = dwSidSize - sizeof(ULONG);

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_DENIED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case SYSTEM_AUDIT_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        dwAceSize += sizeof(COMPOUND_ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

         pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pCompoundAceType = (PUSHORT)(pAccessMask + sizeof(ACCESS_MASK));
        *pCompoundAceType = (USHORT)dwCompoundAceType;

        //
        // Fill in the reserved field here.
        //

        pSidAddress = (PSID)((LPBYTE)pCompoundAceType + sizeof(DWORD));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

    case ACCESS_DENIED_OBJECT_ACE_TYPE:

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:


        hr = pAccessControlEntry->get_AceFlags((LONG *)&dwAceFlags);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_Flags((LONG *)&dwFlags);
        BAIL_ON_FAILURE(hr);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        hr = pAccessControlEntry->get_ObjectType(&bstrObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrObjectTypeClsid, &ObjectTypeGUID);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_InheritedObjectType(&bstrInheritedObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrInheritedObjectTypeClsid, &InheritedObjectTypeGUID);
        BAIL_ON_FAILURE(hr);



        dwAceSize += sizeof(ACCESS_ALLOWED_OBJECT_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        //
        // Fill in Flags
        //

        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));

        pFlags = (PULONG)(pOffset);

        *pFlags = dwFlags;

        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &ObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);

        }


        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &InheritedObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);
        }

        pSidAddress = (PSID)((LPBYTE)pOffset);
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    default:
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_ACL);
        BAIL_ON_FAILURE(hr);
        break;

    }

    *ppAce = pAce;

error:

    if (bstrTrustee) {
        ADsFreeString(bstrTrustee);
    }

    if (pSid) {
        FreeADsMem(pSid);
    }

    if (bstrObjectTypeClsid) {
        SysFreeString(bstrObjectTypeClsid);
    }

    if (bstrInheritedObjectTypeClsid) {
        SysFreeString(bstrInheritedObjectTypeClsid);
    }

    if (pPrivAce) {
        pPrivAce->Release();
    }

    RRETURN(hr);
}

HRESULT
ComputeTotalAclSize(
    PACE_HEADER * ppAceHdr,
    DWORD dwAceCount,
    PDWORD pdwAclSize
    )
{
    DWORD i = 0;
    PACE_HEADER pAceHdr = NULL;
    DWORD dwAceSize = 0;
    DWORD dwAclSize = 0;

    for (i = 0; i < dwAceCount; i++) {

        pAceHdr = *(ppAceHdr + i);
        dwAceSize = pAceHdr->AceSize;
        dwAclSize += dwAceSize;
    }

    dwAclSize += sizeof(ACL);

    *pdwAclSize = dwAclSize;

    RRETURN(S_OK);

}

HRESULT
ParseAccountName(LPWSTR szFullAccountName,
                 LPWSTR *pszUserDomainName,
                 LPWSTR *pszUserAccountName)
{
    HRESULT hr = S_OK;
    DWORD dwDomain = 0;
    BOOLEAN bFound = FALSE;
    LPWSTR szUserDomainName = NULL;
    LPWSTR szUserAccountName = NULL;
    LPWSTR szCount = szFullAccountName;

    if (!szFullAccountName) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    while (*szCount) {
        if (*szCount == '\\') {
            bFound = TRUE;
            break;
        }
        dwDomain++;
        szCount++;
    }

    if (bFound) {
        DWORD dwRest = 0;
        szUserDomainName = (LPWSTR)AllocADsMem(sizeof(WCHAR) * (dwDomain+1));
        if (!szUserDomainName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        wcsncpy(szUserDomainName,
                szFullAccountName,
                dwDomain);
        szUserDomainName[dwDomain] = L'\0';

        szUserAccountName = AllocADsStr(szCount+1);
        if (!szUserAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    else {
        szUserAccountName = AllocADsStr(szFullAccountName);
        if (!szUserAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        szUserDomainName = NULL;
    }
    *pszUserAccountName = szUserAccountName;
    *pszUserDomainName = szUserDomainName;
    return hr;

error:
    if (szUserAccountName) {
        FreeADsMem(szUserAccountName);
    }
    if (szUserDomainName) {
        FreeADsMem(szUserDomainName);
    }
    return hr;
}


HRESULT
ConvertTrusteeToSid(
    LPWSTR pszServerName,
    CCredentials& Credentials,
    BSTR bstrTrustee,
    PSID * ppSid,
    PDWORD pdwSidSize,
    BOOL fNTDSType
    )
{
    HRESULT hr = S_OK;
    BYTE Sid[MAX_PATH];
    DWORD dwSidSize = sizeof(Sid);
    DWORD dwRet = 0;
    DWORD dwErr = 0;
    WCHAR szDomainName[MAX_PATH];
    DWORD dwDomainSize = sizeof(szDomainName)/sizeof(WCHAR);
    SID_NAME_USE eUse;

    PSID pSid = NULL;    

    LPWSTR szUserDomainName = NULL;
    LPWSTR szUserAccountName = NULL;
    LPWSTR szAccountName = NULL;
    BOOL fForceVerify = FALSE;

    //
    // Load the strings into table if necessary
    //
    if (!g_fStringsLoaded) {

        EnterCriticalSection(&g_StringsCriticalSection);

        //
        // Verify flag again.
        //
        if (!g_fStringsLoaded) {

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_BUILTIN,
                        g_szBuiltin,
                        sizeof( g_szBuiltin ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(g_szBuiltin, L"BUILTIN");
            }

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_NT_AUTHORITY,
                        g_szNT_Authority,
                        sizeof( g_szNT_Authority ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(g_szNT_Authority, L"NT AUTHORITY");
            }

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_ACCOUNT_OPERATORS,
                        g_szAccountOperators,
                        sizeof( g_szAccountOperators ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(g_szAccountOperators, L"Account Operators");
            }

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_PRINT_OPERATORS,
                        g_szPrintOperators,
                        sizeof( g_szPrintOperators ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(g_szPrintOperators, L"Print Operators");
            }

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_BACKUP_OPERATORS,
                        g_szBackupOperators,
                        sizeof( g_szBackupOperators ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(g_szBackupOperators, L"Backup Operators");
            }

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_SERVER_OPERATORS,
                        g_szServerOperators,
                        sizeof( g_szServerOperators ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(g_szServerOperators, L"Server Operators");
            }

            dwRet = LoadStringW(
                        g_hInst,
                        ADS_PRE_WIN2000,
                        g_szPreWindows2000,
                        sizeof( g_szPreWindows2000 ) / sizeof( WCHAR )
                        );

            if (!dwRet) {
                //
                // Default to English values.
                //
                wcscpy(
                    g_szPreWindows2000,
                    L"Pre-Windows 2000 Compatible Access"
                    );
            }

        }

        g_fStringsLoaded = TRUE;

        LeaveCriticalSection(&g_StringsCriticalSection);

    }

    //
    //
    // parse Trustee and determine whether its NTDS or U2
    //

    if (fNTDSType) {
        WCHAR szDomainName[MAX_PATH];
        WCHAR szServerName[MAX_PATH];
        LPWSTR szLookupServer = NULL;
        BOOL fSpecialLookup = FALSE;
        BOOL fLookupOnServer = FALSE;
        DWORD dwTmpSidLen = 0;

        dwSidSize = sizeof(Sid);
        szAccountName = bstrTrustee;

        hr = ParseAccountName(bstrTrustee,
                              &szUserDomainName,
                              &szUserAccountName);
        BAIL_ON_FAILURE(hr);

        //
        // Need to look these up on the server only.
        //
        if (szUserAccountName
            && ((_wcsicmp(szUserAccountName, g_szAccountOperators) == 0)
                || (_wcsicmp(szUserAccountName, g_szPrintOperators) == 0)
                || (_wcsicmp(szUserAccountName, g_szBackupOperators) == 0)
                || (_wcsicmp(szUserAccountName, g_szServerOperators) == 0)
                || (_wcsicmp(szUserAccountName, g_szPreWindows2000) == 0)
                )
            ) {
            if (szUserDomainName
                && (_wcsicmp(szUserDomainName, g_szBuiltin)) == 0) {
                fSpecialLookup = TRUE;
            } else {
                fSpecialLookup = FALSE;
            }
        } // special users

        if (fSpecialLookup ||
            (szUserDomainName &&
            (_wcsicmp(szUserDomainName, g_szBuiltin) != 0) &&
            (_wcsicmp(szUserDomainName, g_szNT_Authority) != 0))
            ) {

            //
            // We will come back here and do a force retry
            // if the server is down.
            //
retryForce:
            //
            // Force hr to S_OK. This will be needed especially
            // when we jump to the retryForce label.
            //
            hr = S_OK;

            //
            // Set Lookup on server to true so that later
            // on we do not do the lookup on the server again.
            // In some cases just like we fall back to local machine,
            // we need to look at the server if the local machine fails.
            // this will be the case for mixed locale domains.
            //
            DWORD dwStatus = GetDomainDNSNameForDomain(
                                fSpecialLookup ?
                                    NULL :
                                    szUserDomainName,
                                fForceVerify, // forceVerify
                                FALSE,
                                szServerName,
                                szDomainName
                                );

            fLookupOnServer = TRUE;

            if (dwStatus) {
                szLookupServer = NULL;
            }
            else {
                szLookupServer = szServerName;
            }
            szAccountName = szUserAccountName;
        }

        dwRet = LookupAccountName(
                    szLookupServer,
                    bstrTrustee,
                    Sid,
                    &dwSidSize,
                    szDomainName,
                    &dwDomainSize,
                    (PSID_NAME_USE)&eUse
                    );
        if (!dwRet) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        } 
        else {
            //
            // Update the length of the SID.
            //
            
            //
            // Call needed on NT4 where GetLenghtSid  does not
            // reset the error correctly leading to false errors.
            //
            SetLastError(NO_ERROR);
            
            dwTmpSidLen = GetLengthSid(Sid);
            
            if ((dwRet = GetLastError()) == NO_ERROR) {
                //
                //  Got the correct length so update dwSidSize
                //
                dwSidSize = dwTmpSidLen;
            }
        }

        if (FAILED(hr)
            && hr != HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE)) {

            //
            // This code path should not be hit often but it can
            // happen on multi locale domains. The server when might
            // have returned say Builtin instead of german for the same.
            // If the client is german we will be looking for germanbuiltin
            // and that wont work. The lookup will fail locally but
            // will succeed on the server. This is especially true for
            // Builtin\Print Operators as that can only be resolved on the DC.
            //
            if (pszServerName) {
                //
                // Before we do a dsgetdc, we should try with
                // the serverName passed in.
                //
                hr = S_OK;
                dwRet = LookupAccountName(
                            pszServerName,
                            bstrTrustee,
                            Sid,
                            &dwSidSize,
                            szDomainName,
                            &dwDomainSize,
                            (PSID_NAME_USE)&eUse
                            );
                if (!dwRet) {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    //
                    // force server name to NULL so we wont
                    // try this again.
                    //
                    pszServerName = NULL;
                }
                else {
                    //
                    // Update the length of the SID.
                    //
            
                    //
                    // Call needed on NT4 where GetLenghtSid  does not
                    // reset the error correctly leading to false errors.
                    //
                    SetLastError(NO_ERROR);
            
                    dwTmpSidLen = GetLengthSid(Sid);
            
                    if ((dwRet = GetLastError()) == NO_ERROR) {
                        //
                        //  Got the correct length so update dwSidSize
                        //
                        dwSidSize = dwTmpSidLen;
                    }
                }
            }


            if (FAILED(hr)) {
                //
                // We could be here if either pszServerName was always
                // NULL or if the call to the server failed.
                // The only thing we can do is to retry if we know
                // that the szLookupServer was NULL (that is local machine)
                // or if szLookupServer was something other than the default
                // server for the machine (that is we called DsGetDC with
                // the name of a domain rather than NULL).
                // In all other cases we should not retry and just return
                // the error.
                //


                if (fSpecialLookup) {
                    //
                    // We should not retry in this case as we will not
                    // get anything useful. Setting fLookupOnServer
                    // to true will force this (if you look above this
                    // is not really needed but it helps clear things)
                    //
                    fLookupOnServer = TRUE;
                }
                else {
                    //
                    // This was not a special lookup, so we
                    // need to retry irrespective of what
                    // szLookupServer was.
                    //
                    fLookupOnServer = FALSE;
                    szLookupServer = NULL;
                }

            }

            //
            // This will do the correct thing even if the above
            // LookUpCall failed. If not we should go down this
            // as we can get stuck in an infinite loop.
            //
            if (FAILED(hr)
                && !pszServerName
                && !szLookupServer
                && !fLookupOnServer
                ) {
                //
                // In this case we want to try and call
                // DsGetDCName and hopefully we will get the right
                // DC. fSpecialLookup will be true so that we go to
                // the default DC for the machine/user.
                //
                fSpecialLookup = TRUE;
                goto retryForce;
            }
        }

        //
        // If failure was due to an expected error then retry
        //
        if (FAILED(hr)
            && hr == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE)
            ) {
            if (!fForceVerify) {
                fForceVerify = TRUE;
                goto retryForce;
            }
        }

    }else {

        //
        // We know that LookupAccountName failed,
        // so now try the U2 DS
        //
        dwSidSize = 0;

        hr = ConvertU2TrusteeToSid(
                    pszServerName,
                    Credentials,
                    bstrTrustee,
                    Sid,
                    &dwSidSize
                    );
    }

    //
    // If neither the NTDS nor the U2 conversion
    // worked, then try a textual translation
    //

    if (FAILED(hr)) {

        hr = ConvertStringToSid(
                   bstrTrustee,
                    &pSid,
                    &dwSidSize                    
                    );
        BAIL_ON_FAILURE(hr);

        memcpy(Sid,pSid, dwSidSize);

        if (pSid) {
            LocalFree(pSid);
        }

    }

    //
    // On NT4 for some reason GetLengthSID does not set lasterror to 0
    //
    SetLastError(NO_ERROR);

    dwSidSize = GetLengthSid((PSID) Sid);

    dwErr = GetLastError();

    //
    // This is an extra check to make sure that we have the
    // correct length.
    //
    if (dwErr != NO_ERROR) {
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    BAIL_ON_FAILURE(hr);   ;
    
    pSid = AllocADsMem(dwSidSize);
    if (!pSid) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(pSid, Sid, dwSidSize);

    *pdwSidSize = dwSidSize;

    *ppSid = pSid;

error:

    if (szUserDomainName) {
        FreeADsStr(szUserDomainName);
    };
    if (szUserAccountName) {
        FreeADsStr(szUserAccountName);
    }

    RRETURN(hr);
}


/*
+--------------------------------------------------------------------------------+

    NAME:       get_sid_out_of_string

    FUNCTION:   Convert a string representation of a SID back into
                a sid.  The expected format of the string is:
                L"S-1-5-32-549"

                If a string in a different format or an incorrect or
                incomplete string is given, the operation is failed.

                The returned sid must be free via a call to SEC_FREE.

    Arguments:

                string - The wide string to be converted

                sid - Where the created SID is to be returned

                end - Where in the string we stopped processing

    RETURN:

                NTSTATUS error codes or success.

+--------------------------------------------------------------------------------+
*/
HRESULT
ConvertStringToSid(
    IN  PWSTR       string,
    OUT PSID       *sid,
    OUT PDWORD     pdwSidSize    
    )
{
    HRESULT                     hr = S_OK;
    BOOL                        fResult = FALSE;    

    fResult = ConvertStringSidToSid(string, sid);
    if(fResult)
    {
        fResult = IsValidSid(*sid);
        if(fResult)
        {
            *pdwSidSize = GetLengthSid(*sid);
        }
        else
        {
            if(*sid)
            {
                LocalFree(*sid);
                *sid = NULL;
            }
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
            BAIL_ON_FAILURE(hr);
        }
        
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        BAIL_ON_FAILURE(hr);
    }
    
error:

    RRETURN(hr);
}


HRESULT
SecCreateSidFromArray (
    OUT PSID                        *PPSid,
    IN  PSID_IDENTIFIER_AUTHORITY   PSidAuthority,
    IN  UCHAR                       SubAuthorityCount,
    IN  ULONG                       SubAuthorities[],
    OUT PDWORD                      pdwSidSize
    )
/*++

Routine Description:

    Creates a SID with desired authority and sub authorities.

    NOTE:  This routine allocates memory for the SID.  When finished
           the caller should free memory using SEC_FREE (PSid).

Arguments:

    PPSid -- addr of ptr to SID to be created
        Note: if SID creation fails ptr set to NULL

    PSidAuthority -- desired value for SID authority

    SubAuthorityCount -- number of sub authorities desired

    SubAuthorities -- sub-authority values, MUST SPECIFY contain
        at least SubAuthorityCount number of values

Return Value:

    STATUS_SUCCESS if SID created.
    STATUS_UNSUCCESSFUL otherwise.

--*/
{
    USHORT  iSub;           /*  sub-authority index */
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;

    /*  allocate memory for SID */

    dwSidSize = RtlLengthRequiredSid(SubAuthorityCount);
    *PPSid = (PSID) AllocADsMem( dwSidSize );
    if (! *PPSid){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    *pdwSidSize = dwSidSize;


    /*  initialize SID with top level SID identifier authority */
    RtlInitializeSid( *PPSid, PSidAuthority, SubAuthorityCount);

    /*  fill in sub authorities */
    for (iSub=0; iSub < SubAuthorityCount; iSub++)
        * RtlSubAuthoritySid( *PPSid, iSub) = SubAuthorities[iSub];

    /*  sanity check */

    if ( ! RtlValidSid( *PPSid) ) {
        FreeADsMem( *PPSid);
        *PPSid = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        BAIL_ON_FAILURE(hr);
    }

error:


    RRETURN(hr);
}



BOOL
EquivalentServers(
    LPWSTR pszTargetServer,
    LPWSTR pszSourceServer
    )
{
    if (!pszTargetServer && !pszSourceServer) {
        return(TRUE);
    }

    if (pszTargetServer && pszSourceServer) {

#ifdef WIN95
        if (!_wcsicmp(pszTargetServer, pszSourceServer)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszTargetServer,
                -1,
                pszSourceServer,
                -1
            ) == CSTR_EQUAL ) {
#endif

            return(TRUE);
        }
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\utilprop.cxx ===
//-- == 0-------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  utilprop.cxx
//
//  Contents:
//
//
//  History:   08-28-96     shanksh    Created.
//
//----------------------------------------------------------------------------
// Notes - there are two main methods in this module:
//     - CUtilProps::GetPropertyInfo, a helper function for
//       GetProperty method on Data Source
//     - CUtilProps::GetProperties, a helper function for
//       GetProperties method on Data Source, Session and Command objects
//     - CUtilProps::SetProperties, a helper function for
//       SetProperties method on Data Source, Session and Command objects
//
//
// The implementation is very simple - we keep a global table of the
// properties we support in s_rgprop. We search this table sequentially.
// 

#include "oleds.hxx"
#pragma hdrstop

PROPSTRUCT s_rgDBInitProp[] =
{
    {DBPROP_AUTH_PASSWORD,         F_DBINITRW, VT_BSTR, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Password"},
    {DBPROP_AUTH_USERID,           F_DBINITRW, VT_BSTR, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"User ID"},
    {DBPROP_AUTH_ENCRYPT_PASSWORD, F_DBINITRW, VT_BOOL, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Encrypt Password"},
    {DBPROP_AUTH_INTEGRATED,       F_DBINITRW, VT_BSTR, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Integrated Security"},
    {DBPROP_INIT_DATASOURCE,       F_DBINITRW, VT_BSTR, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Data Source"},
    {DBPROP_INIT_LOCATION,         F_DBINITRW, VT_BSTR, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Location"},
    {DBPROP_INIT_PROVIDERSTRING,   F_DBINITRW, VT_BSTR, VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Extended Properties"},
    {DBPROP_INIT_TIMEOUT,          F_DBINITRW, VT_I4,   VARIANT_FALSE, 90,           OPT_REQ, NULL, L"Connect Timeout"},
    {DBPROP_INIT_PROMPT,           F_DBINITRW, VT_I2,   VARIANT_FALSE, DBPROMPT_NOPROMPT, OPT_REQ, NULL,  L"Prompt"},
    {DBPROP_INIT_HWND,             F_DBINITRW, VT_I4,   VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Window Handle"},
    {DBPROP_INIT_MODE,             F_DBINITRW, VT_I4,   VARIANT_FALSE, DB_MODE_READ,      OPT_REQ, NULL, L"Mode"}
#if (!defined(BUILD_FOR_NT40)) 
    ,
    {DBPROP_INIT_BINDFLAGS,        F_DBINITRW, VT_I4,   VARIANT_FALSE, 0,            OPT_REQ, NULL, L"Bind Flags"}
#endif
};

PROPSTRUCT s_rgADSIBindProp[] =
{
    // initialize this property to a reserved value. The client is not supposed
    // to set this property to the reserved value. This reserved value prevents
    // ADSIFLAG from overriding ENCRYPT_PASSWORD when VB initializes this
    // property to its default value. See IsValidValue().

    {ADSIPROP_ADSIFLAG,            F_DBINITRW, VT_I4,   VARIANT_FALSE, 
     ADS_AUTH_RESERVED, OPT_REQ, NULL, L"ADSI Flag"} 
};

PROPSTRUCT s_rgDSInfoProp[] =
{
    {DBPROP_ACTIVESESSIONS,             F_DSRO,    VT_I4,   VARIANT_FALSE, 0, OPT_REQ, NULL,                                              L"Active Sessions"},
    {DBPROP_BYREFACCESSORS,             F_DSRO,    VT_BOOL, VARIANT_FALSE, 1, OPT_REQ, NULL,                                              L"Pass By Ref Accessors"},
    {DBPROP_CATALOGLOCATION,            F_DSRO,    VT_I4,   VARIANT_FALSE, DBPROPVAL_CL_START, OPT_REQ, NULL,                             L"Catalog Location"},
    {DBPROP_CATALOGTERM,                F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, NULL,                                              L"Catalog Term"},
    {DBPROP_CATALOGUSAGE,               F_DSRO,    VT_I4,   VARIANT_FALSE, 0, OPT_REQ, NULL,                                              L"Catalog Usage"},
    {DBPROP_DATASOURCENAME,             F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, L"Active Directory Service Interfaces",            L"Data Source Name"},
    {DBPROP_DATASOURCEREADONLY,         F_DSRO,    VT_BOOL, VARIANT_TRUE,  0, OPT_REQ, NULL,                                              L"Read-Only Data Source"},
//  {DBPROP_DBMSNAME,                   F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, NULL,                                              L"DBMS Name"},
//  {DBPROP_DBMSVER,                    F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, NULL,                                              L"DBMS Version"},
    {DBPROP_DSOTHREADMODEL,             F_DSRO,    VT_I4,   VARIANT_FALSE, DBPROPVAL_RT_FREETHREAD, OPT_REQ, NULL,                        L"Data Source Object Threading Model"},
    {DBPROP_MAXROWSIZE,                 F_DSRO,    VT_I4,   VARIANT_FALSE, 0, OPT_SIC, NULL,                                              L"Maximum Row Size"},
#if (!defined(BUILD_FOR_NT40))
    {DBPROP_OLEOBJECTS,                 F_DSRO,    VT_I4,   VARIANT_FALSE, DBPROPVAL_OO_ROWOBJECT | DBPROPVAL_OO_DIRECTBIND | DBPROPVAL_OO_SINGLETON, OPT_REQ, NULL, L"OLE Object Support"},
#endif
    {DBPROP_PERSISTENTIDTYPE,           F_DSRO,    VT_I4,   VARIANT_FALSE, DBPROPVAL_PT_NAME, OPT_SIC, NULL,                              L"Persistent ID Type"},
    {DBPROP_PROVIDERFRIENDLYNAME,       F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, L"Microsoft OLE DB Provider for ADSI",             L"Provider Friendly Name"},
    {DBPROP_PROVIDERNAME,               F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, L"ACTIVEDS.DLL",                                   L"Provider Name"},
    {DBPROP_PROVIDEROLEDBVER,           F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, L"02.50",                                          L"OLE DB Version"},
    {DBPROP_PROVIDERVER,                F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, L"02.50.0000",                                     L"Provider Version"},
    {DBPROP_SQLSUPPORT,                 F_DSRO,    VT_I4,   VARIANT_FALSE, DBPROPVAL_SQL_ODBC_MINIMUM, OPT_REQ, NULL,                     L"SQL Support"},
    {DBPROP_ROWSETCONVERSIONSONCOMMAND, F_DSRO,    VT_BOOL, VARIANT_TRUE,  0, OPT_REQ, NULL,                                              L"Rowset Conversions on Command"},
    {DBPROP_USERNAME,                   F_DSRO,    VT_BSTR, VARIANT_FALSE, 0, OPT_REQ, NULL,                                              L"User Name"}
};

PROPSTRUCT s_rgRowsetProp[] =
{
    {DBPROP_IAccessor,                       F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IAccessor"},
    {DBPROP_IColumnsInfo,                    F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IColumnsInfo"},
#if (!defined(BUILD_FOR_NT40))
    {DBPROP_IColumnsInfo2,                   F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IColumnsInfo2"},
#endif
    {DBPROP_IConvertType,                    F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IConvertType"},
#if (!defined(BUILD_FOR_NT40))
    {DBPROP_IGetSession,                     F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IGetSession"},
    {DBPROP_IRow,                            F_ROWSETRW,     VT_BOOL, VARIANT_FALSE,    0, OPT_REQ, NULL, L"IRow"},
    {DBPROP_IGetRow,                         F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IGetRow"},
#endif
    {DBPROP_IRowset,                         F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IRowset"},
    {DBPROP_IRowsetIdentity,                 F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,   0, OPT_SIC, NULL, L"IRowsetIdentity"},
    {DBPROP_IRowsetInfo,                     F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IRowsetInfo"},
    {DBPROP_IRowsetLocate,                   F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IRowsetLocate"},
    {DBPROP_IRowsetScroll,                   F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"IRowsetScroll"},
    {DBPROP_ABORTPRESERVE,                   F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_REQ, NULL, L"Preserve on Abort"},
    {DBPROP_BLOCKINGSTORAGEOBJECTS,          F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"Blocking Storage Objects"},
    {DBPROP_BOOKMARKS,                       F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"Use Bookmarks"},
    {DBPROP_BOOKMARKSKIPPED,                 F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_REQ, NULL, L"Skip Deleted Bookmarks"},
    {DBPROP_BOOKMARKTYPE,                    F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   DBPROPVAL_BMK_NUMERIC, OPT_REQ, NULL, L"Bookmark Type"},
    {DBPROP_CANFETCHBACKWARDS,               F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,   0, OPT_SIC, NULL, L"Fetch Backwards"},
    {DBPROP_CANHOLDROWS,                     F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,   0, OPT_SIC, NULL, L"Hold Rows"},
    {DBPROP_CANSCROLLBACKWARDS,              F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,   0, OPT_SIC, NULL, L"Scroll Backwards"},
    {DBPROP_COLUMNRESTRICT,                  F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_SIC, NULL, L"Column Privileges"},
    {DBPROP_COMMITPRESERVE,                  F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_REQ, NULL, L"Preserve on Commit"},
    {DBPROP_IMMOBILEROWS,                    F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_SIC, NULL, L"Immobile Rows"},
    {DBPROP_LITERALBOOKMARKS,                F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_SIC, NULL, L"Literal Bookmarks"},
    {DBPROP_LITERALIDENTITY,                 F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,   0, OPT_REQ, NULL, L"Literal Row Identity"},
    {DBPROP_MAXOPENROWS,                     F_ROWSETRW,     VT_I4,   VARIANT_FALSE,   0, OPT_SIC, NULL, L"Maximum Open Rows"},
    {DBPROP_MAXPENDINGROWS,                  F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_SIC, NULL, L"Maximum Pending Rows"},
    {DBPROP_MAXROWS,                         F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_SIC, NULL, L"Maximum Rows"},
    {DBPROP_NOTIFICATIONPHASES,              F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Notification Phases"},
//  {DBPROP_NOTIFYCOLUMNRECALCULATED,        F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"NotifyColumnRecalculated"},
    {DBPROP_NOTIFYCOLUMNSET,                 F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Column Set Notification"},
//  {DBPROP_NOTIFYROWACTIVATE,               F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"NotifyRowActivate"},
    {DBPROP_NOTIFYROWDELETE,                 F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Delete Notification"},
    {DBPROP_NOTIFYROWFIRSTCHANGE,            F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row First Change Notification"},
    {DBPROP_NOTIFYROWINSERT,                 F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Insert Notification"},
//  {DBPROP_NOTIFYROWRELEASE,                F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"NotifyRowRelease"},
    {DBPROP_NOTIFYROWRESYNCH,                F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Resynchronization Notification"},
    {DBPROP_NOTIFYROWSETRELEASE,             F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Rowset Release Notification"},
    {DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE, F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Rowset Fetch Position Change Notification"},
    {DBPROP_NOTIFYROWUNDOCHANGE,             F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Undo Change Notification"},
    {DBPROP_NOTIFYROWUNDODELETE,             F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Undo Delete Notification"},
    {DBPROP_NOTIFYROWUNDOINSERT,             F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Undo Insert Notification"},
    {DBPROP_NOTIFYROWUPDATE,                 F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Update Notification"},
    {DBPROP_ORDEREDBOOKMARKS,                F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_SIC, NULL, L"Bookmarks Ordered"},
    {DBPROP_OWNINSERT,                       F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_SIC, NULL, L"Own Inserts Visible"},
    {DBPROP_OWNUPDATEDELETE,                 F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_SIC, NULL, L"Own Changes Visible"},
    {DBPROP_QUICKRESTART,                    F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,   0, OPT_SIC, NULL, L"Quick Restart"},
    {DBPROP_REENTRANTEVENTS,                 F_ROWSETRO,     VT_BOOL, VARIANT_TRUE,    0, OPT_REQ, NULL, L"Reentrant Events"},
    {DBPROP_REMOVEDELETED,                   F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_SIC, NULL, L"Remove Deleted Rows"},
    {DBPROP_REPORTMULTIPLECHANGES,           F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_REQ, NULL, L"Report Multiple Changes"},
    {DBPROP_ROWRESTRICT,                     F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_REQ, NULL, L"Row Privileges"},
    {DBPROP_ROWTHREADMODEL,                  F_ROWSETRO,     VT_I4,   VARIANT_FALSE,   DBPROPVAL_RT_FREETHREAD, OPT_REQ, NULL, L"Row Threading Model"},
    {DBPROP_STRONGIDENTITY,                  F_ROWSETRO,     VT_BOOL, VARIANT_FALSE,   0, OPT_REQ, NULL, L"Strong Row Identity"},

};

PROPSTRUCT s_rgDBSessProp[] =
{
    {DBPROP_SESS_AUTOCOMMITISOLEVELS, F_SESSRO, VT_I4, VARIANT_FALSE, 0, OPT_REQ, NULL, L"Autocommit Isolation Levels"},
};


PROPSTRUCT s_rgADSISearchProp[12] =
{
    {ADSIPROP_ASYNCHRONOUS,     F_ADSIRW,    VT_BOOL,    VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Asynchronous"},
    {ADSIPROP_DEREF_ALIASES,    F_ADSIRW,    VT_I4,      VARIANT_FALSE,  ADS_DEREF_NEVER,           OPT_REQ, NULL, L"Deref Aliases"},
    {ADSIPROP_SIZE_LIMIT,       F_ADSIRW,    VT_I4,      VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Size Limit"},
    {ADSIPROP_TIME_LIMIT,       F_ADSIRW,    VT_I4,      VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Server Time Limit"},
    {ADSIPROP_ATTRIBTYPES_ONLY, F_ADSIRW,    VT_BOOL,    VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Column Names only"},
    {ADSIPROP_SEARCH_SCOPE,     F_ADSIRW,    VT_I4,      VARIANT_FALSE,  ADS_SCOPE_SUBTREE,         OPT_REQ, NULL, L"SearchScope"},
    {ADSIPROP_TIMEOUT,          F_ADSIRW,    VT_I4,      VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Timeout"},
    {ADSIPROP_PAGESIZE,         F_ADSIRW,    VT_I4,      VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Page size"},
    {ADSIPROP_PAGED_TIME_LIMIT, F_ADSIRW,    VT_I4,      VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Time limit"},
    {ADSIPROP_CHASE_REFERRALS,  F_ADSIRW,    VT_I4,      VARIANT_FALSE,  ADS_CHASE_REFERRALS_NEVER, OPT_REQ, NULL, L"Chase referrals"},
    {ADSIPROP_SORT_ON,          F_ADSIRW,    VT_BSTR,    VARIANT_FALSE,  0,                         OPT_REQ, NULL, L"Sort On"},
    {ADSIPROP_CACHE_RESULTS,    F_ADSIRW,    VT_BOOL,    VARIANT_TRUE,   0,                         OPT_REQ, NULL, L"Cache Results"}

};

// Number of supported properties per property set
#define    NUMBER_OF_SUPPORTED_PROPERTY_SETS   6

static PROPSET s_rgPropertySets[NUMBER_OF_SUPPORTED_PROPERTY_SETS] =
{
    {&DBPROPSET_DBINIT,         NUMELEM(s_rgDBInitProp),    s_rgDBInitProp},
    {&DBPROPSET_ADSIBIND,       NUMELEM(s_rgADSIBindProp),  s_rgADSIBindProp},
    {&DBPROPSET_DATASOURCEINFO, NUMELEM(s_rgDSInfoProp),    s_rgDSInfoProp},
    {&DBPROPSET_SESSION,        NUMELEM(s_rgDBSessProp),    s_rgDBSessProp},
    {&DBPROPSET_ROWSET,         NUMELEM(s_rgRowsetProp),    s_rgRowsetProp},
    {&DBPROPSET_ADSISEARCH,     NUMELEM(s_rgADSISearchProp),s_rgADSISearchProp}
};

//
// WARNING: Don't change the order. Add new property sets at the end
//
// Update: New property sets should not always be added at the end.
// Property sets which have properties in the Initialization  property group
// have to be added before DATASOURCEINFO and prop. sets with properties
// in the  data source information property groups have to be added
// before INDEX_SESSION and so on. This is for GetProperties to work correctly.
//

#define INDEX_INIT              0
#define INDEX_ADSIBIND          1
#define INDEX_DATASOURCEINFO    2
#define INDEX_SESSION           3
#define INDEX_ROWSET            4
#define INDEX_ADSISEARCH        5

//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::CUtilProp
//
//  Synopsis:  Constructor for this class
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CUtilProp::CUtilProp(
    void
    )
{
    _pIMalloc      = NULL;
    _pCredentials  = NULL;
    _prgProperties = NULL;
    _dwDescBufferLen = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::FInit
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    09-20-96   ShankSh     Created.
//
//  Update: pCredentials may be NULL if called from CRowset.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CUtilProp::FInit(
    CCredentials *pCredentials
    )
{
    HRESULT hr=S_OK;
    ULONG i, j;
    ULONG c = 0;

    //
    // Get the IMalloc interface pointer
    //
    hr = CoGetMalloc(MEMCTX_TASK, &_pIMalloc);
    BAIL_ON_FAILURE( hr );

    _pCredentials = pCredentials;
    _prgProperties = (PROPSTRUCT*) AllocADsMem(sizeof(PROPSTRUCT) *
                                               (NUMELEM(s_rgDBInitProp) +
                                                NUMELEM(s_rgADSIBindProp) +
                                                NUMELEM(s_rgDSInfoProp) +
                                                NUMELEM(s_rgDBSessProp) +
                                                NUMELEM(s_rgRowsetProp) +
                                                NUMELEM(s_rgADSISearchProp)) );
    if( !_prgProperties )
        BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );

    for (i=c=0; i< NUMBER_OF_SUPPORTED_PROPERTY_SETS; i++) {
        for (j=0; j < s_rgPropertySets[i].cProperties; j++) {
            // Copy static structure
            memcpy( &_prgProperties[c],
                    &s_rgPropertySets[i].pUPropInfo[j], sizeof(PROPSTRUCT) );

            // Allocate new BSTR value
            _prgProperties[c].pwstrVal =
                    AllocADsStr(s_rgPropertySets[i].pUPropInfo[j].pwstrVal);

            // Add description length
            if( s_rgPropertySets[i].pUPropInfo[j].pwszDescription ) {
                _dwDescBufferLen += wcslen(s_rgPropertySets[i].pUPropInfo[j].pwszDescription) + 1;
            }

            c++;
        }
    }
    _dwDescBufferLen *= sizeof(WCHAR);

    ADsAssert( c == NUMELEM(s_rgDBInitProp) +
                    NUMELEM(s_rgADSIBindProp) +
                    NUMELEM(s_rgDSInfoProp) +
                    NUMELEM(s_rgDBSessProp) +
                    NUMELEM(s_rgRowsetProp) +
                    NUMELEM(s_rgADSISearchProp) );

error:

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::~CUtilProp
//
//  Synopsis:  Destructor for this class
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------

CUtilProp:: ~CUtilProp
(
void
)
{
    ULONG c = 0;

    if( _prgProperties )
    {
        // Clear all of the String values
        for (ULONG i=c=0; i< NUMBER_OF_SUPPORTED_PROPERTY_SETS; i++) {
            for (ULONG j=0; j < s_rgPropertySets[i].cProperties; j++) {
                if( _prgProperties[c].pwstrVal )
                    FreeADsStr(_prgProperties[c].pwstrVal);
                c++;
            }
        }

        FreeADsMem(_prgProperties);
    }

    if( _pIMalloc )
        _pIMalloc->Release();

    return;
}


PROPSET *
CUtilProp::GetPropSetFromGuid (
    GUID guidPropSet
    )
{

    for (int j=0; j< NUMELEM(s_rgPropertySets); j++) {
        if (IsEqualGUID(guidPropSet,
                        *(s_rgPropertySets[j].guidPropertySet)))
            return &(s_rgPropertySets[j]);
    }
    return NULL;
}

HRESULT
CUtilProp::GetSearchPrefInfo(
    DBPROPID dwPropId,
    PADS_SEARCHPREF_INFO pSearchPrefInfo
    )
{
    PADS_SORTKEY pSortKey = NULL;
    LPWSTR pszAttrs = NULL;
    LPWSTR pszFirstAttr = NULL;
    LPWSTR pszCurrentAttr = NULL, pszNextAttr = NULL, pszOrder = NULL;
    DWORD cAttrs = 0;
    HRESULT hr = S_OK;
    DWORD index;

    if (!pSearchPrefInfo) {
        RRETURN (E_INVALIDARG);
    }

    if (dwPropId >= g_cMapDBPropToSearchPref)
        RRETURN(E_FAIL);

    pSearchPrefInfo->dwSearchPref = g_MapDBPropIdToSearchPref[dwPropId];

    //
    // Get index of where ADSI search properties begin
    //

    index = NUMELEM(s_rgDBInitProp) +
            NUMELEM(s_rgADSIBindProp) +
            NUMELEM(s_rgDSInfoProp) +
            NUMELEM(s_rgDBSessProp) +
            NUMELEM(s_rgRowsetProp);

    switch (_prgProperties[index + dwPropId].vtType) {
    case VT_BOOL:
        pSearchPrefInfo->vValue.dwType = ADSTYPE_BOOLEAN;
        pSearchPrefInfo->vValue.Boolean =
            _prgProperties[index + dwPropId].boolVal == VARIANT_TRUE ? TRUE : FALSE;
        break;

    case VT_I4:
    case VT_I2:
        pSearchPrefInfo->vValue.dwType = ADSTYPE_INTEGER;
        pSearchPrefInfo->vValue.Integer = _prgProperties[index + dwPropId].longVal;
        break;

    case VT_BSTR: {
        if (pSearchPrefInfo->dwSearchPref != ADS_SEARCHPREF_SORT_ON) {
            //
            // right now, this is the only string preference supported
            //
            RRETURN (E_FAIL);
        }
        //
        // The preference is a list of atributes to be sorted on (in that order
        // and an optional indication of whether it has to be sorted ascending
        // or not.
        // eg., "name ASC, usnchanged DESC, cn"
        //
        pSearchPrefInfo->vValue.dwType = ADSTYPE_PROV_SPECIFIC;

        if (!_prgProperties[index + dwPropId].pwstrVal ||
            !_wcsicmp(_prgProperties[index + dwPropId].pwstrVal, L"")) {

            pSearchPrefInfo->vValue.ProviderSpecific.dwLength = 0;
            pSearchPrefInfo->vValue.ProviderSpecific.lpValue = NULL;

            break;
        }

        // make a copy
        pszAttrs = AllocADsStr(_prgProperties[index + dwPropId].pwstrVal);

        pszCurrentAttr = pszFirstAttr = wcstok(pszAttrs, L",");

        for(cAttrs=0; pszCurrentAttr != NULL; cAttrs++ ) {
            pszCurrentAttr = wcstok(NULL, L",");
        }

        if(cAttrs == 0) {
           BAIL_ON_FAILURE ( hr = E_ADS_BAD_PARAMETER );
        }

        pSortKey = (PADS_SORTKEY) AllocADsMem(sizeof(ADS_SORTKEY) * cAttrs);

        if (!pSortKey) {
            BAIL_ON_FAILURE ( E_OUTOFMEMORY );
        }

        pszCurrentAttr = pszFirstAttr;

        for (DWORD i=0 ; i < cAttrs; i++) {

            pszNextAttr = pszCurrentAttr + wcslen(pszCurrentAttr) + 1;
            pszCurrentAttr = RemoveWhiteSpaces(pszCurrentAttr);

            pszOrder = wcstok(pszCurrentAttr, L" ");
            pszOrder = pszOrder ? wcstok(NULL, L" ") : NULL;

            if (pszOrder && !_wcsicmp(pszOrder, L"DESC"))
                pSortKey[i].fReverseorder = 1;
            else
                pSortKey[i].fReverseorder = 0;  // This is the default

            pSortKey[i].pszAttrType = AllocADsStr(pszCurrentAttr);
            pSortKey[i].pszReserved = NULL;

            pszCurrentAttr = pszNextAttr;

        }

        pSearchPrefInfo->vValue.ProviderSpecific.dwLength = sizeof(ADS_SORTKEY) * cAttrs;
        pSearchPrefInfo->vValue.ProviderSpecific.lpValue = (LPBYTE) pSortKey;

        break;

    }

    default:

        RRETURN (E_FAIL);
    }

error:

    if (pszAttrs) {
        FreeADsStr(pszAttrs);
    }

    RRETURN(hr);

}


HRESULT
CUtilProp::FreeSearchPrefInfo(
    PADS_SEARCHPREF_INFO pSearchPrefInfo,
    DWORD dwNumSearchPrefs
    )
{

    PADS_SORTKEY pSortKey = NULL;
    DWORD nSortKeys = 0;

    if (!pSearchPrefInfo || !dwNumSearchPrefs) {
        RRETURN (S_OK);
    }

    for (DWORD i=0; i<dwNumSearchPrefs; i++) {

        switch(pSearchPrefInfo[i].vValue.dwType) {

        case ADSTYPE_BOOLEAN:
        case ADSTYPE_INTEGER:
            // do nothing
            break;

        case ADSTYPE_PROV_SPECIFIC:

            if (pSearchPrefInfo[i].dwSearchPref == ADS_SEARCHPREF_SORT_ON) {
                //
                // delete the strings allocated for each of the attributes
                // to be sorted

                nSortKeys = pSearchPrefInfo[i].vValue.ProviderSpecific.dwLength / sizeof(ADS_SORTKEY);
                pSortKey = (PADS_SORTKEY) pSearchPrefInfo[i].vValue.ProviderSpecific.lpValue;

                for (DWORD j=0; pSortKey && j<nSortKeys; j++) {
                    FreeADsStr(pSortKey[j].pszAttrType);
                }

                if (pSortKey) {
                    FreeADsMem(pSortKey);
                }

            }

            break;
        }

    }

    RRETURN (S_OK);

}

//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::LoadDBPROPINFO
//
//  Synopsis:  Helper for GetPropertyInfo. Loads field of DBPROPINFO
//             structure.
//
//  Arguments:
//
//  Returns:        TRUE    :  Method succeeded
//                  FALSE   :  Method failed (couldn't allocate memory)
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUtilProp::LoadDBPROPINFO (
    PROPSTRUCT* pPropStruct,
    ULONG       cProperties,
    DBPROPINFO* pPropInfo
    )
{
    ULONG cCount;
    PROPSTRUCT* pProp=NULL;

    // asserts
    ADsAssert( pPropInfo );
    if( cProperties ) {
        ADsAssert( pPropStruct );
    }

    //
    // init the variant
    //
    VariantInit( &pPropInfo->vValues );

    for (cCount=0; cCount < cProperties; cCount++) {
        if(pPropInfo->dwPropertyID == pPropStruct[cCount].dwPropertyID)
            break;
    }

    if(cCount == cProperties) {
        pPropInfo->dwFlags = DBPROPFLAGS_NOTSUPPORTED;
        pPropInfo->pwszDescription = NULL;
        RRETURN (DB_S_ERRORSOCCURRED);
    }

    pProp = &(pPropStruct[cCount]);
    //
    // set the easy fields..
    //
    pPropInfo->dwPropertyID    = pProp->dwPropertyID;
    pPropInfo->dwFlags        = pProp->dwFlags;
    pPropInfo->vtType        = pProp->vtType;


    // fill in the description
    if (pPropInfo->pwszDescription)
        wcscpy(pPropInfo->pwszDescription, pProp->pwszDescription);

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::LoadDBPROP
//
//  Synopsis:  Helper for GetProperties. Loads field of DBPROP structure.
//
//  Arguments:
//
//  Returns:        TRUE    :  Method succeeded
//                  FALSE   :  Method failed (couldn't allocate memory)
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUtilProp::LoadDBPROP (
    PROPSTRUCT* pPropStruct,
    ULONG       cProperties,
    DBPROP*     pPropSupport,
    BOOL        IsDBInitPropSet
    )
{
    ULONG cCount;
    PROPSTRUCT* pProp=NULL;
    LPWSTR szUserName=NULL, szPassword=NULL;
    BOOL fAuthFlags=0;

    // asserts
    ADsAssert( pPropSupport );
    if( cProperties ) {
        ADsAssert( pPropStruct );
    }

    //
    // init the variant
    //
    VariantInit( &pPropSupport->vValue );

    for (cCount=0; cCount < cProperties; cCount++) {
        if( pPropSupport->dwPropertyID == pPropStruct[cCount].dwPropertyID )
            break;
    }

    if( cCount == cProperties ) {
        pPropSupport->dwStatus = DBPROPSTATUS_NOTSUPPORTED;
        RRETURN ( DB_S_ERRORSOCCURRED );
    }

    pProp = &(pPropStruct[cCount]);

    pPropSupport->colid = DB_NULLID;
    pPropSupport->dwOptions = pProp->dwOptions;

    //
    // set pPropSupport->vValue based on Variant type
    //
    switch (pProp->vtType) {
        case VT_BOOL:
            V_VT( &pPropSupport->vValue ) = VT_BOOL;
            V_BOOL( &pPropSupport->vValue ) = (SHORT)pProp->boolVal;
            break;

        case VT_I4:
            V_VT( &pPropSupport->vValue ) = VT_I4;
            V_I4( &pPropSupport->vValue ) = pProp->longVal;
            break;

        case VT_I2:
            V_VT( &pPropSupport->vValue ) = VT_I2;
            V_I2( &pPropSupport->vValue ) = (short)pProp->longVal;
            break;

        case VT_BSTR:
            //
            // If requesting password, get it from the credentials structure
            // as it is not stored anywhere else
            //
            if (IsDBInitPropSet &&
                pPropSupport->dwPropertyID == DBPROP_AUTH_PASSWORD)
            {
                PWSTR pszPassword = NULL;

                if (FAILED(_pCredentials->GetPassword(&pszPassword)))
                {
                    VariantClear( &pPropSupport->vValue );
                    return DB_S_ERRORSOCCURRED;
                }

                if (pszPassword)
                {
                    V_VT(&pPropSupport->vValue)  = VT_BSTR;
                    V_BSTR(&pPropSupport->vValue)= SysAllocString(pszPassword);

                    //
                    // Zero out the password before freeing it
                    //
                    SecureZeroMemory(pszPassword, wcslen(pszPassword) * sizeof(WCHAR));
                    FreeADsMem(pszPassword);

                    if( V_BSTR(&pPropSupport->vValue) == NULL ) {
                        VariantClear( &pPropSupport->vValue );
                        return DB_S_ERRORSOCCURRED;
                    }
                }
            }
            else if( pProp->pwstrVal ) {
                V_VT(&pPropSupport->vValue)  = VT_BSTR;

                V_BSTR(&pPropSupport->vValue)= SysAllocString(pProp->pwstrVal);

                if( V_BSTR(&pPropSupport->vValue) == NULL ) {
                    VariantClear( &pPropSupport->vValue );
                    return DB_S_ERRORSOCCURRED;
                }
            }
            break;

        default:
            ADsAssert( !"LoadDBPROP unknown variant type!\n\r" );
            pPropSupport->dwStatus = DBPROPSTATUS_BADVALUE;
            RRETURN (DB_S_ERRORSOCCURRED);
            break;
    }
    //
    // all went well
    //
    pPropSupport->dwStatus = DBPROPSTATUS_OK;
    RRETURN(S_OK);
}



//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::StoreDBProp
//
//  Synopsis:  Helper for SetProperties. Loads field of DBPROP structure.
//
//  Arguments:
//
//  Returns:
//
//
//  Modifies:
//
//  History:    09-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUtilProp::StoreDBPROP (
    PROPSTRUCT* pPropStruct,
    PROPSTRUCT* pStaticPropStruct,
    ULONG       cProperties,
    DBPROP*     pPropSupport,
    DWORD       dwPropIndex
)
{
    // asserts
    ADsAssert( pPropStruct );
    ADsAssert( pPropSupport );

    ULONG i;
    HRESULT hr=S_OK;

    // Initialize the status to DBPROPSTATUS_OK
    pPropSupport->dwStatus = DBPROPSTATUS_OK;

    for (i=0; i < cProperties; i++) {
        if(pPropStruct[i].dwPropertyID == pPropSupport->dwPropertyID) {

            // arg checking for the prop
            if( pPropSupport->dwOptions != DBPROPOPTIONS_OPTIONAL &&
                pPropSupport->dwOptions != DBPROPOPTIONS_REQUIRED ) {
                pPropSupport->dwStatus = DBPROPSTATUS_BADOPTION;
                hr = DB_S_ERRORSOCCURRED;
                goto error;
            }

            if( (pPropStruct[i].vtType != V_VT(&pPropSupport->vValue) &&
                 V_VT(&pPropSupport->vValue) != VT_EMPTY) ||
                (IsValidValue(pPropSupport, dwPropIndex) == S_FALSE) ) {

                pPropSupport->dwStatus = DBPROPSTATUS_BADVALUE;
                hr = DB_S_ERRORSOCCURRED;
                goto error;
            }

            //
            // If property being set is password, we get out here.
            // Reason is we have already stored it in the Credentials structure
            // in encrypted form in the function IsVaidValue above.
            // We should not store it in plain text in pPropStruct[i].
            //
            if (dwPropIndex == INDEX_INIT &&
                pPropSupport->dwPropertyID == DBPROP_AUTH_PASSWORD)
            {
                pPropSupport->dwStatus = DBPROPSTATUS_OK;
                pPropStruct[i].dwOptions = pPropSupport->dwOptions;
                goto error;
            }

            if( !(pPropStruct[i].dwFlags & DBPROPFLAGS_WRITE) ) {
                // Check the value - if they are the same, do nothing
                if ( (V_VT(&pPropSupport->vValue) == VT_EMPTY) ||
                     ((V_VT(&pPropSupport->vValue) == VT_BOOL) &&
                      (pPropStruct[i].boolVal == V_BOOL(&pPropSupport->vValue))) ||
                     ((V_VT(&pPropSupport->vValue) == VT_I4) &&
                      (pPropStruct[i].longVal == V_I4(&pPropSupport->vValue))) ||
                     ((V_VT(&pPropSupport->vValue) == VT_I2) &&
                      ((short)pPropStruct[i].longVal == V_I2(&pPropSupport->vValue))) ||
                     ((V_VT(&pPropSupport->vValue) == VT_BSTR) && pPropStruct[i].pwstrVal &&
                      (NULL != V_BSTR(&pPropSupport->vValue)) &&
                      (wcscmp(pPropStruct[i].pwstrVal,V_BSTR(&pPropSupport->vValue)) == 0)) )

                    goto error;

                if( pPropSupport->dwOptions != DBPROPOPTIONS_OPTIONAL )
                    pPropSupport->dwStatus = DBPROPSTATUS_NOTSETTABLE;
                else
                    pPropSupport->dwStatus = DBPROPSTATUS_NOTSET;

                hr = DB_S_ERRORSOCCURRED;
                goto error;
            }

            switch (pPropStruct[i].vtType) {
                case VT_BOOL:
                    if( V_VT(&pPropSupport->vValue) != VT_EMPTY )
                        pPropStruct[i].boolVal = V_BOOL( &pPropSupport->vValue );
                    else
                        pPropStruct[i].boolVal = pStaticPropStruct[i].boolVal;
                    break;

                case VT_I4:
                    if( V_VT(&pPropSupport->vValue) != VT_EMPTY )
                        pPropStruct[i].longVal = V_I4( &pPropSupport->vValue );
                    else
                        pPropStruct[i].longVal = pStaticPropStruct[i].longVal;
                    break;

                case VT_I2:
                    if( V_VT(&pPropSupport->vValue) != VT_EMPTY )
                        pPropStruct[i].longVal = V_I2( &pPropSupport->vValue );
                    else
                        pPropStruct[i].longVal = pStaticPropStruct[i].longVal;
                    break;

                case VT_BSTR:
                    if(pPropStruct[i].pwstrVal) {
                        FreeADsStr(pPropStruct[i].pwstrVal);
                        pPropStruct[i].pwstrVal = NULL;
                    }

                    if( V_VT(&pPropSupport->vValue) == VT_EMPTY )
                        pPropStruct[i].pwstrVal = AllocADsStr(( pStaticPropStruct[i].pwstrVal ));
                    else
                    {
                        if (V_BSTR( &pPropSupport->vValue) == NULL &&
                            pPropSupport->dwPropertyID == DBPROP_AUTH_INTEGRATED)
                        {
                            //
                            // For integrated security, NULL bstrVal implies 'use default
                            // provider', which is "SSPI" for us. The reason we don't set
                            // the defult value to SSPI in the static structure is
                            // because this property is special. Unless set, it should
                            // not be used.
                            //
                            pPropStruct[i].pwstrVal = AllocADsStr(L"SSPI");
                        }
                        else
                            pPropStruct[i].pwstrVal = AllocADsStr(V_BSTR( &pPropSupport->vValue ));
                    }

                    if( !pPropStruct[i].pwstrVal &&
                        V_VT(&pPropSupport->vValue) == VT_BSTR ) {

                        hr = E_FAIL;
                        goto error;
                    }
                    break;

                default:
                    pPropSupport->dwStatus = DBPROPSTATUS_BADVALUE;
                    hr = DB_S_ERRORSOCCURRED;
                    goto error;
            }
            pPropSupport->dwStatus = DBPROPSTATUS_OK;
            pPropStruct[i].dwOptions = pPropSupport->dwOptions;
            break;
        }

    }

    if (i == cProperties) {
        pPropSupport->dwStatus = DBPROPSTATUS_NOTSUPPORTED;
        hr = DB_E_ERRORSOCCURRED;
        goto error;
    }

error:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::IsValidValue
//
//  Synopsis:  Helper for SetProperties. Check the valid values for the Property.
//
//  Arguments:
//
//  Returns:
//
//
//  Modifies:
//
//  History:    09-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CUtilProp::IsValidValue
        (
        DBPROP*         pDBProp,
        DWORD           dwPropIndex
        )
{
    // Check BOOLEAN values
    if( (pDBProp->vValue.vt == VT_BOOL) &&
        !((V_BOOL(&(pDBProp->vValue)) == VARIANT_TRUE) ||
          (V_BOOL(&(pDBProp->vValue)) == VARIANT_FALSE)) )
        return S_FALSE;

    if( pDBProp->vValue.vt != VT_EMPTY &&
        dwPropIndex == INDEX_INIT )
    {
        switch( pDBProp->dwPropertyID )
        {
        case DBPROP_INIT_PROMPT:
            // These are the only values we support (from spec).
            if (!(V_I2(&pDBProp->vValue) == DBPROMPT_PROMPT ||
                  V_I2(&pDBProp->vValue) == DBPROMPT_COMPLETE ||
                  V_I2(&pDBProp->vValue) == DBPROMPT_COMPLETEREQUIRED ||
                  V_I2(&pDBProp->vValue) == DBPROMPT_NOPROMPT))
                return S_FALSE;
                break;

        case DBPROP_INIT_TIMEOUT:
            if( (pDBProp->vValue.vt != VT_I4) ||
                (V_I4(&pDBProp->vValue) < 0) )
                return S_FALSE;

            break;

        case DBPROP_AUTH_USERID:
            if( (!_pCredentials) ||
                (S_OK != _pCredentials->SetUserName(V_BSTR(&pDBProp->vValue))) )
                return S_FALSE;

                break;

        case DBPROP_AUTH_PASSWORD:
            if( (!_pCredentials) ||
                (S_OK != _pCredentials->SetPassword(V_BSTR(&pDBProp->vValue))) )
                return S_FALSE;

                break;

        case DBPROP_AUTH_INTEGRATED:
            //
            // For integrated security, NULL bstrVal implies 'use default
            // provider', which is "SSPI" for us.
            //
            if( ((pDBProp->vValue.vt != VT_BSTR) &&
                 (pDBProp->vValue.vt != VT_NULL))    ||
                ((V_BSTR(&pDBProp->vValue) != NULL) &&
                 (wcscmp(V_BSTR(&pDBProp->vValue), L"SSPI") != 0)))
                return S_FALSE;

            break;

        case DBPROP_INIT_MODE:
            if( (pDBProp->vValue.vt != VT_I4) ||
                    (S_FALSE == IsValidInitMode(V_I4(&pDBProp->vValue))) )
                return S_FALSE;

            break;

#if (!defined(BUILD_FOR_NT40))

        case DBPROP_INIT_BINDFLAGS:
            if( (pDBProp->vValue.vt != VT_I4) ||
                    (S_FALSE == IsValidBindFlag(V_I4(&pDBProp->vValue))) )
                return S_FALSE;

            break;
#endif

        case DBPROP_AUTH_ENCRYPT_PASSWORD:
            if( !_pCredentials )
                return S_FALSE;

            if( IsADSIFlagSet() )
                // override this property if the user set the authentication
                break;

            BOOL fAuthFlags = _pCredentials->GetAuthFlags();

            if( V_BOOL(&pDBProp->vValue) )
                _pCredentials->SetAuthFlags(fAuthFlags | ADS_SECURE_AUTHENTICATION);
            else
                _pCredentials->SetAuthFlags(fAuthFlags & ~ADS_SECURE_AUTHENTICATION);

            break;

        }
    }
    else if( pDBProp->vValue.vt != VT_EMPTY &&
             dwPropIndex == INDEX_ADSIBIND )
    {
        switch( pDBProp->dwPropertyID )
        {
            case ADSIPROP_ADSIFLAG:
                if( !_pCredentials )
                    // don't think this will ever happen
                    return S_FALSE;

                // prevent default initialization by VB from setting the
                // AUTH flags. The client should not specify ADS_AUTH_RESERVED
                // for this property (this might happen if the client behaves
                // like VB i.e, does GetProperties and then SetProperties 
                // without ORing in any flags. In this case, ENCRYPT_PASSWORD
                // will not be overwritten by this property due to this check).
                if( ADS_AUTH_RESERVED == (V_I4(&pDBProp->vValue)) )
                    break;

                // the following call might overwrite ENCRYPT_PASSWORD
                _pCredentials->SetAuthFlags((V_I4(&pDBProp->vValue)) & 
                                                     (~ADS_AUTH_RESERVED) );

                break;

        }
    }
    else if( pDBProp->vValue.vt != VT_EMPTY &&
             dwPropIndex == INDEX_SESSION )
    {
        switch( pDBProp->dwPropertyID )
        {
            case DBPROP_SESS_AUTOCOMMITISOLEVELS:
                // These are the only values we support (from spec).
                if( (pDBProp->vValue.vt != VT_I4) ||
                     (V_I4(&pDBProp->vValue) != 0                            &&
                      V_I4(&pDBProp->vValue) != DBPROPVAL_TI_CHAOS           &&
                      V_I4(&pDBProp->vValue) != DBPROPVAL_TI_READUNCOMMITTED &&
                      V_I4(&pDBProp->vValue) != DBPROPVAL_TI_READCOMMITTED   &&
                      V_I4(&pDBProp->vValue) != DBPROPVAL_TI_REPEATABLEREAD  &&
                      V_I4(&pDBProp->vValue) != DBPROPVAL_TI_SERIALIZABLE) )
                    return S_FALSE;

                break;
        }
    }
    else if( pDBProp->vValue.vt != VT_EMPTY &&
             dwPropIndex == INDEX_ROWSET )
    {
        switch( pDBProp->dwPropertyID )
        {
            case DBPROP_MAXOPENROWS:
                if( (pDBProp->vValue.vt != VT_I4) || 
                    (V_I4(&pDBProp->vValue) < 0) )
                    return S_FALSE;

                    break;
        }
    }

    return S_OK;    // Is valid
}

//----------------------------------------------------------------------------
// IsValidInitMode
//
// Checks if a given value is a valid value for DBPROP_INIT_MODE
//
//----------------------------------------------------------------------------
HRESULT
CUtilProp::IsValidInitMode(
    long lVal
    )
{
    // check if any bit that shouldn't be set is actually set
    if( lVal & (~(DB_MODE_READWRITE | 
                  DB_MODE_SHARE_EXCLUSIVE | DB_MODE_SHARE_DENY_NONE)) )
        return S_FALSE;
 
    return S_OK;

}

//---------------------------------------------------------------------------
// IsValidInitBindFlag
//
// Checks if a given value is a valid value for DBPROP_INIT_BINDFLAGS
//
//---------------------------------------------------------------------------
HRESULT
CUtilProp::IsValidBindFlag(
    long lVal
    )
{
#if (!defined(BUILD_FOR_NT40))
    // check if any bit that shouldn't be set is actually set
    if( lVal & (~(DB_BINDFLAGS_DELAYFETCHCOLUMNS | 
                  DB_BINDFLAGS_DELAYFETCHSTREAM | DB_BINDFLAGS_RECURSIVE |
                  DB_BINDFLAGS_OUTPUT | DB_BINDFLAGS_COLLECTION |
                  DB_BINDFLAGS_OPENIFEXISTS | DB_BINDFLAGS_OVERWRITE |
                  DB_BINDFLAGS_ISSTRUCTUREDDOCUMENT)) )
        return S_FALSE;

    // check for mutually exclusive flags
    if( (lVal & DB_BINDFLAGS_OPENIFEXISTS) &&
            (lVal & DB_BINDFLAGS_OVERWRITE) )
        return S_FALSE;

    return S_OK;
#else
    return E_FAIL;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::GetPropertiesArgChk
//
//  Synopsis:  Initialize the buffers and check for E_INVALIDARG
//
//  Arguments:
//             cPropertyIDSets       # of restiction property IDs
//             rgPropertyIDSets[]    restriction guids
//             pcPropertySets        count of properties returned
//             prgPropertySets       property information returned
//             dwBitMask             which property group
//
//  Returns:
//             S_OK          | The method succeeded
//             E_INVALIDARG  | pcPropertyIDSets or prgPropertyInfo was NULL
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CUtilProp::GetPropertiesArgChk(
        ULONG                           cPropertySets,
        const DBPROPIDSET               rgPropertySets[],
        ULONG*                          pcProperties,
        DBPROPSET**                     prgProperties,
        DWORD                           dwBitMask
    )
{
    // Initialize values
    if( pcProperties )
        *pcProperties = 0;
    if( prgProperties )
        *prgProperties = NULL;

    // Check Arguments
    if( ((cPropertySets > 0) && !rgPropertySets) ||
         !pcProperties || !prgProperties )
        RRETURN ( E_INVALIDARG );

    // New argument check for > 1 cPropertyIDs and NULL pointer for
    // array of property ids.
    for(ULONG ul=0; ul<cPropertySets; ul++)
    {
        if( rgPropertySets[ul].cPropertyIDs && !(rgPropertySets[ul].rgPropertyIDs) )
            RRETURN ( E_INVALIDARG );

        // Check for propper formation of DBPROPSET_PROPERTIESINERROR
        if( ((dwBitMask & PROPSET_DSO) || (dwBitMask & PROPSET_COMMAND)) &&
            (rgPropertySets[ul].guidPropertySet == DBPROPSET_PROPERTIESINERROR) )
        {
            if( (cPropertySets > 1) ||
                (rgPropertySets[ul].cPropertyIDs != 0) ||
                (rgPropertySets[ul].rgPropertyIDs != NULL) )
                 RRETURN ( E_INVALIDARG );
        }
    }

    RRETURN ( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::GetPropertyInfo
//
//  Synopsis:  Returns information about rowset and data source properties
//            supported by the provider
//
//  Arguments:
//              cPropertyIDSets             # properties
//              rgPropertyIDSets[]          Array of property sets
//              pcPropertyInfoSets          # DBPROPSET structures
//              prgPropertyInfoSets         DBPROPSET structures property
//                                          information returned
//              ppDescBuffer                Property descriptions
//
//  Returns:
//             S_OK          | The method succeeded
//             E_INVALIDARG  | pcPropertyIDSets or prgPropertyInfo was NULL
//             E_OUTOFMEMORY | Out of memory
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP CUtilProp::GetPropertyInfo
(
    ULONG                cPropertyIDSets,
    const DBPROPIDSET    rgPropertyIDSets[],
    ULONG*               pcPropertyInfoSets,
    DBPROPINFOSET**      pprgPropertyInfoSets,
    WCHAR**              ppDescBuffer,
    BOOL                 fDSOInitialized
    )
{
    DBPROPINFO*      pPropInfo = NULL;
    DBPROPINFOSET*   pPropInfoSet = NULL;
    BOOL             fNoPropInfoGot = TRUE;
    BOOL             fWarning=FALSE;
    HRESULT          hr;
    LPWSTR           pwszDescBuffer=NULL;
    ULONG            cPropertySets=0, cProperties=0;
    ULONG            cCount, j, i;
    ULONG            cNewPropIDSets    = 0;
    BOOL             fIsSpecialGUID    = FALSE;
    BOOL             fIsNotSpecialGUID = FALSE;
    ULONG            ul;
    BOOL             fNewDescription = TRUE;

    // asserts
    ADsAssert( _pIMalloc );

    // init out params
    if( pcPropertyInfoSets )
        *pcPropertyInfoSets = 0;
    if( pprgPropertyInfoSets )
        *pprgPropertyInfoSets = NULL;
    if( ppDescBuffer )
        *ppDescBuffer = NULL;

    // Check Arguments, on failure post HRESULT to error queue
    if( (cPropertyIDSets > 0 && !rgPropertyIDSets) ||
        !pcPropertyInfoSets || !pprgPropertyInfoSets )
        RRETURN( E_INVALIDARG );

    // New argument check for > 1 cPropertyIDs and NULL pointer for
    // array of property ids.
    for(ul=0; ul<cPropertyIDSets; ul++)
    {
        if( rgPropertyIDSets[ul].cPropertyIDs &&
            !rgPropertyIDSets[ul].rgPropertyIDs )
            RRETURN( E_INVALIDARG );

        // Add 1 for the Provider Specific Rowset Properties
        if( (rgPropertyIDSets[ul].guidPropertySet == DBPROPSET_DBINITALL) ||
            (fDSOInitialized &&
            rgPropertyIDSets[ul].guidPropertySet == DBPROPSET_ROWSETALL) )
            cNewPropIDSets++;

        //
        // Special Guids for Property Sets can not be mixed with ordinary
        // Property Set Guids. Either one or the other, not both
        //
        if (IsSpecialGuid(rgPropertyIDSets[ul].guidPropertySet))
            fIsSpecialGUID = TRUE;
        else
            fIsNotSpecialGUID = TRUE;

        if( fIsSpecialGUID && fIsNotSpecialGUID )
            RRETURN( E_INVALIDARG );
    }

    // save the count of PropertyIDSets
    cNewPropIDSets += cPropertyIDSets;

    // If the consumer does not restrict the property sets
    // by specify an array of property sets and a cPropertySets
    // greater than 0, then we need to make sure we
    // have some to return
    if( cPropertyIDSets == 0 )
    {
        if( fDSOInitialized )
            cNewPropIDSets = NUMBER_OF_SUPPORTED_PROPERTY_SETS;
        else
            // we have 2 property sets in the DBINIT property group
            cNewPropIDSets = 2;
    }

    // use task memory allocater to alloc a DBPROPINFOSET struct
    pPropInfoSet = (DBPROPINFOSET*) _pIMalloc->Alloc(cNewPropIDSets *
                                                                                                sizeof( DBPROPINFOSET ));
    if( !pPropInfoSet )
        BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );

    memset( pPropInfoSet, 0, (cNewPropIDSets * sizeof( DBPROPINFOSET )));

    if( ppDescBuffer )
    {
        // Allocating more memory than actually required, since 
        // _dwDescBufferLen is th etotal for all property sets together, not
        // just for one property set 
        pwszDescBuffer = (LPWSTR) _pIMalloc->Alloc(_dwDescBufferLen * cNewPropIDSets);
        if( !pwszDescBuffer )
            BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );

        memset( pwszDescBuffer, 0, _dwDescBufferLen * cNewPropIDSets);
        *ppDescBuffer = pwszDescBuffer;
    }

    // If no restrictions return all properties from the three supported property sets
    if( cPropertyIDSets == 0 )
    {
        // Fill in all of the Providers Properties
        for (j=0; j< cNewPropIDSets; j++)
            pPropInfoSet[j].guidPropertySet = *s_rgPropertySets[j].guidPropertySet;
    }
    else
    {
        cCount = 0;

        //
        // Deal with the Special GUID's
        //
        for (j=0; j< cPropertyIDSets; j++)
        {
            if( rgPropertyIDSets[j].guidPropertySet == DBPROPSET_DBINITALL )
            {
                pPropInfoSet[cCount].guidPropertySet = DBPROPSET_DBINIT;
                // Adjust for ADSI_BIND (provider specific) property set
                cCount++;
                pPropInfoSet[cCount].guidPropertySet = DBPROPSET_ADSIBIND;
            }
            else if( fDSOInitialized &&
                     rgPropertyIDSets[j].guidPropertySet == DBPROPSET_DATASOURCEINFOALL )
                pPropInfoSet[cCount].guidPropertySet = DBPROPSET_DATASOURCEINFO;
            else if( fDSOInitialized &&
                     rgPropertyIDSets[j].guidPropertySet == DBPROPSET_SESSIONALL )
                pPropInfoSet[cCount].guidPropertySet = DBPROPSET_SESSION;
            else if( fDSOInitialized &&
                    rgPropertyIDSets[j].guidPropertySet == DBPROPSET_ROWSETALL )
            {
                pPropInfoSet[cCount].guidPropertySet = DBPROPSET_ROWSET;
                // Adjust for the Provider Specific
                cCount++;
                pPropInfoSet[cCount].guidPropertySet = DBPROPSET_ADSISEARCH;
            }
            else
            {
                pPropInfoSet[cCount].guidPropertySet = rgPropertyIDSets[j].guidPropertySet;
                pPropInfoSet[cCount].cPropertyInfos  = rgPropertyIDSets[j].cPropertyIDs;
            }

            cCount++;
        }
    }

    //
    // For each supported Property Set
    //
    for (cPropertySets=0;
        cPropertySets < cNewPropIDSets;
        cPropertySets++)
    {
        // Set cProperties to the numerber passed in
        cProperties = pPropInfoSet[cPropertySets].cPropertyInfos;
        pPropInfo = NULL;

        // Get the correct Static data. We have 2 property sets in the
        // INIT property group. Note that we assume that both these property
        // sets occur successively in s_rgPropertySets.
        for (j=0; j< (fDSOInitialized ? NUMELEM(s_rgPropertySets) : 2); j++) {
            if( IsEqualGUID(pPropInfoSet[cPropertySets].guidPropertySet,
                            *(s_rgPropertySets[j].guidPropertySet)) ) {
                if( pPropInfoSet[cPropertySets].cPropertyInfos == 0 )
                    cProperties = s_rgPropertySets[j].cProperties;
                break;
            }
        }

        if( cProperties )
        {
            //
            // use task memory allocater to alloc array of DBPROPINFO structs
            //
            pPropInfo = (DBPROPINFO*) _pIMalloc->Alloc(cProperties * sizeof( DBPROPINFO ));
            if( !pPropInfo ) {
                for (i=0; i<cNewPropIDSets; i++)
                    _pIMalloc->Free(pPropInfoSet[i].rgPropertyInfos);
                BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );
            }

            memset(pPropInfo, 0, cProperties * sizeof(DBPROPINFO));

            for (cCount=0; cCount < cProperties; cCount++)
            {
                if( pPropInfoSet[cPropertySets].cPropertyInfos == 0 )
                    pPropInfo[cCount].dwPropertyID =
                               s_rgPropertySets[j].pUPropInfo[cCount].dwPropertyID;
                else
                    pPropInfo[cCount].dwPropertyID =
                                  rgPropertyIDSets[cPropertySets].rgPropertyIDs[cCount];

                // set the description pointer. If this property was already 
                // requested in this call, then we reuse the same description
                // pointer. 
                DWORD dwTmp;
                for(dwTmp = 0; dwTmp < cCount; dwTmp++)
                    if(pPropInfo[dwTmp].dwPropertyID == 
                                   pPropInfo[cCount].dwPropertyID) 
                    // same property requested more than once
                        break;

                if(dwTmp == cCount)
                {
                    fNewDescription = TRUE;
                    pPropInfo[cCount].pwszDescription = pwszDescBuffer;
                }
                else
                {
                    fNewDescription = FALSE;
                    pPropInfo[cCount].pwszDescription = 
                                      pPropInfo[dwTmp].pwszDescription;
                }

                hr = LoadDBPROPINFO(
                        ((j < (fDSOInitialized ? NUMELEM(s_rgPropertySets) : 2)) ?
                                        s_rgPropertySets[j].pUPropInfo  : NULL),
                        ((j < (fDSOInitialized ? NUMELEM(s_rgPropertySets) : 2)) ?
                                        s_rgPropertySets[j].cProperties : 0),
                         &pPropInfo[cCount]
                         );

                if( FAILED(hr) ) {
                    ULONG ulFor;
                    //
                    // something went wrong
                    // clear all variants used so far..
                    //
                    for (ulFor = 0; ulFor < cCount; ulFor++)
                        VariantClear( &pPropInfo[ulFor].vValues );

                    //
                    // .. delete the pPropInfo array, return failure
                    //
                    for (i=0; i<cNewPropIDSets; i++)
                        _pIMalloc->Free(pPropInfoSet[i].rgPropertyInfos);

                    _pIMalloc->Free(pPropInfo);
                    BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );
                }

                if( hr != S_OK )
                    fWarning = TRUE;
                else
                    fNoPropInfoGot = FALSE;

                // move the description pointer to the next, if required
                if( pPropInfo[cCount].pwszDescription && fNewDescription)
                    pwszDescBuffer += (wcslen(pPropInfo[cCount].pwszDescription) + 1);
            }
        }
        else
            fWarning = TRUE;

        pPropInfoSet[cPropertySets].rgPropertyInfos = pPropInfo;
        pPropInfoSet[cPropertySets].cPropertyInfos = cProperties;
    }    // for each property set

    //
    // set count of properties and property information
    //
    *pcPropertyInfoSets= cNewPropIDSets;
    *pprgPropertyInfoSets = pPropInfoSet;

    if( fNoPropInfoGot ) {
        if( ppDescBuffer )
            *ppDescBuffer = NULL;
        if( pwszDescBuffer )
            _pIMalloc->Free(pwszDescBuffer);
        RRETURN ( DB_E_ERRORSOCCURRED );
    }
    else if( fWarning )
       RRETURN ( DB_S_ERRORSOCCURRED );
    else
       RRETURN ( S_OK );

error:

    if( pPropInfoSet )
        _pIMalloc->Free(pPropInfoSet);
    if( pwszDescBuffer )
        _pIMalloc->Free(pwszDescBuffer);

        RRETURN ( hr );
}

//----------------------------------------------------------------------------
// IsSpecialGuid
//
// Check if the the property set GUID is one of the special GUIDs
//
//----------------------------------------------------------------------------
BOOL CUtilProp::IsSpecialGuid(
    GUID guidPropSet
    )
{
    if( (DBPROPSET_ROWSETALL == guidPropSet) || 
        (DBPROPSET_DATASOURCEALL == guidPropSet) ||
        (DBPROPSET_DATASOURCEINFOALL == guidPropSet) ||
        (DBPROPSET_SESSIONALL == guidPropSet) ||
        (DBPROPSET_DBINITALL == guidPropSet) 

#if (!defined(BUILD_FOR_NT40)) 
                                             ||
        (DBPROPSET_COLUMNALL == guidPropSet) ||
        (DBPROPSET_CONSTRAINTALL == guidPropSet) ||
        (DBPROPSET_INDEXALL == guidPropSet) ||
        (DBPROPSET_TABLEALL == guidPropSet) ||
        (DBPROPSET_TRUSTEEALL == guidPropSet) ||
        (DBPROPSET_VIEWALL == guidPropSet) 
#endif
                                         )
        
        return TRUE;
    else
        return FALSE;
} 

//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::GetProperties
//
//  Synopsis:  Returns current settings of all properties supported
//             by the DSO/rowset
//
//  Arguments:
//
//             cPropertyIDSets       # of restiction property IDs
//             rgPropertyIDSets[]    restriction guids
//             pcPropertySets        count of properties returned
//             prgPropertySets       property information returned
//
//
//  Returns:
//             S_OK          | The method succeeded
//             E_INVALIDARG  | pcPropertyIDSets or prgPropertyInfo was NULL
//             E_OUTOFMEMORY | Out of memory
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUtilProp::GetProperties
(
    ULONG               cPropertyIDSets,
    const DBPROPIDSET   rgPropertyIDSets[],
    ULONG*              pcPropertySets,
    DBPROPSET**         pprgPropertySets,
    DWORD               dwBitMask
    )
{
    ULONG       cPropertySets, cProperties;
    ULONG       cNewPropIDSets = 0;
    ULONG       cCount, j, i;
    DBPROP*     pProp = NULL;
    DBPROPSET*  pPropSet = NULL;
    HRESULT     hr = E_FAIL;
    BOOL        fNoPropertyGot = TRUE;
    BOOL        fWarning = FALSE;
    BOOL        fFound = FALSE;
    ULONG       cOffset = 0;

    // asserts
    ADsAssert(_pIMalloc);

    // Assign in the count
    cNewPropIDSets = cPropertyIDSets;

    // If the consumer does not restrict the property sets
    // by specify an array of property sets and a cPropertySets
    // greater than 0, then we need to make sure we
    // have some to return
    if( cPropertyIDSets == 0 )
    {
        // Set the count of properties
        cNewPropIDSets = 1;

        if(dwBitMask & PROPSET_DSO)
        {
            if(dwBitMask & PROPSET_INIT)
                // if the data src object has been initialized, return
                // properties in the DBInit, DSInfo and ADSIBind property sets.
                cNewPropIDSets = 3;
            else
                // Return DBInit and ADSIBind property sets only. Note that we
                // are counting on ADSIBind being the second property set in
                // s_rgPropertySets, since we are leaving cOffset as 0
                cNewPropIDSets = 2;
        }

         if(dwBitMask & PROPSET_COMMAND)
            cNewPropIDSets = 2;
    }

    // Figure out the Offset
    if( dwBitMask & PROPSET_SESSION )
        cOffset = INDEX_SESSION;
    else if( dwBitMask & PROPSET_COMMAND )
        cOffset = INDEX_ROWSET;

    //
    // use task memory allocater to alloc a DBPROPSET struct
    //
    pPropSet = (DBPROPSET*) _pIMalloc->Alloc(cNewPropIDSets * sizeof( DBPROPSET ));

    if( !pPropSet )
        BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );

    memset( pPropSet, 0, (cNewPropIDSets * sizeof( DBPROPSET )));

    //
    // For each supported Property Set
    //
    for (cPropertySets=0; cPropertySets < cNewPropIDSets; cPropertySets++) {

        // Initialize variable
        ULONG cPropOffset = 0;
        int cNumDSOProps = 0;
        cProperties = 0;
        pProp = NULL;
        fFound = FALSE;

        // Setup the PropSet GUID
        if( cPropertyIDSets == 0 ) {
            pPropSet[cPropertySets].guidPropertySet =
                       *s_rgPropertySets[cPropertySets+cOffset].guidPropertySet;
        }
        else {
            cProperties = rgPropertyIDSets[cPropertySets].cPropertyIDs;
            pPropSet[cPropertySets].guidPropertySet =
                    rgPropertyIDSets[cPropertySets].guidPropertySet;
        }

        if(dwBitMask & PROPSET_DSO)
             // we have 2 property sets whose properties can be set before
             // initialization and one whose properties can be set only after
             // init. Set the count of properties accordingly.
             cNumDSOProps = 1 + !!(dwBitMask & PROPSET_INIT);

        // Setup the count of Properties for that PropSet
        for (j=0;
             j <= cOffset+ cNumDSOProps + !!(dwBitMask & PROPSET_COMMAND);
             j++) {
            if( j >= cOffset &&
                IsEqualGUID(pPropSet[cPropertySets].guidPropertySet,
                            *(s_rgPropertySets[j].guidPropertySet)) ) {
                if (rgPropertyIDSets == NULL ||
                    rgPropertyIDSets[cPropertySets].cPropertyIDs == 0)
                    cProperties = s_rgPropertySets[j].cProperties;

                fFound = TRUE;
                break;
            }

            // Move to the next PropSet
            cPropOffset += s_rgPropertySets[j].cProperties;
        }

        if( cProperties != 0 ) {
            // use task memory allocator to alloc array of DBPROP struct
            pProp = (DBPROP*) _pIMalloc->Alloc(cProperties * sizeof( DBPROP ));

            if( pProp == NULL ) {
                for (i=0; i < cPropertySets; i++)
                    _pIMalloc->Free(pPropSet[i].rgProperties);

                BAIL_ON_FAILURE ( hr=E_OUTOFMEMORY );
            }

            memset( pProp, 0, (cProperties * sizeof( DBPROP )));

            if( rgPropertyIDSets == NULL ||
                rgPropertyIDSets[cPropertySets].cPropertyIDs == 0 ) {
                for (cCount=0; cCount < cProperties; cCount++)
                    pProp[cCount].dwPropertyID =
                        s_rgPropertySets[j-!fFound].pUPropInfo[cCount].dwPropertyID;
            }
            else {
                for (cCount=0; cCount < cProperties; cCount++)
                    pProp[cCount].dwPropertyID =
                        rgPropertyIDSets[cPropertySets].rgPropertyIDs[cCount];
            }
        }
        else
            fWarning = TRUE;

        //
        // for each prop in our table..
        //
        for (cCount = 0; cCount < cProperties; cCount++) {
            hr = LoadDBPROP((fFound ? &(_prgProperties[cPropOffset]) :  NULL),
                            (fFound ? s_rgPropertySets[j-!fFound].cProperties : 0),
                            &pProp[cCount],
                            pPropSet[cPropertySets].guidPropertySet == DBPROPSET_DBINIT
                            );

            if( FAILED(hr) ) {
                // something went wrong
                // clear all variants used so far..
                for (i=0; i < cCount; i++)
                    VariantClear( &pProp[i].vValue );

                for (i=0; i < cPropertySets; i++)
                    _pIMalloc->Free(pPropSet[i].rgProperties);

                                _pIMalloc->Free(pProp);

                BAIL_ON_FAILURE( hr );
            }

            if( hr != S_OK )
                fWarning = TRUE;
            else
                fNoPropertyGot = FALSE;

        }    // for each property

        pPropSet[cPropertySets].rgProperties = pProp;
        pPropSet[cPropertySets].cProperties = cProperties;
    }    // for each property set

    // set count of properties and property informatio
    *pcPropertySets   = cNewPropIDSets;
    *pprgPropertySets = pPropSet;

    if( fNoPropertyGot )
       RRETURN( DB_E_ERRORSOCCURRED );
    else if( fWarning )
       RRETURN( DB_S_ERRORSOCCURRED );
    else
       RRETURN( S_OK );

error:
    if( pPropSet )
        _pIMalloc->Free(pPropSet);
    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CUtilProp::SetProperties
//
//  Synopsis:  Set current settings of properties supported by the DSO/rowset
//
//  Arguments:
//
//             cPropertyIDSets,      # of DBPROPSET
//             rgPropertyIDSets[]    Array of property sets
//
//  Returns:
//             S_OK          | The method succeeded
//             E_INVALIDARG  | pcPropertyIDSets or prgPropertyInfo was NULL
//             E_OUTOFMEMORY | Out of memory
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CUtilProp::SetProperties(
    ULONG cPropertySets,
    DBPROPSET rgPropertySets[],
    DWORD dwBitMask
    )
{
    ULONG cCount, j, k;
    HRESULT hr;
    BOOL fNoPropertySet = TRUE;
    BOOL fWarning = FALSE;

    // check params
    if( cPropertySets > 0 && !rgPropertySets )
        RRETURN ( E_INVALIDARG );

    // New argument check for > 1 cPropertyIDs and NULL pointer for
    // array of property ids.
    for(ULONG ul=0; ul<cPropertySets; ul++)
    {
        if( rgPropertySets[ul].cProperties &&
            !(rgPropertySets[ul].rgProperties) )
            RRETURN ( E_INVALIDARG );
    }

    for (cCount=0; cCount < cPropertySets; cCount++) {
        // Not legal to Set INIT or DATASOURCE properties after Initializing
        if( (dwBitMask & PROPSET_INIT) &&
            (rgPropertySets[cCount].guidPropertySet == DBPROPSET_DBINIT) ) {
            //
            // Wrong time to set these Properties
            //
            for (k=0; k < rgPropertySets[cCount].cProperties; k++) {
                rgPropertySets[cCount].rgProperties[k].dwStatus = DBPROPSTATUS_NOTSETTABLE;
                fWarning = TRUE;
            }
            continue;
        }

        // Trying to set the wrong Property Set
        if( ((dwBitMask & PROPSET_DSO) && !(dwBitMask & PROPSET_INIT) &&
             (rgPropertySets[cCount].guidPropertySet != DBPROPSET_DBINIT &&
              rgPropertySets[cCount].guidPropertySet != DBPROPSET_ADSIBIND)) ||
            ((dwBitMask & PROPSET_DSO) && (dwBitMask & PROPSET_INIT) &&
             rgPropertySets[cCount].guidPropertySet != DBPROPSET_DATASOURCEINFO) ||
            ((dwBitMask & PROPSET_SESSION) &&
             rgPropertySets[cCount].guidPropertySet != DBPROPSET_SESSION) ||
            ((dwBitMask & PROPSET_COMMAND) &&
             rgPropertySets[cCount].guidPropertySet != DBPROPSET_ROWSET &&
             rgPropertySets[cCount].guidPropertySet != DBPROPSET_ADSISEARCH) ) {

            //
            // Wrong Property Set
            //
            for (k=0; k < rgPropertySets[cCount].cProperties; k++) {
                rgPropertySets[cCount].rgProperties[k].dwStatus = DBPROPSTATUS_NOTSUPPORTED;
                fWarning = TRUE;
            }
            continue;
        }

        ULONG cPropOffset = 0;

        for (j=0; j< NUMELEM(s_rgPropertySets); j++) {
            if (IsEqualGUID(rgPropertySets[cCount].guidPropertySet,
                            *(s_rgPropertySets[j].guidPropertySet))) {
                for (k=0; k < rgPropertySets[cCount].cProperties; k++) {
                    hr = StoreDBPROP(&(_prgProperties[cPropOffset]),
                                     s_rgPropertySets[j].pUPropInfo,
                                     s_rgPropertySets[j].cProperties,
                                     &(rgPropertySets[cCount].rgProperties[k]),
                                     j );

                    if( hr != S_OK )
                        fWarning = TRUE;
                    else
                        fNoPropertySet = FALSE;
                }
                break;
            }
            // Move to the next PropSet
            cPropOffset += s_rgPropertySets[j].cProperties;
        }
    }

    if ( fNoPropertySet && fWarning )
       RRETURN ( DB_E_ERRORSOCCURRED );
    else if (fWarning)
       RRETURN ( DB_S_ERRORSOCCURRED );
    else
       RRETURN ( S_OK );
}


BOOL
CUtilProp::IsIntegratedSecurity(
    void
    )
{
    // Check to see if SSPI is set
    for (ULONG i=0; i< s_rgPropertySets[INDEX_INIT].cProperties; i++) {
        if( _prgProperties[i].dwPropertyID == DBPROP_AUTH_INTEGRATED)
        {
            if (_prgProperties[i].pwstrVal )
                return( wcscmp(_prgProperties[i].pwstrVal, L"SSPI") == 0 );
            break;
        }
    }

    return FALSE;
}

BOOL
CUtilProp::IsADSIFlagSet()
{
    ULONG PropSetOffset = 0, i;

    for(i = 0; i < INDEX_ADSIBIND; i++)
          PropSetOffset += s_rgPropertySets[i].cProperties;

    // Check if "ADSI Flag" is set to something other than ADS_AUTH_RESERVED 
    for (i=0; i < s_rgPropertySets[INDEX_ADSIBIND].cProperties; i++)
        if(_prgProperties[i+PropSetOffset].dwPropertyID == ADSIPROP_ADSIFLAG)
             return (_prgProperties[i+PropSetOffset].longVal != 
                                                           ADS_AUTH_RESERVED);

    // we should never get here
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\sql\sqltree.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       SqlTree.cxx
//
//  Contents:   Implementation of the SQL Query Tree to convert SQL queries
//              to LDAP queries
//
//  Functions:
//
//  History:    12-Dec-96   Felix Wong  Created.
//
//----------------------------------------------------------------------------
#include "lexer.hxx"
#include "sqltree.hxx"
#include "sqlparse.hxx"

//+---------------------------------------------------------------------------
//
//  Function:  CSQLNode::CSQLNode
//
//  Synopsis:  Constructor of the CSQLNode
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
CSQLNode::CSQLNode()
{
    _dwType = 0;
    _szValue = NULL;
    _pLQueryNode = NULL;
    _pRQueryNode = NULL;
}


//+---------------------------------------------------------------------------
//
//  Function:  CSQLNode::CSQLNode
//
//  Synopsis:  Constructor of the CSQLNode
//
//  Arguments:  dwType          type of node
//              pLQueryNode     pointer to left node
//              pRQueryNode     pointer to right node
//
//  Returns:    
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
CSQLNode::CSQLNode(
    DWORD dwType,
    CSQLNode *pLQueryNode,
    CSQLNode *pRQueryNode
    )
{
    _dwType = dwType;
    _pLQueryNode = pLQueryNode;
    _pRQueryNode = pRQueryNode;
}

//+---------------------------------------------------------------------------
//
//  Function:  CSQLNode::SetToString
//
//  Synopsis:  Set the Node to be a String Node
//
//  Arguments: szValue      value of the string
//
//  Returns:    
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT CSQLNode::SetToString(
    LPWSTR szValue
    )
{
    _szValue = szValue;
    _dwType = QUERY_STRING;
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:  CSQLNode::~CSQLNode
//
//  Synopsis:  Destructor of the CSQLNode
//
//  Arguments: 
//
//  Returns:    
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
CSQLNode::~CSQLNode()
{
    if ((_dwType == QUERY_STRING) && _szValue) {
        FreeADsStr(_szValue);
    }
    
    if (_pLQueryNode) {
        delete _pLQueryNode;
    }
    
    if (_pRQueryNode) {
        delete _pRQueryNode;
    }
}



// Helper Functions for creating nodes using the CSQLNode Class

//+---------------------------------------------------------------------------
//
//  Function:  MakeNode
//
//  Synopsis:  Make a node with the input values
//
//  Arguments:  dwType              type of node
//              pLQueryNode         pointer to left node
//              pRQueryNode         pointer to right node
//              ppQueryNodeReturn   pointer to Return Node
//
//  Returns:    
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT MakeNode(
    DWORD dwType,
    CSQLNode *pLQueryNode,
    CSQLNode *pRQueryNode,
    CSQLNode **ppQueryNodeReturn
    )
{
    CSQLNode *pQueryNode = new CSQLNode(
                                      dwType,
                                      pLQueryNode,
                                      pRQueryNode
                                      );
    if (!pQueryNode)
        return E_OUTOFMEMORY;
    *ppQueryNodeReturn = pQueryNode;
    return S_OK;
}
    
//+---------------------------------------------------------------------------
//
//  Function:  MakeLeaf
//
//  Synopsis:  Constructor of the CSQLNode
//
//  Arguments: szValue              value of the string
//             ppQueryNodeReturn    the return node
//
//  Returns:    
//
//  Modifies:
//
//  History:    11-12-96   Felix Wong Created.
//
//----------------------------------------------------------------------------
HRESULT MakeLeaf(
    LPWSTR szValue,
    CSQLNode **ppQueryNodeReturn
    )
{
    HRESULT hr = S_OK;

    CSQLNode *pQueryNode = new CSQLNode();
    if (!pQueryNode)
        return E_OUTOFMEMORY;
        
    hr = pQueryNode->SetToString(szValue);
    BAIL_ON_FAILURE(hr);
    
    *ppQueryNodeReturn = pQueryNode;
    RRETURN(hr);

error:
    delete pQueryNode;
    RRETURN(hr);
}

typedef struct _TOKEN_TO_STRING {
    DWORD dwToken;
    LPWSTR szToken;
} TOKEN_TO_STRING, *LPTOKEN_TO_STRING;

TOKEN_TO_STRING SqlTokenMap[] = 
{
    { TOKEN_EQ,       L"="},
    { TOKEN_LT,       L"<="},
    { TOKEN_GT,       L">="},
    { TOKEN_LE,       L"<="},
    { TOKEN_GE,       L">="},
    { TOKEN_AND,      L"&"},
    { TOKEN_OR,       L"|"},
    { TOKEN_NOT,      L"!"},
    { 0,                0}
};

HRESULT CSQLNode::MapTokenToChar(DWORD dwToken, LPWSTR *pszToken)
{
    LPTOKEN_TO_STRING pTokenMap ;

    pTokenMap = SqlTokenMap; 

    while (pTokenMap->dwToken)
    {
        if (pTokenMap->dwToken == dwToken) {
            *pszToken = pTokenMap->szToken ;
            return S_OK;
        }
        pTokenMap++ ;
    }
    return E_FAIL;
}

HRESULT CSQLNode::GenerateLDAPString(CSQLString* pString)
{
    HRESULT hr = S_OK;

    switch (_dwType) {
        case QUERY_STRING:
            BAIL_ON_FAILURE(hr = pString->Append(_szValue));
            break;
        case TOKEN_EQ:
        case TOKEN_LE:
        case TOKEN_GE:
            {
            BAIL_ON_FAILURE(hr = pString->Append(L"("));
            BAIL_ON_FAILURE(hr = _pLQueryNode->GenerateLDAPString(pString));
            LPWSTR szToken;
            MapTokenToChar(
                       _dwType,
                       &szToken
                       );
            BAIL_ON_FAILURE(hr = pString->Append(szToken));
            BAIL_ON_FAILURE(hr = _pRQueryNode->GenerateLDAPString(pString));
            BAIL_ON_FAILURE(hr = pString->Append(L")"));
            break;
            }
    case TOKEN_LT:
    case TOKEN_GT:
        {
            BAIL_ON_FAILURE(hr = pString->Append(L"(&("));
            BAIL_ON_FAILURE(hr = _pLQueryNode->GenerateLDAPString(pString));
            LPWSTR szToken;
            MapTokenToChar(
                       _dwType,
                       &szToken
                       );
            BAIL_ON_FAILURE(hr = pString->Append(szToken));
            BAIL_ON_FAILURE(hr = _pRQueryNode->GenerateLDAPString(pString));
            BAIL_ON_FAILURE(hr = pString->Append(L")(!("));
            BAIL_ON_FAILURE(hr = _pLQueryNode->GenerateLDAPString(pString));
            BAIL_ON_FAILURE(hr = pString->Append(L"="));
            BAIL_ON_FAILURE(hr = _pRQueryNode->GenerateLDAPString(pString));
            BAIL_ON_FAILURE(hr = pString->Append(L")))"));
        break;
        }
    case TOKEN_NE:
        {
            BAIL_ON_FAILURE(hr = pString->Append(L"(!("));
            BAIL_ON_FAILURE(hr = _pLQueryNode->GenerateLDAPString(pString));
            BAIL_ON_FAILURE(hr = pString->Append(L"="));
            BAIL_ON_FAILURE(hr = _pRQueryNode->GenerateLDAPString(pString));
            BAIL_ON_FAILURE(hr = pString->Append(L"))"));
        }
        break;
    case TOKEN_NOT:
    {    
        BAIL_ON_FAILURE(hr = pString->Append(L"(!"));
        BAIL_ON_FAILURE(hr = _pLQueryNode->GenerateLDAPString(pString));
        BAIL_ON_FAILURE(hr = pString->Append(L")"));
        break;
        }
    case TOKEN_AND:
    case TOKEN_OR:
        {
        BAIL_ON_FAILURE(hr = pString->Append(L"("));
        LPWSTR szToken;
        MapTokenToChar(
                   _dwType,
                   &szToken
                   );
        BAIL_ON_FAILURE(hr = pString->Append(szToken));
        BAIL_ON_FAILURE(hr = _pLQueryNode->GenerateLDAPString(pString));
        BAIL_ON_FAILURE(hr = _pRQueryNode->GenerateLDAPString(pString));
        BAIL_ON_FAILURE(hr = pString->Append(L")"));
        break;
        }
    default:
        return E_FAIL;
    }
    return S_OK;

error:

    return hr;
}

#define SQLSTR_INC 255

CSQLString::CSQLString()
{
    _dwSizeMax = SQLSTR_INC;
    _szString = (LPWSTR)AllocADsMem(sizeof(WCHAR)*SQLSTR_INC);
    _dwSize = 0;
}

CSQLString::~CSQLString()
{
    FreeADsMem((void*)_szString);
}

HRESULT CSQLString::Append(LPWSTR szAppend)
{
    DWORD dwAppendSize = wcslen(szAppend);
    DWORD dwSizeCurrent = _dwSize + dwAppendSize + 1;

    if (dwSizeCurrent <= _dwSizeMax) {
        wcscat(
            _szString,
            szAppend
            );
        _dwSize +=dwAppendSize;
    }
    else {
        DWORD dwNewSizeMax = _dwSizeMax + SQLSTR_INC;
        while (dwSizeCurrent > dwNewSizeMax) {
            dwNewSizeMax += SQLSTR_INC;
        }
        LPWSTR szTemp = (LPWSTR)ReallocADsMem(
                                         (void*)_szString,
                                         _dwSizeMax*sizeof(WCHAR),
                                         dwNewSizeMax*sizeof(WCHAR)
                                         );
        if (!szTemp) {
            return E_OUTOFMEMORY;
        }
        _szString = szTemp;
        wcscat(
            _szString,
            szAppend
            );
        _dwSizeMax = dwNewSizeMax;
        _dwSize +=dwAppendSize;
    }
    return S_OK;
}


HRESULT CSQLString::AppendAtBegin(LPWSTR szAppend)
{

    DWORD dwAppendSize = wcslen(szAppend);
    DWORD dwSizeCurrent = _dwSize + dwAppendSize + 1;
    DWORD i = 0;

    //
    // Explicitly  move the original string and copy the new string to the
    // beginning

    if (dwSizeCurrent <= _dwSizeMax) {

        for (i=dwSizeCurrent - 1; i > dwAppendSize - 1; i--) {
            _szString[i] = _szString[i-dwAppendSize];
        }

        wcsncpy(
            _szString,
            szAppend,
            dwAppendSize
            );
        _dwSize +=dwAppendSize;
    }
    else {
        DWORD dwNewSizeMax = _dwSizeMax + SQLSTR_INC;
        while (dwSizeCurrent > dwNewSizeMax) {
            dwNewSizeMax += SQLSTR_INC;
        }
        LPWSTR szTemp = (LPWSTR)ReallocADsMem(
                                         (void*)_szString,
                                         _dwSizeMax*sizeof(WCHAR),
                                         dwNewSizeMax*sizeof(WCHAR)
                                         );
        if (!szTemp) {
            return E_OUTOFMEMORY;
        }

        _szString = szTemp;


        //
        // Explicitly  move the original string and copy the new string to the
        // beginning
    
        for (i=dwSizeCurrent - 1; i > dwAppendSize - 1; i--) {
            _szString[i] = _szString[i-dwAppendSize];
        }

        wcsncpy(
            _szString,
            szAppend,
            dwAppendSize
            );
        _dwSize +=dwAppendSize;

        _dwSizeMax = dwNewSizeMax;
        _dwSize +=dwAppendSize;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\sql\sqlparse.cxx ===
/*

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sqlparse.cxx

Abstract:

Author:

    Felix Wong [t-FelixW]    16-Dec-1996

++*/
#include "lexer.hxx"
#include "sqltree.hxx"
#include "sqlparse.hxx"

//#define DEBUG_DUMPSTACK
//#define DEBUG_DUMPRULE

#if (defined(DEBUG_DUMPSTACK) || defined (DEBUG_DUMPRULE))
#include "stdio.h"
#endif

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

// Action Table
typedef struct _action{
    DWORD type;
    DWORD dwState;
}action;

// Rule Table
typedef struct _rule{
    DWORD dwNumber;
    DWORD dwA;
}rule;

enum types {
    N,
    S,
    R,
    A
    };

#define X 99

action g_action[59][28] = {
//       ERROR  ,EQ,    STAR,  LPARAN,RPARAN,INT,   REAL,  STR,   UDN,   COMMA, LT,    GT,    LE,    GE,    NE,    SELECT,ALL,   FROM,  WHERE, BOOL,  AND,   OR,    NOT,   ORDER  BY     ASC    DESC    END
/*00*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,3 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*01*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,49},{N,X },{N,X },{N,X },{A,X } },
/*02*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*03*/  { {N,X },{N,X },{S,4 },{N,X },{N,X },{N,X },{N,X },{S,47},{S,5 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,11},{R,5 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*04*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,6 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*05*/  { {N,X },{R,10},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,10},{R,10},{R,10},{R,10},{R,10},{R,10},{N,X },{N,X },{R,10},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*06*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,4 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*07*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,7 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*08*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,9 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,8 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*09*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,47},{S,5 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*10*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,9 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*11*/  { {N,X },{N,X },{S,4 },{N,X },{N,X },{N,X },{N,X },{S,47},{S,5 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*12*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,13},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*13*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,14},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*14*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,11},{N,X },{N,X },{N,X },{N,X },{R,11},{N,X },{N,X },{N,X },{R,11} },
/*15*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,16},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,2 } },
/*16*/  { {N,X },{N,X },{N,X },{N,X },{S,23},{N,X },{N,X },{S,47},{S,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,21},{N,X },{N,X },{N,X },{N,X },{N,X } },
/*17*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,3 },{N,X },{N,X },{N,X },{R,3 } },
/*18*/  { {N,X },{N,X },{N,X },{N,X },{R,12},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,26},{N,X },{R,12},{N,X },{N,X },{N,X },{R,12} },
/*19*/  { {N,X },{N,X },{N,X },{N,X },{R,14},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,28},{R,14},{N,X },{R,14},{N,X },{N,X },{N,X },{R,14} },
/*20*/  { {N,X },{N,X },{N,X },{N,X },{R,16},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,16},{R,16},{S,21},{R,16},{N,X },{N,X },{N,X },{R,16} },
/*21*/  { {N,X },{N,X },{N,X },{S,23},{N,X },{N,X },{N,X },{S,47},{S,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*22*/  { {N,X },{N,X },{N,X },{N,X },{R,18},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,18},{R,18},{N,X },{R,18},{N,X },{N,X },{N,X },{R,18} },
/*23*/  { {N,X },{N,X },{N,X },{S,23},{N,X },{N,X },{N,X },{S,47},{S,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*24*/  { {N,X },{S,38},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,34},{S,35},{S,37},{S,36},{S,39},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*25*/  { {N,X },{R,10},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,10},{R,10},{R,10},{R,10},{R,10},{R,10},{N,X },{N,X },{R,10},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*26*/  { {N,X },{N,X },{N,X },{S,23},{N,X },{N,X },{N,X },{S,47},{S,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,21},{N,X },{N,X },{N,X },{N,X },{N,X } },
/*27*/  { {N,X },{N,X },{N,X },{N,X },{R,13},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,13},{N,X },{N,X },{N,X },{R,13} },
/*28*/  { {N,X },{N,X },{N,X },{S,23},{N,X },{N,X },{N,X },{S,47},{S,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,21},{N,X },{N,X },{N,X },{N,X },{N,X } },
/*29*/  { {N,X },{N,X },{N,X },{N,X },{R,15},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,15},{N,X },{R,15},{N,X },{N,X },{N,X },{R,15} },
/*30*/  { {N,X },{N,X },{N,X },{N,X },{R,17},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,17},{R,17},{N,X },{R,17},{N,X },{N,X },{N,X },{R,17} },
/*31*/  { {N,X },{N,X },{N,X },{N,X },{S,32},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*32*/  { {N,X },{N,X },{N,X },{N,X },{R,19},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,19},{R,19},{N,X },{R,19},{N,X },{N,X },{N,X },{R,19} },
/*33*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{S,44},{S,45},{S,41},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,43},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*34*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{R,21},{R,21},{R,21},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,21},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*35*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{R,22},{R,22},{R,22},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,22},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*36*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{R,23},{R,23},{R,23},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,23},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*37*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{R,24},{R,24},{R,24},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,24},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*38*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{R,25},{R,25},{R,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,25},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*39*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{R,26},{R,26},{R,26},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,26},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*40*/  { {N,X },{N,X },{N,X },{N,X },{R,20},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,20},{R,20},{N,X },{R,20},{N,X },{N,X },{N,X },{R,20} },
/*41*/  { {N,X },{N,X },{N,X },{N,X },{R,27},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,27},{R,27},{N,X },{R,27},{N,X },{N,X },{N,X },{R,27} },
/*42*/  { {N,X },{N,X },{N,X },{N,X },{R,28},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,28},{R,28},{N,X },{R,28},{N,X },{N,X },{N,X },{R,28} },
/*43*/  { {N,X },{N,X },{N,X },{N,X },{R,29},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,29},{R,29},{N,X },{R,29},{N,X },{N,X },{N,X },{R,29} },
/*44*/  { {N,X },{N,X },{N,X },{N,X },{R,30},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,30},{R,30},{N,X },{R,30},{N,X },{N,X },{N,X },{R,30} },
/*45*/  { {N,X },{N,X },{N,X },{N,X },{R,31},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,31},{R,31},{N,X },{R,31},{N,X },{N,X },{N,X },{R,31} },
/*46*/  { {N,X },{N,X },{N,X },{N,X },{N,X}, {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,5 },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X}  },
/*47*/  { {N,X },{R,32},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,32},{R,32},{R,32},{R,32},{R,32},{R,32},{N,X },{N,X },{R,32},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,32} },
/*48*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{A,X } },
/*49*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,50},{N,X },{N,X },{N,X } },
/*50*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,55},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*51*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,34} },
/*52*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,53},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,35} },
/*53*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,55},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X } },
/*54*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,36} },
/*55*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,37},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{S,57},{S,58},{R,37} },
/*56*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,38},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,38} },
/*57*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,39},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,39} },
/*58*/  { {N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,40},{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{N,X },{R,40} },
};

enum non_terminals {
    NONTERM_SEL_STMT,
    NONTERM_SEL_LIST_ALL,
    NONTERM_SEL_LIST,
    NONTERM_SEL_SUBLIST,
    NONTERM_COL_ID,
    NONTERM_TBL_ID,
    NONTERM_SRCH_COND,
    NONTERM_BOOL_TERM,
    NONTERM_BOOL_FACT,
    NONTERM_BOOL_PRIM,
    NONTERM_COMP,
    NONTERM_COMP_OP,
    NONTERM_LITERAL,
    NONTERM_NUM,
    NONTERM_STMT,
    NONTERM_ORDER_BY,
    NONTERM_SORT_SPEC_LIST,
    NONTERM_SORT_COL_ID,
    NONTERM_ORDER_SPEC
};


rule g_rule[] = {
//        1)No. of non-terminals and terminals on the right hand side
//        2)The Parent
/*00*/    {0, 0,                },
/*01*/    {1, NONTERM_STMT      },
/*02*/    {4, NONTERM_SEL_STMT  },
/*03*/    {6, NONTERM_SEL_STMT  },
/*04*/    {1, NONTERM_SEL_LIST_ALL    },
/*05*/    {2, NONTERM_SEL_LIST_ALL    },
/*06*/    {1, NONTERM_SEL_LIST   },
/*07*/    {1, NONTERM_SEL_LIST   },
/*08*/    {1, NONTERM_SEL_SUBLIST   },
/*09*/    {3, NONTERM_SEL_SUBLIST   },
/*10*/    {1, NONTERM_COL_ID    },
/*11*/    {1, NONTERM_TBL_ID   },
/*12*/    {1, NONTERM_SRCH_COND   },
/*13*/    {3, NONTERM_SRCH_COND   },
/*14*/    {1, NONTERM_BOOL_TERM,   },
/*15*/    {3, NONTERM_BOOL_TERM    },
/*16*/    {1, NONTERM_BOOL_FACT    },
/*17*/    {2, NONTERM_BOOL_FACT    },
/*18*/    {1, NONTERM_BOOL_PRIM   },
/*19*/    {3, NONTERM_BOOL_PRIM   },
/*20*/    {3, NONTERM_COMP },
/*21*/    {1, NONTERM_COMP_OP },
/*22*/    {1, NONTERM_COMP_OP },
/*23*/    {1, NONTERM_COMP_OP },
/*24*/    {1, NONTERM_COMP_OP },
/*25*/    {1, NONTERM_COMP_OP },
/*26*/    {1, NONTERM_COMP_OP },
/*27*/    {1, NONTERM_LITERAL  },
/*28*/    {1, NONTERM_LITERAL   },
/*29*/    {1, NONTERM_LITERAL   },
/*30*/    {1, NONTERM_NUM   },
/*31*/    {1, NONTERM_NUM   },
/*32*/    {1, NONTERM_COL_ID    },
/*33*/    {2, NONTERM_STMT    },
/*34*/    {3, NONTERM_ORDER_BY    },
/*35*/    {1, NONTERM_SORT_SPEC_LIST    },
/*36*/    {3, NONTERM_SORT_SPEC_LIST    },
/*37*/    {1, NONTERM_SORT_COL_ID    },
/*38*/    {2, NONTERM_SORT_COL_ID    },
/*39*/    {1, NONTERM_ORDER_SPEC    },
/*40*/    {1, NONTERM_ORDER_SPEC    },
};

#ifdef DEBUG_DUMPRULE
LPWSTR g_rgszRule[] = {
/*00*/      L"",
/*01*/      L"stmt -> sel_stmt",
/*02*/      L"sel_stmt -> T_SELECT sel_list_all T_FROM tbl_id",
/*03*/      L"sel_stmt -> T_SELECT sel_list_all T_FROM tbl_id T_WHERE srch_cond",
/*04*/      L"sel_list_all -> sel_list",
/*05*/      L"sel_list_all -> T_ALL sel_list",
/*06*/      L"sel_list -> T_STAR",
/*07*/      L" sel_list -> sel_sublist",
/*08*/      L" sel_sublist -> col_id",
/*09*/      L" sel_sublist -> col_id T_COMMA sel_sublist",
/*10*/      L" col_id -> T_UD_NAME",
/*11*/      L" tbl_id -> T_STRING",
/*12*/      L" srch_cond -> bool_term",
/*13*/      L" srch_cond -> bool_term T_OR srch_cond",
/*14*/      L" bool_term -> bool_fact",
/*15*/      L" bool_term -> bool_fact T_AND bool_term",
/*16*/      L" bool_fact -> bool_prim",
/*17*/      L" bool_fact -> T_NOT bool_prim",
/*18*/      L" bool_prim -> comp",
/*19*/      L" bool_prim -> T_LPARAN srch_cond T_RPARAN",
/*20*/      L" comp -> col_id comp_op literal",
/*21*/      L" comp_op -> T_LT",
/*22*/      L" comp_op -> T_GT",
/*23*/      L" comp_op -> T_GE",
/*24*/      L" comp_op -> T_LE",
/*25*/      L" comp_op -> T_EQ",
/*26*/      L" comp_op -> T_NE",
/*27*/      L" literal -> T_STRING",
/*28*/      L" literal -> num",
/*29*/      L" literal -> T_BOOL",
/*30*/      L" num -> T_INT",
/*31*/      L" num -> T_REAL",
/*32*/      L" col_id -> T_STRING",
/*33*/      L" stmt -> sel_stmt order_by_clause",
/*34*/      L" order_by_clause ::= T_ORDER T_BY sort_spec_list",
/*35*/      L" sort_spec_list ::= sort_col_id",
/*36*/      L" sort_spec_list ::= sort_col_id T_COMMA sort_spec_list",
/*37*/      L" sort_col_id ::= T_UD_NAME",
/*38*/      L" sort_col_id ::= T_UD_NAME order_spec",
/*39*/      L" order_spec ::= T_ASC",
/*40*/      L" order_spec ::= T_DESC"
};
#endif

DWORD g_goto[59][19] = {
//         Sel  sel  sel  sel  col  tbl  srch bool bool bool comp comp lit  num stmt  order sort  sort  order
//         stmt,lsta,lst, sub, id,  id,  cond,trm, fact,prim,    ,op,     ,    ,      by,   spec, col , spec ,
/*00*/    {1,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   2,    X,    X,    X,    X,   },
/*01*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    48,   X,    X,    X,   },
/*02*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*03*/    {X,   12,  6,   7,   8,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*04*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*05*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*06*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*07*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*08*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*09*/    {X,   X,   X,  10,   8,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*10*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*11*/    {X,   X,  46,   7,   8,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*12*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*13*/    {X,   X,   X,   X,   X,  15,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*14*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*15*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*16*/    {X,   X,   X,   X,  24,   X,  17,  18,  19,  20,  22,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*17*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*18*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*19*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*20*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*21*/    {X,   X,   X,   X,  24,   X,   X,   X,   X,  30,  22,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*22*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*23*/    {X,   X,   X,   X,  24,   X,  31,  18,  19,  20,  22,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*24*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,  33,   X,   X,   X,    X,    X,    X,    X,   },
/*25*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*26*/    {X,   X,   X,   X,  24,   X,  27,  18,  19,  20,  22,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*27*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*28*/    {X,   X,   X,   X,  24,   X,   X,  29,  19,  20,  22,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*29*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*30*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*31*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*32*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*33*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,  40,  42,   X,    X,    X,    X,    X,   },
/*34*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*35*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*36*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*37*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*38*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*39*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*40*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*41*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*42*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*43*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*44*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*45*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*46*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*47*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*48*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*49*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*50*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    51,   52,   X,   },
/*51*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*52*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*53*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    54,   52,   X,   },
/*54*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*55*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    56,  },
/*56*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*57*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
/*58*/    {X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,   X,    X,    X,    X,    X,   },
};

HRESULT SQLParse(
          LPWSTR szQuery,
          LPWSTR *ppszLocation,
          LPWSTR *ppszLDAPQuery,
          LPWSTR *ppszSelect,
          LPWSTR *ppszOrderList
          )
{
    //
    // check input parameters
    //
    if (!ppszLocation || !ppszLDAPQuery || !ppszSelect || !ppszOrderList) {
        return (E_INVALIDARG);
    }
    *ppszLocation = *ppszLDAPQuery = *ppszSelect = *ppszOrderList = NULL;

    CStack Stack;
    CLexer Query(szQuery);
    LPWSTR lexeme;
    DWORD dwToken;
    DWORD dwState;
    HRESULT hr = E_ADS_INVALID_FILTER;

    CSyntaxNode *pSynNode;
    CSQLNode *pNode1 = NULL;
    CSQLNode *pNode2 = NULL;
    CSQLNode *pNode3 = NULL;
    CSQLString *pString = NULL, *pOrderString = NULL;

    // Push in State 0
    pSynNode = new CSyntaxNode;
    if (!pSynNode) {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    Stack.Push(pSynNode);
    pSynNode = NULL;

#ifdef DEBUG_DUMPSTACK
    Stack.Dump();
#endif

    while (1) {
        // Getting information for this iteration, dwToken and dwState
        hr = Query.GetCurrentToken(
                                &lexeme,
                                &dwToken
                                );
        BAIL_ON_FAILURE(hr);

        hr = Stack.Current(&pSynNode);
        BAIL_ON_FAILURE(hr);

        dwState = pSynNode->_dwState;
        pSynNode = NULL;

        // Analysing and processing the data
        if (g_action[dwState][dwToken].type == S) {
            pSynNode = new CSyntaxNode;
            if (!pSynNode) {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            pSynNode->_dwState = g_action[dwState][dwToken].dwState;
            pSynNode->_dwToken = dwToken;
            switch (dwToken) {
                case TOKEN_STRING_LITERAL:
                case TOKEN_USER_DEFINED_NAME:
                case TOKEN_INTEGER_LITERAL:
                case TOKEN_REAL_LITERAL:
                case TOKEN_BOOLEAN_LITERAL:
                case TOKEN_ASC:
                case TOKEN_DESC:
                {
                    LPWSTR szValue = AllocADsStr(lexeme);
                    if (!szValue) {
                        hr = E_OUTOFMEMORY;
                        goto error;
                    }
                    pSynNode->SetNode(szValue);
                    break;
                }
            }
            hr = Stack.Push(pSynNode);
            BAIL_ON_FAILURE(hr);
            pSynNode = NULL;

            hr = Query.GetNextToken(
                               &lexeme,
                               &dwToken
                               );
            BAIL_ON_FAILURE(hr);
#ifdef DUMP
            Stack.Dump();
#endif
        }
        else if (g_action[dwState][dwToken].type == R) {
            DWORD dwRule = g_action[dwState][dwToken].dwState;
            DWORD dwNumber = g_rule[dwRule].dwNumber;
#ifdef DEBUG_DUMPRULE
            wprintf(L"%s\n",g_rgszRule[dwRule]);
#endif
            pSynNode = new CSyntaxNode;
            if (NULL == pSynNode)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            CSyntaxNode *pSynNodeRed, *pSynNodeRed2;
            switch (dwRule) {
                case 20:
                {
                    DWORD dwType;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    hr = MakeLeaf(
                               pSynNodeRed->_szValue,
                               &pNode2
                               );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    dwType = pSynNodeRed->_dwFilterType;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    hr = MakeLeaf(
                               pSynNodeRed->_szValue,
                               &pNode1
                               );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                        // New node
                    hr = MakeNode(
                               dwType,
                               pNode1,
                               pNode2,
                               &pNode3
                               );
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode3
                              );
                    pNode1 = NULL;
                    pNode2 = NULL;
                    pNode3 = NULL;
                    break;
                }
                case 13:
                case 15:
                    // Reduction of AND OR
                {
                    CSQLNode *pNode1;
                    CSQLNode *pNode2;
                    CSQLNode *pNode3;
                    DWORD dwType;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode2 = pSynNodeRed->_pSQLNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    dwType = pSynNodeRed->_dwToken;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode1 = pSynNodeRed->_pSQLNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                        // New node
                    hr = MakeNode(
                               dwType,
                               pNode1,
                               pNode2,
                               &pNode3
                               );
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode3
                              );
                    pNode1 = NULL;
                    pNode2 = NULL;
                    pNode3 = NULL;
                    break;
                }

                case 17:    // Reduction of NOT
                {
                    CSQLNode *pNode1;
                    CSQLNode *pNode2;
                    DWORD dwType;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode1 = pSynNodeRed->_pSQLNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    dwType = pSynNodeRed->_dwToken;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    // New node
                    hr = MakeNode(
                               dwType,
                               pNode1,
                               NULL,
                               &pNode2
                               );
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pNode2
                              );
                    pNode1 = NULL;
                    pNode2 = NULL;
                    break;
                }
                case 3:
                    // save entry
                {
                    CSQLNode* pNode;
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pNode = pSynNodeRed->_pSQLNode;
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;

                    for (DWORD i = 0;i<dwNumber-1;i++)
                        Stack.Pop();

                    CSQLString *pString = new CSQLString;
                    if (!pString) {
                        hr = E_OUTOFMEMORY;
                        goto error;
                    }
                    hr = pNode->GenerateLDAPString(
                                          pString
                                          );
                    BAIL_ON_FAILURE(hr);
                    delete pNode;

                    *ppszLDAPQuery = AllocADsStr(pString->_szString);
                    delete pString;
                    if (!*ppszLDAPQuery) {
                        hr = E_OUTOFMEMORY;
                        goto error;
                    }
                    break;
                }
                case 11:
                {
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    *ppszLocation = AllocADsStr(pSynNodeRed->_szValue);
                    delete pSynNodeRed;
                    break;
                }
                case 21:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                {
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_dwToken
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    break;
                }
                case 12:
                case 14:
                case 16:
                case 18:
                {
                    // we propogate the last entry
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_pSQLNode
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    break;
                }
                case 10:
                case 27:
                case 29:
                case 30:
                case 31:
                case 28:
                                    case 32:
                case 37:
                case 39:
                case 40:
                {
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_szValue
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    break;
                }
                case 19:
                {
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pSynNode->SetNode(
                              pSynNodeRed->_pSQLNode
                              );
                    pSynNodeRed->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    break;
                }
                case 8:
                {
                    pString = new CSQLString;
                    if (NULL == pString)
                        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    BAIL_ON_FAILURE(
                        hr = pString->Append(pSynNodeRed->_szValue));
                    delete pSynNodeRed;
                    break;
                }
                case 9:
                {
                    CSQLNode *pNode;
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    BAIL_ON_FAILURE(
                        hr = pString->Append(L","));
                    BAIL_ON_FAILURE(
                        hr = pString->Append(pSynNodeRed->_szValue));
                    delete pSynNodeRed;
                    break;
                }
                case 35:
                {
                    pOrderString = new CSQLString;
                    if (NULL == pOrderString)
                        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    BAIL_ON_FAILURE(
                        hr = pOrderString->Append(pSynNodeRed->_szValue));
                    delete pSynNodeRed;
                    break;
                }
                case 36:
                {
                    CSQLNode *pNode;
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    hr = Stack.Pop();
                    BAIL_ON_FAILURE(hr);
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    pOrderString->AppendAtBegin(L",");
                    pOrderString->AppendAtBegin(pSynNodeRed->_szValue);
                    delete pSynNodeRed;
                    break;
                }
                case 38:
                {
                    CSQLNode *pNode;
                    LPWSTR pTemp = NULL;
                    hr = Stack.Pop(&pSynNodeRed);
                    BAIL_ON_FAILURE(hr);
                    hr = Stack.Pop(&pSynNodeRed2);
                    BAIL_ON_FAILURE(hr);
                    pTemp = (LPWSTR) AllocADsMem((wcslen(pSynNodeRed2->_szValue) +
                                        wcslen(pSynNodeRed->_szValue) +
                                        wcslen(L" ") + 1) * sizeof(WCHAR));
                    if (!pTemp) {
                        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                    }

                    wsprintf(pTemp, L"%s %s",
                             pSynNodeRed2->_szValue,
                             pSynNodeRed->_szValue);

                    pSynNode->SetNode( pTemp );

                    //
                    // In all other cases the _dwType of the deleted nodes is 
                    // set to SNODE_NULL before deletion because the data contained
                    // in the node is transferred to the new node.
                    // In this case, we have effectively copied the data (with the
                    // wsprintf statement) and so we should not alter the _dwType of
                    // the nodes before deletion because we do want the nodes to 
                    // clean up their data.
                    //
                    //pSynNodeRed->_dwType = SNODE_NULL;
                    //pSynNodeRed2->_dwType = SNODE_NULL;
                    delete pSynNodeRed;
                    delete pSynNodeRed2;
                    break;
                }
                default:
                {
                    for (DWORD i = 0;i<dwNumber;i++)
                        Stack.Pop();
                    break;
                }
            }
            hr = Stack.Current(&pSynNodeRed);
            BAIL_ON_FAILURE(hr);

            dwState = pSynNodeRed->_dwState;

            DWORD A = g_rule[dwRule].dwA;
            pSynNode->_dwState = g_goto[dwState][A];
            pSynNode->_dwToken = A;
            hr = Stack.Push(pSynNode);
            BAIL_ON_FAILURE(hr);
            pSynNode = NULL;

#ifdef DEBUG_DUMPSTACK
            Stack.Dump();
#endif
        }
        else if (g_action[dwState][dwToken].type == A){
            if (pString == NULL) {
                *ppszSelect = AllocADsStr(L"*");
            }
            else {
                *ppszSelect = AllocADsStr(pString->_szString);
            }
            if (!*ppszSelect) {
                hr = E_OUTOFMEMORY;
                goto error;
            }
            delete pString;

            if (pOrderString) {

                *ppszOrderList = AllocADsStr(pOrderString->_szString);
                if (!*ppszOrderList) {
                    hr = E_OUTOFMEMORY;
                    goto error;
                }
                delete pOrderString;
            }
            return S_OK;
        }
        else {
            hr = E_ADS_INVALID_FILTER;
            goto error;
        }
    }
error:
    if (pSynNode)
        delete pSynNode;
    if (pNode1)
        delete pNode1;
    if (pNode2)
        delete pNode2;
    if (pNode3)
        delete pNode3;
    if (pString)
        delete pString;
    if (pOrderString)
        delete pOrderString;
    if (*ppszSelect)
    {
        FreeADsMem(*ppszSelect);
        *ppszSelect = NULL;
    }
    if (*ppszLocation)
    {
        FreeADsMem(*ppszLocation);
        *ppszLocation = NULL;
    }
    if (*ppszLDAPQuery)
    {
        FreeADsMem(*ppszLDAPQuery);
        *ppszLDAPQuery = NULL;
    }
    if (*ppszOrderList)
    {
        FreeADsMem(*ppszOrderList);
        *ppszOrderList = NULL;
    }
    return hr;
}


CStack::CStack()
{
    _dwStackIndex = 0;
}

CStack::~CStack()
{
    DWORD dwIndex = _dwStackIndex;
    while  (dwIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--dwIndex];
        delete pNode;
    }
}

#ifdef DEBUG_DUMPSTACK
void CStack::Dump()
{
    DWORD dwIndex = _dwStackIndex;
    printf("Stack:\n");
    while  (dwIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--dwIndex];
        printf(
           "State=%5.0d, Token=%5.0d\n",
           pNode->_dwState,
           pNode->_dwToken
           );
    }
}
#endif

HRESULT CStack::Push(CSyntaxNode* pNode)
{
    if (_dwStackIndex < MAXVAL) {
        _Stack[_dwStackIndex++] = pNode;
        return S_OK;
    }
    else
        return E_FAIL;
}

HRESULT CStack::Pop(CSyntaxNode** ppNode)
{
    if (_dwStackIndex > 0) {
        *ppNode =  _Stack[--_dwStackIndex];
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

HRESULT CStack::Pop()
{
    if (_dwStackIndex > 0) {
        CSyntaxNode *pNode;
        pNode = _Stack[--_dwStackIndex];
        delete pNode;
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}

HRESULT CStack::Current(CSyntaxNode **ppNode)
{
    if (_dwStackIndex > 0) {
        *ppNode =  _Stack[_dwStackIndex-1];
        return S_OK;
    }
    else {
        return E_FAIL;
    }
}


CSyntaxNode::CSyntaxNode()
{
    _dwType = SNODE_NULL;
    _dwToken = 0;
    _dwState = 0;
    _pSQLNode = 0;
}

CSyntaxNode::~CSyntaxNode()
{
    switch (_dwType) {
        case SNODE_SZ:
            FreeADsStr(_szValue);
            break;
        case SNODE_SQLNODE:
            delete _pSQLNode;
            break;
        default:
            break;
    }
}


void CSyntaxNode::SetNode(
                    CSQLNode *pSQLNode
                    )
{
    _pSQLNode = pSQLNode;
    _dwType = SNODE_SQLNODE;
}

void CSyntaxNode::SetNode(
                     LPWSTR szValue
                     )
{
    _szValue = szValue;
    _dwType = SNODE_SZ;
}

void CSyntaxNode::SetNode(
                    DWORD dwFilterType
                    )
{
    _dwFilterType = dwFilterType;
    _dwType = SNODE_FILTER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\types\header.h ===
#define OLEDS_LIBIID_ADs                          97d25db0-0363-11cf-abc4-02608c9e7553

#define OLEDS_IID_IADs                            fd8256d0-fd15-11ce-abc4-02608c9e7553
#define OLEDS_IID_IADsContainer                   001677d0-fd16-11ce-abc4-02608c9e7553

#define OLEDS_IID_IADsClass                       c8f93dd0-4ae0-11cf-9e73-00aa004a5691
#define OLEDS_IID_IADsProperty                    c8f93dd3-4ae0-11cf-9e73-00aa004a5691
#define OLEDS_IID_IADsSyntax                      c8f93dd2-4ae0-11cf-9e73-00aa004a5691

#define OLEDS_IID_IADsCollection                  72b945e0-253b-11cf-a988-00aa006bc149
#define OLEDS_IID_IADsMembers                     451a0030-72ec-11cf-b03b-00aa006e0975

#define OLEDS_IID_IADsNamespaces                  28b96ba0-b330-11cf-a9ad-00aa006bc149

#define OLEDS_IID_IADsDomain                      00e4c220-fd16-11ce-abc4-02608c9e7553

#define OLEDS_IID_IADsLocality                    a05e03a2-effe-11cf-8abc-00c04fd8d503
#define OLEDS_IID_IADsO                           a1cd2dc6-effe-11cf-8abc-00c04fd8d503
#define OLEDS_IID_IADsOU                          a2f733b8-effe-11cf-8abc-00c04fd8d503

#define OLEDS_IID_IADsComputer                    efe3cc70-1d9f-11cf-b1f3-02608c9e7553
#define OLEDS_IID_IADsComputerOperations          ef497680-1d9f-11cf-b1f3-02608c9e7553

#define OLEDS_IID_IADsGroup                       27636b00-410f-11cf-b1ff-02608c9e7553
#define OLEDS_IID_IADsGroupOperations             257760a0-410f-11cf-b1ff-02608c9e7553

#define OLEDS_IID_IADsUser                        3e37e320-17e2-11cf-abc4-02608c9e7553

#define OLEDS_IID_IADsPrintQueue                  b15160d0-1226-11cf-a985-00aa006bc149
#define OLEDS_IID_IADsPrintQueueOperations        124be5c0-156e-11cf-a986-00aa006bc149

#define OLEDS_IID_IADsPrintJob                    32fb6780-1ed0-11cf-a988-00aa006bc149
#define OLEDS_IID_IADsPrintJobOperations          9a52db30-1ecf-11cf-a988-00aa006bc149

#define OLEDS_IID_IADsService                     68af66e0-31ca-11cf-a98a-00aa006bc149
#define OLEDS_IID_IADsServiceOperations           5d7b33f0-31ca-11cf-a98a-00aa006bc149

#define OLEDS_IID_IADsFileService                 a89d1900-31ca-11cf-a98a-00aa006bc149
#define OLEDS_IID_IADsFileServiceOperations       a02ded10-31ca-11cf-a98a-00aa006bc149

#define OLEDS_IID_IADsFileShare                   eb6dcaf0-4b83-11cf-a995-00aa006bc149
#define OLEDS_IID_IADsSession                     398b7da0-4aab-11cf-ae2c-00aa006ebfb9
#define OLEDS_IID_IADsResource                    34a05b20-4aab-11cf-ae2c-00aa006ebfb9

#define OLEDS_IID_IADsOpenDSObject                ddf2891e-0f9c-11d0-8ad4-00c04fd8d503

#define OLEDS_IID_IADsSearch                      C69F7780-4008-11D0-B94C-00C04FD8D5A8

#define OLEDS_IID_IDirectoryObject                e798de2c-22e4-11d0-84fe-00c04fd8d503

#define OLEDS_IID_IDirectorySearch                109ba8ec-92f0-11d0-a790-00c04fd8d5a8

#define OLEDS_IID_IDirectorySchemaMgmt            75db3b9c-a4d8-11d0-a79c-00c04fd8d5a8

#define OLEDS_IID_IADsPropertyList                c6f602b6-8f69-11d0-8528-00c04fd8d503

#define OLEDS_IID_IADsAggregatee                  1346ce8c-9039-11d0-8528-00c04fd8d503

#define OLEDS_IID_IADsAggregator                  52db5fb0-941f-11d0-8529-00c04fd8d503

#define OLEDS_IID_IADsPropertyEntry               05792c8e-941f-11d0-8529-00c04fd8d503
#define OLEDS_CLSID_PropertyEntry                 72d3edc2-a4c4-11d0-8533-00c04fd8d503

#define OLEDS_IID_IADsAttrInfo                    af1206f6-aef7-11d0-8537-00c04fd8d503

#define OLEDS_IID_IADsPropertyValue               79fa9ad0-a97c-11d0-8534-00c04fd8d503
#define OLEDS_CLSID_PropertyValue                 7b9e38b0-a97c-11d0-8534-00c04fd8d503

#define OLEDS_IID_IADsPropertyValue2              306e831c-5bc7-11d1-a3b8-00c04fb950dc

#define OLEDS_IID_IADsValue                       1e3ef0aa-aef5-11d0-8537-00c04fd8d503

#define OLEDS_IID_IADsAccessControlEntry          b4f3a14c-9bdd-11d0-852c-00c04fd8d503
#define OLEDS_CLSID_AccessControlEntry            b75ac000-9bdd-11d0-852c-00c04fd8d503
#define OLEDS_IID_IADsAccessControlList           b7ee91cc-9bdd-11d0-852c-00c04fd8d503
#define OLEDS_CLSID_AccessControlList             b85ea052-9bdd-11d0-852c-00c04fd8d503
#define OLEDS_IID_IADsSecurityDescriptor          b8c787ca-9bdd-11d0-852c-00c04fd8d503
#define OLEDS_CLSID_SecurityDescriptor            b958f73c-9bdd-11d0-852c-00c04fd8d503
#define OLEDS_IID_IADsPathname                    d592aed4-f420-11d0-a36e-00c04fb950dc
#define OLEDS_CLSID_Pathname                      080d0d78-f421-11d0-a36e-00c04fb950dc
#define OLEDS_IID_IADsPathnameProvider            aacd1d30-8bd0-11d2-92a9-00c04f79f834
#define OLEDS_IID_IADsNameTranslate               b1b272a3-3625-11d1-a3a4-00c04fb950dc
#define OLEDS_CLSID_NameTranslate                 274fae1f-3626-11d1-a3a4-00c04fb950dc
#define OLEDS_CLSID_CaseIgnoreList                15f88a55-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_IID_IADsCaseIgnoreList              7b66b533-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_CLSID_FaxNumber                     a5062215-4681-11d1-a3b4-00c04fb950dc
#define OLEDS_IID_IADsFaxNumber                   a910dea9-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_CLSID_NetAddress                    b0b71247-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsNetAddress                  b21a50a9-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_CLSID_OctetList                     1241400f-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_IID_IADsOctetList                   7b28b80f-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_CLSID_Email                         8f92a857-478e-11d1-a3b4-00c04fb950dc
#define OLEDS_IID_IADsEmail                       97af011a-478e-11d1-a3b4-00c04fb950dc
#define OLEDS_CLSID_Path                          b2538919-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsPath                        b287fcd5-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_CLSID_ReplicaPointer                f5d1badf-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsReplicaPointer              f60fb803-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsAcl                         8452d3ab-0869-11d1-a377-00c04fb950dc
#define OLEDS_CLSID_Timestamp                     b2bed2eb-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsTimestamp                   b2f5a901-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_CLSID_PostalAddress                 0a75afcd-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_IID_IADsPostalAddress               7adecf29-4680-11d1-a3b4-00c04fb950dc
#define OLEDS_CLSID_BackLink                      fcbf906f-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsBackLink                    fd1302bd-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_CLSID_TypedName                     b33143cb-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsTypedName                   b371a349-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_CLSID_Hold                          b3ad3e13-4080-11d1-a3ac-00c04fb950dc
#define OLEDS_IID_IADsHold                        b3eb3b37-4080-11d1-a3ac-00c04fb950dc

#define OLEDS_CLSID_ADSystemInfo                  50B6327F-AFD1-11d2-9CB9-0000F87A369E
#define OLEDS_IID_IADsADSystemInfo                5BB11929-AFD1-11d2-9CB9-0000F87A369E

#define OLEDS_CLSID_WinNTSystemInfo               66182EC4-AFD1-11d2-9CB9-0000F87A369E
#define OLEDS_IID_IADsWinNTSystemInfo             6C6D65DC-AFD1-11d2-9CB9-0000F87A369E

#define OLEDS_IID_IADsLargeInteger                9068270b-0939-11d1-8be1-00c04fd8d503
#define OLEDS_CLSID_LargeInteger                  927971f5-0939-11d1-8be1-00c04fd8d503

#define OLEDS_IID_IADsDNWithString                370df02e-f934-11d2-ba96-00c04fb6d0d1
#define OLEDS_CLSID_DNWithString                  334857cc-f934-11d2-ba96-00c04fb6d0d1

#define OLEDS_IID_IADsDNWithBinary                7e99c0a2-f935-11d2-ba96-00c04fb6d0d1
#define OLEDS_CLSID_DNWithBinary                  7e99c0a3-f935-11d2-ba96-00c04fb6d0d1

#define OLEDS_IID_IADsObjectOptions               46f14fda-232b-11d1-a808-00c04fd8d5a8

#define OLEDS_IID_IADsObjOptPrivate               81cbb829-1867-11d2-9220-00c04fb6d0d1

#define OLEDS_IID_IPrivateDispatch                86ab4bbe-65f6-11d1-8c13-00c04fd8d503

#define OLEDS_IID_IPrivateUnknown                 89126bab-6ead-11d1-8c18-00c04fd8d503

#define OLEDS_IID_IADsExtension                   3d35553c-d2b0-11d1-b17b-0000f87593a0

#define OLEDS_IID_IADsDeleteOps                   b2bd0902-8878-11d1-8c21-00c04fd8d503

#define OLEDS_IID_IADsUmiHelperPrivate            4fe243f0-ad89-4cbc-9b14-486126446ae0

#define OLEDS_IID_IUmiADSIPrivate                 8f3bb40b-d4ad-4648-ae4a-6efa197a1656

#define OLEDS_IID_IADsAcePrivate                  fd145df2-fd96-4135-9b22-68ff0f6bf5bb

#define OLEDS_CLSID_ADsSecurityUtility            f270c64a-ffb8-4ae4-85fe-3a75e5347966
#define OLEDS_IID_IADsSecurityUtility             a63251b2-5f21-474b-ab52-4a8efad10895


#define PROPERTY_RW(name,type, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] type * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] type name);

#define PROPERTY_RO(name,type, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] type * retval);

#define PROPERTY_LONG_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] long ln##name);

#define PROPERTY_LONG_WO(name, prid)                  \
        [propput, id(prid)]                           \
        HRESULT name([in] long ln##name);


#define PROPERTY_LONG_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);

#define PROPERTY_BSTR_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] BSTR bstr##name);

#define PROPERTY_BSTR_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);

#define PROPERTY_VARIANT_BOOL_RW(name, prid)          \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT_BOOL * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT_BOOL f##name);

#define PROPERTY_VARIANT_BOOL_RO(name, prid)          \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT_BOOL * retval);

#define PROPERTY_VARIANT_RW(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT v##name);

#define PROPERTY_VARIANT_RO(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \

#define PROPERTY_DATE_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] DATE * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] DATE da##name);

#define PROPERTY_DATE_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] DATE * retval);


#define PROPERTY_DISPATCH_RW(name, prid)              \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] IDispatch ** retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] IDispatch * p##name);





#define DISPID_IADs_UPPER_BOUND           14
#define DISPID_IADsService_UPPER_BOUND    DISPID_IADs_UPPER_BOUND + 18
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\types\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:


--*/


#include "adstype.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\utils\date.cxx ===
#include "Procs.hxx"

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\


HRESULT
NTTimeFormattoDateFormat(
    LARGE_INTEGER *NTTimeFormat,
    DATE *DateFormat
    )
{
    *DateFormat = (DATE)0;
    RRETURN(S_OK);
}


HRESULT
ConvertDWORDtoDATE(
    DWORD dwDate,
    DATE * pdaDate,
    BOOL fIsGMT
    )
{

    FILETIME fileTime;
    SYSTEMTIME SystemTime, LocalTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;    

    if (pdaDate) {
        memset(pdaDate, 0, sizeof(DATE));
    }

    memset(&fileTime, 0, sizeof(FILETIME));

    ::RtlSecondsSince1970ToTime(dwDate, &tmpTime );

    fileTime.dwLowDateTime = tmpTime.LowPart;
    fileTime.dwHighDateTime = tmpTime.HighPart;

    if(!fIsGMT)
    // OLE DB on NDS does not convert to local file time. We don't
    // convert here to be consistent.
        FileTimeToLocalFileTime(&fileTime, &fileTime);

    if (!FileTimeToSystemTime(&fileTime, &SystemTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (!SystemTimeToVariantTime(&SystemTime, pdaDate)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}


HRESULT
ConvertDATEtoDWORD(
    DATE daDate,
    DWORD *pdwDate,
    BOOL fIsGMT
    )
{

    FILETIME fileTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;
    SYSTEMTIME systemTime;

    if (!VariantTimeToSystemTime(daDate, &systemTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (!SystemTimeToFileTime(&systemTime, &fileTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if(!fIsGMT)
    // OLE DB on NDS does not convert to local file time. We don't
    // convert here to be consistent.
        LocalFileTimeToFileTime(&fileTime, &fileTime);

    tmpTime.LowPart = fileTime.dwLowDateTime;
    tmpTime.HighPart = fileTime.dwHighDateTime;


    ::RtlTimeToSecondsSince1970(&tmpTime, (ULONG *)pdwDate);

error:
    RRETURN(hr);

}


HRESULT
ConvertDATEToDWORD(
    DATE  daDate,
    DWORD *pdwDate
    )
{
    RRETURN(S_OK);
}

HRESULT
ConvertSystemTimeToDATE(
    SYSTEMTIME Time,
    DATE *     pdaTime
    )
{
    FILETIME ft;
    BOOL fRetval = FALSE;
    USHORT wDosDate;
    USHORT wDosTime;
    SYSTEMTIME LocalTime;

    //
    // Get Time-zone specific local time.
    //

    fRetval = SystemTimeToTzSpecificLocalTime(
                  NULL,
                  &Time,
                  &LocalTime
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // System Time To File Time.
    //

    fRetval = SystemTimeToFileTime(&LocalTime,
                                   &ft);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // File Time to DosDateTime.
    //

    fRetval = FileTimeToDosDateTime(&ft,
                                    &wDosDate,
                                    &wDosTime);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // DosDateTime to VariantTime.
    //

    fRetval = DosDateTimeToVariantTime(wDosDate,
                                       wDosTime,
                                       pdaTime );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    RRETURN(S_OK);
}


HRESULT
ConvertDWORDToDATE(
    DWORD    dwTime,
    DATE *     pdaTime
    )

{
    RRETURN(S_OK);
}

HRESULT
ConvertDATEToSYSTEMTIME(
    DATE  daDate,
    SYSTEMTIME *pSysTime
    )
{
    HRESULT hr;
    FILETIME ft;
    FILETIME lft; //local file time
    BOOL fRetval = FALSE;
    SYSTEMTIME LocalTime;
    USHORT wDosDate;
    USHORT wDosTime;

    fRetval = VariantTimeToDosDateTime(daDate,
                                       &wDosDate,
                                       &wDosTime );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = DosDateTimeToFileTime(wDosDate,
                                    wDosTime,
                                    &lft);



    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    //
    // convert local file time to filetime
    //

    fRetval = LocalFileTimeToFileTime(&lft,
                                      &ft );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = FileTimeToSystemTime(&ft,
                                   pSysTime );


    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\utils\disputil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       disputil.cxx
//
//  Contents:   Dispatch Utilities.
//
//  Classes:
//
//  Functions:
//
//  History:  25-Oct-94   KrishnaG appropriated from the ADs project
//
//----------------------------------------------------------------------------

#include "procs.hxx"

#define VT_TYPEMASK   0x3ff

#define BAIL_ON_FAILURE(hr) \
    if (FAILED(hr)) {       \
        goto error;         \
    }

#define CONTINUE_ON_FAILURE(hr) \
    if (FAILED(hr)) {           \
        continue;               \
    }

HMODULE g_hActiveDs = NULL; // Module handle of activeds.dll. This should be
                            // initialized when the provider module is loaded
                            // into a process' address space. The handle
                            // is used by FillExcepInfo to retrieve error
                            // description strings from activeds.dll.

static HRESULT VARIANTARGToCVar(VARIANTARG * pvarg, VARTYPE vt, void* pv);
static void CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg);




//+---------------------------------------------------------------------------
//
//  Function:   FreeEXCEPINFO
//
//  Synopsis:   Frees resources in an excepinfo.  Does not reinitialize
//              these fields.
//
//----------------------------------------------------------------------------

void
FreeEXCEPINFO(EXCEPINFO * pEI)
{
    if (pEI)
    {
        ADsFreeString(pEI->bstrSource);
        ADsFreeString(pEI->bstrDescription);
        ADsFreeString(pEI->bstrHelpFile);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   ValidateInvoke
//
//  Synopsis:   Validates arguments to a call of IDispatch::Invoke.  A call
//              to this function takes less space than the function itself.
//
//----------------------------------------------------------------------------

HRESULT
ValidateInvoke(
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr)
{
    if (pvarResult)
        VariantInit(pvarResult);

    if (pexcepinfo)
        InitEXCEPINFO(pexcepinfo);

    if (puArgErr)
        *puArgErr = 0;

    if (!pdispparams)
        RRETURN(E_INVALIDARG);

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGToCVar
//
//  Synopsis:   Converts a VARIANT to a C-language variable.
//
//  Arguments:  [pvarg] -- Variant to convert.
//              [vt]    -- Type to convert to.
//              [pv]    -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_I2, VT_I4, VT_R4,
//              VT_R8.
//----------------------------------------------------------------------------

static HRESULT
VARIANTARGToCVar(VARIANT * pvarg, VARTYPE vt, void * pv)
{
    HRESULT     hr      = S_OK;
    VARIANTARG  vargNew;                    // variant of new type

    ADsAssert(pvarg);
    ADsAssert(pv);
    ADsAssert((vt & ~VT_TYPEMASK) == 0 || (vt & ~VT_TYPEMASK) == VT_BYREF);

    if (vt & VT_BYREF)
    {
        if (V_VT(pvarg) != vt)
        {
            hr = DISP_E_TYPEMISMATCH;
            goto Cleanup;
        }

        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
        vargNew = *pvarg;
    }
    else
    {
        VariantInit(&vargNew);
        hr = VariantChangeType(&vargNew, pvarg, 0, vt);
        if (hr)
            goto Cleanup;
    }

    switch (vt)
    {
    case VT_BOOL:
        if (V_BOOL(&vargNew) != VB_FALSE && V_BOOL(&vargNew) != VB_TRUE)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // convert VT_TRUE to TRUE
        *(BOOL *)pv = - V_BOOL(&vargNew);
        break;

    case VT_I2:
        *(short *)pv = V_I2(&vargNew);
        break;

    case VT_I4:
        *(long *)pv = V_I4(&vargNew);
        break;

    case VT_R4:
        *(float *)pv = V_R4(&vargNew);
        break;

    case VT_R8:
        *(double *)pv = V_R8(&vargNew);
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        *(void **)pv = V_BYREF(&vargNew);
        break;

    default:
        ADsAssert(FALSE && "Unknown type in VARIANTARGToCVar().\n");
        break;
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CVarToVARIANTARG
//
//  Synopsis:   Converts a C-language variable to a VARIANT.
//
//  Arguments:  [pv]    -- Pointer to C-language variable.
//              [vt]    -- Type of C-language variable.
//              [pvarg] -- Resulting VARIANT.  Must be initialized by caller.
//                         Any contents will be freed.
//
//  Modifies:   [pvarg]
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_UI2, VT_I2, VT_UI4,
//              VT_I4, VT_R4, VT_R8.
//
//----------------------------------------------------------------------------

static void
CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg)
{
    ADsAssert(pv);
    ADsAssert(pvarg);

    VariantClear(pvarg);

    V_VT(pvarg) = vt;
    if (V_ISBYREF(pvarg))
    {
        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
    }

    switch (vt)
    {
    case VT_BOOL:
        // convert TRUE to VT_TRUE
        ADsAssert(*(BOOL *) pv == 1 || *(BOOL *) pv == 0);
        V_BOOL(pvarg) = VARIANT_BOOL(-*(BOOL *) pv);
        break;

    case VT_I2:
        V_I2(pvarg) = *(short *) pv;
        break;

    case VT_I4:
        V_I4(pvarg) = *(long *) pv;
        break;

    case VT_R4:
         V_R4(pvarg) = *(float *) pv;
        break;

    case VT_R8:
        V_R8(pvarg) = *(double *) pv;
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        V_BYREF(pvarg) = *(long **)pv;
        break;

    default:
        Assert(FALSE && "Unknown type.");
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   CParamsToDispParams
//
//  Synopsis:   Converts a C parameter list to a dispatch parameter list.
//
//  Arguments:  [pDispParams] -- Resulting dispatch parameter list.
//                               Note that the rgvarg member of pDispParams
//                               must be initialized with an array of
//                               EVENTPARAMS_MAX VARIANTs.
//
//              [pvt]         -- List of C parameter types.  May be NULL.
//                               If not NULL, Last elem in list MUST be
//                               VT_EMPTY.
//
//              [va]          -- List of C arguments.
//
//  Modifies:   [pDispParams]
//
//  History:    05-Jan-94   adams   Created
//              23-Feb-94   adams   Reversed order of disp arguments, added
//                                  support for VT_R4, VT_R8, and pointer
//                                  types.
//
//  Notes:      Only types VT_I2,VT_I4, and VT_UNKNOWN are supported.
//
//----------------------------------------------------------------------------

void
CParamsToDispParams(
        DISPPARAMS *    pDispParams,
        VARTYPE *       pvt,
        va_list         va)
{
    ADsAssert(pDispParams);
    ADsAssert(pDispParams->rgvarg);

    VARIANTARG *    pvargCur;           // current variant
    VARTYPE *       pvtCur;            // current vartype

    // Assign vals to dispatch param list.
    pDispParams->cNamedArgs         = 0;
    pDispParams->rgdispidNamedArgs  = NULL;

    // Get count of arguments.
    if (!pvt)
    {
        pDispParams->cArgs = 0;
        return;
    }

    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
        ;

    pDispParams->cArgs = (DWORD)(pvtCur - pvt);
    ADsAssert(pDispParams->cArgs < EVENTPARAMS_MAX);


    //
    // Convert each C-param to a dispparam.  Note that the order of dispatch
    // parameters is the reverse of the order of c-params.
    //

    ADsAssert(pDispParams->rgvarg);
    pvargCur = pDispParams->rgvarg + pDispParams->cArgs;
    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
    {
        pvargCur--;
        ADsAssert(pvargCur >= pDispParams->rgvarg);

        V_VT(pvargCur) = *pvtCur;
        if ((*pvtCur & VT_BYREF) == VT_BYREF)
        {
            V_BYREF(pvargCur) = va_arg(va, long *);
        }
        else
        {
            switch (*pvtCur)
            {
            case VT_BOOL:
                // convert TRUE to VT_TRUE
                V_BOOL(pvargCur) = VARIANT_BOOL(-va_arg(va, BOOL));
                ADsAssert(V_BOOL(pvargCur) == VB_FALSE ||
                        V_BOOL(pvargCur) == VB_TRUE);
                break;

            case VT_I2:
                V_I2(pvargCur) = va_arg(va, short);
                break;

            case VT_I4:
                V_I4(pvargCur) = va_arg(va, long);
                break;

            case VT_R4:
                V_R4(pvargCur) = va_arg(va, float);
                break;

            case VT_R8:
                V_R8(pvargCur) = va_arg(va, double);
                break;

            //
            // All Pointer types.
            //
            case VT_BSTR:
            case VT_LPSTR:
            case VT_LPWSTR:
            case VT_DISPATCH:
            case VT_UNKNOWN:
                V_BYREF(pvargCur) = va_arg(va, long *);
                break;

            default:
                Assert(FALSE && "Unknown type.\n");
            }
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   DispParamsToCParams
//
//  Synopsis:   Converts Dispatch::Invoke method params to C-language params.
//
//  Arguments:  [pDP] -- Dispatch params to be converted.
//              [pvt] -- Array of types of C-params.  May be NULL.  If
//                       non-NULL, last element must be VT_EMPTY.
//              [...] -- List of pointers to c-params to be converted to.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types listed in VARIANTToCParam.
//
//----------------------------------------------------------------------------

STDAPI
DispParamsToCParams(
        DISPPARAMS *    pDP,
        UINT *          puArgErr,
        VARTYPE *       pvt,
        ...)
{
    HRESULT         hr;
    va_list         va;                // list of pointers to c-params.
    VARTYPE *       pvtCur;            // current VARTYPE of c-param.
    VARIANTARG *    pvargCur;          // current VARIANT being converted.
    void *          pv;                // current c-param being converted.
    int             cArgs;             // count of arguments.

    ADsAssert(pDP);

    hr = S_OK;
    va_start(va, pvt);
    if (!pvt)
    {
        if (pDP->cArgs > 0)
            goto BadParamCountError;

        goto Cleanup;
    }

    pvargCur = pDP->rgvarg + pDP->cArgs - 1;
    pvtCur = pvt;
    for (cArgs = 0; cArgs < (int)pDP->cArgs; cArgs++)
    {
        if (*pvtCur == VT_EMPTY)
            goto BadParamCountError;

        pv = va_arg(va, void *);
        hr = VARIANTARGToCVar(pvargCur, *pvtCur, pv);
        if (hr)
        {
            if (puArgErr)
                *puArgErr = cArgs;

            goto Cleanup;
        }

        pvargCur--;
        pvtCur++;
    }

    if (*pvtCur != VT_EMPTY)
        goto BadParamCountError;

Cleanup:
    va_end(va);
    RRETURN(hr);

BadParamCountError:
    hr = DISP_E_BADPARAMCOUNT;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispProp
//
//  Synopsis:   Gets a property of an object.
//
//  Arguments:  [pDisp]  -- The object containing the property.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object desired
//              [lcid]   -- The locale of the object.
//              [pvar]   -- The resulting property.  Must be initialized.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pvarg].
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
GetDispProp(
        IDispatch * pDisp,
        DISPID      dispid,
        REFIID      riid,
        LCID        lcid,
        VARIANT *   pvar,
        EXCEPINFO * pexcepinfo)
{
    HRESULT     hr;
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.
    UINT        uiErr;                 // Argument error.

    ADsAssert(pDisp);
    ADsAssert(pvar);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            pvar,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispProp
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- The object to set the property on.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object
//              [lcid]   -- The locale of the property.
//              [pvarg]  -- The value to set.
//
//  Returns:    HRESULT.
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
SetDispProp(
        IDispatch *     pDisp,
        DISPID          dispid,
        REFIID          riid,
        LCID            lcid,
        VARIANTARG *    pvarg,
        EXCEPINFO *     pexcepinfo)
{
    HRESULT     hr;
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke
    UINT        uiErr;                 // Invoke error param.

    ADsAssert(pDisp);
    ADsAssert(pvarg);

    dp.rgvarg = pvarg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispPropOfType
//
//  Synopsis:   Gets a property from an object, and converts it to a c
//              variable.
//
//  Arguments:  [pDisp]  -- The object to retrieve the property from.
//              [dispid] -- Property ID.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of c-variable to receive property.
//              [pv]     -- Pointer to resulting c-variable.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pv].
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports variable types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
GetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANT     varProp;               // Property retrieved.
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.

    ADsAssert(pDisp);
    ADsAssert(pv);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    VariantInit(&varProp);
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            &varProp,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    hr = VARIANTARGToCVar(&varProp, vt, pv);

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispPropOfType
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- Object to set property on.
//              [dispid] -- Property ID to set.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of property to set.
//              [pv]     -- Pointer to property value.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
SetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANTARG  varg;                   // Variant property to put.
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke

    ADsAssert(pDisp);
    ADsAssert(pv);

    VariantInit(&varg);
    CVarToVARIANTARG(pv, vt, &varg);
    dp.rgvarg = &varg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            NULL,
            NULL);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CallDispMethod
//
//  Synopsis:   Calls a late-bound method on a object via IDispatch::Invoke.
//
//  Arguments:  [pDisp]     -- Object to call method on.
//              [dispid]    -- Method ID.
//              [lcid]      -- Locale of method.
//              [vtReturn]  -- Type of return value.  If no return value,
//                             must be VT_VOID.
//              [pvReturn]  -- Location of return value.  If no return value,
//                             must be NULL.
//              [pvtParams] -- List of param types.  May be NULL.  If
//                             non-NULL, last entry must be VT_EMPTY.
//              [...]       -- List of params.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CallDispMethod(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vtReturn,
        void *      pvReturn,
        VARTYPE *   pvtParams,
        ...)
{
    HRESULT     hr;
    VARIANTARG  av[EVENTPARAMS_MAX];   // List of args for Invoke.
    DISPPARAMS  dp;                    // Params for Invoke.
    VARIANT     varReturn;             // Return value.
    va_list     va;                    // List of C-params.

    ADsAssert(pDisp);
    ADsAssert((vtReturn != VT_VOID) == (pvReturn != NULL));

    va_start(va, pvtParams);
    dp.rgvarg = av;
    CParamsToDispParams(&dp, pvtParams, va);
    va_end(va);

    if (pvReturn)
        VariantInit(&varReturn);

    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_METHOD,
            &dp,
            pvReturn ? &varReturn : NULL,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    if (pvReturn)
        hr = VARIANTARGToCVar(&varReturn, vtReturn, pvReturn);

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   IsVariantEqual, public API
//
//  Synopsis:   Compares the values of two VARIANTARGs.
//
//  Arguments:  [pvar1], [pvar2] -- VARIANTARGs to compare.
//
//  Returns:    TRUE if equal, FALSE if not.
//
//  History:    18-Mar-93   SumitC      Created.
//              11-May-94   SumitC      don't assert for VT_UNKNOWN
//
//  Notes:      Variant type unequal returns FALSE, even if actual values
//              are the same.
//              Currently does I2, I4, R4, R8, CY, BSTR, BOOL
//              Returns FALSE for all other VariantTypes.
//
//-------------------------------------------------------------------------

BOOL
IsVariantEqual( VARIANTARG FAR* pvar1, VARIANTARG FAR* pvar2 )
{
    if( V_VT(pvar1) != V_VT(pvar2) )
        return FALSE;

    switch (V_VT(pvar1))
    {
    case VT_EMPTY :
    case VT_NULL:
        return TRUE;    // just the types being equal is good enough

    case VT_I2 :
        return (V_I2(pvar1) == V_I2(pvar2));

    case VT_I4 :
        return (V_I4(pvar1) == V_I4(pvar2));

    case VT_R4 :
        return (V_R4(pvar1) == V_R4(pvar2));

    case VT_R8 :
        return (V_R8(pvar1) == V_R8(pvar2));

    case VT_CY :
        return !memcmp(&V_CY(pvar1), &V_CY(pvar2), sizeof(CY));

    case VT_BSTR :
        return !ADsStringCmp(V_BSTR(pvar1), V_BSTR(pvar2));

    case VT_BOOL :
        return (V_BOOL(pvar1) == V_BOOL(pvar2));

    case VT_UNKNOWN:
        // returns FALSE unless the objects are the same
        return (V_UNKNOWN(pvar1) == V_UNKNOWN(pvar2));

    default:
        ADsAssert(0 && "Type not handled");
        break;
    };

    return(FALSE);
}

HRESULT
ConvertSafeArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    VARIANT * pVarArray = NULL;
    SAFEARRAY * pArray = NULL;
    VARIANT *pvProp = NULL;

    *pdwNumVariants = 0;
    *ppVarArray  = 0;

    //
    // It has to be a variant and a safearray. It might
    // also be a variant that is byref and safe array
    //
    //

    pvProp = &varSafeArray;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&varSafeArray);
    }

    if(!(((V_VT(pvProp) & VT_VARIANT)== VT_VARIANT)
         && V_ISARRAY(pvProp))) {
        //
        // We need to make this additional check. This is not really 
        // legal but it could be that just the tag at this level is wrong.
        // This was allowed in older versions of ADSI and therefore needs
        // on future versions (backward compatibility). 
        //
        if(!((V_VT(&varSafeArray) & VT_VARIANT) && V_ISARRAY(&varSafeArray)))
          RRETURN(E_FAIL);
    }

    if (V_VT(pvProp) == (VT_BYREF | VT_VARIANT | VT_ARRAY)) {
        //
        // in this case we need to use the ARRAY_REF.
        //
        pArray = *(V_ARRAYREF(pvProp));
    }
    else {
        //
        // pvProp will always have the correc info, byref or not.
        //
        pArray = V_ARRAY(pvProp);
    }

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        RRETURN(S_OK);  // Return success and null array
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;
    pVarArray = (PVARIANT)AllocADsMem(
                                sizeof(VARIANT)*dwNumVariants
                                );
    if (!pVarArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        VariantInit(pVarArray + i);
        hr = SafeArrayGetElement(pArray,
                                (long FAR *)&i,
                                (pVarArray + i)
                                );
        CONTINUE_ON_FAILURE(hr);
    }

    *ppVarArray = pVarArray;
    *pdwNumVariants = dwNumVariants;

error:

    RRETURN(hr);
}

//
// This method should go away.  ConvertSafeArrayToVariantArray does the job.
//
HRESULT
ConvertByRefSafeArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    )
{
    RRETURN(ConvertSafeArrayToVariantArray(
        varSafeArray,
        ppVarArray,
        pdwNumVariants
        ));
}

//
// An LDAP query needs a NULL-terminated array of strings.
//
HRESULT
ConvertVariantArrayToLDAPStringArray(
    PVARIANT pVarArray,
    PWSTR **pppszStringArray,
    DWORD dwNumStrings
    )
{
    HRESULT hr = S_OK;
    PWSTR *ppszStringArray = NULL;
    DWORD i = 0;

    //
    // Start off with a zero-length array.
    //
    *pppszStringArray = NULL;

    //
    // The LDAP library expects an array terminated with a NULL string.
    // So make space for an extra one.
    //
    dwNumStrings++;

    ppszStringArray = (PWSTR *)AllocADsMem(dwNumStrings * sizeof(PWSTR));
    if (!ppszStringArray)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    for (i = 0; i < dwNumStrings - 1; i++)
    {
        if (!(V_VT(pVarArray + i) == VT_BSTR))
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);

        ppszStringArray[i] = AllocADsStr(V_BSTR(pVarArray + i));
        if (!ppszStringArray[i])
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // NULL-terminated for LDAP.
    //
    ppszStringArray[i] = NULL;

    *pppszStringArray = ppszStringArray;
    RRETURN(hr);

error:
    if (ppszStringArray)
    {
        for (DWORD j = 0; j < i; j++)
            if (ppszStringArray[i])
                FreeADsStr(ppszStringArray[i]);

        FreeADsMem(ppszStringArray);
    }
    RRETURN(hr);
}

HRESULT
VariantToBinary(
    PVARIANT pVarSrcObject,
    DWORD *pdwLength,
    BYTE  **ppByte
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    BYTE  *pByte = NULL;

    if( pVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    pByte = (BYTE*)AllocADsMem( dwSUBound - dwSLBound + 1);
    if ( pByte == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    hr = SafeArrayAccessData( V_ARRAY(pVarSrcObject),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pByte,
            pArray,
            dwSUBound-dwSLBound+1);

    SafeArrayUnaccessData( V_ARRAY(pVarSrcObject) );

    *pdwLength = dwSUBound - dwSLBound + 1;
    *ppByte = pByte;

    RRETURN(hr);
error:
    if (pByte) {
        FreeADsMem(pByte);
    }
    RRETURN(hr);
}

HRESULT
BinaryToVariant(
    DWORD Length,
    BYTE* pByte,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = Length;
    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, pByte, aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(lpVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(lpVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    RRETURN(hr);
}

HRESULT
CopyOctetString(
    DWORD dwNumBytes,
    BYTE *pData,
    DWORD *pdwNumBytes,
    BYTE **ppByte
    )
{
    LPBYTE lpByteStream = NULL;
    HRESULT hr = S_OK;

    if (dwNumBytes) {
        lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);
        if (lpByteStream == NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        memcpy(
            lpByteStream,
            pData,
            dwNumBytes
            );

        *pdwNumBytes = dwNumBytes;
        *ppByte =  lpByteStream;
    }
    else {
        *pdwNumBytes = 0;
        *ppByte = NULL;
    }
error:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   RaiseException, public API
//
//  Synopsis:   Generic function for translating ADS HRESULT codes to an
//              OLE error object.
//
//  Arguments:  [hr] - The HRESULT code to be translated into
//                     an OLE error object.
//
//
//  Returns:    Nothing. This function is called when an error occurred.
//              There isn't much the caller can do if this function fails.
//
//  History:    10-Sep-97   t-rmak      Created.
//
//
//  Notes:      1) Only ADS error codes are properly translated to
//                 corresponding OLE error objects.
//              2) This function will ignore the lcid passed into
//                 ITypeInfo::Invoke and it always passes 0 as the langid
//                 to FormatMessage.
//              3) Only the source field and the description field of the
//                 error object will be filled by this function.
//              4) This function does not support inserts in the description
//                 string.
//
//-------------------------------------------------------------------------
void
RaiseException(HRESULT hr)
{

    DWORD            dwStrLen;
    LPTSTR           lpszMessage = NULL;
    ICreateErrorInfo *pICreateErrorInfo = NULL;
    IErrorInfo       *pIErrorInfo = NULL;
    HRESULT          localhr = S_OK;

    if (g_hActiveDs != NULL) {

        //
        // Clear any previously set error object
        //
        SetErrorInfo(0, NULL);

        //
        // Let FormatMessage allocate the message buffer.
        // In a multi-threaded environment, this is the simplest
        // solution.
        //
        dwStrLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM |
                                 // Ignore inserts for now.
                                 FORMAT_MESSAGE_IGNORE_INSERTS |
                                 FORMAT_MESSAGE_FROM_HMODULE,
                                 (LPCVOID) g_hActiveDs,
                                 hr,
                                 0,
                                 (LPTSTR) &lpszMessage,
                                 0,
                                 NULL);

        //
        // We may want to fail with a special error code if the specified
        // lcid is not supported.
        //
        if (dwStrLen == 0) {
            goto error;
        }

        //
        // We may want to add support for help file in the future.
        //
        localhr = CreateErrorInfo(&pICreateErrorInfo);

        BAIL_ON_FAILURE(localhr);

        //
        // Note that we don't care whether the following calls succeed since
        // there is nothing we can if they fail.
        //
        pICreateErrorInfo->SetDescription(lpszMessage);
        pICreateErrorInfo->SetSource(TEXT("Active Directory"));

        //
        // Set the threads error object.
        //
        pICreateErrorInfo->QueryInterface(IID_IErrorInfo, (void **)&pIErrorInfo);
        SetErrorInfo(0, pIErrorInfo);

    }

error:

    if (lpszMessage != NULL) {
        LocalFree(lpszMessage);
    }

    //
    // Release the error object's interface pointers
    //
    if (pIErrorInfo != NULL) {
        pIErrorInfo->Release();
    }

    if (pICreateErrorInfo != NULL) {
        pICreateErrorInfo->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\utils\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//              multiple IDispatch-callable interfaces.
//
//  Classes:    CDispatchMgr
//
//  Functions:  None external.
//
//  History:    ??-???-??   KrishnaG   created
//              07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

#include "procs.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include "cdispmgr.hxx"
#include "iprops.hxx"

#endif  // ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    End Non-ADSI compile stuff

//
// Error recovery.
//
#define BAIL_ON_FAILURE(hr) if (FAILED(hr)) { goto cleanup; }

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:    Simplified from Win4AssertEx, to make this dispatch manager
//              not depend on other files.
//
//----------------------------------------------------------------------------
static void
AssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[199];
    DWORD dwCount = strlen("File: %s line %u, thread id %d");

    if (szFile) {
        dwCount += strlen(szFile);
    }

    dwCount += 15; // for the line number and thread id

    if (dwCount > 199) {
        sprintf(szAssertCaption, "Error, could not get more infomration");
    } 
    else {
        sprintf(szAssertCaption, "File: %s line %u, thread id %d",
                szFile, iLine, GetCurrentThreadId());
    }

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
        DebugBreak();
    }
}
# define DispMgrAssert(x)  (void)((x) || (AssertEx(__FILE__, __LINE__, #x),0))
#else
# define AssertEx(f,l,m)   do {} while(0)
# define DispMgrAssert(x)  do {} while(0)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(LONG TypeInfoId, LONG DispId, DISPID *pResult)
{
    if (DispId == DISPID_UNKNOWN)
        *pResult = DispId;
    else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
        DispId < 0 || DispId >= 0x10000)
    {
        //
        // Might happen if some object has very large dispid's.
        // But we can't handle it if it does.
        //
        *pResult = DISPID_UNKNOWN;
    }
    else
        *pResult = ((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

}

static inline void
IncDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
        if (rgdispid[i] == DISPID_UNKNOWN)
            continue;

        //
        // This is either a stack of DispMgrs >127 high, or
        // a programming error.  More likely the latter.
        //
        DispMgrAssert(getDispMgrId(rgdispid[i]) < 0x7f);

        rgdispid[i] =
            (rgdispid[i] & 0x00ffffff) |
            (((getDispMgrId(rgdispid[i]) + 1) & 0x7f) << 24);
    }
}

static inline void
DecDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
        //
        // It should never be less than zero, and the only place
        // this is called from guarantees it is not zero.
        //
        DispMgrAssert(getDispMgrId(rgdispid[i]) > 0);

        rgdispid[i] =
            (rgdispid[i] & 0x00ffffff) |
            (((getDispMgrId(rgdispid[i]) - 1) & 0x7f) << 24);
    }
}

static inline void
MakeDISPIDs(LONG TypeInfoId, DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//
// Struct defs
//
typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


PTYPEINFO_TABLE gpTypeInfoTable = NULL;

CRITICAL_SECTION g_DispTypeInfoCritSect;

#define ENTER_DISP_TYPEINFO_CRITSECT()  EnterCriticalSection(&g_DispTypeInfoCritSect)
#define LEAVE_DISP_TYPEINFO_CRITSECT()  LeaveCriticalSection(&g_DispTypeInfoCritSect)

LONG glnObjCount = 0;
LONG glnTypesOfInfo = 0;
LONG glnOledbObjCnt = 0;


//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CDispatchMgr::CDispatchMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
    _pDispatch = NULL;
}

CDispatchMgr::~CDispatchMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        InterlockedDecrement(&glnObjCount);

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

    ENTER_DISP_TYPEINFO_CRITSECT();
    if (glnObjCount == glnTypesOfInfo) {
        //
        // We need to clean up the list
        //
        FreeTypeInfoTable();

        glnObjCount = glnTypesOfInfo = 0;

    }
    LEAVE_DISP_TYPEINFO_CRITSECT();

    if (_pDispatch)
        _pDispatch->Release();
}

void
CDispatchMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}

void
CDispatchMgr::RegisterBaseDispatchPtr(IDispatch *pDispatch)
{
    _pDispatch = pDispatch;
}

STDMETHODIMP
CDispatchMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDispatchMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDispatchMgr::GetIDsOfNames(REFIID iid, LPWSTR *rgszNames,
        unsigned int cNames, LCID lcid, DISPID *rgdispid)
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
        hr = S_OK;
        for (DWORD dw = 0; dw < cNames; dw++) {
            if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
                    (PDWORD)(rgdispid + dw)))) {
                hr = DISP_E_UNKNOWNNAME;
                rgdispid[dw] = DISPID_UNKNOWN;
            }
        }
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(_dwPropCacheID, rgdispid, cNames);
        }
    }

    //
    // Try our "base class" dispatch pointer.
    //
    if (FAILED(hr) && _pDispatch) {
        hr = _pDispatch->GetIDsOfNames(iid, rgszNames, cNames, lcid, rgdispid);

        if (SUCCEEDED(hr)) {
            IncDispMgrIds(rgdispid, cNames);
        }
    }

    return hr;
}

STDMETHODIMP
CDispatchMgr::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,
        unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CDispatchMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CDispatchMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CDispatchMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CDispatchMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CDispatchMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

    return S_OK;

cleanup:
    return hr;
}

STDMETHODIMP
CDispatchMgr::TypeInfoInvoke(DISPID dispidMember, REFIID iid, LCID lcid,
        unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

        //
            // One of the special DISPIDs.
            //
            // If we have an interface pointer for it, use that.
            // If we don't, and we have a base IDispatch pointer,
            //   pass it to the base pointer's Invoke() method.
            // If we don't, and we don't have a base IDispatch pointer,
            //   return failure.
            //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
            break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

            if (!pInterfacePtr) {
            if (_pDispatch) {
                    return _pDispatch->Invoke(dispidMember, iid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);
                } else {
                    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
                }
            }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else if (getDispMgrId(dispidMember)) {

            //
            // A regular DISPID of a "base class" dispatch manager.
            //

            if (!_pDispatch){

                char szMessage[80];
                sprintf(szMessage, "_pDispatch is NULL, dispid = 0x%08x",
                        dispidMember);
                 AssertEx(__FILE__, __LINE__, szMessage);
                return DISP_E_MEMBERNOTFOUND;
            }

            DecDispMgrIds(&dispidMember, 1);

            hr = _pDispatch->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                        pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        return(hr);

    } else {

        //
            // A regular DISPID of ours.
            //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

            if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
                pInterfacePtr = getInterfacePtr(typeinfoid);
                pTypeInfo = getTypeInfo(typeinfoid);
                if (!pTypeInfo)
                        //
                    // Shouldn't happen.
                    //
                    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
            }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = DynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

cleanup:
    return hr;
}


HRESULT
DynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

cleanup:
    return(hr);

}


HRESULT
CDispatchMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CDispatchMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CDispatchMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    DispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

ITypeInfo *
FindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
LoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    DispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (!SUCCEEDED(hr))
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CDispatchMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    ENTER_DISP_TYPEINFO_CRITSECT();

    pTypeInfo = ::FindTypeInfo(gpTypeInfoTable, iid);

    if (!pTypeInfo) {

        LEAVE_DISP_TYPEINFO_CRITSECT();

        hr = LoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        ENTER_DISP_TYPEINFO_CRITSECT();

        gpTypeInfoTable = ::AddTypeInfo(
                                gpTypeInfoTable,
                                iid,
                                pTypeInfo
                                );
        if (!gpTypeInfoTable) {

                LEAVE_DISP_TYPEINFO_CRITSECT();
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        // Increment the global list of the types of type info's.
        //
        InterlockedIncrement(&glnTypesOfInfo);

        InterlockedIncrement(&glnObjCount);
    }
    pTypeInfo->AddRef();


    hr = AddTypeInfo(pTypeInfo, pIntf);

    if (FAILED(hr)) {
        LEAVE_DISP_TYPEINFO_CRITSECT();
        BAIL_ON_FAILURE(hr);
    }

    //
    // We have a ref on the object as add was succesful
    //
    InterlockedIncrement(&glnObjCount);
    LEAVE_DISP_TYPEINFO_CRITSECT();

    if (SpecialId == -4) {
        hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
        hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

cleanup:
    if (pTypeInfo)
        pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CDispatchMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
FreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }

    gpTypeInfoTable = NULL;
}

BOOL
DllReadyToUnload()
{
    BOOL retVal = FALSE;

    ENTER_DISP_TYPEINFO_CRITSECT();
        retVal = ((glnTypesOfInfo == 0) && (glnOledbObjCnt == 0));
    LEAVE_DISP_TYPEINFO_CRITSECT();

    return retVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\utils\fbstr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       fbstr.cxx
//
//  Contents:   Wrappers around BSTR api to account for wierdness with NULL
//
//  Functions:  ADsAllocString
//              ADsAllocStringLen
//              ADsReAllocString
//              ADsReAllocStringLen
//              ADsFreeString
//              ADsStringLen
//              ADsStringByteLen
//              ADsAllocStringByteLen
//              ADsStringCmp
//              ADsStringNCmp
//              ADsStringICmp
//              ADsStringNICmp
//
//  History:   25-Oct-94 krishnag
//
//
//----------------------------------------------------------------------------

#include "procs.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   ADsAllocString
//
//  Synopsis:   Allocs a BSTR and initializes it from a string.  If the
//              initializer is NULL or the empty string, the resulting bstr is
//              NULL.
//
//  Arguments:  [pch]   -- String to initialize BSTR.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR]
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsAllocString(const OLECHAR * pch, BSTR * pBSTR)
{
    HRESULT hr = S_OK;

    ADsAssert(pBSTR);
    if (!pch)
    {
        *pBSTR = NULL;
        return S_OK;
    }

    *pBSTR = SysAllocString(pch);
    hr = (*pBSTR) ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsAllocStringLen
//
//  Synopsis:   Allocs a BSTR of [uc] + 1 OLECHARS, and
//              initializes it from an optional string.  If [uc] == 0, the
//              resulting bstr is NULL.
//
//  Arguments:  [pch]   -- String to initialize.
//              [uc]    -- Count of characters of string.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsAllocStringLen(const OLECHAR * pch, UINT uc, BSTR * pBSTR)
{
    HRESULT hr = S_OK;

    ADsAssert(pBSTR);

    if (!pch){

        *pBSTR = NULL;
        return S_OK;

     }


    *pBSTR = SysAllocStringLen(pch, uc);
    hr =  *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsReAllocString
//
//  Synopsis:   Allocates a BSTR initialized from a string; if successful,
//              frees the original string and replaces it.
//
//  Arguments:  [pBSTR] -- String to reallocate.
//              [pch]   -- Initializer.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsReAllocString(BSTR * pBSTR, const OLECHAR * pch)
{
    ADsAssert(pBSTR);

#if DBG == 1
    HRESULT hr;
    BSTR    bstrTmp;

    hr = ADsAllocString(pch, &bstrTmp);
    if (hr)
        RRETURN(hr);

    ADsFreeString(*pBSTR);
    *pBSTR = bstrTmp;
    return S_OK;
#else

    if (!pch){

        SysFreeString(*pBSTR);
        *pBSTR = NULL;
        return S_OK;
     }


    return SysReAllocString(pBSTR, pch) ? S_OK : E_OUTOFMEMORY;
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsReAllocStringLen
//
//  Synopsis:   Allocates a BSTR of [uc] + 1 OLECHARs and optionally
//              initializes it from a string; if successful, frees the original
//              string and replaces it.
//
//  Arguments:  [pBSTR] -- String to reallocate.
//              [pch]   -- Initializer.
//              [uc]    -- Count of characters.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsReAllocStringLen(BSTR * pBSTR, const OLECHAR * pch, UINT uc)
{
    ADsAssert(pBSTR);

#if DBG == 1
    HRESULT hr;
    BSTR    bstrTmp;

    hr = ADsAllocStringLen(pch, uc, &bstrTmp);
    if (hr)
        RRETURN(hr);

    ADsFreeString(*pBSTR);
    *pBSTR = bstrTmp;
    return S_OK;
#else

    if (!pch){

        SysFreeString(*pBSTR);
        *pBSTR = NULL;
        return S_OK;
     }

    return SysReAllocStringLen(pBSTR, pch, uc) ? S_OK : E_OUTOFMEMORY;
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringLen
//
//  Synopsis:   Returns the length of the BSTR.
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI_(UINT)
ADsStringLen(BSTR bstr)
{
    return bstr ? SysStringLen(bstr) : 0;
}



#ifdef WIN32

//+---------------------------------------------------------------------------
//
//  Function:   ADsStringByteLen
//
//  Synopsis:   Returns the length of a BSTR in bytes.
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI_(UINT)
ADsStringByteLen(BSTR bstr)
{
    return bstr ? SysStringByteLen(bstr) : 0;
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsAllocStringByteLen
//
//  Synopsis:   Allocates a BSTR of [uc] + 1 chars and optionally initializes
//              from a string.  If [uc] = 0, the resulting bstr is NULL.
//
//  Arguments:  [pch]   -- Initializer.
//              [uc]    -- Count of chars.
//              [pBSTR] -- Result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsAllocStringByteLen(const char * pch, UINT uc, BSTR * pBSTR)
{
    HRESULT hr = S_OK;

    ADsAssert(pBSTR);

    if (!pch){

        *pBSTR = NULL;
        return S_OK;
     }


    *pBSTR = SysAllocStringByteLen(pch, uc);

    RRETURN(hr);
}
#endif



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringCmp
//
//  Synopsis:   As per wcscmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringCmp(CBSTR bstr1, CBSTR bstr2)
{
    return wcscmp(STRVAL(bstr1), STRVAL(bstr2));
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringNCmp
//
//  Synopsis:   As per wcsncmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringNCmp(CBSTR bstr1, CBSTR bstr2, size_t c)
{
    return wcsncmp(STRVAL(bstr1), STRVAL(bstr2), c);
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringICmp
//
//  Synopsis:   As per wcsicmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//              15-Aug-94 doncl   changed from wcsicmp to _wcsicmp
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringICmp(CBSTR bstr1, CBSTR bstr2)
{
    return _wcsicmp(STRVAL(bstr1), STRVAL(bstr2));
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringNICmp
//
//  Synopsis:   As per wcsnicmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//              15-Aug-94 doncl   changed from wcsnicmp to _wcsnicmp
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringNICmp(CBSTR bstr1, CBSTR bstr2, size_t c)
{
    return _wcsnicmp(STRVAL(bstr1), STRVAL(bstr2), c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\utils\pack.cxx ===
#include "procs.hxx"
#pragma hdrstop
#include "macro.h"

HRESULT
PackStringinVariant(
    BSTR bstrString,
    VARIANT * pvarInputData
    )
{
    HRESULT hr = S_OK;

    if ( bstrString == NULL )
        RRETURN(E_FAIL);

    VariantInit(pvarInputData);

    pvarInputData->vt = VT_BSTR;

    if (!bstrString) {
        V_BSTR(pvarInputData) = NULL;
        RRETURN(S_OK);
    }

    hr = ADsAllocString(bstrString, &(V_BSTR(pvarInputData)));

    RRETURN(hr);
}


HRESULT
UnpackStringfromVariant(
    VARIANT varSrcData,
    BSTR * pbstrDestString
    )
{
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_BSTR){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!V_BSTR(&varSrcData)) {
        *pbstrDestString = NULL;
        RRETURN(S_OK);
    }

    hr = ADsAllocString(V_BSTR(&varSrcData), pbstrDestString);

    RRETURN(hr);
}


HRESULT
PackLONGinVariant(
    LONG  lValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_I4;
    V_I4(pvarInputData) = lValue;

    RRETURN(S_OK);
}

HRESULT
UnpackLONGfromVariant(
    VARIANT varSrcData,
    LONG * plValue
    )
{
    if( varSrcData.vt != VT_I4){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *plValue = V_I4(&varSrcData);

    RRETURN(S_OK);
}


HRESULT
PackDATEinVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_DATE;
    V_DATE(pvarInputData) = daValue;

    RRETURN(S_OK);
}

HRESULT
UnpackDATEfromVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    )
{
    if( varSrcData.vt != VT_DATE){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdaValue = V_DATE(&varSrcData);

    RRETURN(S_OK);
}



HRESULT
PackFILETIMEinVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    )
{
    IADsLargeInteger *pTime = NULL;
    VARIANT var;
    SYSTEMTIME systemtime;
    FILETIME filetime;
    HRESULT hr = S_OK;

    if (VariantTimeToSystemTime(daValue,
                                &systemtime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    if (SystemTimeToFileTime(&systemtime,
                             &filetime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (LocalFileTimeToFileTime(&filetime, &filetime ) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = CoCreateInstance(
                CLSID_LargeInteger,
                NULL,
                CLSCTX_ALL,
                IID_IADsLargeInteger,
                (void**)&pTime
                );
    BAIL_ON_FAILURE(hr);

    hr = pTime->put_HighPart(filetime.dwHighDateTime);
    BAIL_ON_FAILURE(hr);
    hr = pTime->put_LowPart(filetime.dwLowDateTime);
    BAIL_ON_FAILURE(hr);

    VariantInit(pvarInputData);
    pvarInputData->pdispVal = pTime;
    pvarInputData->vt = VT_DISPATCH;

error:
	
    return hr;
}

HRESULT
UnpackFILETIMEfromVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    )
{
    IADsLargeInteger *pLarge = NULL;
    IDispatch *pDispatch = NULL;
    FILETIME filetime;
    FILETIME locFiletime;
    SYSTEMTIME systemtime;
    DATE date;
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_DISPATCH){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    pDispatch = varSrcData.pdispVal;
    hr = pDispatch->QueryInterface(IID_IADsLargeInteger, (VOID **) &pLarge);
    BAIL_ON_FAILURE(hr);

    hr = pLarge->get_HighPart((long*)&filetime.dwHighDateTime);
    BAIL_ON_FAILURE(hr);

    hr = pLarge->get_LowPart((long*)&filetime.dwLowDateTime);
    BAIL_ON_FAILURE(hr);

    // 
    // time is "0" actually means that either user never logs on or property not known
    //
    if (filetime.dwLowDateTime == 0 && filetime.dwHighDateTime == 0) {
        hr = E_ADS_PROPERTY_NOT_FOUND;
        BAIL_ON_FAILURE(hr);
    }    	

    if (FileTimeToLocalFileTime(&filetime, &locFiletime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (FileTimeToSystemTime(&locFiletime,
                             &systemtime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (SystemTimeToVariantTime(&systemtime,
                                &date) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    *pdaValue = date;
error:

    if(pLarge)
    {
        pLarge->Release();
        pLarge = NULL;
    }
    return hr;
}

HRESULT
PackVARIANT_BOOLinVariant(
    VARIANT_BOOL  fValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_BOOL;
    V_BOOL(pvarInputData) = fValue;

    RRETURN(S_OK);
}

HRESULT
UnpackVARIANT_BOOLfromVariant(
    VARIANT varSrcData,
    VARIANT_BOOL * pfValue
    )
{
    if( varSrcData.vt != VT_BOOL){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pfValue = V_BOOL(&varSrcData);

    RRETURN(S_OK);
}


HRESULT
PackVARIANTinVariant(
    VARIANT vaValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_VARIANT;
    RRETURN( VariantCopy( pvarInputData, &vaValue ));
}

HRESULT
UnpackVARIANTfromVariant(
    VARIANT varSrcData,
    VARIANT * pvaValue
    )
{
    VariantInit( pvaValue );

    RRETURN( VariantCopy( pvaValue, &varSrcData ));
}


HRESULT
PackDATEinLONGVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    )
{
    LONG lValue;
    HRESULT hr = S_OK;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    FILETIME LocalFileTime;
    FILETIME FileTimeCurrent;
    DATE       date ;
    BOOL       fRetval;

    VariantInit(pvarInputData);

    if( hr = ConvertDATEToSYSTEMTIME(daValue,
                                &LocalTime)
      ) {
        RRETURN( hr );
    }

    fRetval = SystemTimeToFileTime(&LocalTime,
                         &LocalFileTime);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    fRetval = LocalFileTimeToFileTime(
                  &LocalFileTime,
                  &FileTimeCurrent
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    fRetval = FileTimeToSystemTime(&FileTimeCurrent,
                         &stSystemTime);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }
    lValue = stSystemTime.wHour * 60 + stSystemTime.wMinute;

    pvarInputData->vt = VT_I4;
    V_I4(pvarInputData) = lValue;

    RRETURN(S_OK);
}

HRESULT
UnpackDATEfromLONGVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    )
{
    LONG lValue;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    DATE       date ;
    BOOL       fRetval;
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_I4){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    lValue = V_I4(&varSrcData);

    GetSystemTime( &stSystemTime);


    stSystemTime.wHour = (WORD)(lValue)/60;
    stSystemTime.wMinute = (WORD)(lValue)%60;
    stSystemTime.wSecond =0;
    stSystemTime.wMilliseconds = 0;

    fRetval = SystemTimeToTzSpecificLocalTime(
                  NULL,
                  &stSystemTime,
                  &LocalTime
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    hr = ConvertSystemTimeToDATE (LocalTime,
                                  pdaValue);

    //lpVarDestObject->date = date - (DWORD)date;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\utils\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       registry.cxx
//
//  Contents:   Registry utilities
//
//  Classes:
//
//  Functions:
//
//  History:    23-May-1996  RamV (Ram Viswanathan) Created
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   SetKeyAndValue
//
//  Synopsis:   Used for setting a key value
//
//
//  Arguments:  pszRegLocation: where to look for/create key
//              pszKey :   name of the Key
//              pszSubKey: name of the subkey
//              pszValue : Value to set
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    5/21/1996  RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
SetKeyAndValue(
    LPTSTR pszRegLocation,
    LPTSTR pszKey,
    LPTSTR pszSubKey,
    LPTSTR pszValue
    )

{

    HKEY        hKey;
    TCHAR       szKey[MAX_PATH];
    LONG        lErrorCode;
    HRESULT     hr = S_OK;

    _tcscpy(szKey, pszRegLocation);

    if (pszSubKey != NULL){
        _tcscpy(szKey, TEXT("\\"));
        _tcscat(szKey, pszSubKey);
    }

    lErrorCode = RegCreateKeyEx(HKEY_CURRENT_USER,
                                szKey,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                NULL);

    if (lErrorCode != ERROR_SUCCESS){
        return HRESULT_FROM_WIN32(lErrorCode);
    }

    if (pszValue != NULL){
        lErrorCode = RegSetValueEx(hKey,
                                   pszKey,
                                   0,
                                   REG_SZ,
                                   (BYTE *)pszValue,
                                   (_tcslen(pszValue)+1)*sizeof(TCHAR));

        if(lErrorCode != ERROR_SUCCESS){
            hr = HRESULT_FROM_WIN32(lErrorCode);
            goto cleanup;
        }

    }

cleanup:
    RegCloseKey(hKey);
    return S_OK;
}


HRESULT
QueryKeyValue(
    LPTSTR pszRegLocation,
    LPTSTR pszKey,
    LPTSTR * ppszValue
    )

{
    LONG lErrorCode;
    TCHAR szKey[MAX_PATH];
    DWORD dwDataLen;
    DWORD dwType;
    HKEY  hKey = NULL;
    HRESULT hr = S_OK;

    dwDataLen = sizeof(TCHAR)* MAX_PATH;
    
    *ppszValue = (LPTSTR)AllocADsMem( dwDataLen );

    if(!*ppszValue){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    _tcscpy(szKey, pszRegLocation);

    lErrorCode = RegOpenKeyEx(HKEY_CURRENT_USER,
                              szKey,
                              NULL,
                              KEY_READ,
                              &hKey);

    if( lErrorCode != ERROR_SUCCESS){
        hr = HRESULT_FROM_WIN32(lErrorCode);
        goto cleanup;
    }

    lErrorCode = RegQueryValueEx(hKey,
                                 pszKey,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)*ppszValue,
                                 &dwDataLen);

    if (lErrorCode == ERROR_MORE_DATA){
        FreeADsMem(*ppszValue);
        *ppszValue = NULL;
        *ppszValue = (LPTSTR)AllocADsMem (dwDataLen);

        if(!*ppszValue){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        lErrorCode = RegQueryValueEx(hKey,
                                     pszKey,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)*ppszValue,
                                     &dwDataLen);


        hr = HRESULT_FROM_WIN32(lErrorCode);
        BAIL_IF_ERROR(hr);

    } else if (lErrorCode != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lErrorCode);
        FreeADsMem(*ppszValue);
        *ppszValue = NULL;
    }
cleanup:
    if(hKey){
        RegCloseKey(hKey);
    }
    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\utils\misc.cxx ===
//+---------------------------------------------------------------------
//
//  File:       misc.cxx
//
//  Contents:   Useful OLE helper and debugging functions
//
//----------------------------------------------------------------------

#include "procs.hxx"

//+------------------------------------------------------------------------
//
//  Function:   GetLastWin32Error
//
//  Synopsis:   Returns the last Win32 error, converted to an HRESULT.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
GetLastWin32Error( )
{
    return HRESULT_FROM_WIN32(GetLastError());
}



#if DBG == 1

//+---------------------------------------------------------------
//
//  Function:   TraceIID
//
//  Synopsis:   Outputs the name of the interface to the debugging device
//
//  Arguments:  [riid] -- the interface
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

STDAPI_(void)
PrintIID(DWORD dwFlags, REFIID riid)
{
    LPWSTR lpstr = NULL;

#define CASE_IID(iid)  \
        if (IsEqualIID(IID_##iid, riid)) lpstr = (LPWSTR)L#iid;

    CASE_IID(IUnknown)
    CASE_IID(IOleLink)
    CASE_IID(IOleCache)
    CASE_IID(IOleManager)
    CASE_IID(IOlePresObj)
    CASE_IID(IDebug)
    CASE_IID(IDebugStream)
    CASE_IID(IAdviseSink2)
    CASE_IID(IDataObject)
    CASE_IID(IViewObject)
    CASE_IID(IOleObject)
    CASE_IID(IOleInPlaceObject)
    CASE_IID(IParseDisplayName)
    CASE_IID(IOleContainer)
    CASE_IID(IOleItemContainer)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IPersist)
    CASE_IID(IPersistStorage)
    CASE_IID(IPersistFile)
    CASE_IID(IPersistStream)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IAdviseSink)
    CASE_IID(IDataAdviseHolder)
    CASE_IID(IOleAdviseHolder)
    CASE_IID(IClassFactory)
    CASE_IID(IOleWindow)
    CASE_IID(IOleInPlaceActiveObject)
    CASE_IID(IOleInPlaceUIWindow)
    CASE_IID(IOleInPlaceFrame)
    CASE_IID(IDropSource)
    CASE_IID(IDropTarget)
    CASE_IID(IBindCtx)
    CASE_IID(IEnumUnknown)
    CASE_IID(IEnumString)
    CASE_IID(IEnumFORMATETC)
    CASE_IID(IEnumSTATDATA)
    CASE_IID(IEnumOLEVERB)
    CASE_IID(IEnumMoniker)
    CASE_IID(IEnumGeneric)
    CASE_IID(IEnumHolder)
    CASE_IID(IEnumCallback)
    CASE_IID(ILockBytes)
    CASE_IID(IStorage)
    CASE_IID(IStream)
    CASE_IID(IDispatch)
    CASE_IID(IMarshal)
    //CASE_IID(IEnumVARIANT)
    //CASE_IID(ITypeInfo)
    //CASE_IID(ITypeLib)
    //CASE_IID(ITypeComp)
    //CASE_IID(ICreateTypeInfo)
    //CASE_IID(ICreateTypeLib)

#undef CASE_IID

    if (lpstr == NULL)
    {
        WCHAR chBuf[256];
        StringFromGUID2(riid, chBuf, 256);

        ADsDebugOut((dwFlags | DEB_NOCOMPNAME,
                       "UNKNOWN ITF %ws", chBuf));
    }
    else
        ADsDebugOut((dwFlags | DEB_NOCOMPNAME, "%ws", lpstr));
}

#endif  // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\utils\stdfact.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdfact.cxx
//
//  Contents:   Standard IClassFactory implementation
//
//  Classes:    StdClassFactory
//              CDynamicCF
//
//  History:    6-21-94   adams   added CDynamicCF
//              19-Jul-94 doncl   init StdClassFactory::_ulRefs to 1
//
//----------------------------------------------------------------------

#include "procs.hxx"

//+------------------------------------------------------------------------
//
//  StdClassFactory Implementation
//
//-------------------------------------------------------------------------


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::AddRef, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
StdClassFactory::AddRef(void)
{
    ADsAssert(_ulRefs);

    if (_ulRefs == 1)
        INC_OBJECT_COUNT();

    return ++_ulRefs;
}


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::Release, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
StdClassFactory::Release(void)
{
    ADsAssert(_ulRefs > 1);

    if (--_ulRefs == 1)
        DEC_OBJECT_COUNT();

    return _ulRefs;
}

//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::LockServer, public
//
//  Synopsis:   Method of IClassFactory interface
//
//  Notes:      Since class factories based on this class are global static
//              objects, this method doesn't serve much purpose.
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::LockServer (BOOL fLock)
{
    if (fLock)
        INC_OBJECT_COUNT();
    else
        DEC_OBJECT_COUNT();
    return NOERROR;
}

#ifdef DOCGEN
//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::CreateInstance, public
//
//  Synopsis:   Manufactures an instance of the class
//
//  Notes:      This pure virtual function must be overridden by the
//              inheriting class because the base class does not know what
//              class to instantiate.
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
        REFIID iid,
        LPVOID FAR* ppv) {};

//REVIEW: how to enforce ref counting of Class factory in object
// constructor/destructor?  Can we do this in a conjunction of StdUnknown
// with StdClassFactory.
#endif  // DOCGEN


//+------------------------------------------------------------------------
//
//  CDynamicCF Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CDynamicCF::CDynamicCF
//
//  Synopsis:   Constructor.
//
//  History:    7-20-94   adams   Created
//
//----------------------------------------------------------------------------

CDynamicCF::CDynamicCF(void)
{
    _ulRefs = 1;

    INC_OBJECT_COUNT();
}



//+---------------------------------------------------------------------------
//
//  Member:     CDynamicCF::~CDynamicCF
//
//  Synopsis:   Destructor.
//
//  History:    7-20-94   adams   Created
//
//----------------------------------------------------------------------------

CDynamicCF::~CDynamicCF(void)
{
    DEC_OBJECT_COUNT();
}



//+---------------------------------------------------------------
//
//  Member:     CDynamicCF::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
CDynamicCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CDynamicCF::LockServer, public
//
//  Synopsis:   Since these class factories are on the heap, we have
//              to implement this properly.  In our case, LockServer is
//              equivalent to AddRef/Release because we don't have a single
//              'application' object that we can put an external lock on.
//              Each time CreateInstance is called, we return a newly created
//              object.  If, instead, we returned a pointer to an existing
//              object, we would need to call CoLockObjectExternal on that
//              global object in the implementation of LockServer to keep it
//              alive.
//
//----------------------------------------------------------------

STDMETHODIMP
CDynamicCF::LockServer (BOOL fLock)
{
    if (fLock)
    {
        _ulRefs++;
    }
    else
    {
        _ulRefs--;
        Assert(_ulRefs != 0 && "Improper use of IClassFactory::LockServer!");
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\ccgi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  ccgi.cxx
//
//  Contents:  This file contains the Computer Object's
//             GeneralInfo Functional Set.
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//  Class CWinNTComputer

STDMETHODIMP CWinNTComputer::get_ComputerID(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, ComputerID);
}

STDMETHODIMP CWinNTComputer::get_Site(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Site);
}

STDMETHODIMP CWinNTComputer::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Description);
}

STDMETHODIMP CWinNTComputer::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Description);
}

STDMETHODIMP CWinNTComputer::get_Location(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Location);
}

STDMETHODIMP CWinNTComputer::put_Location(THIS_ BSTR bstrLocation)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Location);
}

STDMETHODIMP CWinNTComputer::get_PrimaryUser(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, PrimaryUser);
}

STDMETHODIMP CWinNTComputer::put_PrimaryUser(THIS_ BSTR bstrPrimaryUser)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, PrimaryUser);
}

STDMETHODIMP CWinNTComputer::get_Owner(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Owner);
}

STDMETHODIMP CWinNTComputer::put_Owner(THIS_ BSTR bstrOwner)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Owner);
}

STDMETHODIMP CWinNTComputer::get_Division(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Division);
}

STDMETHODIMP CWinNTComputer::put_Division(THIS_ BSTR bstrDivision)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Division);
}

STDMETHODIMP CWinNTComputer::get_Department(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Department);
}

STDMETHODIMP CWinNTComputer::put_Department(THIS_ BSTR bstrDepartment)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Department);
}

STDMETHODIMP CWinNTComputer::get_Role(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Role);
}

STDMETHODIMP CWinNTComputer::put_Role(THIS_ BSTR bstrRole)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Role);
}

STDMETHODIMP CWinNTComputer::get_OperatingSystem(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, OperatingSystem);
}

STDMETHODIMP CWinNTComputer::put_OperatingSystem(THIS_ BSTR bstrOperatingSystem)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, OperatingSystem);
}

STDMETHODIMP CWinNTComputer::get_OperatingSystemVersion(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, OperatingSystemVersion);
}

STDMETHODIMP CWinNTComputer::put_OperatingSystemVersion(THIS_ BSTR bstrOperatingSystemVersion)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, OperatingSystemVersion);
}

STDMETHODIMP CWinNTComputer::get_Model(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Model);
}

STDMETHODIMP CWinNTComputer::put_Model(THIS_ BSTR bstrModel)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Model);
}

STDMETHODIMP CWinNTComputer::get_Processor(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, Processor);
}

STDMETHODIMP CWinNTComputer::put_Processor(THIS_ BSTR bstrProcessor)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, Processor);
}

STDMETHODIMP CWinNTComputer::get_ProcessorCount(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, ProcessorCount);
}

STDMETHODIMP CWinNTComputer::put_ProcessorCount(THIS_ BSTR bstrProcessorCount)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, ProcessorCount);
}

STDMETHODIMP CWinNTComputer::get_MemorySize(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, MemorySize);
}

STDMETHODIMP CWinNTComputer::put_MemorySize(THIS_ BSTR bstrMemorySize)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, MemorySize);
}

STDMETHODIMP CWinNTComputer::get_StorageCapacity(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsComputer *)this, StorageCapacity);
}

STDMETHODIMP CWinNTComputer::put_StorageCapacity(THIS_ BSTR bstrStorageCapacity)
{
    PUT_PROPERTY_BSTR((IADsComputer *)this, StorageCapacity);
}

STDMETHODIMP CWinNTComputer::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsComputer *)this, NetAddresses);
}

STDMETHODIMP CWinNTComputer::put_NetAddresses(THIS_ VARIANT vNetAddresses)
{
    PUT_PROPERTY_VARIANT((IADsComputer *)this, NetAddresses);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\ccomp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  oleds.odl
//
//  Contents:  Top level odl file for the ADs project
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop

//  Class CWinNTComputer

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTComputer)
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTComputer)
DEFINE_IADs_TempImplementation(CWinNTComputer)
DEFINE_IADs_PutGetImplementation(CWinNTComputer, ComputerClass,gdwComputerTableSize)
DEFINE_IADsPropertyList_Implementation(CWinNTComputer,ComputerClass,gdwComputerTableSize)



CWinNTComputer::CWinNTComputer():
                _pDispMgr(NULL),
                _pExtMgr(NULL),
                _pPropertyCache(NULL),
                _DomainName(NULL),
                _fCredentialsBound(FALSE),
                _hrBindingResult(S_OK),
                _fNoWKSTA(FALSE)
{
    VariantInit(&_vFilter);
}


HRESULT
CWinNTComputer::CreateComputer(
    BSTR Parent,
    BSTR DomainName,
    BSTR ComputerName,
    DWORD dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTComputer FAR * pComputer = NULL;
    HRESULT hr = S_OK;

    hr = AllocateComputerObject(&pComputer);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pComputer->_pDispMgr);


    hr = pComputer->InitializeCoreObject(
                Parent,
                ComputerName,
                COMPUTER_CLASS_NAME,
                COMPUTER_SCHEMA_NAME,
                CLSID_WinNTComputer,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( DomainName, &pComputer->_DomainName);
    BAIL_ON_FAILURE(hr);

    if (DomainName == NULL) {
        pComputer->_fNoWKSTA = TRUE;
    }

    //
    // The computer is a special case for using credentials.  If it is
    // created from a Domain object, the credentials will have the server
    // name of the Domain's DC.  So when we go to RefServer the computer
    // object, it has a different machine name, which should ordinarily fail.
    // We obviously don't want that, so we tell RefServer to allow a change
    // of server names.
    //
    // We also don't want to try to bind to each computer in a domain, since
    // most computers won't actually be examined in detail.  So we don't
    // RefServer until we perform an operation on this object.
    //
    pComputer->_Credentials = Credentials;


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                COMPUTER_CLASS_NAME,
                (IADsComputer *) pComputer,
                pComputer->_pDispMgr,
                Credentials,
                &pComputer->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pComputer->_pExtMgr);


    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(2 == pComputer->_dwNumComponents) {
            pComputer->_CompClasses[0] = L"Domain";
            pComputer->_CompClasses[1] = L"Computer";
        }
        else if(1 == pComputer->_dwNumComponents) {
            pComputer->_CompClasses[0] = L"Computer";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pComputer->InitUmiObject(
                pComputer->_Credentials,
                ComputerClass,
                gdwComputerTableSize,
                pComputer->_pPropertyCache,
                (IUnknown *)(INonDelegatingUnknown *) pComputer,
                pComputer->_pExtMgr,
                IID_IUnknown,
                ppvObj
                );
        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }


    hr = pComputer->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pComputer->Release();

    RRETURN(hr);

error:

    delete pComputer;
    RRETURN_EXP_IF_ERR(hr);
}


CWinNTComputer::~CWinNTComputer( )
{
    VariantClear(&_vFilter);

    if (_DomainName) {
        ADsFreeString(_DomainName);
    }

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTComputer::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTComputer::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTComputer::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTComputer::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsComputer))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsComputerOperations))
    {
        *ppv = (IADsComputerOperations FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
       *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsComputer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(iid, ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CWinNTComputer::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsComputer) ||
        IsEqualIID(riid, IID_IADsComputerOperations) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

HRESULT
CWinNTComputer::RefCredentials()
{
    if (!_fCredentialsBound)
    {
        //
        // Only try it once, regardless of whether we succeed.
        //
        _fCredentialsBound = TRUE;

        //
        // Also let us rebind to a different server (the TRUE flag).
        //
        _hrBindingResult = _Credentials.RefServer(_Name, TRUE);
    }

    //
    // We also want to return the same value on each call; if we failed to
    //   bind, this object shouldn't be allowed to do anything.
    //
    RRETURN_EXP_IF_ERR(_hrBindingResult);
}


/* IADs methods */

STDMETHODIMP
CWinNTComputer::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    WCHAR szHostServerName[MAX_PATH];

    // We should ref the credentials only if the computer exists
    // otherwise the call will fail.
    if (GetObjectState() != ADS_OBJECT_UNBOUND) {
        BAIL_ON_FAILURE(hr = RefCredentials());
    }

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = WinNTGetCachedDCName(
                        _DomainName,
                        szHostServerName,
                        _Credentials.GetFlags()
                        );
        BAIL_ON_FAILURE(hr);

        hr = WinNTCreateComputer(
                    (szHostServerName + 2),
                    _Name
                    );
        BAIL_ON_FAILURE(hr);

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        RRETURN_EXP_IF_ERR(E_NOTIMPL);
    }

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTComputer::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(4, TRUE));
}

STDMETHODIMP
CWinNTComputer::ImplicitGetInfo(THIS)
{
    RRETURN(GetInfo(4, FALSE));
}

/* IADsContainer methods */

STDMETHODIMP
CWinNTComputer::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTComputer::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTComputer::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTComputer::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CWinNTComputer::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CWinNTComputer::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    WCHAR szBuffer[MAX_PATH];
    DWORD dwLength = 0;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    // Make sure we have proper credentials.
    BAIL_ON_FAILURE(hr = RefCredentials());

    //
    // Length of ADsPath, the relative name and
    // +2 for / and \0
    //
    dwLength = wcslen(_ADsPath) + wcslen(RelativeName) + 2;
    if ( dwLength > MAX_PATH) {
        RRETURN(hr = E_ADS_BAD_PARAMETER);
    }

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName) {
        //
        // +1 for the ",".
        //
        dwLength += wcslen(ClassName) + 1;
        //
        // See if this will cause a buffer overflow.
        //
        if (dwLength > MAX_PATH) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }

        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                (LPVOID *)ppObject,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTComputer::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    // Make sure we have proper credentials.
    BAIL_ON_FAILURE(hr = RefCredentials());

    hr = CWinNTComputerEnum::Create(
                (CWinNTComputerEnum **)&penum,
                _ADsPath,
                _DomainName,
                _Name,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTComputer::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    ULONG ObjectType = 0;
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;

    // Make sure we have proper credentials.
    BAIL_ON_FAILURE(hr = RefCredentials());


    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       ClassName,
                       (PDWORD)&ObjectType
                       );
    BAIL_ON_FAILURE(hr);

    hr = BuildObjectInfo(_ADsPath,
                         RelativeName,
                         &pObjectInfo
                         );
    BAIL_ON_FAILURE(hr);

    switch (ObjectType) {

    case WINNT_USER_ID:

        hr = CWinNTUser::CreateUser(_ADsPath,
                                    WINNT_COMPUTER_ID,
                                    _DomainName,
                                    _Name,
                                    RelativeName,
                                    ADS_OBJECT_UNBOUND,
                                    IID_IDispatch,
                                    _Credentials,
                                    (void **)ppObject
                                    );
        break;


    case WINNT_PRINTER_ID:
        hr = CWinNTPrintQueue::CreatePrintQueue(_ADsPath,
                                      WINNT_COMPUTER_ID,
                                      pObjectInfo->ComponentArray[0],
                                      pObjectInfo->ComponentArray[1],
                                      RelativeName,
                                      ADS_OBJECT_UNBOUND,
                                      IID_IDispatch,
                                      _Credentials,
                                      (void**)ppObject
                                      );
        break;


    //
    // default "group" to local group in computer container for backward
    // compatiblity
    //
    case WINNT_GROUP_ID:
        hr = CWinNTGroup::CreateGroup(
                            _ADsPath,
                            WINNT_COMPUTER_ID,
                            _DomainName,
                            _Name,
                            RelativeName,
                            WINNT_GROUP_LOCAL,
                            ADS_OBJECT_UNBOUND,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppObject
                            );
        break;



    case WINNT_SERVICE_ID:
        hr = CWinNTService::Create(_ADsPath,
                                   pObjectInfo->ComponentArray[0],
                                   pObjectInfo->ComponentArray[1],
                                   RelativeName,
                                   ADS_OBJECT_UNBOUND,
                                   IID_IDispatch,
                                   _Credentials,
                                   (void**)ppObject
                                   );

        break;


    default:

        hr = E_ADS_UNKNOWN_OBJECT;
        break;
    }

    BAIL_ON_FAILURE(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTComputer::Delete(
    BSTR bstrClassName,
    BSTR bstrSourceName
    )
{
    ULONG ObjectType = 0;
    POBJECTINFO pObjectInfo = NULL;
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;
    WCHAR szUncServerName[MAX_PATH];

    // Check if the input parameters are valid
    if (bstrClassName == NULL || bstrSourceName == NULL) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    // Make sure we have proper credentials.
    BAIL_ON_FAILURE(hr = RefCredentials());


    hr = GetObjectType(gpFilters,
                      gdwMaxFilters,
                      bstrClassName,
                      (PDWORD)&ObjectType );

    BAIL_ON_FAILURE(hr);

    hr = BuildObjectInfo(
                _ADsPath,
                bstrSourceName,
                &pObjectInfo
                );

    BAIL_ON_FAILURE(hr);


    switch (ObjectType) {

    case WINNT_USER_ID:

       hr = WinNTDeleteUser(pObjectInfo, _Credentials);

       // This might be the case where the user is on the local
       // machine and there workstation is not available
       if (FAILED(hr) && _fNoWKSTA) {
           // We need to go ahead and whack this user
           hr = WinNTDeleteUser(
                    pObjectInfo->ComponentArray[0],
                    bstrSourceName
                    );
       }

       break;

    case WINNT_GROUP_ID:

       //
       // for backward compatability: allow user to delete by classname "group"
       //

       hr = WinNTDeleteGroup(pObjectInfo, WINNT_GROUP_EITHER, _Credentials);

       if (FAILED(hr) && _fNoWKSTA) {
           //
           // We need to whack this group.
           //
           hr = WinNTDeleteLocalGroup(
                    pObjectInfo->ComponentArray[0],
                    bstrSourceName
                    );
       }
       break;

    //
    // Global Group and LocalGroup ID's will now goto default
    //

    case WINNT_PRINTER_ID:

       hr = WinNTDeletePrinter(pObjectInfo);
       break;

    case WINNT_SERVICE_ID:

       hr = WinNTDeleteService(pObjectInfo);
       break;

    default:

       hr = E_ADS_UNKNOWN_OBJECT;
       break;
    }

    BAIL_ON_FAILURE(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTComputer::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsComputer methods */

HRESULT
CWinNTComputer::AllocateComputerObject(
    CWinNTComputer ** ppComputer
    )
{
    CWinNTComputer FAR * pComputer = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pComputer = new CWinNTComputer();
    if (pComputer == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsComputer,
                (IADsComputer *)pComputer,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsComputerOperations,
                (IADsComputerOperations *)pComputer,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pComputer,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pComputer,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             ComputerClass,
             gdwComputerTableSize,
             (CCoreADsObject *)pComputer,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );


    pComputer->_pPropertyCache = pPropertyCache;
    pComputer->_pDispMgr = pDispMgr;
    *ppComputer = pComputer;

    RRETURN(hr);

error:

    delete  pPropertyCache;
    delete  pDispMgr;
    delete  pComputer;

    RRETURN(hr);

}

WCHAR *szCurrentVersion = L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
WCHAR *szHardwareInfo =  L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0";

STDMETHODIMP
CWinNTComputer::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{

    COMP_INFO_4 CompInfo4;
    PCOMP_INFO_4 pCompInfo4 = &CompInfo4;
    DWORD dwRet = 0;
    HKEY hKey = NULL;
    HKEY hCurrentKey = NULL;
    HKEY hHardwareKey = NULL;
    DWORD cbData = 0;
    HRESULT hr = S_OK;
    WCHAR lpszServerName[MAX_PATH];
    NET_API_STATUS nasStatus;
    LPSERVER_INFO_101 lpServerInfo =NULL;
    WCHAR szMajorVersion[20];
    WCHAR szMinorVersion[20];


    // Make sure we have proper credentials.
    BAIL_ON_FAILURE(hr = RefCredentials());

    memset(pCompInfo4, 0, sizeof(COMP_INFO_4));
    switch (dwApiLevel) {
    case 4:

        hr = MakeUncName(_Name, lpszServerName);
        BAIL_ON_FAILURE(hr);

        dwRet = RegConnectRegistry(
                        lpszServerName,
                        HKEY_LOCAL_MACHINE,
                        &hKey
                        );
        if (dwRet !=ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(dwRet);
            BAIL_ON_FAILURE(hr);
        }

        dwRet =  RegOpenKeyEx(
                        hKey,
                        szCurrentVersion,
                        0,
                        KEY_READ,
                        &hCurrentKey
                        );

        if (dwRet != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(dwRet);
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(pCompInfo4->szOS, L"Windows NT");

        nasStatus = NetServerGetInfo(lpszServerName,
                                     101,
                                     (LPBYTE *)&lpServerInfo
                                     );

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

        _itow(
            lpServerInfo->sv101_version_major,
            szMajorVersion,
            10
            );

        _itow(
            lpServerInfo->sv101_version_minor,
            szMinorVersion,
            10
            );

        wcscpy(
            pCompInfo4->szOSVersion,
            szMajorVersion
            );

        wcscat(
            pCompInfo4->szOSVersion,
            L"."
            );

        wcscat(
            pCompInfo4->szOSVersion,
            szMinorVersion
            );

        cbData = sizeof(pCompInfo4->szOwner);
        dwRet = RegQueryValueEx(
                    hCurrentKey,
                    L"RegisteredOwner",
                    NULL,
                    NULL,
                    (LPBYTE)pCompInfo4->szOwner,
                    &cbData
                    );


        cbData = sizeof(pCompInfo4->szDivision),
        dwRet = RegQueryValueEx(
                    hCurrentKey,
                    L"RegisteredOrganization",
                    NULL,
                    NULL,
                    (LPBYTE)pCompInfo4->szDivision,
                    &cbData
                    );

        cbData = sizeof(pCompInfo4->szProcessorCount),
        dwRet = RegQueryValueEx(
                    hCurrentKey,
                    L"CurrentType",
                    NULL,
                    NULL,
                    (LPBYTE)pCompInfo4->szProcessorCount,
                    &cbData
                    );

        dwRet =  RegOpenKeyEx(
                        hKey,
                        szHardwareInfo,
                        0,
                        KEY_READ,
                        &hHardwareKey
                        );
        if (dwRet != ERROR_SUCCESS) {
            hr = HRESULT_FROM_WIN32(dwRet);
            BAIL_ON_FAILURE(hr);
        }

        cbData = sizeof(pCompInfo4->szProcessor),
        dwRet = RegQueryValueEx(
                    hHardwareKey,
                    L"Identifier",
                    NULL,
                    NULL,
                    (LPBYTE)pCompInfo4->szProcessor,
                    &cbData
                    );


        hr = UnMarshall_Level4(fExplicit, pCompInfo4);

error:
        if(lpServerInfo) {
            NetApiBufferFree(lpServerInfo);
                }

        if (hCurrentKey) {
            RegCloseKey(hCurrentKey);
        }

        if (hHardwareKey) {
            RegCloseKey(hHardwareKey);
        }

        if (hKey) {
            RegCloseKey(hKey);
        }




        RRETURN_EXP_IF_ERR(hr);

    default:
        RRETURN_EXP_IF_ERR(E_FAIL);
    }


}

HRESULT
CWinNTComputer::UnMarshall_Level4(
    BOOL fExplicit,
    LPCOMP_INFO_4 pCompInfo4
    )
{
    HRESULT hr = S_OK;

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("OperatingSystem"),
                pCompInfo4->szOS,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("OperatingSystemVersion"),
                pCompInfo4->szOSVersion,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Owner"),
                pCompInfo4->szOwner,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Division"),
                pCompInfo4->szDivision,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("ProcessorCount"),
                pCompInfo4->szProcessorCount,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Processor"),
                pCompInfo4->szProcessor,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );


    RRETURN(S_OK);
}


STDMETHODIMP
CWinNTComputer::Status(
    IDispatch * FAR * ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


STDMETHODIMP
CWinNTComputer::Shutdown(
    VARIANT_BOOL bReboot
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
RenameUserObject(
    POBJECTINFO pObjectInfo,
    LPWSTR szNewName,
    CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    LPUSER_INFO_0 lpUI = NULL;
    HRESULT hr;
    WCHAR lpszUncName[MAX_PATH];
    NET_API_STATUS nasStatus;
    DWORD dwParam = 0;
    USER_INFO_0 userinfo;
    memset(&userinfo, 0, sizeof(USER_INFO_0));

    switch (pObjectInfo->NumComponents) {
    case 2:

        //
        // if 2 components then either it is user in computer
        // or user in domain.

        hr = WinNTGetCachedDCName(
                        pObjectInfo->ComponentArray[0],
                        szHostServerName,
                        Credentials.GetFlags()
                        );


        if(SUCCEEDED(hr)){
/*
            If the provider works without this code, then remove it permanently

            nasStatus = NetUserGetInfo(szHostServerName,
                                       pObjectInfo->ComponentArray[1],
                                       1,
                                       (LPBYTE *)&lpUI);

            hr = HRESULT_FROM_WIN32(nasStatus);

            //
            // If any buffer was allocated then free it, to prevent us orphaning
            // it in any later call to NetUserGetInfo.
            // Possibly we can just remove the above call to NetUserGetInfo,
            // but I didn't want to, in case that call actually has some useful
            // side effect.
            // 
            if (lpUI)
            {
              NetApiBufferFree(lpUI);
              lpUI = NULL;
            }
*/
            userinfo.usri0_name = szNewName;
            nasStatus = NetUserSetInfo(szHostServerName,
                                       pObjectInfo->ComponentArray[1],
                                       0,
                                       (LPBYTE)&userinfo,
                                       &dwParam);
            hr = HRESULT_FROM_WIN32(nasStatus);
        }

        //
        // if we are here with hr != S_OK it could be that we have
        // user in a  computer.
        //

        if(FAILED(hr)){
            hr = ValidateComputerParent(
                     NULL,
                     pObjectInfo->ComponentArray[0],
                     Credentials
                     );

            BAIL_ON_FAILURE(hr);

            hr = MakeUncName(pObjectInfo->ComponentArray[0],
                             lpszUncName);
            BAIL_ON_FAILURE(hr);

            nasStatus = NetUserGetInfo(lpszUncName,
                                       pObjectInfo->ComponentArray[1],
                                       0,
                                       (LPBYTE *)&lpUI);

            hr = HRESULT_FROM_WIN32(nasStatus);

            userinfo.usri0_name = szNewName;
            nasStatus = NetUserSetInfo(lpszUncName,
                                       pObjectInfo->ComponentArray[1],
                                       0,
                                       (LPBYTE)&userinfo,
                                       &dwParam);
            hr = HRESULT_FROM_WIN32(nasStatus);

        }

        BAIL_ON_FAILURE(hr);

        break;

    case 3:

        //
        // user in domain\computer or user in workgroup\computer
        //



        hr = ValidateComputerParent(pObjectInfo->ComponentArray[0],
                                    pObjectInfo->ComponentArray[1],
                                    Credentials);
        BAIL_ON_FAILURE(hr);

        hr = MakeUncName(pObjectInfo->ComponentArray[1],
                         lpszUncName);
        BAIL_ON_FAILURE(hr);

        nasStatus = NetUserGetInfo(lpszUncName,
                                   pObjectInfo->ComponentArray[2],
                                   0,
                                   (LPBYTE *)&lpUI);

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

        userinfo.usri0_name = szNewName;
        nasStatus = NetUserSetInfo(lpszUncName,
                                   pObjectInfo->ComponentArray[2],
                                   0,
                                   (LPBYTE)&userinfo,
                                   &dwParam);
        hr = HRESULT_FROM_WIN32(nasStatus);
        break;


    default:
        RRETURN(E_ADS_BAD_PATHNAME);
    }


  error:
    if (lpUI) {
        NetApiBufferFree((LPBYTE)lpUI);
    }


    RRETURN(hr);

}

HRESULT
RenameGroupObject(
    POBJECTINFO pObjectInfo,
    LPWSTR szNewName,
    CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    LPGROUP_INFO_0 lpGI = NULL;
    HRESULT hr;
    WCHAR lpszUncName[MAX_PATH];
    NET_API_STATUS nasStatus;
    GROUP_INFO_0 groupinfo;
    memset(&groupinfo, 0, sizeof(GROUP_INFO_0));
    groupinfo.grpi0_name = szNewName;
    DWORD dwParam;

    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // if 2 components then either it is a group in computer
        // or group in domain.
        //

        hr = WinNTGetCachedDCName(
                    pObjectInfo->ComponentArray[0],
                    szHostServerName,
                    Credentials.GetFlags()
                    );

        if(SUCCEEDED(hr)){
            //
            // must be a group in a domain
            //
            hr = ValidateGlobalGroupObject(
                     szHostServerName,
                     &(pObjectInfo->ComponentArray[1]),
                     Credentials
                     );

            if (FAILED(hr)) {
                hr = ValidateLocalGroupObject(
                         szHostServerName,
                         &(pObjectInfo->ComponentArray[1]),
                         Credentials
                         );

                if(SUCCEEDED(hr)){
                    nasStatus = NetLocalGroupSetInfo(szHostServerName,
                                               pObjectInfo->ComponentArray[1],
                                               0,
                                               (LPBYTE)&groupinfo,
                                               &dwParam);
                    hr = HRESULT_FROM_WIN32(nasStatus);
                }

            }else{
                nasStatus = NetGroupSetInfo(szHostServerName,
                                           pObjectInfo->ComponentArray[1],
                                           0,
                                           (LPBYTE)&groupinfo,
                                           &dwParam);
                hr = HRESULT_FROM_WIN32(nasStatus);
            }
        }

        if(FAILED(hr)){
            //
            // potentially a group in a computer
            //

            hr = ValidateComputerParent(NULL,
                                        pObjectInfo->ComponentArray[0],
                                        Credentials);
            BAIL_ON_FAILURE(hr);

            //
            // group in a computer
            //
            hr = MakeUncName(pObjectInfo->ComponentArray[0],
                             lpszUncName);
            BAIL_ON_FAILURE(hr);

            hr = ValidateGlobalGroupObject(
                     lpszUncName,
                     &(pObjectInfo->ComponentArray[1]),
                     Credentials
                     );

            if (FAILED(hr)) {

                hr = ValidateLocalGroupObject(
                         lpszUncName,
                         &(pObjectInfo->ComponentArray[1]),
                         Credentials
                         );

                BAIL_ON_FAILURE(hr);
                    nasStatus = NetLocalGroupSetInfo(lpszUncName,
                                               pObjectInfo->ComponentArray[1],
                                               0,
                                               (LPBYTE)&groupinfo,
                                               &dwParam);
                    hr = HRESULT_FROM_WIN32(nasStatus);

            }else{
                nasStatus = NetGroupSetInfo(lpszUncName,
                                           pObjectInfo->ComponentArray[1],
                                           0,
                                           (LPBYTE)&groupinfo,
                                           &dwParam);
                hr = HRESULT_FROM_WIN32(nasStatus);
            }
        }
        break;

        case 3:

        //
        // if there are 3 components then we must have parentid
        // WINNT_COMPUTER_ID
        //
        hr = ValidateComputerParent(pObjectInfo->ComponentArray[0],
                                    pObjectInfo->ComponentArray[1],
                                    Credentials);

        BAIL_ON_FAILURE(hr);

        hr = MakeUncName(
                      pObjectInfo->ComponentArray[1],
                      lpszUncName
                      );
        BAIL_ON_FAILURE(hr);

        hr = ValidateGlobalGroupObject(
                        lpszUncName,
                        &(pObjectInfo->ComponentArray[2]),
                        Credentials
                        );

        if (FAILED(hr)) {

            hr = ValidateLocalGroupObject(
                           lpszUncName,
                           &(pObjectInfo->ComponentArray[2]),
                           Credentials
                           );

            BAIL_ON_FAILURE(hr);
            nasStatus = NetLocalGroupSetInfo(lpszUncName,
                                       pObjectInfo->ComponentArray[2],
                                       0,
                                       (LPBYTE)&groupinfo,
                                       &dwParam);
            hr = HRESULT_FROM_WIN32(nasStatus);

        }else{
            nasStatus = NetGroupSetInfo(lpszUncName,
                                       pObjectInfo->ComponentArray[2],
                                       0,
                                       (LPBYTE)&groupinfo,
                                       &dwParam);
            hr = HRESULT_FROM_WIN32(nasStatus);
        }
        break;

    default:
        RRETURN(E_ADS_BAD_PATHNAME);
    }


error:
    if (lpGI) {
        NetApiBufferFree((LPBYTE)lpGI);
    }

    RRETURN(hr);

}

HRESULT
CompareBasePath(POBJECTINFO pObjectInfo, POBJECTINFO pObjectInfoParent)
{
    HRESULT hr = S_OK;
    DWORD i;

    if (wcscmp(pObjectInfo->ProviderName,
               pObjectInfoParent->ProviderName) != 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (pObjectInfo->NumComponents != pObjectInfoParent->NumComponents+1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    for (i=0;i<pObjectInfoParent->NumComponents;i++) {
        if (wcscmp(pObjectInfo->ComponentArray[i],
                   pObjectInfoParent->ComponentArray[i]) != 0) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }
    }

error:
    return hr;
}

HRESULT
MoveUserGroupObject(
    THIS_ BSTR SourceName,
    BSTR NewName,
    BSTR bstrParentADsPath,
    CWinNTCredentials& Credentials,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;
    POBJECTINFO pObjectInfoParent = NULL;

    if ((!SourceName || *SourceName == NULL) ||
        (!NewName || *NewName == NULL)) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_IF_ERROR(hr);
    }

    hr = BuildObjectInfo(
                SourceName,
                &pObjectInfo
                );
    BAIL_IF_ERROR(hr);

    hr = BuildObjectInfo(
                bstrParentADsPath,
                &pObjectInfoParent
                );
    BAIL_IF_ERROR(hr);

    hr = CompareBasePath(pObjectInfo,
                         pObjectInfoParent);
    BAIL_IF_ERROR(hr);

    hr = ValidateProvider(pObjectInfo);
    BAIL_IF_ERROR(hr);

    // check if the call is from UMI. If so, the old path will have a class
    // specified in it. Try to rename the object of that class, as opposed
    // to trying to trying to rename a user first and then rename a group.
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
       if(pObjectInfo->ObjectType == TOKEN_USER) {
           hr = RenameUserObject(
                    pObjectInfo,
                    NewName,
                    Credentials
                    );
       }
       else if(pObjectInfo->ObjectType == TOKEN_GROUP) {
           hr = RenameGroupObject(
                    pObjectInfo,
                    NewName,
                    Credentials
                    );
       }
       else
           hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
    }
    else {
        hr = RenameUserObject(
                pObjectInfo,
                NewName,
                Credentials
                );
        if (FAILED(hr)
            && hr != HRESULT_FROM_WIN32(ERROR_BAD_USERNAME)
            && hr != HRESULT_FROM_WIN32(NERR_UserExists)
            && hr != HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)
            ) {

            hr = RenameGroupObject(
                    pObjectInfo,
                    NewName,
                    Credentials
                    );

            if (hr == HRESULT_FROM_WIN32(NERR_GroupNotFound)) {
                //
                // The object to move wasn't a group or user
                //
                hr = HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
            }
        }
    } // else

    BAIL_ON_FAILURE(hr);

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    hr = BuildObjectInfo(
                bstrParentADsPath,
                NewName,
                &pObjectInfo
                );
    BAIL_IF_ERROR(hr);

    hr = HeuristicGetObject(
                    pObjectInfo,
                    (void**)ppObject,
                    Credentials);
    BAIL_IF_ERROR(hr);

cleanup:
error:
    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }
    if (pObjectInfoParent) {
        FreeObjectInfo(pObjectInfoParent);
    }
    return hr;
}

STDMETHODIMP
CWinNTComputer::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    return MoveUserGroupObject(SourceName,
                               NewName,
                               _ADsPath,
                               _Credentials,
                               ppObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\ccred.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ccred.cxx

Abstract:

    This module abstracts user credentials for the multiple credential support.

Author:

    Blake Jones (t-blakej) 08-08-1997

Revision History:

--*/

#include "winnt.hxx"
extern "C" {
#include "winnetwk.h"
}
#pragma hdrstop

//
// The resource to bind to on remote machines.
//
static const PWSTR g_pszResourceName = TEXT("IPC$");

//
// The error to return from CCred::ref when a bind to a different server
// is attempted.  The caller (should be CWinNTCredentials::RefServer)
// should catch this and dispense with it appropriately.
//
// This should be an error other than E_OUTOFMEMORY or anything that
// WNetAddConnection2 can return.  This is pretty much a bogus error,
// but I'm appropriating it just for RefServer.
//
static const HRESULT dwRebindErr = HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS);

//////////////////////////////////////////////////////////////////////////////

//
// Internal class declarations:
//

//+---------------------------------------------------------------------------
//    ____      _ _   ____            _
//   / ___|_ __(_) |_/ ___|  ___  ___| |_
//  | |   | '__| | __\___ \ / _ \/ __| __|
//  | |___| |  | | |_ ___) |  __/ (__| |_
//   \____|_|  |_|\__|____/ \___|\___|\__|
//
// Class CritSect -- C++ wrapper around an NT critical section object.
//
// Constructors:
//   CritSect()                         - initialize the NT object
//
// Public methods:
//   Lock                               - enter the critical section
//   Locked                             - whether we're in the crit. sect.
//   Unlock                             - leave the critical section
//
//----------------------------------------------------------------------------
class CritSect
{
public:
    CritSect()          { InitializeCriticalSection(&m_cs); m_bLocked = FALSE; }
    void Lock()         { EnterCriticalSection(&m_cs); m_bLocked = TRUE; }
    BOOL Locked()       { return m_bLocked; }
    void Unlock()       { LeaveCriticalSection(&m_cs); m_bLocked = FALSE; }
    ~CritSect()         { DeleteCriticalSection(&m_cs); }

private:
    CRITICAL_SECTION m_cs;
    BOOL m_bLocked;
};

//+---------------------------------------------------------------------------
//    ____ ____              _ _____     _     _
//   / ___/ ___|_ __ ___  __| |_   _|_ _| |__ | | ___
//  | |  | |   | '__/ _ \/ _` | | |/ _` | '_ \| |/ _ \
//  | |__| |___| | |  __/ (_| | | | (_| | |_) | |  __/
//   \____\____|_|  \___|\__,_| |_|\__,_|_.__/|_|\___|
//
// Class CCredTable -- performs the authentication requests for the CCred
//   objects, and keeps a mapping for deregistration of objects.
//
// Constructors:
//   CCredTable()                       - make an empty credential table
//
// Public methods:
//   AddCred                            - try to obtain a credential;
//                                        if successful, add it to the table
//   DelCred                            - remove a credential from the table
//
//----------------------------------------------------------------------------
class CCredTable
{
public:
    CCredTable();
    ~CCredTable();

    HRESULT
    AddCred(PWSTR pszUserName, PWSTR pszPassword, PWSTR pszServer,
        DWORD *dwIndex);

    HRESULT
    DelCred(DWORD dwIndex);

private:
    HRESULT
    GrowTable(void);

    //
    // The type used for storing credential->resource name mappings
    //   for deregistration.
    //
    struct cred { PWSTR m_pResource; BOOL m_bUsed; DWORD m_dwCount; 
                  BOOL m_fAlreadyConnected; // was net use already established
                };

    cred *m_pCredentials;               // the cred->resource name table
    DWORD m_dwAlloc;                    // # table entries allocated
    DWORD m_dwUsed;                     // # table entries used
    CritSect m_cs;                      // to guard table access
};

//+---------------------------------------------------------------------------
//    ____ ____              _
//   / ___/ ___|_ __ ___  __| |
//  | |  | |   | '__/ _ \/ _` |
//  | |__| |___| | |  __/ (_| |
//   \____\____|_|  \___|\__,_|
//
// Class CCred - encapsulates the reference-countable parts of the
//   WinNT authentication object.
//
// Constructors:
//   CCred()                            - create an empty CCred
//   CCred(PWSTR pszUserName,           - create a CCred with a username
//         PWSTR pszPassword)             and password.  This does not bind
//                                        to a server yet.
//
// Public methods:
//   GetUserName                        - get the username of the credentials
//   SetUserName                        - set the username of the credentials
//   GetPassword                        - get the password of the credentials
//   SetPassword                        - set the password of the credentials
//   ref                                - add a reference to this object
//   deref                              - remove a reference from this object
//
//----------------------------------------------------------------------------
class CCred
{
    // so it can call the copy ctor
    friend class CWinNTCredentials;

public:
    CCred();
    CCred(PWSTR pszUserName, PWSTR pszPassword);
    ~CCred();

    HRESULT ref(PWSTR pszServer);
    HRESULT deref();

    HRESULT GetUserName(PWSTR *ppszUserName);
    HRESULT GetPassword(PWSTR *ppszPassword);
    DWORD m_dwUsageCount;               // this object's usage count

private:
    CCred(const CCred& other);          // only called by CWinNTCredentials
    CCred& operator=(const CCred&);     // deliberately not implemented

    //
    // Used for storing the password encrypted.
    //
    enum { NW_ENCODE_SEED3 = 0x83 };

    PWSTR m_pszUserName;                // username
    PWSTR m_pszPassword;                // password
    DWORD m_dwPasswdLen;                // #bytes allocated for password
    PWSTR m_pszServer;                  // server on which we have credentials

    DWORD m_dwIndex;                    // index in the CredTable
    DWORD m_dwRefCount;                 // this object's reference count

    static CCredTable g_CredTable;      // the table
};

//
// The table.
//
CCredTable CCred::g_CredTable;

//////////////////////////////////////////////////////////////////////////////

//
// Class definitions:
//

///---------------------------------------------------------------------------
//    ____ ____              _
//   / ___/ ___|_ __ ___  __| |
//  | |  | |   | '__/ _ \/ _` |
//  | |__| |___| | |  __/ (_| | definitions
//   \____\____|_|  \___|\__,_|
//
///---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
// CCred constructor
//
// Create an empty credential object.
//
//----------------------------------------------------------------------------
CCred::CCred() :
    m_pszUserName(NULL), m_pszPassword(NULL), m_pszServer(NULL),
    m_dwIndex((DWORD) -1), m_dwRefCount(0), m_dwUsageCount(1), m_dwPasswdLen(0)
{
}

//+---------------------------------------------------------------------------
//
// CCred constructor
//
// Create a credential object with a username and a password.
// This doesn't increase the reference count, since it doesn't make any
//   connections to the server.
//
// Arguments:
//   [pszUserName]                      - username
//   [pszPassword]                      - password
//
//----------------------------------------------------------------------------
CCred::CCred(PWSTR pszUserName, PWSTR pszPassword) :
    m_pszUserName(NULL), m_pszPassword(NULL), m_pszServer(NULL),
    m_dwIndex((DWORD) -1), m_dwRefCount(0), m_dwUsageCount(1), m_dwPasswdLen(0)
{
    //
    // NTRAID#NTBUG9-67020-2000-7-26-AjayR. We need a way to fail
    // on the constructor.
    //
    m_pszUserName = pszUserName ? AllocADsStr(pszUserName) : NULL;

    if (pszPassword)
    {
        UNICODE_STRING Password;
        UCHAR Seed = NW_ENCODE_SEED3;

        m_dwPasswdLen =  (wcslen(pszPassword) + 1)*sizeof(WCHAR) + 
                         (DES_BLOCKLEN -1);
        m_pszPassword = (PWSTR) AllocADsMem(m_dwPasswdLen);

        ADsAssert(m_pszPassword != NULL);

        if (m_pszPassword) {
            wcscpy(m_pszPassword, pszPassword);
            RtlInitUnicodeString(&Password, m_pszPassword); 

            if(NULL == g_pRtlEncryptMemory)
                RtlRunEncodeUnicodeString(&Seed, &Password);
            else {
                DWORD extra = 0;
                NTSTATUS ntStatus = 0;

                if(extra = (Password.MaximumLength % DES_BLOCKLEN))
                    Password.MaximumLength += (DES_BLOCKLEN - extra);

                ntStatus = g_pRtlEncryptMemory(
                               Password.Buffer,
                               Password.MaximumLength,
                               0
                               );
                ADsAssert(ntStatus == STATUS_SUCCESS);

                m_dwPasswdLen = Password.MaximumLength;
            }
        }
    }
    else {
        m_dwPasswdLen = 0;
        m_pszPassword = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// CCred constructor
//
// Create a credential object with a username and a password.
// This doesn't copy the reference count of the "other" object, nor the
//   server nor the server connection index.  This is used to create
//   credentials with the same user/pass on a different server.
// This should only be used by CWinNTCredentials::RefServer.
//
// Arguments:
//   [other]                            - credentials to copy
//
//----------------------------------------------------------------------------
CCred::CCred(const CCred& other) : m_pszServer(NULL),
    m_dwIndex((DWORD) -1), m_dwRefCount(0), m_dwUsageCount(1)
{
    m_pszUserName =
        other.m_pszUserName ? AllocADsStr(other.m_pszUserName) : NULL;

    if(other.m_pszPassword != NULL) {
        m_pszPassword = (PWSTR) AllocADsMem(other.m_dwPasswdLen);
        ADsAssert(m_pszPassword != NULL);
        if(m_pszPassword != NULL) {
            memcpy(m_pszPassword, other.m_pszPassword, other.m_dwPasswdLen);
            m_dwPasswdLen = other.m_dwPasswdLen;
        }
        else
            m_dwPasswdLen = 0;
    }
    else {
        m_dwPasswdLen = 0;
        m_pszPassword = NULL;
    }
}

//+---------------------------------------------------------------------------
//
// CCred destructor
//
// Doesn't lower the reference count.
// The object is really deleted in deref().
// It will release the underlying info only if the
// there are no outstanding references
// -- AjayR modified on 6-24-98.
//
//----------------------------------------------------------------------------
CCred::~CCred()
{
    //
    // Clean up only if the usageCount and refCount are 0
    // Any other case means someone has a pointer to this
    //
    if (m_dwUsageCount == 0 && m_dwRefCount == 0) {

        if (m_pszUserName)
            FreeADsStr(m_pszUserName);
        if (m_pszPassword)
            FreeADsMem(m_pszPassword);
        if (m_pszServer)
            FreeADsStr(m_pszServer);

    }

}

//+---------------------------------------------------------------------------
//
// CCred::ref
//
// Adds a reference to this credential object, and if necessary, binds
//   to the specified server.  If this is already bound to the given server,
//   the reference count is simply increased.
//
// Arguments:
//   [pszServer]                        - server to bind to
//
// Returns:
//   S_OK               - if we bound to the server, or are already bound to
//                        the given server.
//   E_FAIL             - if this object is bound, and "pszServer" is not the
//                        same server as we are bound to.
//   E_OUTOFMEMORY      - if we run out of memory.
//   Other error codes resulting from WNetAddConnection2.
//
//----------------------------------------------------------------------------
HRESULT
CCred::ref(PWSTR pszServer)
{
    HRESULT hr = S_OK;
    PWSTR pszPassword = NULL;

    if (!m_pszServer)
    {
        hr = GetPassword(&pszPassword);
        BAIL_ON_FAILURE(hr);

        hr = g_CredTable.AddCred(m_pszUserName, pszPassword, pszServer,
            &m_dwIndex);

        //
        // Zero out the memory holding the password, now we have finished
        // with it.
        //
        SecureZeroMemory(pszPassword, wcslen(pszPassword) * sizeof(WCHAR));

        if (SUCCEEDED(hr))
        {
            m_dwRefCount++;
            m_pszServer = AllocADsStr(pszServer);
        }
        else
            // Don't set m_pszServer, since we didn't bind.
            m_dwIndex = (DWORD) -1;
    }
    else
    {
        if (_wcsicmp(m_pszServer, pszServer) == 0)
            m_dwRefCount++;
        else
            //
            // Don't rebind to another server.  Let the caller do it
            //   explicitly, if desired.
            //
            hr = dwRebindErr;
    }

error:
    if (pszPassword)
        FreeADsStr(pszPassword);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CCred::deref
//
// Removes a reference from this credential object.  When the reference count
//   drops to zero, it unbinds from the associated server and deletes itself.
// After the caller calls deref(), it shouldn't touch this object ever again.
//
// Returns:
//   S_OK               - deref occurred okay.
//   Other error codes resulting from WNetCancelConnection2.
//
//----------------------------------------------------------------------------
HRESULT
CCred::deref(void)
{
    HRESULT hr = S_OK;
    ADsAssert(m_dwRefCount > 0);

    m_dwRefCount--;

    if (m_dwRefCount == 0)
        {
            hr = g_CredTable.DelCred(m_dwIndex);

            // Reset the index and free server to play extra safe
            m_dwIndex = (DWORD) -1;

            if (m_pszServer) {
                FreeADsStr(m_pszServer);
                m_pszServer = NULL;
            }
#if DBG
            if (hr == E_INVALIDARG)
                ADsAssert(FALSE && "Invalid table index in CCred::deref()!");
#endif
        }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CCred::GetUserName
//
// Retrieves the username represented by this credentials object.
//
// Arguments:
//   [ppszUserName]                     - address of a PWSTR to receive a
//                                        pointer to the username.
// Returns:
//   S_OK               - on success
//   E_OUTOFMEMORY      - if we run out of memory.
//
//----------------------------------------------------------------------------
HRESULT
CCred::GetUserName(PWSTR *ppszUserName)
{
    if (!m_pszUserName)
        *ppszUserName = NULL;
    else
    {
        *ppszUserName = AllocADsStr(m_pszUserName);
        if (!*ppszUserName)
            RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
//
// CCred::GetPassword
//
// Retrieves the password represented by this credentials object.
//
// Arguments:
//   [ppszPassword]                     - address of a PWSTR to receive a
//                                        pointer to the password.
// Returns:
//   S_OK               - on success
//   E_OUTOFMEMORY      - if we run out of memory.
//
//----------------------------------------------------------------------------
HRESULT
CCred::GetPassword(PWSTR * ppszPassword)
{
    UNICODE_STRING Password;
    PWSTR pTempPassword = NULL;
    UCHAR Seed = NW_ENCODE_SEED3;


    Password.Length = 0;

    if (!m_pszPassword)
        *ppszPassword = NULL;
    else
    {
        pTempPassword = (PWSTR) AllocADsMem(m_dwPasswdLen);
        if (!pTempPassword)
            RRETURN(E_OUTOFMEMORY);

        memcpy(pTempPassword, m_pszPassword, m_dwPasswdLen);

        if(NULL == g_pRtlDecryptMemory) {
            RtlInitUnicodeString(&Password, pTempPassword);
            RtlRunDecodeUnicodeString(Seed, &Password);
        }
        else {
            NTSTATUS ntStatus = 0;

            ntStatus = g_pRtlDecryptMemory(pTempPassword, m_dwPasswdLen, 0);
            if(ntStatus != STATUS_SUCCESS)
                RRETURN(E_FAIL);
        }    

        *ppszPassword = pTempPassword;
    }

    RRETURN(S_OK);
}

///---------------------------------------------------------------------------
//    ____ ____              _ _____     _     _
//   / ___/ ___|_ __ ___  __| |_   _|_ _| |__ | | ___
//  | |  | |   | '__/ _ \/ _` | | |/ _` | '_ \| |/ _ \
//  | |__| |___| | |  __/ (_| | | | (_| | |_) | |  __/ definitions
//   \____\____|_|  \___|\__,_| |_|\__,_|_.__/|_|\___|
//
///---------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
// CCredTable constructor
//
// Creates an empty CCredTable.
//
//----------------------------------------------------------------------------
CCredTable::CCredTable() :
    m_pCredentials(NULL), m_dwAlloc(0), m_dwUsed(0)
{
}

//+---------------------------------------------------------------------------
//
// CCredTable destructor
//
// Destroys the CCredTable.  If there are entries still in use at dtor
// time, it will print a debug message.  (Maybe it should assert?)
//
//----------------------------------------------------------------------------
CCredTable::~CCredTable()
{
    for (DWORD dw = 0; dw < m_dwUsed; ++dw)
    {
        if (m_pCredentials[dw].m_bUsed)
        {
            // the share name could be up to MAX_PATH.
#if 0
            WCHAR pszMessage[64 + MAX_PATH];
            wsprintf(pszMessage, TEXT("Credential %d (\"%s\") not free!"),
                dw, m_pCredentials[dw].m_pResource);
            OutputDebugString(pszMessage);
#endif
        }

        //
        // Try to cancel the connection, so we don't have lots left
        // lying around, but don't complain if we can't disconnect.
        //
        DelCred(dw);
    }
    if (m_pCredentials)
        FreeADsMem(m_pCredentials);
}

//+---------------------------------------------------------------------------
//
// CCredTable::AddCred
//
// Tries to get credentials for a server's "IPC$" resource.  If the
//   credentials are gained, an entry is added to the resource table.
//   The "index" returned allows the caller to delete the resource
//   when it's done with it.
//
// Arguments:
//   [pszUserName]                      - username to use
//   [pszPassword]                      - password to use
//   [pszServer]                        - server to connect to
//   [pdwIndex]                         - address of a DWORD to receive
//                                        the table index of this resource.
// Returns:
//   S_OK               - if we bound to the server.
//   E_OUTOFMEMORY      - if we run out of memory.
//   Other error codes resulting from WNetAddConnection2.
//
//----------------------------------------------------------------------------
HRESULT
CCredTable::AddCred(PWSTR pszUserName, PWSTR pszPassword, PWSTR pszServer,
        DWORD *pdwIndex)
{
    HRESULT hr = S_OK;
    BOOL fAlreadyInTable = FALSE;
    DWORD dwCtr = 0;
    NET_API_STATUS nasStatus = 0;
    USE_INFO_1 *pUseInfo = NULL;
    BOOL fConnectionAdded = FALSE;
    BOOL fInCritSect = FALSE;

    *pdwIndex = (DWORD) -1;

    //
    // Open a connection to IPC$ on the server.
    //

    NETRESOURCE NetResource;
    memset(&NetResource, 0, sizeof(NETRESOURCE));
    NetResource.dwType = RESOURCETYPE_ANY;
    NetResource.lpLocalName = NULL;
    NetResource.lpProvider = NULL;

    WCHAR RemoteName[MAX_PATH];

    if( (wcslen(pszServer) + wcslen(g_pszResourceName) + 4) > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    wsprintf(RemoteName, TEXT("\\\\%ls\\%ls"), pszServer, g_pszResourceName);
    NetResource.lpRemoteName = RemoteName;

    //
    // WNetAddConnection2 ignores the other members of NETRESOURCE.
    //

    DWORD dwResult;
    dwResult = WNetAddConnection2(&NetResource, pszPassword, pszUserName, 0);
    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwResult));
    fConnectionAdded = TRUE;

    m_cs.Lock();
    fInCritSect = TRUE;

    //
    // At this point, we know that the NetUse call succeeded.
    // We are not going to see if we need to add this to the
    // table or not. If we already have a net use to the same
    // resource then we need not add this to the table and
    // instead we should bump up the refCount and return the
    // index of the already stored resource.
    //
    for (dwCtr = 0; (dwCtr < m_dwUsed) && !fAlreadyInTable; dwCtr++) {

        if (m_pCredentials[dwCtr].m_bUsed
            && m_pCredentials[dwCtr].m_pResource) {

#ifdef WIN95
            if (_wcsicmp(
                    m_pCredentials[dwCtr].m_pResource,
                    RemoteName
                    )
                == 0 ) {
#else
            if (CompareStringW(
                    LOCALE_SYSTEM_DEFAULT,
                    NORM_IGNORECASE,
                    m_pCredentials[dwCtr].m_pResource,
                    -1,
                    RemoteName,
                    -1
                ) == CSTR_EQUAL ) {
#endif
                *pdwIndex = dwCtr;
                fAlreadyInTable = TRUE;
                m_pCredentials[dwCtr].m_dwCount++;
            }

        }
    }

    //
    // Index will not be -1 if we found a match in the table.
    //
    if (!fAlreadyInTable) {

        if (m_dwUsed == m_dwAlloc)
            hr = GrowTable();
        BAIL_ON_FAILURE(hr);
        ADsAssert(m_dwUsed < m_dwAlloc);

        m_pCredentials[m_dwUsed].m_pResource = AllocADsStr(RemoteName);
        if (!m_pCredentials[m_dwUsed].m_pResource)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        m_pCredentials[m_dwUsed].m_bUsed = TRUE;

        m_pCredentials[m_dwUsed].m_dwCount = 1;

        //
        // check to see if there was already a net use connection existing at
        // the time WNetAddConnection2 was called.
        //

        nasStatus = NetUseGetInfo(
                           NULL,
                           RemoteName,
                           1, // level
                           (LPBYTE *) &pUseInfo
                           );

        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));

        ADsAssert(pUseInfo != NULL);

        if(pUseInfo->ui1_usecount == 1)  {
        // only this process has an open connection

            m_pCredentials[m_dwUsed].m_fAlreadyConnected = FALSE;
        }
        else  {
            m_pCredentials[m_dwUsed].m_fAlreadyConnected = TRUE;
        }

        // do this last thing.
        *pdwIndex = m_dwUsed++;
    }

    m_cs.Unlock();
    fInCritSect = FALSE;

    if(pUseInfo != NULL)
        NetApiBufferFree(pUseInfo);

    RRETURN(hr);

error:
    if (m_dwUsed != m_dwAlloc && m_pCredentials[m_dwUsed].m_pResource != NULL)
    {
        FreeADsStr(m_pCredentials[m_dwUsed].m_pResource);
        m_pCredentials[m_dwUsed].m_pResource = NULL;
    }

    if (fInCritSect)
        m_cs.Unlock();

    if (fConnectionAdded)
        (void) WNetCancelConnection2(RemoteName, 0, FALSE);

    if(pUseInfo != NULL)
        NetApiBufferFree(pUseInfo);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CCredTable::DelCred
//
// Disconnects from the "ADMIN$" resource specified by the table entry
//   with index "dwIndex".
//
// Arguments:
//   [DWORD dwIndex]                    - index of table entry to delete
//
// Returns:
//   S_OK               - deref occurred okay.
//   E_INVALIDARG       - the table index is invalid.
//   Other error codes resulting from WNetCancelConnection2.
//
//----------------------------------------------------------------------------
HRESULT
CCredTable::DelCred(DWORD dwIndex)
{
    HRESULT hr = S_OK;
    DWORD dwResult;

    m_cs.Lock();

    if (((LONG)dwIndex) < 0 || dwIndex >= m_dwUsed)
        hr = E_INVALIDARG;
    else if (m_pCredentials[dwIndex].m_bUsed == FALSE)
        hr = S_OK;
    else
    {
        ADsAssert(m_pCredentials[dwIndex].m_dwCount);

        //
        // Delete only if the refCount is zero.
        //
        if (--m_pCredentials[dwIndex].m_dwCount == 0) {
            //
            // cancel connection only if if it was not already present at the
            // time we did WNetAddConnection2
            //
            if(m_pCredentials[dwIndex].m_fAlreadyConnected == FALSE) {
                dwResult = WNetCancelConnection2(
                        m_pCredentials[dwIndex].m_pResource, 0, FALSE);
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwResult));
            }

            FreeADsStr(m_pCredentials[dwIndex].m_pResource);
            m_pCredentials[dwIndex].m_pResource = NULL;
            m_pCredentials[dwIndex].m_bUsed = FALSE;
            m_pCredentials[dwIndex].m_dwCount = 0;
            m_pCredentials[dwIndex].m_fAlreadyConnected = FALSE;

        }
        else {
            hr = S_OK;
        }
    }

error:
    m_cs.Unlock();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CCredTable::GrowTable
//
// Increase the size of the CredTable by a fixed amount.  Private method.
//
// Returns:
//   S_OK               - deref occurred okay.
//   E_OUTOFMEMORY      - we ran out of memory.
//
//----------------------------------------------------------------------------
HRESULT
CCredTable::GrowTable(void)
{
    ADsAssert(m_cs.Locked());

    cred *pCredentials = (cred *)ReallocADsMem(m_pCredentials,
        m_dwAlloc * sizeof(cred), (m_dwAlloc + 10) * sizeof(cred));

    if (!pCredentials)
        RRETURN(E_OUTOFMEMORY);
    m_pCredentials = pCredentials;
    for (DWORD dw = m_dwAlloc; dw < m_dwAlloc + 10; dw++)
    {
        m_pCredentials[dw].m_bUsed = FALSE;
        m_pCredentials[dw].m_pResource = NULL;
        m_pCredentials[dw].m_dwCount = 0;
        m_pCredentials[dw].m_fAlreadyConnected = FALSE;
    }

    m_dwAlloc += 10;

    RRETURN(S_OK);
}

//////////////////////////////////////////////////////////////////////////////
//   _____      ___      _  _ _____ ___            _         _   _      _
//  / __\ \    / (_)_ _ | \| |_   _/ __|_ _ ___ __| |___ _ _| |_(_)__ _| |___
// | (__ \ \/\/ /| | ' \| .` | | || (__| '_/ -_) _` / -_) ' \  _| / _` | (_-<
//  \___| \_/\_/ |_|_||_|_|\_| |_| \___|_| \___\__,_\___|_||_\__|_\__,_|_/__/
//                              definitions
//
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
// CWinNTCredentials constructor
//
// Creates an empty CWinNTCredentials object.
//
//----------------------------------------------------------------------------
CWinNTCredentials::CWinNTCredentials():
    m_cRefAdded(0), m_pCred(NULL), m_dwFlags(0)
{
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials constructor
//
// Creates a CWinNTCredentials object for a given username/password.
//
// Arguments:
//   [pszUserName]                      - username
//   [pszPassword]                      - password
//
//----------------------------------------------------------------------------
CWinNTCredentials::CWinNTCredentials(PWSTR pszUserName, PWSTR pszPassword, DWORD dwFlags) :
    m_cRefAdded(0), m_pCred(NULL), m_dwFlags(dwFlags)
{
    //
    // If both username and password are NULL or "", don't create a cred.
    //

    if ((pszUserName && *pszUserName) || (pszPassword && *pszPassword))
        m_pCred = new CCred(pszUserName, pszPassword);
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials copy constructor
//
// Copies a CWinNTCredentials object from another.
// This sets the "referenced" flag to FALSE, and doesn't increase the
//   reference count.  That should be done explicitly with ref().
//
// Arguments:
//   [other]                            - credentials to copy
//
//----------------------------------------------------------------------------
CWinNTCredentials::CWinNTCredentials(const CWinNTCredentials& other) :
    m_cRefAdded(0), m_pCred(other.m_pCred), m_dwFlags(other.m_dwFlags)
{
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials destructor
//
// Dereferences the credentials.  If the reference count drops to zero,
//   the internal refcounted credentials object goes away.
//
//----------------------------------------------------------------------------
CWinNTCredentials::~CWinNTCredentials()
{
    Clear_pCredObject();
}



//+---------------------------------------------------------------------------
//
// CWinNTCredentials::Clear_pCredObject
//
// Dereferences the credentials.  If the reference count drops to zero,
//   the internal refcounted credentials object goes away.
// This is a private member function as this needs to be called
// in different places and therefore the destructor is not the
// right place - AjayR 6-25-98.
//
//----------------------------------------------------------------------------
void
CWinNTCredentials::Clear_pCredObject()
{
    if (m_cRefAdded) {

        m_pCred->deref();
        m_cRefAdded--;

    }

    if (m_pCred) {

        m_pCred->m_dwUsageCount--;

        if (m_pCred->m_dwUsageCount == 0) {
            delete m_pCred;
            m_pCred = NULL;
        }
    }

}
//+---------------------------------------------------------------------------
//
// CWinNTCredentials copy operator
//
// Copies a CWinNTCredentials object from another.  This dereferences
//   the old object, and doesn't increase the reference count of the
//   new object.  That should be done explicitly with ref().
//
// Arguments:
//   [other]                            - credentials to copy
//
//----------------------------------------------------------------------------
const CWinNTCredentials&
CWinNTCredentials::operator=(const CWinNTCredentials& other)
{
    if (&other != this)
    {
        // Clean up the current m_pCred
        Clear_pCredObject();

        m_dwFlags = other.m_dwFlags;

        m_pCred = other.m_pCred;
        if (m_pCred) {
            m_pCred->m_dwUsageCount++;
        }
        m_cRefAdded = 0;
        // Don't addref here.
    }

    return *this;
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials::RefServer
//
// Increments the credentials object's reference count, and if necessary,
//   attempts to connect to the server's "ADMIN$" resource.
//
// Arguments:
//   [pszServer]                        - server to establish credentials with
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::RefServer(PWSTR pszServer, BOOL fAllowRebinding)
{
    HRESULT hr = S_OK;

    if (m_pCred)
    {
        ADsAssert(pszServer && *pszServer);
        hr = m_pCred->ref(pszServer);
        //
        // We usually don't want to allow rebinding, to catch coding mistakes.
        // The only time we want to is when we open a Computer object from a
        //   Domain, which has been opened via OpenDSObject.
        //
        if (hr == dwRebindErr && fAllowRebinding)
        {
            // Copy the username and password, and try again.
            CCred * pCCred = new CCred(*m_pCred);

            // clear the m_pCred object
            Clear_pCredObject();

            //
            // assign the m_pCred object to the copy and try
            // and rebind if the new CCred object is not null
            //
            m_pCred = pCCred;

            //
            // m_cRefAdded is this CWinNTCredentials object's contribution
            // to the refcount of m_pCred. Since we have a new CCred object, 
            // set m_cRefAdded to 0. 
            //
            m_cRefAdded = 0;

            if (m_pCred) 
                hr = m_pCred->ref(pszServer);
            else
                hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
            m_cRefAdded++;
    }
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
// CWinNTCredentials::DeRefServer
//
// Call this only in special cases, when you know that the credentials
// object is being passed around will have to RefServer/RefDomain
// more than once as we are in the process of validating/finding
// the object as opposed to actually creating the adsi object.
// AjayR added on 6-24-98.
//
// Arguments:
//   [pszServer]                        - server to deref
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::DeRefServer()
{
    HRESULT hr = S_OK;

    if (m_pCred && m_cRefAdded)
    {
        hr = m_pCred->deref();

        m_cRefAdded--;
    }
    RRETURN(hr);
}
//+---------------------------------------------------------------------------
//
// CWinNTCredentials::RefDomain
//
// Increments the credentials object's reference count, and if necessary,
//   attempts to connect to the server's "ADMIN$" resource.
//
// Arguments:
//   [pszDomain]                        - domain to establish credentials with
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::RefDomain(PWSTR pszDomain)
{
    HRESULT hr = S_OK;

    // Don't take the hit of WinNTGetCachedDCName if we have null creds.
    if (m_pCred)
    {
        WCHAR szDCName[MAX_PATH];

        ADsAssert(pszDomain && *pszDomain);

        hr = WinNTGetCachedDCName(pszDomain, szDCName, m_dwFlags);

        if (SUCCEEDED(hr))
            // +2 for the initial "\\"
            hr = RefServer(szDCName + 2);
    }
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials::DeRefDomain
//
// Call this only in special cases, when you know that the credentials
// object is being passed around will have to RefServer/RefDomain
// more than once as we are in the process of validating/finding
// the object as opposed to actually creating the adsi object.
// AjayR added on 6-24-98.
//
// Arguments:
//   [pszServer]                        - server to deref
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::DeRefDomain()
{
    HRESULT hr = S_OK;

    //
    // Call DeRefServer - since we just want to whack the ref
    //
    hr = DeRefServer();

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials::Ref
//
// Increments the credentials object's reference count, and if necessary,
//   attempts to connect to the server's "ADMIN$" resource.
//
// This takes both a server and a domain; since several objects are created
//   with both server and domain as arguments (which one is used depends on
//   what the object's ADs parent is), this is a commonly used bit of code.
//
// Arguments:
//   [pszServer]                        - server to bind to
//   [pszDomain]                        - domain of the PDC to bind to
//   [dwType]                           - WINNT_DOMAIN_ID or WINNT_COMPUTER_ID
//
// Returns:
//   S_OK               - if we bound to the server, or are already bound to
//                        the given server.
//   E_FAIL             - if this object is bound, and the specified server
//                        is not the same server as we are bound to.
//   E_OUTOFMEMORY      - if we run out of memory.
//   Other error codes resulting from WNetAddConnection2 and from
//     WinNTGetCachedDCName.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::Ref(PWSTR pszServer, PWSTR pszDomain, DWORD dwType)
{
    HRESULT hr = S_OK;

    ADsAssert(dwType == WINNT_DOMAIN_ID || dwType == WINNT_COMPUTER_ID);

    // Don't take the hit of WinNTGetCachedDCName if we have null creds.
    if (m_pCred)
    {
        if (dwType == WINNT_DOMAIN_ID)
            hr = RefDomain(pszDomain);
        else
            hr = RefServer(pszServer);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials::GetUserName
//
// Retrieves the username represented by this credentials object.
//
// Arguments:
//   [ppszUserName]                     - address of a PWSTR to receive a
//                                        pointer to the username.
// Returns:
//   S_OK               - on success
//   E_OUTOFMEMORY      - if we run out of memory.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::GetUserName(PWSTR *ppszUserName)
{
    HRESULT hr;

    if (!ppszUserName)
        RRETURN(E_ADS_BAD_PARAMETER);

    //
    // Based on the rest of the codes, if UserName & Password are both "",
    // no CCred is created & m_pCred = NULL. (See Constructor). Before we
    // can hit CCred::GetUserName and get back *ppszUserName=NULL with hr =
    // S_OK, we will have AV already. So need to check if m_pCred 1st.
    //

    if (m_pCred)
    {
        hr = m_pCred->GetUserName(ppszUserName);
    }
    else
    {
        *ppszUserName = NULL;
        hr = S_OK;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials::GetPassword
//
// Retrieves the password represented by this credentials object.
//
// Arguments:
//   [ppszPassword]                     - address of a PWSTR to receive a
//                                        pointer to the password.
// Returns:
//   S_OK               - on success
//   E_OUTOFMEMORY      - if we run out of memory.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTCredentials::GetPassword(PWSTR * ppszPassword)
{
    HRESULT hr;

    if (!ppszPassword)
        RRETURN(E_ADS_BAD_PARAMETER);

    //
    // Based on the rest of the codes, if UserName & Password are both "",
    // no CCred is created & m_pCred = NULL. (See Constructor). Before we
    // can hit CCred::GetUserName and get back *ppszPassword=NULL with hr =
    // S_OK, we will have AV already. So need to check if m_pCred 1st.
    //

    if (m_pCred)
    {
        hr = m_pCred->GetPassword(ppszPassword);
    }
    else
    {
        *ppszPassword = NULL;
        hr = S_OK;
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
// CWinNTCredentials::Bound
//
// Returns TRUE iff this object has a reference to a server.
//
//----------------------------------------------------------------------------
BOOL
CWinNTCredentials::Bound()
{
    RRETURN(m_cRefAdded != 0);
}

void
CWinNTCredentials::SetFlags(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
}

DWORD
CWinNTCredentials::GetFlags() const
{
    RRETURN(m_dwFlags);
}

void
CWinNTCredentials::SetUmiFlag(void)
{
    m_dwFlags |= ADS_AUTH_RESERVED;
}

void
CWinNTCredentials::ResetUmiFlag(void)
{
    m_dwFlags &= (~ADS_AUTH_RESERVED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\ccache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ccache.cxx
//
//  Contents:     Class Cache functionality for the NT Provider
//
//
//----------------------------------------------------------------------------
#include "winnt.hxx"

HRESULT
SetOctetPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    BYTE *pByte,
    DWORD dwLength,
    BOOL fExplicit
    )
{
    HRESULT hr;
    OctetString octString;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    octString.pByte = pByte;
    octString.dwSize = dwLength;

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&octString,
                    1,
                    NT_SYNTAX_ID_OCTETSTRING,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

HRESULT
SetLPTSTRPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszValue,
                    1,
                    NT_SYNTAX_ID_LPTSTR,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDWORDPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    DWORD  dwValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&dwValue,
                    1,
                    NT_SYNTAX_ID_DWORD,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDATE70PropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    DWORD  dwValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&dwValue,
                    1,
                    NT_SYNTAX_ID_DATE_1970,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}



HRESULT
SetDATEPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    DWORD  dwValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&dwValue,
                    1,
                    NT_SYNTAX_ID_DATE,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetBOOLPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    BOOL  fValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&fValue,
                    1,
                    NT_SYNTAX_ID_BOOL,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetSYSTEMTIMEPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    SYSTEMTIME stValue,
    BOOL fExplicit
    )
{
    HRESULT hr;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)&stValue,
                    1,
                    NT_SYNTAX_ID_SYSTEMTIME,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
SetDelimitedStringPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{
    HRESULT hr;
    DWORD dwNumValues = 0;

    LPWSTR pszString =  AllocADsStr(pszValue);

    if(!pszString){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    if(!pPropertyCache){
        BAIL_ON_FAILURE(hr = E_POINTER);
    }


    //
    // Find the size of the delimited String
    //

    if((dwNumValues = DelimitedStrSize(pszString, TEXT(',')))== 0){
        hr = E_FAIL;
        goto error;
    }

    

    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszString,
                    dwNumValues,
                    NT_SYNTAX_ID_DelimitedString,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    if(pszString){
        FreeADsStr(pszString); 
    }

    RRETURN(hr);
}

HRESULT
SetNulledStringPropertyInCache(
    CPropertyCache *pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR pszValue,
    BOOL fExplicit
    )
{

    HRESULT hr;
    DWORD dwNumValues = 0;

    if(!pPropertyCache){
        RRETURN(E_POINTER);
    }


    //
    // Find the size of the nulled String
    //

    if((dwNumValues = NulledStrSize(pszValue))== 0){
        hr = E_FAIL;
        goto error;
    }

    
    hr = pPropertyCache->unmarshallproperty(
                    pszProperty,
                    (LPBYTE)pszValue,
                    dwNumValues,
                    NT_SYNTAX_ID_NulledString,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);


}

HRESULT
GetOctetPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    OctetString *pOctet)
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    if (NULL == pOctet)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);

    hr = MarshallNTSynIdToNT(
                dwSyntaxId,
                pNTObject,
                dwNumValues,
                (LPBYTE)pOctet
                );
    BAIL_ON_FAILURE(hr);


error:

    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }

    RRETURN (hr);
}

HRESULT
GetLPTSTRPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    if (NULL == ppszValue)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);

    hr = MarshallNTSynIdToNT(
                dwSyntaxId,
                pNTObject,
                dwNumValues,
                (LPBYTE)ppszValue
                );
    BAIL_ON_FAILURE(hr);


error:

    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }

    RRETURN (hr);
}

HRESULT
GetDelimitedStringPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    if (NULL == ppszValue)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);


    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)ppszValue
                    );
    }


error:

    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }



    RRETURN (hr);
}


HRESULT
GetNulledStringPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPTSTR * ppszValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    if (NULL == ppszValue)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);


    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)ppszValue
                    );
    }


error:


    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }

    RRETURN (hr);
}

HRESULT
GetBOOLPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    PBOOL pBool
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    if (NULL == pBool)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);


    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)pBool
                    );
    }


error:

    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }

    RRETURN (hr);
}


HRESULT
GetDWORDPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPDWORD pdwDWORD
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    if (NULL == pdwDWORD)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);


    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)pdwDWORD
                    );
    }


error:


    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }

    RRETURN (hr);
}


HRESULT
GetDATE70PropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    LPDWORD pdwDWORD
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    if (NULL == pdwDWORD)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);


    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)pdwDWORD
                    );
    }


error:

    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }



    RRETURN (hr);
}

HRESULT
GetDATEPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    PDWORD pdwDate
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    if (NULL == pdwDate)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);


    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)pdwDate
                    );
    }


error:


    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }



    RRETURN (hr);
}

HRESULT
GetSYSTEMTIMEPropertyFromCache(
    CPropertyCache * pPropertyCache,
    LPTSTR pszProperty,
    SYSTEMTIME * pstTime
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    if (NULL == pstTime)
        BAIL_ON_FAILURE(hr = E_POINTER);

    hr = pPropertyCache->marshallgetproperty(
                              pszProperty,
                              &dwSyntaxId,
                              &dwNumValues,
                              &pNTObject
                              );
    BAIL_ON_FAILURE(hr);

    if(SUCCEEDED(hr)){

        hr = MarshallNTSynIdToNT(
                    dwSyntaxId,
                    pNTObject,
                    dwNumValues,
                    (LPBYTE)pstTime
                    );
    }

error:

    if (pNTObject) {

        NTTypeFreeNTObjects(
            pNTObject,
            dwNumValues
            );
    }


    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//      multiple IDispatch-callable interfaces.
//
//  Classes:    CAggregatorDispMgr
//
//  Functions:  None external.
//
//  History:    ??-???-??   KrishnaG   created
//      07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//


#include "winnt.hxx"
#pragma hdrstop


//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include ".\cdispmgr.hxx"
#include "iprops.hxx"

#endif  // ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    End Non-ADSI compile stuff

//
// Error recovery.
//

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:    Simplified from Win4AssertEx, to make this dispatch manager
//          not depend on other files.
//
//----------------------------------------------------------------------------
static void
AggregatorAssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[199];
    DWORD dwCount = strlen("File: %s line %u, thread id %d");

    if (szFile) {
        dwCount += strlen(szFile);
    }

    dwCount += 15; // for the line number and thread id

    if (dwCount > 199) {
        sprintf(szAssertCaption, "Error, could not get more infomration");
    } 
    else {
        sprintf(szAssertCaption, "File: %s line %u, thread id %d",
                szFile, iLine, GetCurrentThreadId());
    }

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
        DebugBreak();
    }
}
# define AggregatorDispMgrAssert(x)  (void)((x) || (AggregatorAssertEx(__FILE__, __LINE__, #x),0))
#else
# define AggregatorAssertEx(f,l,m)
# define AggregatorDispMgrAssert(x)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(LONG TypeInfoId, LONG DispId, DISPID *pResult)
{
    if (DispId == DISPID_UNKNOWN)
    *pResult = DispId;
    else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
    DispId < 0 || DispId >= 0x10000)
    {
    //
    // Might happen if some object has very large dispid's.
    // But we can't handle it if it does.
    //
    *pResult = DISPID_UNKNOWN;
    }
    else
    *pResult = ((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

}

static inline void
IncDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
    if (rgdispid[i] == DISPID_UNKNOWN)
        continue;

    //
    // This is either a stack of DispMgrs >127 high, or
    // a programming error.  More likely the latter.
    //
    AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) < 0x7f);

    rgdispid[i] =
        (rgdispid[i] & 0x00ffffff) |
        (((getDispMgrId(rgdispid[i]) + 1) & 0x7f) << 24);
    }
}

static inline void
DecDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
    //
    // It should never be less than zero, and the only place
    // this is called from guarantees it is not zero.
    //
    AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) > 0);

    rgdispid[i] =
        (rgdispid[i] & 0x00ffffff) |
        (((getDispMgrId(rgdispid[i]) - 1) & 0x7f) << 24);
    }
}

static inline void
MakeDISPIDs(LONG TypeInfoId, DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//
// Struct definition
//
typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


PTYPEINFO_TABLE gpTypeInfoTable = NULL;

CRITICAL_SECTION g_TypeInfoCritSect;

#define ENTER_TYPEINFO_CRITSECT()  EnterCriticalSection(&g_TypeInfoCritSect)
#define LEAVE_TYPEINFO_CRITSECT()  LeaveCriticalSection(&g_TypeInfoCritSect)

LONG glnObjCount = 0;
LONG glnTypesOfInfo = 0;


//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregatorDispMgr::CAggregatorDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
}

CAggregatorDispMgr::~CAggregatorDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        InterlockedDecrement(&glnObjCount);

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

    ENTER_TYPEINFO_CRITSECT();

    if (glnObjCount == glnTypesOfInfo) {
        //
        // We need to clean up the list
        //
        FreeTypeInfoTable();

        glnObjCount = glnTypesOfInfo = 0;

    }
    LEAVE_TYPEINFO_CRITSECT();

}

void
CAggregatorDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregatorDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregatorDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregatorDispMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR *rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID *rgdispid
    )
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    if (!rgdispid)
    {
        hr = E_ADS_BAD_PARAMETER;
    }
    else
    {
        //
        // Try our list of TypeInfos.
        //
        pTypeInfo = _pTypeInfoEntry;
        while (pTypeInfo) {
            hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                    rgszNames,
                                    cNames,
                                    rgdispid
                                    );
            if (SUCCEEDED(hr)) {
                MakeDISPIDs(pTypeInfo->TypeInfoId, rgdispid, cNames);
                return hr;
            }
            pTypeInfo = pTypeInfo->pNext;
        }

        //
        // Try our property cache.
        //
        if (FAILED(hr) && _pPropertyCache) {
            hr = S_OK;
            for (DWORD dw = 0; dw < cNames; dw++) {
                if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
                    (PDWORD)(rgdispid + dw)))) {
                        hr = DISP_E_UNKNOWNNAME;
                        rgdispid[dw] = DISPID_UNKNOWN;
                }
            }
            if (SUCCEEDED(hr)) {
                MakeDISPIDs(_dwPropCacheID, rgdispid, cNames);
            }
        }
    }

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregatorDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregatorDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregatorDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr = S_OK;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

error:

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::TypeInfoInvoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
    EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

        //
        // One of the special DISPIDs.
        //
        // If we have an interface pointer for it, use that.
        // If we don't, and we have a base IDispatch pointer,
        //   pass it to the base pointer's Invoke() method.
        // If we don't, and we don't have a base IDispatch pointer,
        //   return failure.
        //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
        break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

        if (!pInterfacePtr) {

            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

        }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                              
        // A regular DISPID of ours.
        //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
            pInterfacePtr = getInterfacePtr(typeinfoid);
            pTypeInfo = getTypeInfo(typeinfoid);
            if (!pTypeInfo)
                //
            // Shouldn't happen.
            //
            BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
        }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = DynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

error:
    return hr;
}


HRESULT
DynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

error:
    return(hr);

}


HRESULT
CAggregatorDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregatorDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregatorDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    AggregatorDispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

ITypeInfo *
FindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
LoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    AggregatorDispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (!SUCCEEDED(hr))
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregatorDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    ENTER_TYPEINFO_CRITSECT();
    pTypeInfo = ::FindTypeInfo(gpTypeInfoTable, iid);

    if (!pTypeInfo) {

        LEAVE_TYPEINFO_CRITSECT();

        hr = LoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        ENTER_TYPEINFO_CRITSECT();

        gpTypeInfoTable = ::AddTypeInfo(
                                gpTypeInfoTable,
                                iid,
                                pTypeInfo
                                );
        if (!gpTypeInfoTable) {
            LEAVE_TYPEINFO_CRITSECT();
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        // Increment the global list of the types of type info's.
        //
        InterlockedIncrement(&glnTypesOfInfo);

        InterlockedIncrement(&glnObjCount);

    }
    pTypeInfo->AddRef();


    hr = AddTypeInfo(pTypeInfo, pIntf);

    if (FAILED(hr)) {
        LEAVE_TYPEINFO_CRITSECT();
        BAIL_ON_FAILURE(hr);
    }

    //
    // We have a ref on the object as add was succesful
    //
    InterlockedIncrement(&glnObjCount);

    LEAVE_TYPEINFO_CRITSECT();

    if (SpecialId == -4) {
        hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
        hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

error:
    if (pTypeInfo)
        pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregatorDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
FreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }

    gpTypeInfoTable = NULL;
}

BOOL
AggregatorDllCanUnload()
{
    BOOL retVal = FALSE;

    ENTER_TYPEINFO_CRITSECT();
    retVal = (glnTypesOfInfo == 0);
    LEAVE_TYPEINFO_CRITSECT();

    return retVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cdomain.cxx ===
//---------------------------------------------------------------------------
//
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomain.cxx
//
//  Contents:  Windows NT 3.5
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

DECLARE_INFOLEVEL( Domain );
DECLARE_DEBUG( Domain );
#define DomainDebugOut(x) DomainInlineDebugOut x

//  Class CWinNTDomain

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTDomain)
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTDomain)
DEFINE_IADs_TempImplementation(CWinNTDomain)
DEFINE_IADs_PutGetImplementation(CWinNTDomain, DomainClass, gdwDomainTableSize)
DEFINE_IADsPropertyList_Implementation(CWinNTDomain, DomainClass, gdwDomainTableSize)

HRESULT
MoveUserGroupObject(
    THIS_ BSTR SourceName,
    BSTR NewName,
    BSTR bstrParentADsPath,
    CWinNTCredentials& Credentials,
    IDispatch * FAR* ppObject
    );

CWinNTDomain::CWinNTDomain() :
                _pDispMgr(NULL),
                _pExtMgr(NULL),
                _pPropertyCache(NULL)
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CWinNTDomain);
}

HRESULT
CWinNTDomain::CreateDomain(
    BSTR Parent,
    BSTR DomainName,
    DWORD dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTDomain FAR * pDomain = NULL;
    NET_API_STATUS nasStatus;
    HRESULT hr = S_OK;


    hr = AllocateDomainObject(&pDomain);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pDomain->_pDispMgr);


    hr = pDomain->InitializeCoreObject(
                Parent,
                DomainName,
                DOMAIN_CLASS_NAME,
                DOMAIN_SCHEMA_NAME,
                CLSID_WinNTDomain,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    pDomain->_Credentials = Credentials;
    hr = pDomain->_Credentials.RefDomain(DomainName);
    BAIL_ON_FAILURE(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                DOMAIN_CLASS_NAME,
                (IADsDomain *) pDomain,
                pDomain->_pDispMgr,
                Credentials,
                &pDomain->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pDomain->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(1 == pDomain->_dwNumComponents)
            pDomain->_CompClasses[0] = L"Domain";
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pDomain->InitUmiObject(
                    pDomain->_Credentials,
                    DomainClass, 
                    gdwDomainTableSize,
                    pDomain->_pPropertyCache,
                    (IUnknown *) (INonDelegatingUnknown *) pDomain,
                    pDomain->_pExtMgr,
                    IID_IUnknown,
                    ppvObj
                    );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pDomain->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pDomain->Release();

    RRETURN(hr);

error:

    delete pDomain;
    RRETURN_EXP_IF_ERR(hr);
}

CWinNTDomain::~CWinNTDomain( )
{
    VariantClear(&_vFilter);

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTDomain::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTDomain::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTDomain::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTDomain::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsDomain FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsDomain))
    {
        *ppv = (IADsDomain FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(iid, ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTDomain::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsPropertyList) ||
        IsEqualIID(riid, IID_IADsDomain)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}
STDMETHODIMP
CWinNTDomain::SetInfo(THIS)
{
    HRESULT hr;

    hr = SetInfo(0);

    hr = SetInfo(2);

    hr = SetInfo(3);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTDomain::GetInfo(THIS)
{
    HRESULT hr;

    _pPropertyCache->flushpropcache();

    hr = GetInfo(0, TRUE);

    hr = GetInfo(2, TRUE);

    hr = GetInfo(3, TRUE);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTDomain::ImplicitGetInfo(THIS)
{
    HRESULT hr;

    hr = GetInfo(0, FALSE);

    hr = GetInfo(2, FALSE);

    hr = GetInfo(3, FALSE);

    RRETURN_EXP_IF_ERR(hr);
}

/* IADsContainer methods */

STDMETHODIMP
CWinNTDomain::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTDomain::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTDomain::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTDomain::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CWinNTDomain::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTDomain::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{

    WCHAR szBuffer[MAX_PATH];
    DWORD dwLength = 0;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    //
    // Verify that the lenght of the string will not cause overflow.
    // +2 for / and \0
    //
    dwLength = wcslen(_ADsPath) + wcslen(RelativeName) + 2;
    if (dwLength > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName) {
        //
        // +1 for the ",".
        //
        dwLength += wcslen(ClassName) + 1;
        //
        // Check for buffer overflow again.
        //
        if (dwLength > MAX_PATH) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                (LPVOID *)ppObject,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTDomain::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CWinNTDomainEnum::Create(
                (CWinNTDomainEnum **)&penum,
                _ADsPath,
                _Name,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTDomain::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    ULONG ObjectType = 0;
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;

    hr = GetObjectType(
                gpFilters,
                gdwMaxFilters,
                ClassName,
                (PDWORD)&ObjectType
                );
    BAIL_ON_FAILURE(hr);


    switch (ObjectType) {

    case WINNT_USER_ID:

        hr = CWinNTUser::CreateUser(
                            _ADsPath,
                            WINNT_DOMAIN_ID,
                            _Name,
                            NULL,
                            RelativeName,
                            ADS_OBJECT_UNBOUND,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppObject
                            );
        break;

    case WINNT_GROUP_ID:
        hr = CWinNTGroup::CreateGroup(
                            _ADsPath,
                            WINNT_DOMAIN_ID,
                            _Name,
                            NULL,
                            RelativeName,
                            WINNT_GROUP_GLOBAL,
                            ADS_OBJECT_UNBOUND,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppObject
                            );
        break;

    case WINNT_COMPUTER_ID:
        hr = CWinNTComputer::CreateComputer(
                            _ADsPath,
                            _Name,
                            RelativeName,
                            ADS_OBJECT_UNBOUND,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppObject
                            );
        break;

    default:

        hr = E_ADS_UNKNOWN_OBJECT;
        break;
    }

    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTDomain::Delete(
    BSTR bstrClassName,
    BSTR bstrSourceName
    )
{
    ULONG ObjectType = 0;
    POBJECTINFO pObjectInfo = NULL;
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;
    WCHAR szUncServerName[MAX_PATH];


    // Make sure input parameters are valid
    if (bstrClassName == NULL || bstrSourceName == NULL) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }


    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       bstrClassName,
                       (PDWORD)&ObjectType
                       );

    BAIL_ON_FAILURE(hr);


    hr = BuildObjectInfo(
                         _ADsPath,
                         bstrSourceName,
                         &pObjectInfo
                         );

    BAIL_ON_FAILURE(hr);


    switch (ObjectType) {

    case WINNT_USER_ID:

        hr = WinNTDeleteUser(pObjectInfo, _Credentials);
        break;

    case WINNT_GROUP_ID:

        //
        // for backward compatablity: allow user to delete by classname "group"
        //

        hr = WinNTDeleteGroup(pObjectInfo, WINNT_GROUP_EITHER, _Credentials);
        break;

    //
    // Global Group and LocalGroup ID's will now goto default
    //

    case WINNT_COMPUTER_ID:

        hr = WinNTDeleteComputer(pObjectInfo, _Credentials);
        break;

    default:

        hr = E_ADS_UNKNOWN_OBJECT;
        break;
    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }
    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CWinNTDomain::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTDomain::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    return MoveUserGroupObject(SourceName,
                               NewName,
                               _ADsPath,
                               _Credentials,
                               ppObject);
}

/* IADsDomain methods */

STDMETHODIMP
CWinNTDomain::get_IsWorkgroup(THIS_ VARIANT_BOOL FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CWinNTDomain::AllocateDomainObject(
    CWinNTDomain ** ppDomain
    )
{
    CWinNTDomain FAR * pDomain = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pDomain = new CWinNTDomain();
    if (pDomain == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);


    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsDomain,
                (IADsDomain *)pDomain,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsContainer,
                (IADsContainer *)pDomain,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);


    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pDomain,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);


    hr = CPropertyCache::createpropertycache(
             DomainClass,
             gdwDomainTableSize,
             (CCoreADsObject *)pDomain,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);


    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );


    pDomain->_pPropertyCache = pPropertyCache;
    pDomain->_pDispMgr = pDispMgr;
    *ppDomain = pDomain;

    RRETURN(hr);

error:

    delete  pPropertyCache;
    delete  pDispMgr;
    delete  pDomain;

    RRETURN(hr);

}


STDMETHODIMP
CWinNTDomain::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    NET_API_STATUS nasStatus;
    LPBYTE lpBuffer = NULL;
    HRESULT hr;
    WCHAR szPDCName[MAX_PATH];

    hr = WinNTGetCachedDCName(
                _Name,
                szPDCName,
                _Credentials.GetFlags()
                );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetUserModalsGet(
                    szPDCName,
                    dwApiLevel,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    hr = UnMarshall(lpBuffer, dwApiLevel, fExplicit);
    BAIL_ON_FAILURE(hr);

error:
    if (lpBuffer) {
        NetApiBufferFree(lpBuffer);
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTDomain::UnMarshall(
    LPBYTE lpBuffer,
    DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    HRESULT hr;

    ADsAssert(lpBuffer);
    switch (dwApiLevel) {
    case 0:
        hr = UnMarshall_Level0(fExplicit, (LPUSER_MODALS_INFO_0)lpBuffer);
        break;

    case 2:
        hr = UnMarshall_Level2(fExplicit, (LPUSER_MODALS_INFO_2)lpBuffer);
        break;


    case 3:
        hr = UnMarshall_Level3(fExplicit, (LPUSER_MODALS_INFO_3)lpBuffer);
        break;

    default:
        hr = E_FAIL;

    }
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CWinNTDomain::UnMarshall_Level0(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_0 pUserInfo0
    )
{

    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MinPasswordLength"),
                pUserInfo0->usrmod0_min_passwd_len,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MaxPasswordAge"),
                pUserInfo0->usrmod0_max_passwd_age,
                fExplicit
                );


    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MinPasswordAge"),
                pUserInfo0->usrmod0_min_passwd_age,
                fExplicit
                );


    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PasswordHistoryLength"),
                pUserInfo0->usrmod0_password_hist_len,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CWinNTDomain::UnMarshall_Level2(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_2 pUserInfo2
    )
{
    RRETURN(S_OK);
}


HRESULT
CWinNTDomain::UnMarshall_Level3(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_3 pUserInfo3
    )
{
    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("AutoUnlockInterval"),
                pUserInfo3->usrmod3_lockout_duration,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("LockoutObservationInterval"),
                pUserInfo3->usrmod3_lockout_observation_window,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MaxBadPasswordsAllowed"),
                pUserInfo3->usrmod3_lockout_threshold,
                fExplicit
                );

    RRETURN_EXP_IF_ERR(S_OK);
}

STDMETHODIMP
CWinNTDomain::SetInfo(THIS_ DWORD dwApiLevel)
{
    NET_API_STATUS nasStatus;
    HRESULT hr;
    LPBYTE lpBuffer = NULL;
    DWORD dwParamErr = 0;
    WCHAR szPDCName[MAX_PATH];


    hr = WinNTGetCachedDCName(
                    _Name,
                    szPDCName,
                    _Credentials.GetFlags()
                    );
    BAIL_ON_FAILURE(hr);


    nasStatus = NetUserModalsGet(
                    szPDCName,
                    dwApiLevel,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);



     hr = MarshallAndSet(szPDCName, lpBuffer, dwApiLevel);
     BAIL_ON_FAILURE(hr);

error:

     if (lpBuffer) {
         NetApiBufferFree(lpBuffer);
     }

     RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTDomain::MarshallAndSet(
    LPWSTR szServerName,
    LPBYTE lpBuffer,
    DWORD  dwApiLevel
    )
{
    ADsAssert(lpBuffer);
    switch (dwApiLevel) {
    case 0:
        RRETURN(Marshall_Set_Level0(
                    szServerName,
                    (LPUSER_MODALS_INFO_0)lpBuffer
                    ));
        break;

    case 2:
        RRETURN(Marshall_Set_Level2(
                    szServerName,
                    (LPUSER_MODALS_INFO_2)lpBuffer
                    ));
        break;


    case 3:
        RRETURN(Marshall_Set_Level3(
                    szServerName,
                    (LPUSER_MODALS_INFO_3)lpBuffer
                    ));
        break;

    default:
        RRETURN(E_FAIL);

    }
}



HRESULT
CWinNTDomain::Marshall_Set_Level0(
    LPWSTR szServerName,
    LPUSER_MODALS_INFO_0 pUserInfo0)
{
    NET_API_STATUS nasStatus;
    DWORD dwParamErr = 0;
    HRESULT hr = S_OK;

    DWORD dwMinPasswdLen = 0;
    DWORD dwMaxPasswdAge = 0;
    DWORD dwMinPasswdAge = 0;
    DWORD dwPasswdHistLen = 0;

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MinPasswordLength"),
                    &dwMinPasswdLen
                    );

    if (SUCCEEDED(hr)) {

        pUserInfo0->usrmod0_min_passwd_len = dwMinPasswdLen;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MaxPasswordAge"),
                    &dwMaxPasswdAge
                    );

    if (SUCCEEDED(hr)) {
        pUserInfo0->usrmod0_max_passwd_age = dwMaxPasswdAge;
    }


    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MinPasswordAge"),
                    &dwMinPasswdAge
                    );

    if (SUCCEEDED(hr)) {
        pUserInfo0->usrmod0_min_passwd_age = dwMinPasswdAge;
    }


    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PasswordHistoryLength"),
                    &dwPasswdHistLen
                    );

    if (SUCCEEDED(hr)) {

        pUserInfo0->usrmod0_password_hist_len = dwPasswdHistLen;
    }

    //
    // Now Set this Data. Remember that the property store
    // returns to us data in its own format. It is the caller's
    // responsibility to free all buffers for bstrs, variants
    // etc
    //

     nasStatus = NetUserModalsSet(
                     szServerName,
                     0,
                     (LPBYTE)pUserInfo0,
                     &dwParamErr
                     );
     hr = HRESULT_FROM_WIN32(nasStatus);
     BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}


HRESULT
CWinNTDomain::Marshall_Set_Level2(
    LPWSTR szServerName,
    LPUSER_MODALS_INFO_2 pUserInfo2
    )
{
    RRETURN(S_OK);
}


HRESULT
CWinNTDomain::Marshall_Set_Level3(
    LPWSTR szServerName,
    LPUSER_MODALS_INFO_3 pUserInfo3
    )
{
    NET_API_STATUS nasStatus;
    HRESULT hr;
    DWORD dwParamErr =  0;

    DWORD dwAutoUnlockIntrvl = 0;
    DWORD dwLockoutObsIntrvl = 0;
    DWORD dwMaxBadPasswdsAllowed = 0;

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("AutoUnlockInterval"),
                    &dwAutoUnlockIntrvl
                    );

    if (SUCCEEDED(hr)) {
        pUserInfo3->usrmod3_lockout_duration = dwAutoUnlockIntrvl;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("LockoutObservationInterval"),
                    &dwLockoutObsIntrvl
                    );

    if (SUCCEEDED(hr)) {
        pUserInfo3->usrmod3_lockout_observation_window  = dwLockoutObsIntrvl;
    }


    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MaxBadPasswordsAllowed"),
                    &dwMaxBadPasswdsAllowed
                    );


    if (SUCCEEDED(hr)) {
        pUserInfo3->usrmod3_lockout_threshold = dwMaxBadPasswdsAllowed;
    }


    //
    // Now Set this Data. Remember that the property store
    // returns to us data in its own format. It is the caller's
    // responsibility to free all buffers for bstrs, variants
    // etc
    //

     nasStatus = NetUserModalsSet(
                     szServerName,
                     3,
                     (LPBYTE)pUserInfo3,
                     &dwParamErr
                     );
     hr = HRESULT_FROM_WIN32(nasStatus);
     BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cdompwd.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdompwd.cxx
//
//  Contents:  Domain Password PropertySet
//
//  History:   11-1-95     krishnag    Created.
//
//             PROPERTY_RW(MinPasswordLength, long, 1)          I
//             PROPERTY_RW(MinPasswordAge, long, 2)             I
//             PROPERTY_RW(MaxPasswordAge, long, 3)             I
//             PROPERTY_RW(MaxBadPasswordsAllowed, long, 4)     I
//             PROPERTY_RW(PasswordHistoryLength, long, 5)      I
//             PROPERTY_RW(PasswordAttributes, long, 6)         NI
//             PROPERTY_RW(AutoUnlockInterval, long, 7)           NI
//             PROPERTY_RW(LockoutObservationInterval, long, 8) NI
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//  Class CWinNTDomain

/* IADsDomain methods */

STDMETHODIMP
CWinNTDomain::get_MinPasswordLength(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, MinPasswordLength);
}
STDMETHODIMP
CWinNTDomain::put_MinPasswordLength(THIS_ long lMinPasswordLength)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, MinPasswordLength);
}

STDMETHODIMP
CWinNTDomain::get_MinPasswordAge(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, MinPasswordAge);
}

STDMETHODIMP CWinNTDomain::put_MinPasswordAge(THIS_ long lMinPasswordAge)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, MinPasswordAge);
}

STDMETHODIMP CWinNTDomain::get_MaxPasswordAge(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, MaxPasswordAge);
}

STDMETHODIMP CWinNTDomain::put_MaxPasswordAge(THIS_ long lMaxPasswordAge)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, MaxPasswordAge);
}

STDMETHODIMP CWinNTDomain::get_MaxBadPasswordsAllowed(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, MaxBadPasswordsAllowed);

}
STDMETHODIMP CWinNTDomain::put_MaxBadPasswordsAllowed(THIS_ long lMaxBadPasswordsAllowed)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, MaxBadPasswordsAllowed);

}
STDMETHODIMP CWinNTDomain::get_PasswordHistoryLength(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, PasswordHistoryLength);

}

STDMETHODIMP CWinNTDomain::put_PasswordHistoryLength(THIS_ long lPasswordHistoryLength)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, PasswordHistoryLength);

}

STDMETHODIMP CWinNTDomain::get_PasswordAttributes(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, PasswordAttributes);
}

STDMETHODIMP CWinNTDomain::put_PasswordAttributes(THIS_ long lPasswordAttributes)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, PasswordAttributes);
}

STDMETHODIMP CWinNTDomain::get_AutoUnlockInterval(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, AutoUnlockInterval);
}

STDMETHODIMP CWinNTDomain::put_AutoUnlockInterval(THIS_ long lAutoUnlockInterval)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, AutoUnlockInterval);
}

STDMETHODIMP CWinNTDomain::get_LockoutObservationInterval(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsDomain *)this, LockoutObservationInterval);
}

STDMETHODIMP CWinNTDomain::put_LockoutObservationInterval(THIS_ long lLockoutObservationInterval)
{
    PUT_PROPERTY_LONG((IADsDomain *)this, LockoutObservationInterval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenmfpre.cxx ===
/*++

  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  cenmfpre.cxx

  Abstract:

  Contains methods for implementing the Enumeration of resources(open files)
  on a  server. Has methods for the CFPNWResourcesCollection object
  as well as the CFPNWResourcesEnumVar object.

  Author:

  Ram Viswanathan (ramv) 03/12/96

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop


CFPNWResourcesCollection::CFPNWResourcesCollection()
{
    _pszServerADsPath = NULL;
    _pszServerName = NULL;
    _pszBasePath = NULL;
    _pszUserName = NULL;

    _pDispMgr = NULL;
    _pCResourcesEnumVar = NULL;
    ENLIST_TRACKING(CFPNWResourcesCollection);
}

CFPNWResourcesCollection::~CFPNWResourcesCollection()
{
    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszBasePath){
        FreeADsStr(_pszBasePath);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }
    delete _pDispMgr;
    if(_pCResourcesEnumVar){
        _pCResourcesEnumVar->Release();
    }

}

HRESULT
CFPNWResourcesCollection::Create(LPTSTR pszServerADsPath,
                                 LPTSTR pszBasePath,
                                 CWinNTCredentials& Credentials,
                                 CFPNWResourcesCollection
                                 ** ppCFPNWResourcesCollection 
                                 )
{

    BOOL fStatus = FALSE, LastError;
    HRESULT hr;
    CFPNWResourcesCollection *pCFPNWResourcesCollection = NULL;
    POBJECTINFO pServerObjectInfo = NULL;
    //
    // create the Resources collection object
    //

    pCFPNWResourcesCollection = new CFPNWResourcesCollection();

    if(pCFPNWResourcesCollection == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    pCFPNWResourcesCollection->_pszServerADsPath = 
        AllocADsStr(pszServerADsPath);

    if(!pCFPNWResourcesCollection->_pszServerADsPath){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo
                         );

    BAIL_IF_ERROR(hr);


    pCFPNWResourcesCollection->_pszServerName = 
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!pCFPNWResourcesCollection->_pszServerName){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCFPNWResourcesCollection->_Credentials = Credentials;
    hr = pCFPNWResourcesCollection->_Credentials.RefServer(
        pCFPNWResourcesCollection->_pszServerName);
    BAIL_IF_ERROR(hr);

    if(pszBasePath){

        pCFPNWResourcesCollection->_pszBasePath = 
            AllocADsStr(pszBasePath);
        
        if(!pCFPNWResourcesCollection->_pszBasePath){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }


    }

    pCFPNWResourcesCollection->_pDispMgr = new CAggregatorDispMgr;
    if (pCFPNWResourcesCollection->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = LoadTypeInfoEntry(pCFPNWResourcesCollection->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsCollection,
                           (IADsCollection *)pCFPNWResourcesCollection,
                           DISPID_NEWENUM);

    BAIL_IF_ERROR(hr);

    hr = CFPNWResourcesEnumVar::Create(pszServerADsPath,
                                       pszBasePath,
                                       pCFPNWResourcesCollection->_Credentials,
                                       &pCFPNWResourcesCollection->_pCResourcesEnumVar);

    BAIL_IF_ERROR(hr);

    *ppCFPNWResourcesCollection =pCFPNWResourcesCollection;

cleanup:

    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }
    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }
    delete pCFPNWResourcesCollection;
    RRETURN_EXP_IF_ERR(hr);

}

/* IUnknown methods for Resources collection object  */

STDMETHODIMP
CFPNWResourcesCollection::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch *)this;
    }
    
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsCollection))
    {
        *ppvObj = (IADsCollection FAR *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CFPNWResourcesCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsCollection)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

DEFINE_IDispatch_Implementation(CFPNWResourcesCollection);

/* IADsCollection methods */

STDMETHODIMP
CFPNWResourcesCollection::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    CFPNWResourcesEnumVar *pCResourcesEnumVar = NULL;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = NULL;

    ADsAssert(_pCResourcesEnumVar);

    hr = _pCResourcesEnumVar->QueryInterface(IID_IUnknown, (void **)retval);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWResourcesCollection::GetObject(THIS_ BSTR bstrResourceName,
                                     VARIANT *pvar
                                     ) 

{

    // 
    // scan the buffer _pbSessions to find one where the ConnectionId
    // matches the one in bstrSessionName and get this object
    //

    HRESULT hr;

    hr = _pCResourcesEnumVar->GetObject(bstrResourceName, pvar);

    RRETURN_EXP_IF_ERR(hr);
                                      
/*
    HRESULT hr = S_OK;
    DWORD   dwFileId;
    IDispatch *pDispatch = NULL;
 
    if(!bstrResourceName || !pvar){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    //
    // convert the job name into a fileid
    //

    dwFileId = (DWORD)_wtol(bstrResourceName);

    hr = CFPNWResource::Create((LPTSTR)_bstrServerADsPath,
                                ADS_OBJECT_BOUND,
                                dwFileId,
                                IID_IDispatch,
                                _Credentials,
                                (void **)&pDispatch);

    BAIL_IF_ERROR(hr);

    //
    // stick this IDispatch pointer into caller provided variant
    //
    
    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;

cleanup:
    RRETURN_EXP_IF_ERR(hr);

*/

}


STDMETHODIMP 
CFPNWResourcesCollection::Add(THIS_ BSTR bstrName, VARIANT varNewItem) 

{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP
CFPNWResourcesCollection::Remove(THIS_ BSTR bstrResourceName) 

{
    
    RRETURN_EXP_IF_ERR(E_NOTIMPL);    
}


//
// CFPNWResourcesEnumVar methods follow
//

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWResourcesEnumVar::CFPNWResourcesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CFPNWResourcesEnumVar::CFPNWResourcesEnumVar()
{
    _pszServerADsPath = NULL;
    _pszServerName = NULL;
    _pszBasePath = NULL;
    _pszUserName = NULL;
    _pbResources = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;
    _dwTotalEntries = 0;
    _dwResumeHandle = 0;

}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWResourcesEnumVar::~CFPNWResourcesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CFPNWResourcesEnumVar::~CFPNWResourcesEnumVar()
{

    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszBasePath){
        FreeADsStr(_pszBasePath);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }

    if(_pbResources){
        NetApiBufferFree(_pbResources);
    }
}


HRESULT CFPNWResourcesEnumVar::Create(LPTSTR pszServerADsPath,
                                       LPTSTR pszBasePath,
                                       CWinNTCredentials& Credentials,
                                       CFPNWResourcesEnumVar
                                       **ppCResourcesEnumVar)
{

    HRESULT hr;
    BOOL fStatus = FALSE;
    POBJECTINFO  pServerObjectInfo = NULL;
    CFPNWResourcesEnumVar FAR* pCResourcesEnumVar = NULL;

    *ppCResourcesEnumVar = NULL;

    pCResourcesEnumVar = new CFPNWResourcesEnumVar();

    if (pCResourcesEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCResourcesEnumVar->_pszServerADsPath = 
        AllocADsStr(pszServerADsPath);

    if(!pCResourcesEnumVar->_pszServerADsPath){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo);
    BAIL_IF_ERROR(hr);


    pCResourcesEnumVar->_pszServerName = 
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!pCResourcesEnumVar->_pszServerName){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCResourcesEnumVar->_Credentials = Credentials;
    hr = pCResourcesEnumVar->_Credentials.RefServer(
        pCResourcesEnumVar->_pszServerName);
    BAIL_IF_ERROR(hr);

 
    if(pszBasePath){

        pCResourcesEnumVar->_pszBasePath = 
            AllocADsStr(pszBasePath);
        
        if(!pCResourcesEnumVar->_pszBasePath){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

    }

    *ppCResourcesEnumVar = pCResourcesEnumVar;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCResourcesEnumVar;
    RRETURN_EXP_IF_ERR(hr);


}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWResourcesEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Resource objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWResourcesEnumVar::Next(ULONG ulNumElementsRequested,
                             VARIANT FAR* pvar,
                             ULONG FAR* pulNumFetched)
{

    HRESULT hresult;
    ULONG l;
    LONG lNewCurrent;
    ULONG lNumFetched;
    PNWFILEINFO pFileInfo;
    VARIANT v;
    IDispatch * pDispatch = NULL;

    if (pulNumFetched != NULL){
        *pulNumFetched = 0;
    }

    //
    // Check the out parameter to ensure it is valid
    //
    if (!pvar)
        RRETURN(S_FALSE);

    //
    // Initialize the elements to be returned
    //

    for (l=0; l<ulNumElementsRequested; l++){
        VariantInit(&pvar[l]);
    }

    if(!_pbResources || (_lCurrentPosition == _lLBound +(LONG)_cElements) ){
        if (_pbResources){
            NetApiBufferFree(_pbResources);
            _pbResources = NULL;
        }

        hresult = FPNWEnumResources(_pszServerName,
                                    _pszBasePath,
                                    &_pbResources,
                                    &_cElements,
                                    &_dwResumeHandle);

        if(hresult == S_FALSE){
            RRETURN(S_FALSE);
        }
        _lLBound = 0;
        _lCurrentPosition = _lLBound;
    }

    //
    // Get each element and place it into the return array
    // Don't request more than we have
    //

    for (lNewCurrent=_lCurrentPosition, lNumFetched=0;
         lNewCurrent<(LONG)(_lLBound+_cElements) &&
         lNumFetched < ulNumElementsRequested;
         lNewCurrent++, lNumFetched++){

        pFileInfo = (PNWFILEINFO)(_pbResources + \
                                     lNewCurrent*sizeof(NWFILEINFO));


        hresult = CFPNWResource::Create(_pszServerADsPath,
                                        pFileInfo,
                                        ADS_OBJECT_BOUND,
                                        IID_IDispatch,
                                        _Credentials,
                                        (void **)&pDispatch);


        BAIL_ON_FAILURE(hresult);

        VariantInit(&v);
        V_VT(&v) = VT_DISPATCH;
        V_DISPATCH(&v) = pDispatch;
        pvar[lNumFetched] = v;

    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //

    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;

    _lCurrentPosition = lNewCurrent;

    //
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //

    return (lNumFetched < ulNumElementsRequested) ?
        S_FALSE
            : S_OK;

error:

    RRETURN(S_FALSE);
}


HRESULT
FPNWEnumResources(LPTSTR pszServerName,
                   LPTSTR pszBasePath,
                   LPBYTE * ppMem,
                   LPDWORD pdwEntriesRead,
                   LPDWORD pdwResumeHandle
                   )

{
    HRESULT hr;
    DWORD dwErrorCode;

    dwErrorCode = ADsNwFileEnum(pszServerName,
                                  1,
                                  pszBasePath,
                                  (PNWFILEINFO *) ppMem,
                                  pdwEntriesRead,
                                  pdwResumeHandle);

    if(*ppMem == NULL|| (dwErrorCode != NERR_Success)){
        //
        // no more entries returned by NwFileEnum
        //
        RRETURN(S_FALSE);
    }

    RRETURN(S_OK);

}

//
// helper function
//

HRESULT 
CFPNWResourcesEnumVar::GetObject(BSTR bstrResourceName, VARIANT *pvar)
{
    HRESULT hr = S_OK;
    DWORD dwFileId;
    PNWFILEINFO pFileInfo = NULL;
    IDispatch *pDispatch = NULL;
    DWORD i;

    if(!_pbResources){
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    // 
    // scan the buffer _pbResources to find one where the ConnectionId
    // matches the one in bstrResourceName and get this object
    //

    dwFileId = (DWORD)_wtol(bstrResourceName);

    for( i=0; i<_cElements; i++){
        pFileInfo = (PNWFILEINFO)(_pbResources+ i*sizeof(PNWFILEINFO));
        
        if(pFileInfo->dwFileId = dwFileId){
            //
            // return this struct in the static create for the object
            //
            hr = CFPNWResource::Create(_pszServerADsPath,
                                       pFileInfo,
                                       ADS_OBJECT_BOUND,
                                       IID_IDispatch,
                                       _Credentials,
                                       (void **) &pDispatch );
            
            BAIL_IF_ERROR(hr);
                                
            break;
        } 
    }

    if(i == _cElements){
        //
        // no such element
        //
        hr = E_ADS_UNKNOWN_OBJECT;
        goto cleanup;

    }        

    //
    // stick this IDispatch pointer into caller provided variant
    //
    
    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;
        
cleanup:
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenmlgrp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  Windows NT 3.5 GroupCollection Enumeration Code
//
//              CWinNTLocalGroupCollectionEnum::CWinNTLocalGroupCollectionEnum()
//              CWinNTLocalGroupCollectionEnum::CWinNTLocalGroupCollectionEnum
//              CWinNTLocalGroupCollectionEnum::EnumObjects
//              CWinNTLocalGroupCollectionEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTLocalGroupCollectionEnum::Create(
    CWinNTLocalGroupCollectionEnum FAR* FAR* ppenumvariant,
    BSTR Parent,
    ULONG ParentType,
    BSTR ADsPath,
    BSTR DomainName,
    BSTR ServerName,
    BSTR GroupName,
    ULONG GroupType,
    VARIANT var,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CWinNTLocalGroupCollectionEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CWinNTLocalGroupCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( Parent, &penumvariant->_Parent);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( DomainName, &penumvariant->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName, &penumvariant->_ServerName);
    BAIL_ON_FAILURE(hr);

    penumvariant->_ParentType = ParentType;

    hr = ADsAllocString(ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( GroupName, &penumvariant->_GroupName);
    BAIL_ON_FAILURE(hr);

    penumvariant->_GroupType = GroupType;


    hr = ObjectTypeList::CreateObjectTypeList(
                    var,
                    &penumvariant->_pObjList
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;
    hr = penumvariant->_Credentials.Ref(ServerName, DomainName, ParentType);
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CWinNTLocalGroupCollectionEnum::CWinNTLocalGroupCollectionEnum():
                                _Parent(NULL),
                                _ParentType(0),
                                _ADsPath(NULL),
                                _DomainName(NULL),
                                _ServerName(NULL),
                                _GroupName(NULL),
                                _lpServerName(NULL),
                                _hGroup(NULL)

{
    _pObjList = NULL;
}



CWinNTLocalGroupCollectionEnum::CWinNTLocalGroupCollectionEnum(ObjectTypeList ObjList):
                                _Parent(NULL),
                                _ParentType(0),
                                _ADsPath(NULL),
                                _DomainName(NULL),
                                _ServerName(NULL),
                                _GroupName(NULL),
                                _lpServerName(NULL),
                                _hGroup(NULL)
{
    _pObjList = NULL;
}

CWinNTLocalGroupCollectionEnum::~CWinNTLocalGroupCollectionEnum()
{

    if (_hGroup) {


        if (_GroupType == WINNT_GROUP_GLOBAL) {


            WinNTGlobalGroupClose(
                            _hGroup
                            );
        }else {

            WinNTLocalGroupClose(
                        _hGroup
                        );
        }

    }


    if (_pObjList) {

        delete _pObjList;
    }

    if (_lpServerName) {

        FreeADsStr(_lpServerName) ;
    }

    if(_Parent) {

    	ADsFreeString(_Parent);
    }

    if(_DomainName) {

    	ADsFreeString(_DomainName);
    }

    if(_ServerName) {

    	ADsFreeString(_ServerName);
    }

    if(_ADsPath) {

    	ADsFreeString(_ADsPath);
    }

    if(_GroupName) {

    	ADsFreeString(_GroupName);
    }
}

HRESULT
CWinNTLocalGroupCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    IADs * pIADs = NULL;
    BSTR pszClass = NULL;
    DWORD dwClassID;
    DWORD dwFilterID;
    BOOL fFound = FALSE;

    while (i < cElements) {

        hr = GetComputerMemberObject(&pDispatch);

        if (hr == S_FALSE) {
            break;
        }

        //
        // Apply the IADsMembers::put_Filter filter.
        // If the enumerated object is not one of the types to be returned,
        // go on to the next member of the group.
        //
        
        hr = pDispatch->QueryInterface(IID_IADs, (void **)&pIADs);
        BAIL_ON_FAILURE(hr);

        //
        // Determine the object class of the enumerated object and the corresponding
        // object class ID number (as specified in the Filters global array).
        //        
        hr = pIADs->get_Class(&pszClass);
        BAIL_ON_FAILURE(hr);

        hr = IsValidFilter(pszClass, &dwClassID, gpFilters, gdwMaxFilters);
        if (SUCCEEDED(hr)) {

            //
            // Enumerate through the object classes listed in the user-specified filter
            // until we either find a match (fFound = TRUE) or we reach the end of the
            // list.
            //
            hr = _pObjList->Reset();

            while (SUCCEEDED(hr)) {
                hr = _pObjList->GetCurrentObject(&dwFilterID);

                if (SUCCEEDED(hr)
                    && (dwFilterID == dwClassID)
                    ) {
                    fFound = TRUE;
                    break;
                }


                hr = _pObjList->Next();
            }

            if (!fFound) {
                // 
                // not on the list of objects to return, try again
                // with the next member of the group
                //
                pDispatch->Release();

                pIADs->Release();
                
                if (pszClass) {
                    ADsFreeString(pszClass);
                }
                
                continue;
            }

        }

        pIADs->Release();
        
        if (pszClass) {
            ADsFreeString(pszClass);
        }

        //
        // Return it.
        // 
        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN_EXP_IF_ERR(hr);

error:
    if (pDispatch) {
        pDispatch->Release();
    }

    if (pIADs) {
        pIADs->Release();
    }

    if (pszClass) {
        ADsFreeString(pszClass);
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTLocalGroupCollectionEnum::GetComputerMemberObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPCOMPUTER_GROUP_MEMBER pComputerGrpMember = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;


    if (!_hGroup) {
        dwRet = WinNTLocalGroupOpen(
                        _DomainName,
                        _ServerName,
                        _GroupName,
                        &_hGroup
                        );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = WinNTLocalGroupEnum(
                    _hGroup,
                    1,
                    &pBuffer,
                    &dwReturned
                    );
    if (!dwRet) {
        goto error;
    }

    pComputerGrpMember = (LPCOMPUTER_GROUP_MEMBER)pBuffer;

    switch (pComputerGrpMember->Type) {
    case WINNT_USER_ID :
        hr = CWinNTUser::CreateUser(
                            pComputerGrpMember->Parent,
                            pComputerGrpMember->ParentType,
                            pComputerGrpMember->Domain,
                            pComputerGrpMember->Computer,
                            pComputerGrpMember->Name,
                            ADS_OBJECT_BOUND,
                            NULL,   // UserFlags
                            NULL,   // FullName
                            NULL,   // Description
                            pComputerGrpMember->Sid,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppDispatch
                            );
        break;

    case WINNT_GROUP_ID:
    case WINNT_LOCALGROUP_ID:
        hr = CWinNTGroup::CreateGroup(
                            pComputerGrpMember->Parent,
                            pComputerGrpMember->ParentType,
                            pComputerGrpMember->Domain,
                            pComputerGrpMember->Computer,
                            pComputerGrpMember->Name,
                            pComputerGrpMember->Type == WINNT_GROUP_ID ?
                                WINNT_GROUP_GLOBAL :
                                WINNT_GROUP_LOCAL,
                            ADS_OBJECT_BOUND,
                            pComputerGrpMember->Sid,                                                        
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppDispatch
                        );
        break;

    default:
        goto error;
    }

    BAIL_ON_FAILURE(hr);

    hr = S_OK;

cleanup:

    if (pBuffer) {
        FreeADsMem(pBuffer);
    }

    RRETURN(hr);


error:
    *ppDispatch = NULL;

    hr = S_FALSE;

    goto cleanup;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTLocalGroupCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTLocalGroupCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    //
    // Check the out parameter to ensure it is valid
    //
    if (!pvar)
    {
        //
        // Returning S_FALSE to indicate that we aren't returning
        // as many elements as requested.
        //
        hr = S_FALSE;
    }
    else
    {
        hr = EnumGroupMembers(
                cElements,
                pvar,
                &cElementFetched
                );
    }

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenumcom.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cenumcom.cxx
//
//  Contents:  Windows NT 4.0 Enumeration code for computer container
//
//              CWinNTComputerEnum::CWinNTComputerEnum()
//              CWinNTComputerEnum::CWinNTComputerEnum
//              CWinNTComputerEnum::EnumObjects
//              CWinNTComputerEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

#if DBG
DECLARE_INFOLEVEL(EnumComp);
DECLARE_DEBUG(EnumComp);
#define EnumCompDebugOut(x) EnumCompInlineDebugOut x
#endif



//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTComputerEnum::Create(
    CWinNTComputerEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    BSTR DomainName,
    BSTR ComputerName,
    VARIANT var,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CWinNTComputerEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CWinNTComputerEnum();

    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( DomainName, &penumvariant->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ComputerName, &penumvariant->_ComputerName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;
    hr = penumvariant->_Credentials.RefServer(ComputerName);
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}



CWinNTComputerEnum::CWinNTComputerEnum():
                            _ComputerName(NULL),
                            _DomainName(NULL),
                            _ADsPath(NULL)
{
    _pObjList = NULL;
    _pBuffer = NULL;
    _bNoMore = 0;
    _dwObjectReturned = 0;
    _dwObjectCurrentEntry = 0;
    _dwObjectTotal = 0;

    _hLGroupComputer = NULL;
    _hGGroupComputer = NULL;
    _dwGroupArrayIndex = 0;


    _pPrinterBuffer = NULL;
    _dwPrinterObjectReturned = 0;
    _dwPrinterObjectCurrentEntry = 0;
    _dwPrinterObjectTotal = 0;
    _fPrinterNoMore = 0;

    _pServiceBuffer = NULL;
    _dwServiceObjectReturned = 0;
    _dwServiceObjectCurrentEntry = 0;
    _dwServiceObjectTotal = 0;
    _fServiceNoMore = 0;
    _dwIndex = 0;


}



CWinNTComputerEnum::CWinNTComputerEnum(ObjectTypeList ObjList):
                                _ComputerName(NULL),
                                _DomainName(NULL),
                                _ADsPath(NULL)
{
    _pObjList = NULL;
    _pBuffer = NULL;
    _bNoMore = 0;
    _dwObjectReturned = 0;
    _dwObjectTotal = 0;
    _dwObjectCurrentEntry = 0;

    _hLGroupComputer = NULL;
    _hGGroupComputer = NULL;
    _dwGroupArrayIndex = 0;

    _pPrinterBuffer = NULL;
    _dwPrinterObjectReturned = 0;
    _dwPrinterObjectCurrentEntry = 0;
    _dwPrinterObjectTotal = 0;
    _fPrinterNoMore = FALSE;

    _pServiceBuffer = NULL;
    _dwServiceObjectReturned = 0;
    _dwServiceObjectCurrentEntry = 0;
    _dwServiceObjectTotal = 0;
    _fServiceNoMore = FALSE;
    _dwIndex = 0;

}

CWinNTComputerEnum::~CWinNTComputerEnum()
{
    if (_pServiceBuffer) {
        FreeADsMem(_pServiceBuffer);
    }

    if(_pPrinterBuffer){
        FreeADsMem(_pPrinterBuffer);
    }

    if (_hLGroupComputer) {

        WinNTCloseComputer(_hLGroupComputer);

    }

    if (_hGGroupComputer) {

        WinNTCloseComputer(_hGGroupComputer);
    }

    if (_ComputerName) {
        ADsFreeString(_ComputerName);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_DomainName) {
        ADsFreeString(_DomainName);
    }

    if (_pObjList) {

        delete _pObjList;
    }

    if (_pBuffer)
    {
        NetApiBufferFree(_pBuffer);
    }

}

HRESULT
CWinNTComputerEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{

    HRESULT hr = S_OK ;
    DWORD cElementLocal = 0;
    DWORD cElementGlobal = 0;

    switch (ObjectType) {

    case WINNT_GROUP_ID:

        //
        // for backward compatabillity, "group" includes "local group" and
        // "global group" during enumeration
        //

        //
        // enum local groups first
        //

        hr = EnumGroupObjects(WINNT_GROUP_LOCAL,
							  cElements,
							  pvar,
                              &cElementLocal
							  );

        if (hr == S_FALSE) {

            //
            // enum global groups after all local groups have been enumerated
            //

            hr = EnumGroupObjects(WINNT_GROUP_GLOBAL,
							  cElements-cElementLocal,
							  pvar+cElementLocal,
							  &cElementGlobal
                              );
        }


        //
        // increment instead of assingn: consistent with other switch cases
        //

        (*pcElementFetched) += (cElementGlobal+cElementLocal);

        break;


    case WINNT_LOCALGROUP_ID:
        hr = EnumGroupObjects(WINNT_GROUP_LOCAL,
							  cElements,
							  pvar,
							  pcElementFetched);
        break;


    case WINNT_GLOBALGROUP_ID:
        hr = EnumGroupObjects(WINNT_GROUP_GLOBAL,
							  cElements,
							  pvar,
							  pcElementFetched);
        break;


    case WINNT_USER_ID:
        hr = EnumUsers(cElements, pvar, pcElementFetched);
        break;
    case WINNT_PRINTER_ID:
        hr = EnumPrintQueues(cElements, pvar, pcElementFetched);
        break;
    case WINNT_SERVICE_ID:
        hr = EnumServices(cElements, pvar, pcElementFetched);
        break;
    default:
        hr = S_FALSE;
    }
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTComputerEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_FALSE;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while (SUCCEEDED(_pObjList->GetCurrentObject(&ObjectType)) &&
            ((hr = EnumObjects(ObjectType,
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (FAILED(_pObjList->Next())){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            return(ResultFromScode(S_FALSE));
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTComputerEnum::EnumUsers(ULONG cElements,
                     VARIANT FAR* pvar,
                     ULONG FAR* pcElementFetched)
{
    HRESULT hr = S_OK ;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetUserObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}

HRESULT
CWinNTComputerEnum::GetUserObject(IDispatch ** ppDispatch)
{
    HRESULT hr = S_OK;
    NTSTATUS Status;
    PNET_DISPLAY_USER pUserInfo1 = NULL;
    NET_API_STATUS nasStatus = 0;
    DWORD dwResumeHandle = 0;
    WCHAR szBuffer[MAX_PATH];

    if (!_pBuffer || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        if (_pBuffer) {
            NetApiBufferFree(_pBuffer);
            _pBuffer = NULL;
        }

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        hr = MakeUncName(_ComputerName, szBuffer);
        BAIL_IF_ERROR(hr);
        
        nasStatus = NetQueryDisplayInformation(
                            szBuffer,
                            1,
                            _dwIndex,
                            1024,
                            MAX_PREFERRED_LENGTH,
                            &_dwObjectReturned,
                            (PVOID *)&_pBuffer
                            );
        //
        // The following if clause is to handle real errors; anything
        // other than ERROR_SUCCESS and ERROR_MORE_DATA
        //

        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)) {
            RRETURN(S_FALSE);
        }

        //
        // This one is to handle the termination case - Call completed
        // successfully but there is no data to retrieve _pBuffer = NULL
        //

        if (!_pBuffer) {
            RRETURN(S_FALSE);
        }

        _dwIndex  = ((PNET_DISPLAY_USER)_pBuffer + _dwObjectReturned -1)->usri1_next_index;

    }

    //
    // Now send back the current ovbject
    //

    pUserInfo1 = (PNET_DISPLAY_USER)_pBuffer;
    pUserInfo1 += _dwObjectCurrentEntry;

    hr = CWinNTUser::CreateUser(
                        _ADsPath,
                        WINNT_COMPUTER_ID,
                        NULL,
                        _ComputerName,
                        pUserInfo1->usri1_name,
                        ADS_OBJECT_BOUND,
                        &(pUserInfo1->usri1_flags),
                        pUserInfo1->usri1_full_name,
                        pUserInfo1->usri1_comment,
                        NULL,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_IF_ERROR(hr);
    _dwObjectCurrentEntry++;

    RRETURN(S_OK);

cleanup:
    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CWinNTComputerEnum::EnumPrintQueues(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )

{
    HRESULT hr = S_OK ;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetPrinterObject(&pDispatch);
        if (hr != S_OK) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}

HRESULT
CWinNTComputerEnum::GetPrinterObject(IDispatch **ppDispatch)
{
    HRESULT hr = S_OK;
    NTSTATUS Status;
    NET_API_STATUS nasStatus = NERR_Success;
    DWORD dwBytesNeeded = 0;
    DWORD dwBufLen       = 0;
    WCHAR szPrintObjectName[MAX_PATH];
    BOOL fStatus;
    DWORD dwLastError;
    LPBYTE pMem = NULL;
    PRINTER_INFO_2 * pPrinterInfo2 = NULL;
    WCHAR   szDomainName[MAX_PATH];

    if(!_pPrinterBuffer || (_dwPrinterObjectCurrentEntry == _dwPrinterObjectReturned)){

       if (_pPrinterBuffer) {

           FreeADsMem(_pPrinterBuffer);
           _pPrinterBuffer = NULL;

       }

       if (_fPrinterNoMore) {
          *ppDispatch = NULL;
          return(S_FALSE);
       }

       _dwPrinterObjectCurrentEntry = 0;
       _dwPrinterObjectReturned = 0;

       hr = MakeUncName(_ComputerName, szPrintObjectName);
       BAIL_IF_ERROR(hr);

       fStatus = WinNTEnumPrinters(
                    PRINTER_ENUM_NAME| PRINTER_ENUM_SHARED,
                    szPrintObjectName,
                    2,
                    (LPBYTE *)&_pPrinterBuffer,
                    &_dwPrinterObjectReturned
                    );

        if (!fStatus || !_dwPrinterObjectReturned) {

            _fPrinterNoMore = TRUE;
            RRETURN(S_FALSE);
        }


    }

    pPrinterInfo2 = (PRINTER_INFO_2 *)_pPrinterBuffer;
    pPrinterInfo2 += _dwPrinterObjectCurrentEntry;

    hr = CWinNTPrintQueue::CreatePrintQueue(
                     _ADsPath,
                     WINNT_COMPUTER_ID,
                     szDomainName,
                     _ComputerName,
                     pPrinterInfo2->pShareName,
                     ADS_OBJECT_BOUND,
                     IID_IDispatch,
                     _Credentials,
                     (void **)ppDispatch
                     );

    BAIL_IF_ERROR(hr);

    _dwPrinterObjectCurrentEntry++;

    if(_dwPrinterObjectCurrentEntry == _dwPrinterObjectReturned){
        _fPrinterNoMore = TRUE;
    }


cleanup:
    if(FAILED(hr)){
       *ppDispatch = NULL;
#if DBG


       EnumCompDebugOut((DEB_TRACE,
                         "hr Failed with value: %ld \n", hr ));

#endif
       hr = S_FALSE; // something else may have failed!
    }
    RRETURN_EXP_IF_ERR(hr);
}




HRESULT
CWinNTComputerEnum::EnumServices(
    ULONG cElements,
     VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )

{
    HRESULT hr = S_OK ;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetServiceObject(&pDispatch);
        if (hr != S_OK) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);

}

HRESULT
CWinNTComputerEnum::GetServiceObject(IDispatch **ppDispatch)
{

    HRESULT hr = S_OK;
    LPBYTE pMem = NULL;
    DWORD dwBytesNeeded = 0;
    NET_API_STATUS nasStatus = NERR_Success;
    WCHAR szBuffer[MAX_PATH];
    ENUM_SERVICE_STATUS *pqssBuf;
    WCHAR szDomainName[MAX_PATH];

    if(!_pServiceBuffer || (_fServiceNoMore == TRUE )){

       if(_pServiceBuffer){
           FreeADsMem(_pServiceBuffer);
           _pServiceBuffer = NULL;
       }

       if (_fServiceNoMore == TRUE) {
           *ppDispatch = NULL;
           return(S_FALSE);
       }

       _dwServiceObjectCurrentEntry = 0;
       _dwServiceObjectReturned = 0;


       hr = WinNTEnumServices( _ComputerName,
                               &_dwServiceObjectReturned,
                               &_pServiceBuffer
                             );

       BAIL_IF_ERROR(hr);

       if(hr == S_FALSE){
          _fServiceNoMore = TRUE;
          *ppDispatch = NULL;
          goto cleanup;
       }

    }

    hr = GetDomainFromPath(_ADsPath, szDomainName);
    BAIL_IF_ERROR(hr);

    pqssBuf = (ENUM_SERVICE_STATUS *)_pServiceBuffer;
    pqssBuf += _dwServiceObjectCurrentEntry;

    hr = CWinNTService::Create(_ADsPath,
                               szDomainName,
                               _ComputerName,
                               pqssBuf->lpServiceName,
                               ADS_OBJECT_BOUND,
                               IID_IDispatch,
                               _Credentials,
                               (void **)ppDispatch);

    BAIL_IF_ERROR(hr);

    _dwServiceObjectCurrentEntry++;

    if(_dwServiceObjectCurrentEntry == _dwServiceObjectReturned){
       _fServiceNoMore = TRUE;
    }

cleanup:
    if(FAILED(hr)){
#if DBG
        EnumCompDebugOut((DEB_TRACE,
                          "hr Failed with value: %ld \n", hr ));

#endif
        hr = S_FALSE;
    }
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CWinNTComputerEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTComputerEnum::Next(ULONG cElements,
                        VARIANT FAR* pvar,
                        ULONG FAR* pcElementFetched)
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    if (NULL == pvar)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = EnumObjects(cElements,
                        pvar,
                        &cElementFetched
                        );
    }

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTComputerEnum::GetGlobalGroupObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPWINNT_GROUP pWinNTGrp = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;



    if (!_hGGroupComputer) {
        dwRet = WinNTComputerOpen(
                        _DomainName,
                        _ComputerName,
                        WINNT_COMPUTER_ID,
                        &_hGGroupComputer
                        );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = WinNTEnumGlobalGroups(
                    _hGGroupComputer,
                    1,
                    &pBuffer,
                    &dwReturned
                    );
    if (!dwRet) {
        goto error;
    }

    pWinNTGrp = (LPWINNT_GROUP)pBuffer;

    hr = CWinNTGroup::CreateGroup(
                        pWinNTGrp->Parent,
                        WINNT_COMPUTER_ID,
                        pWinNTGrp->Domain,
                        pWinNTGrp->Computer,
                        pWinNTGrp->Name,
                        WINNT_GROUP_GLOBAL,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);


    hr = S_OK;

cleanup:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);

error:
    *ppDispatch = NULL;

    hr = S_FALSE;

    goto cleanup;
}

HRESULT
CWinNTComputerEnum::GetLocalGroupObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPWINNT_GROUP pWinNTGrp = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;



    if (!_hLGroupComputer) {
        dwRet = WinNTComputerOpen(
                        _DomainName,
                        _ComputerName,
                        WINNT_COMPUTER_ID,
                        &_hLGroupComputer
                        );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = WinNTEnumLocalGroups(
                    _hLGroupComputer,
                    1,
                    &pBuffer,
                    &dwReturned
                    );
    if (!dwRet) {
        goto error;
    }

    pWinNTGrp = (LPWINNT_GROUP)pBuffer;

    hr = CWinNTGroup::CreateGroup(
                        pWinNTGrp->Parent,
                        WINNT_COMPUTER_ID,
                        pWinNTGrp->Domain,
                        pWinNTGrp->Computer,
                        pWinNTGrp->Name,
                        WINNT_GROUP_LOCAL,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );

    BAIL_ON_FAILURE(hr);

    hr = S_OK;

cleanup:

   if (pBuffer) {
       FreeADsMem(pBuffer);

   }

   RRETURN(hr);

error:
    *ppDispatch = NULL;

    //
    // We missed a member so return E_FAIL if that was the error
    // as we would still like to get at the other groups
    //
    if (hr != E_FAIL) {
        hr = S_FALSE;
    }

    goto cleanup;
}

HRESULT
CWinNTComputerEnum::EnumGroupObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    HRESULT hr = S_OK ;

    switch (ObjectType) {

    case WINNT_GROUP_GLOBAL:
        hr = EnumGlobalGroups(cElements, pvar, pcElementFetched);
        break;

    case WINNT_GROUP_LOCAL:
        hr = EnumLocalGroups(cElements, pvar, pcElementFetched);
        break;

    default:
        hr = S_FALSE;
    }
    RRETURN(hr);
}


extern ULONG GroupTypeArray[];


HRESULT
CWinNTComputerEnum::EnumGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while ((GroupTypeArray[_dwGroupArrayIndex] != (ULONG)-1) &&
            ((hr = EnumGroupObjects(
                               GroupTypeArray[_dwGroupArrayIndex],
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {

        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (GroupTypeArray[_dwGroupArrayIndex++] == (ULONG)-1){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN(hr);
}

HRESULT
CWinNTComputerEnum::EnumGlobalGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK ;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetGlobalGroupObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CWinNTComputerEnum::EnumLocalGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK ;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        //
        // Need to set it here in case we are getting multiple elements
        //
        hr = E_FAIL;

        //
        // We use a while loop in case a get of one of the objects fails
        // because it has a long pathname or otherwise
        //
        while (hr == E_FAIL) {
            hr = GetLocalGroupObject(&pDispatch);
        }
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenumfsh.cxx ===
/*++


  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  cenumfsh.cxx

  Abstract:

  Contains methods for implementing the Enumeration of session on a
  server. Has methods for the CWinNTFileSharesEnumVar object.

  Author:

  Ram Viswanathan (ramv) 11-28-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop

#if DBG
DECLARE_INFOLEVEL(EnumFileShare);
DECLARE_DEBUG(EnumFileShare);
#define EnumFileShareDebugOut(x) EnumFileShareInlineDebugOut x
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileSharesEnumVar::CWinNTFileSharesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CWinNTFileSharesEnumVar::CWinNTFileSharesEnumVar()
{
    _pszADsPath = NULL;
    _pszServerName = NULL;
    _pbFileShares = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;
    _dwTotalEntries = 0;
    _dwResumeHandle = 0;
    VariantInit(&_vFilter);

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileSharesEnumVar::~CWinNTFileSharesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CWinNTFileSharesEnumVar::~CWinNTFileSharesEnumVar()
{

    if(_pszADsPath){
        FreeADsStr(_pszADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pbFileShares){
        NetApiBufferFree(_pbFileShares);
    }
    VariantClear(&_vFilter);
}


HRESULT CWinNTFileSharesEnumVar::Create(LPTSTR pszServerName,
                                        LPTSTR pszADsPath,
                                        CWinNTFileSharesEnumVar **ppCFileSharesEnumVar,
                                        VARIANT vFilter,
                                        CWinNTCredentials& Credentials
                                        )
{

    HRESULT hr = S_OK;
    BOOL fStatus = FALSE;

    CWinNTFileSharesEnumVar FAR* pCFileSharesEnumVar = NULL;
    *ppCFileSharesEnumVar = NULL;

    pCFileSharesEnumVar = new CWinNTFileSharesEnumVar();
    if (pCFileSharesEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pCFileSharesEnumVar->_pszServerName =
        AllocADsStr(pszServerName);

    if(!(pCFileSharesEnumVar->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pCFileSharesEnumVar->_pszADsPath =
        AllocADsStr(pszADsPath);

    if(!(pCFileSharesEnumVar->_pszADsPath)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = VariantCopy(&(pCFileSharesEnumVar->_vFilter), &vFilter);
    BAIL_ON_FAILURE(hr);

    pCFileSharesEnumVar->_Credentials = Credentials;
    hr = pCFileSharesEnumVar->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);

    *ppCFileSharesEnumVar = pCFileSharesEnumVar;
    RRETURN(hr);

error:

    delete pCFileSharesEnumVar;
    RRETURN_EXP_IF_ERR(hr);


}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileSharesEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Share objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [ulNumFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTFileSharesEnumVar::Next(ULONG ulNumElementsRequested,
                              VARIANT FAR* pvar,
                              ULONG FAR* pulNumFetched)
{

    HRESULT hresult = S_OK;
    ULONG l;
    ULONG lNewCurrent;
    ULONG lNumFetched;
    LPSHARE_INFO_1 lpShareInfo = NULL;
    VARIANT v;
    IDispatch * pDispatch = NULL;


    if (pulNumFetched != NULL){
        *pulNumFetched = 0;
    }

    //
    // Check the out parameter to ensure it is valid
    //
    if (!pvar)
        return S_FALSE;

    //
    // Initialize the elements to be returned
    //

    for (l=0; l<ulNumElementsRequested; l++){
        VariantInit(&pvar[l]);
    }

    if(!_pbFileShares ||(_lCurrentPosition == _lLBound +(LONG)_cElements)){
        if (_pbFileShares){
            NetApiBufferFree(_pbFileShares);
            _pbFileShares = NULL;
        }

        if(_dwTotalEntries == _cElements && (_dwTotalEntries !=0)){
            //
            // we got all elements already, no need to do another call
            //
            RRETURN(S_FALSE);
        }

        if(!(ValidateFilterValue(_vFilter))){
            RRETURN(S_FALSE);
        }

        hresult = WinNTEnumFileShares(_pszServerName,
                                      &_cElements,
                                      &_dwTotalEntries,
                                      &_dwResumeHandle,
                                      &_pbFileShares
                                      );
        if(hresult == S_FALSE){
            goto cleanup;
        }
        _lLBound = 0;
        _lCurrentPosition = _lLBound;
    }

    //
    // Get each element and place it into the return array
    // Don't request more than we have
    //

    lNumFetched = 0;
    lNewCurrent = _lCurrentPosition;

    while((lNumFetched < ulNumElementsRequested) &&
           (lNewCurrent< _lLBound +_cElements))
    {


        lpShareInfo = (LPSHARE_INFO_1)(_pbFileShares +
                                       lNewCurrent*sizeof(SHARE_INFO_1));

        if(lpShareInfo->shi1_type == STYPE_DISKTREE){
            //
            // file share object
            //
            hresult = CWinNTFileShare::Create(_pszADsPath,
                                              _pszServerName,
                                              FILESHARE_CLASS_NAME,
                                              lpShareInfo->shi1_netname,
                                              ADS_OBJECT_BOUND,
                                              IID_IDispatch,
                                              _Credentials,
                                              (void **)&pDispatch);


            BAIL_IF_ERROR(hresult);

            VariantInit(&v);
            V_VT(&v) = VT_DISPATCH;
            V_DISPATCH(&v) = pDispatch;
            pvar[lNumFetched] = v;

            lNumFetched++;
        }

        lNewCurrent++;

        if(lNumFetched == ulNumElementsRequested){
            //
            // we got all elements
            //
            break;
        }

        if(lNewCurrent==(_lLBound+_cElements)){

            //
            // first free our current buffer
            //

            if(_pbFileShares){
                NetApiBufferFree(_pbFileShares);
                _pbFileShares = NULL;
            }
            if(_cElements < _dwTotalEntries){
                hresult = WinNTEnumFileShares(_pszServerName,
                                              &_cElements,
                                              &_dwTotalEntries,
                                              &_dwResumeHandle,
                                              &_pbFileShares);
                if(hresult == S_FALSE){
                    if (pulNumFetched != NULL){
                        *pulNumFetched = lNumFetched;
                    }
                    goto cleanup;
                }
                _lLBound = 0;
                _lCurrentPosition = _lLBound;
                lNewCurrent = _lCurrentPosition;
            }
            else{

                //
                // you have gone through every share object
                // return S_FALSE
                //

                hresult = S_FALSE;
                if (pulNumFetched != NULL){
                    *pulNumFetched = lNumFetched;
                }

                goto cleanup;
            }

            lNewCurrent = _lCurrentPosition;
        }

    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //

    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;

    _lCurrentPosition = lNewCurrent;

    //
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //

    return (lNumFetched < ulNumElementsRequested) ?
        S_FALSE
            : S_OK;

cleanup:
    if(_pbFileShares){
        NetApiBufferFree(_pbFileShares);
    }

    if(FAILED(hresult)){
       #if DBG
       EnumFileShareDebugOut((DEB_TRACE,
                         "hresult Failed with value: %ld \n", hresult ));
       #endif
           RRETURN(S_FALSE);

    } else {

        if(hresult == S_FALSE)
            RRETURN(S_FALSE);
   
        RRETURN(S_OK);
    }

}


HRESULT
WinNTEnumFileShares(LPTSTR pszServerName,
                    PDWORD pdwElements,
                    PDWORD pdwTotalEntries,
                    PDWORD pdwResumeHandle,
                    LPBYTE * ppMem
                    )
{

    NET_API_STATUS nasStatus;

    nasStatus = NetShareEnum(pszServerName,
                             1,
                             ppMem,
                             MAX_PREFERRED_LENGTH,
                             pdwElements,
                             pdwTotalEntries,
                             pdwResumeHandle
                             );

    if(*ppMem == NULL || (nasStatus!= NERR_Success)){
        //
        //no more entries returned by FileShares
        //
        RRETURN(S_FALSE);
    }

    RRETURN(S_OK);

}


BOOL
ValidateFilterValue(VARIANT vFilter)
{
    // this function unpacks vFilter and scans the safearray to investigate
    // whether or not it contains the string "fileshare". If it does,
    // we return true so that enumeration can proceed.

    BOOL fRetval = FALSE;
    HRESULT hr = S_OK;
    LONG lIndices;
    ULONG cElements;
    SAFEARRAY  *psa = NULL;
    VARIANT vElement;
    ULONG i;

    VariantInit(&vElement);

    if(V_VT(&vFilter) == VT_EMPTY){
        //
        // if no filter is set, you can still enumerate
        //
        fRetval = TRUE;
        goto cleanup;

    }else if (!(V_VT(&vFilter) ==  (VT_VARIANT|VT_ARRAY))) {

        fRetval = FALSE;
        goto cleanup;
    }

    psa = V_ARRAY(&vFilter);

    //
    // Check that there is only one dimension in this array
    //

    if (psa->cDims != 1) {
        fRetval = FALSE;
        goto cleanup;
    }

    //
    // Check that there is atleast one element in this array
    //

    cElements = psa->rgsabound[0].cElements;

    if (cElements == 0){
        fRetval = TRUE;
        //
        // If filter is set and is empty, then
        // we return all objects.
        //
        goto cleanup;
    }

    //
    // We know that this is a valid single dimension array
    //

    for(lIndices=0; lIndices< (LONG)cElements; lIndices++){
        VariantInit(&vElement);
        hr = SafeArrayGetElement(psa, &lIndices, &vElement);
        BAIL_IF_ERROR(hr);

        if(!(V_VT(&vElement) == VT_BSTR)){
            hr = E_FAIL;
            goto cleanup;
        }

        if ( _tcsicmp(vElement.bstrVal, TEXT("fileshare")) == 0){
            //
            // found it, you can return TRUE now
            //
            fRetval = TRUE;
            goto cleanup;
        }

        VariantClear(&vElement);
    }


cleanup:
    //
    // In success case as well as error if we tripped after
    // getting the value but not clearing it in the for loop.
    //
    VariantClear(&vElement);

    if(FAILED(hr)){
        return FALSE;
    }

    return fRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenumdom.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumdom.cxx
//
//  Contents:  Windows NT 3.5 Domain Enumeration Code
//
//              CWinNTDomainEnum::CWinNTDomainEnum()
//              CWinNTDomainEnum::CWinNTDomainEnum
//              CWinNTDomainEnum::EnumObjects
//              CWinNTDomainEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTDomainEnum::Create(
    CWinNTDomainEnum FAR* FAR* ppenumvariant,
    LPWSTR ADsPath,
    LPWSTR DomainName,
    VARIANT var,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CWinNTDomainEnum FAR* penumvariant = NULL;
    NET_API_STATUS  nasStatus = 0;

    *ppenumvariant = NULL;

    penumvariant = new CWinNTDomainEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    penumvariant->_ADsPath = AllocADsStr( ADsPath);
    if (!penumvariant->_ADsPath) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    penumvariant->_DomainName = AllocADsStr( DomainName);
    if (!penumvariant->_DomainName) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);


    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    //
    // ramv's change. You don't need to do a WinNTGetCachedDCName
    // to validate a domain here. You might be dealing with a
    // workgroup. If this call succeeds then we keep a BOOL variable
    // which tells us next time when it is necessary whether it is a
    // domain or workgroup
    //

    hr = WinNTGetCachedDCName(
                penumvariant->_DomainName,
                penumvariant->_szDomainPDCName,
                Credentials.GetFlags()
                );

    if(SUCCEEDED(hr)){
        penumvariant->_fIsDomain = TRUE;

    } else {
        penumvariant->_fIsDomain = FALSE;
    }

    penumvariant->_Credentials = Credentials;
    hr = penumvariant->_Credentials.RefDomain(DomainName);
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(S_OK);

error:

    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CWinNTDomainEnum::CWinNTDomainEnum():
                    _ADsPath(NULL),
                    _DomainName(NULL)
{
    _pObjList = NULL;
    _pBuffer = NULL;
    _dwObjectReturned = 0;
    _dwIndex = 0;
    _dwObjectCurrentEntry = 0;
    _dwObjectTotal = 0;
    _dwNetCount = 0;

    _hLGroupComputer = NULL;
    _hGGroupComputer = NULL;
    _dwGroupArrayIndex = 0;


    _dwCompObjectReturned = 0;
    _dwCompObjectCurrentEntry = 0;
    _dwCompObjectTotal = 0;
    _pCompBuffer = 0;
    _dwCompIndex = 0;
    _pServerInfo = NULL;

    _fSchemaReturned = FALSE;

    memset(_szDomainPDCName, 0, sizeof(WCHAR)*MAX_PATH);

}



CWinNTDomainEnum::CWinNTDomainEnum(ObjectTypeList ObjList):
                            _ADsPath(NULL),
                            _DomainName(NULL)
{
    _pObjList = NULL;
    _pBuffer = NULL;
    _dwObjectReturned = 0;
    _dwObjectCurrentEntry = 0;
    _dwIndex = 0;
    _dwNetCount = 0;

    _hLGroupComputer = NULL;
    _hGGroupComputer = NULL;
    _dwGroupArrayIndex = 0;

    _dwCompObjectReturned = NULL;
    _dwCompObjectCurrentEntry = NULL;
    _dwCompObjectTotal = NULL;
    _dwCompResumeHandle = 0;
    _pCompBuffer = NULL;
    _fIsDomain  = FALSE;
    _pServerInfo = NULL;

    _fSchemaReturned = FALSE;

    memset(_szDomainPDCName, 0, sizeof(WCHAR)*MAX_PATH);

}

CWinNTDomainEnum::~CWinNTDomainEnum()
{
    if (_hLGroupComputer) {
        WinNTCloseComputer(
            _hLGroupComputer
            );
    }

    if (_hGGroupComputer) {
        WinNTCloseComputer(
            _hGGroupComputer
            );
    }

    if (_pCompBuffer) {

        NetApiBufferFree(_pCompBuffer);
    }

    if (_DomainName) {
        FreeADsStr(_DomainName);
    }

    if (_ADsPath) {
        FreeADsStr(_ADsPath);
    }

    if (_pObjList) {

        delete _pObjList;
    }

    if (_pBuffer)
    {
        NetApiBufferFree(_pBuffer);
    }

    if (_pServerInfo)
    {
        NetApiBufferFree(_pServerInfo);
    }

}

HRESULT
CWinNTDomainEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    HRESULT hr = S_OK;
    ULONG cElementGlobal = 0;
    ULONG cElementLocal = 0;


    switch (ObjectType) {

    case WINNT_COMPUTER_ID:
        hr = EnumComputers(cElements, pvar, pcElementFetched);
        break;
    case WINNT_USER_ID:
        hr = EnumUsers(cElements, pvar, pcElementFetched);
        break;

    case WINNT_GROUP_ID:

        //
        // for backward compatabillity, "group" includes "local group" and
        // "global group" during enumeration
        //

        //
        // enum all the global groups first
        //

        hr = EnumGlobalGroups(
                cElements,
                pvar,
                &cElementGlobal
                );

        //
        // enum local groups when there is no more global
        //

        if (hr == S_FALSE) {
            hr = EnumLocalGroups(
                    cElements-cElementGlobal,  // we have reduced buffer size!
                    pvar+cElementGlobal,
                    &cElementLocal
                    );
        }

        //
        // increment instead of just assingment: for consistency with
        // other switch cases
        //
        (*pcElementFetched) += (cElementGlobal+cElementLocal);
        break;

    case WINNT_LOCALGROUP_ID:
        hr = EnumLocalGroups(cElements, pvar, pcElementFetched);
        break;

    case WINNT_GLOBALGROUP_ID:
        hr = EnumGlobalGroups(cElements, pvar, pcElementFetched);
        break;

    case WINNT_SCHEMA_ID:
        hr = EnumSchema(cElements, pvar, pcElementFetched);
        break;
    default:
        RRETURN(S_FALSE);
    }
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CWinNTDomainEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while (SUCCEEDED(_pObjList->GetCurrentObject(&ObjectType)) &&
            ((hr = EnumObjects(ObjectType,
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {

        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (FAILED(_pObjList->Next())){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTDomainEnum::EnumSchema(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
)
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;

    if ( _fSchemaReturned )
        RRETURN(S_FALSE);

    if ( cElements > 0 )
    {
        hr = CWinNTSchema::CreateSchema(
                  _ADsPath,
                  TEXT("Schema"),
                  ADS_OBJECT_BOUND,
                  IID_IDispatch,
                  _Credentials,
                  (void **)&pDispatch
                  );

        if ( hr == S_OK )
        {
            VariantInit(&pvar[0]);
            pvar[0].vt = VT_DISPATCH;
            pvar[0].pdispVal = pDispatch;
            (*pcElementFetched)++;
            _fSchemaReturned = TRUE;
        }
    }

    RRETURN(hr);
}

HRESULT
CWinNTDomainEnum::EnumUsers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    if(!_fIsDomain){
        RRETURN(S_FALSE);
    }
    while (i < cElements) {

        hr = GetUserObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CWinNTDomainEnum::GetUserObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    NTSTATUS Status;
    PNET_DISPLAY_USER pUserInfo1 = NULL;
    NET_API_STATUS nasStatus = 0;
    DWORD dwResumeHandle = 0;

    if (!_pBuffer || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        if (_pBuffer) {
            NetApiBufferFree(_pBuffer);
            _pBuffer = NULL;
        }

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        nasStatus = NetQueryDisplayInformation(
                            _szDomainPDCName,
                            1,
                            _dwIndex,
                            1024,
                            MAX_PREFERRED_LENGTH,
                            &_dwObjectReturned,
                            (PVOID *)&_pBuffer
                            );
        _dwNetCount++;

        //
        // The following if clause is to handle real errors; anything
        // other than ERROR_SUCCESS and ERROR_MORE_DATA
        //

        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)) {
            RRETURN(S_FALSE);
        }

        //
        // This one is to handle the termination case - Call completed
        // successfully but there is no data to retrieve _pBuffer = NULL
        //

        if (!_pBuffer) {
            RRETURN(S_FALSE);
        }

        _dwIndex  = (_pBuffer + _dwObjectReturned -1)->usri1_next_index;

    }

    //
    // Now send back the current ovbject
    //

    pUserInfo1 = (PNET_DISPLAY_USER)_pBuffer;
    pUserInfo1 += _dwObjectCurrentEntry;

    hr = CWinNTUser::CreateUser(
                        _ADsPath,
                        WINNT_DOMAIN_ID,
                        _DomainName,
                        NULL,
                        pUserInfo1->usri1_name,
                        ADS_OBJECT_BOUND,
                        &(pUserInfo1->usri1_flags),
                        pUserInfo1->usri1_full_name,
                        pUserInfo1->usri1_comment,
                        NULL,                        
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_IF_ERROR(hr);
    _dwObjectCurrentEntry++;

    RRETURN(S_OK);

cleanup:
    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CWinNTDomainEnum::EnumComputers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {
        if(_fIsDomain == TRUE){
            hr = GetComputerObject(&pDispatch);
        }
        else {
            hr = GetComputerObjectInWorkGroup(&pDispatch);
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CWinNTDomainEnum::GetComputerObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    NTSTATUS Status;
    PNET_DISPLAY_MACHINE pDisplayComp = NULL;
    NET_API_STATUS nasStatus = 0;
    DWORD dwResumeHandle = 0;
    DWORD clen = 0;

    if (!_pCompBuffer || (_dwCompObjectCurrentEntry == _dwCompObjectReturned)) {

        if (_pCompBuffer) {
            NetApiBufferFree(_pCompBuffer);
            _pCompBuffer = NULL;
        }

        _dwCompObjectCurrentEntry = 0;
        _dwCompObjectReturned = 0;


        nasStatus = NetQueryDisplayInformation(
                            _szDomainPDCName,
                            2,
                            _dwCompIndex,
                            100,
                            MAX_PREFERRED_LENGTH,
                            &_dwCompObjectReturned,
                            (PVOID *)&_pCompBuffer
                            );

        // The following if clause is to handle real errors; anything
        // other than ERROR_SUCCESS and ERROR_MORE_DATA
        //

        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)) {
            RRETURN(S_FALSE);
        }

        //
        // This one is to handle the termination case - Call completed
        // successfully but there is no data to retrieve _pBuffer = NULL
        //

        if (!_pCompBuffer) {
            RRETURN(S_FALSE);
        }

        _dwCompIndex  = (_pCompBuffer + _dwCompObjectReturned -1)->usri2_next_index;

    }

    //
    // Now send back the current object
    //

    pDisplayComp = (PNET_DISPLAY_MACHINE)_pCompBuffer;
    pDisplayComp += _dwCompObjectCurrentEntry;

    //
    // The usri2_name is going to be returned back with a
    // $ character appended. Null set the $ character.
    //

    clen = wcslen(pDisplayComp->usri2_name);
    *(pDisplayComp->usri2_name + clen -1) = L'\0';

    hr = CWinNTComputer::CreateComputer(
                        _ADsPath,
                        _DomainName,
                        pDisplayComp->usri2_name,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_IF_ERROR(hr);
    _dwCompObjectCurrentEntry++;

    RRETURN(S_OK);

cleanup:
    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTDomainEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTDomainEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    if (NULL == pvar)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = EnumObjects(
                cElements,
                pvar,
                &cElementFetched
                );
    }

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);
}

HRESULT
CWinNTDomainEnum::GetComputerObjectInWorkGroup(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    NTSTATUS Status;
    PSERVER_INFO_100  pServerInfo = NULL;
    NET_API_STATUS nasStatus = 0;
    DWORD clen = 0;

    if (!_pServerInfo || (_dwCompObjectCurrentEntry == _dwCompObjectReturned))
    {

        if (_pServerInfo) {
            NetApiBufferFree(_pServerInfo);
            _pServerInfo = NULL;
        }

        if(_dwCompObjectTotal == _dwCompObjectReturned
           && (_dwCompObjectTotal !=0)){
            //
            // we got all elements already, no need to do another call
            //
            RRETURN(S_FALSE);
        }

        nasStatus = NetServerEnum(
                        NULL,
                        100,
                        (LPBYTE *)&_pServerInfo,
                        MAX_PREFERRED_LENGTH,
                        &_dwCompObjectReturned,
                        &_dwCompObjectTotal,
                        SV_TYPE_NT,
                        _DomainName,
                        &_dwCompResumeHandle
                        );

/*
        nasStatus = NetQueryDisplayInformation(
                            _szDomainPDCName,
                            2,
                            _dwCompIndex,
                            100,
                            MAX_PREFERRED_LENGTH,
                            &_dwCompObjectReturned,
                            (PVOID *)&_pServerInfo
                            );

*/
        //
        // The following if clause is to handle real errors; anything
        // other than ERROR_SUCCESS and ERROR_MORE_DATA
        //

        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)) {
            RRETURN(S_FALSE);
        }

        _dwCompObjectCurrentEntry = 0;

        //
        // This one is to handle the termination case - Call completed
        // successfully but there is no data to retrieve _pServerInfo = NULL
        //
        
        if (!_dwCompObjectReturned) {
                        _pServerInfo = NULL;
            RRETURN(S_FALSE);
        }

    }

    //
    // Now send back the current object
    //

    pServerInfo = (PSERVER_INFO_100)_pServerInfo;
    pServerInfo += _dwCompObjectCurrentEntry;

    hr = CWinNTComputer::CreateComputer(
                        _ADsPath,
                        _DomainName,
                        pServerInfo->sv100_name,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_IF_ERROR(hr);
    _dwCompObjectCurrentEntry++;

    RRETURN(S_OK);

cleanup:
    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}



HRESULT
CWinNTDomainEnum::GetGlobalGroupObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPWINNT_GROUP pWinNTGrp = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;



    if (!_hGGroupComputer) {
        dwRet = WinNTComputerOpen(
                        _DomainName,
                        (_szDomainPDCName + 2),
                        WINNT_DOMAIN_ID,
                        &_hGGroupComputer
                        );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = WinNTEnumGlobalGroups(
                    _hGGroupComputer,
                    1,
                    &pBuffer,
                    &dwReturned
                    );
    if (!dwRet) {
        goto error;
    }

    pWinNTGrp = (LPWINNT_GROUP)pBuffer;

    hr = CWinNTGroup::CreateGroup(
                        pWinNTGrp->Parent,
                        WINNT_DOMAIN_ID,
                        pWinNTGrp->Domain,
                        pWinNTGrp->Computer,
                        pWinNTGrp->Name,
                        WINNT_GROUP_GLOBAL,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    hr = S_OK;

cleanup:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);

error:
    *ppDispatch = NULL;


    hr = S_FALSE;

    goto cleanup;
}


HRESULT
CWinNTDomainEnum::GetLocalGroupObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    LPWINNT_GROUP pWinNTGrp = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;



    if (!_hLGroupComputer) {
        dwRet = WinNTComputerOpen(
                        _DomainName,
                        (_szDomainPDCName + 2),
                        WINNT_DOMAIN_ID,
                        &_hLGroupComputer
                        );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = WinNTEnumLocalGroups(
                    _hLGroupComputer,
                    1,
                    &pBuffer,
                    &dwReturned
                    );
    if (!dwRet) {
        goto error;
    }

    pWinNTGrp = (LPWINNT_GROUP)pBuffer;

    hr = CWinNTGroup::CreateGroup(
                        pWinNTGrp->Parent,
                        WINNT_DOMAIN_ID,
                        pWinNTGrp->Domain,
                        pWinNTGrp->Computer,
                        pWinNTGrp->Name,
                        WINNT_GROUP_LOCAL,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    hr = S_OK;

cleanup:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);

error:
    *ppDispatch = NULL;


    hr = S_FALSE;

    goto cleanup;

}


HRESULT
CWinNTDomainEnum::EnumGroupObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    HRESULT hr;
    switch (ObjectType) {

    case WINNT_GROUP_GLOBAL:
        hr = EnumGlobalGroups(cElements, pvar, pcElementFetched);
        break;

    case WINNT_GROUP_LOCAL:
        hr = EnumLocalGroups(cElements, pvar, pcElementFetched);
        break;

    default:
        hr = S_FALSE;
        break;
    }
    RRETURN(hr);
}


ULONG GroupTypeArray[] = {WINNT_GROUP_GLOBAL, WINNT_GROUP_LOCAL, 0xFFFFFFFF};

HRESULT
CWinNTDomainEnum::EnumGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_OK;
    DWORD           ObjectType;

    if(!_fIsDomain){
        RRETURN(S_FALSE);
    }

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while ((GroupTypeArray[_dwGroupArrayIndex] != (ULONG)-1) &&
            ((hr = EnumGroupObjects(
                               GroupTypeArray[_dwGroupArrayIndex],
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {

        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (GroupTypeArray[_dwGroupArrayIndex++] == (ULONG)-1){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN(hr);
}


HRESULT
CWinNTDomainEnum::EnumGlobalGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetGlobalGroupObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


HRESULT
CWinNTDomainEnum::EnumLocalGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetLocalGroupObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenmfpsh.cxx ===
/*++


  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  cenmfpsh.cxx

  Abstract:

  Contains methods for implementing the Enumeration of session on a 
  server. Has methods for the CFPNWFileSharesEnumVar object.

  Author:

  Ram Viswanathan (ramv) 11-28-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop

#if DBG
DECLARE_INFOLEVEL(FPNWEnumFileShare);
DECLARE_DEBUG(FPNWEnumFileShare);
#define FPNWEnumFileShareDebugOut(x) FPNWEnumFileShareInlineDebugOut x
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileSharesEnumVar::CFPNWFileSharesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CFPNWFileSharesEnumVar::CFPNWFileSharesEnumVar()
{
    _pszADsPath = NULL;
    _pszServerName = NULL;
    _pbFileShares = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;  
    _dwTotalEntries = 0;
    _dwResumeHandle = 0;
    VariantInit(&_vFilter); 
}   

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileSharesEnumVar::~CFPNWFileSharesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CFPNWFileSharesEnumVar::~CFPNWFileSharesEnumVar()
{
    
    if(_pszADsPath){
        FreeADsStr(_pszADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pbFileShares){
        ADsNwApiBufferFree(_pbFileShares);
    }
    VariantClear(&_vFilter);
}


HRESULT CFPNWFileSharesEnumVar::Create(LPTSTR pszServerName,
                                       LPTSTR pszADsPath,
                                       CFPNWFileSharesEnumVar **ppCFileSharesEnumVar,
                                       VARIANT vFilter,
                                       CWinNTCredentials& Credentials
                                        )
{

    HRESULT hr = S_OK;
    BOOL fStatus = FALSE;

    CFPNWFileSharesEnumVar FAR* pCFileSharesEnumVar = NULL;

    *ppCFileSharesEnumVar = NULL;
    
    pCFileSharesEnumVar = new CFPNWFileSharesEnumVar();
    if (pCFileSharesEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }   



    pCFileSharesEnumVar->_pszServerName = 
        AllocADsStr(pszServerName);

    if(!(pCFileSharesEnumVar->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pCFileSharesEnumVar->_pszADsPath = 
        AllocADsStr(pszADsPath);

    if(!(pCFileSharesEnumVar->_pszADsPath)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    hr = VariantCopy(&(pCFileSharesEnumVar->_vFilter), &vFilter);
    BAIL_ON_FAILURE(hr);
    
    pCFileSharesEnumVar->_Credentials = Credentials;
    hr = pCFileSharesEnumVar->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);

    *ppCFileSharesEnumVar = pCFileSharesEnumVar;
    RRETURN(hr);   
    
error:

    delete pCFileSharesEnumVar;
    RRETURN_EXP_IF_ERR(hr);


}


//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileSharesEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Share objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [ulNumFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWFileSharesEnumVar::Next(ULONG ulNumElementsRequested,
                              VARIANT FAR* pvar,
                              ULONG FAR* pulNumFetched)
{

    HRESULT hresult;
    ULONG l;
    ULONG lNewCurrent;
    ULONG lNumFetched;
    PNWVOLUMEINFO  pVolumeInfo = NULL;
    VARIANT v;
    IDispatch * pDispatch = NULL;
    

    if (pulNumFetched != NULL){
        *pulNumFetched = 0;
    }

    //
    // Check the out parameter to ensure it is valid
    //
    if (!pvar)
        return S_FALSE;

    //                       
    // Initialize the elements to be returned
    //
    
    for (l=0; l<ulNumElementsRequested; l++){
        VariantInit(&pvar[l]);
    }
    
    if(!_pbFileShares ||(_lCurrentPosition == _lLBound +(LONG)_cElements)){
        if (_pbFileShares){
            ADsNwApiBufferFree(_pbFileShares);
            _pbFileShares = NULL;
        }
        
        if(!(ValidateFilterValue(_vFilter))){
            RRETURN(S_FALSE);
        }

        hresult = FPNWEnumFileShares(_pszServerName,
                                     &_cElements,
                                     &_dwResumeHandle,
                                     &_pbFileShares);
        if(hresult == S_FALSE){
            goto cleanup;
        }
        _lLBound = 0;
        _lCurrentPosition = _lLBound;
    }
    
    //
    // Get each element and place it into the return array
    // Don't request more than we have    
    //

    lNumFetched = 0;
    lNewCurrent = _lCurrentPosition;

    while((lNumFetched < ulNumElementsRequested) ||
          (lNewCurrent< _lLBound +_cElements ))
    {

        
        pVolumeInfo = (PNWVOLUMEINFO)(_pbFileShares +
                                      lNewCurrent*sizeof(NWVOLUMEINFO));
        
        if(pVolumeInfo->dwType == FPNWVOL_TYPE_DISKTREE){
            //
            // file share object
            //
            hresult = CFPNWFileShare::Create((LPTSTR)_pszADsPath,
                                             _pszServerName,
                                             FILESHARE_CLASS_NAME,
                                             pVolumeInfo->lpVolumeName,
                                             ADS_OBJECT_BOUND,
                                             IID_IDispatch,
                                             _Credentials,
                                             (void **)&pDispatch);  
            
            
            BAIL_IF_ERROR(hresult);
            
            VariantInit(&v);
            V_VT(&v) = VT_DISPATCH;
            V_DISPATCH(&v) = pDispatch;    
            pvar[lNumFetched] = v;
            
            lNumFetched++;
        }
        
        lNewCurrent++;

        if(lNumFetched == ulNumElementsRequested){
            //
            // we got all elements 
            //
            break;
        }

        if(lNewCurrent==(_lLBound+_cElements)){

            //
            // first free our current buffer
            //

            if(_pbFileShares){
                ADsNwApiBufferFree(_pbFileShares);
                _pbFileShares = NULL;
            }

            hresult = FPNWEnumFileShares(_pszServerName,
                                         &_cElements,
                                         &_dwResumeHandle,
                                         &_pbFileShares);
            if(hresult == S_FALSE){
                break;
            } 
  
            _lLBound = 0;
            _lCurrentPosition = _lLBound;
            lNewCurrent = _lCurrentPosition;
        }

    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //
    
    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;
    
    _lCurrentPosition = lNewCurrent;
    
    //    
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //
    
    return (lNumFetched < ulNumElementsRequested) ? 
        S_FALSE 
            : S_OK;

cleanup:
    if(_pbFileShares){
        ADsNwApiBufferFree(_pbFileShares);
        _pbFileShares = NULL;
    }    
    if(FAILED(hresult)){
       #if DBG
       FPNWEnumFileShareDebugOut((DEB_TRACE,
                         "hresult Failed with value: %ld \n", hresult ));
       #endif
    }
        
    RRETURN(S_FALSE);
}

HRESULT 
FPNWEnumFileShares(LPTSTR pszServerName,
                   PDWORD pdwElements,
                   PDWORD pdwResumeHandle,
                   LPBYTE * ppMem
                   )     
{
    
    NET_API_STATUS nasStatus;
    DWORD dwErrorCode;

    //
    // assumption: *ppMem = NULL when passed here
    //

    dwErrorCode = ADsNwVolumeEnum(pszServerName,
                               1,
                               (PNWVOLUMEINFO *)ppMem,
                               pdwElements,
                               pdwResumeHandle);
    

    if(dwErrorCode != NERR_Success || (*ppMem == NULL )){
                //
                // NwVolumeEnum returns NERR_Success even when there 
                // aren't any more items to enumerate
                //

        RRETURN(S_FALSE);
    }

    RRETURN(S_OK);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenmfpse.cxx ===
/*++

  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  cenmfpse.cxx

  Abstract:

  Contains methods for implementing the Enumeration of session on a
  server. Has methods for the CFPNWSessionsCollection object
  as well as the CFPNWSessionsEnumVar object.

  Author:

  Ram Viswanathan (ramv) 11-28-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop


#if DBG
DECLARE_INFOLEVEL(FPNWEnumSession);
DECLARE_DEBUG(FPNWEnumSession);
#define FPNWEnumSessionDebugOut(x) FPNWEnumSessionInlineDebugOut x
#endif



CFPNWSessionsCollection::CFPNWSessionsCollection()
{
    _pszServerADsPath = NULL;
    _pszServerName = NULL;
    _pDispMgr = NULL;
    _pCSessionsEnumVar = NULL;
    ENLIST_TRACKING(CFPNWSessionsCollection);
}

CFPNWSessionsCollection::~CFPNWSessionsCollection()
{

    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    delete _pDispMgr;
    if(_pCSessionsEnumVar){
        _pCSessionsEnumVar->Release();
    }

}

HRESULT
CFPNWSessionsCollection::Create(LPTSTR pszServerADsPath,
                                CWinNTCredentials& Credentials,
                                 CFPNWSessionsCollection
                                 ** ppCFPNWSessionsCollection )
{

    BOOL fStatus = FALSE;
    HRESULT hr;
    CFPNWSessionsCollection *pCFPNWSessionsCollection = NULL;
    POBJECTINFO  pServerObjectInfo = NULL;

    //
    // create the Sessions collection object
    //

    pCFPNWSessionsCollection = new CFPNWSessionsCollection();

    if(pCFPNWSessionsCollection == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCFPNWSessionsCollection->_pszServerADsPath   =
        AllocADsStr(pszServerADsPath);

    if(!(pCFPNWSessionsCollection->_pszServerADsPath  )){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo
                         );
    BAIL_IF_ERROR(hr);



    pCFPNWSessionsCollection->_pszServerName =
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCFPNWSessionsCollection->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCFPNWSessionsCollection->_Credentials = Credentials;
    hr = pCFPNWSessionsCollection->_Credentials.RefServer(
        pCFPNWSessionsCollection->_pszServerName);
    BAIL_IF_ERROR(hr);

    pCFPNWSessionsCollection->_pDispMgr = new CAggregatorDispMgr;
    if (pCFPNWSessionsCollection->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = LoadTypeInfoEntry(pCFPNWSessionsCollection->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsCollection,
                           (IADsCollection *)pCFPNWSessionsCollection,
                           DISPID_NEWENUM
                           );

    BAIL_IF_ERROR(hr);

    hr = CFPNWSessionsEnumVar::Create(pszServerADsPath,
                                      pCFPNWSessionsCollection->_Credentials,
                                      &pCFPNWSessionsCollection->_pCSessionsEnumVar);

    BAIL_IF_ERROR(hr);

    *ppCFPNWSessionsCollection = pCFPNWSessionsCollection;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }
    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCFPNWSessionsCollection;
    RRETURN_EXP_IF_ERR(hr);

}

/* IUnknown methods for Sessions collection object  */

STDMETHODIMP
CFPNWSessionsCollection::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsCollection))
    {
        *ppvObj = (IADsCollection FAR *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

DEFINE_IDispatch_Implementation(CFPNWSessionsCollection);

/* ISupportErrorInfo method */
STDMETHODIMP
CFPNWSessionsCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsCollection)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADsCollection methods */


STDMETHODIMP
CFPNWSessionsCollection::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = NULL;


    ADsAssert(_pCSessionsEnumVar);

    hr = _pCSessionsEnumVar->QueryInterface(IID_IUnknown, (void **)retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWSessionsCollection::GetObject(THIS_ BSTR bstrSessionName,
                                   VARIANT *pvar
                                   )

{

    //
    // scan the buffer _pbSessions to find one where the ConnectionId
    // matches the one in bstrSessionName and get this object
    //

    HRESULT hr;

    hr = _pCSessionsEnumVar->GetObject(bstrSessionName, pvar);

    RRETURN_EXP_IF_ERR(hr);

/*
    LPTSTR  pszSession = NULL;
    IDispatch *pDispatch = NULL;
    HRESULT hr;

    if(!bstrSessionName || !pvar){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    pszSession = AllocADsStr(bstrSessionName);
    if(!pszSession){
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    hr = CFPNWSession::Create(_pszServerADsPath,

                              ADS_OBJECT_BOUND,
                              IID_IDispatch,
                              _Credentials,
                              (void **)&pDispatch);


    BAIL_IF_ERROR(hr);

    //
    // stick this IDispatch pointer into caller provided variant
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;

cleanup:
    FreeADsStr(pszSession);
    RRETURN_EXP_IF_ERR(hr);
    */
}

STDMETHODIMP
CFPNWSessionsCollection::Add(THIS_ BSTR bstrName, VARIANT varNewItem)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CFPNWSessionsCollection::Remove(THIS_ BSTR bstrSessionName)
{

    HRESULT hr = S_OK;
    DWORD dwConnectionId;
    DWORD dwErrorCode;

    dwConnectionId  = (DWORD)_wtol(bstrSessionName);

    dwErrorCode = ADsNwConnectionDel(_pszServerName,
                                  dwConnectionId);

    if(dwErrorCode != NERR_Success){
        hr = HRESULT_FROM_WIN32(dwErrorCode);
    }

    RRETURN_EXP_IF_ERR(hr);
}


//
// CFPNWSessionsEnumVar methods follow
//

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWSessionsEnumVar::CFPNWSessionsEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CFPNWSessionsEnumVar::CFPNWSessionsEnumVar()
{

    _pszServerName = NULL;
    _pszServerADsPath = NULL;
    _pbSessions = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;
    _dwResumeHandle = 0;

}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWSessionsEnumVar::~CFPNWSessionsEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CFPNWSessionsEnumVar::~CFPNWSessionsEnumVar()
{

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }

    if(_pbSessions){
        NetApiBufferFree(_pbSessions);
    }
}


HRESULT CFPNWSessionsEnumVar::Create(LPTSTR pszServerADsPath,
                                     CWinNTCredentials& Credentials,
                                      CFPNWSessionsEnumVar \
                                      **ppCSessionsEnumVar
                                     )
{

    HRESULT hr;
    BOOL fStatus = FALSE;
    POBJECTINFO  pServerObjectInfo = NULL;
    CFPNWSessionsEnumVar FAR* pCSessionsEnumVar = NULL;

    *ppCSessionsEnumVar = NULL;

    pCSessionsEnumVar = new CFPNWSessionsEnumVar();

    if (pCSessionsEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCSessionsEnumVar->_pszServerADsPath =
        AllocADsStr(pszServerADsPath);

    if(!(pCSessionsEnumVar->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo);
    BAIL_IF_ERROR(hr);

    pCSessionsEnumVar->_pszServerName =
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCSessionsEnumVar->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCSessionsEnumVar->_Credentials = Credentials;
    hr = pCSessionsEnumVar->_Credentials.RefServer(
        pCSessionsEnumVar->_pszServerName);
    BAIL_IF_ERROR(hr);

    *ppCSessionsEnumVar = pCSessionsEnumVar;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCSessionsEnumVar;
    RRETURN_EXP_IF_ERR(hr);


}


//+---------------------------------------------------------------------------
//
//  Function:   CFPNWSessionsEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Session objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWSessionsEnumVar::Next(ULONG ulNumElementsRequested,
                            VARIANT FAR* pvar,
                            ULONG FAR* pulNumFetched)
{

    HRESULT hresult;
    ULONG ulIndex;
    LONG lNewCurrent;
    ULONG lNumFetched;
    PNWCONNECTIONINFO  pConnectionInfo;
    IDispatch * pDispatch = NULL;

    if (pulNumFetched != NULL){
        *pulNumFetched = 0;
    }

    //
    // Check the out parameter to ensure it is valid
    //
    if (!pvar)
        RRETURN(S_FALSE);

    //
    // Initialize the elements to be returned
    //

    for (ulIndex= 0; ulIndex < ulNumElementsRequested; ulIndex++){
        VariantInit(&pvar[ulIndex]);
    }

    if(!_pbSessions || (_lCurrentPosition == _lLBound +(LONG)_cElements) ){
        if (_pbSessions){
            NetApiBufferFree(_pbSessions);
            _pbSessions = NULL;
        }

        hresult = FPNWEnumSessions(_pszServerName,
                                   &_cElements,
                                   &_dwResumeHandle,
                                   &_pbSessions);

        if(hresult == S_FALSE){
            RRETURN(S_FALSE);
        }
        _lLBound = 0;
        _lCurrentPosition = _lLBound;

    }

    //
    // Get each element and place it into the return array
    // Don't request more than we have
    //

    for (lNewCurrent=_lCurrentPosition, lNumFetched=0;
         lNewCurrent<(LONG)(_lLBound+_cElements) &&
         lNumFetched < ulNumElementsRequested;
         lNewCurrent++, lNumFetched++){

        pConnectionInfo = (PNWCONNECTIONINFO)(_pbSessions +
                          lNewCurrent*sizeof(NWCONNECTIONINFO));

        hresult = CFPNWSession::Create((LPTSTR)_pszServerADsPath,
                                       pConnectionInfo,
                                       ADS_OBJECT_BOUND,
                                       IID_IDispatch,
                                       _Credentials,
                                       (void **)&pDispatch);

        BAIL_ON_FAILURE(hresult);

        V_VT(&(pvar[lNumFetched])) = VT_DISPATCH;
        V_DISPATCH(&(pvar[lNumFetched])) = pDispatch;

    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //

    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;

    _lCurrentPosition = lNewCurrent;

    //
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //

    return (lNumFetched < ulNumElementsRequested) ?
        S_FALSE
            : S_OK;

error:
#if DBG
    if(FAILED(hresult)){
        FPNWEnumSessionDebugOut((DEB_TRACE,
                                 "hresult Failed with value: %ld \n", hresult ));
    }
#endif

    RRETURN(S_FALSE);
}

//
// helper function
//

HRESULT
CFPNWSessionsEnumVar::GetObject(BSTR bstrSessionName, VARIANT *pvar)
{
    HRESULT hr = S_OK;
    DWORD dwConnectionId;
    PNWCONNECTIONINFO pConnectionInfo = NULL;
    IDispatch *pDispatch = NULL;
    DWORD i;

    if(!_pbSessions){
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    //
    // scan the buffer _pbSessions to find one where the ConnectionId
    // matches the one in bstrSessionName and get this object
    //

    dwConnectionId = (DWORD)_wtol(bstrSessionName);

    for( i=0; i<_cElements; i++){
        pConnectionInfo = (PNWCONNECTIONINFO)(_pbSessions+
                                              i*sizeof(PNWCONNECTIONINFO));

        if(pConnectionInfo->dwConnectionId = dwConnectionId){
            //
            // return this struct in the static create for the object
            //
            hr = CFPNWSession::Create(_pszServerADsPath,
                                     pConnectionInfo,
                                     ADS_OBJECT_BOUND,
                                     IID_IDispatch,
                                     _Credentials,
                                     (void **) &pDispatch );

            BAIL_IF_ERROR(hr);

            break;
        }
    }

    if(i == _cElements){
        //
        // no such element
        //
        hr = E_ADS_UNKNOWN_OBJECT;
        goto cleanup;

    }

    //
    // stick this IDispatch pointer into caller provided variant
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;

cleanup:
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
FPNWEnumSessions(LPTSTR pszServerName,
                 PDWORD pdwEntriesRead,
                 PDWORD pdwResumeHandle,
                 LPBYTE * ppMem
                 )

{
    DWORD dwErrorCode;

    dwErrorCode = ADsNwConnectionEnum(pszServerName,
                                        1,         //info level desired
                                        (PNWCONNECTIONINFO *)ppMem,
                                        pdwEntriesRead,
                                        pdwResumeHandle);

    if(*ppMem == NULL || (dwErrorCode != NERR_Success)){
        //
        //no more entries returned by sessions
        //
        RRETURN(S_FALSE);
    }


    RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenumres.cxx ===
/*++

  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  cenumres.cxx

  Abstract:

  Contains methods for implementing the Enumeration of resources(open files)
  on a  server. Has methods for the CWinNTResourcesCollection object
  as well as the CWinNTResourcesEnumVar object.

  Author:

  Ram Viswanathan (ramv) 03/12/96

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop

#if DBG
DECLARE_INFOLEVEL(EnumRes);
DECLARE_DEBUG(EnumRes);
#define EnumResDebugOut(x) EnumResInlineDebugOut x
#endif


CWinNTResourcesCollection::CWinNTResourcesCollection()
{
    _pszServerADsPath = NULL;
    _pszServerName = NULL;
    _pszBasePath = NULL;
    _pszUserName = NULL;

    _pDispMgr = NULL;
    _pCResourcesEnumVar = NULL;
    ENLIST_TRACKING(CWinNTResourcesCollection);
}

CWinNTResourcesCollection::~CWinNTResourcesCollection()
{
    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszBasePath){
        FreeADsStr(_pszBasePath);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }
    delete _pDispMgr;
    if(_pCResourcesEnumVar){
        _pCResourcesEnumVar->Release();
    }

}

HRESULT
CWinNTResourcesCollection::Create(LPTSTR pszServerADsPath,
                                  LPTSTR pszBasePath,
                                  LPTSTR pszUserName,
                                  CWinNTCredentials& Credentials,
                                  CWinNTResourcesCollection
                                  ** ppCWinNTResourcesCollection )
{

    BOOL fStatus = FALSE, LastError;
    HRESULT hr;
    CWinNTResourcesCollection *pCWinNTResourcesCollection = NULL;
    POBJECTINFO pServerObjectInfo = NULL;
    //
    // create the Resources collection object
    //

    pCWinNTResourcesCollection = new CWinNTResourcesCollection();

    if(pCWinNTResourcesCollection == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCWinNTResourcesCollection->_pszServerADsPath =
        AllocADsStr(pszServerADsPath);

    if (!pCWinNTResourcesCollection->_pszServerADsPath){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo
                         );

    BAIL_IF_ERROR(hr);

    pCWinNTResourcesCollection->_pszServerName = 
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCWinNTResourcesCollection->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCWinNTResourcesCollection->_Credentials = Credentials;
    hr = pCWinNTResourcesCollection->_Credentials.RefServer(
        pCWinNTResourcesCollection->_pszServerName);
    BAIL_IF_ERROR(hr);

    if(pszBasePath){
        pCWinNTResourcesCollection->_pszBasePath = 
            AllocADsStr(pszBasePath);

        if(!(pCWinNTResourcesCollection->_pszBasePath)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    if(pszUserName){
        pCWinNTResourcesCollection->_pszUserName = 
            AllocADsStr(pszUserName);

        if(!(pCWinNTResourcesCollection->_pszUserName)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    pCWinNTResourcesCollection->_pDispMgr = new CAggregatorDispMgr;
    if (pCWinNTResourcesCollection->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = LoadTypeInfoEntry(pCWinNTResourcesCollection->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsCollection,
                           (IADsCollection *)pCWinNTResourcesCollection,
                           DISPID_NEWENUM
                           );

    BAIL_IF_ERROR(hr);

    *ppCWinNTResourcesCollection =pCWinNTResourcesCollection;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }
    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }
    delete pCWinNTResourcesCollection;
    RRETURN_EXP_IF_ERR(hr);

}

/* IUnknown methods for Resources collection object  */

STDMETHODIMP
CWinNTResourcesCollection::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsCollection))
    {
        *ppvObj = (IADsCollection FAR *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP 
CWinNTResourcesCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsCollection)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

DEFINE_IDispatch_Implementation(CWinNTResourcesCollection);

/* IADsCollection methods */

STDMETHODIMP
CWinNTResourcesCollection::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    CWinNTResourcesEnumVar *pCResourcesEnumVar = NULL;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = NULL;

    hr = CWinNTResourcesEnumVar::Create(_pszServerADsPath,
                                        _pszBasePath,
                                        _pszUserName,
                                        _Credentials,
                                        &pCResourcesEnumVar
                                        );

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCResourcesEnumVar);

    _pCResourcesEnumVar = pCResourcesEnumVar;

    hr = _pCResourcesEnumVar->QueryInterface(IID_IUnknown,
                                             (void **)retval
                                             );

    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:
    delete pCResourcesEnumVar;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTResourcesCollection::GetObject(THIS_ BSTR bstrResourceName,
                                     VARIANT *pvar
                                     ) 

{

    HRESULT hr = S_OK;
    DWORD   dwFileId;
    IDispatch *pDispatch = NULL;
 
    if(!bstrResourceName || !pvar){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    //
    // convert the job name into a fileid
    //

    dwFileId = (DWORD)_wtol(bstrResourceName);

    hr = CWinNTResource::Create(_pszServerADsPath,
                                dwFileId,
                                ADS_OBJECT_BOUND,
                                IID_IDispatch,
                                _Credentials,
                                (void **)&pDispatch
                                );

    BAIL_IF_ERROR(hr);

    //
    // stick this IDispatch pointer into caller provided variant
    //
    
    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;

cleanup:
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP 
CWinNTResourcesCollection::Add(THIS_ BSTR bstrName, VARIANT varNewItem) 

{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP
CWinNTResourcesCollection::Remove(THIS_ BSTR bstrResourceName) 

{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);    
}


//
// CWinNTResourcesEnumVar methods follow
//

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTResourcesEnumVar::CWinNTResourcesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CWinNTResourcesEnumVar::CWinNTResourcesEnumVar()
{
    _pszServerADsPath = NULL;
    _pszServerName = NULL;
    _pszBasePath = NULL;
    _pszUserName = NULL;
    _pbResources = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;
    _dwTotalEntries = 0;
    _dwResumeHandle = 0;

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTResourcesEnumVar::~CWinNTResourcesEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CWinNTResourcesEnumVar::~CWinNTResourcesEnumVar()
{
    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszBasePath){
        FreeADsStr(_pszBasePath);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }

    if(_pbResources){
        NetApiBufferFree(_pbResources);
    }
}


HRESULT CWinNTResourcesEnumVar::Create(LPTSTR pszServerADsPath,
                                       LPTSTR pszBasePath,
                                       LPTSTR pszUserName,
                                       CWinNTCredentials& Credentials,
                                       CWinNTResourcesEnumVar
                                       **ppCResourcesEnumVar)
{

    HRESULT hr;
    BOOL fStatus = FALSE;
    POBJECTINFO  pServerObjectInfo = NULL;
    CWinNTResourcesEnumVar FAR* pCResourcesEnumVar = NULL;

    *ppCResourcesEnumVar = NULL;

    pCResourcesEnumVar = new CWinNTResourcesEnumVar();

    if (pCResourcesEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCResourcesEnumVar->_pszServerADsPath = 
        AllocADsStr(pszServerADsPath);

    if(!(pCResourcesEnumVar->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo
                         );
    BAIL_IF_ERROR(hr);

    pCResourcesEnumVar->_pszServerName = 
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCResourcesEnumVar->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCResourcesEnumVar->_Credentials = Credentials;
    hr = pCResourcesEnumVar->_Credentials.RefServer(
        pCResourcesEnumVar->_pszServerName);
    BAIL_IF_ERROR(hr);

    if(pszBasePath){
        pCResourcesEnumVar->_pszBasePath = 
            AllocADsStr(pszBasePath);

        if(!(pCResourcesEnumVar->_pszBasePath)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    if(pszUserName){

        pCResourcesEnumVar->_pszUserName = 
            AllocADsStr(pszUserName);

        if(!(pCResourcesEnumVar->_pszUserName)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

    }

    *ppCResourcesEnumVar = pCResourcesEnumVar;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCResourcesEnumVar;
    RRETURN_EXP_IF_ERR(hr);


}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTResourcesEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Resource objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTResourcesEnumVar::Next(ULONG ulNumElementsRequested,
                             VARIANT FAR* pvar,
                             ULONG FAR* pulNumFetched)
{

    HRESULT hresult;
    ULONG l;
    LONG lNewCurrent;
    ULONG lNumFetched = 0;
    LPFILE_INFO_3 lpFileInfo;
    VARIANT v;
    IDispatch * pDispatch = NULL;

    if (pulNumFetched != NULL){
        *pulNumFetched = 0;
    }

    //
    // Check the out parameter to ensure it is valid
    //
    if (!pvar)
        RRETURN(S_FALSE);

    //
    // Initialize the elements to be returned
    //

    for (l=0; l<ulNumElementsRequested; l++){
        VariantInit(&pvar[l]);
    }

    if(!_pbResources || (_lCurrentPosition == _lLBound +(LONG)_cElements) ){
        if (_pbResources){
            NetApiBufferFree(_pbResources);
            _pbResources = NULL;
        }

        if(_dwTotalEntries == _cElements && (_dwTotalEntries !=0)){
            //
            // we got all elements already, no need to do another call
            //
            RRETURN(S_FALSE);
        }

        hresult = WinNTEnumResources(_pszServerName,
                                     _pszBasePath,
                                     _pszUserName,
                                     &_pbResources,
                                     &_cElements,
                                     &_dwTotalEntries,
                                     &_dwResumeHandle
                                     );

        if(hresult == S_FALSE){
            RRETURN(S_FALSE);
        }
        _lLBound = 0;
        _lCurrentPosition = _lLBound;
    }

    //
    // Get each element and place it into the return array
    // Don't request more than we have
    //

    for (lNewCurrent=_lCurrentPosition, lNumFetched=0;
         lNewCurrent<(LONG)(_lLBound+_cElements) &&
         lNumFetched < ulNumElementsRequested;
         lNewCurrent++){

        lpFileInfo = (LPFILE_INFO_3)(_pbResources + \
                                     lNewCurrent*sizeof(FILE_INFO_3));


        hresult = CWinNTResource::Create((LPTSTR)_pszServerADsPath,
                                         ADS_OBJECT_BOUND,
                                         lpFileInfo->fi3_id,
                                         IID_IDispatch,
                                         _Credentials,
                                         (void **)&pDispatch);
        //
        // If we failed, ignore the error and continue untile we get to the 
        // end or we have got all the caller requested.  Only increment
        // lNumFetched if we succeeded.
        //
        if (SUCCEEDED(hresult))
        {
            VariantInit(&v);
            V_VT(&v) = VT_DISPATCH;
            V_DISPATCH(&v) = pDispatch;
            pvar[lNumFetched] = v;

            ++lNumFetched;
        }
    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //

    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;

    _lCurrentPosition = lNewCurrent;

    //
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //

    return (lNumFetched < ulNumElementsRequested) ?
        S_FALSE
            : S_OK;
}


HRESULT
WinNTEnumResources(LPTSTR pszServerName,
                   LPTSTR pszBasePath,
                   LPTSTR pszUserName,
                   LPBYTE * ppMem,
                   LPDWORD pdwEntriesRead,
                   LPDWORD pdwTotalEntries,
                   PDWORD_PTR pdwResumeHandle
                   )

{

    LPBYTE  pMem    = NULL;
    CWinNTResource *pCWinNTResource = NULL;
    IDispatch *pDispatch = NULL;
    VARIANT v;
    LONG l;
    HRESULT hr;
    NET_API_STATUS nasStatus;

    UNREFERENCED_PARAMETER(pszBasePath);
    UNREFERENCED_PARAMETER(pszUserName);

    //
    // why have these parameters if they are unreferenced? Because we might
    // use them in the future when more complicated enumerations are desired
    //

    nasStatus = NetFileEnum(pszServerName,
                            NULL,
                            pszUserName,
                            3,  //info level desired
                            ppMem,
                            MAX_PREFERRED_LENGTH,
                            pdwEntriesRead,
                            pdwTotalEntries,
                            pdwResumeHandle
                            );

    if(*ppMem == NULL|| (nasStatus != NERR_Success)){
        //
        // no more entries returned by NetFileEnum
        //
        RRETURN(S_FALSE);
    }

    RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenumsch.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumsch.cxx
//
//  Contents:  Windows NT 3.5 Schema Enumeration Code
//
//             CWinNTSchemaEnum::CWinNTSchemaEnum()
//             CWinNTSchemaEnum::CWinNTSchemaEnum
//             CWinNTSchemaEnum::EnumObjects
//             CWinNTSchemaEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTSchemaEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTSchemaEnum::Create(
    CWinNTSchemaEnum FAR* FAR* ppenumvariant,
    BSTR bstrADsPath,
    BSTR bstrName,
    VARIANT vFilter,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CWinNTSchemaEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CWinNTSchemaEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrName, &penumvariant->_bstrName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            vFilter,
            &penumvariant->_pObjList );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;
    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    delete penumvariant;

    RRETURN(hr);
}

CWinNTSchemaEnum::CWinNTSchemaEnum()
    : _bstrADsPath( NULL ),
      _bstrName( NULL ),
      _pObjList( NULL ),
      _dwCurrentEntry( 0 ),
      _dwPropCurrentEntry( 0)
{
}

CWinNTSchemaEnum::~CWinNTSchemaEnum()
{
   ADsFreeString( _bstrName );
   ADsFreeString( _bstrADsPath );

   if ( _pObjList != NULL )
   {
       delete _pObjList;
       _pObjList = NULL;
   }
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTSchemaEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   yihsins     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTSchemaEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    if (NULL == pvar)
    {
        //
        // Returning S_FALSE to indicate that we aren't returning
        // as many elements as requested.
        //
        hr = S_FALSE;
    }
    else
    {
        hr = EnumObjects( cElements,
                        pvar,
                        &cElementFetched );
    }

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN(hr);
}

HRESULT
CWinNTSchemaEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    HRESULT hr = S_OK;

    switch (ObjectType)
    {
        case WINNT_CLASS_ID:
            hr = EnumClasses(cElements, pvar, pcElementFetched);
            break;
        case WINNT_SYNTAX_ID:
            hr = EnumSyntaxObjects(cElements, pvar, pcElementFetched);
            break;
        case WINNT_PROPERTY_ID:
            hr = EnumProperties(cElements, pvar, pcElementFetched);
            break;
        default:
            RRETURN(S_FALSE);
    }
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTSchemaEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_FALSE;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTSchemaEnum::EnumClasses(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetClassObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CWinNTSchemaEnum::GetClassObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwCurrentEntry >= g_cWinNTClasses )
        goto error;

    hr = CWinNTClass::CreateClass(
                        _bstrADsPath,
                        &g_aWinNTClasses[_dwCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CWinNTSchemaEnum::EnumSyntaxObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetSyntaxObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CWinNTSchemaEnum::GetSyntaxObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current object
    //
    if ( _dwCurrentEntry >= g_cWinNTSyntax )
        goto error;

    hr = CWinNTSyntax::CreateSyntax(
                        _bstrADsPath,
                        &g_aWinNTSyntax[_dwCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}


HRESULT
CWinNTSchemaEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CWinNTSchemaEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwPropCurrentEntry >= g_cWinNTProperties )
        goto error;

    hr = CWinNTProperty::CreateProperty(
                        _bstrADsPath,
                        &g_aWinNTProperties[_dwPropCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        _Credentials,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwPropCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenumgrp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  Windows NT 3.5 GroupCollection Enumeration Code
//
//              CWinNTGroupCollectionEnum::CWinNTGroupCollectionEnum()
//              CWinNTGroupCollectionEnum::CWinNTGroupCollectionEnum
//              CWinNTGroupCollectionEnum::EnumObjects
//              CWinNTGroupCollectionEnum::EnumObjects
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTGroupCollectionEnum::Create(
    CWinNTGroupCollectionEnum FAR* FAR* ppenumvariant,
    BSTR Parent,
    ULONG ParentType,
    BSTR ADsPath,
    BSTR DomainName,
    BSTR ServerName,
    BSTR GroupName,
    ULONG GroupType,
    VARIANT var,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CWinNTGroupCollectionEnum FAR* penumvariant = NULL;

    *ppenumvariant = NULL;

    penumvariant = new CWinNTGroupCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( Parent, &penumvariant->_Parent);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( DomainName, &penumvariant->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName, &penumvariant->_ServerName);
    BAIL_ON_FAILURE(hr);

    penumvariant->_ParentType = ParentType;

    hr = ADsAllocString(ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( GroupName, &penumvariant->_GroupName);
    BAIL_ON_FAILURE(hr);

    penumvariant->_GroupType = GroupType;


    hr = ObjectTypeList::CreateObjectTypeList(
                    var,
                    &penumvariant->_pObjList
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;
    hr = penumvariant->_Credentials.Ref(ServerName, DomainName, ParentType);
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    delete penumvariant;

    RRETURN_EXP_IF_ERR(hr);
}

CWinNTGroupCollectionEnum::CWinNTGroupCollectionEnum():
                                _Parent(NULL),
                                _ParentType(0),
                                _ADsPath(NULL),
                                _DomainName(NULL),
                                _ServerName(NULL),
                                _GroupName(NULL),
                                _lpServerName(NULL),
                                _hGroup(NULL)

{
    _pObjList = NULL;
}



CWinNTGroupCollectionEnum::CWinNTGroupCollectionEnum(ObjectTypeList ObjList):
                                _Parent(NULL),
                                _ParentType(0),
                                _ADsPath(NULL),
                                _DomainName(NULL),
                                _ServerName(NULL),
                                _GroupName(NULL),
                                _lpServerName(NULL),
                                _hGroup(NULL)
{
    _pObjList = NULL;
}

CWinNTGroupCollectionEnum::~CWinNTGroupCollectionEnum()
{

    if (_hGroup) {


        if (_GroupType == WINNT_GROUP_GLOBAL) {


            WinNTGlobalGroupClose(
                            _hGroup
                            );
        }else {

            WinNTLocalGroupClose(
                        _hGroup
                        );
        }

    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_DomainName) {
        ADsFreeString(_DomainName);
    }

    if (_ServerName) {
        ADsFreeString(_ServerName);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_GroupName) {
        ADsFreeString(_GroupName);
    }

    if (_pObjList) {

        delete _pObjList;
    }

    if (_lpServerName) {

        FreeADsStr(_lpServerName) ;
    }
}

HRESULT
CWinNTGroupCollectionEnum::EnumGroupMembers(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    IADs * pIADs = NULL;
    BSTR pszClass = NULL;
    DWORD dwClassID;
    DWORD dwFilterID;
    BOOL fFound = FALSE;

   
    while (i < cElements) {


        //
        // This is the global group case
        //
        hr = GetDomainMemberObject(&pDispatch);

        if (hr == S_FALSE) {
            break;
        }

        //
        // Apply the IADsMembers::put_Filter filter.
        // If the enumerated object is not one of the types to be returned,
        // go on to the next member of the group.
        //
        
        hr = pDispatch->QueryInterface(IID_IADs, (void **)&pIADs);
        BAIL_ON_FAILURE(hr);

        //
        // Determine the object class of the enumerated object and the corresponding
        // object class ID number (as specified in the Filters global array).
        //        
        hr = pIADs->get_Class(&pszClass);
        BAIL_ON_FAILURE(hr);

        hr = IsValidFilter(pszClass, &dwClassID, gpFilters, gdwMaxFilters);
        if (SUCCEEDED(hr)) {

            //
            // Enumerate through the object classes listed in the user-specified filter
            // until we either find a match (fFound = TRUE) or we reach the end of the
            // list.
            //
            hr = _pObjList->Reset();

            while (SUCCEEDED(hr)) {
                hr = _pObjList->GetCurrentObject(&dwFilterID);
                
                if (SUCCEEDED(hr)
                    && (dwFilterID == dwClassID)
                    ) {
                    fFound = TRUE;
                    break;
                }

                hr = _pObjList->Next();
            }

            if (!fFound) {
                // 
                // not on the list of objects to return, try again
                // with the next member of the group
                //
                pDispatch->Release();

                pIADs->Release();
                
                if (pszClass) {
                    ADsFreeString(pszClass);
                }
                
                continue;
            }

        }

        pIADs->Release();
        
        if (pszClass) {
            ADsFreeString(pszClass);
        }

        //
        // Return it.
        // 
        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN_EXP_IF_ERR(hr);

error:
    if (pDispatch) {
        pDispatch->Release();
    }

    if (pIADs) {
        pIADs->Release();
    }

    if (pszClass) {
        ADsFreeString(pszClass);
    }

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CWinNTGroupCollectionEnum::GetDomainMemberObject(
    IDispatch ** ppDispatch
    )
{

    HRESULT hr = S_OK;
    LPDOMAIN_GROUP_MEMBER pDomainGrpMember = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwReturned = 0;
    BOOL dwRet = 0;
    WCHAR szHostServerName[MAX_PATH];

    if (!_lpServerName) {

        hr = WinNTGetCachedDCName(
                        _DomainName,
                        szHostServerName,
                        _Credentials.GetFlags()
                        );

        BAIL_ON_FAILURE(hr);

        if (!(_lpServerName = AllocADsStr(szHostServerName))) {

            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY) ;

            BAIL_ON_FAILURE(hr);
        }
    }


    if (!_hGroup) {
        dwRet = WinNTGlobalGroupOpen(
                        _DomainName,
                        _lpServerName + 2, // skip the 2 leading back slashes
                        _GroupName,
                        &_hGroup
                        );
        if (!dwRet) {
            goto error;
        }
    }

    dwRet = WinNTGlobalGroupEnum(
                    _hGroup,
                    1,
                    &pBuffer,
                    &dwReturned
                    );
    if (!dwRet) {
        goto error;
    }

    pDomainGrpMember = (LPDOMAIN_GROUP_MEMBER)pBuffer;

    switch (pDomainGrpMember->Type) {
    case WINNT_USER_ID :
        hr = CWinNTUser::CreateUser(
                            pDomainGrpMember->Parent,
                            WINNT_DOMAIN_ID,
                            pDomainGrpMember->Domain,
                            NULL,
                            pDomainGrpMember->Name,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppDispatch
                            );
        break;

    case WINNT_GROUP_ID:
        hr = CWinNTGroup::CreateGroup(
                            pDomainGrpMember->Parent,
                            WINNT_DOMAIN_ID,
                            pDomainGrpMember->Domain,
                            NULL,
                            pDomainGrpMember->Name,
                            WINNT_GROUP_GLOBAL,
                            ADS_OBJECT_BOUND,
                            IID_IDispatch,
                            _Credentials,
                            (void **)ppDispatch
                            );
        break;

    default:
        goto error;
    }

    BAIL_ON_FAILURE(hr);

    hr = S_OK;

cleanup:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }


    RRETURN(hr);


error:

    *ppDispatch = NULL;

   hr = S_FALSE;

   goto cleanup;

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTGroupCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTGroupCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    if (NULL == pvar)
    {
        hr = S_FALSE;
    }
    else
    {
        hr = EnumGroupMembers(
                cElements,
                pvar,
                &cElementFetched
                );
    }

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenumjob.cxx ===
/*++

  Copyright (c) 1995  Microsoft Corporation

  Module Name:

  cenumjob.cxx

  Abstract:

  Contains methods for implementing the Enumeration of print jobs on a
  printer. Has methods for the CWinNTPrintJobsCollection object
  as well as the CWinNTJobsEnumVar object.

  Author:

  Ram Viswanathan (ramv) 11-28-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop

CWinNTPrintJobsCollection::CWinNTPrintJobsCollection()
{
    _pDispMgr = NULL;
    _pCJobsEnumVar = NULL;
    ENLIST_TRACKING(CWinNTPrintJobsCollection);
}

CWinNTPrintJobsCollection::~CWinNTPrintJobsCollection()
{
    DWORD fStatus;

    //
    // close the printer and destroy sub objects
    //
    if(_pszADsPrinterPath){
        FreeADsStr(_pszADsPrinterPath);
    }

    if(_pszPrinterName){
        FreeADsStr(_pszPrinterName);
    }

    if (_hPrinter){
        fStatus = ClosePrinter(_hPrinter);
    }

    delete _pDispMgr;

}

HRESULT
CWinNTPrintJobsCollection::Create(LPWSTR pszADsPrinterPath,
                                  CWinNTCredentials& Credentials,
                                  CWinNTPrintJobsCollection
                                  ** ppCWinNTPrintJobsCollection )
{

    BOOL fStatus = FALSE, LastError;
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE| READ_CONTROL};
    HRESULT hr;
    CWinNTPrintJobsCollection *pCWinNTJobsCollection = NULL;
    POBJECTINFO pObjectInfo = NULL;
    TCHAR szUncPrinterName[MAX_PATH];

    //
    // create the jobs collection object
    //

    pCWinNTJobsCollection = new CWinNTPrintJobsCollection();
    if(pCWinNTJobsCollection == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = BuildObjectInfo(pszADsPrinterPath,
                         &pObjectInfo
                         );

    BAIL_ON_FAILURE(hr);

    pCWinNTJobsCollection->_Credentials = Credentials;
    hr = pCWinNTJobsCollection->_Credentials.RefServer(
        pObjectInfo->ComponentArray[1]);
    BAIL_ON_FAILURE(hr);


    hr = PrinterNameFromObjectInfo(pObjectInfo,
                                   szUncPrinterName
                                   );

    BAIL_ON_FAILURE(hr);



    pCWinNTJobsCollection->_pszPrinterName =
        AllocADsStr(szUncPrinterName);

    if(!(pCWinNTJobsCollection->_pszPrinterName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pCWinNTJobsCollection->_pszADsPrinterPath =
        AllocADsStr(pszADsPrinterPath);

    if(!(pCWinNTJobsCollection->_pszADsPrinterPath)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // open printer and set the handle to the appropriate value
    //

    fStatus = OpenPrinter(szUncPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        LastError = GetLastError();

        switch (LastError) {
        case ERROR_ACCESS_DENIED:
        {
            PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
            fStatus = OpenPrinter(szUncPrinterName,
                                  &hPrinter,
                                  &PrinterDefaults
                                  );
            if (!fStatus) {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            break;
        }
        default:
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;

        }
    }

    BAIL_ON_FAILURE(hr);

    pCWinNTJobsCollection->_hPrinter = hPrinter;

    pCWinNTJobsCollection->_pDispMgr = new CAggregatorDispMgr;
    if (pCWinNTJobsCollection->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    hr = LoadTypeInfoEntry(pCWinNTJobsCollection->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsCollection,
                           (IADsCollection *)pCWinNTJobsCollection,
                           DISPID_NEWENUM
                           );

    BAIL_ON_FAILURE(hr);

    *ppCWinNTPrintJobsCollection =pCWinNTJobsCollection;

    if(pObjectInfo){
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN(hr);

error:
    delete pCWinNTJobsCollection;

    if(pObjectInfo){
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN_EXP_IF_ERR(hr);

}

/* IUnknown methods for jobs collection object  */

STDMETHODIMP
CWinNTPrintJobsCollection::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if(!ppvObj)
    {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsCollection))
    {
        *ppvObj = (IADsCollection FAR *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}


/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTPrintJobsCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsCollection)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

DEFINE_IDispatch_Implementation(CWinNTPrintJobsCollection);


     /* IADsCollection methods */


STDMETHODIMP
CWinNTPrintJobsCollection::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    CWinNTJobsEnumVar *pCJobsEnumVar = NULL;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = NULL;

    hr = CWinNTJobsEnumVar::Create(_hPrinter,
                                   _pszADsPrinterPath,
                                   _Credentials,
                                   &pCJobsEnumVar);

    if (FAILED(hr)) {
        goto error;
    }

    ADsAssert(pCJobsEnumVar);

    _pCJobsEnumVar = pCJobsEnumVar;

    hr = _pCJobsEnumVar->QueryInterface(IID_IUnknown,
                                        (void **)retval
                                        );

    BAIL_ON_FAILURE(hr);

    _pCJobsEnumVar->Release();

    RRETURN(S_OK);

error:
    delete pCJobsEnumVar;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTPrintJobsCollection::GetObject(THIS_ BSTR bstrJobName,
                                     VARIANT *pvar)
{
    HRESULT hr;
    DWORD dwJobId;
    IDispatch *pDispatch = NULL;


    if(!bstrJobName || !pvar){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    dwJobId = (DWORD)_wtol(bstrJobName);

    hr = CWinNTPrintJob::CreatePrintJob(_pszADsPrinterPath,
                                        dwJobId,
                                        ADS_OBJECT_BOUND,
                                        IID_IDispatch,
                                        _Credentials,
                                        (void **)&pDispatch);

    BAIL_IF_ERROR(hr);

    //
    // stick this IDispatch pointer into caller provided variant
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;

cleanup:
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTPrintJobsCollection::Add(THIS_ BSTR bstrName, VARIANT varNewItem)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTPrintJobsCollection::Remove(THIS_ BSTR bstrJobName)
{
    DWORD dwJobId;
    HRESULT hr = S_OK;
    HANDLE hPrinter = NULL;
    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};

    if(! bstrJobName){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    //
    // convert the job name into a jobid
    //

    dwJobId = (DWORD)_wtol(bstrJobName);

    fStatus = OpenPrinter((LPTSTR)_pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }


    //
    // use JOB_CONTROL_DELETE instead of JOB_CONTROL_CANCEL as DELETE works
    // even when a print job has been restarted while CANCEL won't
    //

    fStatus = SetJob (hPrinter,
                      dwJobId,
                      0,
                      NULL,
                      JOB_CONTROL_DELETE
                      );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;

    }

cleanup:

    if (hPrinter) {
        ClosePrinter(hPrinter);
    }

    RRETURN (hr);
}




//
// CWinNTJobsEnumVar methods follow
//

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::CWinNTJobsEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CWinNTJobsEnumVar::CWinNTJobsEnumVar()
{
    _pszADsPrinterPath = NULL;
    _pSafeArray = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;
    ENLIST_TRACKING(CWinNTJobsEnumVar);

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::~CWinNTJobsEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CWinNTJobsEnumVar::~CWinNTJobsEnumVar()
{
    if (_pSafeArray != NULL)
        SafeArrayDestroy(_pSafeArray);

    _pSafeArray = NULL;
    if(_pszADsPrinterPath){
        FreeADsStr(_pszADsPrinterPath);
    }
}


HRESULT CWinNTJobsEnumVar::Create(HANDLE hPrinter,
                                  LPTSTR szADsPrinterPath,
                                  CWinNTCredentials& Credentials,
                                  CWinNTJobsEnumVar ** ppCJobsEnumVar)
{

    //
    //  This function uses the handle to the printer to query for the
    // number of jobs(cJobs) on the printer, It uses the returned value
    // to create a safearray of cJobs number of Job Objects.
    //

    HRESULT hr;
    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE| READ_CONTROL};

    OBJECTINFO ObjectInfo;
    CLexer Lexer(szADsPrinterPath);

    CWinNTJobsEnumVar FAR* pCJobsEnumVar = NULL;

    *ppCJobsEnumVar = NULL;

    memset((void*)&ObjectInfo, 0, sizeof(OBJECTINFO));

    pCJobsEnumVar = new CWinNTJobsEnumVar();

    if (pCJobsEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pCJobsEnumVar->_pszADsPrinterPath = AllocADsStr(szADsPrinterPath);

    if (!(pCJobsEnumVar->_pszADsPrinterPath)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = Object(&Lexer, &ObjectInfo);
    BAIL_ON_FAILURE(hr);

    pCJobsEnumVar->_Credentials = Credentials;
    // We want the next-to-last element in the array.
    ADsAssert(ObjectInfo.NumComponents >= 2);
    hr = pCJobsEnumVar->_Credentials.RefServer(
        ObjectInfo.ComponentArray[(ObjectInfo.NumComponents - 1) - 1]);
    BAIL_ON_FAILURE(hr);

    //
    // Fill in the safearray with relevant information here
    //

    hr = FillSafeArray(hPrinter, szADsPrinterPath, pCJobsEnumVar->_Credentials,
        pCJobsEnumVar);

    BAIL_ON_FAILURE(hr);

    *ppCJobsEnumVar = pCJobsEnumVar;

    //
    // Free the objectInfo data
    //
    FreeObjectInfo( &ObjectInfo, TRUE );
    RRETURN(S_OK);

error:

    //
    // Free the objectInfo data
    //
    FreeObjectInfo( &ObjectInfo, TRUE );
    delete pCJobsEnumVar;
    RRETURN_EXP_IF_ERR(hr);


}



//+------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTJobsEnumVar::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    if(!ppv){
        RRETURN(E_POINTER);
    }
    *ppv = NULL;

    if (iid == IID_IUnknown )
    {
        *ppv = this;
    }
    else if(iid == IID_IEnumVARIANT)
    {
        *ppv = (IEnumVARIANT *)this;
    }

    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Job objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTJobsEnumVar::Next(ULONG ulNumElementsRequested,
                        VARIANT FAR* pvar,
                        ULONG FAR* pulNumFetched)
{

    HRESULT hresult;
    ULONG l;
    LONG lNewCurrent;
    ULONG lNumFetched;


    if (pulNumFetched != NULL)
        *pulNumFetched = 0;

    //
    // Check the out parameter to ensure it is valid
    //
    if (!pvar)
    {
        //
        // Returning S_FALSE to indicate that we aren't returning
        // as many elements as requested.
        //
        return(S_FALSE);
    }

    //
    // Initialize the elements to be returned
    //

    for (l=0; l<ulNumElementsRequested; l++)
        VariantInit(&pvar[l]);

    //
    // Get each element and place it into the return array
    // Don't request more than we have
    //

    for (lNewCurrent=_lCurrentPosition, lNumFetched=0;
         lNewCurrent<(LONG)(_lLBound+_cElements) &&
         lNumFetched < ulNumElementsRequested;
         lNewCurrent++, lNumFetched++){

        hresult = SafeArrayGetElement(_pSafeArray, &lNewCurrent,
                                      &pvar[lNumFetched]);
        //
        // Something went wrong!!!
        //

        if (FAILED(hresult)){
            for (l=0; l<ulNumElementsRequested; l++)
                VariantClear(&pvar[l]);

            ADsAssert(hresult == S_FALSE);
            return(S_FALSE);

        }                               // End of If Failed
    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //

    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;

    _lCurrentPosition = lNewCurrent;

    //
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //

    return (lNumFetched < ulNumElementsRequested) ?
        S_FALSE
            : S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTJobsEnumVar::Skip(ULONG cElements)
{
    //
    // Skip the number of elements requested
    //

    _lCurrentPosition += cElements;

    //
    // if we went outside of the boundaries unskip
    //

    if (_lCurrentPosition > (LONG)(_lLBound +_cElements)){
        _lCurrentPosition =  _lLBound +_cElements;
        return (S_FALSE);
    }
    else
        RRETURN(S_OK);

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTJobsEnumVar::Reset()
{
    //
    //Just move the CurrentPosition to the lower array boundary
    //

    _lCurrentPosition = _lLBound;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTJobsEnumVar::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTJobsEnumVar::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


HRESULT FillSafeArray(HANDLE hPrinter,
                      LPTSTR szPrinterPath,
                      CWinNTCredentials& Credentials,
                      CWinNTJobsEnumVar *pJobsEnumVar )
{
    BOOL fStatus = FALSE;
    DWORD   dwPassed =0, dwNeeded = 0;
    DWORD   dwcJobs;            // Number of jobs in print queue
    LPPRINTER_INFO_2 pPrinterInfo2;
    DWORD   dwError = 0, LastError =0;
    LPBYTE  pMem    = NULL;
    LPBYTE  lpbJobs = NULL;
    DWORD   cbBuf =0;
    DWORD   dwReturned =0;
    CWinNTPrintJob *pCWinNTPrintJob = NULL;
    SAFEARRAYBOUND sabound[1];
    IDispatch *pDispatch;
    VARIANT v;
    LONG l;
    HRESULT hr = S_OK;
    LPJOB_INFO_1 lpJobInfo1 = NULL;

    if(hPrinter == NULL){
        RRETURN_EXP_IF_ERR(HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE));
    }

    VariantInit(&v);

    //
    // First Get info from  printer to determine the number of jobs.
    // AjayR: 10-01-99. We always expect this call to fail but tell
    // us how much memory is needed !!!
    //

    fStatus = GetPrinter(hPrinter,
                         2,
                         (LPBYTE)pMem,
                         dwPassed,
                         &dwNeeded
                         );

    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {
        case ERROR_INSUFFICIENT_BUFFER:
            if (pMem){
                FreeADsMem(pMem);
            }
            dwPassed = dwNeeded;
            pMem = (LPBYTE)AllocADsMem(dwPassed);

            if (!pMem) {

                hr = E_OUTOFMEMORY;
                break;
            }

            fStatus = GetPrinter(hPrinter,
                                 2,
                                 (LPBYTE)pMem,
                                 dwPassed,
                                 &dwNeeded
                                 );
            if (!fStatus) {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            break;

        default:
            hr = HRESULT_FROM_WIN32(GetLastError());;
            break;

        }
    }

    if(FAILED(hr))
        goto error;

    pPrinterInfo2 =(LPPRINTER_INFO_2)pMem;
    dwcJobs = pPrinterInfo2->cJobs;

    fStatus = MyEnumJobs(hPrinter,
                         0,                          // First job you want
                         dwcJobs,
                         1,                          //Job Info level
                         &lpbJobs,
                         &cbBuf,
                         &dwReturned
                         );

    if(!fStatus){
        hr =HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    //
    // Use the array bound as the number of jobs returned, not
    // the number of jobs you requested, this may have changed!
    //

    sabound[0].cElements = dwReturned;
    sabound[0].lLbound = 0;

    //
    // Create a one dimensional SafeArray
    //

    pJobsEnumVar->_pSafeArray  = SafeArrayCreate(VT_VARIANT, 1, sabound);

    if (pJobsEnumVar->_pSafeArray == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    //
    // for each of the Jobs retrieved create the appropriate structure
    //

    for(l=0; l<(LONG)dwReturned; l++){

        lpJobInfo1 = (LPJOB_INFO_1)(lpbJobs +l*sizeof(JOB_INFO_1));

        hr = CWinNTPrintJob::CreatePrintJob(
                                    szPrinterPath,
                                    lpJobInfo1->JobId,
                                    ADS_OBJECT_BOUND,
                                    IID_IDispatch,
                                    Credentials,
                                    (void **)&pDispatch
                                    );

        if(FAILED(hr)){
            break;
        }

        VariantInit(&v);
        V_VT(&v) = VT_DISPATCH;
        V_DISPATCH(&v) = pDispatch;

        //
        // Stick the caller provided data into the end of the SafeArray
        //

        hr = SafeArrayPutElement(pJobsEnumVar->_pSafeArray, &l, &v);
        VariantClear(&v);

        if (FAILED(hr)){
            break;
        }
        pJobsEnumVar->_cElements++;

    }

    BAIL_ON_FAILURE(hr);


    if (pMem) {
        FreeADsMem(pMem);
    }

    if(lpbJobs){
        FreeADsMem(lpbJobs);
    }

    RRETURN(S_OK);


error:
    if (pMem) {
        FreeADsMem(pMem);
    }

    //
    // Free the buffer you just allocated
    //

    if (lpbJobs){
        FreeADsMem(lpbJobs);
    }

    //
    // Destroy the safearray
    //

    if(pJobsEnumVar->_pSafeArray != NULL)
        SafeArrayDestroy(pJobsEnumVar->_pSafeArray);

    VariantClear(&v);
    RRETURN_EXP_IF_ERR(hr);
}



BOOL
MyEnumJobs(HANDLE hPrinter,
           DWORD  dwFirstJob,
           DWORD  dwNoJobs,
           DWORD  dwLevel,
           LPBYTE *lplpbJobs,
           DWORD  *pcbBuf,
           LPDWORD lpdwReturned
           )
{

    BOOL fStatus = FALSE;
    DWORD   dwNeeded = 0;
    DWORD   dwError = 0;


    fStatus = EnumJobs(hPrinter,
                       dwFirstJob,
                       dwNoJobs,
                       dwLevel,
                       *lplpbJobs,
                       *pcbBuf,
                       &dwNeeded,
                       lpdwReturned
                       );


    if (!fStatus) {
        if ((dwError = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) {

            if (*lplpbJobs) {
                FreeADsMem( *lplpbJobs );
            }

            *lplpbJobs = (LPBYTE)AllocADsMem(dwNeeded);

            if (!*lplpbJobs) {
                *pcbBuf = 0;
                return(FALSE);
            }

            *pcbBuf = dwNeeded;


            fStatus = EnumJobs(hPrinter,
                               dwFirstJob,
                               dwNoJobs,
                               dwLevel,
                               *lplpbJobs,
                               *pcbBuf,
                               &dwNeeded,
                               lpdwReturned
                               );

            if (!fStatus) {
                return(FALSE);

            }else {
                return(TRUE);
            }
        }else {
            return(FALSE);
        }
    }else {
        return(TRUE);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenumses.cxx ===
/*++

  Copyright (c) 1996  Microsoft Corporation

  Module Name:

  cenumses.cxx

  Abstract:

  Contains methods for implementing the Enumeration of session on a
  server. Has methods for the CWinNTSessionsCollection object
  as well as the CWinNTSessionsEnumVar object.

  Author:

  Ram Viswanathan (ramv) 11-28-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop

#if DBG
DECLARE_INFOLEVEL(EnumSession);
DECLARE_DEBUG(EnumSession);
#define EnumSessionDebugOut(x) EnumSessionInlineDebugOut x
#endif


CWinNTSessionsCollection::CWinNTSessionsCollection()
{
    _pszServerADsPath = NULL;
    _pszServerName = NULL;
    _pszClientName = NULL;
    _pszUserName = NULL;
    _pDispMgr = NULL;
    _pCSessionsEnumVar = NULL;
    ENLIST_TRACKING(CWinNTSessionsCollection);
}

CWinNTSessionsCollection::~CWinNTSessionsCollection()
{

    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszClientName){
        FreeADsStr(_pszClientName);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }

    delete _pDispMgr;
    if(_pCSessionsEnumVar){
        _pCSessionsEnumVar->Release();
    }

}

HRESULT
CWinNTSessionsCollection::Create(LPTSTR pszServerADsPath,
                                 LPTSTR pszClientName,
                                 LPTSTR pszUserName,
                                 CWinNTCredentials& Credentials,
                                 CWinNTSessionsCollection
                                 ** ppCWinNTSessionsCollection )
{

    BOOL fStatus = FALSE;
    HRESULT hr;
    CWinNTSessionsCollection *pCWinNTSessionsCollection = NULL;
    POBJECTINFO  pServerObjectInfo = NULL;

    //
    // create the Sessions collection object
    //

    pCWinNTSessionsCollection = new CWinNTSessionsCollection();

    if(pCWinNTSessionsCollection == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCWinNTSessionsCollection->_pszServerADsPath =
        AllocADsStr(pszServerADsPath);

    if(!(pCWinNTSessionsCollection->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo
                         );
    BAIL_IF_ERROR(hr);

    pCWinNTSessionsCollection->_pszServerName = 
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCWinNTSessionsCollection->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCWinNTSessionsCollection->_Credentials = Credentials;
    hr = pCWinNTSessionsCollection->_Credentials.RefServer(
        pCWinNTSessionsCollection->_pszServerName);
    BAIL_IF_ERROR(hr);

    if (pszUserName){
        pCWinNTSessionsCollection->_pszUserName = 
            AllocADsStr(pszUserName);
        
        if(!(pCWinNTSessionsCollection->_pszUserName)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    if(pszClientName){
        pCWinNTSessionsCollection->_pszClientName = 
            AllocADsStr(pszClientName);
        
        if(!(pCWinNTSessionsCollection->_pszClientName)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    pCWinNTSessionsCollection->_pDispMgr = new CAggregatorDispMgr;
    if (pCWinNTSessionsCollection->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = LoadTypeInfoEntry(pCWinNTSessionsCollection->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsCollection,
                           (IADsCollection *)pCWinNTSessionsCollection,
                           DISPID_NEWENUM
                           );

    BAIL_IF_ERROR(hr);

    *ppCWinNTSessionsCollection = pCWinNTSessionsCollection;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }
    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }
    delete pCWinNTSessionsCollection;
    RRETURN_EXP_IF_ERR (hr);

}

/* IUnknown methods for Sessions collection object  */

STDMETHODIMP
CWinNTSessionsCollection::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IDispatch *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsCollection))
    {
        *ppvObj = (IADsCollection FAR *)this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTSessionsCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsCollection)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}


DEFINE_IDispatch_Implementation(CWinNTSessionsCollection);


/* IADsCollection methods */


STDMETHODIMP
CWinNTSessionsCollection::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    CWinNTSessionsEnumVar *pCSessionsEnumVar = NULL;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = NULL;

    hr = CWinNTSessionsEnumVar::Create(_pszServerADsPath,
                                       _pszClientName,
                                       _pszUserName,
                                       _Credentials,
                                       &pCSessionsEnumVar);

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCSessionsEnumVar);

    _pCSessionsEnumVar = pCSessionsEnumVar;

    hr = _pCSessionsEnumVar->QueryInterface(IID_IUnknown, (void **)retval);
    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:
    delete pCSessionsEnumVar;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTSessionsCollection::GetObject(THIS_ BSTR bstrSessionName, 
                                    VARIANT *pvar
                                    ) 

{
    LPTSTR  pszSession = NULL;
    LPTSTR pszUserName;
    LPTSTR pszClientName;
    IDispatch *pDispatch = NULL;
    HRESULT hr;

    if(!bstrSessionName || !pvar){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    pszSession = AllocADsStr(bstrSessionName);
    if(!pszSession){
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    hr = SplitIntoUserAndClient(pszSession, &pszUserName, &pszClientName);
    BAIL_IF_ERROR(hr);

    hr = CWinNTSession::Create(_pszServerADsPath,
                               pszClientName,
                               pszUserName,
                               ADS_OBJECT_BOUND,
                               IID_IDispatch,
                               _Credentials,
                               (void **)&pDispatch);  
    

    BAIL_IF_ERROR(hr);

    //
    // stick this IDispatch pointer into caller provided variant
    //
    
    VariantInit(pvar);
    V_VT(pvar) = VT_DISPATCH;
    V_DISPATCH(pvar) = pDispatch;

cleanup:
    FreeADsStr(pszSession);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP 
CWinNTSessionsCollection::Add(THIS_ BSTR bstrName, VARIANT varNewItem) 
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSessionsCollection::Remove(THIS_ BSTR bstrSessionName) 
{

    LPTSTR pszSession = NULL;
    LPTSTR pszUserName;
    LPTSTR pszClientName;
    TCHAR szUncClientName[MAX_PATH];
    TCHAR szUncServerName[MAX_PATH];
    HRESULT hr;
    NET_API_STATUS nasStatus;

    pszSession = AllocADsStr(bstrSessionName);
    if(!pszSession){
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    hr = SplitIntoUserAndClient(pszSession, &pszUserName, &pszClientName);
    BAIL_IF_ERROR(hr);

    hr = MakeUncName(_pszServerName, szUncServerName);
    BAIL_IF_ERROR(hr);

    hr = MakeUncName(pszClientName, szUncClientName);
    BAIL_IF_ERROR(hr);

    nasStatus  = NetSessionDel(szUncServerName,
                               szUncClientName,
                               pszUserName );

    if(nasStatus != NERR_Success){
        hr = HRESULT_FROM_WIN32(nasStatus);
    }


cleanup:
    FreeADsStr(pszSession);
    RRETURN_EXP_IF_ERR(hr);

}


//
// CWinNTSessionsEnumVar methods follow
//

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTSessionsEnumVar::CWinNTSessionsEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------
CWinNTSessionsEnumVar::CWinNTSessionsEnumVar()
{

    _pszServerName = NULL;
    _pszServerADsPath = NULL;
    _pszClientName = NULL;
    _pszUserName = NULL;
    _pbSessions = NULL;
    _cElements = 0;
    _lLBound = 0;
    _lCurrentPosition = _lLBound;
    _dwTotalEntries = 0;
    _dwResumeHandle = 0;

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTSessionsEnumVar::~CWinNTSessionsEnumVar
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:   11-22-95 RamV Created.
//
//----------------------------------------------------------------------------

CWinNTSessionsEnumVar::~CWinNTSessionsEnumVar()
{

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszClientName){
        FreeADsStr(_pszClientName);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }

    if(_pbSessions){
        NetApiBufferFree(_pbSessions);
    }
}


HRESULT CWinNTSessionsEnumVar::Create(LPTSTR pszServerADsPath,
                                      LPTSTR pszClientName,
                                      LPTSTR pszUserName,
                                      CWinNTCredentials& Credentials,
                                      CWinNTSessionsEnumVar \
                                      **ppCSessionsEnumVar)
{

    HRESULT hr;
    BOOL fStatus = FALSE;
    POBJECTINFO  pServerObjectInfo = NULL;
    CWinNTSessionsEnumVar FAR* pCSessionsEnumVar = NULL;

    *ppCSessionsEnumVar = NULL;

    pCSessionsEnumVar = new CWinNTSessionsEnumVar();

    if (pCSessionsEnumVar == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    pCSessionsEnumVar->_pszServerADsPath = 
        AllocADsStr(pszServerADsPath);

    if(!(pCSessionsEnumVar->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo
                         );
    BAIL_IF_ERROR(hr);

    pCSessionsEnumVar->_pszServerName = 
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCSessionsEnumVar->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCSessionsEnumVar->_Credentials = Credentials;
    hr = pCSessionsEnumVar->_Credentials.RefServer(
        pCSessionsEnumVar->_pszServerName);
    BAIL_IF_ERROR(hr);

    if(pszClientName){

        pCSessionsEnumVar->_pszClientName = 
            AllocADsStr(pszClientName);

        if(!(pCSessionsEnumVar->_pszClientName)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

    }

    if(pszUserName){
        pCSessionsEnumVar->_pszUserName = 
            AllocADsStr(pszUserName);

        if(!(pCSessionsEnumVar->_pszUserName)){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    *ppCSessionsEnumVar = pCSessionsEnumVar;

cleanup:
    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCSessionsEnumVar;
    RRETURN_EXP_IF_ERR(hr);
    
    
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTSessionsEnumVar::Next
//
//  Synopsis:   Returns cElements number of requested Session objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-27-95   RamV     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTSessionsEnumVar::Next(ULONG ulNumElementsRequested,
                            VARIANT FAR* pvar,
                            ULONG FAR* pulNumFetched)
{

    HRESULT hresult;
    ULONG ulIndex;
    LONG lNewCurrent;
    ULONG lNumFetched;
    LPSESSION_INFO_1 lpSessionInfo;
    IDispatch * pDispatch = NULL;
    LPTSTR pszClientName = NULL;
    LPTSTR pszUserName = NULL;

    if (pulNumFetched != NULL){
        *pulNumFetched = 0;
    }

    if (NULL == pvar)
    {
        RRETURN(S_FALSE);
    }

    //
    // Initialize the elements to be returned
    //

    for (ulIndex= 0; ulIndex < ulNumElementsRequested; ulIndex++){
        VariantInit(&pvar[ulIndex]);
    }

    if(!_pbSessions || (_lCurrentPosition == _lLBound +(LONG)_cElements) ){
        if (_pbSessions){
            NetApiBufferFree(_pbSessions);
            _pbSessions = NULL;
        }

        if(_dwTotalEntries == _cElements && (_dwTotalEntries !=0)){
            //
            // we got all elements already, no need to do another call
            //
            RRETURN(S_FALSE);
        }

        hresult = WinNTEnumSessions(_pszServerName,
                                    _pszClientName,
                                    _pszUserName,
                                    &_cElements,
                                    &_dwTotalEntries,
                                    &_dwResumeHandle,
                                    &_pbSessions
                                    );

        if(hresult == S_FALSE){
            RRETURN(S_FALSE);
        }
        _lLBound = 0;
        _lCurrentPosition = _lLBound;

    }

    //
    // Get each element and place it into the return array
    // Don't request more than we have
    //

    for (lNewCurrent=_lCurrentPosition, lNumFetched=0;
         lNewCurrent<(LONG)(_lLBound+_cElements) &&
         lNumFetched < ulNumElementsRequested;
         lNewCurrent++, lNumFetched++){

        lpSessionInfo = (LPSESSION_INFO_1)(_pbSessions +
                                           lNewCurrent*sizeof(SESSION_INFO_1));

        pszClientName = lpSessionInfo->sesi1_cname;
        pszUserName = lpSessionInfo->sesi1_username;

        hresult = CWinNTSession::Create(_pszServerADsPath,
                                        pszClientName,
                                        pszUserName,
                                        ADS_OBJECT_BOUND,
                                        IID_IDispatch,
                                        _Credentials,
                                        (void **)&pDispatch);


        BAIL_ON_FAILURE(hresult);

        V_VT(&(pvar[lNumFetched])) = VT_DISPATCH;
        V_DISPATCH(&(pvar[lNumFetched])) = pDispatch;

    }

    //
    // Tell the caller how many we got (which may be less than the number
    // requested), and save the current position
    //

    if (pulNumFetched != NULL)
        *pulNumFetched = lNumFetched;

    _lCurrentPosition = lNewCurrent;

    //
    // If we're returning less than they asked for return S_FALSE, but
    // they still have the data (S_FALSE is a success code)
    //

    return (lNumFetched < ulNumElementsRequested) ?
        S_FALSE
            : S_OK;

error:
#if DBG
    if(FAILED(hresult)){
        EnumSessionDebugOut((DEB_TRACE,
                            "hresult Failed with value: %ld \n", hresult ));
    }
#endif

    RRETURN(S_FALSE);
}

HRESULT
WinNTEnumSessions(LPTSTR pszServerName,
                  LPTSTR pszClientName,
                  LPTSTR pszUserName,
                  PDWORD pdwEntriesRead,
                  PDWORD pdwTotalEntries,
                  PDWORD pdwResumeHandle,
                  LPBYTE * ppMem
                  )

{

    NET_API_STATUS nasStatus;

    UNREFERENCED_PARAMETER(pszClientName);
    UNREFERENCED_PARAMETER(pszUserName);

    //
    // why have these parameters if they are unreferenced? Because we might
    // use them in the future when more complicated enumerations are desired
    //

    nasStatus = NetSessionEnum(pszServerName,
                               NULL,
                               NULL,
                               1,  //info level desired
                               ppMem,
                               MAX_PREFERRED_LENGTH,
                               pdwEntriesRead,
                               pdwTotalEntries,
                               pdwResumeHandle);

    if(*ppMem == NULL || (nasStatus != NERR_Success)){
        //
        //no more entries returned by sessions
        //
        RRETURN(S_FALSE);
    }


    RRETURN(S_OK);

}



//
// helper functions
//

HRESULT
SplitIntoUserAndClient(LPTSTR   pszSession,
                       LPTSTR * ppszUserName,
                       LPTSTR * ppszClientName
                       )

{

    HRESULT hr = S_OK;
    int i=0;

    //
    //  assumption: Valid strings are passed to this function
    //  i.e. bstrSession is valid
    //  we have the format username\clientname
    //  suppose we have no username then it is "\clientname"
    //  suppose we dont have clientname it is username\


    *ppszUserName = pszSession;
    *ppszClientName = pszSession;


    if((*ppszClientName = _tcschr(pszSession, TEXT('\\')))== NULL)
       {
           //
           // invalid name specified
           //

           RRETURN(E_FAIL);
       }
     **ppszClientName = TEXT('\0');
    (*ppszClientName)++;
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenumusr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  Windows NT 3.5 GroupCollection Enumeration Code
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

#define BASE_BUFFER_SIZE (4096 * sizeof(WCHAR))

CWinNTUserGroupsCollectionEnum::CWinNTUserGroupsCollectionEnum():
                                _ParentType(0),
                                _ParentADsPath(NULL),
                                _DomainName(NULL),
                                _ServerName(NULL),
                                _UserName(NULL),
                                _pGlobalBuffer(NULL),
                                _pLocalBuffer(NULL),
                                _dwCurrent(0),
                                _dwTotal(0),
                                _dwGlobalTotal(0),
                                _dwLocalTotal(0),
                                _fIsDomainController(FALSE)
{
    VariantInit(&_vFilter);
}

CWinNTUserGroupsCollectionEnum::~CWinNTUserGroupsCollectionEnum()
{
    if (_ParentADsPath)
        ADsFreeString(_ParentADsPath);
    if (_DomainName)
        ADsFreeString(_DomainName);
    if (_ServerName)
        ADsFreeString(_ServerName);
    if (_UserName)
        ADsFreeString(_UserName);
    if (_pGlobalBuffer)
        NetApiBufferFree(_pGlobalBuffer);
    if (_pLocalBuffer)
        NetApiBufferFree(_pLocalBuffer);
    VariantClear(&_vFilter);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTUserGroupsCollectionEnum::Create(
    CWinNTUserGroupsCollectionEnum FAR* FAR* ppenumvariant,
    ULONG ParentType,
    BSTR ParentADsPath,
    BSTR DomainName,
    BSTR ServerName,
    BSTR UserName,
    VARIANT vFilter,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = NOERROR;
    CWinNTUserGroupsCollectionEnum FAR* penumvariant = NULL;    
    WCHAR szServer[MAX_PATH];
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdomainInfo = NULL; 
    DWORD dwResult = ERROR_SUCCESS;

    //
    // Should the checks below be assertions?
    //

    if (!ppenumvariant)
        return E_FAIL;

    if (ParentType != WINNT_DOMAIN_ID &&
        ParentType != WINNT_COMPUTER_ID)
        return E_FAIL;

    *ppenumvariant = NULL;

    penumvariant = new CWinNTUserGroupsCollectionEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    penumvariant->_ParentType = ParentType;

    hr = ADsAllocString(ParentADsPath , &penumvariant->_ParentADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(DomainName, &penumvariant->_DomainName);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString(ServerName, &penumvariant->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(UserName, &penumvariant->_UserName);
    BAIL_ON_FAILURE(hr);

    //
    // We currently copy the filter but do nothing with it!!!
    //

    hr = VariantCopy(&penumvariant->_vFilter, &vFilter);
    BAIL_ON_FAILURE(hr);

    // check if the server is a DC
    hr = MakeUncName(ServerName, szServer);
    BAIL_ON_FAILURE(hr);    

    dwResult = DsRoleGetPrimaryDomainInformation(
                                     szServer,                      
                                     DsRolePrimaryDomainInfoBasic,   // InfoLevel
                                     (PBYTE*)&pdomainInfo            // pBuffer
                                   );    
    hr = HRESULT_FROM_WIN32(dwResult);
    BAIL_ON_FAILURE(hr);

    if( (pdomainInfo->MachineRole == DsRole_RoleBackupDomainController) ||
        (pdomainInfo->MachineRole == DsRole_RolePrimaryDomainController) ) {
        penumvariant->_fIsDomainController = TRUE;
    }
    else
        penumvariant->_fIsDomainController = FALSE;

    hr = penumvariant->DoEnumeration();
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;
    hr = penumvariant->_Credentials.Ref(ServerName, DomainName, ParentType);
    BAIL_ON_FAILURE(hr);

    if ( pdomainInfo )
    {
        DsRoleFreeMemory(pdomainInfo);
    }

    *ppenumvariant = penumvariant;
    RRETURN(hr);

error:
    delete penumvariant;

    if ( pdomainInfo )
    {
        DsRoleFreeMemory(pdomainInfo);
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTUserGroupsCollectionEnum::DoEnumeration()
{
    HRESULT hr;

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = DoGlobalEnumeration();
        BAIL_ON_FAILURE(hr);

        hr = DoLocalEnumeration();

    } else if (_ParentType == WINNT_COMPUTER_ID) {

        // We also want to try and get the global groups,
        // as this will be empty if the user does not belong to
        // any global groups.
        // We need to be careful on where we fail as we should
        // continue enumerating local groups for lots of cases.
        hr = DoGlobalEnumeration();

        if ((hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
             || (hr == HRESULT_FROM_WIN32(NERR_InvalidComputer))
             || (hr == HRESULT_FROM_WIN32(NERR_UserNotFound))
             || (hr == E_FAIL)) {
            hr = S_OK;
            _dwGlobalTotal = 0;
        }

        BAIL_ON_FAILURE(hr);

        hr = DoLocalEnumeration();

    } else {
        hr = E_FAIL;
    }
error:
    _dwTotal = _dwGlobalTotal + _dwLocalTotal;
    RRETURN(hr);
}

HRESULT
CWinNTUserGroupsCollectionEnum::DoGlobalEnumeration()
{
    HRESULT hr;
    DWORD dwStatus;
    DWORD dwRead = 0;
    WCHAR szServer[MAX_PATH];
    LPGROUP_USERS_INFO_0 pGroupUserInfo = NULL;
    GROUP_INFO_2 *pGroupInfo2 = NULL;
    NET_API_STATUS nasStatus; 

    hr = MakeUncName(_ServerName, szServer);
    BAIL_ON_FAILURE(hr);

    dwStatus = NetUserGetGroups(szServer,
                                _UserName,
                                0,
                                (LPBYTE*)&_pGlobalBuffer,
                                MAX_PREFERRED_LENGTH,
                                &dwRead,
                                &_dwGlobalTotal);
    hr = HRESULT_FROM_WIN32(dwStatus);
    BAIL_ON_FAILURE(hr);

    if (dwRead != _dwGlobalTotal)
        hr = E_FAIL;

    if (dwRead == 1) {
    //
    // Check if it is the none group - dont want that
    //
    pGroupUserInfo = (LPGROUP_USERS_INFO_0)_pGlobalBuffer;
    if ( pGroupUserInfo->grui0_name && (FALSE == _fIsDomainController) &&
         (1 == _dwGlobalTotal) ) {
    // check if this the none group. Only non-DCs will return this group.
        
        nasStatus = NetGroupGetInfo(
                 szServer,
                 pGroupUserInfo->grui0_name,
                 2,
                 (LPBYTE *) &pGroupInfo2
                 );
        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);
                 
        if (pGroupInfo2->grpi2_group_id == DOMAIN_GROUP_RID_USERS) {

            //
            // Set the global total to zero - destructor will dealloc.
            //
            _dwGlobalTotal = 0;
        }
    }
}


error:
    if(pGroupInfo2)
        NetApiBufferFree(pGroupInfo2);

    RRETURN(hr);
}

HRESULT
CWinNTUserGroupsCollectionEnum::DoLocalEnumeration()
{
    HRESULT hr;
    DWORD dwStatus;
    DWORD dwRead = 0;
    WCHAR szServer[MAX_PATH];

    hr = MakeUncName(_ServerName, szServer);
    BAIL_ON_FAILURE(hr);

    dwStatus = NetUserGetLocalGroups(szServer,
                                     _UserName,
                                     0,
                                     0,
                                     (LPBYTE*)&_pLocalBuffer,
                                     MAX_PREFERRED_LENGTH,
                                     &dwRead,
                                     &_dwLocalTotal);
    hr = HRESULT_FROM_WIN32(dwStatus);
    BAIL_ON_FAILURE(hr);

    if (dwRead != _dwLocalTotal)
        hr = E_FAIL;

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTUserGroupsCollectionEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTUserGroupsCollectionEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    if (NULL == pvar)
    {
        //
        // Returning S_FALSE to indicate that we aren't returning
        // as many elements as requested.
        //
        hr = S_FALSE;
    }
    else
    {
        hr = EnumUserGroups(
                cElements,
                pvar,
                &cElementFetched
                );
    }

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUserGroupsCollectionEnum::Skip(ULONG cElements)
{
    //
    // Note: we better not wrap around when we add!
    //

    _dwCurrent += cElements;
    _dwCurrent = min(_dwTotal, _dwCurrent);

    if (_dwCurrent < _dwTotal)
        return S_OK;
    return S_FALSE;
}

STDMETHODIMP
CWinNTUserGroupsCollectionEnum::Reset()
{
    _dwCurrent = 0;
    return S_OK;
}

HRESULT
CWinNTUserGroupsCollectionEnum::EnumUserGroups(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements) {

        hr = GetNextUserGroup(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN(hr);
}

HRESULT
CWinNTUserGroupsCollectionEnum::GetNextUserGroup(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr;
    LPGROUP_USERS_INFO_0 lpInfo;
    LPWSTR GroupName;
    ULONG GroupType;

    if (_dwCurrent >= _dwTotal)
        return S_FALSE;

    if (_dwCurrent < _dwGlobalTotal) {
        lpInfo = (LPGROUP_USERS_INFO_0)_pGlobalBuffer + _dwCurrent;
        GroupType = WINNT_GROUP_GLOBAL;
    } else {
        lpInfo = (LPGROUP_USERS_INFO_0)_pLocalBuffer + _dwCurrent -
            _dwGlobalTotal;
        GroupType = WINNT_GROUP_LOCAL;
    }

    _dwCurrent++;

    GroupName = lpInfo->grui0_name;

    //
    // On an error, should we try to keep going?
    //

	if (GroupType == WINNT_GROUP_GLOBAL) {
		hr = CWinNTGroup::CreateGroup(_ParentADsPath,
									  _ParentType,
									  _DomainName,
									  _ServerName,
									  GroupName,
									  GroupType,
									  ADS_OBJECT_BOUND,
									  IID_IDispatch,
									  _Credentials,
									  (void **)ppDispatch
									 );
	}
	else {
		hr = CWinNTGroup::CreateGroup(_ParentADsPath,
									  _ParentType,
									  _DomainName,
									  _ServerName,
									  GroupName,
									  GroupType,
									  ADS_OBJECT_BOUND,
									  IID_IDispatch,
									  _Credentials,
									  (void **)ppDispatch
									 );
	}
    if (FAILED(hr))
        return S_FALSE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenumns.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//             CWinNTNamespaceEnum::Create
//             CWinNTNamespaceEnum::CWinNTNamespaceEnum
//             CWinNTNamespaceEnum::~CWinNTNamespaceEnum
//             CWinNTNamespaceEnum::QueryInterface
//             CWinNTNamespaceEnum::AddRef
//             CWinNTNamespaceEnum::Release
//             CWinNTNamespaceEnum::Next
//             CWinNTNamespaceEnum::Skip
//             CWinNTNamespaceEnum::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTNamespaceEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CWinNTNamespaceEnum::Create(
    CWinNTNamespaceEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CWinNTNamespaceEnum FAR* penumvariant = NULL;

    penumvariant = new CWinNTNamespaceEnum();

    if (penumvariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;
    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:

    if (penumvariant) {
        delete penumvariant;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTNamespaceEnum::CWinNTNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CWinNTNamespaceEnum::CWinNTNamespaceEnum()
{
    _pObjList = NULL;
    _pBuffer = 0;
    _dwObjectReturned = 0;
    _dwObjectCurrentEntry = 0;
    _dwObjectTotal = 0;
    _dwResumeHandle = 0;
    _bNoMore = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTNamespaceEnum::~CWinNTNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CWinNTNamespaceEnum::~CWinNTNamespaceEnum()
{
    if (_pBuffer) {
        NetApiBufferFree(_pBuffer);
    }

    if ( _pObjList )
        delete _pObjList;
}


HRESULT
CWinNTNamespaceEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    HRESULT hr = S_OK;
    switch (ObjectType) {

    case WINNT_DOMAIN_ID:
        hr = EnumDomains(cElements, pvar, pcElementFetched);
        RRETURN(hr);

    default:
        RRETURN(S_FALSE);
    }
}

HRESULT
CWinNTNamespaceEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr = S_FALSE;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)  {
        VariantInit(&pvar[i]);
    }
    cRequested = cElements;

    while (SUCCEEDED(_pObjList->GetCurrentObject(&ObjectType)) &&
            ((hr = EnumObjects(ObjectType,
                               cRequested,
                               pPathvar,
                               &cFetchedByPath)) == S_FALSE )) {

        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if (FAILED(_pObjList->Next())){
            if (pcElementFetched)
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

    }

    if (pcElementFetched) {
        *pcElementFetched = cTotalFetched + cFetchedByPath;
    }

    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTNamespaceEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTNamespaceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    if (NULL == pvar)
    {
        //
        // Returning S_FALSE to indicate that we aren't returning
        // as many elements as requested.
        //
        hr = S_FALSE; 
    }
    else
    {
        hr = EnumObjects(
                cElements,
                pvar,
                &cElementFetched
                );
    }

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTNamespaceEnum::EnumDomains(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;
    BOOL fRepeat = FALSE;
    DWORD dwFailureCount = 0;
    DWORD dwPermitFailure = 1000;

    while (i < cElements) {

        hr = GetDomainObject(&pDispatch);
        if (hr == S_FALSE) {
            break;
        }
        else if (FAILED(hr)) {
            //
            // Got an error while retrieving the object, ignore the
            // error and continue with the next object.
            // If continuously getting error more than dwPermitFailure,
            // make the return value S_FALSE, leave the loop.            
            //            
            if (fRepeat) {
            	dwFailureCount++;
            	if(dwFailureCount > dwPermitFailure) {
            		hr = S_FALSE;
            		break;
            	}            	
            }
            else {
            	fRepeat = TRUE;
            	dwFailureCount = 1;
            }

            // we need to move the _dwObjectCurrentEntry
            _dwObjectCurrentEntry++;
            	                        
            hr = S_OK;
            continue;
        }

        if (fRepeat) {
        	fRepeat = FALSE;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTNamespaceEnum::GetDomainObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    PSERVER_INFO_100 pServerInfo100 = NULL;
    NET_API_STATUS nasStatus = 0;

    if (!_pBuffer || (_dwObjectCurrentEntry == _dwObjectReturned)) {

        if (_pBuffer) {
            NetApiBufferFree(_pBuffer);
            _pBuffer = NULL;
        }

        _dwObjectCurrentEntry = 0;
        _dwObjectReturned = 0;

        if (_bNoMore) {
            RRETURN(S_FALSE);
        }

        nasStatus = NetServerEnum(
                        NULL,
                        100,
                        (LPBYTE *)&_pBuffer,
                        MAX_PREFERRED_LENGTH,
                        &_dwObjectReturned,
                        &_dwObjectTotal,
                        SV_TYPE_DOMAIN_ENUM,
                        NULL,
                        &_dwResumeHandle
                        );

        //
        // The following if clause is to handle real errors; anything
        // other than ERROR_SUCCESS and ERROR_MORE_DATA
        //

        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)) {
            hr =S_FALSE;
            goto cleanup;
        }

        if (nasStatus == ERROR_SUCCESS) {
            _bNoMore = TRUE;
        }
    }

    //
    // Now send back the current object
    //

    //
    // There is a scenario where NetServerEnum returns ERROR_SUCCESS
    // when there is no data to send back. However the field
    // _dwObjectsReturned will also be 0. We need to check that and
    // bail out if necessary
    //

    if ((nasStatus == ERROR_SUCCESS) && _dwObjectReturned == 0){
        RRETURN(S_FALSE);
    }
    pServerInfo100 = (LPSERVER_INFO_100)_pBuffer;
    pServerInfo100 += _dwObjectCurrentEntry;

    //
    // We couldn't have any credentials coming in from a Namespace
    // enumeration, since you can't have credentials coming in from
    // a Namespace.  So we use null credentials.
    //
    hr = CWinNTDomain::CreateDomain(
                    L"WinNT:",
                    pServerInfo100->sv100_name,
                    ADS_OBJECT_BOUND,
                    IID_IDispatch,
                    _Credentials,
                    (void **) ppDispatch
                    );
    
    BAIL_IF_ERROR(hr);
    _dwObjectCurrentEntry++;

    RRETURN(S_OK);

cleanup:
    *ppDispatch = NULL;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 3.5 Enumerator Code
//
//             CWinNTEnumVariant::Create
//             CWinNTEnumVariant::CWinNTEnumVariant
//             CWinNTEnumVariant::~CWinNTEnumVariant
//             CWinNTEnumVariant::QueryInterface
//             CWinNTEnumVariant::AddRef
//             CWinNTEnumVariant::Release
//             CWinNTEnumVariant::Next
//             CWinNTEnumVariant::Skip
//             CWinNTEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::CWinNTEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CWinNTEnumVariant::CWinNTEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::~CWinNTEnumVariant
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CWinNTEnumVariant::~CWinNTEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CWinNTEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CWinNTEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTEnumVariant::Skip(ULONG cElements)
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTEnumVariant::Reset()
{

    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cfpnwses.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfpnwses.cxx
//
//  Contents:  Contains methods for the following objects
//             CFPNWSession, CFPNWSessionGeneralInfo
//
//
//  History:   02/08/96     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

DECLARE_INFOLEVEL( FPNWSession );
DECLARE_DEBUG( FPNWSession );
#define FPNWSessionDebugOut(x) FPNWSessionInlineDebugOut x


DEFINE_IDispatch_ExtMgr_Implementation(CFPNWSession);
DEFINE_IADsExtension_ExtMgr_Implementation(CFPNWSession);
DEFINE_IADs_TempImplementation(CFPNWSession)
DEFINE_IADs_PutGetImplementation(CFPNWSession, FPNWSessionClass, gdwFPNWSessionTableSize)
DEFINE_IADsPropertyList_Implementation(CFPNWSession, FPNWSessionClass, gdwFPNWSessionTableSize)


CFPNWSession::CFPNWSession()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pszServerName = NULL;
    _pszComputerName = NULL;
    _pszUserName  = NULL;
    _pPropertyCache = NULL;
    ENLIST_TRACKING(CFPNWSession);
    return;

}

CFPNWSession::~CFPNWSession()
{

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }
    if(_pszComputerName){
        FreeADsStr(_pszComputerName);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }
    delete _pPropertyCache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CFPNWSession::Create
//
//  Synopsis:   Static function used to create a Session object. This
//              will be called by EnumSessions::Next
//
//  Arguments:  [ppFPNWSession] -- Ptr to a ptr to a new Session object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
CFPNWSession::Create(LPTSTR pszServerADsPath,
                     PNWCONNECTIONINFO  pConnectionInfo,
                     DWORD  dwObject,
                     REFIID riid,
                     CWinNTCredentials& Credentials,
                     LPVOID * ppvoid
                     )

{

    CFPNWSession FAR * pCFPNWSession = NULL;
    HRESULT hr;
    TCHAR szSessionName[MAX_LONG_LENGTH];

    //
    // Create the Session Object
    //

    hr = AllocateSessionObject(pszServerADsPath,
                               pConnectionInfo,
                               &pCFPNWSession);

    BAIL_IF_ERROR(hr);

    ADsAssert(pCFPNWSession->_pDispMgr);


    _ltow(pConnectionInfo->dwConnectionId, szSessionName, 10);

    hr = pCFPNWSession->InitializeCoreObject(pszServerADsPath,
                                             szSessionName,
                                             SESSION_CLASS_NAME,
                                             FPNW_SESSION_SCHEMA_NAME,
                                             CLSID_FPNWSession,
                                             dwObject);

    BAIL_IF_ERROR(hr);

    pCFPNWSession->_dwConnectionId = pConnectionInfo->dwConnectionId;

    pCFPNWSession->_Credentials = Credentials;
    hr = pCFPNWSession->_Credentials.RefServer(pCFPNWSession->_pszServerName);
    BAIL_IF_ERROR(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                SESSION_CLASS_NAME,
                (IADs *) pCFPNWSession,
                pCFPNWSession->_pDispMgr,
                Credentials,
                &pCFPNWSession->_pExtMgr
                );
    BAIL_IF_ERROR(hr);

    ADsAssert(pCFPNWSession->_pExtMgr);


    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        // Session objects have "" as their ADsPath. Just set the class for
        // iddentification purposes.
        pCFPNWSession->_CompClasses[0] = L"Session";

        hr = pCFPNWSession->InitUmiObject(
                pCFPNWSession->_Credentials,
                FPNWSessionClass, 
                gdwFPNWSessionTableSize,
                pCFPNWSession->_pPropertyCache,
                (IUnknown *) (INonDelegatingUnknown *) pCFPNWSession,
                pCFPNWSession->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_IF_ERROR(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pCFPNWSession->QueryInterface(riid, (void **)ppvoid);
    BAIL_IF_ERROR(hr);

    pCFPNWSession->Release();

cleanup:

    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCFPNWSession;
    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CFPNWSession::AllocateSessionObject(LPTSTR pszServerADsPath,
                                    PNWCONNECTIONINFO pConnectionInfo,
                                    CFPNWSession ** ppSession
                                    )

{
    CFPNWSession FAR * pCFPNWSession = NULL;
    HRESULT hr = S_OK;
    POBJECTINFO pServerObjectInfo = NULL;

    pCFPNWSession = new CFPNWSession();
    if (pCFPNWSession == NULL) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCFPNWSession->_pDispMgr = new CAggregatorDispMgr;
    if (pCFPNWSession->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = LoadTypeInfoEntry(pCFPNWSession->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsSession,
                           (IADsSession *)pCFPNWSession,
                           DISPID_REGULAR);
    BAIL_IF_ERROR(hr);

    hr = LoadTypeInfoEntry(pCFPNWSession->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsPropertyList,
                           (IADsPropertyList *)pCFPNWSession,
                           DISPID_VALUE);
    BAIL_IF_ERROR(hr);


    pCFPNWSession->_pszServerADsPath =
        AllocADsStr(pszServerADsPath);

    if(!(pCFPNWSession->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo);
    BAIL_IF_ERROR(hr);

    pCFPNWSession->_pszServerName =
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCFPNWSession->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    //
    // GetInfo is not supported by the underlying API. So we
    // we will set all properties right here.
    //

    pCFPNWSession->_pszUserName =
        AllocADsStr(pConnectionInfo->lpUserName);

    if(!(pCFPNWSession->_pszUserName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    hr = FPNWSERVERADDRtoString(pConnectionInfo->WkstaAddress,
                                &(pCFPNWSession->_pszComputerName));

    BAIL_IF_ERROR(hr);


    pCFPNWSession->_dwConnectTime = pConnectionInfo ->dwLogonTime;


    hr = CPropertyCache::createpropertycache(
             FPNWSessionClass,
             gdwFPNWSessionTableSize,
             (CCoreADsObject *)pCFPNWSession,
             &(pCFPNWSession->_pPropertyCache)
             );

    BAIL_IF_ERROR(hr);

    pCFPNWSession->_pDispMgr->RegisterPropertyCache(
                              pCFPNWSession->_pPropertyCache
                              );

    *ppSession = pCFPNWSession;

cleanup:

    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if (!SUCCEEDED(hr)) {

        //
        // direct memeber assignement assignement at pt of creation, so
        // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
        // of deletion again in pPrintJob destructor and AV
        //

        delete pCFPNWSession;
    }

    RRETURN(hr);
}




/* IUnknown methods for session object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CFPNWSession::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWSession::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWSession::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWSession::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;
    
    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADs *) this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADs *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList *)this;
    }

    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsSession))
    {
        *ppvObj = (IADsSession FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CFPNWSession::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsSession) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   SetInfo on actual session
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    02/08/96    RamV  Created

//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWSession::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CFPNWSession::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
   HRESULT hr;

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("User"),
                                  _pszUserName,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Computer"),
                                  _pszComputerName,
                                  fExplicit
                                  );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("ConnectTime"),
                                  _dwConnectTime,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );


    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWSession::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(1,TRUE));
}

STDMETHODIMP
CFPNWSession::ImplicitGetInfo(THIS)
{

    RRETURN(GetInfo(1,FALSE));
}

STDMETHODIMP
CFPNWSession::get_User(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    //
    // UserName is set once and never modified,
    //
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }
    hr = ADsAllocString(_pszUserName, retval);
    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CFPNWSession::get_UserPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CFPNWSession::get_Computer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }
    hr = ADsAllocString(_pszComputerName, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWSession::get_ComputerPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CFPNWSession::get_ConnectTime(THIS_ LONG FAR* retval)
{
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    *retval = _dwConnectTime;

    RRETURN(S_OK);

}

STDMETHODIMP
CFPNWSession::get_IdleTime(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADs *)this, IdleTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cfpnwfsh.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cfpnwfsh.cxx
//
//  Contents:  Contains methods for the following objects
//             CFPNWFileShare, CFPNWFileShareGeneralInfo
//
//
//  History:   02/15/96     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

#if DBG
DECLARE_INFOLEVEL(FPNWFileShare );
DECLARE_DEBUG( FPNWFileShare);
#define FPNWFileShareDebugOut(x) FPNWFileShareInlineDebugOut x
#endif

DEFINE_IDispatch_ExtMgr_Implementation(CFPNWFileShare);
DEFINE_IADsExtension_ExtMgr_Implementation(CFPNWFileShare);
DEFINE_IADs_TempImplementation(CFPNWFileShare);
DEFINE_IADs_PutGetImplementation(CFPNWFileShare,FPNWFileShareClass,gdwFPNWFileShareTableSize);
DEFINE_IADsPropertyList_Implementation(CFPNWFileShare, FPNWFileShareClass,gdwFPNWFileShareTableSize);

CFPNWFileShare::CFPNWFileShare()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    ENLIST_TRACKING(CFPNWFileShare);
    _pszShareName = NULL;
    _pPropertyCache = NULL;
    return;

}

CFPNWFileShare::~CFPNWFileShare()
{
    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszShareName){
        FreeADsStr(_pszShareName);
    }
    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }

    delete _pPropertyCache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileShare::Create
//
//  Synopsis:   Static function used to create a FileShare object. This
//              will be called by EnumFileShares::Next
//
//  Arguments:  [ppFPNWFileShare] -- Ptr to a ptr to a new FileShare object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
CFPNWFileShare::Create(LPTSTR pszADsParent,
                        LPTSTR pszServerName,
                        LPTSTR pszServiceName,
                        LPTSTR pszShareName,
                        DWORD  dwObject,
                        REFIID riid,
                        CWinNTCredentials& Credentials,
                        LPVOID * ppvoid
                        )

{

    CFPNWFileShare FAR * pCFPNWFileShare = NULL;
    HRESULT hr;


    //
    // Create the FileShare Object
    //

    hr = AllocateFileShareObject(pszADsParent,
                                 pszServerName,
                                 pszServiceName,
                                 pszShareName,
                                 &pCFPNWFileShare );

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCFPNWFileShare->_pDispMgr);


    hr = pCFPNWFileShare->InitializeCoreObject(pszADsParent,
                                                pszShareName,
                                                FILESHARE_CLASS_NAME,
                                                FPNW_FILESHARE_SCHEMA_NAME,
                                                CLSID_FPNWFileShare,
                                                dwObject);

    BAIL_ON_FAILURE(hr);

    pCFPNWFileShare->_Credentials = Credentials;
    hr = pCFPNWFileShare->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                FILESHARE_CLASS_NAME,
                (IADs *) pCFPNWFileShare,
                pCFPNWFileShare->_pDispMgr,
                Credentials,
                &pCFPNWFileShare->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCFPNWFileShare->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(4 == pCFPNWFileShare->_dwNumComponents) {
            pCFPNWFileShare->_CompClasses[0] = L"Domain";
            pCFPNWFileShare->_CompClasses[1] = L"Computer";
            pCFPNWFileShare->_CompClasses[2] = L"FileService";
            pCFPNWFileShare->_CompClasses[3] = L"FileShare";
        }
        else if(3 == pCFPNWFileShare->_dwNumComponents) {
            pCFPNWFileShare->_CompClasses[0] = L"Computer";
            pCFPNWFileShare->_CompClasses[1] = L"FileService";
            pCFPNWFileShare->_CompClasses[2] = L"FileShare";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pCFPNWFileShare->InitUmiObject(
                pCFPNWFileShare->_Credentials,
                FPNWFileShareClass,
                gdwFPNWFileShareTableSize,
                pCFPNWFileShare->_pPropertyCache,
                (IUnknown *) (INonDelegatingUnknown *) pCFPNWFileShare,
                pCFPNWFileShare->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pCFPNWFileShare->QueryInterface(riid, (void **)ppvoid);
    BAIL_ON_FAILURE(hr);

    pCFPNWFileShare->Release();


    RRETURN(hr);

error:

    delete pCFPNWFileShare;
    RRETURN_EXP_IF_ERR (hr);

}

HRESULT
CFPNWFileShare::AllocateFileShareObject(LPTSTR pszADsParent,
                                         LPTSTR pszServerName,
                                         LPTSTR pszServiceName,
                                         LPTSTR pszShareName,
                                         CFPNWFileShare ** ppFileShare
                                         )
{

    CFPNWFileShare * pCFPNWFileShare = NULL;
    HRESULT hr;

    //
    // Create the FileShare Object
    //

    pCFPNWFileShare = new CFPNWFileShare();
    if (pCFPNWFileShare == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pCFPNWFileShare->_pDispMgr = new CAggregatorDispMgr;

    if(pCFPNWFileShare ->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr =  LoadTypeInfoEntry(pCFPNWFileShare->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsFileShare,
                            (IADsFileShare *)pCFPNWFileShare,
                            DISPID_REGULAR );


    BAIL_ON_FAILURE(hr);


    hr =  LoadTypeInfoEntry(pCFPNWFileShare->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsPropertyList,
                            (IADsPropertyList *)pCFPNWFileShare,
                            DISPID_VALUE );


    BAIL_ON_FAILURE(hr);



    pCFPNWFileShare->_pszServerName =
        AllocADsStr(pszServerName);

    if(!(pCFPNWFileShare->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pCFPNWFileShare->_pszShareName =
        AllocADsStr(pszShareName);

    if(!(pCFPNWFileShare->_pszShareName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    hr = CPropertyCache::createpropertycache(
             FPNWFileShareClass,
             gdwFPNWFileShareTableSize,
             (CCoreADsObject *)pCFPNWFileShare,
             &(pCFPNWFileShare ->_pPropertyCache)
             );

    pCFPNWFileShare->_pDispMgr->RegisterPropertyCache(
                                  pCFPNWFileShare->_pPropertyCache
                                  );


    *ppFileShare = pCFPNWFileShare;
    RRETURN(hr);

error:

    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete pCFPNWFileShare;

    RRETURN_EXP_IF_ERR(hr);

}


/* IUnknown methods for FileShare object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CFPNWFileShare::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWFileShare::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWFileShare::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWFileShare::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADs *) this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADs *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList *)this;
    }

    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileShare))
    {
        *ppvObj = (IADsFileShare FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}


/* ISupportErrorInfo method */
STDMETHODIMP
CFPNWFileShare::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsFileShare) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   SetInfo on actual Volume
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    02/08/96    RamV  Created

//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWFileShare::SetInfo(THIS)
{

    PNWVOLUMEINFO pVolumeInfo = NULL;
    HRESULT hr = S_OK;
    DWORD dwErrorCode;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = FPNWAddFileShare();
        BAIL_IF_ERROR(hr);
        SetObjectState(ADS_OBJECT_BOUND);
    }


    //
    // First get the information and modify only those fields which
    // have been changed by user
    //


    dwErrorCode = ADsNwVolumeGetInfo(_pszServerName,
                                     _pszShareName,
                                     1,
                                     &pVolumeInfo);

    hr = HRESULT_FROM_WIN32(dwErrorCode);
    BAIL_IF_ERROR(hr);

    hr = MarshallAndSet(pVolumeInfo);

    BAIL_IF_ERROR(hr);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:
    if(pVolumeInfo){
        ADsNwApiBufferFree(pVolumeInfo);
    }
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileShare::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    HRESULT hr = S_OK;
    DWORD dwErrorCode;
    PNWVOLUMEINFO pVolumeInfo = NULL;
    TCHAR szComputerPath[MAX_PATH];
    POBJECTINFO pObjectInfo = NULL;

    //
    // only level 1 is valid. This function is not exported so we
    // assert if not valid
    //

    ADsAssert(dwApiLevel == 1);

    dwErrorCode = ADsNwVolumeGetInfo(_pszServerName,
                                     _pszShareName,
                                     1,
                                     &pVolumeInfo);


    hr = HRESULT_FROM_WIN32(dwErrorCode);
    BAIL_IF_ERROR(hr);

    //
    // unmarshall the information
    //

    hr = BuildObjectInfo(_Parent, &pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = BuildComputerFromObjectInfo(pObjectInfo,
                                     szComputerPath);

    BAIL_IF_ERROR(hr);

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostComputer"),
                                  szComputerPath,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Path"),
                                  pVolumeInfo->lpPath,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("CurrentUserCount"),
                                 pVolumeInfo->dwCurrentUses,
                                 fExplicit
                                 );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("MaxUserCount"),
                                  pVolumeInfo->dwMaxUses,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    hr = S_OK;

cleanup:
    if(pVolumeInfo){
        ADsNwApiBufferFree(pVolumeInfo);
    }
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileShare::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(1,TRUE));
}

STDMETHODIMP
CFPNWFileShare::ImplicitGetInfo(THIS)
{

    RRETURN(GetInfo(1,FALSE));
}

HRESULT
CFPNWFileShare::FPNWAddFileShare(void)
{
    DWORD dwErrorCode;
    NWVOLUMEINFO  VolumeInfo;
    DWORD    dwMaxUserCount;
    LPTSTR   pszPath = NULL;
    HRESULT hr;

    //
    // Fill the VolumeInfo structure
    //

    //
    // set the file share count to be a default value (no limit)
    //

    VolumeInfo.dwMaxUses = (DWORD)-1;
    VolumeInfo.lpVolumeName = _pszShareName;
    VolumeInfo.dwType = FPNWVOL_TYPE_DISKTREE;

    hr = GetLPTSTRPropertyFromCache(_pPropertyCache,
                                    TEXT("Path"),
                                    &pszPath);

    if(SUCCEEDED(hr)){
        VolumeInfo.lpPath = pszPath;
    }

    hr = GetDWORDPropertyFromCache(_pPropertyCache,
                                   TEXT("MaxUserCount"),
                                   &dwMaxUserCount);

    if(SUCCEEDED(hr)){
        VolumeInfo.dwMaxUses = dwMaxUserCount;
    }

    VolumeInfo.dwCurrentUses =  0;


    dwErrorCode = ADsNwVolumeAdd(_pszServerName,
                                 1,
                                 &VolumeInfo);

    RRETURN_EXP_IF_ERR(HRESULT_FROM_WIN32(dwErrorCode));

}


STDMETHODIMP
CFPNWFileShare::get_CurrentUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, CurrentUserCount);
}

STDMETHODIMP
CFPNWFileShare::get_Description(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CFPNWFileShare::put_Description(THIS_ BSTR bstrDescription)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CFPNWFileShare::get_HostComputer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;
    TCHAR szComputerName[MAX_PATH];

    hr = BuildObjectInfo(_Parent, &pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = BuildComputerFromObjectInfo(pObjectInfo,
                                     szComputerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(szComputerName, retval);

error:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileShare::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CFPNWFileShare::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, Path);
}

STDMETHODIMP
CFPNWFileShare::put_Path(THIS_ BSTR bstrPath)
{
    //
    // note that path can be set only prior to creation
    // of the object. It cannot be changed later.
    //

    if(GetObjectState() == ADS_OBJECT_UNBOUND){
        PUT_PROPERTY_BSTR((IADsFileShare *)this,  Path);
    } else {
        RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
    }
}

STDMETHODIMP
CFPNWFileShare::get_MaxUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, MaxUserCount);
}

STDMETHODIMP
CFPNWFileShare::put_MaxUserCount(THIS_ LONG lMaxUserCount)
{
    PUT_PROPERTY_LONG((IADsFileShare *)this,  MaxUserCount);
}

//
// Helper functions
//

HRESULT
CFPNWFileShare::MarshallAndSet(PNWVOLUMEINFO pVolumeInfo)
{
    HRESULT hr = S_OK;
    LPTSTR    pszPath        = NULL;
    DWORD     dwValue;
    DWORD    dwErrorCode;
    DWORD    dwParmErr;

    pVolumeInfo->lpVolumeName = _pszShareName;

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Path"),
                    &pszPath
                    );

    if(SUCCEEDED(hr)){
        pVolumeInfo->lpPath = pszPath;
    }


    hr = GetDWORDPropertyFromCache(_pPropertyCache,
                                   TEXT("MaxUserCount"),
                                   &dwValue );
    if(SUCCEEDED(hr)){
        pVolumeInfo->dwMaxUses = dwValue;
    }


    //
    // you ignore earlier errors, why? because these errors were raised
    // due to internal cached values being invalid.
    //

    hr = S_OK;

    //
    // Do the SetInfo now that you have all info
    //

    dwErrorCode = ADsNwVolumeSetInfo(_pszServerName,
                                     _pszShareName,
                                     1,
                                     pVolumeInfo);


    hr = HRESULT_FROM_WIN32(dwErrorCode);
    BAIL_IF_ERROR(hr);

cleanup:
    if(pszPath)
        FreeADsStr(pszPath);
    RRETURN_EXP_IF_ERR(hr);
}


//
// helper functions
//

HRESULT
FPNWDeleteFileShare(POBJECTINFO pObjectInfo)
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    DWORD dwErrorCode;

    dwErrorCode = ADsNwVolumeDel(pObjectInfo->ComponentArray[1],
                                   pObjectInfo->ComponentArray[3]);

    RRETURN(HRESULT_FROM_WIN32(dwErrorCode));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cextmgr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cextmgr.cxx
//
//  Contents:  LDAP ExtMgr Object
//
//
//  History:   06-15-96     yihsins     Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//  Class CADsExtMgr

CADsExtMgr::CADsExtMgr(
        IUnknown FAR * pUnkOuter
        ):
    _pUnkOuter(pUnkOuter),
    _pClassEntry(NULL),
    _pDispMgr(NULL),
    _fExtensionsLoaded(FALSE)
{

}

HRESULT
CADsExtMgr::CreateExtMgr(
    IUnknown FAR * pUnkOuter,
    CAggregatorDispMgr * pDispMgr,
    LPTSTR pszClassName,
    CWinNTCredentials& Credentials,
    CADsExtMgr ** ppExtMgr
    )
{
    PCLASS_ENTRY pClassEntry =  NULL;
    CADsExtMgr FAR * pExtMgr = NULL;
    HRESULT hr = S_OK;

    pExtMgr = new CADsExtMgr(pUnkOuter);
    if (!pExtMgr)
        RRETURN(E_OUTOFMEMORY);


    //
    // Now store the DispatchMgr of the Aggregator
    //

    pExtMgr->_pDispMgr = pDispMgr;


    //
    // Read the list of extension object of the same class from registry
    //

    hr = ADSIGetExtensionList(
            pszClassName,
            &(pExtMgr->_pClassEntry)
            );
    BAIL_ON_FAILURE(hr);

    pExtMgr->_Credentials = Credentials;

    *ppExtMgr = pExtMgr;

    RRETURN(hr);

error:
    *ppExtMgr = NULL;
    delete pExtMgr;
    RRETURN(hr);
}


CADsExtMgr::~CADsExtMgr( )
{
    //
    // Free the ClassEntry
    //

    if (_pClassEntry) {

        FreeClassEntry(_pClassEntry);
    }

    //
    // And do nothing with the DispMgr - we just keep a pointer
    //

}


//
// Instantiate extension objects listed in _pClassEntry as aggregates of
// aggregator _pUnkOuter. Initialize extensions with <Credentials>.
//
// Max Load 127 extensions.
// 

HRESULT
CADsExtMgr::LoadExtensions(
    CWinNTCredentials &Credentials
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    DWORD dwExtensionID = MIN_EXTENSION_ID;
    IPrivateDispatch * pPrivDisp = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    DWORD dwAuthFlags = 0;          // dummy for winnt
    VARIANT varUserName;
    VARIANT varPassword;
    VARIANT varAuthFlags;
    PVARIANT pvarUserName = &varUserName;
    PVARIANT pvarPassword = &varPassword;
    PVARIANT pvarAuthFlags = &varAuthFlags;
    BOOL    fReturnError = FALSE;


    //
    // Extensions (ext mgr) do(es) not exist on its own without an aggregator
    //

    ADsAssert(_pUnkOuter);


    //
    // If _pClassEntry!=NULL, pClassEntry->pExtensionHead should not
    // be NULL either. But just in case a user removes all extension entries
    // under a class key without removing the class key itself in the registry,
    //  we will let it pass and just return S_OK here.
    //

    if (!_pClassEntry || !(pExtEntry=_pClassEntry->pExtensionHead) ) {
        RRETURN(S_OK);
    }


    VariantInit(pvarUserName);
    VariantInit(pvarPassword);
    VariantInit(pvarAuthFlags);


    hr = Credentials.GetUserName(&pszUserName);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }

    hr = Credentials.GetPassword(&pszPassword);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }


    while (pExtEntry) {

        //
        // Max # of extension have been loaded, cannot load more
        //

        if (dwExtensionID>MAX_EXTENSION_ID) {
            break;
        }

        //
        // create extension object (aggregatee) and ask for Non-delegating
        // IUnknown. Ref count on extension object = 1.
        //

        hr = CoCreateInstance(
                    pExtEntry->ExtCLSID,
                    _pUnkOuter,
                    CLSCTX_INPROC_SERVER,
                    IID_IUnknown,
                    (void **)&(pExtEntry->pUnknown)
                    );


        //
        // if fail, go to next extesion entry s.t. bad individual extension
        // cannot block other extensions from loading (no clean up needed)
        //
        // no warning to user about failure
        //


        if (SUCCEEDED(hr)) {

            pExtEntry->dwExtensionID = dwExtensionID;


            hr = (pExtEntry->pUnknown)->QueryInterface(
                        IID_IADsExtension,
                        (void **) &(pExtEntry->pADsExt)
                        );

            if  (FAILED(hr)) {

                //
                // extension does not support the optioanl IADsExtension -> OK.
                // (no clean up needed)
                //

                pExtEntry->pADsExt=NULL;

                pExtEntry->fDisp = FALSE;

            } else {

                //
                // Cache the interface ptr but call Release() immediately to
                // avoid aggregator having a ref count on itself
                // since IADsExtension inherits from delegating IUnknown.
                //
                // Note: codes still works if inherit from NonDelegatingIUknown
                //

                (pExtEntry->pADsExt)->Release() ;

                //
                // For efficiency, set this flag to FALSE on FIRST encounter of
                // pADsExt->PrivateGetIDsOfNames()/Invoke() returning E_NOTIMPL.
                // Set as TRUE now s.t. at least first encounter will happen.
                //

                pExtEntry->fDisp = TRUE;


                //
                // Pass its own credentials to extension. Ignore error if any.
                //

                hr = ADsAllocString(
                        pszUserName,
                        &(pvarUserName->bstrVal)
                        );
                if (FAILED(hr)) {
                    fReturnError = TRUE;
                    BAIL_ON_FAILURE(hr);
                }
                V_VT(pvarUserName) = VT_BSTR;

                hr = ADsAllocString(
                        pszPassword,
                        &(pvarPassword->bstrVal)
                        );
                if (FAILED(hr)) {
                    fReturnError = TRUE;
                    BAIL_ON_FAILURE(hr);
                }
                V_VT(pvarPassword) = VT_BSTR;

                V_I4(pvarAuthFlags) = dwAuthFlags;
                V_VT(pvarAuthFlags) = VT_I4;

                hr = (pExtEntry->pADsExt)->Operate(
                        ADS_EXT_INITCREDENTIALS,
                        varUserName,
                        varPassword,
                        varAuthFlags
                        );
                //
                // Zero out the memory that was used to store the password.
                //
                if (pvarPassword->bstrVal)
                {
                    SecureZeroMemory
                        (
                            pvarPassword->bstrVal, 
                            wcslen(pvarPassword->bstrVal) * sizeof(WCHAR)
                        );
                }

                //
                // Free them as they are reused
                //
                VariantClear(pvarUserName);
                VariantClear(pvarPassword);
            }

        } // end if CoCreateInstance() succeeded


        pExtEntry = pExtEntry->pNext;


        //
        // ++ extension ID even if creat'n of extension fails just to be safe
        // - chuck's stuff :)
        //

        dwExtensionID++;

    }   // end while



error:

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        //
        // Zero out the password before freeing so it doesn't remain
        // visible in memory.
        //
        SecureZeroMemory(pszPassword, wcslen(pszPassword) * sizeof(WCHAR));
        FreeADsStr(pszPassword);
    }

    VariantClear(pvarUserName);
    VariantClear(pvarPassword);
    VariantClear(pvarAuthFlags);

    if (fReturnError) {
        RRETURN(hr);        // fetal error,
    }
    else {
        RRETURN(S_OK);      // "okay" error if any, optional support
    }

}

HRESULT 
CADsExtMgr::LoadExtensionsIfReqd(void)
{
    HRESULT hr = S_OK;

    if(FALSE == _fExtensionsLoaded) {
        hr = LoadExtensions(_Credentials);
        BAIL_ON_FAILURE(hr);
 
        hr = FinalInitializeExtensions(); // this call never fails
        BAIL_ON_FAILURE(hr);

        _fExtensionsLoaded = TRUE;
    }

    RRETURN(S_OK);

error:

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    IUnknown * pUnknown = NULL;
    PINTERFACE_ENTRY pIID = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    HRESULT hr = S_OK;

    if (!pClassEntry) {

        RRETURN(E_NOINTERFACE);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pIID = pExtensionEntry->pIID;

        while (pIID) {

            if (IsEqualIID(pIID->iid, iid)) {

                hr = LoadExtensionsIfReqd();
                if(FAILED(hr))
                    RRETURN(E_NOINTERFACE);

                pUnknown = pExtensionEntry->pUnknown;

                if (!pUnknown) {

                    RRETURN(E_NOINTERFACE);
                }

                hr = pUnknown->QueryInterface(
                            iid,
                            ppv
                            );
                RRETURN(hr);
            }

            pIID = pIID->pNext;

        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    RRETURN(hr = E_NOINTERFACE);
}



HRESULT
ADSILoadExtensionManager(
    LPWSTR pszClassName,
    IUnknown * pUnkOuter,
    CAggregatorDispMgr * pDispMgr,
    CWinNTCredentials& Credentials,
    CADsExtMgr ** ppExtMgr
    )
{

    HRESULT hr = S_OK;

    hr = CADsExtMgr::CreateExtMgr(
            pUnkOuter,
            pDispMgr,
            pszClassName,
            Credentials,
            ppExtMgr
            );

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::GetTypeInfoCount(
    unsigned int FAR* pctinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetTypeInfo(
    unsigned int itinfo,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR FAR* rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID FAR* rgdispid
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch FAR * pPrivDisp = NULL;


    hr = _pDispMgr->GetIDsOfNames(
            iid,
            rgszNames,
            cNames,
            lcid,
            rgdispid
            );

    if (FAILED(hr)) {

        if (!_pClassEntry) {
            RRETURN(DISP_E_UNKNOWNNAME);
        }

        hr = LoadExtensionsIfReqd();
        if(FAILED(hr))
            RRETURN(DISP_E_UNKNOWNNAME);

        pExtension = _pClassEntry->pExtensionHead;

        while (pExtension) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates
                //  1)  extension supports pADsExt AND
                //  2)  either
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
                //      OR
                //      b) we don't know if a) is true or not yet
                //

                ADsAssert(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateGetIDsOfNames(
                          iid,
                          rgszNames,
                          cNames,
                          lcid,
                          rgdispid
                          );

                if (SUCCEEDED(hr)) {

                    //
                    // check & prefix extension id to dispid(s) returned
                    // by extension
                    //

                    hr = CheckAndPrefixExtIDArray(
                                pExtension->dwExtensionID,
                                cNames,
                                rgdispid
                                );

                    if (SUCCEEDED(hr) )
                    {
                        RRETURN(hr);
                    }

                    //
                    // if cannot prefix extension id because NOT ALL
                    // dispids returned by PrivateGetIDsOfNames() are
                    // valid, this extension does not support this property
                    // or method -> try next extension
                    //
                }

                else if (hr == E_NOTIMPL) {

                    //
                    // extension object does not support the optional
                    // IADsExtension::PrivateGetIDsOfNames()/PrivateInvoke()
                    // -> remember this in cache & try next extension object
                    //

                    pExtension->fDisp = FALSE;
                }

                else {

                    //
                    // extens'n object supports PrivateGetIDsOfNames()/Invoke()
                    // but does not know about this property or method
                    // -> try next extension object
                    //
                }

            } // end "if (pExtension->pADs && pExtension->fDisp)"

            pExtension = pExtension->pNext;

        } // end while

    }


    //
    // Unify the final error code retuned to ADSI client to DISP_E_UNKNOWNNAME
    //

    if ( FAILED(hr) && hr!=E_OUTOFMEMORY) {

        hr = DISP_E_UNKNOWNNAME;
    }

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    unsigned int FAR* puArgErr
    )
{
    DWORD dwExtensionId = 0;
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch * pPrivDisp = NULL;
    DISPID rgExtDispid = DISPID_UNKNOWN;

    //
    // This could be a special dispatch id - pass it to
    // the aggregator
    //

    if (dispidMember <= 0) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    //
    // It is not a special dispatch id, so compute the extension
    // id and pass it to the appropriate dispatch manager
    //

    dwExtensionId = EXTRACT_EXTENSION_ID(dispidMember);

    if (!dwExtensionId) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    if (!_pClassEntry) {

        RRETURN(DISP_E_MEMBERNOTFOUND);
    }

    // Shouldn't really be required here, but just being paranoid.
    hr = LoadExtensionsIfReqd();
    if(FAILED(hr))
        RRETURN(DISP_E_MEMBERNOTFOUND);
    
    pExtension = _pClassEntry->pExtensionHead;

    rgExtDispid = REMOVE_EXTENSION_ID(dispidMember);

    while (pExtension) {

        if (dwExtensionId == pExtension->dwExtensionID) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates
                //  1)  extension supports pADsExt AND
                //  2)  either
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
                //      OR
                //      b) we don't know if a) is true or not yet
                //

                ADsAssert(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateInvoke(
                        rgExtDispid,
                        iid,
                        lcid,
                        wFlags,
                        pdispparams,
                        pvarResult,
                        pexcepinfo,
                        puArgErr
                        );
                RRETURN(hr);

            } else {

                //
                // A dwExtensionId match indicates THIS extens'n has returned
                // a valid dispid to clients thru' pADs->PrivateGetIDsOfNames.
                // Thus, fDisp should be TURE.
                //
                // But since dispid goes thru' clients before passed back to
                // PrivateInovke(), don't ASSERT in case of clients errors.
                //

                RRETURN(DISP_E_MEMBERNOTFOUND);
            }
        }

        pExtension = pExtension->pNext;

    } // end while

    RRETURN(DISP_E_MEMBERNOTFOUND);
}


HRESULT
CADsExtMgr::CheckAndPrefixExtIDArray(
    IN      DWORD dwExtensionID,
    IN      unsigned int cDispids,
    IN OUT  DISPID * rgDispids
    )
{

    HRESULT hrEach = S_OK;
    HRESULT hrAll = S_OK;


    ASSERT_VALID_EXTENSION_ID(dwExtensionID);


    for (unsigned int i = 0; i<cDispids; i++)
    {
        hrEach = CheckAndPrefixExtID(
                    dwExtensionID,
                    rgDispids[i],
                    rgDispids+i
                    );

        if (FAILED(hrEach))
        {
            hrAll = E_FAIL;

            //
            // The entire operation is considered as failure as a whole.
            // But continue to get other dispid s.t. debugger or user knows
            // which dispid in the array is causing problem -> DISPID_UNKOWN
            //
        }
    }

    RRETURN(hrAll);

}


HRESULT
CADsExtMgr::CheckAndPrefixExtID(
    IN      DWORD   dwExtensionID,
    IN      DISPID  dispid,
    IN OUT  DISPID  * pNewDispid
    )
{
    ADsAssert(pNewDispid);

    if  ( (dispid>= ADS_EXT_MINEXTDISPID) &&
          (dispid<= ADS_EXT_MAXEXTDISPID) )
    {
        *pNewDispid = PREFIX_EXTENSION_ID(dwExtensionID, dispid) ;

        RRETURN(S_OK);
    }
    else
    {
        *pNewDispid = DISPID_UNKNOWN;

        RRETURN(E_FAIL);
    }

}



//+------------------------------------------------------------------------
//
//  Function:   CADsExtMgr::FinalInitializeExtensions
//
//  Synopsis:   At this point we call Operate on all the extensions
//           so that they can do initialization stuff that
//
//
//
//  Arguments: None
//
//  AjayR - added on 1-28-99.
//-------------------------------------------------------------------------
HRESULT
CADsExtMgr::FinalInitializeExtensions()
{

    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    VARIANT vDummy;

    VariantInit(&vDummy);

    //
    // Extensions (ext mgr) does not exist on its own without an aggregator
    //

    ADsAssert(_pUnkOuter);

    //
    // If _pClassEntry!=NULL, pClassEntry->pExtensionHead should not
    // be NULL either. But just in case a user removes all extension entries
    // under a class key without removing the class key itself in the registry,
    //  we will let it pass and just return S_OK here.
    //

    if (!_pClassEntry || !(pExtEntry=_pClassEntry->pExtensionHead) ) {
        RRETURN(S_OK);
    }


    while (pExtEntry) {

        //
        // Call operate only if the extension supports the interface
        //
        if (pExtEntry->pADsExt) {

            hr = (pExtEntry->pADsExt)->Operate(
                      ADS_EXT_INITIALIZE_COMPLETE,
                      vDummy,
                      vDummy,
                      vDummy
                      );
        }

        //
        // we cannot really do much if there is a failure here
        //

        pExtEntry = pExtEntry->pNext;

    }   // end while


    //
    // We need to return S_OK here as otherwise just because
    // the final initialization of one extension failed - we
    // will hold up the entire lot.
    //
    RRETURN(S_OK);

}

//----------------------------------------------------------------------------
// Function:   GetCLSIDForIID
//
// Synopsis:   Returns the CLSID corresponding to a given interface IID. 
//             If the IID is one of the interfaces implemented by the 
//             extension manager, then the extension's CLSID is returned.
//
// Arguments:
//
// riid        Interface ID for which we want to find the CLSID
// lFlags      Reserved. Must be 0.
// pCLSID      Returns the CLSID corresponding to the IID.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pCLSID to return CLSID.
//
//----------------------------------------------------------------------------
STDMETHODIMP CADsExtMgr::GetCLSIDForIID(
    REFIID riid,
    long lFlags,
    CLSID *pCLSID
    )
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PINTERFACE_ENTRY pIID = NULL;
    HRESULT hr = S_OK;

    ADsAssert( (0 == lFlags) && (pCLSID != NULL) );

    if (!pClassEntry) {

        RRETURN(UMI_E_NOT_FOUND);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {
        pIID = pExtensionEntry->pIID;

        while (pIID) {

            if (IsEqualIID(pIID->iid, riid)) {
                *pCLSID = pExtensionEntry->ExtCLSID;
                RRETURN(S_OK);
            }

            pIID = pIID->pNext;

        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    RRETURN(hr = UMI_E_NOT_FOUND);
}

//----------------------------------------------------------------------------
// Function:   GetObjectByCLSID
//
// Synopsis:   Returns a pointer to a requested interface on the object
//             specified by a CLSID. The object specified by the CLSID is
//             aggregated by the specified outer unknown on return. The 
//             interface returned is a non-delegating interface on the object.
//
// Arguments:
//
// clsid       CLSID of object on which interface should be obtained
// pUnkOuter   Aggregating outer unknown
// riid        Interface requested
// ppInterface Returns requested interface
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return requested interface
//
//----------------------------------------------------------------------------
STDMETHODIMP CADsExtMgr::GetObjectByCLSID(
    CLSID clsid,
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppInterface
    )
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    HRESULT hr = S_OK;
    IUnknown *pPrevUnk = NULL, *pUnknown = NULL;

    ADsAssert( (ppInterface != NULL) && (pUnkOuter != NULL) );

    if (!pClassEntry) {

        RRETURN(UMI_E_NOT_FOUND);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {
        if (IsEqualCLSID(pExtensionEntry->ExtCLSID, clsid)) {
           pPrevUnk = _pUnkOuter;

           _pUnkOuter = pUnkOuter;

           hr = LoadExtensionsIfReqd();
           if(FAILED(hr)) {
               _pUnkOuter = pPrevUnk;
               BAIL_ON_FAILURE(hr = UMI_E_FAIL);
           }

           pUnknown = pExtensionEntry->pUnknown; 

           if (!pUnknown) {

                BAIL_ON_FAILURE(hr = UMI_E_FAIL);
           }

           *ppInterface = pUnknown;
           pUnknown->AddRef();

           RRETURN(S_OK);
       }

       pExtensionEntry = pExtensionEntry->pNext;
    }

    RRETURN(UMI_E_NOT_FOUND);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   GetCLSIDForNames
//
// Synopsis:   Returns the CLSID of the object that supports a specified
//             method/property. Also returns DISPIDs for the property/method.
//
// Arguments:
//
// rgszNames   Names to be mapped
// cNames      Number of names to be mapped
// lcid        Locale in which to interpret the names
// rgDispId    Returns DISPID
// lFlags      Reserved. Must be 0.
// pCLSID      Returns CLSID of object which supports this property/method.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *pCLSID to return the CLSID.
//             *rgDispId to return the DISPIDs.
//
//----------------------------------------------------------------------------
STDMETHODIMP CADsExtMgr::GetCLSIDForNames(
    LPOLESTR *rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID *rgDispId,
    long lFlags,
    CLSID *pCLSID
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;

    ADsAssert( (pCLSID != NULL) && (0 == lFlags) && (rgszNames != NULL) &&
               (rgDispId != NULL) );

    if (!_pClassEntry) {
        RRETURN(DISP_E_UNKNOWNNAME);
    }

    hr = LoadExtensionsIfReqd();
    if(FAILED(hr))
        RRETURN(DISP_E_UNKNOWNNAME);    

    pExtension = _pClassEntry->pExtensionHead;

    while(pExtension) {
        if (pExtension->fDisp) {
            //
            // fDisp = TRUE indicates
            //  1)  extension supports pADsExt AND
            //  2)  either
            //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL
            //      OR
            //      b) we don't know if a) is true or not yet
            //

            ADsAssert(pExtension->pADsExt);

            hr = (pExtension->pADsExt)->PrivateGetIDsOfNames(
                          IID_NULL,
                          rgszNames,
                          cNames,
                          lcid,
                          rgDispId
                          );

            if (SUCCEEDED(hr)) {
                *pCLSID = pExtension->ExtCLSID;
                RRETURN(S_OK);
            }

            else if (hr == E_NOTIMPL) {
            //
            // extension object does not support the optional
            // IADsExtension::PrivateGetIDsOfNames()/PrivateInvoke()
            // -> remember this in cache & try next extension object
            //
                pExtension->fDisp = FALSE;
            }
        } 

        pExtension = pExtension->pNext;

    } // end while

    RRETURN(hr = DISP_E_UNKNOWNNAME);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cfserv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfserv.cxx
//
//  Contents:  Contains methods for the following objects
//             CWinNTFileService and CWinNTFileServiceGeneralInfo.
//
//
//  History:   12/11/95     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------



#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

//
// class CWinNTFileService methods
//

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTFileService);
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTFileService);
DEFINE_IADs_TempImplementation(CWinNTFileService);
DEFINE_IADsPropertyList_Implementation(CWinNTFileService, FileServiceClass, gdwFileServiceTableSize)

CWinNTFileService::CWinNTFileService()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pService = NULL;
    _pServiceOps = NULL;
    _pszServerName = NULL;
    VariantInit(&_vFilter);
    _pPropertyCache = NULL;
    ENLIST_TRACKING(CWinNTFileService);
    return;

}

CWinNTFileService::~CWinNTFileService()
{
    if(_pService){
        _pService->Release();
    }

    if (_pServiceOps) {
        _pServiceOps->Release();
    }


    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }

    VariantClear(&_vFilter);

    delete _pPropertyCache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileService::CreateFileService
//
//  Synopsis:   Static function used to create a FileService object. This
//              will be called by BindToObject
//
//  Arguments:  [ppWinNTFileService] -- Ptr to a ptr to a new Service object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------

HRESULT
CWinNTFileService::CreateFileService(LPTSTR pszADsParent,
                                     DWORD  dwParentId,
                                     LPTSTR pszDomainName,
                                     LPTSTR pszServerName,
                                     LPTSTR pszFileServiceName,
                                     DWORD  dwObjectState,
                                     REFIID riid,
                                     CWinNTCredentials& Credentials,
                                     LPVOID * ppvoid
                                     )

{
    CWinNTFileService FAR * pCWinNTFileService = NULL;
    HRESULT hr = S_OK;

    //
    // Create the FileService Object
    //

    hr = AllocateFileServiceObject(&pCWinNTFileService);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTFileService->_pDispMgr);


    hr = pCWinNTFileService->InitializeCoreObject(pszADsParent,
                                                  pszFileServiceName,
                                                  FILESERVICE_CLASS_NAME,
                                                  FILESERVICE_SCHEMA_NAME,
                                                  CLSID_WinNTFileService,
                                                  dwObjectState);


    BAIL_ON_FAILURE(hr);

    pCWinNTFileService->_Credentials = Credentials;
    hr = pCWinNTFileService->_Credentials.Ref(pszServerName,
        pszDomainName, dwParentId);
    BAIL_ON_FAILURE(hr);

    hr = CWinNTService::Create(pszADsParent,
                               pszDomainName,
                               pszServerName,
                               pszFileServiceName,
                               dwObjectState,
                               IID_IADsService,
                               pCWinNTFileService->_Credentials,
                               (void **)(&(pCWinNTFileService->_pService)));

    BAIL_ON_FAILURE(hr);


    hr = (pCWinNTFileService->_pService)->QueryInterface(
                    IID_IADsServiceOperations,
                    (void **)&(pCWinNTFileService->_pServiceOps));
    BAIL_ON_FAILURE(hr);



    pCWinNTFileService->_pszServerName =
        AllocADsStr(pszServerName);

    if(!(pCWinNTFileService->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                FILESERVICE_CLASS_NAME,
                (IADsFileService *) pCWinNTFileService,
                pCWinNTFileService->_pDispMgr,
                Credentials,
                &pCWinNTFileService->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTFileService->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pCWinNTFileService->_dwNumComponents) {
            pCWinNTFileService->_CompClasses[0] = L"Domain";
            pCWinNTFileService->_CompClasses[1] = L"Computer";
            pCWinNTFileService->_CompClasses[2] = L"FileService";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pCWinNTFileService->InitUmiObject(
                 pCWinNTFileService->_Credentials,
                 FileServiceClass, 
                 gdwFileServiceTableSize,
                 pCWinNTFileService->_pPropertyCache,
                 (IUnknown *) (INonDelegatingUnknown *) pCWinNTFileService,
                 pCWinNTFileService->_pExtMgr,
                 IID_IUnknown,
                 ppvoid
                 );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }
                 
    hr = pCWinNTFileService->QueryInterface(riid,
                                            (void **)ppvoid);


    BAIL_ON_FAILURE(hr);

    pCWinNTFileService->Release();

    RRETURN(hr);

error:

    delete pCWinNTFileService;
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTFileService::AllocateFileServiceObject(
    CWinNTFileService ** ppFileService
    )
{
    CWinNTFileService FAR * pFileService = NULL;
    HRESULT hr = S_OK;

    pFileService = new CWinNTFileService();
    if (pFileService == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);


    pFileService->_pDispMgr = new CAggregatorDispMgr;
    if (pFileService->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }

    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pFileService->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsFileService,
                           (IADsFileService *)pFileService,
                           DISPID_REGULAR);
    BAIL_ON_FAILURE(hr);



    hr =  LoadTypeInfoEntry(pFileService->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsContainer,
                            (IADsContainer *)pFileService,
                            DISPID_NEWENUM);
    BAIL_ON_FAILURE(hr);


    hr =  LoadTypeInfoEntry(
                pFileService->_pDispMgr,
                LIBID_ADs,
                IID_IADsFileServiceOperations,
                (IADsFileServiceOperations *)pFileService,
                DISPID_REGULAR
                );

    BAIL_ON_FAILURE(hr);



    hr =  LoadTypeInfoEntry(
                pFileService->_pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pFileService,
                DISPID_VALUE
                );

    BAIL_ON_FAILURE(hr);


    hr = CPropertyCache::createpropertycache(
             FileServiceClass,
             gdwFileServiceTableSize,
             (CCoreADsObject *)pFileService,
             &(pFileService->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);

    (pFileService->_pDispMgr)->RegisterPropertyCache(
                                    pFileService->_pPropertyCache
                                    );


    *ppFileService = pFileService;

    RRETURN(hr);

error:

    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete  pFileService;

    RRETURN(hr);

}



/* IUnknown methods for file service object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTFileService::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTFileService::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTFileService::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTFileService::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsFileService*)this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsFileService *)this;

    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsFileServiceOperations))
    {
        *ppvObj = (IADsFileServiceOperations *)this;
    }
    else if (IsEqualIID(riid, IID_IADsServiceOperations))
    {
        *ppvObj = (IADsFileServiceOperations *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileService))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsService))
    {
        *ppvObj = (IADsService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsContainer))
    {
        *ppvObj = (IADsContainer FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTFileService::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsService) ||
        IsEqualIID(riid, IID_IADsFileService) ||
        IsEqualIID(riid, IID_IADsServiceOperations) ||
        IsEqualIID(riid, IID_IADsFileServiceOperations) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:        RamV  Created
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTFileService::SetInfo(THIS)
{
    HRESULT hr;
    IADsService * pADsService = NULL;

    ADsAssert(_pService);

    hr = _pService->SetInfo();
    BAIL_IF_ERROR(hr);

    hr = SetLevel1005Info();

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetInfo
//
//  Synopsis:
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12/11/95    RamV  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTFileService::GetInfo(THIS)
{
    HRESULT hr =S_OK;

    hr = GetInfo(1, TRUE);
    if(FAILED(hr))
        RRETURN_EXP_IF_ERR(hr);

    hr = GetInfo(2,TRUE);

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTFileService::ImplicitGetInfo(THIS)
{
    HRESULT hr =S_OK;

    hr = GetInfo(1, FALSE);
    if(FAILED(hr))
        RRETURN_EXP_IF_ERR(hr);

    hr = GetInfo(2,FALSE);

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTFileService::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{

    HRESULT hr =S_OK;

    switch(dwApiLevel){

    case 1:
        ADsAssert(_pService);
        hr = _pService->GetInfo();
        BAIL_IF_ERROR(hr);
        break;

    case 2:
        hr = GetLevel101Info(fExplicit);
        BAIL_IF_ERROR(hr);
        break;

    default:
        ADsAssert(FALSE);
        break;
    }

cleanup:
    RRETURN (hr);
}


STDMETHODIMP
CWinNTFileService::SetLevel1005Info(THIS)
{
    SERVER_INFO_1005 ServerInfo;
    NET_API_STATUS  nasStatus;
    HRESULT hr = S_OK;
    LPTSTR pszDescription = NULL;

    memset(&ServerInfo, 0, sizeof(ServerInfo));

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );

    if(SUCCEEDED(hr)){
        ServerInfo.sv1005_comment = pszDescription;
    }

    nasStatus = NetServerSetInfo(_pszServerName,
                                 1005,
                                 (LPBYTE)(&ServerInfo),
                                 NULL
                                 );

    hr = HRESULT_FROM_WIN32(nasStatus);

    if(pszDescription){
        FreeADsStr(pszDescription);
    }
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTFileService::GetLevel101Info(THIS_ BOOL fExplicit)
{
    //
    // here we do a NetServerGetInfo on level101 and then unmarshall the
    // comment field into description
    //

    NET_API_STATUS nasStatus;
    LPSERVER_INFO_101 lpServerInfo =NULL;
    HRESULT hr;

    //
    // level 101 is available with user permissions,
    // Level 1005 is preferable but exists only in LanMan 2.0
    //

    nasStatus = NetServerGetInfo(_pszServerName,
                                 101,
                                 (LPBYTE *)&lpServerInfo
                                 );

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_IF_ERROR(hr);


    //
    // unmarshall the info into the Description field
    //

    ADsAssert(lpServerInfo);

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  lpServerInfo->sv101_comment,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostComputer"),
                                  _Parent,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("MaxUserCount"),
                                   (DWORD)-1,
                                   fExplicit
                                   );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );


    hr = S_OK;

cleanup:
    if(lpServerInfo)
        NetApiBufferFree(lpServerInfo);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTFileService::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;

    hr= _pService->Get(bstrName, pvProp );

    if(FAILED(hr)){
        hr = GenericGetPropertyManager(
                   _pPropertyCache,
                   bstrName,
                   pvProp
                   );
    }
    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CWinNTFileService::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;

    hr= _pService->Put(bstrName, vProp );

    if(FAILED(hr)){
        hr = GenericPutPropertyManager(_pPropertyCache,
                                       FileServiceClass,
                                       gdwFileServiceTableSize,
                                       bstrName,
                                       vProp);
    }

    RRETURN_EXP_IF_ERR(hr);

}


//
// IADsService Methods
//


/* IADsContainer methods */

STDMETHODIMP
CWinNTFileService::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTFileService::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    RRETURN(VariantCopy(&_vFilter, &Var));
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::GetObject(THIS_ BSTR ClassName,
                             BSTR RelativeName,
                             IDispatch * FAR* ppObject
                             )
{
    HRESULT hr;
    DWORD dwObjectType;
    POBJECTINFO pObjectInfo = NULL;

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       ClassName,
                       (PDWORD)&dwObjectType
                       );

    BAIL_IF_ERROR(hr);

    if(dwObjectType != WINNT_FILESHARE_ID){
        //
        // trying to create an invalid object at this level
        //
        hr = E_FAIL;
        goto error;

    }

    hr = BuildObjectInfo(_ADsPath,
                         RelativeName,
                         &pObjectInfo
                         );

    BAIL_ON_FAILURE(hr);

    hr = ValidateObject(dwObjectType,
                        pObjectInfo,
                        _Credentials
                        );

    BAIL_ON_FAILURE(hr);

    //
    // The only object that has a file service as a container is
    // a file share object
    //
    hr = CWinNTFileShare::Create(_ADsPath,
                                 pObjectInfo->ComponentArray[1],
                                 pObjectInfo->ComponentArray[2],
                                 RelativeName,
                                 ADS_OBJECT_UNBOUND,
                                 IID_IDispatch,
                                 _Credentials,
                                 (void**)ppObject
                                 );

    BAIL_ON_FAILURE(hr);

error:
cleanup:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTFileService::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr = S_OK;
    CWinNTFileSharesEnumVar *pCFileSharesEnumVar = NULL;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = NULL;

    hr = CWinNTFileSharesEnumVar::Create(_pszServerName,
                                         _ADsPath,
                                         &pCFileSharesEnumVar,
                                         _vFilter,
                                         _Credentials);

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCFileSharesEnumVar);

    hr = pCFileSharesEnumVar->QueryInterface(IID_IUnknown,
                                             (void **)retval);

    BAIL_ON_FAILURE(hr);

    pCFileSharesEnumVar->Release();

    RRETURN(hr);

error:
    delete pCFileSharesEnumVar;
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTFileService::Create(THIS_ BSTR ClassName,
                          BSTR RelativeName,
                          IDispatch * FAR* ppObject
                          )
{

    DWORD dwObjectType = 0;
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       ClassName,
                       (PDWORD)&dwObjectType
                       );

    BAIL_IF_ERROR(hr);

    if(dwObjectType != WINNT_FILESHARE_ID){
        //
        // trying to create an invalid object at this level
        //
        hr = E_FAIL;
        goto error;

    }

    hr = BuildObjectInfo(_ADsPath,
                         RelativeName,
                         &pObjectInfo
                         );

    BAIL_ON_FAILURE(hr);

    hr = ValidateObject(dwObjectType,
                        pObjectInfo,
                        _Credentials
                        );

    if(SUCCEEDED(hr)){
        hr = E_ADS_OBJECT_EXISTS;
        goto error;
    }

    //
    // The only object that has a file service as a container is
    // a file share object

    hr = CWinNTFileShare::Create(_ADsPath,
                                 pObjectInfo->ComponentArray[1],
                                 pObjectInfo->ComponentArray[2],
                                 RelativeName,
                                 ADS_OBJECT_UNBOUND,
                                 IID_IDispatch,
                                 _Credentials,
                                 (void**)ppObject
                                 );

    BAIL_ON_FAILURE(hr);

error:
cleanup:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTFileService::Delete(THIS_ BSTR Type,
                          BSTR SourceName
                          )
{
    HRESULT hr;
    DWORD dwObjectType = 0;
    POBJECTINFO pObjectInfo = NULL;

    // Make sure the input parameters are valid
    if (Type == NULL || SourceName == NULL) {
        RRETURN_EXP_IF_ERR(hr = E_ADS_BAD_PARAMETER);
    }

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       Type,
                       (PDWORD)&dwObjectType
                       );

    BAIL_IF_ERROR(hr);

    if(dwObjectType != WINNT_FILESHARE_ID){
        //
        // trying to delete an invalid object at this level
        //
        hr = E_FAIL;
        goto cleanup;

    }

    hr = BuildObjectInfo(_ADsPath,
                         SourceName,
                         &pObjectInfo
                         );

    BAIL_IF_ERROR(hr);

    hr = WinNTDeleteFileShare(pObjectInfo);


cleanup:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CWinNTFileService::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTFileService::CopyHere(THIS_ BSTR SourceName,
                            BSTR NewName,
                            IDispatch * FAR* ppObject
                            )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTFileService::MoveHere(THIS_ BSTR SourceName,
                            BSTR NewName,
                            IDispatch * FAR* ppObject
                            )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



STDMETHODIMP
CWinNTFileService::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CWinNTFileService::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CWinNTFileService::get_MaxUserCount(THIS_ long FAR* retval)
{
    //
    // here -1 signifies no limit
    //
    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = -1;
    RRETURN(S_OK);
}

STDMETHODIMP CWinNTFileService::put_MaxUserCount(THIS_ long lnMaxUserCount)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


STDMETHODIMP
CWinNTFileService::Sessions(THIS_ IADsCollection FAR* FAR* ppSessions)
{
    //
    // The session collection object is created and it is passed the server
    // name. It uses this to create the session object
    //

    HRESULT hr = S_OK;
    CWinNTSessionsCollection * pSessionsCollection = NULL;

    if(!ppSessions){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    hr = CWinNTSessionsCollection::Create(_ADsPath,
                                          NULL,
                                          NULL,
                                          _Credentials,
                                          &pSessionsCollection
                                          );

    BAIL_IF_ERROR(hr);

    hr = pSessionsCollection->QueryInterface(IID_IADsCollection,
                                             (void **) ppSessions);

    BAIL_IF_ERROR(hr);

    pSessionsCollection->Release();

cleanup:

    if(FAILED(hr)){
        delete pSessionsCollection;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTFileService::Resources(THIS_ IADsCollection FAR* FAR* ppResources)
{
    //
    // The resource collection object is created and it is passed the server
    // name. It uses this to create the resource object
    //

    HRESULT hr = S_OK;
    CWinNTResourcesCollection * pResourcesCollection = NULL;

    if(!ppResources){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    hr = CWinNTResourcesCollection::Create(_ADsPath,
                                           NULL,
                                           NULL,
                                           _Credentials,
                                           &pResourcesCollection
                                           );

    BAIL_IF_ERROR(hr);

    hr = pResourcesCollection->QueryInterface(IID_IADsCollection,
                                              (void **) ppResources
                                              );

    BAIL_IF_ERROR(hr);

    pResourcesCollection->Release();

cleanup:

    if(FAILED(hr)){
        delete pResourcesCollection;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTFileService::get_HostComputer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_HostComputer(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    HRESULT hr;
    hr = _pService->put_HostComputer(bstrHostComputer);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_DisplayName(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_DisplayName(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_DisplayName(THIS_ BSTR bstrDisplayName)
{
    HRESULT hr;
    hr = _pService->put_DisplayName(bstrDisplayName);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_Version(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_Version(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_Version(THIS_ BSTR bstrVersion)
{
    HRESULT hr;
    hr = _pService->put_Version(bstrVersion);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_ServiceType(THIS_ long FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ServiceType(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_ServiceType(THIS_ long lServiceType)
{
    HRESULT hr;
    hr = _pService->put_ServiceType(lServiceType);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_StartType(THIS_ LONG FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_StartType(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_StartType(THIS_ LONG lStartType)
{
    HRESULT hr;
    hr = _pService->put_StartType(lStartType);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_Path(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_Path(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_Path(THIS_ BSTR bstrPath)
{
    HRESULT hr;
    hr = _pService->put_Path(bstrPath);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_StartupParameters(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_StartupParameters(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_StartupParameters(THIS_ BSTR bstrStartupParameters)
{
    HRESULT hr;
    hr = _pService->put_StartupParameters(bstrStartupParameters);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_ErrorControl(THIS_ LONG FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ErrorControl(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_ErrorControl(THIS_ LONG lErrorControl)
{
    HRESULT hr;
    hr = _pService->put_ErrorControl(lErrorControl);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_LoadOrderGroup(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_LoadOrderGroup(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_LoadOrderGroup(THIS_ BSTR bstrLoadOrderGroup)
{
    HRESULT hr;
    hr = _pService->put_LoadOrderGroup(bstrLoadOrderGroup);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_ServiceAccountName(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ServiceAccountName(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_ServiceAccountName(THIS_ BSTR bstrServiceAccountName)
{
    HRESULT hr;
    hr = _pService->put_ServiceAccountName(bstrServiceAccountName);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_ServiceAccountPath(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ServiceAccountPath(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_ServiceAccountPath(THIS_ BSTR bstrServiceAccountName)
{
    HRESULT hr;
    hr = _pService->put_ServiceAccountPath(bstrServiceAccountName);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_Dependencies(THIS_ VARIANT FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_Dependencies(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::put_Dependencies(THIS_ VARIANT vDependencies)
{
    HRESULT hr;
    hr = _pService->put_Dependencies(vDependencies);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::SetPassword(THIS_ BSTR bstrNewPassword)
{
    HRESULT hr;
    hr = _pServiceOps->SetPassword(bstrNewPassword);
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileService::Start
//
//  Synopsis:   Attempts to start the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  RamV    Created
//
// Notes:
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTFileService::Start(THIS)
{
    HRESULT hr;
    hr = _pServiceOps->Start();
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileService::Stop
//
//  Synopsis:   Attempts to stop the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96 RamV    Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTFileService::Stop(THIS)
{
    HRESULT hr;
    hr = _pServiceOps->Stop();
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileService::Pause
//
//  Synopsis:   Attempts to pause the service named _bstrServiceName on the
//              server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01-04-96    RamV     Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTFileService::Pause(THIS)

{
    HRESULT hr;
    hr = _pServiceOps->Pause();
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileService::Continue
//
//  Synopsis:   Attempts to "unpause" the service specified in _bstrServiceName
//              on the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  RamV   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTFileService::Continue(THIS)
{
    HRESULT hr;
    hr = _pServiceOps->Continue();
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::get_Status(THIS_ long FAR* plStatusCode)
{
    HRESULT hr;
    hr = _pServiceOps->get_Status(plStatusCode);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileService::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    HRESULT hr = S_OK;

    hr = GenericGetExPropertyManager(
                ADS_OBJECT_BOUND,
                _pPropertyCache,
                bstrName,
                pvProp
                );

    if(FAILED(hr)){
        hr= _pService->GetEx(bstrName, pvProp );
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTFileService::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{

    HRESULT hr = S_OK;

    hr = GenericPutExPropertyManager(
                _pPropertyCache,
                FileServiceClass,
                gdwFileServiceTableSize,
                bstrName,
                vProp
                );
    if(FAILED(hr)){
        hr= _pService->PutEx(lnControlCode, bstrName, vProp );
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cfpnwsrv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfpnwsrv.cxx
//
//  Contents:  Contains methods for the following objects
//             CFPNWFileService and CFPNWFileServiceGeneralInfo.
//
//
//  History:   12/11/95     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------



#include "winnt.hxx"
#pragma hdrstop
#define INITGUID


//
// class CFPNWFileService methods
//

DEFINE_IDispatch_ExtMgr_Implementation(CFPNWFileService);
DEFINE_IADsExtension_ExtMgr_Implementation(CFPNWFileService);
DEFINE_IADs_TempImplementation(CFPNWFileService);

CFPNWFileService::CFPNWFileService()
{
    _pDispMgr = NULL;
    _pExtMgr  = NULL;
    _pService = NULL;
    _pCFileSharesEnumVar = NULL;
    _pszServerName = NULL;
    _pPropertyCache = NULL;
    ENLIST_TRACKING(CFPNWFileService);
    VariantInit(&_vFilter);
    return;

}

CFPNWFileService::~CFPNWFileService()
{
    if(_pService){
        _pService->Release();
    }

    if (_pServiceOps) {
        _pServiceOps->Release();
    }

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }

    VariantClear(&_vFilter);

    delete _pPropertyCache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileService::CreateFileService
//
//  Synopsis:   Static function used to create a FileService object. This
//              will be called by BindToObject
//
//  Arguments:  [ppFPNWFileService] -- Ptr to a ptr to a new Service object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------

HRESULT
CFPNWFileService::CreateFileService(LPTSTR pszADsParent,
                                    DWORD  dwParentId,
                                    LPTSTR pszDomainName,
                                    LPTSTR pszServerName,
                                    LPTSTR pszFileServiceName,
                                    DWORD  dwObjectState,
                                    REFIID riid,
                                    CWinNTCredentials& Credentials,
                                    LPVOID * ppvoid
                                    )

{
    CFPNWFileService FAR * pCFPNWFileService = NULL;
    HRESULT hr = S_OK;

    //
    // Create the FileService Object
    //

    hr = AllocateFileServiceObject(&pCFPNWFileService);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCFPNWFileService->_pDispMgr);


    hr = pCFPNWFileService->InitializeCoreObject(pszADsParent,
                                                 pszFileServiceName,
                                                 FILESERVICE_CLASS_NAME,
                                                 FPNW_FILESERVICE_SCHEMA_NAME,
                                                 CLSID_FPNWFileService,
                                                 dwObjectState);
    //
    // note that no class fileservice is defined
    //

    BAIL_ON_FAILURE(hr);


    pCFPNWFileService->_Credentials = Credentials;
    hr = pCFPNWFileService->_Credentials.Ref(pszServerName,
        pszDomainName, dwParentId);
    BAIL_ON_FAILURE(hr);

    hr = CWinNTService::Create(pszADsParent,
                               pszDomainName,
                               pszServerName,
                               pszFileServiceName,
                               dwObjectState,
                               IID_IADsService,
                               pCFPNWFileService->_Credentials,
                               (void **)(&(pCFPNWFileService->_pService)));

    BAIL_ON_FAILURE(hr);


    hr = (pCFPNWFileService->_pService)->QueryInterface(
                   IID_IADsServiceOperations,
                   (void **)&(pCFPNWFileService->_pServiceOps));
    BAIL_ON_FAILURE(hr);


    pCFPNWFileService->_pszServerName =
        AllocADsStr(pszServerName);

    if(!(pCFPNWFileService->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pCFPNWFileService->_Credentials = Credentials;
    hr = pCFPNWFileService->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                FILESERVICE_CLASS_NAME,
                (IADsFileService *) pCFPNWFileService,
                pCFPNWFileService->_pDispMgr,
                Credentials,
                &pCFPNWFileService->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCFPNWFileService->_pExtMgr);


    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pCFPNWFileService->_dwNumComponents) {
            pCFPNWFileService->_CompClasses[0] = L"Domain";
            pCFPNWFileService->_CompClasses[1] = L"Computer";
            pCFPNWFileService->_CompClasses[2] = L"FileService";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pCFPNWFileService->InitUmiObject(
                 pCFPNWFileService->_Credentials,
                 FPNWFileServiceClass,
                 gdwFPNWFileServiceTableSize,
                 pCFPNWFileService->_pPropertyCache,
                 (IUnknown *) (INonDelegatingUnknown *) pCFPNWFileService,
                 pCFPNWFileService->_pExtMgr,
                 IID_IUnknown,
                 ppvoid
                 );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }


    hr = pCFPNWFileService->QueryInterface(riid, (void **)ppvoid);
    BAIL_ON_FAILURE(hr);

    pCFPNWFileService->Release();

    RRETURN(hr);

error:

    delete pCFPNWFileService;
    RRETURN (hr);
}

HRESULT
CFPNWFileService::AllocateFileServiceObject(
                    CFPNWFileService  ** ppFileService
                    )
{
    CFPNWFileService FAR * pFileService = NULL;
    HRESULT hr = S_OK;

    pFileService = new CFPNWFileService();
    if (pFileService == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pFileService->_pDispMgr = new CAggregatorDispMgr;
    if (pFileService->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pFileService->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsFileService,
                           (IADsFileService *)pFileService,
                           DISPID_REGULAR);
    BAIL_ON_FAILURE(hr);



    hr =  LoadTypeInfoEntry(pFileService->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsContainer,
                            (IADsContainer *)pFileService,
                            DISPID_NEWENUM);
    BAIL_ON_FAILURE(hr);


    hr =  LoadTypeInfoEntry(pFileService->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsPropertyList,
                            (IADsPropertyList *)pFileService,
                            DISPID_VALUE);
    BAIL_ON_FAILURE(hr);


    hr = CPropertyCache::createpropertycache(
             FPNWFileServiceClass,
             gdwFPNWFileServiceTableSize,
             (CCoreADsObject *)pFileService,
             &(pFileService->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);

    (pFileService->_pDispMgr)->RegisterPropertyCache(
                                  pFileService->_pPropertyCache
                                  );

    *ppFileService = pFileService;

    RRETURN(hr);


error:

    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete  pFileService;

    RRETURN_EXP_IF_ERR(hr);

}



/* IUnknown methods for file service object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CFPNWFileService::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWFileService::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWFileService::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWFileService::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsFileService *)this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsFileService *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileService))
    {
        *ppvObj = (IADsFileService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileServiceOperations))
    {
        *ppvObj = (IADsFileServiceOperations FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsService))
    {
        *ppvObj = (IADsService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsServiceOperations))
    {
        *ppvObj = (IADsServiceOperations FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsContainer))
    {
        *ppvObj = (IADsContainer FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }

    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CFPNWFileService::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{

    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsService) ||
        IsEqualIID(riid, IID_IADsFileService) ||
        IsEqualIID(riid, IID_IADsServiceOperations) ||
        IsEqualIID(riid, IID_IADsFileServiceOperations) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:        RamV  Created
//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWFileService::SetInfo(THIS)
{
    HRESULT hr;
    IADsService * pADsService = NULL;

    ADsAssert(_pService);

    hr = _pService->SetInfo();
    BAIL_IF_ERROR(hr);

    hr = SetFPNWServerInfo();
    BAIL_IF_ERROR(hr);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetInfo
//
//  Synopsis:
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12/11/95    RamV  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWFileService::GetInfo(THIS)
{
    HRESULT hr =S_OK;

    _pPropertyCache->flushpropcache();

    hr = GetInfo(1, TRUE);
    if(FAILED(hr))
        RRETURN_EXP_IF_ERR(hr);

    hr = GetInfo(2,TRUE);

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CFPNWFileService::ImplicitGetInfo(THIS)
{
    HRESULT hr =S_OK;

    hr = GetInfo(1, FALSE);
    if(FAILED(hr))
        RRETURN_EXP_IF_ERR(hr);

    hr = GetInfo(2,FALSE);

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CFPNWFileService::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{

    HRESULT hr =S_OK;
    DWORD dwErrCode;
    switch(dwApiLevel){

    case 1:
        ADsAssert(_pService);
        hr = _pService->GetInfo();
        BAIL_IF_ERROR(hr);
        break;

    case 2:

        hr = GetFPNWServerInfo(fExplicit);
        BAIL_IF_ERROR(hr);
        break;

    default:
        ADsAssert(FALSE);
        break;
    }

cleanup:
    RRETURN (hr);
}


HRESULT
CFPNWFileService::SetFPNWServerInfo(THIS)
{
    PNWSERVERINFO pServerInfo = NULL;
    HRESULT hr = S_OK;
    DWORD dwErrorCode;
    LPTSTR pszDescription = NULL;

    //
    // Do a GetInfo to first get all the information in this server.
    //
    //
    // only level 1 is valid
    //

    dwErrorCode = ADsNwServerGetInfo(_pszServerName,
                                     1,
                                     &pServerInfo);


    hr = HRESULT_FROM_WIN32(dwErrorCode);
    BAIL_IF_ERROR(hr);

    hr = GetLPTSTRPropertyFromCache(_pPropertyCache,
                                    TEXT("Description"),
                                    &pszDescription );

    if(SUCCEEDED(hr)){
        pServerInfo->lpDescription = pszDescription;
    }

    dwErrorCode = ADsNwServerSetInfo(_pszServerName,
                                     1,
                                     pServerInfo);


    hr = HRESULT_FROM_WIN32(dwErrorCode);
    BAIL_IF_ERROR(hr);

cleanup:
    if(pServerInfo){
        ADsNwApiBufferFree(pServerInfo);
    }
    if(pszDescription){
        FreeADsStr(pszDescription);
    }
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CFPNWFileService::GetFPNWServerInfo(THIS_ BOOL fExplicit)
{
    //
    // here we do a NwServerGetInfo on level1 and then unmarshall the
    // comment field into description
    //

    DWORD dwErrorCode;
    PNWSERVERINFO pServerInfo =NULL;
    HRESULT hr;

    //
    // only level 1 is valid
    //

    dwErrorCode = ADsNwServerGetInfo(_pszServerName,
                                     1,
                                     &pServerInfo);


    hr = HRESULT_FROM_WIN32(dwErrorCode);
    BAIL_IF_ERROR(hr);


    //
    // unmarshall the info into the Description field
    //

    ADsAssert(pServerInfo);


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  pServerInfo->lpDescription,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostComputer"),
                                  _Parent,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("MaxUserCount"),
                                 (DWORD)-1,
                                 fExplicit
                                 );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    hr = S_OK;

cleanup:
    if(pServerInfo){
        ADsNwApiBufferFree(pServerInfo);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;

    hr = GenericGetPropertyManager(
                _pPropertyCache,
                bstrName,
                pvProp
                );

    if(FAILED(hr)){
        hr= _pService->Get(bstrName, pvProp );
    }

    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CFPNWFileService::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;

    hr = GenericPutPropertyManager(
                _pPropertyCache,
                FPNWFileServiceClass,
                gdwFPNWFileServiceTableSize,
                bstrName,
                vProp
                );
    if(FAILED(hr)){
        hr= _pService->Put(bstrName, vProp );
    }

    RRETURN_EXP_IF_ERR(hr);
}


//
// IADsService Methods
//


/* IADsContainer methods */

STDMETHODIMP
CFPNWFileService::get_Count(long * retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CFPNWFileService::get_Filter(THIS_ VARIANT * pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CFPNWFileService::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CFPNWFileService::GetObject(THIS_ BSTR ClassName,
                             BSTR RelativeName,
                             IDispatch * FAR* ppObject
                             )
{
    HRESULT hr;
    DWORD dwObjectType;
    POBJECTINFO pObjectInfo = NULL;

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       ClassName,
                       (PDWORD)&dwObjectType);

    BAIL_IF_ERROR(hr);

    if(dwObjectType != WINNT_FILESHARE_ID){
        //
        // trying to create an invalid object at this level
        //
        hr = E_FAIL;
        goto error;

    }

    hr = BuildObjectInfo(_ADsPath,
                         RelativeName,
                         &pObjectInfo);

    BAIL_ON_FAILURE(hr);

    hr = ValidateObject(dwObjectType,
                        pObjectInfo,
                        _Credentials);

    BAIL_ON_FAILURE(hr);

    //
    // The only object that has a file service as a container is
    // a file share object
    //

    hr = CFPNWFileShare::Create(_ADsPath,
                                 pObjectInfo->ComponentArray[1],
                                 pObjectInfo->ComponentArray[2],
                                 RelativeName,
                                 ADS_OBJECT_UNBOUND,
                                 IID_IDispatch,
                                 _Credentials,
                                 (void**)ppObject);

    BAIL_ON_FAILURE(hr);

error:
cleanup:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CFPNWFileService::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr = S_OK;

    CFPNWFileSharesEnumVar *pCFileSharesEnumVar = NULL;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    *retval = NULL;

    hr = CFPNWFileSharesEnumVar::Create(_pszServerName,
                                        _ADsPath,
                                        &pCFileSharesEnumVar,
                                        _vFilter,
                                        _Credentials);

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCFileSharesEnumVar);

    _pCFileSharesEnumVar = pCFileSharesEnumVar;

    hr = _pCFileSharesEnumVar->QueryInterface(IID_IUnknown,
                                              (void **)retval);

    _pCFileSharesEnumVar->Release();
    _pCFileSharesEnumVar = NULL;

    BAIL_ON_FAILURE(hr);


    RRETURN(hr);

error:
    delete pCFileSharesEnumVar;

    _pCFileSharesEnumVar = NULL;



    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CFPNWFileService::Create(
        THIS_ BSTR ClassName,
        BSTR RelativeName,
        IDispatch * FAR* ppObject
        )
{

    DWORD dwObjectType = 0;
    HRESULT hr = S_OK;
    POBJECTINFO pObjectInfo = NULL;

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       ClassName,
                       (PDWORD)&dwObjectType);

    BAIL_IF_ERROR(hr);


    if(!(dwObjectType == WINNT_FILESHARE_ID ||
         dwObjectType == WINNT_FPNW_FILESHARE_ID)){
        //
        // trying to create an invalid object at this level
        //
        hr = E_FAIL;
        goto error;

    }



    hr = BuildObjectInfo(_ADsPath,
                         RelativeName,
                         &pObjectInfo);

    BAIL_ON_FAILURE(hr);

    hr = ValidateObject(dwObjectType,
                        pObjectInfo,
                        _Credentials);

    if(SUCCEEDED(hr)){
        hr = E_ADS_OBJECT_EXISTS;
        goto error;
    }

    //
    // The only object that has a file service as a container is
    // a file share object



    hr = CFPNWFileShare::Create(_ADsPath,
                                 pObjectInfo->ComponentArray[1],
                                 pObjectInfo->ComponentArray[2],
                                 RelativeName,
                                 ADS_OBJECT_UNBOUND,
                                 IID_IDispatch,
                                 _Credentials,
                                 (void**)ppObject);

    BAIL_ON_FAILURE(hr);



error:
cleanup:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CFPNWFileService::Delete(THIS_ BSTR Type,
                          BSTR SourceName
                          )
{
    HRESULT hr;
    DWORD dwObjectType = 0;
    POBJECTINFO pObjectInfo = NULL;

    // Check to make sure the input parameters are valid
    if (Type == NULL || SourceName == NULL) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = GetObjectType(gpFilters,
                       gdwMaxFilters,
                       Type,
                       (PDWORD)&dwObjectType);

    BAIL_IF_ERROR(hr);


    if(dwObjectType != WINNT_FILESHARE_ID){
        //
        // trying to delete an invalid object at this level
        //
        hr = E_FAIL;
        goto cleanup;

    }



    hr = BuildObjectInfo(_ADsPath,
                         SourceName,
                         &pObjectInfo);

    BAIL_IF_ERROR(hr);

    hr = FPNWDeleteFileShare(pObjectInfo);


cleanup:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileService::CopyHere(THIS_ BSTR SourceName,
                            BSTR NewName,
                            IDispatch * FAR* ppObject
                            )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CFPNWFileService::MoveHere(THIS_ BSTR SourceName,
                            BSTR NewName,
                            IDispatch * FAR* ppObject
                            )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}



/* IADsFSFileServiceGeneralInfo methods */


STDMETHODIMP
CFPNWFileService::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CFPNWFileService::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsFileService *)this, Description);
}

STDMETHODIMP
CFPNWFileService::get_MaxUserCount(THIS_ long FAR* retval)
{
    //
    // here -1 signifies no limit
    //
    if(!retval){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }
    *retval = -1;
    RRETURN(S_OK);
}

STDMETHODIMP CFPNWFileService::put_MaxUserCount(THIS_ long lMaxUserCount)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}



STDMETHODIMP
CFPNWFileService::Sessions(THIS_ IADsCollection ** ppSessions)
{
    //
    // The session collection object is created and it is passed the server
    // name. It uses this to create the session object
    //

    HRESULT hr = S_OK;

    CFPNWSessionsCollection * pSessionsCollection = NULL;

    if(!ppSessions){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    hr = CFPNWSessionsCollection::Create(_ADsPath,
                                         _Credentials,
                                          &pSessionsCollection);

    BAIL_IF_ERROR(hr);

    hr = pSessionsCollection->QueryInterface(IID_IADsCollection,
                                             (void **) ppSessions);

    BAIL_IF_ERROR(hr);

    pSessionsCollection->Release();

cleanup:

    if(FAILED(hr)){
        delete pSessionsCollection;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileService::Resources(THIS_ IADsCollection FAR* FAR* ppResources)
{
    //
    // The resource collection object is created and it is passed the server
    // name. It uses this to create the resource object
    //

    HRESULT hr = S_OK;

    CFPNWResourcesCollection * pResourcesCollection = NULL;

    if(!ppResources){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    hr = CFPNWResourcesCollection::Create(_ADsPath,
                                           NULL,
                                           _Credentials,
                                           &pResourcesCollection);

    BAIL_IF_ERROR(hr);

    hr = pResourcesCollection->QueryInterface(IID_IADsCollection,
                                              (void **) ppResources);

    BAIL_IF_ERROR(hr);

    pResourcesCollection->Release();

cleanup:

    if(FAILED(hr)){
        delete pResourcesCollection;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileService::get_HostComputer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_HostComputer(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    HRESULT hr;
    hr = _pService->put_HostComputer(bstrHostComputer);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_DisplayName(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_DisplayName(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_DisplayName(THIS_ BSTR bstrDisplayName)
{
    HRESULT hr;
    hr = _pService->put_DisplayName(bstrDisplayName);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_Version(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_Version(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_Version(THIS_ BSTR bstrVersion)
{
    HRESULT hr;
    hr = _pService->put_Version(bstrVersion);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_ServiceType(THIS_ long FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ServiceType(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_ServiceType(THIS_ long lServiceType)
{
    HRESULT hr;
    hr = _pService->put_ServiceType(lServiceType);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_StartType(THIS_ LONG FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_StartType(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_StartType(THIS_ LONG lStartType)
{
    HRESULT hr;
    hr = _pService->put_StartType(lStartType);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_Path(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_Path(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_Path(THIS_ BSTR bstrPath)
{
    HRESULT hr;
    hr = _pService->put_Path(bstrPath);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_StartupParameters(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_StartupParameters(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_StartupParameters(THIS_ BSTR bstrStartupParameters)
{
    HRESULT hr;
    hr = _pService->put_StartupParameters(bstrStartupParameters);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_ErrorControl(THIS_ LONG FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ErrorControl(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_ErrorControl(THIS_ LONG lErrorControl)
{
    HRESULT hr;
    hr = _pService->put_ErrorControl(lErrorControl);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_LoadOrderGroup(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_LoadOrderGroup(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_LoadOrderGroup(THIS_ BSTR bstrLoadOrderGroup)
{
    HRESULT hr;
    hr = _pService->put_LoadOrderGroup(bstrLoadOrderGroup);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileService::get_ServiceAccountName(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ServiceAccountName(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_ServiceAccountName(THIS_ BSTR bstrServiceAccountName)
{
    HRESULT hr;
    hr = _pService->put_ServiceAccountName(bstrServiceAccountName);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_ServiceAccountPath(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_ServiceAccountPath(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_ServiceAccountPath(THIS_ BSTR bstrServiceAccountName)
{
    HRESULT hr;
    hr = _pService->put_ServiceAccountPath(bstrServiceAccountName);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_Dependencies(THIS_ VARIANT FAR* retval)
{
    HRESULT hr;
    hr = _pService->get_Dependencies(retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::put_Dependencies(THIS_ VARIANT vDependencies)
{
    HRESULT hr;
    hr = _pService->put_Dependencies(vDependencies);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::SetPassword(THIS_ BSTR bstrNewPassword)
{
    HRESULT hr;
    hr = _pServiceOps->SetPassword(bstrNewPassword);
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileService::Start
//
//  Synopsis:   Attempts to start the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  RamV    Created
//
// Notes:
//----------------------------------------------------------------------------

STDMETHODIMP
CFPNWFileService::Start(THIS)
{
    HRESULT hr;
    hr = _pServiceOps->Start();
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileService::Stop
//
//  Synopsis:   Attempts to stop the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96 RamV    Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWFileService::Stop(THIS)
{
    HRESULT hr;
    hr = _pServiceOps->Stop();
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileService::Pause
//
//  Synopsis:   Attempts to pause the service named _bstrServiceName on the
//              server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01-04-96    RamV     Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWFileService::Pause(THIS)

{
    HRESULT hr;
    hr = _pServiceOps->Pause();
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CFPNWFileService::Continue
//
//  Synopsis:   Attempts to "unpause" the service specified in _bstrServiceName
//              on the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  RamV   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWFileService::Continue(THIS)
{
    HRESULT hr;
    hr = _pServiceOps->Continue();
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWFileService::get_Status(THIS_ long FAR* plStatusCode)
{
    HRESULT hr;
    hr = _pServiceOps->get_Status(plStatusCode);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileService::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    HRESULT hr = S_OK;

    hr = GenericGetExPropertyManager(
                ADS_OBJECT_BOUND,
                _pPropertyCache,
                bstrName,
                pvProp
                );

    if(FAILED(hr)){
        hr= _pService->GetEx(bstrName, pvProp );
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CFPNWFileService::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{

    HRESULT hr = S_OK;

    hr = GenericPutExPropertyManager(
                _pPropertyCache,
                FPNWFileServiceClass,
                gdwFPNWFileServiceTableSize,
                bstrName,
                vProp
                );
    if(FAILED(hr)){
        hr= _pService->PutEx(lnControlCode, bstrName, vProp );
    }

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cfpnwres.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cfpnwres.cxx
//
//  Contents:  Contains methods for the following objects
//             CFPNWResource, CFPNWFSResourceGeneralInfo
//
//
//  History:   05/01/96     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

DECLARE_INFOLEVEL( FPNWResource );
DECLARE_DEBUG( FPNWResource );
#define FPNWResourceDebugOut(x) FPNWResourceInlineDebugOut x


DEFINE_IDispatch_ExtMgr_Implementation(CFPNWResource);
DEFINE_IADsExtension_ExtMgr_Implementation(CFPNWResource);
DEFINE_IADs_TempImplementation(CFPNWResource);
DEFINE_IADs_PutGetImplementation(CFPNWResource,FPNWResourceClass,gdwFPNWResourceTableSize) ;
DEFINE_IADsPropertyList_Implementation(CFPNWResource, FPNWResourceClass,gdwFPNWResourceTableSize)


CFPNWResource::CFPNWResource()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pszServerName = NULL;
    _pPropertyCache = NULL;
    _pszServerADsPath = NULL;
    _pszUserName = NULL;
    _pszPath = NULL;

    ENLIST_TRACKING(CFPNWResource);
    return;

}

CFPNWResource::~CFPNWResource()
{
    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    if (_pszServerADsPath)
    {
        FreeADsStr(_pszServerADsPath);
    }
    if (_pszUserName)
    {
        ADsFreeString(_pszUserName);
    }
    if (_pszPath)
    {
        FreeADsStr(_pszPath);
    }

    delete _pPropertyCache;

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CFPNWResource::Create
//
//  Synopsis:   Static function used to create a Resource object. This
//              will be called by EnumResources::Next
//
//  Arguments:  [ppFPNWResource] -- Ptr to a ptr to a new Resource object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
CFPNWResource::Create(LPTSTR pszServerADsPath,
                      PNWFILEINFO pFileInfo,
                      DWORD  dwObject,
                      REFIID riid,
                      CWinNTCredentials& Credentials,
                      LPVOID * ppvoid
                      )

{

    CFPNWResource FAR * pCFPNWResource = NULL;
    HRESULT hr;
    TCHAR szFileName[MAX_LONG_LENGTH];
    TCHAR szUncServerName[MAX_PATH];


    hr =CFPNWResource::AllocateResourceObject(pszServerADsPath,
                                              pFileInfo,
                                              &pCFPNWResource );
    BAIL_IF_ERROR(hr);

    ADsAssert(pCFPNWResource->_pDispMgr);


    //
    // convert the FileId that we have into a string that we move
    // into the Name field
    //

    _ltow(pFileInfo->dwFileId, szFileName, 10);

    hr = pCFPNWResource->InitializeCoreObject(pszServerADsPath,
                                              szFileName,
                                              RESOURCE_CLASS_NAME,
                                              FPNW_RESOURCE_SCHEMA_NAME,
                                              CLSID_FPNWResource,
                                              dwObject);

    pCFPNWResource->_dwFileId = pFileInfo->dwFileId;

    pCFPNWResource->_Credentials = Credentials;
    hr = pCFPNWResource->_Credentials.RefServer(
        pCFPNWResource->_pszServerName);
    BAIL_IF_ERROR(hr);

    hr = SetLPTSTRPropertyInCache(
                pCFPNWResource->_pPropertyCache,
                TEXT("Name"),
                pCFPNWResource->_Name,
                TRUE
                );
    BAIL_IF_ERROR(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                RESOURCE_CLASS_NAME,
                (IADs* ) pCFPNWResource,
                pCFPNWResource->_pDispMgr,
                Credentials,
                &pCFPNWResource->_pExtMgr
                );
    BAIL_IF_ERROR(hr);

    ADsAssert(pCFPNWResource->_pExtMgr);


    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        // Resource objects have "" as their ADsPath. Just set the class to
        // resource for identification purposes.
        pCFPNWResource->_CompClasses[0] = L"Resource";

        hr = pCFPNWResource->InitUmiObject(
                 pCFPNWResource->_Credentials, 
                 FPNWResourceClass,
                 gdwFPNWResourceTableSize,
                 pCFPNWResource->_pPropertyCache,
                 (IUnknown *) (INonDelegatingUnknown *) pCFPNWResource,
                 pCFPNWResource->_pExtMgr,
                 IID_IUnknown,
                 ppvoid
                 );

        BAIL_IF_ERROR(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    ADsAssert(ppvoid);
    hr = pCFPNWResource->QueryInterface(riid, (void **)ppvoid);
    BAIL_IF_ERROR(hr);

    pCFPNWResource->Release();

    RRETURN(hr);

cleanup:
    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }
    delete pCFPNWResource;
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CFPNWResource::AllocateResourceObject(LPTSTR pszServerADsPath,
                                      PNWFILEINFO pFileInfo,
                                      CFPNWResource ** ppResource)
{

    CFPNWResource FAR * pCFPNWResource = NULL;
    HRESULT hr;
    TCHAR szFileName[MAX_LONG_LENGTH];
    TCHAR szUncServerName[MAX_PATH];
    POBJECTINFO pServerObjectInfo = NULL;

    //
    // Create the Resource Object
    //

    pCFPNWResource = new CFPNWResource();
    if (pCFPNWResource == NULL) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }


    pCFPNWResource->_pDispMgr = new CAggregatorDispMgr;

    if(pCFPNWResource ->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr =  LoadTypeInfoEntry(pCFPNWResource->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsResource,
                            (IADsResource *)pCFPNWResource,
                            DISPID_REGULAR);

    BAIL_IF_ERROR(hr);

    hr =  LoadTypeInfoEntry(pCFPNWResource->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsPropertyList,
                            (IADsPropertyList *)pCFPNWResource,
                            DISPID_VALUE);

    BAIL_IF_ERROR(hr);



    pCFPNWResource->_pszServerADsPath =
        AllocADsStr(pszServerADsPath);

    if(!(pCFPNWResource->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo);
    BAIL_IF_ERROR(hr);


    pCFPNWResource->_pszServerName =
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!(pCFPNWResource->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = CPropertyCache::createpropertycache(
             FPNWResourceClass,
             gdwFPNWResourceTableSize,
             (CCoreADsObject *)pCFPNWResource,
             &(pCFPNWResource->_pPropertyCache)
             );


    hr = SetLPTSTRPropertyInCache(pCFPNWResource->_pPropertyCache,
                                  TEXT("User"),
                                  pFileInfo->lpUserName,
                                  TRUE
                                  );

    BAIL_IF_ERROR(hr);

    hr = ADsAllocString(pFileInfo->lpUserName,
                          &(pCFPNWResource->_pszUserName));
    BAIL_IF_ERROR(hr);

    hr = SetLPTSTRPropertyInCache(pCFPNWResource->_pPropertyCache,
                                  TEXT("Path"),
                                  pFileInfo->lpPathName,
                                  TRUE
                                  );

    BAIL_IF_ERROR(hr);


    pCFPNWResource->_pszPath =
        AllocADsStr(pFileInfo->lpPathName);

    if(!(pCFPNWResource->_pszPath)){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = SetDWORDPropertyInCache(pCFPNWResource->_pPropertyCache,
                                 TEXT("LockCount"),
                                 pFileInfo->dwLocks,
                                 TRUE
                                 );

    pCFPNWResource->_dwLockCount = pFileInfo->dwLocks;


    pCFPNWResource->_pDispMgr->RegisterPropertyCache(
                                  pCFPNWResource->_pPropertyCache
                                  );

    *ppResource = pCFPNWResource;

cleanup:

    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if (!SUCCEEDED(hr)) {

        //
        // direct memeber assignement assignement at pt of creation, so
        // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
        // of deletion again in pPrintJob destructor and AV
        //

        delete pCFPNWResource;
    }

    RRETURN(hr);
}





/* IUnknown methods for Resource object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CFPNWResource::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWResource::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CFPNWResource::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWResource::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(ppvObj == NULL){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADs *) this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADs *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsResource))
    {
        *ppvObj = (IADsResource FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CFPNWResource::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsResource) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   SetInfo on actual Resource
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    02/08/96    RamV  Created

//----------------------------------------------------------------------------


STDMETHODIMP
CFPNWResource::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}



STDMETHODIMP
CFPNWResource::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN(S_OK);
}

STDMETHODIMP
CFPNWResource::ImplicitGetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CFPNWResource::get_User(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = ADsAllocString(_pszUserName, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWResource::get_UserPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CFPNWResource::get_Path(THIS_ BSTR FAR* retval)
{
    HRESULT hr;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = ADsAllocString(_pszPath, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CFPNWResource::get_LockCount(THIS_ LONG FAR* retval)
{
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    *retval = _dwLockCount;
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cfshare.cxx ===
//--------------------------------------------------------------------------/
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996
//
//  File:  cfshare.cxx
//
//  Contents:  Contains methods for the following objects
//             CWinNTFileShare, CWinNTFileShareGeneralInfo
//
//
//  History:   02/15/96     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

#if DBG
DECLARE_INFOLEVEL(FileShare );
DECLARE_DEBUG( FileShare);
#define FileShareDebugOut(x) FileShareInlineDebugOut x
#endif

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTFileShare);
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTFileShare);
DEFINE_IADs_TempImplementation(CWinNTFileShare);
DEFINE_IADs_PutGetImplementation(CWinNTFileShare,FileShareClass, gdwFileShareTableSize);
DEFINE_IADsPropertyList_Implementation(CWinNTFileShare, FileShareClass, gdwFileShareTableSize)

CWinNTFileShare::CWinNTFileShare()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pszShareName = NULL;
    _pPropertyCache = NULL;
    _pszServerName = NULL;

    ENLIST_TRACKING(CWinNTFileShare);


    return;

}

CWinNTFileShare::~CWinNTFileShare()
{

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszShareName){
        FreeADsStr(_pszShareName);
    }

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }
    delete _pPropertyCache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTFileShare::Create
//
//  Synopsis:   Static function used to create a FileShare object. This
//              will be called by EnumFileShares::Next
//
//  Arguments:  [ppWinNTFileShare] -- Ptr to a ptr to a new FileShare object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
CWinNTFileShare::Create(LPTSTR pszADsParent,
                        LPTSTR pszServerName,
                        LPTSTR pszServiceName,
                        LPTSTR pszShareName,
                        DWORD  dwObject,
                        REFIID riid,
                        CWinNTCredentials& Credentials,
                        LPVOID * ppvoid
                        )

{

    CWinNTFileShare FAR * pCWinNTFileShare = NULL;
    HRESULT hr;

    //
    // Create the FileShare Object
    //

    hr = AllocateFileShareObject(pszADsParent,
                                 pszServerName,
                                 pszServiceName,
                                 pszShareName,
                                 &pCWinNTFileShare );

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTFileShare->_pDispMgr);


    hr = pCWinNTFileShare->InitializeCoreObject(pszADsParent,
                                                pszShareName,
                                                FILESHARE_CLASS_NAME,
                                                FILESHARE_SCHEMA_NAME,
                                                CLSID_WinNTFileShare,
                                                dwObject);

    BAIL_ON_FAILURE(hr);

    pCWinNTFileShare->_Credentials = Credentials;
    hr = pCWinNTFileShare->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                FILESHARE_CLASS_NAME,
                (IADs *) pCWinNTFileShare,
                pCWinNTFileShare->_pDispMgr,
                Credentials,
                &pCWinNTFileShare->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTFileShare->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(4 == pCWinNTFileShare->_dwNumComponents) {
            pCWinNTFileShare->_CompClasses[0] = L"Domain";
            pCWinNTFileShare->_CompClasses[1] = L"Computer";
            pCWinNTFileShare->_CompClasses[2] = L"FileService";
            pCWinNTFileShare->_CompClasses[3] = L"FileShare";
        }
        else if(3 == pCWinNTFileShare->_dwNumComponents) {
            pCWinNTFileShare->_CompClasses[0] = L"Computer";
            pCWinNTFileShare->_CompClasses[1] = L"FileService";
            pCWinNTFileShare->_CompClasses[2] = L"FileShare";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pCWinNTFileShare->InitUmiObject(
                pCWinNTFileShare->_Credentials,
                FileShareClass, 
                gdwFileShareTableSize,
                pCWinNTFileShare->_pPropertyCache,
                (IUnknown *) (INonDelegatingUnknown *) pCWinNTFileShare,
                pCWinNTFileShare->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pCWinNTFileShare->QueryInterface(riid, (void **)ppvoid);
    BAIL_ON_FAILURE(hr);

    pCWinNTFileShare->Release();

    RRETURN(hr);

error:

    delete pCWinNTFileShare;
    RRETURN (hr);

}

HRESULT
CWinNTFileShare::AllocateFileShareObject(LPTSTR pszADsParent,
                                         LPTSTR pszServerName,
                                         LPTSTR pszServiceName,
                                         LPTSTR pszShareName,
                                         CWinNTFileShare ** ppFileShare
                                         )
{

    CWinNTFileShare * pCWinNTFileShare = NULL;
    HRESULT hr;

    //
    // Create the FileShare Object
    //

    pCWinNTFileShare = new CWinNTFileShare();
    if (pCWinNTFileShare == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pCWinNTFileShare->_pDispMgr = new CAggregatorDispMgr;

    if(pCWinNTFileShare ->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr =  LoadTypeInfoEntry(pCWinNTFileShare->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsFileShare,
                            (IADsFileShare *)pCWinNTFileShare,
                            DISPID_REGULAR );


    BAIL_ON_FAILURE(hr);

    hr =  LoadTypeInfoEntry(pCWinNTFileShare->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsPropertyList,
                            (IADsPropertyList *)pCWinNTFileShare,
                            DISPID_VALUE );

    BAIL_ON_FAILURE(hr);


    pCWinNTFileShare->_pszServerName =
        AllocADsStr(pszServerName);

    if(!(pCWinNTFileShare->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pCWinNTFileShare->_pszShareName =
        AllocADsStr(pszShareName);

    if(!(pCWinNTFileShare->_pszShareName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = CPropertyCache::createpropertycache(
             FileShareClass,
             gdwFileShareTableSize,
             (CCoreADsObject *)pCWinNTFileShare,
             &(pCWinNTFileShare ->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);

    (pCWinNTFileShare->_pDispMgr)->RegisterPropertyCache(
                                        pCWinNTFileShare->_pPropertyCache
                                        );

    *ppFileShare = pCWinNTFileShare;

    RRETURN(hr);

error:

    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete pCWinNTFileShare;

    RRETURN (hr);

}

/* IUnknown methods for FileShare object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTFileShare::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTFileShare::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTFileShare::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTFileShare::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADs *) this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADs *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }

    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsFileShare))
    {
        *ppvObj = (IADsFileShare FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTFileShare::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsFileShare) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   SetInfo on actual FileShare
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    02/08/96    RamV  Created

//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTFileShare::SetInfo(THIS)
{

    NET_API_STATUS nasStatus;
    LPSHARE_INFO_2 lpShareInfo2 = NULL;
    HRESULT hr = S_OK;
    TCHAR  szUncServerName[MAX_PATH];
    BOOL fNewFileShare = FALSE;


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = WinNTAddFileShare();
        BAIL_IF_ERROR(hr);

        SetObjectState(ADS_OBJECT_BOUND);
        fNewFileShare = TRUE;

    }


    //
    // First get the information and modify only those fields which
    // have been changed by user
    //


    hr = MakeUncName(_pszServerName, szUncServerName);
    BAIL_IF_ERROR(hr);

    nasStatus = NetShareGetInfo(szUncServerName,
                                _pszShareName,
                                2,
                                (LPBYTE *)&lpShareInfo2);

    if (nasStatus != NERR_Success || !lpShareInfo2){
        hr = HRESULT_FROM_WIN32(nasStatus);
        goto cleanup;
    }

    hr = MarshallAndSet(lpShareInfo2);

    BAIL_IF_ERROR(hr);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:

    if (FAILED(hr) && fNewFileShare) {
        //
        // Try and delete the fileshare as the SetInfo as a
        // whole failed but the create part was successful.
        //
        nasStatus = NetShareDel(
                        szUncServerName,
                        _pszShareName,
                        0
                        );

    }

    if(lpShareInfo2)
        NetApiBufferFree(lpShareInfo2);

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTFileShare::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    HRESULT hr = S_OK;

    switch(dwApiLevel){

    case 1:
        hr = GetLevel1Info(fExplicit);
        BAIL_IF_ERROR(hr);
        break;

    case 2:
        hr = GetLevel2Info(fExplicit);
        BAIL_IF_ERROR(hr);
        break;

    default:
        //
        // we should not be here
        //
        ADsAssert(FALSE);
        break;
    }

cleanup:
    RRETURN_EXP_IF_ERR (hr);
}


STDMETHODIMP
CWinNTFileShare::GetInfo(THIS)
{
    RRETURN(GetInfo(2,TRUE));
}

STDMETHODIMP
CWinNTFileShare::ImplicitGetInfo(THIS)
{
    RRETURN(GetInfo(2,FALSE));
}

//
// helper functions for GetInfo and SetInfo
//

HRESULT
CWinNTFileShare::GetLevel2Info(THIS_ BOOL fExplicit)
{
    //
    // here we do a NetShareGetInfo on level 2 and unmarshall the relevant
    // fields
    //

    NET_API_STATUS nasStatus;
    LPSHARE_INFO_2 lpShareInfo2 = NULL;
    HRESULT hr;
    TCHAR  szUncServerName[MAX_PATH];
    POBJECTINFO pObjectInfo = NULL;
    TCHAR  szComputerPath[MAX_PATH];

    hr = MakeUncName(_pszServerName, szUncServerName);
    BAIL_IF_ERROR(hr);

    nasStatus = NetShareGetInfo(szUncServerName,
                                _pszShareName,
                                2,
                                (LPBYTE *)&lpShareInfo2);

    if (nasStatus != NERR_Success || !lpShareInfo2){
        hr = HRESULT_FROM_WIN32(nasStatus);
        goto cleanup;
    }

    //
    // unmarshall the info
    //

    hr = BuildObjectInfo(_Parent, &pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = BuildComputerFromObjectInfo(pObjectInfo,
                                     szComputerPath);

    BAIL_IF_ERROR(hr);

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostComputer"),
                                  szComputerPath,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  lpShareInfo2->shi2_remark,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Path"),
                                  lpShareInfo2->shi2_path,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("CurrentUserCount"),
                                  lpShareInfo2->shi2_current_uses,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("MaxUserCount"),
                                  lpShareInfo2->shi2_max_uses,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

cleanup:
    if(lpShareInfo2){
        NetApiBufferFree(lpShareInfo2);
    }
    FreeObjectInfo(pObjectInfo);
    RRETURN(hr);
}


HRESULT
CWinNTFileShare::GetLevel1Info(THIS_ BOOL fExplicit)
{

    //
    // here we do a NetShareGetInfo on level 1 and unmarshall the relevant
    // fields
    //

    NET_API_STATUS nasStatus;
    LPSHARE_INFO_1 lpShareInfo1 = NULL;
    HRESULT hr;
    TCHAR  szUncServerName[MAX_PATH];
    POBJECTINFO pObjectInfo = NULL;
    TCHAR  szComputerPath[MAX_PATH];

    hr = MakeUncName(_pszServerName, szUncServerName);
    BAIL_IF_ERROR(hr);

    nasStatus = NetShareGetInfo(szUncServerName,
                                _pszShareName,
                                1,
                                (LPBYTE *)&lpShareInfo1);

    if (nasStatus != NERR_Success || !lpShareInfo1){
        hr = HRESULT_FROM_WIN32(nasStatus);
        goto cleanup;
    }

    //
    // unmarshall the info
    //


  //
    // unmarshall the info
    //

    hr = BuildObjectInfo(_Parent, &pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = BuildComputerFromObjectInfo(pObjectInfo,
                                     szComputerPath);

    BAIL_IF_ERROR(hr);

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostComputer"),
                                  szComputerPath,
                                  fExplicit
                                  );

cleanup:
    if(lpShareInfo1)
        NetApiBufferFree(lpShareInfo1);

    FreeObjectInfo(pObjectInfo);
    RRETURN(hr);
}


HRESULT
CWinNTFileShare::WinNTAddFileShare(void)
{
    TCHAR szUncServerName[MAX_ADS_PATH];
    NET_API_STATUS nasStatus;
    SHARE_INFO_2  ShareInfo2;
    DWORD     dwParmErr;
    DWORD    dwMaxUserCount;
    LPTSTR   pszPath = NULL;
    LPTSTR   pszDescription = NULL;
    HRESULT hr = S_OK;

    hr = MakeUncName(_pszServerName, szUncServerName);
    BAIL_IF_ERROR(hr);

    //
    // Fill the ShareInfo2 structure
    //

    ShareInfo2.shi2_netname = _pszShareName;
    ShareInfo2.shi2_type = STYPE_DISKTREE;

    hr = GetLPTSTRPropertyFromCache(_pPropertyCache,
                                    TEXT("Path"),
                                    &pszPath);

    if(SUCCEEDED(hr)){
        ShareInfo2.shi2_path = pszPath;
    } else {
        ShareInfo2.shi2_path = _T("");
    }

    hr = GetLPTSTRPropertyFromCache(_pPropertyCache,
                                    TEXT("Description"),
                                    &pszDescription);

    if(SUCCEEDED(hr)){
        ShareInfo2.shi2_remark = pszDescription;
    } else {
        ShareInfo2.shi2_remark = TEXT("");
    }

   hr = GetDWORDPropertyFromCache(_pPropertyCache,
                                  TEXT("MaxUserCount"),
                                  &dwMaxUserCount);

    if(SUCCEEDED(hr)){
        ShareInfo2.shi2_max_uses = dwMaxUserCount;
    } else {
        ShareInfo2.shi2_max_uses = -1;  // unlimited
    }


    ShareInfo2.shi2_permissions = ACCESS_ALL & ~ ACCESS_PERM;
    ShareInfo2.shi2_current_uses = 0;
    ShareInfo2.shi2_passwd = NULL;

    nasStatus = NetShareAdd(szUncServerName,
                            2,
                            (LPBYTE )&ShareInfo2,
                            &dwParmErr);

    if(nasStatus != NERR_Success){

#if DBG
        FileShareDebugOut((DEB_TRACE,
                           "NetShareAdd : parameter %ld unknown\n",
                           dwParmErr));
#endif
        hr = HRESULT_FROM_WIN32(nasStatus);
        goto cleanup;
    } else{
        hr = S_OK;
    }

 cleanup:

    if(pszPath){
        FreeADsStr(pszPath);
    }
    if(pszDescription){
        FreeADsStr(pszDescription);
    }
    RRETURN(hr);
}


STDMETHODIMP
CWinNTFileShare::get_CurrentUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, CurrentUserCount);
}

STDMETHODIMP
CWinNTFileShare::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, Description);
}

STDMETHODIMP
CWinNTFileShare::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsFileShare *)this, Description);
}

STDMETHODIMP
CWinNTFileShare::get_HostComputer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;
    TCHAR szComputerName[MAX_PATH];

    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = BuildObjectInfo(_Parent, &pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = BuildComputerFromObjectInfo(pObjectInfo,
                                     szComputerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(szComputerName, retval);

error:
    FreeObjectInfo(pObjectInfo);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTFileShare::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTFileShare::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsFileShare *)this, Path);
}

STDMETHODIMP
CWinNTFileShare::put_Path(THIS_ BSTR bstrPath)
{
    //
    // note that path can be set only prior to creation
    // of the object. It cannot be changed later.
    //

    if(GetObjectState() == ADS_OBJECT_UNBOUND){
        PUT_PROPERTY_BSTR((IADsFileShare *)this, Path);
    } else {
        RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
    }
}

STDMETHODIMP
CWinNTFileShare::get_MaxUserCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsFileShare *)this, MaxUserCount);
}

STDMETHODIMP
CWinNTFileShare::put_MaxUserCount(THIS_ LONG lMaxUserCount)
{
    PUT_PROPERTY_LONG((IADsFileShare *)this, MaxUserCount);
}


HRESULT
CWinNTFileShare::MarshallAndSet(LPSHARE_INFO_2 lpShareInfo2)
{
    HRESULT hr = S_OK;
    LPTSTR   pszDescription = NULL;
    LPTSTR   pszPath        = NULL;
    DWORD    dwValue;
    TCHAR   szUncServerName[MAX_PATH];
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;

    hr = MakeUncName(_pszServerName,
                     szUncServerName);

    BAIL_IF_ERROR(hr);

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );
    if(SUCCEEDED(hr)){
        lpShareInfo2->shi2_remark = pszDescription;
    }

   hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Path"),
                    &pszPath
                    );
   //
   // pszPath should not be NULL - sanity check to catch prefix issue.
   //
   if(SUCCEEDED(hr) && pszPath) {
#ifdef WIN95
        if (_wcsicmp(lpShareInfo2->shi2_path, pszPath) ) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                lpShareInfo2->shi2_path,
                -1,
                pszPath,
                -1
                ) != CSTR_EQUAL ) {
#endif
            // trying to change the path which is not allowed
            hr = (E_ADS_PROPERTY_NOT_SUPPORTED);
            BAIL_IF_ERROR(hr);
        }
        lpShareInfo2->shi2_path = pszPath;
    }

   hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MaxUserCount"),
                    &dwValue
                    );
    if(SUCCEEDED(hr)){
        lpShareInfo2->shi2_max_uses = dwValue;
    }

    //
    // you ignore earlier errors, why? because these errors were raised
    // due to internal cached values being invalid.
    //

    hr = S_OK;

    //
    // Do the SetInfo now that you have all info
    //

    nasStatus = NetShareSetInfo(szUncServerName,
                                _pszShareName,
                                2,
                                (LPBYTE)lpShareInfo2,
                                &dwParmErr);

    if(nasStatus != NERR_Success){

#if DBG
        FileShareDebugOut((DEB_TRACE,
                           "NetShareSetInfo : parameter %ld unknown\n", dwParmErr));
#endif


        hr = HRESULT_FROM_WIN32(nasStatus);
    }

cleanup:
    if(pszDescription)
        FreeADsStr(pszDescription);
    if(pszPath)
        FreeADsStr(pszPath);
    RRETURN_EXP_IF_ERR(hr);
}


//
// helper functions
//

HRESULT
WinNTDeleteFileShare(POBJECTINFO pObjectInfo)
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus = NERR_Success;
    TCHAR szUncServerName[MAX_PATH];

    hr = MakeUncName(pObjectInfo->ComponentArray[1],
                     szUncServerName);

    BAIL_IF_ERROR(hr);

    nasStatus = NetShareDel(szUncServerName,
                            pObjectInfo->ComponentArray[3],
                            0);

cleanup:
    if(FAILED(hr)){
        RRETURN(hr);
    }
    if(nasStatus != NERR_Success){
        RRETURN(HRESULT_FROM_WIN32(nasStatus));
    }
    else{
        RRETURN(S_OK);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cggi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cggi.cxx
//
//  Contents:  This file contains the Group Object's
//               IADsGroup and IADsGroupOperation methods
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    );

BOOL
IsStringSID(LPWSTR pszStringSID);

//  Class CWinNTGroup


STDMETHODIMP CWinNTGroup::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsGroup *)this,Description);
}

STDMETHODIMP CWinNTGroup::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsGroup *)this,Description);
}


STDMETHODIMP
CWinNTGroup::Members(
    THIS_ IADsMembers FAR* FAR* ppMembers
    )
{
    HRESULT hr;
    WCHAR szHostServerName[MAX_PATH];
    NET_API_STATUS nasStatus = 0;

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }

    if (_GroupType == WINNT_GROUP_GLOBAL) {

        hr = CWinNTGroupCollection::CreateGroupCollection(
                        _Parent,
                        _ParentType,
                        _DomainName,

                        _ParentType == WINNT_DOMAIN_ID ?
                        (szHostServerName + 2) :
                        _ServerName,

                        _Name,
                        _GroupType,
                        IID_IADsMembers,
                        _Credentials,
                        (void **)ppMembers
            );
    } else {

        hr = CWinNTLocalGroupCollection::CreateGroupCollection(
                    _Parent,
                    _ParentType,
                    _DomainName,

                    _ParentType == WINNT_DOMAIN_ID ?
                    (szHostServerName + 2) :
                    _ServerName,

                    _Name,
                    _GroupType,
                    IID_IADsMembers,
                    _Credentials,
                    (void **)ppMembers
            );
    }

error:

    RRETURN_EXP_IF_ERR(hr);
}




STDMETHODIMP
CWinNTGroup::IsMember(
    THIS_ BSTR bstrMember,
    VARIANT_BOOL FAR* bMember
    )
{
    IADsMembers FAR * pMembers = NULL;
    IUnknown FAR * pUnknown = NULL;
    IEnumVARIANT FAR * pEnumVar = NULL;
    DWORD i = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL fMember = FALSE;
    VARIANT VariantArray[10];
    BOOL fContinue = TRUE;
    ULONG cElementFetched = 0;
    const DWORD dwMaxFailures = 1000;
    DWORD dwFailureCount = 0;

    hr = Members(
            &pMembers
            );
    BAIL_ON_FAILURE(hr);

    hr = pMembers->get__NewEnum(
                &pUnknown
                );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                IID_IEnumVARIANT,
                (void **)&pEnumVar
                );
    BAIL_ON_FAILURE(hr);


    while (fContinue) {

        IADs *pObject ;

        //
        // Reset the fetched count in case the function fails.
        //
        cElementFetched = 0;

        hr = pEnumVar->Next(
                    10,
                    VariantArray,
                    &cElementFetched
                    );

        if (FAILED(hr)) 
        {
            //
            // An error occurred, if we have exceeded our maximum number
            // of failures, give up and return.  Otherwise just ignore
            // the error and try again.
            //
            if (dwMaxFailures < ++dwFailureCount)
            {
                //
                // The rest of the processing in the loop can be done because
                // it doesn't do any harm and will clean up any allocated objects.
                //
                fContinue = FALSE;
                hr = S_FALSE;
            }
            else
            {
                // 
                // Reset hr to S_OK because we may have been returned valid data,
                // we don't really care about the error and we don't want to return
                // an error code if the data that we were returned is a match.
                // Just in case we were returned valid data, continue with the 
                // rest of the processing.
                //
                hr = S_OK;
            }
        }
        else if (hr == S_FALSE) {
            fContinue = FALSE;

            //
            // Reset hr to S_OK, we want to return success
            //

            hr = S_OK;
        }

        fMember = (VARIANT_BOOL)VerifyIfMember(
                        bstrMember,
                        VariantArray,
                        cElementFetched
                        );

        if (fMember) {

            fContinue = FALSE;
        }

        for (i = 0; i < cElementFetched; i++ ) {

            IDispatch *pDispatch = NULL;

            pDispatch = VariantArray[i].pdispVal;
            pDispatch->Release();

        }

        memset(VariantArray, 0, sizeof(VARIANT)*10);

    }

error:

    *bMember = fMember? VARIANT_TRUE : VARIANT_FALSE;

    if (pEnumVar) {
        pEnumVar->Release();
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pMembers) {
        pMembers->Release();
    }


    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTGroup::Add(THIS_ BSTR bstrNewItem)
{

    HRESULT hr;
    NET_API_STATUS nasStatus;
    LOCALGROUP_MEMBERS_INFO_3 Member;
    LPLOCALGROUP_MEMBERS_INFO_3 pMember = &Member;
    POBJECTINFO pObjectInfo = NULL;
    WCHAR szDomName[MAX_PATH];
    WCHAR szHostServerName[MAX_PATH];
    int iLastIndx = 0;
    BOOL fStringSID = FALSE;

    hr = BuildObjectInfo(
                bstrNewItem,
                &pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    iLastIndx = pObjectInfo->NumComponents - 1;

    //
    // If there is only one component, it has to be in the SID form
    // or it has to be a Special SID like everyone.
    //
    if (pObjectInfo->NumComponents == 1) {
        //
        // Check to see if this is S-12-11
        //
        fStringSID = IsStringSID(pObjectInfo->ComponentArray[0]);

    }

    memset(pMember, 0, sizeof(LOCALGROUP_MEMBERS_INFO_3));

    if (_ParentType == WINNT_COMPUTER_ID) {

        hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
        BAIL_ON_FAILURE(hr);

    }else if (_ParentType == WINNT_DOMAIN_ID){

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);
    }

    if (_GroupType == WINNT_GROUP_GLOBAL) {

#ifdef WIN95
        if (_wcsicmp(pObjectInfo->ComponentArray[0], _DomainName)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pObjectInfo->ComponentArray[0],
                -1,
                _DomainName,
                -1
                ) != CSTR_EQUAL ) {
#endif
            hr = E_ADS_INVALID_USER_OBJECT;
            BAIL_ON_FAILURE(hr);
        }
        nasStatus = NetGroupAddUser(
                            szHostServerName,
                            _Name,
                            pObjectInfo->ComponentArray[(
                                pObjectInfo->NumComponents - 1)]
                            );
        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

    }else if (_GroupType == WINNT_GROUP_LOCAL){

        if (fStringSID) {
            hr = AddBySID(
                     pObjectInfo->ComponentArray[0],
                     szHostServerName
                     );
            goto error;
        }

        //
        // 0 implies special sid name.
        //
        if (iLastIndx != 0) {

            hr = MakeWinNTAccountName(pObjectInfo, szDomName, FALSE);
            BAIL_ON_FAILURE(hr);
            pMember->lgrmi3_domainandname = szDomName;
        }
        else {
            pMember->lgrmi3_domainandname =
                pObjectInfo->ComponentArray[iLastIndx];
        }

        //
        // For performance reasos we will first assume that the
        // use has domain name
        //

        nasStatus = NetLocalGroupAddMembers(
                            szHostServerName,
                            _Name,
                            3,
                            (LPBYTE)pMember,
                            1
                            );

        if (nasStatus == ERROR_NO_SUCH_MEMBER) {
            //
            // Try with true to see if that makes a difference
            //
            hr = MakeWinNTAccountName(pObjectInfo, szDomName, TRUE);

            if (SUCCEEDED(hr)) {

                //
                // Try again with this value
                //

                pMember->lgrmi3_domainandname = szDomName;

                nasStatus = NetLocalGroupAddMembers(
                                szHostServerName,
                                _Name,
                                3,
                                (LPBYTE)pMember,
                                1
                                );

            }
        }

        //
        // Either way nasStatus will have the correct value
        //
        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTGroup::Remove(THIS_ BSTR bstrItemToBeRemoved)
{

    HRESULT hr;
    NET_API_STATUS nasStatus;
    LOCALGROUP_MEMBERS_INFO_3 Member;
    LPLOCALGROUP_MEMBERS_INFO_3 pMember = &Member;
    POBJECTINFO pObjectInfo = NULL;
    WCHAR szDomName[MAX_PATH];
    WCHAR szHostServerName[MAX_PATH];
    BOOL fSpecialName = FALSE;
    BOOL fStringSID = FALSE;

    hr = BuildObjectInfo(
                bstrItemToBeRemoved,
                &pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    //
    // If there is only one component, it has to be in the SID form
    // or it has to be a Special SID like everyone.
    //
    if (pObjectInfo->NumComponents == 1) {
        //
        // Check to see if this is S-12-11
        //
        fStringSID = IsStringSID(pObjectInfo->ComponentArray[0]);

        if (!fStringSID) {
            fSpecialName = TRUE;
        }
    }

    memset(pMember, 0, sizeof(LOCALGROUP_MEMBERS_INFO_3));

    if (_ParentType == WINNT_COMPUTER_ID) {

        hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
        BAIL_ON_FAILURE(hr);

    }else if (_ParentType == WINNT_DOMAIN_ID){

        hr = WinNTGetCachedDCName(
                        _DomainName,
                        szHostServerName,
                        _Credentials.GetFlags()
                        );
        BAIL_ON_FAILURE(hr);

    }


    if (fStringSID) {
        hr = DeleteBySID(
                 pObjectInfo->ComponentArray[0],
                 szHostServerName
                 );
        goto error;
    }

    if (_GroupType == WINNT_GROUP_GLOBAL) {

#ifdef WIN95
        if (_wcsicmp(pObjectInfo->ComponentArray[0], _DomainName)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pObjectInfo->ComponentArray[0],
                -1,
                _DomainName,
                -1
                ) != CSTR_EQUAL ) {
#endif
            hr = E_ADS_INVALID_USER_OBJECT;
            BAIL_ON_FAILURE(hr);
        }

        nasStatus = NetGroupDelUser(
                            szHostServerName,
                            _Name,
                            pObjectInfo->ComponentArray[(
                                pObjectInfo->NumComponents) - 1]
                            );
        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

    }else {

        if (!fSpecialName) {
            hr = MakeWinNTAccountName(pObjectInfo, szDomName, FALSE);
            BAIL_ON_FAILURE(hr);

            pMember->lgrmi3_domainandname = szDomName;
        }
        else {
            pMember->lgrmi3_domainandname =
                pObjectInfo->ComponentArray[0];
        }

        nasStatus = NetLocalGroupDelMembers(
                            szHostServerName,
                            _Name,
                            3,
                            (LPBYTE)pMember,
                            1
                            );

        if (nasStatus == ERROR_NO_SUCH_MEMBER) {
            hr = MakeWinNTAccountName(pObjectInfo, szDomName, TRUE);

            if (SUCCEEDED(hr)) {

                pMember->lgrmi3_domainandname = szDomName;
                nasStatus = NetLocalGroupDelMembers(
                                szHostServerName,
                                _Name,
                                3,
                                (LPBYTE)pMember,
                                1
                                );

            }
        }

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

    }

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    RRETURN_EXP_IF_ERR(hr);
}

BOOL
VerifyIfMember(
    BSTR bstrMember,
    VARIANT * VariantArray,
    ULONG cElementFetched
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;
    IADs FAR * pObject = NULL;
    IDispatch FAR * pDispatch = NULL;

    for (i = 0; i < cElementFetched; i++ ) {

        IDispatch *pDispatch = NULL;
        BSTR       bstrName = NULL;

        pDispatch = VariantArray[i].pdispVal;

        hr = pDispatch->QueryInterface(
                    IID_IADs,
                    (VOID **) &pObject
                    );
        BAIL_ON_FAILURE(hr);

        hr = pObject->get_ADsPath(&bstrName);
        BAIL_ON_FAILURE(hr);

#ifdef WIN95
        if (!_wcsicmp(bstrName, bstrMember)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                bstrName,
                -1,
                bstrMember,
                -1
                ) == CSTR_EQUAL ) {
#endif

            SysFreeString(bstrName);
            bstrName = NULL;

            pObject->Release();

           return(TRUE);

        }

        SysFreeString(bstrName);
        bstrName = NULL;

        pObject->Release();

    }

error:

    return(FALSE);

}


HRESULT
CWinNTGroup::DeleteBySID(
    LPWSTR pszStringSID,
    LPWSTR pszServerName
    )
{
    HRESULT hr = S_OK;
    BOOL fRet = FALSE;
    PSID pSid = NULL;
    NET_API_STATUS nasStatus;
    LOCALGROUP_MEMBERS_INFO_0 member;

    //
    // SDDL.H is currently available only for Win2k
    //
#if !defined(WIN95)

    if (!pszStringSID) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    fRet = ConvertStringSidToSidWrapper(
               pszStringSID,
               &pSid
               );
    if (!pSid) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    member.lgrmi0_sid = pSid;

    nasStatus = NetLocalGroupDelMembers(
                    pszServerName,
                    _Name,
                    0,
                    (LPBYTE) &member,
                    1
                    );

    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));

#else
    BAIL_ON_FAILURE(hr = E_FAIL);
#endif


error:
    if (pSid) {
        LocalFree(pSid);
    }

    RRETURN(hr);
}


//
// Same as delete only this time to add by SID.
//
HRESULT
CWinNTGroup::AddBySID(
    LPWSTR pszStringSID,
    LPWSTR pszServerName
    )
{
    HRESULT hr = S_OK;
    BOOL fRet = FALSE;
    PSID pSid = NULL;
    NET_API_STATUS nasStatus;
    LOCALGROUP_MEMBERS_INFO_0 member;

    //
    // SDDL.H is currently available only for Win2k
    //
#if !defined(WIN95)

    if (!pszStringSID) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    fRet = ConvertStringSidToSidWrapper(
               pszStringSID,
               &pSid
               );
    if (!pSid) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    member.lgrmi0_sid = pSid;

    nasStatus = NetLocalGroupAddMembers(
                    pszServerName,
                    _Name,
                    0,
                    (LPBYTE) &member,
                    1
                    );

    BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));

#else
    BAIL_ON_FAILURE(hr = E_FAIL);
#endif


error:
    if (pSid) {
        LocalFree(pSid);
    }

    RRETURN(hr);
}


//
// Helper routine that checks if a string is a sid or not.
//
BOOL
IsStringSID(LPWSTR pszStringSID)
{
    BOOL fRet = FALSE;

    if (!pszStringSID || (wcslen(pszStringSID) < 4)) {
        return FALSE;
    }

    if (((*pszStringSID != L'S') && (*pszStringSID != L's'))
        || (*(pszStringSID + 1) != L'-')
        ) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cnamcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cnamcf.cxx
//
//  Contents:  Windows NT 3.5 Namespace Object Class Factory Code
//
//             CWinNTNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTNamespaceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTNamespaceCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID iid,
    LPVOID * ppv
    )
{
    HRESULT     hr = S_OK;
    CWinNTCredentials Credentials; // default creds

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CWinNTNamespace::CreateNamespace(
                L"ADs:",
                L"WinNT:",
                ADS_OBJECT_BOUND,
                iid,
                Credentials,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\clgroups.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop
#include "winnt.hxx"

//  Class CWinNTLocalGroupCollection

DEFINE_IDispatch_Implementation(CWinNTLocalGroupCollection)


CWinNTLocalGroupCollection::CWinNTLocalGroupCollection():
        _ParentType(0),
        _DomainName(NULL),
        _ServerName(NULL),
        _lpServerName(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CWinNTLocalGroupCollection);
}


HRESULT
CWinNTLocalGroupCollection::CreateGroupCollection(
    BSTR Parent,
    ULONG ParentType,
    BSTR DomainName,
    BSTR ServerName,
    BSTR GroupName,
    ULONG GroupType,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTLocalGroupCollection FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupCollectionObject(&pGroup);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->InitializeCoreObject(
                Parent,
                GroupName,
                LOCALGROUP_CLASS_NAME,
                NULL,
                CLSID_WinNTGroup,
                ADS_OBJECT_UNBOUND
                );
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( DomainName, &pGroup->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName, &pGroup->_ServerName);
    BAIL_ON_FAILURE(hr);

    pGroup->_ParentType = ParentType;
    pGroup->_GroupType = GroupType;

    pGroup->_Credentials = Credentials;
    hr = pGroup->_Credentials.Ref(ServerName, DomainName, ParentType);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();
    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);

}


CWinNTLocalGroupCollection::~CWinNTLocalGroupCollection( )
{
    VariantClear( &_vFilter);

    if(_DomainName) {
    	ADsFreeString(_DomainName);
    }

    if(_ServerName) {
    	ADsFreeString(_ServerName);
    }

    delete _pDispMgr;
}

STDMETHODIMP
CWinNTLocalGroupCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CWinNTLocalGroupCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CWinNTLocalGroupCollection::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTLocalGroupCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTLocalGroupCollection::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTLocalGroupCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CWinNTLocalGroupCollectionEnum::Create(
                (CWinNTLocalGroupCollectionEnum **)&penum,
                _Parent,
                _ParentType,
                _ADsPath,
                _DomainName,
                _ServerName,
                _Name,
                _GroupType,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTLocalGroupCollection::AllocateGroupCollectionObject(
    CWinNTLocalGroupCollection ** ppGroup
    )
{
    CWinNTLocalGroupCollection FAR * pGroup = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pGroup = new CWinNTLocalGroupCollection();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pGroup,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    delete pGroup;
    delete  pDispMgr;

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cgroups.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop
#include "winnt.hxx"

//  Class CWinNTGroupCollection

DEFINE_IDispatch_Implementation(CWinNTGroupCollection)


CWinNTGroupCollection::CWinNTGroupCollection():
        _ParentType(0),
        _DomainName(NULL),
        _ServerName(NULL),
        _lpServerName(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CWinNTGroupCollection);
}


HRESULT
CWinNTGroupCollection::CreateGroupCollection(
    BSTR Parent,
    ULONG ParentType,
    BSTR DomainName,
    BSTR ServerName,
    BSTR GroupName,
    ULONG GroupType,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTGroupCollection FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    hr = AllocateGroupCollectionObject(&pGroup);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->InitializeCoreObject(
                Parent,
                GroupName,
                GROUP_CLASS_NAME,
                NULL,
                CLSID_WinNTGroup,
                ADS_OBJECT_UNBOUND
                );
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( DomainName, &pGroup->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName, &pGroup->_ServerName);
    BAIL_ON_FAILURE(hr);

    pGroup->_ParentType = ParentType;
    pGroup->_GroupType = GroupType;

    pGroup->_Credentials = Credentials;
    hr = pGroup->_Credentials.Ref(ServerName, DomainName, ParentType);
    BAIL_ON_FAILURE(hr);

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();
    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);

}


CWinNTGroupCollection::~CWinNTGroupCollection( )
{
    VariantClear( &_vFilter);

    if (_DomainName) {
        ADsFreeString(_DomainName);
    }

    if (_ServerName) {
        ADsFreeString(_ServerName);
    }

    delete _pDispMgr;
}

STDMETHODIMP
CWinNTGroupCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CWinNTGroupCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CWinNTGroupCollection::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTGroupCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTGroupCollection::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTGroupCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CWinNTGroupCollectionEnum::Create(
                (CWinNTGroupCollectionEnum **)&penum,
                _Parent,
                _ParentType,
                _ADsPath,
                _DomainName,
                _ServerName,
                _Name,
                _GroupType,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTGroupCollection::AllocateGroupCollectionObject(
    CWinNTGroupCollection ** ppGroup
    )
{
    CWinNTGroupCollection FAR * pGroup = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pGroup = new CWinNTGroupCollection();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pGroup,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:
    delete pGroup;
    delete  pDispMgr;

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cnamesp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cnamesp.cxx
//
//  Contents:  Windows NT 3.5 Namespace Object
//
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


DEFINE_IDispatch_Delegating_Implementation(CWinNTNamespace)
DEFINE_IADsExtension_Implementation(CWinNTNamespace)
DEFINE_IADs_Implementation(CWinNTNamespace)

//  Class CWinNTNamespace

CWinNTNamespace::CWinNTNamespace()
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CWinNTNamespace);
}

HRESULT
CWinNTNamespace::CreateNamespace(
    BSTR Parent,
    BSTR NamespaceName,
    DWORD dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTNamespace FAR * pNamespace = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespaceObject(&pNamespace);
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->InitializeCoreObject(
                Parent,
                NamespaceName,
                NAMESPACE_CLASS_NAME,
                NO_SCHEMA,
                CLSID_WinNTNamespace,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    pNamespace->_Credentials = Credentials;

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        // Namespace objects have no components in their ADsPath. Just set the
        // class for identification.
        pNamespace->_CompClasses[0] = L"Namespace";

        hr = pNamespace->InitUmiObject(
                pNamespace->_Credentials,
                NULL,
                0,
                NULL,
                (IUnknown *)(INonDelegatingUnknown *) pNamespace,
                NULL,
                IID_IUnknown,
                ppvObj
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pNamespace->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespace->Release();

    RRETURN(hr);

error:

    delete pNamespace;
    RRETURN_EXP_IF_ERR(hr);
}


CWinNTNamespace::~CWinNTNamespace( )
{
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTNamespace::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTNamespace::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTNamespace::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTNamespace::NonDelegatingQueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOpenDSObject))
    {
        *ppv = (IADsOpenDSObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPathnameProvider))
    {
        *ppv = (IADsPathnameProvider FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTNamespace::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsOpenDSObject)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CWinNTNamespace::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::GetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::ImplicitGetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CWinNTNamespace::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTNamespace::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTNamespace::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}


STDMETHODIMP
CWinNTNamespace::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    WCHAR szBuffer[MAX_PATH];
    DWORD dwLength = 0;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    //
    // Make sure we are not going to overflow the string buffer.
    // +3 for // and \0
    //
    dwLength = wcslen(_ADsPath) + wcslen(RelativeName) + 3;

    if (dwLength > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"//");
    wcscat(szBuffer, RelativeName);

    if (ClassName) {
        //
        // +1 for the ",".
        //
        dwLength += wcslen(ClassName) + 1;
        if (dwLength > MAX_PATH) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(
                szBuffer,
                (LPVOID *)ppObject,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTNamespace::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CWinNTNamespaceEnum::Create((CWinNTNamespaceEnum **)&penum, _vFilter,
                                             _Credentials);
    if (FAILED(hr)){

        goto error;
    }
    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );

    if (FAILED(hr)){
       goto error;
    }

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTNamespace::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::Delete(
    THIS_ BSTR SourceName,
    BSTR Type
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTNamespace::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


HRESULT
CWinNTNamespace::AllocateNamespaceObject(
    CWinNTNamespace ** ppNamespace
    )
{
    CWinNTNamespace FAR * pNamespace = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespace = new CWinNTNamespace();
    if (pNamespace == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
            pDispMgr,
            LIBID_ADs,
            IID_IADs,
            (IADs *)pNamespace,
            DISPID_REGULAR
            );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
            pDispMgr,
            LIBID_ADs,
            IID_IADsOpenDSObject,
            (IADsOpenDSObject *)pNamespace,
            DISPID_REGULAR
            );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
            pDispMgr,
            LIBID_ADs,
            IID_IADsContainer,
            (IADsContainer *)pNamespace,
            DISPID_NEWENUM
            );
    BAIL_ON_FAILURE(hr);

    pNamespace->_pDispMgr = pDispMgr;
    *ppNamespace = pNamespace;

    RRETURN(hr);

error:
    delete pNamespace;
    delete  pDispMgr;

    RRETURN(hr);

}


STDMETHODIMP
CWinNTNamespace::OpenDSObject(
    BSTR lpszDNName,
    BSTR lpszUserName,
    BSTR lpszPassword,
    LONG lnReserved,
    IDispatch **ppADsObj
    )
{
    HRESULT hr = S_OK;
    DWORD dwResult;
    IUnknown * pObject = NULL;

    *ppADsObj = NULL;

    // we need to block the invoke on UMI code
    lnReserved &= (~ADS_AUTH_RESERVED);
    
    CWinNTCredentials Credentials(lpszUserName, lpszPassword, lnReserved);

    hr = ::GetObject(lpszDNName, (LPVOID *)&pObject, Credentials);
    BAIL_ON_FAILURE(hr);

    // UMI objects do not implement IDispatch. Hence QI for IUnknown instead
    // of IDispatch. 
    
    if(lnReserved & ADS_AUTH_RESERVED)
    // call is from UMI
        hr = pObject->QueryInterface(IID_IUnknown, (void **)ppADsObj);
    else
        hr = pObject->QueryInterface(IID_IDispatch, (void **)ppADsObj);
    BAIL_ON_FAILURE(hr);

error:
    if (pObject)
        pObject->Release();

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTNamespace::ParsePath(
    BSTR bstrADsPath,
    DWORD dwType,
    PPATH_OBJECTINFO pObjectInfo
    )

/*++

Routine Description:

    Parse a path based on the type and return the information in pObjectInfo

Arguments:

    bstrADsPath - ads path to be parsed
    dwType - the type of path to be parsed:
                   ADS_PARSE_FULL
                   ADS_PARSE_DN
                   ADS_PARSE_COMPONENT
    pObjectInfo - the place where the parsed object is stored

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    HRESULT hr = S_OK;
    OBJECTINFO ObjInfo;
    POBJECTINFO pObjInfo = &ObjInfo;
    PWSTR szPath = NULL;

    memset(pObjInfo, 0, sizeof(OBJECTINFO));

    switch (dwType) {
        case ADS_PARSE_FULL:
        {
            CLexer Lexer(bstrADsPath);

            hr = Object(&Lexer, pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        case ADS_PARSE_DN:
        {
            WCHAR szToken[MAX_TOKEN_LENGTH];
            DWORD dwToken;

            CLexer Lexer(bstrADsPath);

            Lexer.SetAtDisabler(TRUE);

            hr = PathName(&Lexer,
                          pObjInfo);
            BAIL_ON_FAILURE(hr);

            hr = Lexer.GetNextToken(szToken,
                                    &dwToken);
            BAIL_ON_FAILURE(hr);

            if (dwToken != TOKEN_END) {
                hr = E_ADS_BAD_PATHNAME;
            }
            break;
        }

        case ADS_PARSE_COMPONENT:
        {
            CLexer Lexer(bstrADsPath);

            Lexer.SetAtDisabler(TRUE);

            hr = Component(&Lexer,
                           pObjInfo);
            BAIL_ON_FAILURE(hr);
            break;
        }
        default:
            break;
    }

    //
    // Setting new info
    //
    if (pObjInfo->ProviderName) {
        pObjectInfo->ProviderName = AllocADsStr(pObjInfo->ProviderName);
        if (!pObjectInfo->ProviderName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = SetObjInfoComponents(pObjInfo,
                              pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pObjectInfo->NumComponents = pObjInfo->NumComponents;
    pObjectInfo->dwPathType = ADS_PATHTYPE_ROOTFIRST;

error:
    FreeObjectInfo(pObjInfo,TRUE);
    if (szPath != NULL) {
        FreeADsStr(szPath);
    }
    return (hr);
}

HRESULT
CWinNTNamespace::SetObjInfoComponents(
                        OBJECTINFO *pObjectInfo,
                        PATH_OBJECTINFO *pObjectInfoTarget
                        )

/*++

Routine Description:

    Set all the compoents in an objinfo from another objinfo. Assumes that the
    components in the target objinfo is empty. Users of this function can call
    FreeObjInfo to free that data prior to this function call.

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;
    HRESULT hr = S_OK;

    NumComponents = 0;
    while (NumComponents < pObjectInfo->NumComponents) {
        if (pObjectInfo->ComponentArray[NumComponents]) {
            pObjectInfoTarget->ComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->ComponentArray[NumComponents]);
            if (pObjectInfoTarget->ComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents]) {
            pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent =
                AllocADsStr(pObjectInfo->DisplayComponentArray[NumComponents]);
            if (pObjectInfoTarget->DisplayComponentArray[NumComponents].szComponent == NULL) {
                pObjectInfoTarget->NumComponents = NumComponents;
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
        }
        NumComponents++;
    }
    pObjectInfoTarget->NumComponents = pObjectInfo->NumComponents;
    return hr;

error:
    FreeObjInfoComponents(pObjectInfoTarget);

    RRETURN_EXP_IF_ERR(hr);
}

void
CWinNTNamespace::FreeObjInfoComponents(
                    PATH_OBJECTINFO *pObjectInfo
                    )

/*++

Routine Description:

    Free all the compoents in an objinfo

Arguments:

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    DWORD NumComponents;

    while (pObjectInfo->NumComponents > 0) {
        pObjectInfo->NumComponents--;
        NumComponents = pObjectInfo->NumComponents;

        if (pObjectInfo->ComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szComponent);
            pObjectInfo->ComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->ComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->ComponentArray[NumComponents].szValue);
            pObjectInfo->ComponentArray[NumComponents].szValue = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szComponent) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szComponent);
            pObjectInfo->DisplayComponentArray[NumComponents].szComponent = NULL;
        }
        if (pObjectInfo->DisplayComponentArray[NumComponents].szValue) {
            FreeADsStr(
               pObjectInfo->DisplayComponentArray[NumComponents].szValue);
            pObjectInfo->DisplayComponentArray[NumComponents].szValue = NULL;
        }
    }
}

void
CWinNTNamespace::SetComponent(
                    LPWSTR szReturn,
                    DWORD cComponents,
                    BOOL fEscaped
                    )

/*++

Routine Description:

    Set an individual component in the pathname. For internal use only.
    Not exposed.

Arguments:

    szReturn - the buffer to store the return value
    cComponents - the component number to be set

Return Value:

    S_OK on success, error code otherwise.

--*/

{
    PATH_COMPONENT* pComponent = NULL;
    if (fEscaped) {
        pComponent = _pObjectInfo->DisplayComponentArray;
    }
    else {
        pComponent = _pObjectInfo->ComponentArray;
    }

    if (pComponent[cComponents].szValue) {
        //
        // If value exist, only show display value
        //
        wcscat(szReturn,
               pComponent[cComponents].szValue);
    }
    else {
        //
        // else value is only stored in Component
        //
        wcscat(szReturn,
               pComponent[cComponents].szComponent);
    }
}


HRESULT
CWinNTNamespace::SetComponents(
                            LPWSTR szReturn,
                            LPWSTR chSeparator,
                            DWORD dwType,
                            BOOL fEscaped
                            )
/*++

Routine Description:

    Set components in the pathname. For internal use only. Not exposed.

Arguments:

    szReturn - the buffer to store the return value
    chSeparator - separator to be used
    dwType - the type to be set
        ADS_COMPONENT_LEAF
        ADS_COMPONENT_DN
        ADS_COMPONENT_PARENT


Return Value:

    S_OK on success, error code otherwise.

--*/
{
    HRESULT hr = S_OK;
    long cComponents;
    long dwLimit;
    long dwOtherLimit = 0;

    if (dwType == ADS_COMPONENT_LEAF) {
        //
        // Only returns the leaf component
        //
        if (_pObjectInfo->dwPathType == ADS_PATHTYPE_ROOTFIRST) {
            if (_pObjectInfo->NumComponents > 0) {
                SetComponent(szReturn,
                             _pObjectInfo->NumComponents - 1,
                             fEscaped);
            }
            else {
                hr = E_ADS_BAD_PATHNAME;
            }
        }
        else {
            if (_pObjectInfo->NumComponents != 0) {
                SetComponent(szReturn,
                             0,
                             fEscaped);
            }
            else {
                hr = E_ADS_BAD_PATHNAME;
            }

        }
        RRETURN(hr);
    }

    dwLimit = _pObjectInfo->NumComponents;
    if (dwType == ADS_COMPONENT_PARENT) {
        dwLimit--;
    }
    if (dwOtherLimit >= dwLimit) {
        hr = E_ADS_BAD_PATHNAME;
        goto error;
    }
    for (cComponents = dwOtherLimit; cComponents < dwLimit; cComponents++) {
        SetComponent(szReturn,
                     cComponents,
                     fEscaped);
        if (cComponents != dwLimit - 1) {
            wcscat(szReturn,
                   chSeparator);
        }
    }
error:
    RRETURN(S_OK);
}

DWORD CountPath(
    PPATH_OBJECTINFO pObjectInfo
)
{
    DWORD dwPath = 4;   // Basic needs '://' and '/' for servername
    DWORD i;

    if (pObjectInfo->ProviderName) {
        dwPath += wcslen(pObjectInfo->ProviderName);
    }
    if (pObjectInfo->DisplayServerName) {
        dwPath += wcslen(pObjectInfo->DisplayServerName);
    }
    for (i=0;i<pObjectInfo->NumComponents;i++) {
        if (pObjectInfo->DisplayComponentArray[i].szComponent) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szComponent);
        }
        if (pObjectInfo->DisplayComponentArray[i].szValue) {
            dwPath += wcslen(pObjectInfo->DisplayComponentArray[i].szValue);
        }

        //
        // Add one for comma separator, one for equal sign
        //
        dwPath+=2;
    }
    return dwPath;
}


STDMETHODIMP
CWinNTNamespace::ConstructPath(
    PPATH_OBJECTINFO pObjectInfo,
    DWORD dwFormatType,
    DWORD dwFlag,
    DWORD dwEscapedMode,
    BSTR *pbstrADsPath
    )
{
    HRESULT hr = S_OK;
    PWSTR szReturn = NULL;
    long cComponents;
    DWORD dwPath = 0;
    BOOL fEscaped = FALSE;

    switch (dwEscapedMode) {
        case ADS_ESCAPEDMODE_OFF:
        case ADS_ESCAPEDMODE_OFF_EX:
        case ADS_ESCAPEDMODE_DEFAULT:
            fEscaped = FALSE;
            break;
        case ADS_ESCAPEDMODE_ON:
            fEscaped = TRUE;
            break;
        default:
            hr = E_INVALIDARG;
            goto error;
    }

    if (!pbstrADsPath) {
        hr = E_INVALIDARG;
        goto error;
    }

    dwPath = CountPath(pObjectInfo);
    szReturn = (PWSTR)AllocADsMem((dwPath + 1)* sizeof(WCHAR));
    if (szReturn == NULL) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    _pObjectInfo = pObjectInfo;

    wcscpy(szReturn,TEXT(""));

    switch (dwFormatType) {
        case ADS_FORMAT_WINDOWS:
        case ADS_FORMAT_WINDOWS_NO_SERVER:
            if (dwEscapedMode == ADS_ESCAPEDMODE_DEFAULT) {
                fEscaped = TRUE;
            }
            if (!pObjectInfo->ProviderName) {
                hr = E_FAIL;        // Need Error Code
                goto error;
            }
            wcscat(szReturn,pObjectInfo->ProviderName);
            wcscat(szReturn,TEXT("://"));

            if (dwFormatType == ADS_FORMAT_WINDOWS) {
                if (pObjectInfo->DisplayServerName && (*(pObjectInfo->DisplayServerName))) {
                    wcscat(szReturn,pObjectInfo->DisplayServerName);
                    if (pObjectInfo->NumComponents>0) {
                        wcscat(szReturn,TEXT("/"));
                    }
                }
            }
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_DN:
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_DN,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_WINDOWS_PARENT:
            hr = SetComponents(szReturn,
                               TEXT("/"),
                               ADS_COMPONENT_PARENT,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        case ADS_FORMAT_X500:
        case ADS_FORMAT_X500_NO_SERVER:
        case ADS_FORMAT_X500_DN:
        case ADS_FORMAT_X500_PARENT:
            hr = E_NOTIMPL;
            goto error;
           break;

        case ADS_FORMAT_LEAF:
            //
            // Reverse only if pathtype is X500. In that case, we need to get
            // the first element but not the last
            //
            hr = SetComponents(szReturn,
                               NULL,
                               ADS_COMPONENT_LEAF,
                               fEscaped);
            BAIL_ON_FAILURE(hr);
            break;

        default:
            hr = E_INVALIDARG;
            goto error;
    }
    hr = ADsAllocString(szReturn, pbstrADsPath);
error:
    if (szReturn) {
        FreeADsMem(szReturn);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTNamespace::GetEscapedElement(
    LONG lnReserved,
    BSTR bstrInStr,
    BSTR* pbstrOutStr
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cobjcach.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cpdccach.cxx
//
//  Contents:     PDC Names Cache functionality for the WinNT Provider
//
//  Functions:
//                CObjNameCache::addentry
//                CObjNameCache::findentry
//                CObjNameCache::getentry
//                CProperyCache::CObjNameCache
//                CObjNameCache::~CObjNameCache
//                CObjNameCache::CreateClassCache
//
//  History:      25-Apr-96   KrishnaG   Created.
//                30-Aug-96   RamV       Permit cache to store values
//                                       other than PDC names
//
//----------------------------------------------------------------------------
#include "winnt.hxx"

//
// Definition for DsGetDcName on 4.0
//
typedef DWORD (*PF_DsGetDcName) (
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
);

#ifdef UNICODE
#define GETDCNAME_API        "DsGetDcNameW"
#else
#define GETDCNAME_API        "DsGetDcNameA"
#endif



//
// DsGetDc will be called if applicabel if not we will look
// at the flags and decide if we should call NetGetAnyDCName or
// NetGetDCName - AjayR 11-04-98.
// Note the code below is not exactly "elegant" but I cannot think
// of any other way to build on 4.0, 95 and NT. Please play close
// attention to the #ifdefs when reading.
//
HRESULT
DsGetDcNameNTWrapper(
    IN LPCWSTR DomainName,
    OUT LPWSTR *ppszServerName,
    IN ULONG Flags
    )
{
    LPCWSTR ComputerName = NULL;
    GUID *DomainGuid = NULL;
    LPCWSTR SiteName = NULL;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    DWORD dwStatus = NULL;
    LPWSTR pszNetServerName = NULL;
    HRESULT hr = S_OK;
    ULONG ulDsGetDCFlags = DS_RETURN_FLAT_NAME | DS_WRITABLE_REQUIRED;

    if (Flags & ADS_READONLY_SERVER) {
        ulDsGetDCFlags &= ~DS_WRITABLE_REQUIRED;
    }

    *ppszServerName = NULL;


    static PF_DsGetDcName pfDsGetDcName = NULL ;


    //
    // Load the function if necessary
    //
    if (pfDsGetDcName == NULL) {
        pfDsGetDcName =
            (PF_DsGetDcName) LoadNetApi32Function(GETDCNAME_API) ;
    }

    if (pfDsGetDcName != NULL) {

        dwStatus =  ((*pfDsGetDcName)(
                        ComputerName,
                        DomainName,
                        DomainGuid,
                        SiteName,
                        ulDsGetDCFlags,
                        &pDomainControllerInfo
                        )
                     );

        if (dwStatus == NO_ERROR) {
            *ppszServerName = AllocADsStr(
                                  pDomainControllerInfo->DomainControllerName
                                  );

            if (!*ppszServerName)
                hr = E_OUTOFMEMORY;

        } else {
            hr = HRESULT_FROM_WIN32(dwStatus);
        }

    } else {
        //
        // Could not load library
        //
        if (Flags & ADS_READONLY_SERVER) {

#ifdef WIN95
             dwStatus = NetGetDCName(
                            NULL,
                            DomainName,
                            (LPBYTE *)&pszNetServerName
                            );
#else
             dwStatus = NetGetAnyDCName(
                            NULL,
                            DomainName,
                            (LPBYTE *)&pszNetServerName
                            );
#endif

         } else {

             dwStatus = NetGetDCName(
                            NULL,
                            DomainName,
                            (LPBYTE *)&pszNetServerName
                            );
         }

         if (dwStatus == NO_ERROR) {
             *ppszServerName = AllocADsStr(
                                   pszNetServerName
                                 );

             if (!*ppszServerName)
                 hr = E_OUTOFMEMORY;

         } else {

             hr = HRESULT_FROM_WIN32(dwStatus);

         }

     }


     if (pszNetServerName) {
         (void) NetApiBufferFree( (void*) pszNetServerName);
     }

     if (pDomainControllerInfo) {
         (void) NetApiBufferFree(pDomainControllerInfo);
     }

     RRETURN(hr);
 }







//+------------------------------------------------------------------------
//
//  Function:   CObjNameCache::addentry
//
//  Synopsis:
//
//
//
//  Arguments:  [pszDomainName]       --
//              [pszPDCName]      --
//              [pClassEntry]       --
//
//
//-------------------------------------------------------------------------

HRESULT
CObjNameCache::
addentry(
    LPWSTR pszElementName,
    BOOL fCacheHit,
    DWORD dwElementType,
    LPWSTR pszName
    )
{

    //
    // The parameter pszName is either the Domain/Wkgrp Name (if dwElementType
    // = COMPUTER_ENTRY_TYPE)   and  PDC Name (if   dwElementType     is
    // DOMAIN_ENTRY_TYPE). it will be a blank string if dwElementType is
    // WORKGROUP_ENTRY_TYPE
    //
    // we will support adding cache hits/misses.
    //

    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD dwLRUEntry = 0;
    DWORD dwIndex = 0;

    EnterCriticalSection(&_cs);

    //
    // before adding entries, let us clean out all existing old entries
    //

    if (_dwMaxCacheSize == 0){
        hr = E_FAIL;
        goto error;
    }

    hr = InvalidateStaleEntries();
    BAIL_ON_FAILURE(hr);

    hr = findentry(
            pszElementName,
            &dwIndex
            );

    //
    // if you find an entry then you cannot add it to the cache
    //

    if(SUCCEEDED(hr)){
        goto error;
    }

    hr = S_OK;

    for (i = 0; i < _dwMaxCacheSize; i++ ) {

        if (!_ClassEntries[i].bInUse) {

            //
            // Found an available entry; use it
            // fill in the name of the entry and related information
            // for this class entry
            //
            break;

        } else {

            if ((dwLRUEntry == -1) || (i == IsOlderThan(i, dwLRUEntry))){
                dwLRUEntry = i;
            }
        }

    }

    if (i == _dwMaxCacheSize){

        //
        // We have no available entries so we need to use
        // the LRUEntry which is busy
        //


        //
        // Free the members of the LRU Entry
        //
        if (_ClassEntries[dwLRUEntry].pszElementName)
        {
            FreeADsStr(_ClassEntries[dwLRUEntry].pszElementName);
            _ClassEntries[dwLRUEntry].pszElementName = NULL;
        }

        //
        // All members of the union are strings so it is not
        // necessary to check for each of the members.  Just free
        // one of them if it is non-null.
        //
        if(_ClassEntries[i].u.pszPDCName)
        {
            FreeADsStr(_ClassEntries[i].u.pszPDCName);
            _ClassEntries[i].u.pszPDCName = NULL;
        }

        _ClassEntries[dwLRUEntry].bInUse = FALSE;

        i = dwLRUEntry;
    }


    //
    // Insert the new entry into the Cache
    //

    _ClassEntries[i].pszElementName = AllocADsStr(pszElementName);

    if(_ClassEntries[i].pszElementName == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    _ClassEntries[i].dwElementType = dwElementType;

    if ( fCacheHit){

        _ClassEntries[i].fCacheHit = TRUE;

        switch(dwElementType) {

        case DOMAIN_ENTRY_TYPE:

            _ClassEntries[i].u.pszPDCName = AllocADsStr(pszName);
            if(_ClassEntries[i].u.pszPDCName == NULL){
                hr = E_OUTOFMEMORY;
                goto error;
            }

            break;

        case DOMAIN_ENTRY_TYPE_RO:
            _ClassEntries[i].u.pszDCName = AllocADsStr(pszName);
            if (_ClassEntries[i].u.pszDCName == NULL) {
                hr = E_OUTOFMEMORY;
                goto error;
            }

            break;

        case COMPUTER_ENTRY_TYPE:

            _ClassEntries[i].u.pszDomainName = AllocADsStr(pszName);
            if(_ClassEntries[i].u.pszDomainName == NULL){
                hr = E_OUTOFMEMORY;
                goto error;
            }

            break;

        default:
            break;

        }
    } else {

        _ClassEntries[i].fCacheHit = FALSE;
    }

    _ClassEntries[i].bInUse = TRUE;

    //
    // update the time stamp so that we know when this entry was made
    //

    GetSystemTime(&_ClassEntries[i].st);

error:

    LeaveCriticalSection(&_cs);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CObjNameCache::findentry
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------

HRESULT
CObjNameCache::
findentry(
    LPWSTR pszElementName,
    PDWORD pdwIndex
    )
{
    DWORD i = 0;


    EnterCriticalSection(&_cs);

    if (_dwMaxCacheSize == 0 ) {

        LeaveCriticalSection(&_cs);
        RRETURN(E_FAIL);
    }

    for (i = 0; i < _dwMaxCacheSize; i++ ) {

        if (_ClassEntries[i].bInUse) {

            if(!_ClassEntries[i].pszElementName ){
                continue;
            }

#ifdef WIN95
            if (!_wcsicmp(_ClassEntries[i].pszElementName, pszElementName)){
#else
            if (CompareStringW(
                    LOCALE_SYSTEM_DEFAULT,
                    NORM_IGNORECASE,
                    _ClassEntries[i].pszElementName,
                    -1,
                    pszElementName,
                    -1
                    ) == CSTR_EQUAL ) {
#endif

                *pdwIndex = i;


                LeaveCriticalSection(&_cs);

                RRETURN(S_OK);

            }
        }
    }

    LeaveCriticalSection(&_cs);

    RRETURN(E_FAIL);
}

//+------------------------------------------------------------------------
//
//  Function:   CObjNameCache::getentry
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------

HRESULT
CObjNameCache::
getentry(
    LPWSTR pszElementName,
    PBOOL  pfHit,
    PDWORD pdwEntryType,
    LPWSTR pszName
    )
{
    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    DWORD i;

    EnterCriticalSection(&_cs);

    //
    // blow away all the entries that have expired
    //

    hr = InvalidateStaleEntries();
    BAIL_ON_FAILURE(hr);

    hr = findentry(
            pszElementName,
            &dwIndex
        );
    BAIL_ON_FAILURE(hr);

    *pfHit = _ClassEntries[dwIndex].fCacheHit;
    *pdwEntryType =  _ClassEntries[dwIndex].dwElementType;


    switch(_ClassEntries[dwIndex].dwElementType) {

    case DOMAIN_ENTRY_TYPE:
        wcscpy(pszName, _ClassEntries[dwIndex].u.pszPDCName);
        break;

    case COMPUTER_ENTRY_TYPE:
        wcscpy(pszName, _ClassEntries[dwIndex].u.pszDomainName);
        break;


    case DOMAIN_ENTRY_TYPE_RO:
        wcscpy(pszName, _ClassEntries[dwIndex].u.pszDCName);
        break;

    default:
        wcscpy(pszName, TEXT(""));
        break;

    }


error:

    LeaveCriticalSection(&_cs);

   RRETURN(hr);

}


HRESULT
CObjNameCache::
InvalidateStaleEntries()
{

    DWORD i=0;
    SYSTEMTIME stCurrentTime;
    BOOL fCacheHit;

    GetSystemTime(&stCurrentTime);

    for ( i=0; i< _dwMaxCacheSize; i++){

        fCacheHit = _ClassEntries[i].fCacheHit;

        if(_ClassEntries[i].bInUse &&
           TimeDifference(stCurrentTime, _ClassEntries[i].st)
           > AGE_LIMIT_VALID_ENTRIES  && fCacheHit == CACHE_HIT) {

            _ClassEntries[i].bInUse = FALSE;
            FreeADsStr(_ClassEntries[i].pszElementName);
            _ClassEntries[i].pszElementName = NULL;

            if((_ClassEntries[i].dwElementType == DOMAIN_ENTRY_TYPE) ||
                (_ClassEntries[i].dwElementType == DOMAIN_ENTRY_TYPE_RO))
            {
                FreeADsStr(_ClassEntries[i].u.pszPDCName);
                _ClassEntries[i].u.pszPDCName = NULL;


            } else if (_ClassEntries[i].dwElementType == COMPUTER_ENTRY_TYPE){
                FreeADsStr(_ClassEntries[i].u.pszDomainName);
                _ClassEntries[i].u.pszPDCName = NULL;

            }
        }else if(_ClassEntries[i].bInUse &&
                 TimeDifference(stCurrentTime, _ClassEntries[i].st)
                 > AGE_LIMIT_INVALID_ENTRIES  && fCacheHit == CACHE_MISS) {

            _ClassEntries[i].bInUse = FALSE;
        }

    }

    RRETURN(S_OK);
}


//+------------------------------------------------------------------------
//
//  Function:   CObjNameCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CObjNameCache::CObjNameCache() :
    _fCriticalSectionInitialized(FALSE)
{
    _dwMaxCacheSize = 10;
    memset(_ClassEntries, 0, sizeof(CLASSENTRY)* MAX_ENTRIES);
}

//+------------------------------------------------------------------------
//
//  Function:   ~CObjNameCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CObjNameCache::
~CObjNameCache()
{
    DWORD i= 0;
    for (i=0; i< MAX_ENTRIES; i++){
        if(_ClassEntries[i].pszElementName){
            FreeADsStr(_ClassEntries[i].pszElementName);
        }

        //
        // All members of the union are strings so it is not
        // necessary to check for each of the members.
        //
        if(_ClassEntries[i].u.pszPDCName){
            FreeADsStr(_ClassEntries[i].u.pszPDCName);
        }
    }

    if (_fCriticalSectionInitialized)
        DeleteCriticalSection(&_cs);

}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CObjNameCache::
CreateClassCache(
    CObjNameCache FAR *FAR * ppClassCache
    )
{
    CObjNameCache FAR * pClassCache = NULL;

    pClassCache = new CObjNameCache();

    if (!pClassCache) {
        RRETURN(E_FAIL);
    }

    __try
    {
        InitializeCriticalSection(&(pClassCache->_cs));

        pClassCache->_fCriticalSectionInitialized = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        RRETURN(E_OUTOFMEMORY);
    }

    *ppClassCache = pClassCache;

    RRETURN(S_OK);
}


DWORD
CObjNameCache::
IsOlderThan(
    DWORD i,
    DWORD j
    )
{
    SYSTEMTIME *pi, *pj;
    DWORD iMs, jMs;
    // DBGMSG(DBG_TRACE, ("IsOlderThan entering with i %d j %d\n", i, j));

    pi = &(_ClassEntries[i].st);
    pj = &(_ClassEntries[j].st);

    if (pi->wYear < pj->wYear) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wYear > pj->wYear) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else  if (pi->wMonth < pj->wMonth) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wMonth > pj->wMonth) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else if (pi->wDay < pj->wDay) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
        return(i);
    } else if (pi->wDay > pj->wDay) {
        // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
        return(j);
    } else {
        iMs = ((((pi->wHour * 60) + pi->wMinute)*60) + pi->wSecond)* 1000 + pi->wMilliseconds;
        jMs = ((((pj->wHour * 60) + pj->wMinute)*60) + pj->wSecond)* 1000 + pj->wMilliseconds;

        if (iMs <= jMs) {
            // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", i));
            return(i);
        } else {
            // DBGMSG(DBG_TRACE, ("IsOlderThan returns %d\n", j));
            return(j);
        }
    }
}


HRESULT
WinNTGetCachedDCName(
    LPWSTR pszDomainName,
    LPWSTR pszPDCName,
    DWORD  dwFlags
    )
{
    WCHAR szSAMName[MAX_PATH];

    // In this case credentials do not help because we do not have
    // any server/domain to connect to. This is because the param
    // pszDomainName is not a domain name for certain.

    CWinNTCredentials nullCredentials;

    // We do want to copy the flags parameter as that will tell
    // us if we need to connect to PDC or not

    nullCredentials.SetFlags(dwFlags);

    RRETURN(WinNTGetCachedObject(pszDomainName,
                                 DOMAIN_ENTRY_TYPE,
                                 pszPDCName,
                                 szSAMName,
                                 dwFlags,
                                 nullCredentials
                                 ));
}



HRESULT
WinNTGetCachedComputerName(
    LPWSTR pszComputerName,
    LPWSTR pszName,
    LPWSTR pszSAMName,
    CWinNTCredentials& Credentials
    )
{

    RRETURN(WinNTGetCachedObject(pszComputerName,
                                 COMPUTER_ENTRY_TYPE,
                                 pszName,
                                 pszSAMName,
                                 Credentials.GetFlags(), // doesnt matter
                                 Credentials
                                 ));

}




HRESULT
WinNTGetCachedObject(
    LPWSTR pszElementName,
    DWORD dwElementType,
    LPWSTR pszName,
    LPWSTR pszSAMName,
    DWORD dwFlags,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus = 0;
    BOOL fCacheHit;
    DWORD dwEntryType;
    LPWKSTA_INFO_100 lpWI = NULL;
    DWORD dwObjectsReturned;
    DWORD dwObjectsTotal;
    DWORD dwResumeHandle;
    // Freed using NetAPI
    LPWSTR pszServerName = NULL;
    // Freed using FreeADsStr
    LPWSTR pszADsStrServerName = NULL;
    BOOL fRefAdded = FALSE;
    DWORD dwDomainEntryType = DOMAIN_ENTRY_TYPE;
    // This will be the case most often
    DWORD dwUserFlags = Credentials.GetFlags();
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdomainInfo = NULL;       
    BOOL fNetBIOS = FALSE;
    BOOL fDsRoleCallAttempted = FALSE;

    hr = pgPDCNameCache->getentry(
                    pszElementName,
                    &fCacheHit,
                    &dwEntryType,
                    pszName
                    );

    if (SUCCEEDED(hr)) {
        //
        // we found the entry. Now need to verify that it indeed
        // is an object of type desired
        //

        // Note that dwElement type will never be DOMAIN_ENTRY_TYPE_RO
        if(fCacheHit) {
            if (dwEntryType == dwElementType
                || ((dwElementType == DOMAIN_ENTRY_TYPE)
                    && (dwEntryType == DOMAIN_ENTRY_TYPE_RO)
                    && (dwUserFlags & ADS_READONLY_SERVER))
                ) {

                //
                // If the user now needs a writeable connection
                // should we fail or should we actually pretend
                // that the object is not there in the cache.
                //

                hr = S_OK;
                goto error;

            }

        } else if (!fCacheHit && (dwElementType == WORKGROUP_ENTRY_TYPE)) {
            //
            // looks like we either found a cache miss
            // Return  ok
            //
            hr = S_OK;
            goto error;

        } else {

            hr = E_FAIL;
            goto error;

        }

    }
    switch(dwElementType){

    case DOMAIN_ENTRY_TYPE:

            //
            // A read only server is ok, need to also set the
            // domain entry type accordingly
            //
        if (dwFlags & ADS_READONLY_SERVER) {
            dwDomainEntryType = DOMAIN_ENTRY_TYPE_RO;
        }

        //
        // Call the all encompassing Wrapper.
        //
        hr = DsGetDcNameNTWrapper(
                 pszElementName,
                 &pszADsStrServerName,
                 dwFlags
                 );

        BAIL_ON_FAILURE(hr);

        hr = pgPDCNameCache->addentry(
                pszElementName,
                TRUE,
                dwDomainEntryType,
                pszADsStrServerName
                );

        BAIL_ON_FAILURE(hr);
        //
        // in addition we can also add a computer entry for the PDC
        //

        hr = pgPDCNameCache->addentry(
                pszADsStrServerName+2,  // to get rid of the leading backslashes
                TRUE,
                COMPUTER_ENTRY_TYPE,
                pszElementName
                );

        BAIL_ON_FAILURE(hr);

        wcscpy(pszName, pszADsStrServerName);

        break;

    case COMPUTER_ENTRY_TYPE:

        // Ref the computer, note that RefServer will not
        // do anything if the credentials are null. We are also
        // not worried about errors as we want to use default
        // credentials in that case.

        hr = Credentials.RefServer(pszElementName);

        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        nasStatus = NetWkstaGetInfo(
                        pszElementName,
                        100,
                        (LPBYTE*) &lpWI
                        );

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

#ifdef WIN95
        //
        // No NetpNameCompare for Win9x
        //
        if (lpWI->wki100_computername
            && (_wcsicmp(pszElementName, lpWI->wki100_computername) == 0)
            )
#else
        if (lpWI->wki100_computername
            && ( NetpNameCompare(
                     NULL,
                     pszElementName,
                     lpWI->wki100_computername,
                     NAMETYPE_COMPUTER,
                     0
                     )
                 == 0 )
            )
#endif
         {


            // Want to add the correct capitalized name
            // Not what the user gave
            hr = pgPDCNameCache->addentry(
                     lpWI->wki100_computername,
                     TRUE,
                     COMPUTER_ENTRY_TYPE,
                     lpWI->wki100_langroup
                     );

            wcscpy(pszSAMName, lpWI->wki100_computername);

            fNetBIOS = TRUE;


         } 
         else {

            DsRoleGetPrimaryDomainInformation(
                                         pszElementName,                      
                                         DsRolePrimaryDomainInfoBasic,   // InfoLevel
                                         (PBYTE*)&pdomainInfo            // pBuffer
                                         );    
            fDsRoleCallAttempted = TRUE;
            // we don't bail out even if the call fails

            //
            // user actually passes in ipaddress as the computer name
            //
            if(IsAddressNumeric(pszElementName)) {
            	hr = pgPDCNameCache->addentry(
                         pszElementName,
                         TRUE,
                         COMPUTER_ENTRY_TYPE,
                         pdomainInfo && pdomainInfo->DomainNameDns ? pdomainInfo->DomainNameDns : lpWI->wki100_langroup
                         );

                wcscpy(pszSAMName, L"");
            }
            //
            // user may pass in the dns name of the computer
            //
            else {
                
            	if(pdomainInfo) {
            		if(((pdomainInfo->DomainNameDns) && _wcsicmp(pszElementName, pdomainInfo->DomainNameDns) == 0)
            			               ||
            			               
            	      ((pdomainInfo->DomainNameFlat) && NetpNameCompare(
                                       NULL,
                                       pszElementName,
                                       pdomainInfo->DomainNameFlat,
                                       NAMETYPE_COMPUTER,
                                       0
                                       )
                                       == 0) )            		             
            		 
            		{
            			BAIL_ON_FAILURE(hr=HRESULT_FROM_WIN32(ERROR_BAD_NETPATH));
            		}
            		else {
            			hr = pgPDCNameCache->addentry(
                                 pszElementName,
                                 TRUE,
                                 COMPUTER_ENTRY_TYPE,
                                 pdomainInfo->DomainNameDns
                                 );

                        wcscpy(pszSAMName, L"");
            		}       			
            			
               	} 
            	else {          		           
           	
                    BAIL_ON_FAILURE(hr=HRESULT_FROM_WIN32(ERROR_BAD_NETPATH));
            	}
        
            }
        }    

        // we need to return the correct format of domain name
        if(!(*pszName))
        {
            // the parent name is NULL
            if(fNetBIOS)
            {
                // if the user specifies the computer netbios name, then we just return the domain netbios name
                wcscpy(pszName, lpWI->wki100_langroup);
            }
            else
            {
                // othereise we tries to return the domain dns name
                wcscpy(pszName, pdomainInfo && pdomainInfo->DomainNameDns ? pdomainInfo->DomainNameDns : lpWI->wki100_langroup);
            }
            
        }
        else
        {
            // we have the parent name passed in, so we need to return pszName accordingly
            if (lpWI->wki100_langroup
            && ( NetpNameCompare(
                     NULL,
                     pszName,
                     lpWI->wki100_langroup,
                     NAMETYPE_DOMAIN,
                     0
                     )
                 ))
            {
                // the parent name passed in is not equal to the domain netbios name

                if(!fDsRoleCallAttempted)
                {
                    DsRoleGetPrimaryDomainInformation(
                                         pszElementName,                      
                                         DsRolePrimaryDomainInfoBasic,   // InfoLevel
                                         (PBYTE*)&pdomainInfo            // pBuffer
                                         );    
                    
                }

                // unless the the parent name passed in is equal to the domain dns name, we just put domain netbios name
                // to the pszName
                    
                if(!(pdomainInfo && pdomainInfo->DomainNameDns && !_wcsicmp(pszName, pdomainInfo->DomainNameDns)))
                {
                    // the parent name passed in is not equal to the domain dns name also
                    wcscpy(pszName, lpWI->wki100_langroup);
                }
                
                
            }
            
        }       
        
        
        break;


    default:
        hr = E_FAIL;
        break;
    }

error:

	if (fRefAdded) {
        Credentials.DeRefServer();
        // even if we fail, we have no recovery path
        fRefAdded = FALSE;
    }

            
    if(lpWI){
        NetApiBufferFree(lpWI);
    }

    if(pszServerName){
        NetApiBufferFree(pszServerName);
    }

    if (pszADsStrServerName) {
        FreeADsStr(pszADsStrServerName);
    }

    if ( pdomainInfo )
	{
		DsRoleFreeMemory(pdomainInfo);
	}

    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//    This function is called by Heuristic GetObject to identify what
//    kind of object we are dealing with. Here we try to get a cached
//    entry if it is a hit/miss. If it fails, then we try each kind
//    of object in turn. (Domain/Computer/Workgroup). Once we do this,
//    we cache this information internally
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
WinNTGetCachedName(
    LPWSTR pszElementName,
    PDWORD  pdwElementType,
    LPWSTR pszName,
    LPWSTR pszSAMName,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    BOOL fCacheHit;
    DWORD dwEntryType;
    WCHAR szSAMName[MAX_ADS_PATH];
    BOOL fRefAdded = FALSE;
    DWORD dwUserFlags = Credentials.GetFlags();

    szSAMName[0] = pszName[0] = L'\0';

    if (!pszElementName || !*pszElementName) {
        RRETURN(E_FAIL);
    }

    hr = pgPDCNameCache->getentry(
                    pszElementName,
                    &fCacheHit,
                    &dwEntryType,
                    pszName
                    );

    if (SUCCEEDED(hr)) {
        //
        // we found the entry.
        //

        if (!fCacheHit){
            //
            // cache miss saved as a workgroup
            //
            *pdwElementType = WORKGROUP_ENTRY_TYPE;
            goto error;

        } else {
            if(dwEntryType == DOMAIN_ENTRY_TYPE_RO) { 
                if(dwUserFlags & ADS_READONLY_SERVER) {
                    // HeuristicGetObj doesn't recognize DOMAIN_ENTRY_TYPE_RO
                    *pdwElementType = DOMAIN_ENTRY_TYPE;
                    goto error;
                }
            }
            else {
                *pdwElementType = dwEntryType;
                goto error;
            }
        }

    } 

    {

        // at this point, we can try and ref the domain as
        // we are looking to bind to the domain

        hr = Credentials.RefDomain(pszElementName);
        // note that even if this fails we want to continue
        // as there is the chance that the current users
        // credentials are good enough for the operation

        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        hr = WinNTGetCachedObject(
                 pszElementName,
                 DOMAIN_ENTRY_TYPE,
                 pszName,
                 szSAMName,
                 Credentials.GetFlags(),
                 Credentials
                 );

        if (fRefAdded) {
            Credentials.DeRefDomain();
            // we cannot really do anything useful with HR
            fRefAdded = FALSE;
        }

        if (SUCCEEDED(hr)){
            *pdwElementType = DOMAIN_ENTRY_TYPE;
            wcscpy(pszSAMName, szSAMName);
            RRETURN(hr);
        }

        hr = WinNTGetCachedObject(
                 pszElementName,
                 COMPUTER_ENTRY_TYPE,
                 pszName,
                 szSAMName,
                 Credentials.GetFlags(),
                 Credentials
                 );


        if (SUCCEEDED(hr)){
            *pdwElementType = COMPUTER_ENTRY_TYPE;
            wcscpy(pszSAMName, szSAMName);
            RRETURN(hr);
        }


        //
        // if you are here, it means that you have to cache a miss as a
        // workgroup.
        // Note that pszSAMName rather than pszElementName is added
        // if it is valid

        // AjayR - to handle the no workstation case,
        // We should not add anything if the error was NOWksta service

        if (hr != HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {

            if (szSAMName[0] != L'\0') {

                hr = pgPDCNameCache->addentry(
                         szSAMName,
                         FALSE,
                         WORKGROUP_ENTRY_TYPE,
                         TEXT("")
                         );

            } else {

                hr = pgPDCNameCache->addentry(
                         pszElementName,
                         FALSE,
                         WORKGROUP_ENTRY_TYPE,
                         TEXT("")
                         );

            }
        }  // No Wksta started


        *pdwElementType = WORKGROUP_ENTRY_TYPE;
        wcscpy(pszName, TEXT(""));
        goto error;
    }


error:
    RRETURN(hr);
}

LONG
TimeDifference(
    SYSTEMTIME st1,
    SYSTEMTIME st2
    )

{
   //
   // This function gives the difference between st1 and st2 (st1-st2)in secs.
   // This will be used by our internal cache object so as to find out if
   // a certain entry in the cache is too old.
   // Assumption: st1 is later than st2.


    DWORD dwTime1;
    DWORD dwTime2;
    DWORD dwMonth1;
    DWORD dwMonth2;
    LONG lRetval;
    //
    // Ignore milliseconds because it is immaterial for our purposes
    //


    dwTime1= st1.wSecond + 60 *
        (st1.wMinute + 60* (st1.wHour + 24 * (st1.wDay)));


    dwTime2= st2.wSecond + 60 *
        (st2.wMinute + 60* (st2.wHour + 24 * (st2.wDay)));


    if (dwTime1 == dwTime2) {
        return(0);
    }

    if (dwTime1 > dwTime2 && (st1.wMonth == st2.wMonth) &&
        st1.wYear == st2.wYear) {
        lRetval = (LONG)(dwTime1-dwTime2);
        goto cleanup;
    }


    dwMonth1 = 12*st1.wYear+ st1.wMonth;
    dwMonth2 = 12*st2.wYear+ st2.wMonth;

    if (dwMonth1 < dwMonth2) {
        //
        // looks like we got a bogus value. return -1
        //
        lRetval = -1;
        goto cleanup;
    }

    //
    // if there is a month difference of more than 1 then we return
    // a large positive number (0xFFFFFFF)
    //

    if (dwMonth1 > dwMonth2+1) {
        lRetval = 0xFFFFFFF;
        goto cleanup;
    }


    //
    //  we crossed a month boundary
    //

    dwTime1= st1.wSecond + 60 *
        (st1.wMinute + 60* (st1.wHour));


    dwTime2= st2.wSecond + 60 *
        (st2.wMinute);

    lRetval = ( dwTime2- dwTime1 + 60*60*24);
    goto cleanup;


cleanup:
    return(lRetval);
}

BOOL
IsAddressNumeric(
    LPWSTR HostName
)
{
    BOOLEAN rc = FALSE;

    //
    //  to check to see if it's a TCP address, we check for it to only
    //  contain only numerals and periods.
    //

    while (((*HostName >= L'0') && (*HostName <= L'9')) ||
            (*HostName == L'.')) {
        HostName++;
    }

    //
    //  if we hit the end of the hostname, then it's an address.
    //

    if (*HostName == L'\0' || *HostName == L':') {

        rc = TRUE;
    }
    return rc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\common.cxx ===
#include "winnt.hxx"
#pragma hdrstop

HRESULT
ConvertSafeArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    );


HRESULT
ConvertByRefSafeArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    );

HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    ADSTYPE dwADsType,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    );


FILTERS Filters[] = {
                    {L"user", WINNT_USER_ID},
                    {L"group", WINNT_GROUP_ID},  // for backward compatibility
                    {L"localgroup", WINNT_LOCALGROUP_ID},
                    {L"globalgroup", WINNT_GLOBALGROUP_ID},
                    {L"printqueue", WINNT_PRINTER_ID},
                    {L"domain", WINNT_DOMAIN_ID},
                    {L"computer", WINNT_COMPUTER_ID},
                    {L"service", WINNT_SERVICE_ID},
                    {L"fileshare", WINNT_FILESHARE_ID},
                    {L"schema", WINNT_SCHEMA_ID},
                    {L"class", WINNT_CLASS_ID},
                    {L"syntax", WINNT_SYNTAX_ID},
                    {L"property", WINNT_PROPERTY_ID},
                    {L"FPNWfileshare", WINNT_FPNW_FILESHARE_ID}
                  };

#define MAX_FILTERS  (sizeof(Filters)/sizeof(FILTERS))

PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;
extern WCHAR * szProviderName;



//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains Winnt routines and properties that are common to
//              all Winnt objects. Winnt objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------



HRESULT
BuildADsPath(
    LPWSTR Parent,
    LPWSTR Name,
    LPWSTR *pADsPath
    )
{
    WCHAR ADsPath[MAX_PATH];
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;
    LPWSTR pszDisplayName = NULL;

    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent && Name);
    ADsAssert(pADsPath);

    hr = GetDisplayName(
             Name,
             &pszDisplayName
             );
    BAIL_ON_FAILURE(hr);

    if (!pszDisplayName || !*pszDisplayName) {
        //
        // The display name has to be valid.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // Special case the Namespace object; if
    // the parent is L"ADs:", then Name = ADsPath
    //

    if (!_wcsicmp(Parent, L"ADs:")) {
        *pADsPath = AllocADsStr(pszDisplayName);
        if (*pADsPath == NULL) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        else {
            hr = S_OK;
            goto cleanup;
        }
    }

    //
    // Make sure that the buffer will be large enough.
    // MAX_PATH - 3 is used because we use one character for the NULL terminator 
    // and at the most, 2 slashes in the middle of the string
    //
    if ((wcslen(pszDisplayName) + wcslen(Parent)) > MAX_PATH - 3) 
    {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    //
    // The rest of the cases we expect valid data,
    // Path, Parent and Name are read-only, the end-user
    // cannot modify this data
    //

    //
    // For the first object, the domain object we do not add
    // the first backslash; so we examine that the parent is
    // L"WinNT:" and skip the slash otherwise we start with
    // the slash
    //

    wsprintf(ProviderName, L"%s:", szProviderName);

    wcscpy(ADsPath, Parent);

    if (_wcsicmp(ADsPath, ProviderName)) {
        wcscat(ADsPath, L"/");
    }else {
        wcscat(ADsPath, L"//");
    }
    wcscat(ADsPath, pszDisplayName);

    *pADsPath = AllocADsStr(ADsPath);

    if (*pADsPath == NULL)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);


cleanup:
error:

    if (pszDisplayName) {
        FreeADsMem(pszDisplayName);
    }

    RRETURN(hr);
}

HRESULT
BuildSchemaPath(
    LPWSTR Parent,
    LPWSTR Name,
    LPWSTR Schema,
    LPWSTR *pSchemaPath
    )
{
    WCHAR SchemaPath[MAX_PATH];
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(Parent);


    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent);
    ADsAssert(pSchemaPath);

    //
    // If no schema name is passed in, then there is no schema path
    //
    if ( Schema == NULL || *Schema == 0 ){

        *pSchemaPath = AllocADsStr(L"");
        RRETURN(*pSchemaPath ? S_OK: E_OUTOFMEMORY );
    }

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);


    wsprintf(SchemaPath, L"%s://", szProviderName);

    if (!pObjectInfo->NumComponents) {
        if( (wcslen(Name) + wcslen(szProviderName) + 4) > MAX_PATH ) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }
        wcscat(SchemaPath, Name);
    }else{
        if( (wcslen(pObjectInfo->DisplayComponentArray[0]) +
                    wcslen(szProviderName) + 4) > MAX_PATH ) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        } 
        wcscat(SchemaPath, pObjectInfo->DisplayComponentArray[0]);
    }

    if( (wcslen(SchemaPath) + wcslen(SCHEMA_NAME) + wcslen(Schema) + 3) >
               MAX_PATH ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
 
    wcscat( SchemaPath, L"/");
    wcscat( SchemaPath, SCHEMA_NAME );
    wcscat( SchemaPath, L"/");
    wcscat( SchemaPath, Schema );


    *pSchemaPath = AllocADsStr(SchemaPath);
    hr = pSchemaPath ? S_OK: E_OUTOFMEMORY ;

error:

    FreeObjectInfo( &ObjectInfo, TRUE );

    RRETURN(hr);
}



HRESULT
BuildADsGuid(
    REFCLSID clsid,
    LPWSTR *pADsClass
    )
{
    WCHAR ADsClass[MAX_PATH];

    if (!StringFromGUID2(clsid, ADsClass, MAX_PATH)) {
        //
        // MAX_PATH should be more than enough for the GUID.
        //
        ADsAssert(!"GUID too big !!!");
        RRETURN(E_FAIL);
    }

    *pADsClass = AllocADsStr(ADsClass);
    RRETURN (*pADsClass ? S_OK: E_OUTOFMEMORY);

}


HRESULT
MakeUncName(
    LPWSTR szSrcBuffer,
    LPWSTR szTargBuffer
    )
{
    //
    // The szTargBuffer MUST be at least MAX_PATH characters in length
    //
    ADsAssert(szSrcBuffer);
    ADsAssert(szTargBuffer);
    if (!szSrcBuffer || !szTargBuffer)
    {
      RRETURN(E_ADS_BAD_PARAMETER);
    }

    wcscpy(szTargBuffer, L"\\\\");

    //
    // Only concatenate up to the size of the (buffer - 3) 
    // (for the 2 slashes plus the null terminator)
    //
    wcsncat(szTargBuffer, szSrcBuffer, MAX_PATH - 3);

    //
    // If the string was truncated, return it anyway, but indicate that 
    // an error occurred.
    //
    if (wcslen(szSrcBuffer) > MAX_PATH - 3)
    {
      RRETURN(E_ADS_BAD_PARAMETER);
    }

    RRETURN(S_OK);
}


HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}


HRESULT
BuildObjectInfo(
    LPWSTR ADsParent,
    LPWSTR Name,
    POBJECTINFO * ppObjectInfo
    )
{
    WCHAR szBuffer[MAX_PATH];
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;

    //
    // Both should be set in this call, cannot have a NULL parent.
    //
    if (!ADsParent || !*ADsParent) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    //
    // We need to make sure that the path is not greater
    // than MAX_PATH + 2 = 1 for / and another for \0
    //
    if ((wcslen(ADsParent) + wcslen(Name) + 2) > MAX_PATH) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    wcscpy(szBuffer, ADsParent);
    wcscat(szBuffer, L"/");
    wcscat(szBuffer, Name);

    CLexer Lexer(szBuffer);

    pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));
    if (!pObjectInfo) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    *ppObjectInfo = pObjectInfo;

    RRETURN(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    *ppObjectInfo = NULL;

    RRETURN(hr);
}



HRESULT
BuildObjectInfo(
    LPWSTR ADsPath,
    POBJECTINFO * ppObjectInfo
    )
{
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(ADsPath);

    pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));
    if (!pObjectInfo) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    *ppObjectInfo = pObjectInfo;

    RRETURN(hr);

error:

    if (pObjectInfo) {
        FreeObjectInfo(pObjectInfo);
    }

    *ppObjectInfo =  NULL;

    RRETURN(hr);
}


HRESULT
MakeWinNTAccountName(
    POBJECTINFO pObjectInfo,
    LPWSTR  szUserAccount,
    BOOL fConnectToReg
    )
{
    HRESULT hr = S_OK;
    DWORD dwNumComp = 0;
    DWORD dwProductType = PRODTYPE_INVALID;
    WCHAR szDomain[MAX_PATH];
    WCHAR szSAMName[MAX_ADS_PATH];
    BOOL fReplacedWithDC = FALSE;

    // The credentials are needed to pass into WinNTGetCachedComputerName
    CWinNTCredentials nullCredentials;

    if (!pObjectInfo || !szUserAccount)
    {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    // Need szSAMName as dummy param
    szSAMName[0] = szUserAccount[0] = L'\0';
    

    dwNumComp = pObjectInfo->NumComponents;

    switch (dwNumComp) {

    case 2:
    case 3:

        //
        // Check if machine is a dc
        //

        //
        // Going to try getComputerName first as the NetWkstaGetInfo call
        // times out faster than the RegConnect call we use in
        // GetMachineProductType - AjayR 11-06-98.
        //

        if (fConnectToReg) {

            if (dwNumComp==2) {
               //
               // we don't have domain name in pObjectInfo, let's try
               // to get it from the dc name (comp[0])
               //

               hr = WinNTGetCachedComputerName(
                   pObjectInfo->ComponentArray[0],
                   szUserAccount,
                   szSAMName,
                   nullCredentials
                   );

               if (SUCCEEDED(hr))
               {
                   fReplacedWithDC = TRUE;
               }
            }

            else // dwNumComp==3
            {
               //
               // We have domain name (comp[0]) in our objectInfo, let's use
               // it. Can call ValidateComputerName here, but not needed
               // since error will be caught next.
               //

               wcscpy(szUserAccount, pObjectInfo->ComponentArray[0]);

               fReplacedWithDC = TRUE;
            }

            if (fReplacedWithDC) {
                //
                // Now try connecting to make sure it is a DC
                // otherwise we should not do this replacement
                //
                hr = GetMachineProductType(
                         pObjectInfo->ComponentArray[dwNumComp-2],
                         &dwProductType
                         );
                BAIL_ON_FAILURE(hr);

                if (dwProductType != PRODTYPE_DC) {
                    //
                    // We cannot use szUserAccount as it has
                    // bad info
                    //
                    fReplacedWithDC = FALSE;
                    hr = E_FAIL;
                }

            }

        }// if fConnectToReg

        BAIL_ON_FAILURE(hr);
        //
        // Do not want to replace machine name with domain since not dc or
        // dc but can't replace - best efforts fail
        //

        if (fReplacedWithDC==FALSE)
        {
            wcscpy(szUserAccount, pObjectInfo->ComponentArray[dwNumComp-2]);
        }

        //
        // Add \UserName to account name
        //
        wcscat(szUserAccount, L"\\");
        wcscat(szUserAccount, pObjectInfo->ComponentArray[dwNumComp-1]);
        break;

    default:

        RRETURN(E_ADS_UNKNOWN_OBJECT);

    }


error:
    RRETURN(hr);
}



HRESULT
MakeWinNTDomainAndName(
    POBJECTINFO pObjectInfo,
    LPWSTR szDomName
    )
{
    DWORD dwNumComp = pObjectInfo->NumComponents;

    switch (dwNumComp) {
    case 2:
    case 3:
        wcscpy(szDomName, pObjectInfo->ComponentArray[dwNumComp - 2]);
        wcscat(szDomName, L"\\");
        wcscat(szDomName, pObjectInfo->ComponentArray[dwNumComp - 1]);
        break;

    default:
        RRETURN(E_ADS_UNKNOWN_OBJECT);

    }
    RRETURN(S_OK);
}

HRESULT
ValidateObject(
    DWORD dwObjectType,
    POBJECTINFO pObjectInfo,
    CWinNTCredentials& Credentials
    )
{
    ULONG uGroupType;
    DWORD dwParentId;

    switch (dwObjectType) {
      case WINNT_USER_ID:
        RRETURN(ValidateUserObject(pObjectInfo, &dwParentId, Credentials));

      case WINNT_GROUP_ID:
        RRETURN(ValidateGroupObject(
                    pObjectInfo,
                    &uGroupType,
                    &dwParentId,
                    Credentials
                    ));

      case WINNT_COMPUTER_ID:
        RRETURN(ValidateComputerObject(pObjectInfo, Credentials));

      case WINNT_PRINTER_ID:
        RRETURN(ValidatePrinterObject(pObjectInfo, Credentials));

      case WINNT_SERVICE_ID:
        RRETURN(ValidateServiceObject(pObjectInfo, Credentials));

      case WINNT_FILESHARE_ID:
        RRETURN(ValidateFileShareObject(pObjectInfo, Credentials));

      default:
        RRETURN(E_FAIL);
    }
}

VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo,
    BOOL fStatic
    )
{
    DWORD i = 0;

    if (!pObjectInfo) {
        return;
    }

    FreeADsStr( pObjectInfo->ProviderName );

    for (i = 0; i < pObjectInfo->NumComponents; i++ ) {
        FreeADsStr(pObjectInfo->ComponentArray[i]);
        FreeADsStr(pObjectInfo->DisplayComponentArray[i]);
    }

    if ( !fStatic )
        FreeADsMem(pObjectInfo);
}

HRESULT
CopyObjectInfo(
    POBJECTINFO pSrcObjectInfo,
    POBJECTINFO *pTargObjectInfo
    )
{
    POBJECTINFO pObjectInfo = NULL;
    HRESULT hr S_OK;
    DWORD i;

    if(!pSrcObjectInfo){
        RRETURN(S_OK);
    }
    pObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));

    if (!pObjectInfo) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    pObjectInfo->ObjectType = pSrcObjectInfo->ObjectType;
    pObjectInfo->NumComponents = pSrcObjectInfo->NumComponents;
    pObjectInfo->ProviderName = AllocADsStr(pSrcObjectInfo->ProviderName);

    for(i=0; i<pSrcObjectInfo->NumComponents; i++){
        pObjectInfo->ComponentArray[i] =
          AllocADsStr(pSrcObjectInfo->ComponentArray[i]);
        pObjectInfo->DisplayComponentArray[i] =
          AllocADsStr(pSrcObjectInfo->DisplayComponentArray[i]);
    }
    *pTargObjectInfo = pObjectInfo;
    RRETURN(hr);

error:
    RRETURN(hr);
}

HRESULT
GetObjectType(
    PFILTERS pFilters,
    DWORD dwMaxFilters,
    LPWSTR ClassName,
    PDWORD pdwObjectType
    )
{
    DWORD i = 0;

    ADsAssert(pdwObjectType);

    for (i = 0; i < dwMaxFilters; i++) {
        if (!_wcsicmp(ClassName, (pFilters + i)->szObjectName)) {
            *pdwObjectType = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }
    }
    *pdwObjectType = 0;
    RRETURN(E_INVALIDARG);
}


HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{

    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (!(wcscmp(pObjectInfo->ProviderName, szProviderName))) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}


HRESULT
GetDomainFromPath(
    LPTSTR ADsPath,
    LPTSTR szDomainName
    )
{
   OBJECTINFO ObjectInfo;
   POBJECTINFO pObjectInfo = &ObjectInfo;
   CLexer Lexer(ADsPath);
   HRESULT hr = S_OK;


   //assumption: Valid strings are passed to GetDomainFromPath

   ADsAssert(ADsPath);
   ADsAssert(szDomainName);

   memset(pObjectInfo, 0, sizeof(OBJECTINFO));
   hr = Object(&Lexer, pObjectInfo);
   BAIL_ON_FAILURE(hr);


   if (pObjectInfo->NumComponents) {
       wcscpy(szDomainName, pObjectInfo->ComponentArray[0]);
   }else {
       hr = E_FAIL;
   }

error:

   FreeObjectInfo( &ObjectInfo, TRUE );

   RRETURN(hr);
}

HRESULT
GetServerFromPath(
    LPTSTR ADsPath,
    LPTSTR szServerName
    )
{
   OBJECTINFO ObjectInfo;
   POBJECTINFO pObjectInfo = &ObjectInfo;
   CLexer Lexer(ADsPath);
   HRESULT hr = S_OK;


   //assumption: Valid strings are passed to GetDomainFromPath

   ADsAssert(ADsPath);
   ADsAssert(szServerName);

   memset(pObjectInfo, 0, sizeof(OBJECTINFO));
   hr = Object(&Lexer, pObjectInfo);
   BAIL_ON_FAILURE(hr);


   if (pObjectInfo->NumComponents > 1) {
       wcscpy(szServerName, pObjectInfo->ComponentArray[1]);
   }else {
       hr = E_FAIL;
   }

error:

   FreeObjectInfo( &ObjectInfo, TRUE );

   RRETURN(hr);
}



DWORD
TickCountDiff(
    DWORD dwTime1,
    DWORD dwTime2
    )
{
   //
   // does dwTime1 - dwTime2 and takes care of wraparound.
   // The first time must be later than the second
   // Restriction:: The two times must have been taken not more than
   // 49.7 days apart
   //

   DWORD dwRetval;

   if(dwTime1 >= dwTime2){
      dwRetval = dwTime1 - dwTime2;
   }

   else{
      dwRetval = dwTime2 - dwTime1;
      dwRetval =  MAX_DWORD - dwRetval;
   }
   return dwRetval;
}

HRESULT
DelimitedStringToVariant(
    LPTSTR pszString,
    VARIANT *pvar,
    TCHAR Delimiter
    )
{
    SAFEARRAYBOUND sabound[1];
    DWORD dwElements;
    LPTSTR pszCurrPos = pszString;
    LPTSTR *rgszStrings = NULL;
    SAFEARRAY *psa = NULL;
    VARIANT v;
    HRESULT hr = S_OK;
    LONG i;

    //
    // This function converts a delimited string into a VARIANT of
    // safe arrays.
    //
    // Assumption: a valid string are passed to this function
    // note that the input string gets destroyed in the process
    //

    //
    // scan the delimited string once to find out the dimension
    //

    //
    // in order to filter for NULL input values do a sanity check for
    // length of input string.
    //


    if (!pszString){
        sabound[0].cElements = 0;
        sabound[0].lLbound = 0;

        psa = SafeArrayCreate(VT_VARIANT, 1, sabound);

        if (psa == NULL){
            hr = E_OUTOFMEMORY;
            goto error;
        }

        VariantInit(pvar);
        V_VT(pvar) = VT_ARRAY|VT_VARIANT;
        V_ARRAY(pvar) = psa;
        goto error;
    }

    dwElements = (wcslen(pszString) == 0) ? 0: 1 ;

    while(!(*pszCurrPos == TEXT('\0'))){
        if(*pszCurrPos == Delimiter){
            dwElements++;
            *pszCurrPos = TEXT('\0');
        }
        pszCurrPos++;
    }

    rgszStrings = (LPTSTR *)AllocADsMem(sizeof(LPTSTR)*dwElements);

    if(!rgszStrings){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // scan string again and put the appropriate pointers
    //

    pszCurrPos = pszString;
    if(rgszStrings != NULL){
        (*rgszStrings) = pszCurrPos;
    }
    i = 1;

    while(i < (LONG)dwElements){

        if(*pszCurrPos == TEXT('\0')){
            *(rgszStrings+i) = ++pszCurrPos;
            i++;
        }
        pszCurrPos++;
    }


    //
    // create the safearray
    //

    sabound[0].cElements = dwElements;
    sabound[0].lLbound = 0;

    psa = SafeArrayCreate(VT_VARIANT, 1, sabound);

    if (psa == NULL){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    for(i=0; i<(LONG)dwElements; i++){

        VariantInit(&v);
        V_VT(&v) = VT_BSTR;

        hr = ADsAllocString(*(rgszStrings+i), &(V_BSTR(&v)));

        BAIL_ON_FAILURE(hr);

        //
        // Stick the caller provided data into the end of the SafeArray
        //

        hr = SafeArrayPutElement(psa, &i, &v);
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);

    }

    //
    // convert this safearray into a VARIANT
    //

    VariantInit(pvar);
    V_VT(pvar) = VT_ARRAY|VT_VARIANT;
    V_ARRAY(pvar) = psa;

error:
    if(rgszStrings && dwElements != 0){
        FreeADsMem(rgszStrings);
    }
    RRETURN(hr);
}


HRESULT
BuildComputerFromObjectInfo(
    POBJECTINFO pObjectInfo,
    LPTSTR pszADsPath
    )
{

    if(!pObjectInfo){
        RRETURN(E_FAIL);
    }

    if(pObjectInfo->NumComponents == 3) {

        wsprintf(
            pszADsPath,
            L"%s://%s/%s",
            pObjectInfo->ProviderName,
            pObjectInfo->ComponentArray[0],
            pObjectInfo->ComponentArray[1]
            );

    } else if (pObjectInfo->NumComponents == 2){

        wsprintf(
            pszADsPath,
            L"%s://%s",
            pObjectInfo->ProviderName,
            pObjectInfo->ComponentArray[0]
            );

    } else {
        RRETURN(E_FAIL);
    }

    RRETURN(S_OK);

}

HRESULT
FPNWSERVERADDRtoString(
    FPNWSERVERADDR WkstaAddress,
    LPWSTR * ppszString
    )
{

    HRESULT hr = S_OK;
    TCHAR  szNibble[2]; //one number and a null termination
    USHORT  usNibble;
    int i;
    TCHAR szWkstaAddr[MAX_PATH];

    //
    // assumption: valid input values are passed to this function.
    //

    //
    // First 4 bytes is network address, then a dot and then bytes 5-10
    // are physical node address. Each byte consumes 2 chars space.
    // Then a byte for TEXT('\0')
    //

    _tcscpy(szWkstaAddr, TEXT(""));

    for( i=0; i < 4; i++){

         usNibble = WkstaAddress[i] & 0xF0;
         usNibble = usNibble >> 4;
        _itot(usNibble, szNibble, 16 );
        _tcscat(szWkstaAddr, szNibble);
         usNibble = WkstaAddress[i] & 0xF;
        _itot(usNibble, szNibble, 16 );
        _tcscat(szWkstaAddr, szNibble);

    }

    _tcscat(szWkstaAddr, TEXT("."));

    for(i=4; i<10 ; i++){

         usNibble = WkstaAddress[i] & 0xF0;
         usNibble = usNibble >> 4;
        _itot(usNibble, szNibble, 16 );
        _tcscat(szWkstaAddr, szNibble);
         usNibble = WkstaAddress[i] & 0xF;
        _itot(usNibble, szNibble, 16 );
        _tcscat(szWkstaAddr, szNibble);
    }

    *ppszString = AllocADsStr(szWkstaAddr);

    if(!*ppszString){
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

PKEYDATA
CreateTokenList(
    LPWSTR   pKeyData
)
{
    DWORD       cTokens;
    DWORD       cb;
    PKEYDATA    pResult;
    LPWSTR       pDest;
    LPWSTR       psz = pKeyData;
    LPWSTR      *ppToken;

    if (!psz || !*psz)
        return NULL;

    cTokens=1;

    // Scan through the string looking for commas,
    // ensuring that each is followed by a non-NULL character:

    while ((psz = wcschr(psz, L',')) && psz[1]) {

        cTokens++;
        psz++;
    }

    cb = sizeof(KEYDATA) + (cTokens-1) * sizeof(LPWSTR) +
         wcslen(pKeyData)*sizeof(WCHAR) + sizeof(WCHAR);

    if (!(pResult = (PKEYDATA)AllocADsMem(cb)))
        return NULL;

    // Initialise pDest to point beyond the token pointers:

    pDest = (LPWSTR)((LPBYTE)pResult + sizeof(KEYDATA) +
                                      (cTokens-1) * sizeof(LPWSTR));

    // Then copy the key data buffer there:

    wcscpy(pDest, pKeyData);

    ppToken = pResult->pTokens;


    // Remember, wcstok has the side effect of replacing the delimiter
    // by NULL, which is precisely what we want:

    psz = wcstok (pDest, L",");

    while (psz) {

        *ppToken++ = psz;
        psz = wcstok (NULL, L",");
    }

    pResult->cTokens = cTokens;

    return( pResult );
}

STDMETHODIMP
GenericGetPropertyManager(
    CPropertyCache * pPropertyCache,
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    DWORD dwInfoLevel;
    LPNTOBJECT pNtSrcObjects = NULL;

    //
    // For those who know no not what they do
    //
    if (!pvProp) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // retrieve data object from cache; if one exists

    hr = pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pNtSrcObjects
                );

    BAIL_ON_FAILURE(hr);


    //
    // translate the Nt objects to variants
    //

    if (dwNumValues == 1) {

        hr = NtTypeToVarTypeCopy(
                    pNtSrcObjects,
                    pvProp
                    );

    }else {

        hr = NtTypeToVarTypeCopyConstruct(
                pNtSrcObjects,
                dwNumValues,
                pvProp
                );
    }

    BAIL_ON_FAILURE(hr);

error:

    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}

STDMETHODIMP
GenericPutPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    THIS_ BSTR bstrName,
    VARIANT vProp,
    BOOL fCheckSchemaWriteAccess
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNTOBJECT pNtDestObjects = NULL;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    DWORD dwNumValues = 0;


    //
    // check if property in schema and get syntax of property
    //

    hr = ValidatePropertyinSchemaClass(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName,
                &dwSyntaxId
                );

    if(TRUE == fCheckSchemaWriteAccess) {
    //
    // check if this is a writeable property in the schema
    //

        hr = ValidateIfWriteableProperty(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName
                );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Issue: How do we handle multi-valued support
    //

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY)) ||
        (V_VT(&vProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF))) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);

        if( (0 == dwNumValues) && (NULL == pVarArray) ) {
        // return error if the safearray had no elements. Otherwise, the
        // NT object stored in the property cache is garbage.
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }

        pvProp = pVarArray;

    }else {

        dwNumValues = 1;
    }


    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = pPropertyCache->putproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }


    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}



STDMETHODIMP
GenericGetExPropertyManager(
    DWORD dwObjectState,
    CPropertyCache * pPropertyCache,
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;

    if (!pvProp)
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);

    //
    // retrieve data object from cache; if one exis
    //

    if (dwObjectState == ADS_OBJECT_UNBOUND) {

        hr = pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = NtTypeToVarTypeCopyConstruct(
                pNtSrcObjects,
                dwNumValues,
                pvProp
                );

    BAIL_ON_FAILURE(hr);

error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


STDMETHODIMP
GenericPutExPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPNTOBJECT pNtDestObjects = NULL;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    DWORD dwNumValues = 0;


    //
    // check if property in schema and get syntax of property
    //

    hr = ValidatePropertyinSchemaClass(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName,
                &dwSyntaxId
                );

    //
    // check if this is a writeable property in the schema
    //

    hr = ValidateIfWriteableProperty(
                pSchemaProps,
                dwSchemaPropSize,
                bstrName
                );
    BAIL_ON_FAILURE(hr);


    //
    // Issue: How do we handle multi-valued support
    //

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pvProp = &vProp;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY)) ||
        (V_VT(&vProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF))) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    *pvProp,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);

        if( (0 == dwNumValues) && (NULL == pVarArray) ) {
        // return error if the safearray had no elements. Otherwise, the
        // NT object stored in the property cache is garbage.
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }

        pvProp = pVarArray;

    }else {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = pPropertyCache->putproperty(
                    bstrName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }


    RRETURN(hr);
}


DWORD
DelimitedStrSize(
    LPWSTR pszString,
    WCHAR  Delimiter
    )
{

    DWORD dwElements = (wcslen(pszString) == 0) ? 0: 1 ;
    LPTSTR pszCurrPos = pszString;

    if (!pszString || !*pszString) {
        return dwElements;
    }

    while(!(*pszCurrPos == TEXT('\0'))){

        if(*pszCurrPos == Delimiter){
            dwElements++;
            *pszCurrPos = TEXT('\0');
        }

        pszCurrPos++;
    }

    return dwElements;

}




DWORD
NulledStrSize(
    LPWSTR pszString
    )
{


    DWORD dwElements = 0;
    LPTSTR pszCurrPos = pszString;
    BOOL foundNULL = FALSE;

    if (!pszString || !*pszString) {
        return dwElements;
    }

    while(!(*pszCurrPos == TEXT('\0') && foundNULL== TRUE)){

        if(*pszCurrPos == TEXT('\0')){
            dwElements++;
            foundNULL = TRUE;
        } else {
            foundNULL = FALSE;
        }

        pszCurrPos++;
    }

    return dwElements;

}



HRESULT
GenericPropCountPropertyManager(
    CPropertyCache * pPropertyCache,
    PLONG plCount
    )
{
    HRESULT hr = E_FAIL;

    if (!plCount)
        hr = E_ADS_BAD_PARAMETER;
    else if (pPropertyCache) {
        hr = pPropertyCache->get_PropertyCount((PDWORD)plCount);
    }

    RRETURN(hr);
}

HRESULT
GenericNextPropertyManager(
    CPropertyCache * pPropertyCache,
    VARIANT FAR *pVariant
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    LPNTOBJECT pNtSrcObjects = NULL;
    VARIANT varData;
    IDispatch * pDispatch = NULL;

    VariantInit(&varData);

    if (!pVariant)
        BAIL_ON_FAILURE(E_ADS_BAD_PARAMETER);

    hr = pPropertyCache->unboundgetproperty(
                pPropertyCache->get_CurrentIndex(),
                &dwSyntaxId,
                &dwNumValues,
                &pNtSrcObjects
                );
    BAIL_ON_FAILURE(hr);

    //
    // translate the Nt objects to variants
    //

    hr = ConvertNtValuesToVariant(
                pPropertyCache->get_CurrentPropName(),
                pNtSrcObjects,
                dwNumValues,
                pVariant
                );
    BAIL_ON_FAILURE(hr);



error:


    //
    // - goto next one even if error to avoid infinite looping at a property
    //   which we cannot convert (e.g. schemaless server property.)
    // - do not return the result of Skip() as current operation does not
    //   depend on the sucess of Skip().
    //

    pPropertyCache->skip_propindex(
                1
                );

    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
                pNtSrcObjects,
                dwNumValues
                );
    }

    RRETURN(hr);
}


HRESULT
GenericSkipPropertyManager(
    CPropertyCache * pPropertyCache,
    ULONG cElements
    )
{
    HRESULT hr = E_FAIL;

    hr = pPropertyCache->skip_propindex(
                cElements
                );
    RRETURN(hr);
}

HRESULT
GenericResetPropertyManager(
    CPropertyCache * pPropertyCache
    )
{
    pPropertyCache->reset_propindex();

    RRETURN(S_OK);
}

HRESULT
GenericDeletePropertyManager(
    CPropertyCache * pPropertyCache,
    VARIANT varEntry
    )
{
   HRESULT hr = S_OK;
   DWORD dwIndex = 0;

   switch (V_VT(&varEntry)) {

   case VT_BSTR:

       hr = pPropertyCache->findproperty(
                           V_BSTR(&varEntry),
                           &dwIndex
                           );
       BAIL_ON_FAILURE(hr);
       break;

   case VT_I4:
       dwIndex = V_I4(&varEntry);
       break;


   case VT_I2:
       dwIndex = V_I2(&varEntry);
       break;


   default:
       hr = E_FAIL;
       BAIL_ON_FAILURE(hr);
   }

   hr = pPropertyCache->deleteproperty(
                       dwIndex
                       );
error:
   RRETURN(hr);
}


HRESULT
GenericPutPropItemPropertyManager(
    CPropertyCache * pPropertyCache,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    VARIANT varData
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    WCHAR szPropertyName[MAX_PATH] = L"";
    LPNTOBJECT pNtDestObjects = NULL;
    DWORD dwNumValues = 0;
    DWORD dwControlCode = 0;



    hr = ConvertVariantToNtValues(
                varData,
                pSchemaProps,
                dwSchemaPropSize,
                szPropertyName,
                &pNtDestObjects,
                &dwNumValues,
                &dwSyntaxId,
                &dwControlCode
                );
    BAIL_ON_FAILURE(hr);

    if (dwControlCode != ADS_PROPERTY_UPDATE) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }


    //
    // check if this is a writeable property in the schema
    //

    hr = ValidateIfWriteableProperty(
                pSchemaProps,
                dwSchemaPropSize,
                szPropertyName
                );
    BAIL_ON_FAILURE(hr);


    //
    // Find this property in the cache
    //

    hr = pPropertyCache->findproperty(
                        szPropertyName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = pPropertyCache->addproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = pPropertyCache->putproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNtDestObjects) {
        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumValues
                );

    }

    RRETURN(hr);
}



HRESULT
GenericGetPropItemPropertyManager(
    CPropertyCache * pPropertyCache,
    DWORD dwObjectState,
    BSTR bstrName,
    LONG lnADsType,
    VARIANT * pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;

    if (!pVariant)
        BAIL_ON_FAILURE(E_ADS_BAD_PARAMETER);

    //
    // retrieve data object from cache; if one exis
    //

    if (dwObjectState == ADS_OBJECT_UNBOUND) {

        hr = pPropertyCache->unboundgetproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = pPropertyCache->getproperty(
                    bstrName,
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);
    }


    //
    // translate the Nds objects to variants
    //

    hr = ConvertNtValuesToVariant(
                bstrName,
                pNtSrcObjects,
                dwNumValues,
                pVariant
                );
    BAIL_ON_FAILURE(hr);

error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}



HRESULT
GenericItemPropertyManager(
    CPropertyCache * pPropertyCache,
    DWORD dwObjectState,
    VARIANT varIndex,
    VARIANT *pVariant
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwNumValues;
    LPNTOBJECT pNtSrcObjects = NULL;
    LPWSTR szPropName = NULL;
    VARIANT *pvVar = &varIndex;

    if (!pVariant)
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);

    //
    // retrieve data object from cache; if one exis
    //

    if (V_VT(pvVar) == (VT_BYREF|VT_VARIANT)) {
        //
        // The value is being passed in byref so we need to
        // deref it for vbs stuff to work
        //
        pvVar = V_VARIANTREF(&varIndex);
    }

    switch (V_VT(pvVar)) {

    case VT_BSTR:
        if (dwObjectState == ADS_OBJECT_UNBOUND) {

            hr = pPropertyCache->unboundgetproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNtSrcObjects
                        );
            BAIL_ON_FAILURE(hr);

        }else {

            hr = pPropertyCache->getproperty(
                        V_BSTR(pvVar),
                        &dwSyntaxId,
                        &dwNumValues,
                        &pNtSrcObjects
                        );
            BAIL_ON_FAILURE(hr);
        }

        hr = ConvertNtValuesToVariant(
                    V_BSTR(pvVar),
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);

        break;


    case VT_I4:

        hr = pPropertyCache->unboundgetproperty(
                    V_I4(pvVar),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = pPropertyCache->get_PropName(V_I4(pvVar));

        hr = ConvertNtValuesToVariant(
                    szPropName,
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;


    case VT_I2:

        hr = pPropertyCache->unboundgetproperty(
                    (DWORD)V_I2(pvVar),
                    &dwSyntaxId,
                    &dwNumValues,
                    &pNtSrcObjects
                    );
        BAIL_ON_FAILURE(hr);

        szPropName = pPropertyCache->get_PropName(V_I2(pvVar));

        hr = ConvertNtValuesToVariant(
                    szPropName,
                    pNtSrcObjects,
                    dwNumValues,
                    pVariant
                    );
        BAIL_ON_FAILURE(hr);
        break;


    default:
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);

    }


error:
    if (pNtSrcObjects) {

        NTTypeFreeNTObjects(
            pNtSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);

}


HRESULT
GenericPurgePropertyManager(
    CPropertyCache * pPropertyCache
    )
{
    pPropertyCache->flushpropcache();
    RRETURN(S_OK);
}





HRESULT
CreatePropEntry(
    LPWSTR szPropName,
    ADSTYPE dwADsType,
    VARIANT varData,
    REFIID riid,
    LPVOID * ppDispatch
    )

{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;

    hr = CoCreateInstance(
                CLSID_PropertyEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsPropertyEntry,
                (void **)&pPropEntry
                );
    BAIL_ON_FAILURE(hr);


    hr = pPropEntry->put_Name(szPropName);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_Values(varData);

    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->put_ADsType(dwADsType);

    BAIL_ON_FAILURE(hr);

    // no control code

    hr = pPropEntry->QueryInterface(
                        riid,
                        ppDispatch
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pPropEntry) {
        pPropEntry->Release();
    }

    RRETURN(hr);

}

HRESULT
ConvertNtValuesToVariant(
    LPWSTR szPropertyName,
    PNTOBJECT pNtSrcObject,
    DWORD dwNumValues,
    PVARIANT pVariant
    )
{
    HRESULT hr = S_OK;
    VARIANT varData;
    IDispatch * pDispatch = NULL;
    PADSVALUE pAdsValues = NULL;
    ADSTYPE dwADsType = ADSTYPE_INVALID;

    VariantInit(&varData);
    VariantInit(pVariant);

    if (dwNumValues>0) {

        hr = NTTypeToAdsTypeCopyConstruct(
                pNtSrcObject,
                dwNumValues,
                &pAdsValues
                );

        if (SUCCEEDED(hr)) {

            hr = AdsTypeToPropVariant(
                    pAdsValues,
                    dwNumValues,
                    &varData
                    );
            BAIL_ON_FAILURE(hr);

            dwADsType = pAdsValues->dwType;
        }

        else if (hr==E_OUTOFMEMORY) {

            BAIL_ON_FAILURE(hr);
        }

        //
        // failed because of NTType is not supported yet (e.g DelimitedString)
        // in NTTypeToAdsTypeCopyConstruct() conversion
        // -> use empty variant now.
        //
        else {

            VariantInit(&varData);
        }
    }

    hr = CreatePropEntry(
            szPropertyName,
            dwADsType,
            varData,
            IID_IDispatch,
            (void **)&pDispatch
            );
    BAIL_ON_FAILURE(hr);


    V_DISPATCH(pVariant) = pDispatch;
    V_VT(pVariant) = VT_DISPATCH;


error:

    VariantClear(&varData);

    if (pAdsValues) {
       AdsFreeAdsValues(
            pAdsValues,
            dwNumValues
            );
       FreeADsMem( pAdsValues );
    }

    RRETURN(hr);

}



HRESULT
ConvertVariantToVariantArray(
    VARIANT varData,
    VARIANT ** ppVarArray,
    DWORD * pdwNumValues
    )
{
    DWORD dwNumValues = 0;
    VARIANT * pVarArray = NULL;
    HRESULT hr = S_OK;
    VARIANT * pVarData = NULL;

    *ppVarArray = NULL;
    *pdwNumValues = 0;

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside.
    //
    pVarData = &varData;
    if (V_VT(pVarData) == (VT_BYREF|VT_VARIANT)) {
        pVarData = V_VARIANTREF(&varData);
    }

    if ((V_VT(pVarData) == (VT_VARIANT|VT_ARRAY|VT_BYREF)) ||
        (V_VT(&varData) == (VT_VARIANT|VT_ARRAY))) {

        hr  = ConvertSafeArrayToVariantArray(
                  *pVarData,
                  &pVarArray,
                  &dwNumValues
                  );
        BAIL_ON_FAILURE(hr);

    } else {

        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    *ppVarArray = pVarArray;
    *pdwNumValues = dwNumValues;

error:
    RRETURN(hr);
}

void
FreeVariantArray(
    VARIANT * pVarArray,
    DWORD dwNumValues
    )
{
    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }
}

HRESULT
ConvertVariantToNtValues(
    VARIANT varData,
    PPROPERTYINFO pSchemaProps,
    DWORD dwSchemaPropSize,
    LPWSTR szPropertyName,
    PNTOBJECT *ppNtDestObjects,
    PDWORD pdwNumValues,
    PDWORD pdwSyntaxId,
    PDWORD pdwControlCode
    )
{
    HRESULT hr = S_OK;
    IADsPropertyEntry * pPropEntry = NULL;
    IDispatch * pDispatch = NULL;
    BSTR bstrPropName = NULL;
    DWORD dwControlCode = 0;
    DWORD dwAdsType = 0;
    VARIANT varValues;
    VARIANT * pVarArray = NULL;
    DWORD dwNumValues = 0;
    PADSVALUE pAdsValues = NULL;
    DWORD dwAdsValues  = 0;

    PNTOBJECT pNtDestObjects = 0;
    DWORD dwNumNtObjects = 0;
    DWORD dwNtSyntaxId = 0;

    if (V_VT(&varData) != VT_DISPATCH) {
        RRETURN (hr = DISP_E_TYPEMISMATCH);
    }

    pDispatch = V_DISPATCH(&varData);

    hr = pDispatch->QueryInterface(
                        IID_IADsPropertyEntry,
                        (void **)&pPropEntry
                        );
    BAIL_ON_FAILURE(hr);

    VariantInit(&varValues);
    VariantClear(&varValues);


    hr = pPropEntry->get_Name(&bstrPropName);
    BAIL_ON_FAILURE(hr);
    if(wcslen(bstrPropName) < MAX_PATH)
        wcscpy(szPropertyName, bstrPropName);
    else {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    hr = pPropEntry->get_ControlCode((long *)&dwControlCode);
    BAIL_ON_FAILURE(hr);
    *pdwControlCode = dwControlCode;

    hr = pPropEntry->get_ADsType((long *)&dwAdsType);
    BAIL_ON_FAILURE(hr);

    hr = pPropEntry->get_Values(&varValues);
    BAIL_ON_FAILURE(hr);

    hr = ConvertVariantToVariantArray(
            varValues,
            &pVarArray,
            &dwNumValues
            );
    BAIL_ON_FAILURE(hr);

    if (dwNumValues) {
        hr = PropVariantToAdsType(
                    pVarArray,
                    dwNumValues,
                    &pAdsValues,
                    &dwAdsValues
                    );
        BAIL_ON_FAILURE(hr);

        hr = AdsTypeToNTTypeCopyConstruct(
                    pAdsValues,
                    dwAdsValues,
                    &pNtDestObjects,
                    &dwNumNtObjects,
                    &dwNtSyntaxId
                    );
        BAIL_ON_FAILURE(hr);

    }

    *pdwNumValues = dwNumValues;
    *ppNtDestObjects = pNtDestObjects;
    *pdwSyntaxId = dwNtSyntaxId;

error:

    if (pVarArray) {
        FreeVariantArray(
                pVarArray,
                dwNumValues
                );
    }

    if (pPropEntry) {
        pPropEntry->Release();
    }
    VariantClear(&varValues);

    if (pAdsValues) {
       AdsFreeAdsValues(
            pAdsValues,
            dwAdsValues
            );
       FreeADsMem( pAdsValues );
    }

    RRETURN(hr);
}


HRESULT
GetMachineProductType(
    IN  LPTSTR  pszServer,
    OUT PRODUCTTYPE *pdwProductType
    )
{

    HRESULT     hr = S_OK;
    LONG        dwStatus;
    HKEY        hkLocalMachine = NULL;
    HKEY        hkProductOptions = NULL;
    DWORD       dwValueType;
    WCHAR       szData[20];
    DWORD       dwDataSize = sizeof(szData);


    //
    // pszServer can be NULL for local server
    //
    if (!pdwProductType)
        RRETURN(E_ADS_BAD_PARAMETER);

    *pdwProductType = PRODTYPE_INVALID;


    //
    // Connect to remote's machine registry
    //
    dwStatus = RegConnectRegistry(
                    pszServer,
                    HKEY_LOCAL_MACHINE,
                    &hkLocalMachine
                    );

    if (dwStatus != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }


    //
    // Open key ProductOptions
    //
    dwStatus = RegOpenKeyEx(
                    hkLocalMachine,
                    L"SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
                    0,
                    KEY_QUERY_VALUE,
                    &hkProductOptions
                    );

    if (dwStatus != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwStatus);
        BAIL_ON_FAILURE(hr);
    }


    //
    // Get Value of Product Type
    //
    dwStatus = RegQueryValueEx(
                    hkProductOptions,
                    L"ProductType",
                    NULL,
                    &dwValueType,
                    (LPBYTE) szData,
                    &dwDataSize
                    );


    //
    //  check server type
    //
    if (_wcsicmp(szData, WINNT_A_LANMANNT_W)==0)
    {
        *pdwProductType = PRODTYPE_DC;
    }
    else if (_wcsicmp(szData, WINNT_A_SERVERNT_W)==0)
    {
        *pdwProductType = PRODTYPE_STDALONESVR;
    }
    else if (_wcsicmp(szData, WINNT_A_WINNT_W)==0)
    {
        *pdwProductType = PRODTYPE_WKSTA;
    }
    else
    {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


error:


    if ( hkLocalMachine )
        RegCloseKey(hkLocalMachine);

    if  ( hkProductOptions )
        RegCloseKey(hkProductOptions);

    RRETURN(hr);
}



//
// Get Sid of account name [lpszAccountName] from server [lpszServerName].
// Unmarshall the Sid into cache [pPropertyCache] if [fExplict] is TRUE.
// Use local machine if [lpszServerName] == NULL.
//

HRESULT
GetSidIntoCache(
    IN  LPTSTR lpszServerName,
    IN  LPTSTR lpszAccountName,
    IN  CPropertyCache * pPropertyCache,
    IN  BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    BOOL fGotSid = FALSE;
    DWORD dwErr = 0;
    PSID pSid = NULL;
    DWORD dwSidLength = 0;
    WCHAR szNewAccountName[MAX_PATH+UNLEN+2];
    LPTSTR lpSrvName;

    //
    // default cbSid size :
    //  - 1 (revision), 1 (authid), max sub(auth)
    //  - * 8 (rev, authid, subid all < 8), but use 8 in case of
    //    structure aligment because of compiler/machine (we want
    //    LookUpAccountName() to succeed at first attempt as much
    //    as possible to min this wired call)
    //

    const DWORD maxSid = (1+1+SID_MAX_SUB_AUTHORITIES) * 8;
    DWORD cbSid = maxSid;

    //
    // dummies
    //

    TCHAR szRefDomainName[MAX_PATH];
    DWORD cbRefDomainName = MAX_PATH;
    SID_NAME_USE eNameUse;


    if (!lpszAccountName)
        RRETURN(E_ADS_INVALID_USER_OBJECT);

    if (!pPropertyCache)
        RRETURN(E_ADS_BAD_PARAMETER);


    //
    // allocate sid and RefDomainName buffer
    //

    pSid = (PSID) AllocADsMem(
                    cbSid
                    );
    if (!pSid) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    
    //
    // get sid and other unused info from server
    //

    fGotSid = LookupAccountName(
                lpszServerName,
                lpszAccountName,
                pSid,
                &cbSid,
                szRefDomainName,
                &cbRefDomainName,
                &eNameUse
                );

    if (!fGotSid) {

        if (cbSid>maxSid) {

            //
            // Fail becuase buffer size required > what we have allocated
            // for some reasons,  retry with correct buffer size
            //

            FreeADsMem(pSid);

            pSid = (PSID) AllocADsMem(
                        cbSid
                        );
            if (!pSid) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            fGotSid = LookupAccountName(
                        lpszServerName,
                        lpszAccountName,
                        pSid,
                        &cbSid,
                        szRefDomainName,
                        &cbRefDomainName,
                        &eNameUse
                        );

            if (!fGotSid) {

                //
                // Fail on retry with proper buffer size, can do no more
                //

                dwErr = GetLastError();
                hr = HRESULT_FROM_WIN32(dwErr);
            }

        } else {

            //
            // Fail becuase of reasons other then buffer size, not need to
            // retry.
            //

            dwErr = GetLastError();
            hr = HRESULT_FROM_WIN32(dwErr);
        }
        
    } 
    
    if( fGotSid && (eNameUse == SidTypeDomain) ) {
            lpSrvName = lpszServerName;
            if (lpszServerName && (lpszServerName[0] == L'\\') && (lpszServerName[1] == L'\\')) {
                lpSrvName += 2;
            }

        #ifdef WIN95
                if (!_wcsicmp(lpszAccountName, lpSrvName)) {
        #else
                if (CompareStringW(
                        LOCALE_SYSTEM_DEFAULT,
                        NORM_IGNORECASE,
                        lpszAccountName,
                        -1,
                        lpSrvName,
                        -1
                        ) == CSTR_EQUAL ) {
        #endif
                    wcscpy(szNewAccountName, lpSrvName);
                    wcscat(szNewAccountName, L"\\");
                    wcscat(szNewAccountName, lpszAccountName);

                    cbSid = maxSid;
                    cbRefDomainName = MAX_PATH;
                
                    fGotSid = LookupAccountName(
                            lpszServerName,
                            szNewAccountName,
                            pSid,
                            &cbSid,
                            szRefDomainName,
                            &cbRefDomainName,
                            &eNameUse
                            );

                    if (!fGotSid) {

                        if (cbSid>maxSid) {

                        //
                        // Fail becuase buffer size required > what we have allocated
                        // for some reasons,  retry with correct buffer size
                        //

                            FreeADsMem(pSid);

                            pSid = (PSID) AllocADsMem(
                                    cbSid
                                    );
                            if (!pSid) {
                                hr = E_OUTOFMEMORY;
                                BAIL_ON_FAILURE(hr);
                            }

                            fGotSid = LookupAccountName(
                                        lpszServerName,
                                        szNewAccountName,
                                        pSid,
                                        &cbSid,
                                        szRefDomainName,
                                        &cbRefDomainName,
                                        &eNameUse
                                        );

                            if (!fGotSid) {

                                //
                                // Fail on retry with proper buffer size, can do no more
                                //

                                dwErr = GetLastError();
                                hr = HRESULT_FROM_WIN32(dwErr);
                            }

                        } else {

                                //
                                // Fail becuase of reasons other then buffer size, not need to
                                // retry.
                                //

                                dwErr = GetLastError();
                                hr = HRESULT_FROM_WIN32(dwErr);
                        }
        
                    }
                }
    }

    BAIL_ON_FAILURE(hr);


    //
    // On NT4 for some reason GetLengthSID does not set lasterror to 0
    //
    SetLastError(NO_ERROR);

    dwSidLength = GetLengthSid((PSID) pSid);

    dwErr = GetLastError();

    //
    // This is an extra check to make sure that we have the
    // correct length.
    //
    if (dwErr != NO_ERROR) {
        hr = HRESULT_FROM_WIN32(dwErr);
    }

    BAIL_ON_FAILURE(hr);
    //
    // store Sid in property cache
    //

    hr = SetOctetPropertyInCache(
                pPropertyCache,
                TEXT("objectSid"),
                (PBYTE) pSid,
                dwSidLength,
                fExplicit
                );
    BAIL_ON_FAILURE(hr);


error:

    if (pSid) {
        FreeADsMem(pSid);
    }

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cjob.cxx ===
/*++
Copyright (c) 1995-1996  Microsoft Corporation

Module Name:

    cjob.cxx

Abstract:
 Contains methods for Print Job object and its property sets for the
 Windows NT provider. Objects whose methods are supported here are

 CWinNTPrintJob,
 CWinNTPrintJob and
 CWinNTPrintJob.


Author:

    Ram Viswanathan (ramv) 11-18-95

Revision History:

--*/

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID


//
// class CWinNTPrintJob Methods
//

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTPrintJob);
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTPrintJob);
DEFINE_IADs_TempImplementation(CWinNTPrintJob);
DEFINE_IADs_PutGetImplementation(CWinNTPrintJob, PrintJobClass,gdwJobTableSize);
DEFINE_IADsPropertyList_Implementation(CWinNTPrintJob, PrintJobClass,gdwJobTableSize)

CWinNTPrintJob::CWinNTPrintJob()
{
    _pDispMgr = NULL;
    _pExtMgr  = NULL;
    _hprinter = NULL;
    _lJobId   = 0;
    _pszPrinterName = NULL;
    _pszPrinterPath = NULL;
    _pPropertyCache = NULL;
    ENLIST_TRACKING(CWinNTPrintJob);
    return;

}

CWinNTPrintJob::~CWinNTPrintJob()
{

    if(_pszPrinterName){
        FreeADsStr(_pszPrinterName);
    }

    if(_pszPrinterPath){
        FreeADsStr(_pszPrinterPath);
    }

    _hprinter = NULL;

    delete _pExtMgr;            // created last, destroyed first
    delete _pDispMgr;
    delete _pPropertyCache;

    return;
}


HRESULT
CWinNTPrintJob::CreatePrintJob(
    LPTSTR pszPrinterPath,
    LONG   lJobId,
    DWORD dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    LPVOID *ppvoid
    )
{
    CWinNTPrintJob       *pCWinNTPrintJob =  NULL;
    HRESULT hr;
    TCHAR szJobName[MAX_LONG_LENGTH];
    POBJECTINFO pObjectInfo = NULL;
    TCHAR szUncPrinterName[MAX_PATH];

    //
    // Create the job object
    //

    hr = AllocatePrintJobObject(pszPrinterPath,
                                &pCWinNTPrintJob
                                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTPrintJob->_pDispMgr);

    //
    // convert the JobId that we have into a string that we move
    // into the Name field
    //

    _ltow(lJobId, szJobName, 10);

    hr = pCWinNTPrintJob->InitializeCoreObject(pszPrinterPath,
                                               szJobName,
                                               PRINTJOB_CLASS_NAME,
                                               PRINTJOB_SCHEMA_NAME,
                                               CLSID_WinNTPrintJob,
                                               dwObjectState);

    BAIL_ON_FAILURE(hr);



    hr = BuildObjectInfo(pszPrinterPath,
                         &pObjectInfo);

    BAIL_ON_FAILURE(hr);

    hr = PrinterNameFromObjectInfo(pObjectInfo,
                                   szUncPrinterName);
    BAIL_ON_FAILURE(hr);

    pCWinNTPrintJob->_Credentials = Credentials;
    hr = pCWinNTPrintJob->_Credentials.RefServer(
        pObjectInfo->ComponentArray[1]);
    BAIL_ON_FAILURE(hr);

    pCWinNTPrintJob->_pszPrinterName =
        AllocADsStr(szUncPrinterName);

    if(!(pCWinNTPrintJob->_pszPrinterName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pCWinNTPrintJob->_lJobId = lJobId;

    hr = SetLPTSTRPropertyInCache(pCWinNTPrintJob->_pPropertyCache,
                                  TEXT("HostPrintQueue"),
                                  pszPrinterPath,
                                  TRUE
                                  );


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                PRINTJOB_CLASS_NAME,
                (IADsPrintJob *) pCWinNTPrintJob,
                pCWinNTPrintJob->_pDispMgr,
                Credentials,
                &pCWinNTPrintJob->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTPrintJob->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        // Printjob objects have "" as their ADsPath. Just set the class for
        // iddentification purposes.
        pCWinNTPrintJob->_CompClasses[0] = L"PrintJob";

        hr = pCWinNTPrintJob->InitUmiObject(
                pCWinNTPrintJob->_Credentials,
                PrintJobClass,
                gdwJobTableSize,
                pCWinNTPrintJob->_pPropertyCache,
                (IUnknown *)(INonDelegatingUnknown *) pCWinNTPrintJob,
                pCWinNTPrintJob->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_ON_FAILURE(hr);

        FreeObjectInfo(pObjectInfo);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pCWinNTPrintJob->QueryInterface( riid,(void **)ppvoid);

    BAIL_ON_FAILURE(hr);

    pCWinNTPrintJob->Release();
    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);

error:

    FreeObjectInfo(pObjectInfo);
    delete pCWinNTPrintJob;
    RRETURN (hr);
}


HRESULT
CWinNTPrintJob::AllocatePrintJobObject(
    LPTSTR pszPrinterPath,
    CWinNTPrintJob ** ppPrintJob
    )
{
    CWinNTPrintJob FAR * pPrintJob = NULL;
    HRESULT hr = S_OK;

    pPrintJob = new CWinNTPrintJob();
    if (pPrintJob == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);


    pPrintJob->_pszPrinterPath =
        AllocADsStr(pszPrinterPath);

    if(!(pPrintJob->_pszPrinterPath)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pPrintJob->_pDispMgr = new CAggregatorDispMgr;

    if (pPrintJob->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pPrintJob->_pDispMgr,
                LIBID_ADs,
                IID_IADsPrintJob,
                (IADsPrintJob *)pPrintJob,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pPrintJob->_pDispMgr,
                LIBID_ADs,
                IID_IADsPrintJobOperations,
                (IADsPrintJobOperations *)pPrintJob,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pPrintJob->_pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pPrintJob,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             PrintJobClass,
             gdwJobTableSize,
             (CCoreADsObject *)pPrintJob,
             &(pPrintJob->_pPropertyCache)
             );
    BAIL_ON_FAILURE(hr);

    (pPrintJob->_pDispMgr)->RegisterPropertyCache(
                                    pPrintJob->_pPropertyCache
                                    );


    *ppPrintJob = pPrintJob;

    RRETURN(hr);

error:

    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete  pPrintJob;

    RRETURN_EXP_IF_ERR(hr);

}



/* IUnknown methods for printer object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTPrintJob::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTPrintJob::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTPrintJob::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTPrintJob::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsPrintJob *)this;
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsPrintJob *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsPrintJob FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintJob))
    {
        *ppvObj = (IADsPrintJob FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintJobOperations))
    {
        *ppvObj = (IADsPrintJobOperations FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTPrintJob::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPrintJob) ||
        IsEqualIID(riid, IID_IADsPrintJobOperations) |\
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to set the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11/08/95    RamV  Created
//              part of code appropriated from NetOle project
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTPrintJob::SetInfo(THIS)
{
    BOOL fStatus = FALSE;
    LPJOB_INFO_2 lpJobInfo2 = NULL;
    HRESULT hr;

    //
    // do a getinfo to refresh those properties that arent being set
    //
    hr = GetJobInfo(2,
                    (LPBYTE*)&lpJobInfo2,
                    _pszPrinterName,
                    _lJobId);

    BAIL_IF_ERROR(hr);

    hr = MarshallAndSet(lpJobInfo2,
                        _pszPrinterName,
                        _lJobId);
    BAIL_IF_ERROR(hr);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:
    if(lpJobInfo2){
        FreeADsMem((LPBYTE)lpJobInfo2);
    }
    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CWinNTPrintJob::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    LPJOB_INFO_1 lpJobInfo1 = NULL;
    LPJOB_INFO_2 lpJobInfo2 = NULL;
    HRESULT hr = S_OK;


    switch (dwApiLevel) {
    case 1:
        hr = GetJobInfo(dwApiLevel,
                        (LPBYTE*)&lpJobInfo1,
                        _pszPrinterName,
                        _lJobId
                        );

        BAIL_IF_ERROR(hr);

        hr = UnMarshallLevel1(lpJobInfo1,
                              fExplicit
                              );
        BAIL_IF_ERROR(hr);
        break;

    case 2:
        hr = GetJobInfo(dwApiLevel,
                        (LPBYTE *)&lpJobInfo2,
                        _pszPrinterName,
                        _lJobId
                        );

        BAIL_IF_ERROR(hr);

        hr = UnMarshallLevel2(lpJobInfo2,
                              fExplicit
                              );
        BAIL_IF_ERROR(hr);
        break;

    default:
        hr = E_FAIL;
        break;

    }

cleanup:

    if (lpJobInfo1) {
        FreeADsMem(lpJobInfo1);
    }


    if (lpJobInfo2) {
        FreeADsMem(lpJobInfo2);
    }

    RRETURN_EXP_IF_ERR(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetInfo
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to get information from the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11/08/95    RamV  Created
//              part of code appropriated from NetOle project
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTPrintJob::GetInfo(THIS)
{
    RRETURN(GetInfo(2, TRUE));
}

STDMETHODIMP
CWinNTPrintJob::ImplicitGetInfo(THIS)
{
    RRETURN(GetInfo(2, FALSE));
}

STDMETHODIMP
CWinNTPrintJob::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, Description);
}

STDMETHODIMP
CWinNTPrintJob::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintJob *)this, Description);
}


STDMETHODIMP
CWinNTPrintJob::get_HostPrintQueue(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, HostPrintQueue);
}


STDMETHODIMP
CWinNTPrintJob::get_User(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, User);
}

STDMETHODIMP
CWinNTPrintJob::get_UserPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTPrintJob::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintJob *)this, Priority);
}

STDMETHODIMP
CWinNTPrintJob::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Priority);
}


STDMETHODIMP
CWinNTPrintJob::get_TimeSubmitted(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, TimeSubmitted);
}


STDMETHODIMP
CWinNTPrintJob::get_TotalPages(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, TotalPages);
}


STDMETHODIMP
CWinNTPrintJob::put_StartTime(THIS_ DATE daStartTime)
{
    PUT_PROPERTY_DATE((IADsPrintJob *)this, StartTime);
}

STDMETHODIMP
CWinNTPrintJob::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, StartTime);
}

STDMETHODIMP
CWinNTPrintJob::put_UntilTime(THIS_ DATE daUntilTime)
{
    PUT_PROPERTY_DATE((IADsPrintJob *)this, UntilTime);
}

STDMETHODIMP
CWinNTPrintJob::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintJob *)this, UntilTime);
}


STDMETHODIMP
CWinNTPrintJob::get_Size(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Size);
}

STDMETHODIMP
CWinNTPrintJob::put_Notify(THIS_ BSTR bstrNotify)
{
    PUT_PROPERTY_BSTR((IADsPrintJob *)this, Notify);
}

STDMETHODIMP
CWinNTPrintJob::get_Notify(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintJob *)this, Notify);
}

STDMETHODIMP
CWinNTPrintJob::put_NotifyPath(THIS_ BSTR bstrNotify)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTPrintJob::get_NotifyPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


STDMETHODIMP
CWinNTPrintJob::put_Position(THIS_ LONG lPosition)
{
    PUT_PROPERTY_LONG((IADsPrintJob *)this, Position);
}

STDMETHODIMP
CWinNTPrintJob::get_Position(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, Position);
}

STDMETHODIMP
CWinNTPrintJob::get_PagesPrinted(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, PagesPrinted);
}

STDMETHODIMP
CWinNTPrintJob::get_TimeElapsed(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintJob *)this, TimeElapsed);
}



//+------------------------------------------------------------------------
//
//  Function: CWinNTPrintJob::Pause
//
//  Synopsis:   Binds to real printer as specified in _lpszPrinterName and attempts
//              to pause this job.
//
//  Arguments:  none
//
//  Returns:    HRESULT.
//
//  Modifies:   nothing
//
//  History:    11-07-95   RamV  Created
//
//---------------------------------------------------------------------------


STDMETHODIMP
CWinNTPrintJob::Pause(THIS)
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;


    //
    // we need to open the printer with the right printer
    // defaults in order to perform the operations that we
    // have here
    //

    fStatus = OpenPrinter((LPTSTR)_pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    fStatus = SetJob (hPrinter,
                      _lJobId,
                      0,
                      NULL,
                      JOB_CONTROL_PAUSE
                      );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

cleanup:
    fStatus = ClosePrinter(hPrinter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTPrintJob::Resume(THIS)
{
    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;

    //
    // we need to open the printer with the right printer
    // defaults in order to perform the operations that we
    // have here
    //

    fStatus = OpenPrinter((LPTSTR)_pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        hr =HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    fStatus = SetJob (hPrinter,
                      _lJobId,
                      0,
                      NULL,
                      JOB_CONTROL_RESUME
                      );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;

    }

cleanup:
    fStatus = ClosePrinter(hPrinter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTPrintJob::Remove(THIS)
{
    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;

    fStatus = OpenPrinter((LPTSTR)_pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }


    //
    // se JOB_CONTROL_DELETE instead of JOB_CONTROL_CANCEL as DELETE works
    // even when a print job has been restarted while CANCLE won't
    //

    fStatus = SetJob (hPrinter,
                      _lJobId,
                      0,
                      NULL,
                      JOB_CONTROL_DELETE
                      );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;

    }

cleanup:
    fStatus = ClosePrinter(hPrinter);
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTPrintJob::get_Status(THIS_ long FAR* retval)
{
    HRESULT hr =S_OK;
    LPJOB_INFO_1 lpJobInfo1 = NULL;
    BOOL found;
    DWORD dwStatus;

    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = GetJobInfo(1,
                    (LPBYTE*)&lpJobInfo1,
                    _pszPrinterName,
                    _lJobId);

    BAIL_IF_ERROR(hr);

    //
    // instead of a conversion routine, just return the WinNT
    // Status code
    //

    *retval = lpJobInfo1->Status;

cleanup:
    if(lpJobInfo1){
        FreeADsMem((LPBYTE)lpJobInfo1);
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cgroup.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroup.cxx
//
//  Contents:  Group object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop

//  Class CWinNTGroup -> GlobalGroup DS class

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTGroup)
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTGroup)
DEFINE_IADs_TempImplementation(CWinNTGroup)
DEFINE_IADs_PutGetImplementation(CWinNTGroup,GroupClass,gdwGroupTableSize)
DEFINE_IADsPropertyList_Implementation(CWinNTGroup, GroupClass,gdwGroupTableSize)

CWinNTGroup::CWinNTGroup():
        _pDispMgr(NULL),
        _pExtMgr(NULL),
        _pPropertyCache(NULL),
        _ParentType(0),
        _DomainName(NULL),
        _ServerName(NULL)
{
    ENLIST_TRACKING(CWinNTGroup);
}


HRESULT
CWinNTGroup::CreateGroup(
    BSTR Parent,
    ULONG ParentType,
    BSTR DomainName,
    BSTR ServerName,
    BSTR GroupName,
    ULONG GroupType,
    DWORD dwObjectState,
    PSID pSid,          // OPTIONAL
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTGroup FAR * pGroup = NULL;
    HRESULT hr = S_OK;

    BOOL fAccountSid = TRUE;

    hr = AllocateGroupObject(&pGroup);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pGroup->_pDispMgr);


    hr = pGroup->InitializeCoreObject(
                Parent,
                GroupName,
                GROUP_CLASS_NAME,
                GROUP_SCHEMA_NAME,
                CLSID_WinNTGroup,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(DomainName, &pGroup->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(ServerName, &pGroup->_ServerName);
    BAIL_ON_FAILURE(hr);

    pGroup->_ParentType = ParentType;
    pGroup->_GroupType = GroupType;

    hr = SetDWORDPropertyInCache(
         pGroup->_pPropertyCache,
         TEXT("groupType"),
         GroupType,
         TRUE           // fExplicit
         );

    BAIL_ON_FAILURE(hr);



    //
    // Try to determine if object corresponds to a account
    // domain
    //
    if (pSid) {

        //
        // A domain account sid has:
        //   (1) a identifier authority of SECURITY_NT_AUTHORITY
        //   (2) at least one subauth identifier
        //   (3) the first subauth identifier is SECURITY_NT_NON_UNIQUE
        //

        PSID_IDENTIFIER_AUTHORITY pSidIdentAuth = NULL;
        SID_IDENTIFIER_AUTHORITY NtAuthIdentAuth = SECURITY_NT_AUTHORITY;

        PDWORD pdwSidSubAuth = NULL;

        fAccountSid = FALSE;

        pSidIdentAuth = GetSidIdentifierAuthority(pSid);
        ADsAssert(pSidIdentAuth);

        if (memcmp(pSidIdentAuth, &NtAuthIdentAuth, sizeof(SID_IDENTIFIER_AUTHORITY)) == 0) {

            if (GetSidSubAuthorityCount(pSid) > 0) {

                pdwSidSubAuth = GetSidSubAuthority(pSid, 0);
                ADsAssert(pdwSidSubAuth);

                if (*pdwSidSubAuth == SECURITY_NT_NON_UNIQUE) {
                    fAccountSid = TRUE;
                }
            }
        }
    }

    pGroup->_Credentials = Credentials;
    hr = pGroup->_Credentials.Ref(ServerName, DomainName, ParentType);
    if (fAccountSid) {
        //
        // We permit this to fail if we can determine it is not a account
        // sid, since we won't be able to ref credentials on a non-existent
        // pseudo-domain like NT AUTHORITY (e.g., the well-known sids)
        //
        BAIL_ON_FAILURE(hr);
    }

    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                GROUP_CLASS_NAME,
                (IADsGroup *) pGroup,
                pGroup->_pDispMgr,
                Credentials,
                &pGroup->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pGroup->_pExtMgr);

    //
    // Prepopulate the object
    //
    hr = pGroup->Prepopulate(TRUE,
                            pSid);
    BAIL_ON_FAILURE(hr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pGroup->_dwNumComponents) {
            pGroup->_CompClasses[0] = L"Domain";
            pGroup->_CompClasses[1] = L"Computer";
            pGroup->_CompClasses[2] = L"Group";
        }
        else if(2 == pGroup->_dwNumComponents) {
            if(NULL == DomainName) {
            // workstation services not started. See getobj.cxx.
                pGroup->_CompClasses[0] = L"Computer";
                pGroup->_CompClasses[1] = L"Group";
            }
            else if(NULL == ServerName) {
                pGroup->_CompClasses[0] = L"Domain";
                pGroup->_CompClasses[1] = L"Group";
            }
            else
                BAIL_ON_FAILURE(hr = UMI_E_FAIL);
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pGroup->InitUmiObject(
                pGroup->_Credentials,
                GroupClass,
                gdwGroupTableSize, 
                pGroup->_pPropertyCache,
                (IUnknown *) (INonDelegatingUnknown *) pGroup,
                pGroup->_pExtMgr,
                IID_IUnknown,
                ppvObj
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pGroup->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGroup->Release();

    RRETURN(hr);

error:
    delete pGroup;

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CWinNTGroup::CreateGroup(
    BSTR Parent,
    ULONG ParentType,
    BSTR DomainName,
    BSTR ServerName,
    BSTR GroupName,
    ULONG GroupType,
    DWORD dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;

    hr = CWinNTGroup::CreateGroup(
                              Parent,
                              ParentType,
                              DomainName,
                              ServerName,
                              GroupName,
                              GroupType,
                              dwObjectState,
                              NULL,
                              riid,
                              Credentials,
                              ppvObj
                              );

    RRETURN_EXP_IF_ERR(hr);
}

CWinNTGroup::~CWinNTGroup( )
{
    ADsFreeString(_DomainName);
    ADsFreeString(_ServerName);

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTGroup::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTGroup::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTGroup::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTGroup::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsGroup))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsGroup FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(iid, ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTGroup::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsGroup) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CWinNTGroup::SetInfo(THIS)
{
    HRESULT hr;
    NET_API_STATUS nasStatus;
    WCHAR szHostServerName[MAX_PATH];
    LPBYTE lpBuffer = NULL;
    DWORD dwGroupType = _GroupType;


    //
    // We need to see if the cache has changed a value for
    // groupType and use that info down the line.
    //

    hr = GetDWORDPropertyFromCache(
         _pPropertyCache,
         TEXT("groupType"),
         &dwGroupType
         );

    if (SUCCEEDED(hr)) {
        //
        // Verify the value
        //
        if ((dwGroupType != WINNT_GROUP_LOCAL)
            && (dwGroupType != WINNT_GROUP_GLOBAL)) {

            //
            // This is bad value so we need to BAIL
            //
            hr = E_ADS_BAD_PARAMETER;
        }
        else {
            if (GetObjectState() == ADS_OBJECT_UNBOUND)
                _GroupType = dwGroupType;
            else
               if (_GroupType != dwGroupType) {
                   hr = E_ADS_BAD_PARAMETER;
               }
        }

    } else {

        dwGroupType = _GroupType;
        hr = S_OK;
    }

    BAIL_ON_FAILURE(hr);


    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                 _DomainName,
                 szHostServerName,
                 _Credentials.GetFlags()
                 );
    } else {

        hr = MakeUncName(
                 _ServerName,
                 szHostServerName
                 );
    }

    BAIL_ON_FAILURE(hr);


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        if (dwGroupType == WINNT_GROUP_GLOBAL) {

            if (_ParentType == WINNT_DOMAIN_ID) {

                hr = WinNTCreateGlobalGroup(
                            szHostServerName + 2,
                            _Name
                            );
                BAIL_ON_FAILURE(hr);


            }else {

                hr = WinNTCreateGlobalGroup(
                            _ServerName,
                            _Name
                            );
                BAIL_ON_FAILURE(hr);

            }

        }
        else {

            //
            // Group type has to be local
            //

            hr = WinNTCreateLocalGroup(
                     szHostServerName + 2,
                     _Name
                     );

            BAIL_ON_FAILURE(hr);

        }

         SetObjectState(ADS_OBJECT_BOUND);

    } // if Object not bound

    if (dwGroupType == WINNT_GROUP_GLOBAL) {

        nasStatus = NetGroupGetInfo(
                        szHostServerName,
                        _Name,
                        1,
                        &lpBuffer
                        );

    } else {

        nasStatus = NetLocalGroupGetInfo(
                        szHostServerName,
                        _Name,
                        1,
                        &lpBuffer
                        );

    }

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    hr = Marshall_Set_Level1(
             szHostServerName,
             TRUE,
             lpBuffer
             );
    BAIL_ON_FAILURE(hr);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

    //
    // objectSid not writable
    //

error:
    if (lpBuffer) {
        NetApiBufferFree(lpBuffer);
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTGroup::GetInfo(THIS)
{
    HRESULT hr;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

    RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);

    }


    _pPropertyCache->flushpropcache();

    //
    // Need to add the group type attribute here.
    //
    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("groupType"),
             _GroupType,
             TRUE           // fExplicit
             );
    //
    // GROUP_INFO
    //

    hr = GetInfo(1, TRUE);

    BAIL_ON_FAILURE(hr);
    //
    // objectSid
    //

    hr = GetInfo(20, TRUE);

error :

    RRETURN(hr);

}

STDMETHODIMP
CWinNTGroup::ImplicitGetInfo(THIS)
{
    HRESULT hr;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

    RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);

    }

    //
    // Need to add the group type attribute here.
    //
    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("groupType"),
             _GroupType,
             FALSE           // fExplicit
             );
    //
    // GROUP_INFO
    //

    hr = GetInfo(1, FALSE);

    BAIL_ON_FAILURE(hr);
    //
    // objectSid
    //

    hr = GetInfo(20, FALSE);

error :

    RRETURN(hr);

}

HRESULT
CWinNTGroup::AllocateGroupObject(
    CWinNTGroup ** ppGroup
    )
{
    CWinNTGroup FAR * pGroup = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;


    pGroup = new CWinNTGroup();
    if (pGroup == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsGroup,
                (IADsGroup *)pGroup,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pGroup,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             GroupClass,
             gdwGroupTableSize,
             (CCoreADsObject *)pGroup,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );

    pGroup->_pPropertyCache = pPropertyCache;
    pGroup->_pDispMgr = pDispMgr;
    *ppGroup = pGroup;

    RRETURN(hr);

error:

    delete  pPropertyCache;
    delete  pDispMgr;
    delete  pGroup;

    RRETURN(hr);

}


//
// For current implementation in clocgroup:
// If this function is called as a public function (ie. by another
// modual/class), fExplicit must be FALSE since the cache is NOT
// flushed in this function.
//
// External functions should ONLY call GetInfo(no param) for explicit
// GetInfo. This will flush the cache properly.
//

STDMETHODIMP
CWinNTGroup::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{

    HRESULT hr=E_FAIL;

    switch (dwApiLevel) {

    case 1:

        hr = GetStandardInfo(
                dwApiLevel,
                fExplicit
                );
        RRETURN_EXP_IF_ERR(hr);

    case 20:

        hr = GetSidInfo(
                fExplicit
                );
        RRETURN_EXP_IF_ERR(hr);

    default:

        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }
}


HRESULT
CWinNTGroup::GetStandardInfo(
    DWORD dwApiLevel,
    BOOL fExplicit
    )
{

    NET_API_STATUS nasStatus;
    LPBYTE lpBuffer = NULL;
    HRESULT hr;
    WCHAR szHostServerName[MAX_PATH];



    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                        _DomainName,
                        szHostServerName,
                        _Credentials.GetFlags()
                        );
        BAIL_ON_FAILURE(hr);
    }else {

        hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
        BAIL_ON_FAILURE(hr);

    }

    //
    // Since the object is bound, the groupType has to be
    // _GroupType and cannot change.
    //

    if (_GroupType == WINNT_GROUP_GLOBAL) {

        nasStatus = NetGroupGetInfo(
                        szHostServerName,
                        _Name,
                        dwApiLevel,
                        &lpBuffer
                        );

    } else {

        nasStatus = NetLocalGroupGetInfo(
                        szHostServerName,
                        _Name,
                        dwApiLevel,
                        &lpBuffer
                        );

    }

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    hr = UnMarshall(
            lpBuffer,
            dwApiLevel,
            fExplicit
            );
    BAIL_ON_FAILURE(hr);

error:
    if (lpBuffer) {
        NetApiBufferFree(lpBuffer);
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTGroup::UnMarshall(
    LPBYTE lpBuffer,
    DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    HRESULT hr;
    ADsAssert(lpBuffer);
    switch (dwApiLevel) {
    case 1:
        hr = UnMarshall_Level1(fExplicit, lpBuffer);
        break;

    default:
        hr = E_FAIL;

    }
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTGroup::UnMarshall_Level1(BOOL fExplicit, LPBYTE pBuffer)
{
    BSTR bstrData = NULL;
    LPGROUP_INFO_1 pGroupInfo1 = NULL;
    LPLOCALGROUP_INFO_1 pLocalGroupInfo1 = NULL;
    HRESULT hr = S_OK;

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    if (_GroupType == WINNT_GROUP_GLOBAL) {

        pGroupInfo1 = (LPGROUP_INFO_1)pBuffer;

        hr = SetLPTSTRPropertyInCache(
                 _pPropertyCache,
                 TEXT("Description"),
                 pGroupInfo1->grpi1_comment,
                 fExplicit
                 );
    }
    else {

        pLocalGroupInfo1 = (LPLOCALGROUP_INFO_1) pBuffer;

        hr = SetLPTSTRPropertyInCache(
                 _pPropertyCache,
                 TEXT("Description"),
                 pLocalGroupInfo1->lgrpi1_comment,
                 fExplicit
                 );
    }


    RRETURN(hr);
}


HRESULT
CWinNTGroup::Prepopulate(
    BOOL fExplicit,
    PSID pSid               // OPTIONAL
    )
{
    HRESULT hr = S_OK;

    DWORD dwErr = 0;
    DWORD dwSidLength = 0;
    
    if (pSid) {

        //
        // On NT4 for some reason GetLengthSID does not set lasterror to 0
        //
        SetLastError(NO_ERROR);

        dwSidLength = GetLengthSid((PSID) pSid);

        //
        // This is an extra check to make sure that we have the
        // correct length.
        //
        dwErr = GetLastError();
        if (dwErr != NO_ERROR) {
            hr = HRESULT_FROM_WIN32(dwErr);
            BAIL_ON_FAILURE(hr);
        }
    
        hr = SetOctetPropertyInCache(
                    _pPropertyCache,
                    TEXT("objectSid"),
                    (PBYTE) pSid,
                    dwSidLength,
                    TRUE
                    );
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}


HRESULT
CWinNTGroup::Marshall_Set_Level1(
    LPWSTR szHostServerName,
    BOOL fExplicit,
    LPBYTE pBuffer
    )
{
    LPGROUP_INFO_1 pGroupInfo1 = NULL;
    LPLOCALGROUP_INFO_1 pLocalGroupInfo1 = NULL;
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;
    LPWSTR  pszDescription = NULL;

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );

    if(SUCCEEDED(hr)) {

        if (_GroupType == WINNT_GROUP_GLOBAL) {

            // hr = UM_GET_BSTR_PROPERTY(_pGenInfo,Description, bstrData);

            //
            // This should in reality call a virtual function of a derived
            // class,  beta fix!
            //

            pGroupInfo1 = (LPGROUP_INFO_1)pBuffer;
            pGroupInfo1->grpi1_comment = pszDescription;

            //
            // Now perform the Set call.
            //

            nasStatus = NetGroupSetInfo(
                            szHostServerName,
                            _Name,
                            1,
                            (LPBYTE)pGroupInfo1,
                            &dwParmErr
                            );

        }
        else {

            pLocalGroupInfo1 = (LPLOCALGROUP_INFO_1)pBuffer;
            pLocalGroupInfo1->lgrpi1_comment = pszDescription;

            nasStatus = NetLocalGroupSetInfo(
                            szHostServerName,
                            _Name,
                            1,
                            (LPBYTE)pLocalGroupInfo1,
                            &dwParmErr
                            );

        }

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

    }else {

        //
        // This is because there is no data to marshall
        //

        hr = S_OK;

    }

error:

    if (pszDescription) {
        FreeADsStr(pszDescription);
    }

    RRETURN(hr);
}

HRESULT
CWinNTGroup::Marshall_Create_Level1(
    LPWSTR szHostServerName,
    LPGROUP_INFO_1 pGroupInfo1
    )
{

    //
    // This routine is not called from anywhere ???
    //
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus = ERROR_INVALID_DATA;
    DWORD dwParmErr;

    if (_GroupType == WINNT_GROUP_GLOBAL) {

        pGroupInfo1->grpi1_name = _Name;
        pGroupInfo1->grpi1_comment = NULL;
        nasStatus = NetGroupAdd(
                        szHostServerName,
                        1,
                        (LPBYTE)pGroupInfo1,
                        &dwParmErr
                        );
    }
    else {

        ADsAssert(!"Group type is bad internally!");

        /*
        pLocalGroupInfo1->lgrp1_name = _Name;
        pLocalGroupInfo1->grp1_comment = NULL;
        nasStatus = NetLocalGroupAdd(
                        szHostServerName,
                        1,
                        (LPBYTE)pLocalGroupInfo1,
                        &dwParmErr
                        );
                        */


    }

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
CWinNTGroup::GetSidInfo(
    IN BOOL fExplicit
    )
{
    HRESULT hr = E_FAIL;
    WCHAR szHostServerName[MAX_PATH];

    //
    // Get Server Name
    //

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {

       hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
       BAIL_ON_FAILURE(hr);
    }

    //
    // Get Sid of this group and store in cache if fExplicit.
    //

    hr = GetSidIntoCache(
            szHostServerName,
            _Name,
            _pPropertyCache,
            fExplicit
            );
    BAIL_ON_FAILURE(hr);


error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cpgi.cxx ===
/*++

  Copyright (c) 1995  Microsoft Corporation

  Module Name:

  cprinter.cxx

  Abstract:
  Contains methods for PrintQueue object, GeneralInfo property set
  and Operation property set for the Print Queue object for the Windows NT
  provider

  Author:

  Ram Viswanathan (ramv) 11-09-95

  Revision History:

--*/

#include "winnt.hxx"
#pragma hdrstop

//
//  CWinNTPrintQueue
//

STDMETHODIMP
CWinNTPrintQueue::put_Model(THIS_ BSTR bstrModel)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CWinNTPrintQueue::get_Model(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Model);
}

STDMETHODIMP
CWinNTPrintQueue::put_Datatype(THIS_ BSTR bstrDatatype)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Datatype);
}

STDMETHODIMP
CWinNTPrintQueue::get_Datatype(THIS_ BSTR *retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Datatype);
}

STDMETHODIMP
CWinNTPrintQueue::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}

STDMETHODIMP
CWinNTPrintQueue::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Description);
}


STDMETHODIMP CWinNTPrintQueue::put_Location(THIS_ BSTR bstrLocation)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}

STDMETHODIMP CWinNTPrintQueue::get_Location(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, Location);
}


STDMETHODIMP
CWinNTPrintQueue::put_Priority(THIS_ LONG lPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CWinNTPrintQueue::get_Priority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, Priority);
}

STDMETHODIMP
CWinNTPrintQueue::put_StartTime(THIS_ DATE daStartTime)
{
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CWinNTPrintQueue::get_StartTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, StartTime);
}

STDMETHODIMP
CWinNTPrintQueue::put_UntilTime(THIS_ DATE daUntilTime)
{
    PUT_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CWinNTPrintQueue::get_UntilTime(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsPrintQueue *)this, UntilTime);
}

STDMETHODIMP
CWinNTPrintQueue::put_DefaultJobPriority(THIS_ LONG lDefaultJobPriority)
{
    PUT_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CWinNTPrintQueue::get_DefaultJobPriority(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsPrintQueue *)this, DefaultJobPriority);
}

STDMETHODIMP
CWinNTPrintQueue::put_BannerPage(THIS_ BSTR bstrBannerPage)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CWinNTPrintQueue::get_BannerPage(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, BannerPage);
}

STDMETHODIMP
CWinNTPrintQueue::get_PrinterPath(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    hr = ADsAllocString(_pszPrinterName, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTPrintQueue::put_PrinterPath(THIS_ BSTR bstrPrinterPath)
{
    //
    // Cannot change this in Windows NT!
    //
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTPrintQueue::get_PrintProcessor(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsPrintQueue *)this, PrintProcessor);
}

STDMETHODIMP
CWinNTPrintQueue::put_PrintProcessor(THIS_ BSTR bstrPrintProcessor)
{
    PUT_PROPERTY_BSTR((IADsPrintQueue *)this, PrintProcessor);
}

STDMETHODIMP
CWinNTPrintQueue::get_PrintDevices(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsPrintQueue *)this, PrintDevices);
}

STDMETHODIMP
CWinNTPrintQueue::put_PrintDevices(THIS_ VARIANT vPrintDevices)
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, PrintDevices);
}

STDMETHODIMP
CWinNTPrintQueue::get_NetAddresses(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses);
}

STDMETHODIMP
CWinNTPrintQueue::put_NetAddresses(THIS_ VARIANT vNetAddresses)
{
    PUT_PROPERTY_VARIANT((IADsPrintQueue *)this, NetAddresses);
}

//
// Class CWinNTPrintQueue
//

/* IADsFSPrintQueueOperation methods */

STDMETHODIMP
CWinNTPrintQueue::PrintJobs(
    THIS_ IADsCollection * FAR* ppCollection
    )
{
    //
    // The job collection object is created and it is passed the printer
    // name. It uses this to create a printer object
    //

    HRESULT hr = S_OK;
    CWinNTPrintJobsCollection * pJobsCollection = NULL;


    hr = CWinNTPrintJobsCollection::Create(_ADsPath,
                                           _Credentials,
                                           &pJobsCollection);

    BAIL_IF_ERROR(hr);

    hr = pJobsCollection->QueryInterface(IID_IADsCollection,
                                         (void **) ppCollection);

    BAIL_IF_ERROR(hr);

    pJobsCollection->Release();

cleanup:

    if(FAILED(hr)){
        delete pJobsCollection;
    }

    RRETURN_EXP_IF_ERR(hr);
}




//+------------------------------------------------------------------------
//
//  Function: CWinNTPrintQueue::Pause
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName
//   and attempts to pause the real printer.
//
//  Arguments:  none
//
//  Returns:    HRESULT.
//
//  Modifies:   nothing
//
//  History:    11-07-95   RamV  Created
//  Appropriated from Old NetOle Code.
//
//---------------------------------------------------------------------------

STDMETHODIMP
CWinNTPrintQueue::Pause(THIS)
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;


    fStatus = OpenPrinter(
                    (LPTSTR)_pszPrinterName,
                    &hPrinter,
                    &PrinterDefaults);

    if (!fStatus) {
        goto error;
    }

    fStatus = SetPrinter(hPrinter,
                         0,
                         NULL,
                         PRINTER_CONTROL_PAUSE);
    if (!fStatus) {
        goto error;


    }


    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTPrintQueue::Resume
//
//  Synopsis:   Binds to real printer as specified in _bstrPrinterName and
//              attempts to resume the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV  Created
//              Appropriated from old NetOle Project
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTPrintQueue::Resume(THIS)
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;


    fStatus = OpenPrinter(
                    (LPTSTR)_pszPrinterName,
                    &hPrinter,
                    &PrinterDefaults);

    if (!fStatus) {
        goto error;
    }


    fStatus = SetPrinter(hPrinter,
                         0,
                         NULL,
                         PRINTER_CONTROL_RESUME);
    if (!fStatus) {
        goto error;
    }

    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN_EXP_IF_ERR(hr);

}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTPrintQueue::Purge
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to purge the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-07-95  RamV   Created
//              Appropriated from old NetOle Code
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTPrintQueue::Purge(THIS)
{
    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    PRINTER_INFO_2 PrinterInfo2;
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;


    fStatus = OpenPrinter(
                    (LPTSTR)_pszPrinterName,
                    &hPrinter,
                    &PrinterDefaults);

    if (!fStatus) {
        goto error;
    }

    fStatus = SetPrinter(hPrinter,
                         0,
                         NULL,
                         PRINTER_CONTROL_PURGE);
    if (!fStatus) {
        goto error;

    }

    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CWinNTPrintQueue::get_Status(THIS_ long FAR* retval)
{
    HRESULT hr =S_OK;
    LPPRINTER_INFO_2 lpPrinterInfo2 = NULL;
    DWORD dwStatus;
    BOOL found;

    //
    // We return the WinNT Status Code as the ADS status code
    //

    hr = GetPrinterInfo(
                &lpPrinterInfo2,
                _pszPrinterName
                );

    BAIL_IF_ERROR(hr);

    *retval = lpPrinterInfo2->Status;

cleanup:
    if(lpPrinterInfo2){
        FreeADsMem((LPBYTE)lpPrinterInfo2);
    }
    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cprinter.cxx ===
/*++

  Copyright (c) 1995  Microsoft Corporation

  Module Name:

  cprinter.cxx

  Abstract:
  Contains methods for PrintQueue object, GeneralInfo property set
  and Operation property set for the Print Queue object for the Windows NT
  provider

  Author:

  Ram Viswanathan (ramv) 11-09-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop

//
// Class CWinNTPrintQueue Methods
//

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTPrintQueue)
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTPrintQueue)
DEFINE_IADs_TempImplementation(CWinNTPrintQueue);
DEFINE_IADs_PutGetImplementation(CWinNTPrintQueue,PrintQueueClass,gdwPrinterTableSize);
DEFINE_IADsPropertyList_Implementation(CWinNTPrintQueue, PrintQueueClass,gdwPrinterTableSize)


CWinNTPrintQueue::CWinNTPrintQueue()
{
    _pszPrinterName = NULL;
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pPropertyCache = NULL;
    ENLIST_TRACKING(CWinNTPrintQueue);
    return;

}

CWinNTPrintQueue::~CWinNTPrintQueue()
{
    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;

    if(_pszPrinterName){
        FreeADsStr(_pszPrinterName);
    }
    return;
}

HRESULT
CWinNTPrintQueue:: CreatePrintQueue(
    LPTSTR pszADsParent,
    DWORD  dwParentId,
    LPTSTR pszDomainName,
    LPTSTR pszServerName,
    LPTSTR pszPrinterName,
    DWORD  dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    LPVOID * ppvoid
    )

{

    CWinNTPrintQueue       *pPrintQueue =  NULL;
    HRESULT hr;

    //
    // Create the printer object
    //

    hr = AllocatePrintQueueObject(pszServerName,
                                  pszPrinterName,
                                  &pPrintQueue
                                  );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pPrintQueue->_pDispMgr);


    //
    // initialize the core object
    //

    hr = pPrintQueue->InitializeCoreObject(pszADsParent,
                                           pszPrinterName,
                                           PRINTER_CLASS_NAME,
                                           PRINTER_SCHEMA_NAME,
                                           CLSID_WinNTPrintQueue,
                                           dwObjectState);
    BAIL_ON_FAILURE(hr);


    pPrintQueue->_Credentials = Credentials;
    hr = pPrintQueue->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                PRINTER_CLASS_NAME,
                (IADsPrintQueue *) pPrintQueue,
                pPrintQueue->_pDispMgr,
                Credentials,
                &pPrintQueue->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pPrintQueue->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pPrintQueue->_dwNumComponents) {
            pPrintQueue->_CompClasses[0] = L"Domain";
            pPrintQueue->_CompClasses[1] = L"Computer";
            pPrintQueue->_CompClasses[2] = L"PrintQueue";
        }
        else if(2 == pPrintQueue->_dwNumComponents) {
        // no workstation services
            pPrintQueue->_CompClasses[0] = L"Computer";
            pPrintQueue->_CompClasses[1] = L"PrintQueue";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pPrintQueue->InitUmiObject(
                pPrintQueue->_Credentials,
                PrintQueueClass,
                gdwPrinterTableSize,
                pPrintQueue->_pPropertyCache,
                (IUnknown *)(INonDelegatingUnknown *) pPrintQueue,
                pPrintQueue->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pPrintQueue->QueryInterface(riid, (void **)ppvoid);
    BAIL_ON_FAILURE(hr);

    pPrintQueue->Release();

    RRETURN(hr);

error:
    delete pPrintQueue;
    RRETURN_EXP_IF_ERR(hr);
}

/* IUnknown methods for printer object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTPrintQueue::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTPrintQueue::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTPrintQueue::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTPrintQueue::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj)
    {
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsPrintQueue *)this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsPrintQueue *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueue))
    {
        *ppvObj = (IADsPrintQueue FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPrintQueueOperations))
    {
      *ppvObj = (IADsPrintQueueOperations FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTPrintQueue::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPrintQueue) ||
        IsEqualIID(riid, IID_IADsPrintQueueOperations) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to set the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11/08/95    RamV  Created
//              part of code appropriated from NetOle project
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTPrintQueue::SetInfo(THIS)
{

    BOOL fStatus = FALSE;
    LPPRINTER_INFO_2 lpPrinterInfo2 = NULL;
    BOOL fPrinterAdded = FALSE;
    POBJECTINFO pObjectInfo = NULL;

#if (!defined(BUILD_FOR_NT40))

    LPPRINTER_INFO_7 lpPrinterInfo7 = NULL;
#endif

    HRESULT hr;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = WinNTAddPrinter();
        BAIL_IF_ERROR(hr);

        SetObjectState(ADS_OBJECT_BOUND);
        fPrinterAdded = TRUE;
    }

    //
    // first do a getinfo to get properties that werent changed.
    //

    hr = GetPrinterInfo(&lpPrinterInfo2, _pszPrinterName);

    BAIL_IF_ERROR(hr);

    hr = MarshallAndSet(lpPrinterInfo2);

    BAIL_IF_ERROR(hr);


#if (!defined(BUILD_FOR_NT40))
    hr = GetPrinterInfo7(&lpPrinterInfo7, _pszPrinterName);

    if (SUCCEEDED(hr)) {
        MarshallAndSet(lpPrinterInfo7);
    }
    else if(hr == HRESULT_FROM_WIN32(ERROR_INVALID_LEVEL))
    // Level 7 is not supported on NT4. So, ignore this error.
        hr = S_OK;

#endif

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:


    //
    // If we added a printer and hr is set, we should delete it now
    // as the SetInfo failed in subsequent operations.
    //
    if (FAILED(hr) && fPrinterAdded) {

        //
        // Build ObjectInfo first
        //
        BuildObjectInfo(
             _ADsPath,
             &pObjectInfo
             );
        //
        // Call delete printer only if the pObjectInfo is valid
        // We cannot do anything in the other case.
        //
        if (pObjectInfo) {
            WinNTDeletePrinter(pObjectInfo);
            FreeObjectInfo(pObjectInfo);
        }
    }

    if(lpPrinterInfo2){
        FreeADsMem((LPBYTE)lpPrinterInfo2);
    }

#if (!defined(BUILD_FOR_NT40))

    if (lpPrinterInfo7) {
       FreeADsMem((LPBYTE)lpPrinterInfo7);
    }
#endif

    RRETURN_EXP_IF_ERR(hr);

}


//+---------------------------------------------------------------------------
//
//  Function:   GetInfo(function overloaded: part of CoreADsObject as well
//              as IADs).This function here is part of IADs
//
//  Synopsis:   Binds to real printer as specified in _PrinterName and attempts
//              to get information from the real printer.
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11/08/95    RamV  Created
//              part of code appropriated from NetOle project
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTPrintQueue::GetInfo(THIS)
{

    HRESULT hr = S_OK;

#if (!defined(BUILD_FOR_NT40))

    hr = GetInfo(7,TRUE);

#endif

    hr = GetInfo(2,TRUE);

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTPrintQueue::ImplicitGetInfo(THIS)
{

    HRESULT hr = S_OK;

#if (!defined(BUILD_FOR_NT40))

    hr = GetInfo(7,FALSE);

#endif

    hr = GetInfo(2,FALSE);

    RRETURN_EXP_IF_ERR(hr);

}

//+---------------------------------------------------------------------------
//
//  Function:   GetInfo (overloaded)
//
//  Synopsis:   Calls the IADs GetInfo, because the printer object has just
//              one info level on which to retrieve info from.
//
//  Arguments:  dwApiLevel and fExplicit (Both Ignored)
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01-05-96 RamV Created
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTPrintQueue::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{

    LPPRINTER_INFO_2 lpPrinterInfo2= NULL;
    HRESULT hr = S_OK;

#if (!defined(BUILD_FOR_NT40))

    LPPRINTER_INFO_7 lpPrinterInfo7 = NULL;
    HRESULT hr7 = S_OK;
#endif

    hr = GetPrinterInfo(&lpPrinterInfo2, _pszPrinterName);
    BAIL_IF_ERROR(hr);

    hr = UnMarshall(lpPrinterInfo2,
                    fExplicit);

#if (!defined(BUILD_FOR_NT40))

    hr7 =  GetPrinterInfo7(&lpPrinterInfo7, _pszPrinterName);

    if (SUCCEEDED(hr7)) {

       hr7 = UnMarshall7(lpPrinterInfo7, fExplicit);
    }
#endif

cleanup:
    if(lpPrinterInfo2)
        FreeADsMem((LPBYTE)lpPrinterInfo2);

#if (!defined(BUILD_FOR_NT40))

     if (lpPrinterInfo7) {
        FreeADsMem((LPBYTE)lpPrinterInfo7);
     }

#endif

    RRETURN_EXP_IF_ERR(hr);

}

//
// helper function  WinNTAddPrinter
//

HRESULT
CWinNTPrintQueue::WinNTAddPrinter(void)
{
    HRESULT hr = S_OK;
    TCHAR szUncServerName[MAX_PATH];
    TCHAR szServerName[MAX_PATH];
    PRINTER_INFO_2  PrinterInfo2;
    HANDLE  hPrinter = NULL;
    LPTSTR  pszPrintDevices = NULL;
    LPTSTR  pszModel = NULL;
    LPTSTR  pszDatatype = NULL;
    LPTSTR  pszPrintProcessor = NULL;
    LPTSTR  pszPrinterName =  NULL;
    DWORD dwSyntaxId = 0;
    DWORD dwNumValues = 0;
    PNTOBJECT pNTObject = NULL;

    memset(&PrinterInfo2, 0, sizeof(PRINTER_INFO_2));

    hr = GetDelimitedStringPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrintDevices"),
                    &pszPrintDevices
                    );

    if(SUCCEEDED(hr)){

        PrinterInfo2.pPortName = pszPrintDevices;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Model"),
                    &pszModel
                    );

    if(SUCCEEDED(hr)){

        PrinterInfo2.pDriverName = pszModel;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrinterName"),
                    &pszPrinterName
                    );

    if(SUCCEEDED(hr)){

        PrinterInfo2.pPrinterName = pszPrinterName;
    }
    else {

        PrinterInfo2.pPrinterName = (LPTSTR) _Name;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrintProcessor"),
                    &pszPrintProcessor
                    );

    if(SUCCEEDED(hr)){

        PrinterInfo2.pPrintProcessor = pszPrintProcessor;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Datatype"),
                    &pszDatatype
                    );

    if(SUCCEEDED(hr)){

        PrinterInfo2.pDatatype = pszDatatype;
    }


    hr = GetServerFromPath(_ADsPath, szServerName);
    BAIL_IF_ERROR(hr);

    hr = MakeUncName(szServerName, szUncServerName);
    BAIL_IF_ERROR(hr);


    PrinterInfo2.pServerName = szServerName;
    PrinterInfo2.pShareName =  (LPTSTR)_Name;
    PrinterInfo2.pComment = NULL;
    PrinterInfo2.pLocation = NULL;
    PrinterInfo2.pDevMode = NULL;
    PrinterInfo2.pSepFile = NULL;
    PrinterInfo2.pParameters = NULL;
    PrinterInfo2.pSecurityDescriptor = NULL;
    PrinterInfo2.Attributes = PRINTER_ATTRIBUTE_SHARED;
    PrinterInfo2.Priority = 0;
    PrinterInfo2.DefaultPriority = 0;
    PrinterInfo2.StartTime = 0;
    PrinterInfo2.UntilTime = 0;
    PrinterInfo2.Status = 0;
    PrinterInfo2.cJobs= 0;
    PrinterInfo2.AveragePPM = 0;

    //
    // set properties on printer
    //

    hPrinter = AddPrinter(szUncServerName,
                          2,
                          (LPBYTE)&PrinterInfo2);

    if(hPrinter == NULL){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

 cleanup:
    if(pszPrintDevices){
        FreeADsStr(pszPrintDevices);
    }

    if(pszModel){
        FreeADsStr(pszModel);
    }

    if(pszPrintProcessor){
        FreeADsStr(pszPrintProcessor);
    }

    if(pszDatatype){
        FreeADsStr(pszDatatype);
    }

    if (pszPrinterName) {
        FreeADsStr(pszPrinterName);
    }

    if (hPrinter) {
      ClosePrinter(hPrinter);
    }

    RRETURN(hr);
}



HRESULT
CWinNTPrintQueue::AllocatePrintQueueObject(
    LPTSTR pszServerName,
    LPTSTR pszPrinterName,
    CWinNTPrintQueue ** ppPrintQueue
    )
{
    CWinNTPrintQueue FAR * pPrintQueue = NULL;
    HRESULT hr = S_OK;
    TCHAR   szUncServerName[MAX_PATH];
    TCHAR   szUncPrinterName [MAX_PATH];
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;

    pPrintQueue = new CWinNTPrintQueue();
    if (pPrintQueue == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Build the UNC form of printer name from the supplied information
    //

    if( (wcslen(pszServerName) + 3) > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    hr = MakeUncName(pszServerName,
                     szUncServerName);
    BAIL_ON_FAILURE(hr);

    if( (wcslen(szUncServerName) + wcslen(pszPrinterName) + 2) > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    wcscpy(szUncPrinterName, szUncServerName);
    wcscat(szUncPrinterName, TEXT("\\"));
    wcscat(szUncPrinterName, pszPrinterName);


    pPrintQueue->_pszPrinterName =
        AllocADsStr(szUncPrinterName);

    if(!(pPrintQueue->_pszPrinterName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsPrintQueue,
                           (IADsPrintQueue *)pPrintQueue,
                           DISPID_REGULAR);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsPrintQueueOperations,
                           (IADsPrintQueueOperations *)pPrintQueue,
                           DISPID_REGULAR);
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsPropertyList,
                           (IADsPropertyList *)pPrintQueue,
                           DISPID_VALUE);

    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             PrintQueueClass,
             gdwPrinterTableSize,
             (CCoreADsObject *)pPrintQueue,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );


    pPrintQueue->_pPropertyCache = pPropertyCache;
    pPrintQueue->_pDispMgr = pDispMgr;
    *ppPrintQueue = pPrintQueue;

    RRETURN(hr);

error:

    delete  pPropertyCache;
    delete  pDispMgr;
    delete  pPrintQueue;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  Windows NT 3.5 Provider Object Class Factory Code
//
//             CWinNTProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

//  Class CWinNTProvider

CWinNTProvider::CWinNTProvider()
{

}

HRESULT
CWinNTProvider::Create(
    CWinNTProvider FAR * FAR * ppProvider
    )
{
    CWinNTProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //Create the Provider Object

    pProvider = new CWinNTProvider();
    if (pProvider == NULL) {
        RRETURN(ResultFromScode(E_OUTOFMEMORY));
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }


    *ppProvider = pProvider;
    RRETURN_EXP_IF_ERR(hr);
}

CWinNTProvider::~CWinNTProvider( )
{
    ENLIST_TRACKING(CWinNTProvider);
}

STDMETHODIMP
CWinNTProvider::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CWinNTProvider::ParseDisplayName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;

    *ppmk = NULL;

    if (pchEaten != NULL){
        *pchEaten = 0;
    }

    hr = ResolvePathName(
                pbc,
                szDisplayName,
                pchEaten,
                ppmk
                );

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTProvider::ResolvePathName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;
    LPUNKNOWN pUnknown = NULL;
    //
    // In try block because the Credentials do an InitCritSect
    // down the line on a static variable. This call can fail
    // so we need to catch it.
    //

    if (!pchEaten) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    __try {

        CWinNTCredentials Credentials;

        *pchEaten = 0;
        hr = GetObject(szDisplayName, (LPVOID *)&pUnknown, Credentials);
        BAIL_ON_FAILURE(hr)

        hr = CreatePointerMoniker(pUnknown, ppmk);
        BAIL_ON_FAILURE(hr);

        *pchEaten += wcslen(szDisplayName);

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        RRETURN(E_FAIL);
    }

error :
    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\credel.cxx ===
#include "winnt.hxx"
#pragma hdrstop

HRESULT
WinNTCreateComputer(
    LPWSTR szServerName,
    LPWSTR szComputerName
    );

HRESULT
WinNTDeleteComputer(
    LPWSTR szServerName,
    LPWSTR szComputerName
    );

HRESULT
WinNTCreateLocalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    );

HRESULT
WinNTCreateGlobalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    );

HRESULT
WinNTDeleteLocalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    );

HRESULT
WinNTDeleteGlobalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    );

HRESULT
WinNTCreateUser(
    LPWSTR szServerName,
    LPWSTR szUserName
    );

HRESULT
WinNTDeleteUser(
    LPWSTR szServerName,
    LPWSTR szUserName
    );


HRESULT
WinNTCreateComputer(
    LPWSTR szServerName,
    LPWSTR szComputerName
    )
{
    HRESULT hr = S_OK;
    WCHAR szTargBuffer[MAX_PATH];
    WCHAR szComputerBuffer[MAX_PATH];
    USER_INFO_1 UserInfo1;
    PUSER_INFO_1 pUserInfo1 = &UserInfo1;
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;

    if (!szServerName || !szComputerName ) {
        RRETURN(E_FAIL);
    }

    wcscpy(szComputerBuffer, szComputerName);
    wcscat(szComputerBuffer, L"$");

    memset(pUserInfo1, 0, sizeof(USER_INFO_1));

    pUserInfo1->usri1_name =  szComputerBuffer;
    pUserInfo1->usri1_password = NULL;
    pUserInfo1->usri1_password_age = 0;
    pUserInfo1->usri1_priv = USER_PRIV_USER;
    pUserInfo1->usri1_home_dir = NULL;
    pUserInfo1->usri1_comment = NULL;
    pUserInfo1->usri1_flags = UF_SCRIPT | UF_WORKSTATION_TRUST_ACCOUNT ;
    pUserInfo1->usri1_script_path = NULL;


    hr = MakeUncName(
                szServerName,
                szTargBuffer
                );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetUserAdd(
                    szTargBuffer,
                    1,
                    (LPBYTE)pUserInfo1,
                    &dwParmErr
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}


HRESULT
WinNTDeleteComputer(
    LPWSTR szServerName,
    LPWSTR szComputerName
    )
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    WCHAR szComputerBuffer[MAX_PATH];
    WCHAR szTargBuffer[MAX_PATH];

    if (!szServerName || !szComputerName ) {
        RRETURN(E_FAIL);
    }

    wcscpy(szComputerBuffer, szComputerName);
    wcscat(szComputerBuffer, L"$");

    hr = MakeUncName(
               szServerName,
               szTargBuffer
               );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetUserDel(
                    szTargBuffer,
                    szComputerBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

HRESULT
WinNTCreateGlobalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    )
{
    HRESULT hr = S_OK;
    WCHAR szTargBuffer[MAX_PATH];
    GROUP_INFO_1 GroupInfo1;
    PGROUP_INFO_1 pGroupInfo1 = &GroupInfo1;
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;


    memset(pGroupInfo1, 0, sizeof(GROUP_INFO_1));
    pGroupInfo1->grpi1_name = szGroupName;

    if (!szServerName || !szGroupName ) {
        RRETURN(E_FAIL);
    }

    hr = MakeUncName(
                szServerName,
                szTargBuffer
                );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetGroupAdd(
                    szTargBuffer,
                    1,
                    (LPBYTE)pGroupInfo1,
                    &dwParmErr
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
WinNTCreateLocalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    )
{
    HRESULT hr = S_OK;
    WCHAR szTargBuffer[MAX_PATH];
    LOCALGROUP_INFO_1 LocalGroupInfo1;
    PLOCALGROUP_INFO_1 pLocalGroupInfo1 = &LocalGroupInfo1;
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;


    memset(pLocalGroupInfo1, 0, sizeof(LOCALGROUP_INFO_1));
    pLocalGroupInfo1->lgrpi1_name = szGroupName;

    if (!szServerName || !szGroupName ) {
        RRETURN(E_FAIL);
    }

    hr = MakeUncName(
                szServerName,
                szTargBuffer
                );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetLocalGroupAdd(
                    szTargBuffer,
                    1,
                    (LPBYTE)pLocalGroupInfo1,
                    &dwParmErr
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

HRESULT
WinNTDeleteLocalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    )
{
    WCHAR szTargBuffer[MAX_PATH];
    HRESULT hr;
    NET_API_STATUS nasStatus;

    if (!szServerName || !szGroupName ) {
        RRETURN(E_FAIL);
    }

    hr = MakeUncName(
               szServerName,
               szTargBuffer
               );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetLocalGroupDel(
                    szTargBuffer,
                    szGroupName
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}


HRESULT
WinNTDeleteGlobalGroup(
    LPWSTR szServerName,
    LPWSTR szGroupName
    )
{
    HRESULT hr;
    NET_API_STATUS nasStatus;
    WCHAR szTargBuffer[MAX_PATH];

    if (!szServerName || !szGroupName ) {
        RRETURN(E_FAIL);
    }

    hr = MakeUncName(
               szServerName,
               szTargBuffer
               );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetGroupDel(
                    szTargBuffer,
                    szGroupName
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);

}

HRESULT
WinNTCreateUser(
    LPWSTR szServerName,
    LPWSTR szUserName,
    LPWSTR szUserPassword
    )
{
    HRESULT hr = S_OK;
    WCHAR szTargBuffer[MAX_PATH];
    USER_INFO_1 UserInfo1;
    PUSER_INFO_1 pUserInfo1 = &UserInfo1;
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;
    WCHAR szCompName[MAX_PATH];
    DWORD dwSize = MAX_PATH;

    if (!szServerName || !szUserName ) {
        RRETURN(E_FAIL);
    }

    memset(pUserInfo1, 0, sizeof(USER_INFO_1));

    pUserInfo1->usri1_name =  szUserName;
    pUserInfo1->usri1_password = szUserPassword;
    pUserInfo1->usri1_password_age = DEF_MAX_PWAGE;
    pUserInfo1->usri1_priv = 1;
    pUserInfo1->usri1_home_dir = NULL;
    pUserInfo1->usri1_comment = NULL;
    pUserInfo1->usri1_script_path = NULL;


    pUserInfo1->usri1_flags =  UF_NORMAL_ACCOUNT | UF_SCRIPT;

    hr = MakeUncName(
                szServerName,
                szTargBuffer
                );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetUserAdd(
                    szTargBuffer,
                    USER_PRIV_USER,
                    (LPBYTE)pUserInfo1,
                    &dwParmErr
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);

    //
    // If we fail without workstation services, check if the
    // machine name matches and if so add with NULL as name
    //
    if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {
        if (!GetComputerName(szCompName, &dwSize)) {
            // We cannot get the computer name so bail
            BAIL_ON_FAILURE(hr);
        }

        // Compare the names before we continue
#ifdef WIN95
        if (_wcsicmp(szServerName, szCompName)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                szServerName,
                -1,
                szCompName,
                -1
            ) != CSTR_EQUAL ) {
#endif
            // names do not match
            BAIL_ON_FAILURE(hr);
        }

        nasStatus = NetUserAdd(
                    NULL,
                    USER_PRIV_USER,
                    (LPBYTE)pUserInfo1,
                    &dwParmErr
                    );

        hr = HRESULT_FROM_WIN32(nasStatus);

    }
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}


HRESULT
WinNTDeleteUser(
    LPWSTR szServerName,
    LPWSTR szUserName
    )
{
    HRESULT hr;
    NET_API_STATUS nasStatus;
    WCHAR szTargBuffer[MAX_PATH];
    WCHAR szCompName[MAX_PATH];
    DWORD dwSize = MAX_PATH;

    if (!szServerName || !szUserName ) {
        RRETURN(E_FAIL);
    }

    hr = MakeUncName(
               szServerName,
               szTargBuffer
               );
    BAIL_ON_FAILURE(hr);

    nasStatus = NetUserDel(
                    szTargBuffer,
                    szUserName
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);

        //
    // If we fail without workstation services, check if the
    // machine name matches and if so add with NULL as name
    //
    if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {
        if (!GetComputerName(szCompName, &dwSize)) {
            // We cannot get the computer name so bail
            BAIL_ON_FAILURE(hr);
        }

        // Compare the names before we continue
#ifdef WIN95
        if (_wcsicmp(szServerName, szCompName)) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                szServerName,
                -1,
                szCompName,
                -1
            ) != CSTR_EQUAL ) {
#endif
            // names do not match
            BAIL_ON_FAILURE(hr);
        }

        nasStatus = NetUserDel(
                        NULL,
                        szUserName
                        );

        hr = HRESULT_FROM_WIN32(nasStatus);

    }
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


HRESULT
WinNTDeleteGroup(
    POBJECTINFO pObjectInfo,
    DWORD dwGroupType,
    const CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    HRESULT hr;
    NET_API_STATUS nasStatus;

    if (!pObjectInfo) {
        RRETURN(E_FAIL);
    }

    switch (pObjectInfo->NumComponents) {
    case 2:

        hr = WinNTGetCachedDCName(
                        pObjectInfo->ComponentArray[0],
                        szHostServerName,
                        Credentials.GetFlags() // we need writeable dc
                        );
        BAIL_ON_FAILURE(hr);

        if (dwGroupType == WINNT_GROUP_EITHER) {

            //
            // - try both local and global groups if "group" for backward
            //  compatability
            // - confirmed with cliffv (no global and local group under same
            //   container in nt4 or nt5. So ok.

            hr = WinNTDeleteGlobalGroup(
                    (szHostServerName +2),
                    pObjectInfo->ComponentArray[1]
                    );
            if (FAILED(hr)) {
                hr = WinNTDeleteLocalGroup(
                    (szHostServerName + 2),
                    pObjectInfo->ComponentArray[1]
                    );
            }

        } else if (dwGroupType == WINNT_GROUP_LOCAL) {

            hr = WinNTDeleteLocalGroup(
                    (szHostServerName + 2),
                    pObjectInfo->ComponentArray[1]
                    );

        } else if (dwGroupType == WINNT_GROUP_GLOBAL) {

            hr = WinNTDeleteGlobalGroup(
                    (szHostServerName + 2),
                    pObjectInfo->ComponentArray[1]
                    );

        } else {

            //
            // private funct'n -> must be ADSI own coding bug
            //

            ADsAssert(FALSE);
        }

        BAIL_ON_FAILURE(hr);
        break;

    case 3:

        if (dwGroupType == WINNT_GROUP_EITHER) {

            //
            // - try both local and global groups if "group" for backward
            //  compatability
            // - confirmed with cliffv (no global and local group under same
            //   container in nt4 or nt5. So ok.

            hr = WinNTDeleteGlobalGroup(
                    pObjectInfo->ComponentArray[1],
                    pObjectInfo->ComponentArray[2]
                    );
            if (FAILED(hr)) {
                hr = WinNTDeleteLocalGroup(
                        pObjectInfo->ComponentArray[1],
                        pObjectInfo->ComponentArray[2]
                        );
            }

        } else if (dwGroupType == WINNT_GROUP_LOCAL) {

                hr = WinNTDeleteLocalGroup(
                        pObjectInfo->ComponentArray[1],
                        pObjectInfo->ComponentArray[2]
                        );

        } else if (dwGroupType == WINNT_GROUP_GLOBAL) {

                hr = WinNTDeleteGlobalGroup(
                        pObjectInfo->ComponentArray[1],
                        pObjectInfo->ComponentArray[2]
                        );

        } else {

            //
            // private funct'n -> must be ADSI own coding bug
            //

            ADsAssert(FALSE);
            hr = E_FAIL;
        }

        BAIL_ON_FAILURE(hr);
        break;

    default:
        RRETURN(E_FAIL);

    }

error:

    RRETURN(hr);
}


HRESULT
WinNTDeleteUser(
    POBJECTINFO pObjectInfo,
    const CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    HRESULT hr;
    NET_API_STATUS nasStatus;

    if (!pObjectInfo) {
        RRETURN(E_FAIL);
    }

    switch (pObjectInfo->NumComponents) {
    case 2:

        hr = WinNTGetCachedDCName(
                        pObjectInfo->ComponentArray[0],
                        szHostServerName,
                        Credentials.GetFlags() // we need a writeable dc
                        );
        BAIL_ON_FAILURE(hr);

        hr = WinNTDeleteUser(
                (szHostServerName +2),
                pObjectInfo->ComponentArray[1]
                );
        BAIL_ON_FAILURE(hr);
        break;

    case 3:
        hr = WinNTDeleteUser(
                pObjectInfo->ComponentArray[1],
                pObjectInfo->ComponentArray[2]
                );
        BAIL_ON_FAILURE(hr);
        break;

    default:
        RRETURN(E_FAIL);

    }

error:

    RRETURN(hr);
}


HRESULT
WinNTDeleteComputer(
    POBJECTINFO pObjectInfo,
    const CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    HRESULT hr;
    NET_API_STATUS nasStatus;

    if (!pObjectInfo) {
        RRETURN(E_FAIL);
    }

    switch (pObjectInfo->NumComponents) {
    case 2:
        hr = WinNTGetCachedDCName(
                        pObjectInfo->ComponentArray[0],
                        szHostServerName,
                        Credentials.GetFlags() // we need a writeable DC
                        );
        BAIL_ON_FAILURE(hr);

        hr = WinNTDeleteComputer(
                (szHostServerName +2),
                pObjectInfo->ComponentArray[1]
                );
        BAIL_ON_FAILURE(hr);
        break;

    default:
        RRETURN(E_FAIL);

    }

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cprops.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for NT
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      17-June-1996   RamV   Created.
//                cloned off NT property cache code
//
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma  hdrstop
#define INITGUID

#if DBG
DECLARE_INFOLEVEL(NTMarshall);
DECLARE_DEBUG(NTMarshall);
#define NTMarshallDebugOut(x) NTMarshallInlineDebugOut x
#endif



void
ADsECodesToDispECodes(
    HRESULT *pHr
    );


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::addproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vt]                --
//              [vaData]            --
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
addproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNTOBJECT pNtObject
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pNewProperty = NULL;
    LPWSTR tempString = NULL;

    //
    // Allocate the string first
    //
    tempString = AllocADsStr(szPropertyName);

    if (!tempString)
       BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);

    //
    //  extend the property cache by adding a new property entry
    //

    PPROPERTY pNewProperties = (PPROPERTY)ReallocADsMem(
                                _pProperties,
                                _cb,
                                _cb + sizeof(PROPERTY)
                                );
    if (!pNewProperties) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    else {
      _pProperties = pNewProperties;
    }

    pNewProperty = (PPROPERTY)((LPBYTE)_pProperties + _cb);

    if (pNewProperty->szPropertyName) {
       FreeADsStr(pNewProperty->szPropertyName);
       pNewProperty->szPropertyName = NULL;
    }

    pNewProperty->szPropertyName = tempString;

    //
    // Update the index
    //

    _dwMaxProperties++;
    _cb += sizeof(PROPERTY);


    //
    // add to dynamic dispatch table now ???
    //  - don't check schema here, is it more efficient at all? inconsistency
    //    ???
    //
    /*
    hr = DispatchAddProperty(
            szPropertyName
            );
    BAIL_ON_FAILURE(hr);
    */


    RRETURN(hr);

error:

    if (tempString)
       FreeADsStr(tempString);

    RRETURN_EXP_IF_ERR(hr);
}






//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::updateproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::updateproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNTOBJECT pNtObject,
    BOOL fExplicit
    )
{
    HRESULT hr;
    DWORD dwIndex;
    PNTOBJECT pNtTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;


    if (!fExplicit) {
        if (PROPERTY_FLAGS(pThisProperty) & CACHE_PROPERTY_MODIFIED) {
            hr = S_OK;
            goto error;
        }
    }

    //
    //   Factor in cases where object state is necessary to
    //   decide on update.
    //

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        NTTypeFreeNTObjects(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NTOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

    hr = NtTypeCopyConstruct(
            pNtObject,
            dwNumValues,
            &pNtTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_NTOBJECT(pThisProperty) = pNtTempObject;

    PROPERTY_FLAGS(pThisProperty)  &= ~PROPERTY_MODIFIED;

error:

    RRETURN_EXP_IF_ERR(hr);

}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::findproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )

{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        if (!_wcsicmp(pThisProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }
    *pdwIndex = 0;
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
getproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject,
    BOOL    *pfModified
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;
    DWORD dwResult;
    DWORD dwInfoLevel = 0;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    // don't do implicit GetInfo if there is no ADSI object backing the
    // property cache. This will be true for UMI interafec properties.
    if ((hr == E_ADS_PROPERTY_NOT_FOUND) && (_pCoreADsObject != NULL)) {

        hr = GetPropertyInfoLevel(
                    szPropertyName,
                    _pSchemaClassProps,
                    _dwNumProperties,
                    &dwInfoLevel
                    );
        BAIL_ON_FAILURE(hr);

        //
        // Now call the GetInfo function
        //

        hr = _pCoreADsObject->GetInfo(
                    dwInfoLevel,
                    FALSE
                    );
        BAIL_ON_FAILURE(hr);

        hr = findproperty(
                    szPropertyName,
                    &dwIndex
                    );

    }
    BAIL_ON_FAILURE(hr);




    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        if(pfModified != NULL) { // caller wants to know if prop. was modified
            if(PROPERTY_FLAGS(pThisProperty) & CACHE_PROPERTY_MODIFIED)
                *pfModified = TRUE;
            else
                *pfModified = FALSE;
        } 

        hr = NtTypeCopyConstruct(PROPERTY_NTOBJECT(pThisProperty),
                                 PROPERTY_NUMVALUES(pThisProperty),
                                 ppNtObject );
        BAIL_ON_FAILURE(hr);
    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:
    RRETURN_EXP_IF_ERR(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::marshallgetproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
marshallgetproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;
    DWORD dwResult;
    DWORD dwInfoLevel = 0;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );

    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;


    //
    // If the data has not changed, then do not
    // return data from the cache
    //
    if (PROPERTY_FLAGS(pThisProperty) == 0) {
        hr = E_ADS_PROPERTY_NOT_MODIFIED;
        BAIL_ON_FAILURE(hr);
    }

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(PROPERTY_NTOBJECT(pThisProperty),
                                 PROPERTY_NUMVALUES(pThisProperty),
                                 ppNtObject );
        BAIL_ON_FAILURE(hr);
    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:
    RRETURN_EXP_IF_ERR(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Clsid index
//              [vaData]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::putproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PNTOBJECT pNtObject,
    BOOL   fMarkAsClean
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PNTOBJECT pNtTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        NTTypeFreeNTObjects(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_NTOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

    hr = NtTypeCopyConstruct(
            pNtObject,
            dwNumValues,
            &pNtTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_NTOBJECT(pThisProperty) = pNtTempObject;

    if(FALSE == fMarkAsClean)
        PROPERTY_FLAGS(pThisProperty) |= CACHE_PROPERTY_MODIFIED;

error:
    RRETURN_EXP_IF_ERR(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::CPropertyCache():
    _pCoreADsObject(NULL),
    _pSchemaClassProps(NULL),
    _dwMaxProperties(0),
    _dwCurrentIndex(0),
    _pProperties(NULL),
    _cb(0),
    _pDispProperties(NULL),
    _dwDispMaxProperties(0),
    _cbDisp(0)
{

}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
~CPropertyCache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;
    PDISPPROPERTY pThisDispProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            if (PROPERTY_NTOBJECT(pThisProperty)) {

                NTTypeFreeNTObjects(
                        PROPERTY_NTOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NTOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }


    //
    // Free Dynamic Dispid Table
    //

    if (_pDispProperties) {

        for ( DWORD i = 0; i < _dwDispMaxProperties; i++ ) {

            pThisDispProperty = _pDispProperties + i;

            if (pThisDispProperty->szPropertyName) {
               FreeADsStr(pThisDispProperty->szPropertyName);
               pThisDispProperty->szPropertyName = NULL;
            }

        }

        FreeADsMem(_pDispProperties);
    }


}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
createpropertycache(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    CCoreADsObject FAR * pCoreADsObject,
    CPropertyCache FAR *FAR * ppPropertyCache
    )
{
    CPropertyCache FAR * pPropertyCache = NULL;

    pPropertyCache = new CPropertyCache();

    if (!pPropertyCache) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    pPropertyCache->_pCoreADsObject = pCoreADsObject;
    pPropertyCache->_pSchemaClassProps = pSchemaClassProps;
    pPropertyCache->_dwNumProperties = dwNumProperties;

    *ppPropertyCache = pPropertyCache;

    RRETURN(S_OK);
}


//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unmarshallproperty(
    LPWSTR szPropertyName,
    LPBYTE lpValue,
    DWORD  dwNumValues,
    DWORD  dwSyntaxId,
    BOOL fExplicit
    )
{

    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    PNTOBJECT pNTObject = NULL;

    hr = UnMarshallNTToNTSynId(
                dwSyntaxId,
                dwNumValues,
                lpValue,
                &pNTObject
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = findproperty(
                szPropertyName,
                &dwIndex
                );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //


    if (FAILED(hr)) {
        hr = addproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNTObject
                    );

        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = updateproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pNTObject,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pNTObject) {
        NTTypeFreeNTObjects(
                pNTObject,
                dwNumValues
                );

    }

    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
ValidatePropertyinSchemaClass(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    LPWSTR pszPropName,
    PDWORD pdwSyntaxId
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {
            *pdwSyntaxId = pThisSchProperty->dwSyntaxId;
            RRETURN (S_OK);
        }
    }

    RRETURN(E_ADS_SCHEMA_VIOLATION);
}



HRESULT
ValidateIfWriteableProperty(
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    LPWSTR pszPropName
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {

             RRETURN((pThisSchProperty->dwFlags & PROPERTY_WRITEABLE)
                        ? S_OK : E_ADS_SCHEMA_VIOLATION);
        }
    }

    RRETURN(E_ADS_SCHEMA_VIOLATION);

    // for winnt & nw312, return E_ADS_SCHEMA_VIOLATION if not ok even
    // if just try to write to cache only
}



HRESULT
GetPropertyInfoLevel(
    LPWSTR pszPropName,
    PPROPERTYINFO pSchemaClassProps,
    DWORD dwNumProperties,
    PDWORD pdwInfoLevel
    )
{
    DWORD i = 0;

    PPROPERTYINFO pThisSchProperty = NULL;

    for (i = 0; i < dwNumProperties; i++) {

         pThisSchProperty =  (pSchemaClassProps + i);

        if (!_wcsicmp(pszPropName, pThisSchProperty->szPropertyName)) {

             *pdwInfoLevel = pThisSchProperty->dwInfoLevel;
             RRETURN(S_OK);
        }
    }

    //
    // Returning E_ADS_PROPERTY_NOT_FOUND so that implicit
    // GetInfo fails gracefully
    //
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}


//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
void
CPropertyCache::
flushpropcache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (pThisProperty->szPropertyName) {
               FreeADsStr(pThisProperty->szPropertyName);
               pThisProperty->szPropertyName = NULL;
            }

            if (PROPERTY_NTOBJECT(pThisProperty)) {

                NTTypeFreeNTObjects(
                        PROPERTY_NTOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_NTOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }

    //
    // Reset the property cache
    //

    _pProperties = NULL;
    _dwMaxProperties = 0;
    _cb = 0;
}




//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNtObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}
//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
unboundgetproperty(
    DWORD dwIndex,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PNTOBJECT * ppNtObject
    )
{
    HRESULT hr;
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex)) {
        RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_FOUND);
    }

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_NTOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = NtTypeCopyConstruct(
                PROPERTY_NTOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                ppNtObject
                );
        BAIL_ON_FAILURE(hr);

    }else {

        *ppNtObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_FAIL;

    }

error:

   RRETURN_EXP_IF_ERR(hr);
}


BOOL
CPropertyCache::
index_valid(
   )
{
    //
    // need to check _dwMaxProperties==0 separately since a negative
    // DWORD is equal to +ve large #
    //

    if (_dwMaxProperties==0 || (_dwCurrentIndex>_dwMaxProperties-1) )
        return(FALSE);
    else
        return(TRUE);
}


BOOL
CPropertyCache::
index_valid(
   DWORD dwIndex
   )
{
    //
    // need to check _dwMaxProperties==0 separately since a negative
    // DWORD is equal to +ve large #
    //

    if (_dwMaxProperties==0 || (dwIndex>_dwMaxProperties-1) )
        return(FALSE);
    else
        return(TRUE);
}


void
CPropertyCache::
reset_propindex(
    )
{
  _dwCurrentIndex = 0;

}


HRESULT
CPropertyCache::
skip_propindex(
    DWORD dwElements
    )
{
    DWORD newIndex = _dwCurrentIndex + dwElements;

    if (!index_valid())
        RRETURN_EXP_IF_ERR(E_FAIL);

    //
    // - allow current index to go from within range to out of range by 1
    // - by 1 since initial state is out of range by 1
    //

    if (newIndex>_dwMaxProperties) {
        RRETURN_EXP_IF_ERR(E_FAIL);
    }

    _dwCurrentIndex = newIndex;

    RRETURN(S_OK);

}


HRESULT
CPropertyCache::
get_PropertyCount(
    PDWORD pdwMaxProperties
    )
{
    *pdwMaxProperties = _dwMaxProperties;

    RRETURN(S_OK);
}

DWORD
CPropertyCache::
get_CurrentIndex(
    )
{
    return(_dwCurrentIndex);
}


LPWSTR
CPropertyCache::
get_CurrentPropName(
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!_dwMaxProperties)      // if !_dwMaxProperties, pThisProperty=NULL, AV
        return NULL;            // in PROPERTY_NAME(pThisProperty)

    if (!index_valid())
        return(NULL);

    pThisProperty = _pProperties + _dwCurrentIndex;

    return(PROPERTY_NAME(pThisProperty));
}

LPWSTR
CPropertyCache::
get_PropName(
    DWORD dwIndex
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex))
       return(NULL);

    pThisProperty = _pProperties + dwIndex;

    return(PROPERTY_NAME(pThisProperty));
}


HRESULT
CPropertyCache::
deleteproperty(
    DWORD dwIndex
    )
{
   HRESULT hr = S_OK;
   PPROPERTY pNewProperties = NULL;
   PPROPERTY pThisProperty = _pProperties + dwIndex;

   if (!index_valid(dwIndex)) {
      hr = E_FAIL;
      BAIL_ON_FAILURE(hr);
   }

   if (_dwMaxProperties == 1) {
      //
      // Deleting everything
      //
      if (PROPERTY_NTOBJECT(pThisProperty)) {
          NTTypeFreeNTObjects(
                  PROPERTY_NTOBJECT(pThisProperty),
                  PROPERTY_NUMVALUES(pThisProperty)
                  );
          PROPERTY_NTOBJECT(pThisProperty) = NULL;
      }

      //
      // Free the name of the property
      //
      FreeADsStr(PROPERTY_NAME(pThisProperty));

      FreeADsMem(_pProperties);
      _pProperties = NULL;
      _dwMaxProperties = 0;
      _cb = 0;
      //
      // Reset the current index just in case
      //
      _dwCurrentIndex = 0;
      RRETURN(hr);
   }

   pNewProperties = (PPROPERTY)AllocADsMem(
                               _cb - sizeof(PROPERTY)
                               );
   if (!pNewProperties) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   //
   // Copying the memory before the deleted item
   //
   if (dwIndex != 0) {
      memcpy( pNewProperties,
              _pProperties,
              dwIndex * sizeof(PROPERTY));
   }

   //
   // Copying the memory following the deleted item
   //
   if (dwIndex != (_dwMaxProperties-1)) {
      memcpy( pNewProperties + dwIndex,
              _pProperties + dwIndex + 1,
              (_dwMaxProperties - dwIndex - 1) * sizeof(PROPERTY));
   }

   if (PROPERTY_NTOBJECT(pThisProperty)) {
       NTTypeFreeNTObjects(
               PROPERTY_NTOBJECT(pThisProperty),
               PROPERTY_NUMVALUES(pThisProperty)
               );
       PROPERTY_NTOBJECT(pThisProperty) = NULL;
   }
   
   //
   // Free the property name
   //
   FreeADsStr(PROPERTY_NAME(pThisProperty));

   FreeADsMem(_pProperties);
   _pProperties = pNewProperties;
   _dwMaxProperties--;
   _cb -= sizeof(PROPERTY);
   //
   // Reset the current index if necesary so we do not skip a property.
   //
   if (_dwCurrentIndex > dwIndex) {
       _dwCurrentIndex--;
   }
error:

   RRETURN_EXP_IF_ERR(hr);
}


////////////////////////////////////////////////////////////////////////
//
//  IPropertyCache
//

HRESULT
CPropertyCache::
locateproperty(
    LPWSTR  szPropertyName,
    PDWORD  pdwDispid
    )
{
    HRESULT hr;

    hr = DispatchLocateProperty(
            szPropertyName,
            pdwDispid
            );

    RRETURN(hr);
}

HRESULT
CPropertyCache::
putproperty(
    DWORD   dwDispid,
    VARIANT varValue
    )
{
    HRESULT hr;

    hr = DispatchPutProperty(
            dwDispid,
            varValue
            );

    RRETURN(hr);
}

HRESULT
CPropertyCache::
getproperty(
    DWORD   dwDispid,
    VARIANT * pvarValue
    )
{
    HRESULT hr;

    hr = DispatchGetProperty(
            dwDispid,
            pvarValue
            );

    RRETURN(hr);
}


////////////////////////////////////////////////////////////////////////
//
// Dynamic Dispid Table
//

HRESULT
CPropertyCache::
DispatchFindProperty(
    LPWSTR szPropertyName,
    PDWORD pdwDispid
    )
{
    DWORD i = 0;
    PDISPPROPERTY pDispProp = NULL;

    //
    // use ADs Error codes since this funct'n does not go directly into
    // the dispatch interface
    //
    if (!pdwDispid || !szPropertyName)
        RRETURN(E_ADS_BAD_PARAMETER);

    for (i=0; i<_dwDispMaxProperties; i++) {

        pDispProp = _pDispProperties + i;

        if (!_wcsicmp(DISPATCH_NAME(pDispProp), szPropertyName)) {
            *pdwDispid=i;
            RRETURN(S_OK);
        }
    }

    *pdwDispid = (DWORD) -1;
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}

HRESULT
CPropertyCache::
DispatchAddProperty(
    LPWSTR szPropertyName,
    PDWORD pdwDispid    /* optional */
    )
{

    HRESULT hr = E_FAIL;
    DWORD dwDispid = (DWORD) -1;
    PDISPPROPERTY pNewDispProps = NULL;
    LPWSTR pszTempName = NULL;

    //
    // use ADs Error codes since this funct'n does not go directly into
    // the dispatch interface
    //
    if (!szPropertyName)
        RRETURN(E_ADS_BAD_PARAMETER);

    hr = DispatchFindProperty(
            szPropertyName,
            &dwDispid
            );

    if (hr==E_ADS_PROPERTY_NOT_FOUND) {

        pszTempName = AllocADsStr(szPropertyName);
        if (!pszTempName)
            BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);

        //
        // increase the size of Dynamic Dispid Table by 1 property
        //
        pNewDispProps = (PDISPPROPERTY) ReallocADsMem(
                                            _pDispProperties,
                                            _cbDisp,
                                            _cbDisp + sizeof(DISPPROPERTY)
                                            );
        if (!pNewDispProps)
            BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);

        //
        // must succeeded at this pt. okay to change table & indexes
        //
        _pDispProperties = pNewDispProps;
        DISPATCH_NAME(_pDispProperties+_dwDispMaxProperties) = pszTempName;
        dwDispid = _dwDispMaxProperties++;
        _cbDisp += sizeof(DISPPROPERTY);

        hr = S_OK;
    }

    //
    // return valid, or invalid (-1) in case of failure, dispid of
    // szProperty iff asked for
    //
    if (pdwDispid)
        *pdwDispid = dwDispid;

    RRETURN(hr);


error:

    if (pszTempName)
        FreeADsStr(pszTempName);

    RRETURN(hr);
}

HRESULT
CPropertyCache::
DispatchLocateProperty(
    LPWSTR szPropertyName,
    PDWORD pdwDispid
    )
{
    HRESULT hr;
    DWORD dwSyntaxId;   // (dummy)

    //
    // - pdwDispid not optional here
    // - Use DISP_E_ERROR codes since this function directly called by
    //   the dispatch manager
    //
    if (!pdwDispid || !szPropertyName)
        RRETURN(DISP_E_PARAMNOTOPTIONAL);

    //
    // return dispid of property if already in table;
    //
    hr = DispatchFindProperty(
            szPropertyName,
            pdwDispid
            );

    if (hr==E_ADS_PROPERTY_NOT_FOUND) {

        //
        // check if property in schema
        //      - this is necessary; otherwise, property not in schema will
        //        be allowed to be added to cache and will not be given the
        //        chance to be handled by 3rd party extension.
        //      - note that property not in schema but added to the cache
        //        thru' IADsProperty list will not be handled by 3rd
        //        party extension either.
        //
        hr = ValidatePropertyinSchemaClass(
                _pSchemaClassProps,
                _dwNumProperties,
                szPropertyName,
                &dwSyntaxId
                );

        //
        // Add property that is in the schema but not in the cache to
        // the dynamic dispid table. That is, property which is in the
        // schema will always be handled by the cache/server thur ADSI but
        // will NOT be handled by 3rd party extension.
        //
        if (SUCCEEDED(hr)) {

            hr = DispatchAddProperty(
                        szPropertyName,
                        pdwDispid
                        );
            BAIL_ON_FAILURE(hr);

        }

        //
        // Property Not in the schema will nto be added to the dynamic
        // dispid table and could be handled by 3rd party extension.
        //
        else {

            hr = DISP_E_MEMBERNOTFOUND;
            BAIL_ON_FAILURE(hr);

        }
    }

    RRETURN(hr);

error:

    //
    // translate E_ADS_ error codes to DISP_E if appropriate, see above
    //
    ADsECodesToDispECodes(&hr);

    *pdwDispid = (DWORD) DISPID_UNKNOWN;

    RRETURN(hr);
}


HRESULT
CPropertyCache::
DispatchGetProperty(
    DWORD dwDispid,
    VARIANT * pvarVal
    )
{
    HRESULT hr;
    LPWSTR szPropName = NULL;
    DWORD dwSyntaxId = (DWORD) -1;
    DWORD dwNumValues = 0;
    PNTOBJECT pNtObjs = NULL;

    //
    // Use DISP_E_ERROR codes since this function directly called by
    // the dispatch manager
    //
    if (!pvarVal)
        RRETURN(DISP_E_PARAMNOTOPTIONAL);

    if (!DISPATCH_INDEX_VALID(dwDispid))
        RRETURN(DISP_E_MEMBERNOTFOUND);

    szPropName = DISPATCH_PROPERTY_NAME(dwDispid);

    //
    // return value in cache for szPropName; retrieve value from server
    // if not already in cache; fail if none on sever
    //
    hr = getproperty(
            szPropName,
            &dwSyntaxId,
            &dwNumValues,
            &pNtObjs
            );
    BAIL_ON_FAILURE(hr);

    //
    // translate NT objects into variants
    //
    if (dwNumValues == 1) {

        hr = NtTypeToVarTypeCopy(
                pNtObjs,
                pvarVal
                );

    } else {

        hr = NtTypeToVarTypeCopyConstruct(
                pNtObjs,
                dwNumValues,
                pvarVal
                );
    }
    BAIL_ON_FAILURE(hr);

error:

    if (pNtObjs) {

        NTTypeFreeNTObjects(
            pNtObjs,
            dwNumValues
            );
    }

    if (FAILED(hr)) {

        //
        // return DISP_E errors instead E_ADS_ errors , see above
        //
        ADsECodesToDispECodes(&hr);

        V_VT(pvarVal) = VT_ERROR;
    }

    RRETURN(hr);
}

HRESULT
CPropertyCache::
DispatchPutProperty(
    DWORD dwDispid,
    VARIANT& varVal
    )
{
    HRESULT hr;
    LPWSTR szPropName = NULL;
    VARIANT * pvProp = NULL;            // do not free
    DWORD dwNumValues = 0;
    VARIANT * pTempVarArray = NULL;     // to be freed
    DWORD dwSyntaxId = (DWORD) -1;
    LPNTOBJECT pNtObjs = NULL;
    DWORD dwIndex = (DWORD) -1;


    //
    // Use DISP_E_ERROR codes since this function directly called by
    // the dispatch manager
    //
    if (!DISPATCH_INDEX_VALID(dwDispid))
        RRETURN(DISP_E_MEMBERNOTFOUND);

    //
    // retreive property name from Dynamic Dispatch Table
    //
    szPropName = DISPATCH_PROPERTY_NAME(dwDispid);


    //
    // translate variant to NT Objects
    //

    //
    // A VT_BYREF|VT_VARIANT may expand to a VT_VARIANT|VT_ARRAY.
    // We should dereference a VT_BYREF|VT_VARIANT once and see
    // what's inside. ??
    //
    pvProp = &varVal;

    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(pvProp);
    }

    if ((V_VT(pvProp) == (VT_VARIANT|VT_ARRAY)) ||
        (V_VT(pvProp) == (VT_VARIANT|VT_ARRAY|VT_BYREF))) {

        hr  = ConvertByRefSafeArrayToVariantArray(
                    varVal,
                    &pTempVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);

        if(NULL == pTempVarArray) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }        

        pvProp = pTempVarArray;

    }else {

        //
        // Single value NOT stored in array MUST BE ALLOWED since clients
        // would expect Put() to behave the same whether the dipatch
        // manager is invoked or not. (This funct'n has to be consitent
        // GenericPutPropertyManager(), but NOT GenericPutExProperty...)

        dwNumValues = 1;
    }

    //
    // Need the syntax of this property on the cache.
    //
    hr = ValidatePropertyinSchemaClass(
            _pSchemaClassProps,
            _dwNumProperties,
            szPropName,
            &dwSyntaxId
            );

    BAIL_ON_FAILURE(hr);

    //
    // check if this is a writeable property in schema
    //

    hr = ValidateIfWriteableProperty(
                _pSchemaClassProps,
                _dwNumProperties,
                szPropName
                );
    BAIL_ON_FAILURE(hr);

    //
    // Variant Array to Nt Objects
    //
    hr = VarTypeToNtTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pNtObjs
                    );
    BAIL_ON_FAILURE(hr);


    //
    // add the property to cache if not already in since DispatchAddProperty
    // does not addproperty
    //
    hr = findproperty(
                szPropName,
                &dwIndex
                );

    if (FAILED(hr)) {
        hr = addproperty(
                    szPropName,
                    dwSyntaxId,
                    dwNumValues,
                    pNtObjs
                    );
        BAIL_ON_FAILURE(hr);
    }

    //
    // update property value in cache
    //
    hr = putproperty(
                szPropName,
                dwSyntaxId,
                dwNumValues,
                pNtObjs
                );
    BAIL_ON_FAILURE(hr);


error:

    if (pNtObjs) {
        NTTypeFreeNTObjects(
            pNtObjs,
            dwNumValues
            );
    }

    if (pTempVarArray) {

        DWORD i = 0;
        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pTempVarArray + i);
        }
        FreeADsMem(pTempVarArray);
    }


    if (FAILED(hr)) {

        //
        // return DISP_E errors instead E_ADS_ errors , see above
        //
        ADsECodesToDispECodes(&hr);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   GetPropNames
//
// Synopsis:   Returns the names of all properties in the cache.
//
// Arguments:
//
// pProps      Returns the names of the properties, without any data
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pProps to return the property names
//
//----------------------------------------------------------------------------
HRESULT CPropertyCache::GetPropNames(
    UMI_PROPERTY_VALUES **pProps
    )
{
    UMI_PROPERTY_VALUES *pUmiPropVals = NULL;
    UMI_PROPERTY        *pUmiProps = NULL;
    HRESULT             hr = UMI_S_NO_ERROR;
    ULONG               ulIndex = 0;
    PPROPERTY           pNextProperty = NULL;

    ADsAssert(pProps != NULL);

    pUmiPropVals = (UMI_PROPERTY_VALUES *) AllocADsMem(
                          sizeof(UMI_PROPERTY_VALUES));
    if(NULL == pUmiPropVals)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memset(pUmiPropVals, 0, sizeof(UMI_PROPERTY_VALUES));

    if(0 == _dwMaxProperties) {
    // no properties in cache
        *pProps = pUmiPropVals;
        RRETURN(UMI_S_NO_ERROR);
    }

    pUmiProps = (UMI_PROPERTY *) AllocADsMem(
                          _dwMaxProperties * sizeof(UMI_PROPERTY));
    if(NULL == pUmiProps)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memset(pUmiProps, 0, _dwMaxProperties * sizeof(UMI_PROPERTY));

    for(ulIndex = 0; ulIndex < _dwMaxProperties; ulIndex++) {
        pNextProperty = _pProperties + ulIndex;

        pUmiProps[ulIndex].pszPropertyName =
            (LPWSTR) AllocADsStr(pNextProperty->szPropertyName);
        if(NULL == pUmiProps[ulIndex].pszPropertyName)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    }

    pUmiPropVals->uCount = _dwMaxProperties;
    pUmiPropVals->pPropArray = pUmiProps;

    *pProps = pUmiPropVals;

    RRETURN(UMI_S_NO_ERROR);   

error:

    if(pUmiProps != NULL) {
        for(ulIndex = 0; ulIndex < _dwMaxProperties; ulIndex++)
            if(pUmiProps[ulIndex].pszPropertyName != NULL)
                FreeADsStr(pUmiProps[ulIndex].pszPropertyName);

        FreeADsMem(pUmiProps);
    }

    if(pUmiPropVals != NULL)
        FreeADsMem(pUmiPropVals);

    RRETURN(hr);
} 

//----------------------------------------------------------------------------
// Function:   ClearModifiedFlag 
//
// Synopsis:   Clears the modified flag for all properties in the cache. This
//             is done after a successful SetInfo so that subsequent Get
//             operations return the correct state of the property. 
//
// Arguments:
//
// None
//
// Returns:    Nothing 
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
void
CPropertyCache::ClearModifiedFlags(void)
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        if (PROPERTY_NTOBJECT(pThisProperty)) 
            PROPERTY_FLAGS(pThisProperty) &= ~CACHE_PROPERTY_MODIFIED;
    }
}


//
// Move This function out of this file, out of adsnt in fact. LATER
// Moving it out may make the conversion more difficult since each
// provider return error codes in its own way. May be local is better.
//
void
ADsECodesToDispECodes(
    HRESULT *pHr
    )
{
    DWORD dwADsErr = *pHr;

    switch (dwADsErr) {

    case E_ADS_UNKNOWN_OBJECT:
    case E_ADS_PROPERTY_NOT_SUPPORTED:
    case E_ADS_PROPERTY_INVALID:
    case E_ADS_PROPERTY_NOT_FOUND:

        *pHr = DISP_E_MEMBERNOTFOUND;
        break;

    case E_ADS_BAD_PARAMETER:

        //*pHr = DISP_E_PARAMNOTOPTIONAL;
        break;

    case E_ADS_CANT_CONVERT_DATATYPE:

        *pHr = DISP_E_TYPEMISMATCH;
        //*pHr = DISP_E_BADVARTYPE;
        break;

    case E_ADS_SCHEMA_VIOLATION:

        // depends
        break;

    default:

        break;
        // should make it s.t. E_ADS_xxx -> E_FAIL and no changes on others
        // LATER
    };

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        LPWSTR Parent,
        LPWSTR Name,
        LPWSTR ClassName,
        LPWSTR Schema,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;
    ADsAssert(Parent);
    ADsAssert(Name);
    ADsAssert(ClassName);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
        );
    BAIL_ON_FAILURE(hr);



    if (  ( _tcsicmp( ClassName, PRINTJOB_CLASS_NAME ) == 0 )
       || ( _tcsicmp( ClassName, SESSION_CLASS_NAME ) == 0 )
       || ( _tcsicmp( ClassName, RESOURCE_CLASS_NAME ) == 0 )
       )
    {
        //
        // This three classes are not really DS objects so they don't
        // really have a parent. Hence, we set the parent string to empty
        // string.
        //

        _ADsPath = AllocADsStr(TEXT(""));
        hr = (_ADsPath ? S_OK: E_OUTOFMEMORY);

        BAIL_ON_FAILURE(hr);

        _Parent = AllocADsStr(TEXT(""));
        hr = (_Parent ? S_OK: E_OUTOFMEMORY);

        _dwNumComponents = 0;

    }
    else
    {
        hr = BuildADsPath(
                 Parent,
                 Name,
                 &_ADsPath
                 );

        BAIL_ON_FAILURE(hr);

        // get the number of components in the ADsPath
        hr = GetNumComponents();
        BAIL_ON_FAILURE(hr);

        _Parent = AllocADsStr(Parent);
        hr = (_Parent ? S_OK: E_OUTOFMEMORY);

    }

    BAIL_ON_FAILURE(hr);

    _Name = AllocADsStr(Name);
    hr = (_Name ? S_OK: E_OUTOFMEMORY);

    BAIL_ON_FAILURE(hr);

    _ADsClass = AllocADsStr(ClassName);
    hr = (_ADsClass ? S_OK: E_OUTOFMEMORY);

    BAIL_ON_FAILURE(hr);

    hr = BuildSchemaPath(
            Parent,
            Name,
            Schema,
            &_Schema
            );
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);

}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _Schema(NULL),
                        _ADsGuid(NULL),
                        _dwObjectState(0),
                        _pUnkOuter(NULL),
                        _pObjectInfo(NULL),
                        _pDispatch(NULL)
{
}

CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        FreeADsStr(_Name);
    }

    if (_ADsPath) {
        FreeADsStr(_ADsPath);
    }

    if (_Parent) {
        FreeADsStr(_Parent);
    }

    if (_ADsClass) {
        FreeADsStr(_ADsClass);
    }

    if (_Schema) {
        FreeADsStr(_Schema);
    }

    if (_ADsGuid) {
        FreeADsStr(_ADsGuid);
    }

    if(_pObjectInfo != NULL) {
        FreeObjectInfo(&_ObjectInfo, TRUE);
    }

}

HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Name, retval);
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsPath, retval);
    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsClass, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_Parent, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreSchema(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    if ( _Schema == NULL || *_Schema == 0 )
        RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);

    hr = ADsAllocString(_Schema, retval);
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_ADsGuid, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CCoreADsObject::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CCoreADsObject::ImplicitGetInfo(void)
{
    RRETURN(E_NOTIMPL);
}

//----------------------------------------------------------------------------
// Function:   InitUmiObject
//
// Synopsis:   Initializes UMI object.
//
// Arguments:
//
// Credentials  Credentials stored in the underlying WinNT object
// pSchema      Pointer to schema for this object
// dwSchemaSize Size of schema array
// pPropCache   Pointer to property cache for this object
// pUnkInner    Pointer to inner unknown of WinNT object
// pExtMgr      Pointer to extension manager object on WinNT object
// riid         Interface requested
// ppvObj       Returns pointer to interface 
// pClassInfo   Pointer to class information if this object is a class object.
//              NULL otherwise.
//
// Returns:     S_OK if a UMI object is created and the interface is obtained. 
//              Error code otherwise 
//
// Modifies:    *ppvObj to return the UMI interface requested. 
//
//----------------------------------------------------------------------------
HRESULT CCoreADsObject::InitUmiObject(
    CWinNTCredentials& Credentials,
    PPROPERTYINFO pSchema,
    DWORD dwSchemaSize,
    CPropertyCache * pPropertyCache,
    IUnknown *pUnkInner,
    CADsExtMgr *pExtMgr,
    REFIID riid,
    LPVOID *ppvObj,
    CLASSINFO *pClassInfo
    )
{
    CUmiObject *pUmiObject = NULL;
    HRESULT hr = S_OK;

    // riid is a UMI interface
    if(NULL == ppvObj)
        RRETURN(E_POINTER);

    pUmiObject = new CUmiObject();
    if(NULL == pUmiObject)
        RRETURN(E_OUTOFMEMORY);

    hr = pUmiObject->FInit(
            Credentials,
            pSchema, 
            dwSchemaSize,
            pPropertyCache,
            pUnkInner,
            pExtMgr,
            this,
            pClassInfo
            );
    BAIL_ON_FAILURE(hr);
 
    //
    // Bump up reference count of pUnkInner. On any error after this point,
    // the UMI object's destructor will call Release() on pUnkInner and we
    // don't want this to delete the WinNT object.
    //
    pUnkInner->AddRef();

    hr = pUmiObject->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    // DECLARE_STD_REFCOUNTING initializes the refcount to 1. Call Release()
    // on the created object, so that releasing the interface pointer will
    // free the object.
    pUmiObject->Release();

    // Restore ref count of inner unknown
    pUnkInner->Release();

    //
    // reset ADS_AUTH_RESERVED flag in credentials. This is so that the
    // underlying WinNT object may be returned through IUmiCustomInterface to
    // the client. Doing this will ensure that the WinNT object should behave  
    // like a ADSI object, not a UMI object.
    //
    Credentials.ResetUmiFlag();

    RRETURN(S_OK);

error:

    if(pUmiObject != NULL)
        delete pUmiObject;

    RRETURN(hr);
}
                           
//----------------------------------------------------------------------------
// Function:   GetNumComponents
//
// Synopsis:   This function returns the number of components in the ADsPath.
//             A component is enclosed by '/' in an ADsPath.
//
// Arguments:
//
// None
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing. 
//
//----------------------------------------------------------------------------
HRESULT CCoreADsObject::GetNumComponents(void)
{
    CLexer      Lexer(_ADsPath);
    HRESULT     hr = S_OK;

    _pObjectInfo = &_ObjectInfo;
    memset(_pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, _pObjectInfo);
    if(FAILED(hr)) {
        _pObjectInfo = NULL; // so we don't attempt to free object info later
        goto error;
    }

    _dwNumComponents = _pObjectInfo->NumComponents;

    RRETURN(S_OK);

error:

    if(_pObjectInfo != NULL)
        FreeObjectInfo(&_ObjectInfo, TRUE);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  Windows NT 3.5 Provider Object Class Factory Code
//
//             CWinNTProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CWinNTProviderCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID iid,
    LPVOID * ppv
    )
{
    HRESULT     hr;
    CWinNTProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CWinNTProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cres.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cres.cxx
//
//  Contents:  Contains methods for the following objects
//             CWinNTResource, CWinNTFSResourceGeneralInfo
//
//
//  History:   02/08/96     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

DECLARE_INFOLEVEL( Resource );
DECLARE_DEBUG( Resource );
#define ResourceDebugOut(x) ResourceInlineDebugOut x


DEFINE_IDispatch_ExtMgr_Implementation(CWinNTResource);
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTResource);
DEFINE_IADs_TempImplementation(CWinNTResource);
DEFINE_IADs_PutGetImplementation(CWinNTResource, ResourceClass, gdwResourceTableSize);
DEFINE_IADsPropertyList_Implementation(CWinNTResource, ResourceClass, gdwResourceTableSize)


CWinNTResource::CWinNTResource()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pszServerName = NULL;
    _pPropertyCache = NULL;

    ENLIST_TRACKING(CWinNTResource);
    return;

}

CWinNTResource::~CWinNTResource()
{

    delete _pExtMgr;            // created last, destroyed first
    delete _pDispMgr;
    delete _pPropertyCache;

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }

    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTResource::Create
//
//  Synopsis:   Static function used to create a Resource object. This
//              will be called by EnumResources::Next
//
//  Arguments:  [ppWinNTResource] -- Ptr to a ptr to a new Resource object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
CWinNTResource::Create(LPTSTR pszServerADsPath,
                       DWORD  dwObject,
                       DWORD  dwFileId,
                       REFIID riid,
                       CWinNTCredentials& Credentials,
                       LPVOID * ppvoid
                       )

{

    CWinNTResource FAR * pCWinNTResource = NULL;
    HRESULT hr;
    TCHAR szFileName[MAX_LONG_LENGTH];
    TCHAR szUncServerName[MAX_PATH];


    hr =CWinNTResource::AllocateResourceObject(pszServerADsPath,
                                               &pCWinNTResource );
    BAIL_IF_ERROR(hr);

    ADsAssert(pCWinNTResource->_pDispMgr);


    //
    // convert the FileId that we have into a string that we move
    // into the Name field
    //

    _ltow(dwFileId, szFileName, 10);

    hr = pCWinNTResource->InitializeCoreObject(pszServerADsPath,
                                               szFileName,
                                               RESOURCE_CLASS_NAME,
                                               RESOURCE_SCHEMA_NAME,
                                               CLSID_WinNTResource,
                                               dwObject);


    pCWinNTResource->_dwFileId = dwFileId;

    pCWinNTResource->_Credentials = Credentials;
    hr = pCWinNTResource->_Credentials.RefServer(
        pCWinNTResource->_pszServerName);
    BAIL_IF_ERROR(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                RESOURCE_CLASS_NAME,
                (IADs *) pCWinNTResource,
                pCWinNTResource->_pDispMgr,
                Credentials,
                &pCWinNTResource->_pExtMgr
                );
    BAIL_IF_ERROR(hr);

    ADsAssert(pCWinNTResource->_pExtMgr);


    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        // Resource objects have "" as their ADsPath. Just set the class to
        // resource for identification purposes.
        pCWinNTResource->_CompClasses[0] = L"Resource";

        hr = pCWinNTResource->InitUmiObject(
               pCWinNTResource->_Credentials, 
               ResourceClass, 
               gdwResourceTableSize,
               pCWinNTResource->_pPropertyCache,
               (IUnknown *)(INonDelegatingUnknown *) pCWinNTResource,
               pCWinNTResource->_pExtMgr,
               IID_IUnknown,
               ppvoid
               );

        BAIL_IF_ERROR(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }


    ADsAssert(ppvoid);
    hr = pCWinNTResource->QueryInterface(riid, (void **)ppvoid);
    BAIL_IF_ERROR(hr);

    pCWinNTResource->Release();

    RRETURN(hr);

cleanup:
    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }
    delete pCWinNTResource;
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTResource::AllocateResourceObject(LPTSTR pszServerADsPath,
                                       CWinNTResource ** ppResource)
{

    CWinNTResource FAR * pCWinNTResource = NULL;
    HRESULT hr = S_OK;
    TCHAR szFileName[MAX_LONG_LENGTH];
    TCHAR szUncServerName[MAX_PATH];
    POBJECTINFO pServerObjectInfo = NULL;

    //
    // Create the Resource Object
    //

    pCWinNTResource = new CWinNTResource();
    if (pCWinNTResource == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCWinNTResource->_pDispMgr = new CAggregatorDispMgr;

    if(pCWinNTResource ->_pDispMgr == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr =  LoadTypeInfoEntry(pCWinNTResource->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsResource,
                            (IADsResource *)pCWinNTResource,
                            DISPID_REGULAR);
    BAIL_ON_FAILURE(hr);

    hr =  LoadTypeInfoEntry(pCWinNTResource->_pDispMgr,
                            LIBID_ADs,
                            IID_IADsPropertyList,
                            (IADsPropertyList *)pCWinNTResource,
                            DISPID_VALUE);
    BAIL_ON_FAILURE(hr);


    pCWinNTResource->_pszServerADsPath =
        AllocADsStr(pszServerADsPath);

    if(!(pCWinNTResource->_pszServerADsPath)){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo);
    BAIL_ON_FAILURE(hr);

    pCWinNTResource->_pszServerName =
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if (!pCWinNTResource->_pszServerName){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = CPropertyCache::createpropertycache(
             ResourceClass,
             gdwResourceTableSize,
             (CCoreADsObject *)pCWinNTResource,
             &(pCWinNTResource->_pPropertyCache)
             );
    BAIL_ON_FAILURE(hr);

    (pCWinNTResource->_pDispMgr)->RegisterPropertyCache(
                                        pCWinNTResource->_pPropertyCache
                                        );


    *ppResource = pCWinNTResource;

cleanup:

    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    RRETURN(hr);

error:


    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete pCWinNTResource;

    goto cleanup;
}



/* IUnknown methods for Resource object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTResource::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTResource::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTResource::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTResource::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(ppvObj == NULL){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADs *) this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADs *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsResource))
    {
        *ppvObj = (IADsResource FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTResource::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsResource) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */


//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   SetInfo on actual Resource
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    02/08/96    RamV  Created

//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTResource::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTResource::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    //
    // we do a GetInfo at Info Level of 3
    //
    NET_API_STATUS nasStatus = NERR_Success;
    LPFILE_INFO_3  lpFileInfo3  = NULL;
    HRESULT hr = S_OK;
    TCHAR szUncServerName[MAX_PATH];

    hr = MakeUncName(_pszServerName,
                     szUncServerName);

    BAIL_IF_ERROR(hr);

    nasStatus = NetFileGetInfo(szUncServerName, // contains UNC name
                               _dwFileId,
                               3,
                               (LPBYTE*)&lpFileInfo3);

    if(nasStatus != NERR_Success || !lpFileInfo3){
        hr = HRESULT_FROM_WIN32(nasStatus);
        goto cleanup;
    }

    //
    // unmarshall the info
    //

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Path"),
                                  lpFileInfo3->fi3_pathname,
                                  fExplicit
                                  );


    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("User"),
                                  lpFileInfo3->fi3_username,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("LockCount"),
                                  lpFileInfo3->fi3_num_locks,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );


    hr = S_OK;

cleanup:
    if(lpFileInfo3)
        NetApiBufferFree(lpFileInfo3);
    RRETURN_EXP_IF_ERR(hr);

}




STDMETHODIMP
CWinNTResource::GetInfo(THIS)
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(3, TRUE));
}

STDMETHODIMP
CWinNTResource::ImplicitGetInfo(THIS)
{
    RRETURN(GetInfo(3, FALSE));
}

STDMETHODIMP
CWinNTResource::get_User(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsResource *)this, User);
}

STDMETHODIMP
CWinNTResource::get_UserPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTResource::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsResource *)this, Path);
}

STDMETHODIMP
CWinNTResource::get_LockCount(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsResource *)this, LockCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\csess.cxx ===
//---------------------------------------------------------------------------DSI
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  csess.cxx
//
//  Contents:  Contains methods for the following objects
//             CWinNTSession, CWinNTSessionGeneralInfo
//
//
//  History:   02/08/96     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID

DECLARE_INFOLEVEL( Session );
DECLARE_DEBUG( Session );
#define SessionDebugOut(x) SessionInlineDebugOut x


DEFINE_IDispatch_ExtMgr_Implementation(CWinNTSession);
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTSession);
DEFINE_IADs_TempImplementation(CWinNTSession);
DEFINE_IADs_PutGetImplementation(CWinNTSession, SessionClass,gdwSessionTableSize);
DEFINE_IADsPropertyList_Implementation(CWinNTSession, SessionClass,gdwSessionTableSize)

CWinNTSession::CWinNTSession()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pszServerName = NULL;
    _pszComputerName = NULL;
    _pszUserName  = NULL;
    _pPropertyCache = NULL;
    ENLIST_TRACKING(CWinNTSession);
    return;

}

CWinNTSession::~CWinNTSession()
{

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }

    if(_pszServerADsPath){
        FreeADsStr(_pszServerADsPath);
    }

    if(_pszComputerName){
        FreeADsStr(_pszComputerName);
    }
    if(_pszUserName){
        FreeADsStr(_pszUserName);
    }
    delete _pPropertyCache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTSession::Create
//
//  Synopsis:   Static function used to create a Session object. This
//              will be called by EnumSessions::Next
//
//  Arguments:  [ppWinNTSession] -- Ptr to a ptr to a new Session object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
CWinNTSession::Create(LPTSTR pszServerADsPath,
                      LPTSTR pszClientName,
                      LPTSTR pszUserName,
                      DWORD  dwObject,
                      REFIID riid,
                      CWinNTCredentials& Credentials,
                      LPVOID * ppvoid
                      )

{

    CWinNTSession FAR * pCWinNTSession = NULL;
    HRESULT hr;
    TCHAR szSessionName[MAX_PATH];

    //
    // Create the Session Object
    //

    hr = AllocateSessionObject(pszServerADsPath,
                               pszClientName,
                               pszUserName,
                               &pCWinNTSession);

    BAIL_IF_ERROR(hr);

    ADsAssert(pCWinNTSession->_pDispMgr);


    wcscpy(szSessionName, pszUserName);
    wcscat(szSessionName, TEXT("\\"));
    wcscat(szSessionName, pszClientName);

    hr = pCWinNTSession->InitializeCoreObject(pszServerADsPath,
                                              szSessionName,
                                              SESSION_CLASS_NAME,
                                              SESSION_SCHEMA_NAME,
                                              CLSID_WinNTSession,
                                              dwObject);

    BAIL_IF_ERROR(hr);

    pCWinNTSession->_Credentials = Credentials;
    hr = pCWinNTSession->_Credentials.RefServer(
        pCWinNTSession->_pszServerName);
    BAIL_IF_ERROR(hr);

    if( pszUserName && *pszUserName ) {
        hr = SetLPTSTRPropertyInCache(pCWinNTSession->_pPropertyCache,
                                      TEXT("User"),
                                      pszUserName,
                                      TRUE
                                      );
        BAIL_IF_ERROR(hr);
    }

    hr = SetLPTSTRPropertyInCache(pCWinNTSession->_pPropertyCache,
                                  TEXT("Computer"),
                                  pCWinNTSession->_pszComputerName,
                                  TRUE
                                  );
    BAIL_IF_ERROR(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                SESSION_CLASS_NAME,
                (IADs *) pCWinNTSession,
                pCWinNTSession->_pDispMgr,
                Credentials,
                &pCWinNTSession->_pExtMgr
                );
    BAIL_IF_ERROR(hr);

    ADsAssert(pCWinNTSession->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        // Session objects have "" as their ADsPath. Just set the class for
        // identification purposes.
        pCWinNTSession->_CompClasses[0] = L"Session";

        hr = pCWinNTSession->InitUmiObject(
                pCWinNTSession->_Credentials,
                SessionClass,
                gdwSessionTableSize,
                pCWinNTSession->_pPropertyCache,
                (IUnknown *)(INonDelegatingUnknown *) pCWinNTSession,
                pCWinNTSession->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_IF_ERROR(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pCWinNTSession->QueryInterface(riid,
                                        (void **)ppvoid);
    BAIL_IF_ERROR(hr);

    pCWinNTSession->Release();

cleanup:

    if(SUCCEEDED(hr)){
        RRETURN(hr);
    }

    delete pCWinNTSession;
    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CWinNTSession::AllocateSessionObject(LPTSTR pszServerADsPath,
                                     LPTSTR pszClientName,
                                     LPTSTR pszUserName,
                                     CWinNTSession ** ppSession
                                     )
{
    CWinNTSession FAR * pCWinNTSession = NULL;
    HRESULT hr = S_OK;
    POBJECTINFO pServerObjectInfo = NULL;

    pCWinNTSession = new CWinNTSession();
    if (pCWinNTSession == NULL) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    pCWinNTSession->_pDispMgr = new CAggregatorDispMgr;
    if (pCWinNTSession->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = LoadTypeInfoEntry(pCWinNTSession->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsSession,
                           (IADsSession *)pCWinNTSession,
                           DISPID_REGULAR);
    BAIL_IF_ERROR(hr);

    pCWinNTSession->_pszServerADsPath
        = AllocADsStr(pszServerADsPath);

    if(!pCWinNTSession->_pszServerADsPath){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    hr = BuildObjectInfo(pszServerADsPath,
                         &pServerObjectInfo);
    BAIL_IF_ERROR(hr);

    pCWinNTSession->_pszServerName =
        AllocADsStr(pServerObjectInfo->ComponentArray[1]);

    if(!pCWinNTSession->_pszServerADsPath){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    if(pszClientName){

        pCWinNTSession->_pszComputerName = AllocADsStr(pszClientName);
        if(!pCWinNTSession->_pszComputerName){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    if(pszUserName){
        pCWinNTSession->_pszUserName = AllocADsStr(pszUserName);
        if(!pCWinNTSession->_pszUserName){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }
    }

    hr = CPropertyCache::createpropertycache(
             SessionClass,
             gdwSessionTableSize,
             (CCoreADsObject *)pCWinNTSession,
             &(pCWinNTSession->_pPropertyCache)
             );

    BAIL_IF_ERROR(hr);

    (pCWinNTSession->_pDispMgr)->RegisterPropertyCache(
                pCWinNTSession->_pPropertyCache
                );

    *ppSession = pCWinNTSession;


cleanup:

    if(pServerObjectInfo){
        FreeObjectInfo(pServerObjectInfo);
    }

    if (!SUCCEEDED(hr)) {

        //
        // direct memeber assignement assignement at pt of creation, so
        // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
        // of deletion again in pPrintJob destructor and AV
        //

        delete pCWinNTSession;
    }

    RRETURN(hr);

}




/* IUnknown methods for session object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTSession::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTSession::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTSession::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTSession::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADs *) this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADs *)this;
    }
    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADs FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsSession))
    {
        *ppvObj = (IADsSession FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTSession::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsSession) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */


//+-----------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:   SetInfo on actual session
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    02/08/96    RamV  Created

//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTSession::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSession::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    HRESULT hr;
    hr = GetLevel_1_Info(fExplicit);
    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CWinNTSession::GetInfo(THIS)
{

    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(1, TRUE));
}

STDMETHODIMP
CWinNTSession::ImplicitGetInfo(THIS)
{

    RRETURN(GetInfo(1, FALSE));
}

//
// helper functions for GetInfo
//

STDMETHODIMP
CWinNTSession::GetLevel_1_Info(THIS_ BOOL fExplicit)
{
    NET_API_STATUS nasStatus;
    LPSESSION_INFO_1 lpSessionInfo =NULL;
    HRESULT hr;
    TCHAR szUncServerName[MAX_PATH];
    TCHAR szUncClientName[MAX_PATH];

    //
    // Level 1 info
    //

    hr = MakeUncName(_pszServerName, szUncServerName);
    BAIL_IF_ERROR(hr);

    hr = MakeUncName(_pszComputerName, szUncClientName);
    BAIL_IF_ERROR(hr);

    nasStatus = NetSessionGetInfo(szUncServerName,
                                  szUncClientName,
                                  _pszUserName,
                                  1,
                                  (LPBYTE *)&lpSessionInfo);

    if (nasStatus != NERR_Success || !lpSessionInfo){
        hr = HRESULT_FROM_WIN32(nasStatus);
        goto cleanup;
    }

    //
    // unmarshall the info
    //

    ADsAssert(lpSessionInfo);



    if( _pszUserName && *_pszUserName ) {
        hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                      TEXT("User"),
                                      _pszUserName,
                                      fExplicit
                                      );
    }



    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Computer"),
                                  _pszComputerName,
                                  fExplicit
                                  );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("ConnectTime"),
                                 lpSessionInfo->sesi1_time,
                                 fExplicit
                                 );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("IdleTime"),
                                 lpSessionInfo->sesi1_idle_time,
                                 fExplicit
                                 );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    hr = S_OK;

cleanup:
    if(lpSessionInfo)
        NetApiBufferFree(lpSessionInfo);
    RRETURN(hr);

}

STDMETHODIMP
CWinNTSession::get_User(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    //
    // UserName is set once and never modified,
    //

    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }
    hr = ADsAllocString(_pszUserName, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTSession::get_UserPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTSession::get_Computer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    //
    // Computer name is set once and never modified,
    //
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    hr = ADsAllocString(_pszComputerName, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTSession::get_ComputerPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTSession::get_ConnectTime(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsSession *)this, ConnectTime);
}

STDMETHODIMP
CWinNTSession::get_IdleTime(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsSession *)this, IdleTime);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cuar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuar.cxx
//
//  Contents:  Account Restrictions Propset for the User object
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//        PROPERTY_RW(AccountDisabled, boolean, 1)              I
//        PROPERTY_RW(AccountExpirationDate, DATE, 2)           I
//        PROPERTY_RO(AccountCanExpire, boolean, 3)             I
//        PROPERTY_RO(PasswordCanExpire, boolean, 4)            I
//        PROPERTY_RW(GraceLoginsAllowed, long, 5)              NI
//        PROPERTY_RW(GraceLoginsRemaining, long, 6)            NI
//        PROPERTY_RW(IsAccountLocked, boolean, 7)              I
//        PROPERTY_RW(IsAdmin, boolean, 8)                      I
//        PROPERTY_RW(LoginHours, VARIANT, 9)                   I
//        PROPERTY_RW(LoginWorkstations, VARIANT, 10)           I
//        PROPERTY_RW(MaxLogins, long, 11)                      I
//        PROPERTY_RW(MaxStorage, long, 12)                     I
//        PROPERTY_RW(PasswordExpirationDate, DATE, 13)         I
//        PROPERTY_RW(PasswordRequired, boolean, 14)            I
//        PROPERTY_RW(RequireUniquePassword,boolean, 15)        I
//
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//  Class CWinNTUser

STDMETHODIMP
CWinNTUser::get_AccountDisabled(THIS_ VARIANT_BOOL FAR* retval)
{
   HRESULT hr = S_OK;
   VARIANT var;

   VariantInit(&var);
   hr = Get(L"UserFlags", &var);
   BAIL_ON_FAILURE(hr);

   if (V_I4(&var) & UF_ACCOUNTDISABLE) {

       *retval = VARIANT_TRUE;
   }else {
       *retval = VARIANT_FALSE;
   }

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::put_AccountDisabled(THIS_ VARIANT_BOOL fAccountDisabled)
{
   HRESULT hr = S_OK;
   VARIANT var;

   VariantInit(&var);
   hr = Get(L"UserFlags", &var);
   BAIL_ON_FAILURE(hr);

   if (fAccountDisabled == VARIANT_TRUE) {

       V_I4(&var) |= UF_ACCOUNTDISABLE;
   } else if (fAccountDisabled == VARIANT_FALSE){

       V_I4(&var) &=  ~UF_ACCOUNTDISABLE;
   }else {
       BAIL_ON_FAILURE(hr = E_FAIL);
   }

   hr = Put(L"UserFlags", var);
   BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTUser::get_AccountExpirationDate(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CWinNTUser::put_AccountExpirationDate(THIS_ DATE daAccountExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, AccountExpirationDate);
}

STDMETHODIMP
CWinNTUser::get_GraceLoginsAllowed(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}


STDMETHODIMP
CWinNTUser::put_GraceLoginsAllowed(THIS_ long lGraceLoginsAllowed)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsAllowed);
}

STDMETHODIMP
CWinNTUser::get_GraceLoginsRemaining(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CWinNTUser::put_GraceLoginsRemaining(THIS_ long lGraceLoginsRemaining)
{
    PUT_PROPERTY_LONG((IADsUser *)this, GraceLoginsRemaining);
}

STDMETHODIMP
CWinNTUser::get_IsAccountLocked(THIS_ VARIANT_BOOL FAR* retval)
{

   HRESULT hr = S_OK;
   DWORD dwUserFlags =  0;
   VARIANT var;

   if(_fUseCacheForAcctLocked) {
   // see comment on _fUseCacheForAcctLocked in cuser.hxx
       VariantInit(&var);
       hr = Get(L"UserFlags", &var);
       BAIL_ON_FAILURE(hr);

       if (V_I4(&var) & UF_LOCKOUT) {

           *retval = VARIANT_TRUE;
       }else {
           *retval = VARIANT_FALSE;
       }
    }
    else {
       hr = GetUserFlags(&dwUserFlags);
       BAIL_ON_FAILURE(hr);

       VariantInit(&var);
       hr = Get(L"UserFlags", &var);
       BAIL_ON_FAILURE(hr);

       if (dwUserFlags & UF_LOCKOUT) {
           V_I4(&var) |= UF_LOCKOUT;
           *retval = VARIANT_TRUE;
       } 
       else {
           V_I4(&var) &=  ~UF_LOCKOUT;
           *retval = VARIANT_FALSE;
       }

       hr = Put(L"UserFlags", var);
       BAIL_ON_FAILURE(hr);

       _fUseCacheForAcctLocked = TRUE;
    }

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::put_IsAccountLocked(THIS_ VARIANT_BOOL fIsAccountLocked)
{
   HRESULT hr = S_OK;
   VARIANT var;

   VariantInit(&var);
   hr = Get(L"UserFlags", &var);
   BAIL_ON_FAILURE(hr);

   if (fIsAccountLocked == VARIANT_TRUE) {
   // only the system can lockout an account. Can't do it using ADSI.
       BAIL_ON_FAILURE(hr = E_INVALIDARG);

   } else if (fIsAccountLocked == VARIANT_FALSE){

       V_I4(&var) &=  ~UF_LOCKOUT;
   }else {
       BAIL_ON_FAILURE(hr = E_FAIL);
   }

   hr = Put(L"UserFlags", var);
   BAIL_ON_FAILURE(hr);

   _fUseCacheForAcctLocked = TRUE;

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::get_LoginHours(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this,LoginHours);
}

STDMETHODIMP
CWinNTUser::put_LoginHours(THIS_ VARIANT vLoginHours)
{

    PUT_PROPERTY_VARIANT((IADsUser *)this,LoginHours);
}

STDMETHODIMP
CWinNTUser::get_LoginWorkstations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this,LoginWorkstations);
}


STDMETHODIMP
CWinNTUser::put_LoginWorkstations(THIS_ VARIANT vLoginWorkstations)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this,LoginWorkstations);
}

STDMETHODIMP
CWinNTUser::get_MaxLogins(THIS_ long FAR* retval)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTUser::put_MaxLogins(THIS_ long lMaxLogins)
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTUser::get_MaxStorage(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}


STDMETHODIMP
CWinNTUser::put_MaxStorage(THIS_ long lMaxStorage)
{
    PUT_PROPERTY_LONG((IADsUser *)this, MaxStorage);
}

STDMETHODIMP
CWinNTUser::get_PasswordExpirationDate(THIS_ DATE FAR* retval)
{
   HRESULT hr = S_OK;
   VARIANT var;
   SYSTEMTIME SystemTime;
   SYSTEMTIME LocalTime;
   FILETIME FileTime;
   DWORD dwCurrentTime = 0L;
   DWORD dwLastMod = 0L;
   DWORD dwPasswordAge = 0L;
   DWORD dwMaxPasswordAge = 0L;
   DWORD dwPasswordExpDate = 0L;


   VariantInit(&var);
   hr = Get(L"PasswordAge", &var);
   BAIL_ON_FAILURE(hr);
   dwPasswordAge = V_I4(&var);

   VariantInit(&var);
   hr = Get(L"MaxPasswordAge", &var);
   BAIL_ON_FAILURE(hr);

   dwMaxPasswordAge = V_I4(&var);
   LARGE_INTEGER Time;


   GetSystemTime(&SystemTime);

   SystemTimeToFileTime(&SystemTime, &FileTime);

   memset(&Time, 0, sizeof(LARGE_INTEGER));

   Time.LowPart = FileTime.dwLowDateTime;
   Time.HighPart = FileTime.dwHighDateTime
   ;

   RtlTimeToSecondsSince1970 ((PLARGE_INTEGER)&Time, &dwCurrentTime);

   dwLastMod = dwCurrentTime - dwPasswordAge;

   if (dwMaxPasswordAge == TIMEQ_FOREVER) {
       BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
   }else {
       dwPasswordExpDate = dwLastMod + dwMaxPasswordAge;
   }

   hr = ConvertDWORDtoDATE( dwPasswordExpDate, retval);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::put_PasswordExpirationDate(THIS_ DATE daPasswordExpirationDate)
{
    PUT_PROPERTY_DATE((IADsUser *)this, PasswordExpirationDate);
}

STDMETHODIMP
CWinNTUser::get_PasswordRequired(THIS_ VARIANT_BOOL FAR* retval)
{
   HRESULT hr = S_OK;
   long lnUserFlags =  0L;
   VARIANT var;


   VariantInit(&var);
   hr = Get(L"UserFlags", &var);
   BAIL_ON_FAILURE(hr);

   if (V_I4(&var) & UF_PASSWD_NOTREQD) {

       *retval = VARIANT_FALSE;
   }else {
       *retval = VARIANT_TRUE;
   }

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::put_PasswordRequired(THIS_ VARIANT_BOOL fPasswordRequired)
{
   HRESULT hr = S_OK;
   VARIANT var;

   VariantInit(&var);
   hr = Get(L"UserFlags", &var);
   BAIL_ON_FAILURE(hr);

   if (fPasswordRequired == VARIANT_TRUE) {

       V_I4(&var) &= ~UF_PASSWD_NOTREQD;
   } else if (fPasswordRequired == VARIANT_FALSE){

       V_I4(&var) |= UF_PASSWD_NOTREQD;
   }else {
       BAIL_ON_FAILURE(hr = E_FAIL);
   }

   hr = Put(L"UserFlags", var);
   BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::get_PasswordMinimumLength(THIS_ LONG FAR* retval)
{

   HRESULT hr = S_OK;
   VARIANT varTemp;

   hr = Get(L"MinPasswordLength", &varTemp);
   BAIL_ON_FAILURE(hr);

   *retval = V_I4(&varTemp);

error:

  RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::put_PasswordMinimumLength(THIS_ LONG lPasswordMinimumLength)
{
    VARIANT varTemp;
    HRESULT hr;

    VariantInit(&varTemp);
    V_VT(&varTemp) = VT_I4;
    V_I4(&varTemp) = lPasswordMinimumLength;

    hr = Put(L"MinPasswordLength", varTemp);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::get_RequireUniquePassword(THIS_ VARIANT_BOOL FAR* retval)
{
    GET_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}

STDMETHODIMP
CWinNTUser::put_RequireUniquePassword(THIS_ VARIANT_BOOL fRequireUniquePassword)
{
    PUT_PROPERTY_VARIANT_BOOL((IADsUser *)this, RequireUniquePassword);
}


STDMETHODIMP
CWinNTUser::SetPassword(THIS_ BSTR NewPassword)
{
    NET_API_STATUS nasStatus;
    LPUSER_INFO_2 lpUserInfo2 = NULL;
    HRESULT hr;
    WCHAR szHostServerName[MAX_PATH];
    DWORD dwParmErr = 0;
    WCHAR szBuffer[MAX_PATH];

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        // We want to set the password in this case
        // This is to allow the creation of users when there
        // is a restriction such as new user should have passwd.
        hr = setPrivatePassword(NewPassword);

        RRETURN(hr);
    }

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                        _DomainName,
                        szHostServerName,
                        _Credentials.GetFlags()
                        );
        BAIL_ON_FAILURE(hr);

    }else {
        hr = MakeUncName(
               _ServerName,
               szHostServerName
               );
        BAIL_ON_FAILURE(hr);

    }

    nasStatus = NetUserGetInfo(
                    szHostServerName,
                    _Name,
                    2,
                    (LPBYTE *)&lpUserInfo2
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    lpUserInfo2->usri2_password = NewPassword;

    nasStatus = NetUserSetInfo(
                    szHostServerName,
                    _Name,
                    2,
                    (LPBYTE)lpUserInfo2,
                    &dwParmErr
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);


error:
    if (lpUserInfo2) {
        NetApiBufferFree(lpUserInfo2);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::ChangePassword(THIS_ BSTR bstrOldPassword, BSTR bstrNewPassword)
{
    NET_API_STATUS nasStatus;
    LPBYTE lpBuffer = NULL;
    HRESULT hr;
    WCHAR szHostServerName[MAX_PATH];

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = MakeUncName(
               _ServerName,
               szHostServerName
               );
        BAIL_ON_FAILURE(hr);
    }

    nasStatus = NetUserChangePassword(
                        szHostServerName,
                        _Name,
                        bstrOldPassword,
                        bstrNewPassword
                        );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);


error:

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cschema.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cschema.cxx
//
//  Contents:  Windows NT 3.51
//
//
//  History:   01-09-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop



/******************************************************************/
/*  Class CWinNTSchema
/******************************************************************/

DEFINE_IDispatch_Delegating_Implementation(CWinNTSchema)
DEFINE_IADsExtension_Implementation(CWinNTSchema)
DEFINE_IADs_Implementation(CWinNTSchema)

CWinNTSchema::CWinNTSchema()
{
    VariantInit( &_vFilter );

    ENLIST_TRACKING(CWinNTSchema);
}

CWinNTSchema::~CWinNTSchema()
{
    VariantClear( &_vFilter );
    delete _pDispMgr;
}

HRESULT
CWinNTSchema::CreateSchema(
    BSTR   bstrParent,
    BSTR   bstrName,
    DWORD  dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTSchema FAR *pSchema = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSchemaObject( &pSchema );
    BAIL_ON_FAILURE(hr);

    hr = pSchema->InitializeCoreObject(
             bstrParent,
             bstrName,
             SCHEMA_CLASS_NAME,
             NO_SCHEMA,
             CLSID_WinNTSchema,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSchema->_Credentials = Credentials;

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(2 == pSchema->_dwNumComponents) {
            pSchema->_CompClasses[0] = L"Computer";
            pSchema->_CompClasses[1] = L"Schema";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pSchema->InitUmiObject(
             pSchema->_Credentials,
             SchemaClass,
             g_dwSchemaClassTableSize,
             NULL,
             (IUnknown *) (INonDelegatingUnknown *) pSchema,
             NULL,
             IID_IUnknown,
             ppvObj
             );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pSchema->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSchema->Release();

    RRETURN(hr);

error:

    delete pSchema;
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTSchema::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTSchema::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTSchema::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTSchema::NonDelegatingQueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTSchema::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CWinNTSchema::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSchema::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTSchema::ImplicitGetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsContainer methods */

STDMETHODIMP
CWinNTSchema::get_Count(long FAR* retval)
{
    HRESULT hr;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *retval = g_cWinNTClasses + g_cWinNTSyntax;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTSchema::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    if ( !pVar )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    VariantInit( pVar );
    hr = VariantCopy( pVar, &_vFilter );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTSchema::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    hr = VariantCopy( &_vFilter, &Var );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTSchema::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSchema::put_Hints(THIS_ VARIANT Var)
{
    RRETURN_EXP_IF_ERR( E_NOTIMPL);
}

STDMETHODIMP
CWinNTSchema::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    TCHAR szBuffer[MAX_PATH];
    DWORD dwLength = 0;
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN_EXP_IF_ERR(E_ADS_UNKNOWN_OBJECT);
    }

    //
    // Make sure we are not going to overflow the string buffer.
    // +2 for / and \0
    //
    dwLength = wcslen(_ADsPath) + wcslen(RelativeName) + 2;

    if (dwLength > MAX_PATH) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    wcscpy(szBuffer, _ADsPath);

    wcscat(szBuffer, L"/");
    wcscat(szBuffer, RelativeName);

    if (ClassName) {
        //
        // +1 for the ",".
        //
        dwLength += wcslen(ClassName) + 1;
        if (dwLength > MAX_PATH) {
            BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        }
        wcscat(szBuffer,L",");
        wcscat(szBuffer, ClassName);
    }

    hr = ::GetObject(szBuffer, (LPVOID *)ppObject, _Credentials);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTSchema::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IEnumVARIANT *penum = NULL;

    if ( !retval )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CWinNTSchemaEnum::Create( (CWinNTSchemaEnum **)&penum,
                                   _ADsPath,
                                   _Name,
                                   _vFilter,
                                   _Credentials);
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface( IID_IUnknown, (VOID FAR* FAR*)retval );
    BAIL_ON_FAILURE(hr);

    if ( penum )
        penum->Release();

    RRETURN(hr);

error:

    if ( penum )
        delete penum;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTSchema::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSchema::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSchema::CopyHere(THIS_ BSTR SourceName,
                       BSTR NewName,
                       IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSchema::MoveHere(THIS_ BSTR SourceName,
                       BSTR NewName,
                       IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CWinNTSchema::AllocateSchemaObject(CWinNTSchema FAR * FAR * ppSchema)
{
    CWinNTSchema FAR *pSchema = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSchema = new CWinNTSchema();
    if ( pSchema == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pSchema,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsContainer,
                            (IADsContainer *) pSchema,
                            DISPID_NEWENUM );
    BAIL_ON_FAILURE(hr);

    pSchema->_pDispMgr = pDispMgr;
    *ppSchema = pSchema;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSchema;

    RRETURN_EXP_IF_ERR(hr);

}


/******************************************************************/
/*  Class CWinNTClass
/******************************************************************/

DEFINE_IDispatch_Delegating_Implementation(CWinNTClass)
DEFINE_IADsExtension_Implementation(CWinNTClass)
DEFINE_IADs_Implementation(CWinNTClass)

CWinNTClass::CWinNTClass()
    : _pDispMgr( NULL ),
      _aPropertyInfo( NULL ),
      _cPropertyInfo( 0 ),
      _bstrCLSID( NULL ),
      _bstrOID( NULL ),
      _bstrPrimaryInterface( NULL ),
      _fAbstract( FALSE ),
      _fContainer( FALSE ),
      _bstrHelpFileName( NULL ),
      _lHelpFileContext( 0 )
{
    VariantInit( &_vMandatoryProperties );
    VariantInit( &_vOptionalProperties );
    VariantInit( &_vPossSuperiors );
    VariantInit( &_vContainment );
    VariantInit( &_vFilter );

    ENLIST_TRACKING(CWinNTClass);
}

CWinNTClass::~CWinNTClass()
{

    if ( _bstrCLSID ) {
        ADsFreeString( _bstrCLSID );
    }

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrPrimaryInterface ) {
        ADsFreeString( _bstrPrimaryInterface );
    }

    if ( _bstrHelpFileName ) {
        ADsFreeString( _bstrHelpFileName );
    }

    VariantClear( &_vMandatoryProperties );
    VariantClear( &_vOptionalProperties );
    VariantClear( &_vPossSuperiors );
    VariantClear( &_vContainment );
    VariantClear( &_vFilter );

    delete _pDispMgr;
}

HRESULT
CWinNTClass::CreateClass(
    BSTR   bstrParent,
    CLASSINFO *pClassInfo,
    DWORD  dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTClass FAR *pClass = NULL;
    HRESULT hr = S_OK;
    BSTR bstrTmp = NULL;

    hr = AllocateClassObject( &pClass );
    BAIL_ON_FAILURE(hr);

    pClass->_aPropertyInfo = pClassInfo->aPropertyInfo;
    pClass->_cPropertyInfo = pClassInfo->cPropertyInfo;
    pClass->_lHelpFileContext = pClassInfo->lHelpFileContext;
    pClass->_fContainer = (VARIANT_BOOL)pClassInfo->fContainer;
    pClass->_fAbstract = (VARIANT_BOOL)pClassInfo->fAbstract;

    hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pPrimaryInterfaceGUID),
                          &bstrTmp );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrTmp,
                           &pClass->_bstrPrimaryInterface);
    BAIL_ON_FAILURE(hr);

    CoTaskMemFree(bstrTmp);
    bstrTmp = NULL;

    hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pCLSID),
                           &bstrTmp );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrTmp,
                           &pClass->_bstrCLSID );

    BAIL_ON_FAILURE(hr);

    CoTaskMemFree(bstrTmp);
    bstrTmp = NULL;

    hr = ADsAllocString( pClassInfo->bstrOID, &pClass->_bstrOID);
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringList( pClassInfo->bstrMandatoryProperties,
                                    &(pClass->_vMandatoryProperties));
    BAIL_ON_FAILURE(hr);


    hr = MakeVariantFromStringList( pClassInfo->bstrOptionalProperties,
                                    &(pClass->_vOptionalProperties));
    BAIL_ON_FAILURE(hr);


    hr = MakeVariantFromStringList( pClassInfo->bstrPossSuperiors,
                                    &(pClass->_vPossSuperiors));
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringList( pClassInfo->bstrContainment,
                                    &(pClass->_vContainment));
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pClassInfo->bstrHelpFileName,
                           &pClass->_bstrHelpFileName);
    BAIL_ON_FAILURE(hr);

    hr = pClass->InitializeCoreObject(
             bstrParent,
             pClassInfo->bstrName,
             CLASS_CLASS_NAME,
             NO_SCHEMA,
             CLSID_WinNTClass,
             dwObjectState );

    BAIL_ON_FAILURE(hr);

    pClass->_Credentials = Credentials;

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pClass->_dwNumComponents) {
            pClass->_CompClasses[0] = L"Computer";
            pClass->_CompClasses[1] = L"Schema";
            pClass->_CompClasses[2] = L"Class";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pClass->InitUmiObject(
             pClass->_Credentials,
             SchClassClass,
             g_dwSchClassClassTableSize,
             NULL,
             (IUnknown *)(INonDelegatingUnknown *) pClass,
             NULL,
             IID_IUnknown,
             ppvObj,
             pClassInfo
             );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }
 
    hr = pClass->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pClass->Release();

    RRETURN(hr);

error:
    if ( bstrTmp != NULL )
        CoTaskMemFree(bstrTmp);

    delete pClass;
    RRETURN_EXP_IF_ERR(hr);
}

// called by implicit GetInfo from property cache
STDMETHODIMP
CWinNTClass::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTClass::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTClass::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTClass::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTClass::NonDelegatingQueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsClass FAR * ) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsClass))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTClass::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsClass)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CWinNTClass::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTClass::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTClass::ImplicitGetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsClass methods */

STDMETHODIMP
CWinNTClass::get_PrimaryInterface( THIS_ BSTR FAR *pbstrGUID )
{
    HRESULT hr;
    if ( !pbstrGUID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrPrimaryInterface, pbstrGUID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::get_CLSID( THIS_ BSTR FAR *pbstrCLSID )
{
    HRESULT hr;
    if ( !pbstrCLSID )
        RRETURN(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrCLSID, pbstrCLSID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_CLSID( THIS_ BSTR bstrCLSID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    HRESULT hr;
    if ( !pbstrOID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrOID, pbstrOID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_Abstract( THIS_ VARIANT_BOOL FAR *pfAbstract )
{
    if ( !pfAbstract )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfAbstract = _fAbstract? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTClass::put_Abstract( THIS_ VARIANT_BOOL fAbstract )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_Auxiliary( THIS_ VARIANT_BOOL FAR *pfAuxiliary)
{
    if ( !pfAuxiliary )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfAuxiliary = VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTClass::put_Auxiliary( THIS_ VARIANT_BOOL fAuxiliary )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_MandatoryProperties( THIS_ VARIANT FAR *pvMandatoryProperties )
{
    HRESULT hr;
    VariantInit( pvMandatoryProperties );
    hr = VariantCopy( pvMandatoryProperties, &_vMandatoryProperties );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_MandatoryProperties( THIS_ VARIANT vMandatoryProperties )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_DerivedFrom( THIS_ VARIANT FAR *pvDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::put_DerivedFrom( THIS_ VARIANT vDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_AuxDerivedFrom( THIS_ VARIANT FAR *pvAuxDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::put_AuxDerivedFrom( THIS_ VARIANT vAuxDerivedFrom )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_PossibleSuperiors( THIS_ VARIANT FAR *pvPossSuperiors )
{
    HRESULT hr;
    VariantInit( pvPossSuperiors );
    hr = VariantCopy( pvPossSuperiors, &_vPossSuperiors );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_PossibleSuperiors( THIS_ VARIANT vPossSuperiors )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_Containment( THIS_ VARIANT FAR *pvContainment )
{
    HRESULT hr;
    VariantInit( pvContainment );
    hr = VariantCopy( pvContainment, &_vContainment );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_Containment( THIS_ VARIANT vContainment )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_Container( THIS_ VARIANT_BOOL FAR *pfContainer )
{
    if ( !pfContainer )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfContainer = _fContainer? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTClass::put_Container( THIS_ VARIANT_BOOL fContainer )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_HelpFileName( THIS_ BSTR FAR *pbstrHelpFileName )
{
    HRESULT hr;
    if ( !pbstrHelpFileName )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrHelpFileName, pbstrHelpFileName );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_HelpFileName( THIS_ BSTR bstrHelpFile )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::get_HelpFileContext( THIS_ long FAR *plHelpContext )
{
    if ( !plHelpContext )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plHelpContext = _lHelpFileContext;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTClass::put_HelpFileContext( THIS_ long lHelpContext )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTClass::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CWinNTClass::AllocateClassObject(CWinNTClass FAR * FAR * ppClass)
{

    CWinNTClass FAR  *pClass = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pClass = new CWinNTClass();
    if ( pClass == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsClass,
                            (IADsClass *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pClass->_pDispMgr = pDispMgr;
    *ppClass = pClass;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pClass;

    RRETURN(hr);

}


/******************************************************************/
/*  Class CWinNTProperty
/******************************************************************/

DEFINE_IDispatch_Delegating_Implementation(CWinNTProperty)
DEFINE_IADsExtension_Implementation(CWinNTProperty)
DEFINE_IADs_Implementation(CWinNTProperty)

CWinNTProperty::CWinNTProperty()
    : _pDispMgr( NULL ),
      _bstrOID( NULL ),
      _bstrSyntax( NULL ),
      _lMaxRange( 0 ),
      _lMinRange( 0 ),
      _fMultiValued( FALSE )
{

    ENLIST_TRACKING(CWinNTProperty);
}

CWinNTProperty::~CWinNTProperty()
{

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrSyntax ) {
        ADsFreeString( _bstrSyntax );
    }

    delete _pDispMgr;
}

HRESULT
CWinNTProperty::CreateProperty(
    BSTR   bstrParent,
    PROPERTYINFO *pPropertyInfo,
    DWORD  dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTProperty FAR * pProperty = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePropertyObject( &pProperty );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pPropertyInfo->bstrOID, &pProperty->_bstrOID);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( pPropertyInfo->bstrSyntax, &pProperty->_bstrSyntax);
    BAIL_ON_FAILURE(hr);

    pProperty->_lMaxRange = pPropertyInfo->lMaxRange;
    pProperty->_lMinRange = pPropertyInfo->lMinRange;
    pProperty->_fMultiValued  = (VARIANT_BOOL)pPropertyInfo->fMultiValued;

    hr = pProperty->InitializeCoreObject(
             bstrParent,
             pPropertyInfo->szPropertyName,
             PROPERTY_CLASS_NAME,
             NO_SCHEMA,
             CLSID_WinNTProperty,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pProperty->_Credentials = Credentials;

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pProperty->_dwNumComponents) {
            pProperty->_CompClasses[0] = L"Computer";
            pProperty->_CompClasses[1] = L"Schema";
            pProperty->_CompClasses[2] = L"Property";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pProperty->InitUmiObject(
             pProperty->_Credentials,
             PropertyClass,
             g_dwPropertyClassTableSize,
             NULL,
             (IUnknown *)(INonDelegatingUnknown *) pProperty,
             NULL,
             IID_IUnknown,
             ppvObj
             );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pProperty->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pProperty->Release();

    RRETURN(hr);

error:

    delete pProperty;
    RRETURN_EXP_IF_ERR(hr);
}

// called by implicit GetInfo from property cache
STDMETHODIMP
CWinNTProperty::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTProperty::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTProperty::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTProperty::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTProperty::NonDelegatingQueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsProperty))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTProperty::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsProperty)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CWinNTProperty::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTProperty::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTProperty::ImplicitGetInfo(THIS)
{
    RRETURN(S_OK);
}

/* IADsProperty methods */


STDMETHODIMP
CWinNTProperty::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    HRESULT hr;
    if ( !pbstrOID )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrOID, pbstrOID );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTProperty::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTProperty::get_Syntax( THIS_ BSTR FAR *pbstrSyntax )
{
    HRESULT hr;
    if ( !pbstrSyntax )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    hr = ADsAllocString( _bstrSyntax, pbstrSyntax );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTProperty::put_Syntax( THIS_ BSTR bstrSyntax )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTProperty::get_MaxRange( THIS_ long FAR *plMaxRange )
{
    if ( !plMaxRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMaxRange = _lMaxRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTProperty::put_MaxRange( THIS_ long lMaxRange )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTProperty::get_MinRange( THIS_ long FAR *plMinRange )
{
    if ( !plMinRange )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plMinRange = _lMinRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTProperty::put_MinRange( THIS_ long lMinRange )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTProperty::get_MultiValued( THIS_ VARIANT_BOOL FAR *pfMultiValued )
{
    if ( !pfMultiValued )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *pfMultiValued = _fMultiValued? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTProperty::put_MultiValued( THIS_ VARIANT_BOOL fMultiValued )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTProperty::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CWinNTProperty::AllocatePropertyObject(CWinNTProperty FAR * FAR * ppProperty)
{
    CWinNTProperty FAR *pProperty = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pProperty = new CWinNTProperty();
    if ( pProperty == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsProperty,
                            (IADsProperty *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pProperty->_pDispMgr = pDispMgr;
    *ppProperty = pProperty;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pProperty;

    RRETURN(hr);

}


/******************************************************************/
/*  Class CWinNTSyntax
/******************************************************************/

DEFINE_IDispatch_Delegating_Implementation(CWinNTSyntax)
DEFINE_IADsExtension_Implementation(CWinNTSyntax)
DEFINE_IADs_Implementation(CWinNTSyntax)

CWinNTSyntax::CWinNTSyntax()
{
    ENLIST_TRACKING(CWinNTSyntax);
}

CWinNTSyntax::~CWinNTSyntax()
{
    delete _pDispMgr;
}

HRESULT
CWinNTSyntax::CreateSyntax(
    BSTR   bstrParent,
    SYNTAXINFO *pSyntaxInfo,
    DWORD  dwObjectState,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTSyntax FAR *pSyntax = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSyntaxObject( &pSyntax );
    BAIL_ON_FAILURE(hr);

    hr = pSyntax->InitializeCoreObject(
             bstrParent,
             pSyntaxInfo->bstrName,
             SYNTAX_CLASS_NAME,
             NO_SCHEMA,
             CLSID_WinNTSyntax,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSyntax->_lOleAutoDataType = pSyntaxInfo->lOleAutoDataType;

    pSyntax->_Credentials = Credentials;

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pSyntax->_dwNumComponents) {
            pSyntax->_CompClasses[0] = L"Computer";
            pSyntax->_CompClasses[1] = L"Schema";
            pSyntax->_CompClasses[2] = L"Syntax";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pSyntax->InitUmiObject(
             pSyntax->_Credentials,
             SyntaxClass,
             g_dwSyntaxTableSize,
             NULL,
             (IUnknown *)(INonDelegatingUnknown *) pSyntax,
             NULL,
             IID_IUnknown,
             ppvObj
             );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pSyntax->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSyntax->Release();

    RRETURN(hr);

error:

    delete pSyntax;
    RRETURN_EXP_IF_ERR(hr);
}

// called by implicit GetInfo from property cache
STDMETHODIMP
CWinNTSyntax::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTSyntax::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTSyntax::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTSyntax::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTSyntax::NonDelegatingQueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSyntax))
    {
        *ppv = (IADsSyntax FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTSyntax::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsSyntax)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CWinNTSyntax::SetInfo(THIS)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTSyntax::GetInfo(THIS)
{
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTSyntax::ImplicitGetInfo(THIS)
{
    RRETURN(S_OK);
}

HRESULT
CWinNTSyntax::AllocateSyntaxObject(CWinNTSyntax FAR * FAR * ppSyntax)
{
    CWinNTSyntax FAR *pSyntax = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSyntax = new CWinNTSyntax();
    if ( pSyntax == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry( pDispMgr,
                            LIBID_ADs,
                            IID_IADsSyntax,
                            (IADsSyntax *) pSyntax,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pSyntax->_pDispMgr = pDispMgr;
    *ppSyntax = pSyntax;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSyntax;

    RRETURN(hr);

}

STDMETHODIMP
CWinNTSyntax::get_OleAutoDataType( THIS_ long FAR *plOleAutoDataType )
{
    if ( !plOleAutoDataType )
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    *plOleAutoDataType = _lOleAutoDataType;
    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTSyntax::put_OleAutoDataType( THIS_ long lOleAutoDataType )
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


/******************************************************************/
/*  Misc Helpers
/******************************************************************/

HRESULT
MakeVariantFromStringList(
    BSTR bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    BSTR pszTempList = NULL;

    if ( bstrList != NULL )
    {
        long i = 0;
        long nCount = 1;
        TCHAR c;
        BSTR pszSrc;

        hr = ADsAllocString( bstrList, &pszTempList );
        BAIL_ON_FAILURE(hr);

        while ( c = pszTempList[i] )
        {
            if ( c == TEXT(','))
            {
                pszTempList[i] = 0;
                nCount++;
            }

            i++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszSrc = pszTempList;

        for ( i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            hr = ADsAllocString( pszSrc, &(V_BSTR(&v)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszSrc += _tcslen( pszSrc ) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

        ADsFreeString( pszTempList );
        pszTempList = NULL;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    RRETURN(S_OK);

error:

    if ( pszTempList )
        ADsFreeString( pszTempList );

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}


STDMETHODIMP
CWinNTClass::get_OptionalProperties( THIS_ VARIANT FAR *retval )
{
    HRESULT hr;
    VariantInit( retval );
    hr = VariantCopy( retval, &_vOptionalProperties );
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::put_OptionalProperties( THIS_ VARIANT vOptionalProperties )
{

    HRESULT hr = E_NOTIMPL;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTClass::get_NamingProperties( THIS_ VARIANT FAR *retval )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTClass::put_NamingProperties( THIS_ VARIANT vNamingProperties )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cubi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cubi.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//      PROPERTY_RW(Address, VARIANT, 1)                NI
//      PROPERTY_RW(Department, BSTR, 3)                NI
//      PROPERTY_RW(Division, BSTR, 5)                  NI
//      PROPERTY_RW(EmployeeID, BSTR, 6)                NI
//      PROPERTY_RW(FaxNumber, BSTR, 7)                 NI
//      PROPERTY_RW(FirstName, BSTR, 8)                 Implemented
//      PROPERTY_RW(FullName, BSTR, 9)                  NI
//      PROPERTY_RW(Initials, BSTR, 10)                 NI
//      PROPERTY_RW(LastName, BSTR, 11)                 NI
//      PROPERTY_RW(Manager, BSTR, 12)                  NI
//      PROPERTY_RW(NickName, BSTR, 13)                 NI
//      PROPERTY_RW(OfficeLocation, BSTR, 14)           NI
//      PROPERTY_RW(Picture, VARIANT, 51)               NI
//      PROPERTY_RW(TelephoneHome, VARIANT, 18)         NI
//      PROPERTY_RW(TelephoneMobile, VARIANT, 19)       NI
//      PROPERTY_RW(TelephoneNumber, VARIANT, 20)       NI
//      PROPERTY_RW(FaxNumber, VARIANT, 2)              NI
//      PROPERTY_RW(Title, BSTR, 19)
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


STDMETHODIMP
CWinNTUser::get_Description(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Description);
}

STDMETHODIMP
CWinNTUser::put_Description(THIS_ BSTR bstrDescription)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Description);
}

STDMETHODIMP
CWinNTUser::get_Department(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CWinNTUser::put_Department(THIS_ BSTR bstrDepartment)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Department);
}

STDMETHODIMP
CWinNTUser::get_Division(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CWinNTUser::put_Division(THIS_ BSTR bstrDivision)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Division);
}

STDMETHODIMP
CWinNTUser::get_EmployeeID(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}

STDMETHODIMP
CWinNTUser::put_EmployeeID(THIS_ BSTR bstrEmployeeID)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmployeeID);
}


STDMETHODIMP
CWinNTUser::get_FirstName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CWinNTUser::put_FirstName(THIS_ BSTR bstrFirstName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FirstName);
}

STDMETHODIMP
CWinNTUser::get_FullName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CWinNTUser::put_FullName(THIS_ BSTR bstrFullName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CWinNTUser::get_LastName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CWinNTUser::put_LastName(THIS_ BSTR bstrLastName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LastName);
}

STDMETHODIMP
CWinNTUser::get_Manager(THIS_ BSTR FAR* retval)
{
     GET_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CWinNTUser::put_Manager(THIS_ BSTR bstrManager)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Manager);
}

STDMETHODIMP
CWinNTUser::get_OfficeLocations(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, OfficeLocation);
}

STDMETHODIMP
CWinNTUser::put_OfficeLocations(THIS_ VARIANT vOfficeLocation)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, OfficeLocation);
}

STDMETHODIMP
CWinNTUser::get_Picture(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, Picture);
}

STDMETHODIMP
CWinNTUser::put_Picture(THIS_ VARIANT vPicture)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, Picture);
}

STDMETHODIMP
CWinNTUser::get_PostalAddresses(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CWinNTUser::put_PostalAddresses(THIS_ VARIANT vPostalAddresses)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalAddresses);
}

STDMETHODIMP
CWinNTUser::get_PostalCodes(THIS_ VARIANT FAR* retval)
{
   GET_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CWinNTUser::put_PostalCodes(THIS_ VARIANT vPostalCodes)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, PostalCodes);
}

STDMETHODIMP
CWinNTUser::get_TelephoneNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CWinNTUser::put_TelephoneNumber(THIS_ VARIANT vTelephoneNumber)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneNumber);
}

STDMETHODIMP
CWinNTUser::get_TelephoneHome(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CWinNTUser::put_TelephoneHome(THIS_ VARIANT vTelephoneHome)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneHome);
}

STDMETHODIMP
CWinNTUser::get_TelephoneMobile(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CWinNTUser::put_TelephoneMobile(THIS_ VARIANT vTelephoneMobile)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephoneMobile);
}

STDMETHODIMP
CWinNTUser::get_TelephonePager(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CWinNTUser::put_TelephonePager(THIS_ VARIANT vTelephonePager)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, TelephonePager);
}

STDMETHODIMP
CWinNTUser::get_FaxNumber(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CWinNTUser::put_FaxNumber(THIS_ VARIANT vFaxNumber)
{
   PUT_PROPERTY_VARIANT((IADsUser *)this, FaxNumber);
}

STDMETHODIMP
CWinNTUser::get_Title(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Title);
}

STDMETHODIMP
CWinNTUser::put_Title(THIS_ BSTR bstrTitle)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Title);
}

STDMETHODIMP CWinNTUser::get_HomePage(THIS_ BSTR FAR* retval)
{

    GET_PROPERTY_BSTR((IADsUser *)this,HomePage);
}
STDMETHODIMP CWinNTUser::put_HomePage(THIS_ BSTR bstrHomePage)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, HomePage);
}

STDMETHODIMP CWinNTUser::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, SeeAlso);
}
STDMETHODIMP CWinNTUser::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{

    PUT_PROPERTY_VARIANT((IADsUser *)this, SeeAlso);
}

STDMETHODIMP CWinNTUser::get_NamePrefix(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, NamePrefix);
}
STDMETHODIMP CWinNTUser::put_NamePrefix(THIS_ BSTR bstrNamePrefix)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, NamePrefix);
}
STDMETHODIMP CWinNTUser::get_NameSuffix(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, NameSuffix);
}

STDMETHODIMP CWinNTUser::put_NameSuffix(THIS_ BSTR bstrNamePrefix)
{
    PUT_PROPERTY_BSTR((IADsUser *)this,NamePrefix);
}

STDMETHODIMP CWinNTUser::get_OtherName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, OtherName);
}
STDMETHODIMP CWinNTUser::put_OtherName(THIS_ BSTR bstrOtherName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, OtherName);
}

STDMETHODIMP
CWinNTUser::Groups(THIS_ IADsMembers FAR* FAR* ppGroups)
{
    HRESULT hr;
    WCHAR szHostServerName[MAX_PATH];

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (_ParentType == WINNT_DOMAIN_ID) {
        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()  
                    );
        BAIL_ON_FAILURE(hr);
    }

    hr = CWinNTUserGroupsCollection::CreateUserGroupsCollection(
                    _ParentType,
                    _Parent,
                    _DomainName,

                    _ParentType == WINNT_DOMAIN_ID ?
                    (szHostServerName + 2) :
                    _ServerName,

                    _Name,
                    IID_IADsMembers,
                    _Credentials,
                    (void **)ppGroups
        );

error:

    RRETURN_EXP_IF_ERR(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cserv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:  cserv.cxx
//
//  Contents:  Contains methods for the following objects
//             CWinNTService,
//
//  History:   12/11/95     ramv (Ram Viswanathan)    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID





//
// class CWinNTService methods
//

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTService);
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTService);
DEFINE_IADs_TempImplementation(CWinNTService);
DEFINE_IADs_PutGetImplementation(CWinNTService,ServiceClass,gdwServiceTableSize);
DEFINE_IADsPropertyList_Implementation(CWinNTService, ServiceClass,gdwServiceTableSize)

CWinNTService::CWinNTService()
{
    _pDispMgr = NULL;
    _pExtMgr = NULL;
    _pPropertyCache = NULL;

    _pszServiceName   = NULL;
    _pszServerName    = NULL;
    _pszPath          = NULL;

    _schSCManager      = NULL;
    _schService        = NULL;
    _dwWaitHint        = 0;
    _dwCheckPoint      = 0;
    _fValidHandle      = FALSE;

    ENLIST_TRACKING(CWinNTService);
}

CWinNTService::~CWinNTService()
{
    if(_fValidHandle){
        //
        // an open handle exists, blow it away
        //
        WinNTCloseService();
        _fValidHandle = FALSE;
    }

    if(_pszServiceName){
        FreeADsStr(_pszServiceName);
    }

    if(_pszServerName){
        FreeADsStr(_pszServerName);
    }

    if(_pszPath){
        FreeADsStr(_pszPath);
    }

    delete _pExtMgr;            // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::Create
//
//  Synopsis:   Static function used to create a Service object. This
//              will be called by BindToObject
//
//  Arguments:  [ppWinNTService] -- Ptr to a ptr to a new Service object.
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12-11-95 RamV   Created.
//
//----------------------------------------------------------------------------

HRESULT
CWinNTService::Create(LPTSTR pszADsParent,
                      LPTSTR pszDomainName,
                      LPTSTR pszServerName,
                      LPTSTR pszServiceName,
                      DWORD  dwObjectState,
                      REFIID riid,
                      CWinNTCredentials& Credentials,
                      LPVOID * ppvoid
                      )

{
    CWinNTService FAR * pCWinNTService = NULL;
    HRESULT hr;

    //
    // Create the Service Object
    //


    hr = AllocateServiceObject(pszServerName,
                               pszServiceName,
                               &pCWinNTService);

    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTService->_pDispMgr);


    hr = pCWinNTService->InitializeCoreObject(pszADsParent,
                                              pszServiceName,
                                              SERVICE_CLASS_NAME,
                                              SERVICE_SCHEMA_NAME,
                                              CLSID_WinNTService,
                                              dwObjectState);

    BAIL_ON_FAILURE(hr);

    hr = SetLPTSTRPropertyInCache(pCWinNTService->_pPropertyCache,
                                  TEXT("HostComputer"),
                                  pCWinNTService->_Parent,
                                  TRUE
                                  );

    BAIL_ON_FAILURE(hr);

    pCWinNTService->_Credentials = Credentials;
    hr = pCWinNTService->_Credentials.RefServer(pszServerName);
    BAIL_ON_FAILURE(hr);


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                SERVICE_CLASS_NAME,
                (IADsService *) pCWinNTService,
                pCWinNTService->_pDispMgr,
                Credentials,
                &pCWinNTService->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pCWinNTService->_pExtMgr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where
    // riid passed into this function is defaulted to IID_IDispatch -
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI
    // will QI for the appropriate interface.
    //
        if(3 == pCWinNTService->_dwNumComponents) {
            pCWinNTService->_CompClasses[0] = L"Domain";
            pCWinNTService->_CompClasses[1] = L"Computer";
            pCWinNTService->_CompClasses[2] = L"Service";
        }
        else if(2 == pCWinNTService->_dwNumComponents) {
        // no workstation services
            pCWinNTService->_CompClasses[0] = L"Computer";
            pCWinNTService->_CompClasses[1] = L"Service";
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);
 
        hr = pCWinNTService->InitUmiObject(
                pCWinNTService->_Credentials,
                ServiceClass,
                gdwServiceTableSize,
                pCWinNTService->_pPropertyCache,
                (IUnknown *)(INonDelegatingUnknown *) pCWinNTService,
                pCWinNTService->_pExtMgr,
                IID_IUnknown,
                ppvoid
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr);
    }

    hr = pCWinNTService->QueryInterface(riid, (void **)ppvoid);
    BAIL_ON_FAILURE(hr);

    pCWinNTService->Release();

    RRETURN(hr);

error:

    delete pCWinNTService;
    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTService::AllocateServiceObject(
    LPTSTR pszServerName,
    LPTSTR pszServiceName,
    CWinNTService ** ppService
    )
{
    CWinNTService FAR * pService = NULL;
    HRESULT hr = S_OK;

    pService = new CWinNTService();
    if (pService == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pService->_pDispMgr = new CAggregatorDispMgr;
    if (pService->_pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);


    pService->_pszServerName =
        AllocADsStr(pszServerName);

    if(!(pService->_pszServerName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }


    pService->_pszServiceName =
        AllocADsStr(pszServiceName);

    if(!(pService->_pszServiceName)){
        hr = E_OUTOFMEMORY;
        goto error;
    }

    hr = LoadTypeInfoEntry(pService->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsService,
                           (IADsService *)pService,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pService->_pDispMgr,
                           LIBID_ADs,
                           IID_IADsServiceOperations,
                           (IADsServiceOperations *)pService,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);


    hr = CPropertyCache::createpropertycache(
             ServiceClass,
             gdwServiceTableSize,
             (CCoreADsObject *)pService,
             &(pService->_pPropertyCache)
             );

    BAIL_ON_FAILURE(hr);


    (pService->_pDispMgr)->RegisterPropertyCache(
                            pService->_pPropertyCache
                            );

    *ppService = pService;

    RRETURN(hr);

error:

    //
    // direct memeber assignement assignement at pt of creation, so
    // do NOT delete _pPropertyCache or _pDisMgr here to avoid attempt
    // of deletion again in pPrintJob destructor and AV
    //

    delete pService;

    RRETURN(hr);

}



/* IUnknown methods for service object  */

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTService::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTService::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTService::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTService::NonDelegatingQueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hr = S_OK;

    if(!ppvObj){
        RRETURN(E_POINTER);
    }
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IADsService *)this;
    }

    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = (IADsService *)this;
    }

    else if (IsEqualIID(riid, IID_ISupportErrorInfo))
    {
        *ppvObj = (ISupportErrorInfo FAR *)this;
    }
    else if (IsEqualIID(riid, IID_IADsPropertyList))
    {
        *ppvObj = (IADsPropertyList *)this;
    }
    else if (IsEqualIID(riid, IID_IADs))
    {
        *ppvObj = (IADsService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsService))
    {
        *ppvObj = (IADsService FAR *) this;
    }
    else if (IsEqualIID(riid, IID_IADsServiceOperations))
    {
        *ppvObj = (IADsServiceOperations FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(riid, IID_IADsExtension) )
    {
        *ppvObj = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN( _pExtMgr->QueryInterface(riid, ppvObj));
    }
    else
    {
        *ppvObj = NULL;
        RRETURN(E_NOINTERFACE);
    }
    ((LPUNKNOWN)*ppvObj)->AddRef();
    RRETURN(S_OK);
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTService::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsService) ||
        IsEqualIID(riid, IID_IADsServiceOperations) ||
        IsEqualIID(riid, IID_IADsPropertyList)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SetInfo
//
//  Synopsis:
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:        RamV  Created
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTService::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    DWORD dwServiceType;
    DWORD dwStartType;
    DWORD dwErrorControl;
    LPTSTR  pszPath = NULL;
    LPTSTR  pszLoadOrderGroup = NULL;
    LPTSTR  pszServiceStartName = NULL;
    LPTSTR  pszDependencies = NULL;
    LPTSTR  pszDisplayName  = NULL;
    SC_LOCK sclLock = NULL;
    BOOL fRetval = FALSE;
    LPQUERY_SERVICE_CONFIG lpqServiceConfig = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = WinNTAddService();
        BAIL_IF_ERROR(hr);

        SetObjectState(ADS_OBJECT_BOUND);

    }



    hr = WinNTOpenService(SC_MANAGER_ALL_ACCESS,
                          SERVICE_ALL_ACCESS);

    BAIL_IF_ERROR(hr);

    hr = GetServiceConfigInfo(&lpqServiceConfig);

    BAIL_IF_ERROR(hr);

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Path"),
                    &pszPath
                    );
    if(SUCCEEDED(hr)){
        lpqServiceConfig->lpBinaryPathName = pszPath;
    }

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("LoadOrderGroup"),
                    &pszLoadOrderGroup
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->lpLoadOrderGroup = pszLoadOrderGroup;
    }

    hr = GetNulledStringPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Dependencies"),
                    &pszDependencies
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->lpDependencies = pszDependencies;
    }


    //
    // Issue: Service Account Name property has been disabled from being a
    // writeable property because ChangeServiceConfig AVs services.exe
    // on the server machine when this property is changed
    // RamV - Aug-11-96.

    /*

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("ServiceAccountName"),
                    &pszServiceStartName
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->lpServiceStartName = pszServiceStartName;
    }

    */

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("DisplayName"),
                    &pszDisplayName
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->lpDisplayName = pszDisplayName;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("ServiceType"),
                    &dwServiceType
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->dwServiceType = dwServiceType;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("StartType"),
                    &dwStartType
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->dwStartType = dwStartType;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("ErrorControl"),
                    &dwErrorControl
                    );
    if(SUCCEEDED(hr)){

        lpqServiceConfig->dwErrorControl = dwErrorControl;
    }


    //
    // set hr to S_OK. why? we dont care about the errors we hit so far
    //

    hr = S_OK;

    //
    // put a lock on the database corresponding to this service
    //

    sclLock = LockServiceDatabase(_schSCManager);

    if(sclLock == NULL){
        //
        // Exit if database cannot be locked
        //
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    //
    // change the service configuration. Pass in all the changed parameters.
    // Since there is but one info level for services, use the
    // internal values as parameters.
    //

    fRetval = ChangeServiceConfig(_schService,
                                  lpqServiceConfig->dwServiceType,
                                  lpqServiceConfig->dwStartType,
                                  lpqServiceConfig->dwErrorControl,
                                  lpqServiceConfig->lpBinaryPathName,
                                  lpqServiceConfig->lpLoadOrderGroup,
                                  NULL,
                                  lpqServiceConfig->lpDependencies,
                                  lpqServiceConfig->lpServiceStartName,
                                  NULL,
                                  lpqServiceConfig->lpDisplayName
                                  );

    if (fRetval == FALSE)  {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

cleanup:

    if(lpqServiceConfig){
        FreeADsMem(lpqServiceConfig);
    }

    if(sclLock){
        UnlockServiceDatabase(sclLock);
    }

    WinNTCloseService();

    if(pszPath){
        FreeADsStr(pszPath);
    }

    if(pszLoadOrderGroup){
        FreeADsStr(pszLoadOrderGroup);
    }
    if(pszServiceStartName){
        FreeADsStr(pszServiceStartName);
    }
    if(pszDependencies){
        FreeADsStr(pszDependencies);
    }
    if(pszDisplayName){
        FreeADsStr(pszDisplayName);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetInfo
//
//  Synopsis:   Currently implemented
//
//  Arguments:  void
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    12/11/95    RamV  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTService::GetInfo(THIS)
{

    RRETURN (GetInfo(1, TRUE));

}

STDMETHODIMP
CWinNTService::ImplicitGetInfo(THIS)
{

    RRETURN (GetInfo(1, FALSE));

}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::GetInfo
//
//  Synopsis:   Binds to real Service as specified in _ServiceName and
//              attempts to refresh the Service object from the real Service.
//
//  Arguments:  dwApiLevel (ignored),  fExplicit (ignored)
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/08/96    RamV  Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTService::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    HRESULT                 hr;
    LPQUERY_SERVICE_CONFIG  pMem = NULL;
    BYTE                    FastConfigInfo[256];
    SERVICE_STATUS          ssStatusInfo;
    DWORD                   dwBufAllocated = 256;
    DWORD                   dwBufNeeded;
    DWORD                   dwLastError;
    BOOL                    fRetval;

    //
    // GETTING NT SERVICE INFO
    //
    // Getting information about an NT service requires three calls.
    // One to get configuration information, and one to get current
    // status information, and one to get security information.
    //

    //
    // Open the service
    //


    hr = WinNTOpenService(SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS,
                          GENERIC_READ );

    if (FAILED(hr))  {
        RRETURN_EXP_IF_ERR(hr);
    }

    //
    // Query for Service Status first.
    //
    fRetval = QueryServiceStatus(_schService,
                                 &ssStatusInfo );

    if (fRetval == FALSE)  {
        hr = HRESULT_FROM_WIN32(GetLastError());

        WinNTCloseService();
        goto cleanup;
    }

    fRetval = QueryServiceConfig(_schService,
                                 (LPQUERY_SERVICE_CONFIG)FastConfigInfo,
                                 dwBufAllocated,
                                 &dwBufNeeded
                                 );

    if (fRetval == FALSE)  {
        dwLastError = GetLastError();
        switch (dwLastError)  {
        case ERROR_INSUFFICIENT_BUFFER:
            //
            // Allocate more memory and try again.
            //
            dwBufAllocated = dwBufNeeded;
            pMem = (LPQUERY_SERVICE_CONFIG)AllocADsMem(dwBufAllocated);
            if (pMem == NULL)  {
                hr = E_OUTOFMEMORY;
                break;
            }

            fRetval = QueryServiceConfig(_schService,
                                         pMem,
                                         dwBufAllocated,
                                         &dwBufNeeded
                                         );

            if (fRetval == FALSE)  {
                WinNTCloseService();

                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
            break;

        default:
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;

        }
        if(FAILED(hr)){
            WinNTCloseService();
            goto cleanup;
        }
    }

    WinNTCloseService();

    //
    // clear all properties from cache first if explicit GetInfo
    //
    if (fExplicit) {
        _pPropertyCache->flushpropcache();
    }

    if(pMem){
        hr =  UnMarshall(pMem, fExplicit);
        BAIL_IF_ERROR(hr);
    }else{
        hr = UnMarshall((LPQUERY_SERVICE_CONFIG) FastConfigInfo, fExplicit);
        BAIL_IF_ERROR(hr);
    }
cleanup:
    if(pMem)
        FreeADsMem(pMem);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTService::UnMarshall(THIS_ LPQUERY_SERVICE_CONFIG lpConfigInfo,
                          BOOL fExplicit)
{
    DWORD dwADsServiceType;
    DWORD dwADsStartType;
    DWORD dwADsErrorControl;
    HRESULT hr;

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Path"),
                                  lpConfigInfo->lpBinaryPathName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("LoadOrderGroup"),
                                  lpConfigInfo->lpLoadOrderGroup,
                                  fExplicit
                                  );



    hr = SetNulledStringPropertyInCache(_pPropertyCache,
                                  TEXT("Dependencies"),
                                  lpConfigInfo->lpDependencies,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("ServiceAccountName"),
                                  lpConfigInfo->lpServiceStartName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("DisplayName"),
                                  lpConfigInfo->lpDisplayName,
                                  fExplicit
                                  );


    //
    // 0x133 is the bit mask for valid values of ADs ServiceTypes
    //

    dwADsServiceType = lpConfigInfo->dwServiceType & 0x133;

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("ServiceType"),
                                 dwADsServiceType ,
                                 fExplicit
                                 );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("StartType"),
                                 lpConfigInfo->dwStartType,
                                 fExplicit
                                 );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                 TEXT("ErrorControl"),
                                 lpConfigInfo->dwErrorControl,
                                 fExplicit
                                 );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    RRETURN_EXP_IF_ERR(hr);
}

//
// helper function  WinNTAddService
//


HRESULT
CWinNTService::WinNTAddService(void)
{
    HRESULT hr = S_OK;
    SC_HANDLE schService = NULL;
    SC_HANDLE schSCManager = NULL;
    TCHAR szServerName[MAX_PATH];
    BOOL fRetval;
    LPTSTR pszDisplayName = NULL;
    LPTSTR pszPath = NULL;
    LPTSTR pszLoadOrderGroup = NULL;
    DWORD  dwServiceType;
    DWORD  dwStartType;
    DWORD  dwErrorControl;

    hr = GetServerFromPath(_ADsPath,szServerName);

    BAIL_IF_ERROR(hr);

    //
    // open the SCM for this server
    //

    schSCManager = OpenSCManager(szServerName,
                                 NULL,
                                 SC_MANAGER_ALL_ACCESS);

    if(schSCManager == NULL){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("DisplayName"),
                    &pszDisplayName
                    );


    BAIL_IF_ERROR(hr);

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("ServiceType"),
                    &dwServiceType
                    );

    BAIL_IF_ERROR(hr);

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("StartType"),
                    &dwStartType
                    );

    BAIL_IF_ERROR(hr);

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("ErrorControl"),
                    &dwErrorControl
                    );

    BAIL_IF_ERROR(hr);

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Path"),
                    &pszPath
                    );

    BAIL_IF_ERROR(hr);

    schService = CreateService(schSCManager,
                               _pszServiceName,
                               pszDisplayName,
                               SERVICE_ALL_ACCESS,
                               dwServiceType,
                               dwStartType,
                               dwErrorControl,
                               pszPath,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               NULL );

    if(schService == NULL){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

cleanup:
    if(schSCManager){
        fRetval = CloseServiceHandle(schSCManager);
        if(!fRetval && SUCCEEDED(hr)){
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    if(schService){
        fRetval = CloseServiceHandle(schService);
        if(!fRetval && SUCCEEDED(hr)){
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    if(pszDisplayName){
        FreeADsStr(pszDisplayName);
    }

    if(pszPath){
        FreeADsStr(pszPath);
    }

    if(pszLoadOrderGroup){
        FreeADsStr(pszLoadOrderGroup);
    }

    RRETURN(hr);
}

STDMETHODIMP
CWinNTService::get_HostComputer(THIS_ BSTR FAR* retval)
{
    HRESULT hr;
    if(!retval){
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }
    hr = ADsAllocString(_Parent, retval);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTService::put_HostComputer(THIS_ BSTR bstrHostComputer)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTService::get_DisplayName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsService *)this,  DisplayName);
}

STDMETHODIMP
CWinNTService::put_DisplayName(THIS_ BSTR bstrDisplayName)
{
    PUT_PROPERTY_BSTR((IADsService *)this,  DisplayName);

}

STDMETHODIMP
CWinNTService::get_Version(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsService *)this,  Version);

}

STDMETHODIMP
CWinNTService::put_Version(THIS_ BSTR bstrVersion)
{
    PUT_PROPERTY_BSTR((IADsService *)this,  Version);
}

STDMETHODIMP
CWinNTService::get_ServiceType(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsService *)this, ServiceType);
}

STDMETHODIMP
CWinNTService::put_ServiceType(THIS_ long lServiceType)
{
    PUT_PROPERTY_LONG((IADsService *)this, ServiceType);
}

STDMETHODIMP
CWinNTService::get_StartType(THIS_ LONG FAR* retval)
{
    GET_PROPERTY_LONG((IADsService *)this, StartType);
}

STDMETHODIMP
CWinNTService::put_StartType(THIS_ LONG lStartType)
{
    PUT_PROPERTY_LONG((IADsService *)this, StartType);
}

STDMETHODIMP
CWinNTService::get_Path(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsService *)this,  Path);
}

STDMETHODIMP
CWinNTService::put_Path(THIS_ BSTR bstrPath)
{

    PUT_PROPERTY_BSTR((IADsService *)this,  Path);
}

STDMETHODIMP
CWinNTService::get_StartupParameters(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsService *)this,  StartupParameters);

}

STDMETHODIMP
CWinNTService::put_StartupParameters(THIS_ BSTR bstrStartupParameters) {
    PUT_PROPERTY_BSTR((IADsService *)this,  StartupParameters);

}

STDMETHODIMP
CWinNTService::get_ErrorControl(THIS_ LONG FAR* retval)
{

    GET_PROPERTY_LONG((IADsService *)this, ErrorControl);
}

STDMETHODIMP
CWinNTService::put_ErrorControl(THIS_ LONG lErrorControl)
{
    PUT_PROPERTY_LONG((IADsService *)this, ErrorControl);
}

STDMETHODIMP
CWinNTService::get_LoadOrderGroup(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsService *)this,  LoadOrderGroup);

}

STDMETHODIMP
CWinNTService::put_LoadOrderGroup(THIS_ BSTR bstrLoadOrderGroup)
{

    PUT_PROPERTY_BSTR((IADsService *)this,  LoadOrderGroup);

}

STDMETHODIMP
CWinNTService::get_ServiceAccountName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsService *)this,  ServiceAccountName);

}

STDMETHODIMP
CWinNTService::put_ServiceAccountName(THIS_ BSTR bstrServiceAccountName)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTService::get_ServiceAccountPath(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTService::put_ServiceAccountPath(THIS_ BSTR bstrServiceAccountName)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CWinNTService::get_Dependencies(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsService *)this,  Dependencies);
}

STDMETHODIMP
CWinNTService::put_Dependencies(THIS_ VARIANT vDependencies)
{
    PUT_PROPERTY_VARIANT((IADsService *)this,  Dependencies);
}

STDMETHODIMP
CWinNTService::SetPassword(THIS_ BSTR bstrNewPassword)
{


    //
    // This routine should merely change password. Even if any other
    // properties are set in the configuration functional set then they
    // will not be touched.
    // Therefore we do a QueryServiceConfig and get all the configuration
    // related information, merely change the password and send it back.
    // For this reason, it is not possible to reuse GetInfo or SetInfo
    // because they change service config properties.
    //

    BOOL fRetval;
    LPQUERY_SERVICE_CONFIG pMem = NULL;
    HRESULT hr;

    hr = WinNTOpenService(SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS,
                          SERVICE_ALL_ACCESS);


    BAIL_IF_ERROR(hr);

    hr = GetServiceConfigInfo(&pMem);
    BAIL_IF_ERROR(hr);

    //
    // just change the field corresponding to password.
    //

    fRetval = ChangeServiceConfig(_schService,
                                  pMem->dwServiceType,
                                  pMem->dwStartType,
                                  pMem->dwErrorControl,
                                  pMem->lpBinaryPathName,
                                  pMem->lpLoadOrderGroup,
                                  NULL,
                                  pMem->lpDependencies,
                                  pMem->lpServiceStartName,
                                  (LPTSTR)bstrNewPassword,
                                  pMem->lpDisplayName
                                  );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

cleanup:
    if(pMem){
        FreeADsMem(pMem);
    }
    WinNTCloseService();
    RRETURN_EXP_IF_ERR(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::Start
//
//  Synopsis:   Attempts to start the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  RamV    Created
//
// Notes:
//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTService::Start(THIS)
{
    HRESULT hr;
    hr = WinNTControlService(WINNT_START_SERVICE);
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::Stop
//
//  Synopsis:   Attempts to stop the service specified in _bstrServiceName on
//              the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96 RamV    Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTService::Stop(THIS)
{
    HRESULT hr;
    hr = WinNTControlService(WINNT_STOP_SERVICE);
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::Pause
//
//  Synopsis:   Attempts to pause the service named _bstrServiceName on the
//              server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01-04-96    RamV     Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTService::Pause(THIS)
{
    HRESULT hr;
    hr = WinNTControlService(WINNT_PAUSE_SERVICE);
    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::Continue
//
//  Synopsis:   Attempts to "unpause" the service specified in _bstrServiceName
//              on the server named in _bstrPath.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    01/04/96  RamV   Created
//
//----------------------------------------------------------------------------


STDMETHODIMP
CWinNTService::Continue(THIS)
{
    HRESULT hr;
    hr = WinNTControlService(WINNT_CONTINUE_SERVICE);
    RRETURN_EXP_IF_ERR(hr);
}


//
// Helper Functions
//

HRESULT
CWinNTService::GetServiceConfigInfo(LPQUERY_SERVICE_CONFIG *ppMem)
{
    //
    //gets the service configuration information into ppMem
    //

    BOOL    fRetval;
    DWORD   dwBufAllocated = 0;
    DWORD   dwBufNeeded = 0;
    DWORD   dwLastError;
    HRESULT hr = S_OK;

    ADsAssert(ppMem);
    *ppMem = (LPQUERY_SERVICE_CONFIG)AllocADsMem(dwBufAllocated);

    if (*ppMem == NULL){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    ADsAssert(_schService);

    fRetval = QueryServiceConfig(_schService,
                                 (LPQUERY_SERVICE_CONFIG)(*ppMem),
                                 dwBufAllocated,
                                 &dwBufNeeded);

    if (fRetval == FALSE)  {
        dwLastError = GetLastError();
        switch (dwLastError)  {
        case ERROR_INSUFFICIENT_BUFFER:
            //
            // Allocate more memory and try again.
            //
            FreeADsMem(*ppMem);
            *ppMem = NULL;

            dwBufAllocated = dwBufNeeded;
            *ppMem = (LPQUERY_SERVICE_CONFIG)AllocADsMem(dwBufAllocated);
            if (*ppMem == NULL)  {
                BAIL_IF_ERROR(hr = E_OUTOFMEMORY);
            }

            fRetval = QueryServiceConfig(_schService,
                                         *ppMem,
                                         dwBufAllocated,
                                         &dwBufNeeded);

            if (fRetval == FALSE)  {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
            break;

        default:
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;

        }
        BAIL_IF_ERROR(hr);
    }

    if(*ppMem){
        RRETURN(S_OK);
    }

cleanup:
    RRETURN(hr);

}



HRESULT
CWinNTService::WinNTControlService( DWORD dwControl)
{
    //
    // abstracts out the common code of Start,Stop,Pause and Resume
    //

    HRESULT         hr =S_OK, hrclose=S_OK, hrcontrol=S_OK;
    SERVICE_STATUS  ssStatusInfo;
    BOOL            fRetval;


    if(_fValidHandle){
        //
        // an open handle exists, blow it away
        //
        hrclose = WinNTCloseService();
        BAIL_ON_FAILURE(hrclose);
        _fValidHandle = FALSE;
    }


    hr = WinNTOpenService(SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS,
                          GENERIC_EXECUTE| SERVICE_INTERROGATE
                          );

    BAIL_ON_FAILURE(hr);

    _fValidHandle = TRUE;

    switch(dwControl){

    case WINNT_START_SERVICE:
        fRetval = StartService(_schService,
                               0,
                               NULL );


        if(!fRetval){
            hrcontrol = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
        _dwOpPending = PENDING_START;
        break;

    case WINNT_STOP_SERVICE:
        fRetval = ControlService(_schService,
                                 SERVICE_CONTROL_STOP,
                                 &ssStatusInfo);

        if(!fRetval){
            hrcontrol = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
        _dwOpPending = PENDING_STOP;
        break;

    case WINNT_PAUSE_SERVICE:
        fRetval = ControlService(_schService,
                                 SERVICE_CONTROL_PAUSE,
                                 &ssStatusInfo);

        if(!fRetval){
            hrcontrol = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
        _dwOpPending = PENDING_PAUSE;
        break;

    case WINNT_CONTINUE_SERVICE:
        fRetval = ControlService(_schService,
                                 SERVICE_CONTROL_CONTINUE,
                                 &ssStatusInfo);

        if(!fRetval){
            hrcontrol = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
        _dwOpPending = PENDING_CONTINUE;
        break;

    default:
        hrcontrol = E_FAIL;
        goto error;
    }
    _dwTimeStarted = GetTickCount();
    _dwWaitHint = 10000; //10 seconds
    _dwCheckPoint = 0;

    RRETURN(S_OK);

error:
    if(FAILED(hrcontrol)){
        _fValidHandle = FALSE;

        //
        // Because _fValidHandle is false, _schService and _schSCManager will
        // not be cleaned up in the destructor of this object, so clean up now.
        //
        WinNTCloseService();

        RRETURN(hrcontrol);
    }
    else if(FAILED(hrclose)){
        RRETURN(hrclose);
    }
    else{
        RRETURN(hr);
    }
}





//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::WinNTOpenService
//
//  Synopsis:   Opens the Service Control Manager on the machine specified in
//              _bstrPath, then opens the Service specified in _bstrServiceName.
//              The handle to the SCM is placed in _schSCManager, and the
//              handle to the service is placed in _schService.
//
//  Arguments:  [dwSCMDesiredAccess] -- type of SCM access needed
//              [dwSvrDesiredAccess] -- type of Service access required
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    03-17-95    t-skwan     Created
//              01/04/96    RamV        Modified
//
//----------------------------------------------------------------------------
HRESULT
CWinNTService::WinNTOpenService(
    DWORD   dwSCMDesiredAccess,
    DWORD   dwSvrDesiredAccess
    )
{
    HRESULT hr;
    DWORD   dwLastError;


    //
    // Open the Service Control Manager.
    //

    //
    // OpenSCManager(
    //      LPCTSTR lpszMachineName,
    //      LPCTSTR lpszDatabaseName.
    //      DWORD   fdwDesiredAccess)
    //


    _schSCManager = OpenSCManager(_pszServerName,
                                  NULL,
                                  dwSCMDesiredAccess);

    if (_schSCManager == NULL)  {

        dwLastError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwLastError);
        RRETURN(hr);
    }

    //
    // Get a handle to the specified service.
    //


    _schService = OpenService(_schSCManager,
                              _pszServiceName,
                              dwSvrDesiredAccess);

    if(_schService == NULL)  {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CloseServiceHandle(_schSCManager);
        _schSCManager = NULL;
        RRETURN(hr);
    }

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   CWinNTService::WinNTCloseService
//
//  Synopsis:   Closes the Service handle and the Service Control Manager
//              handle.
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    03-17-95    t-skwan     Created
//              01/04/96    RamV        Modified
//
//----------------------------------------------------------------------------

HRESULT
CWinNTService::WinNTCloseService()
{
    BOOL    fRetval = TRUE;


    //
    // Close the Service handle.
    //
    if(_schService){
        fRetval = CloseServiceHandle(_schService);
        _schService = NULL;
    }

    if (!fRetval)  {
        //
        // Ack.  What do we do if there is an error closing a service?
        //
        RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // Close the Service Control Manager.
    //

    if(_schSCManager){
        fRetval = CloseServiceHandle(_schSCManager);
        _schSCManager = NULL;
    }
    if (!fRetval)  {
        //
        // Ack.  What do we do if there is an error closing an SCM?
        //
        RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    RRETURN(S_OK);
}

STDMETHODIMP
CWinNTService::get_Status(THIS_ long FAR* plStatusCode)
{
    HRESULT hr = S_OK;
    BOOL fRetval = FALSE, found = FALSE;
    SERVICE_STATUS Status;
    DWORD dwStatus = 0;


    if(plStatusCode == NULL){
        RRETURN_EXP_IF_ERR(E_POINTER);
    }

    *plStatusCode = -1; //-1 is an invalid code

    if(!(_fValidHandle)){

        //
        // currently not waiting on any service
        //

        hr = WinNTOpenService(SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS,
                              GENERIC_EXECUTE|SERVICE_INTERROGATE);


        BAIL_IF_ERROR(hr);

        fRetval = ControlService(_schService,
                                 SERVICE_CONTROL_INTERROGATE,
                                 &Status);


        if(!fRetval){
            hr = HRESULT_FROM_WIN32(GetLastError());
            if(hr == HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE)){
                dwStatus = SERVICE_STOPPED;
                hr = S_OK;
            }
            goto cleanup;
        }

        dwStatus = Status.dwCurrentState;

        hr = WinNTCloseService();

        goto cleanup;

    }

    //
    // if you are here
    // you are waiting for a service to complete
    //

    //
    // NOTE: QueryServiceStatus queries the SCM rather than
    // the service directly so to get a more upto date answer
    // we need to use control service with interrogate option
    //


    hr = WinNTOpenService(SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS,
                          GENERIC_EXECUTE|SERVICE_INTERROGATE);

    BAIL_IF_ERROR(hr);

    fRetval = ControlService(_schService,
                             SERVICE_CONTROL_INTERROGATE,
                             &Status);



    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        if(hr == HRESULT_FROM_WIN32(ERROR_SERVICE_NOT_ACTIVE)){
            dwStatus = SERVICE_STOPPED;
            hr = S_OK;
        }
        goto cleanup;
    }

    hr = EvalPendingOperation(PENDING_START,
                              SERVICE_RUNNING,
                              SERVICE_START_PENDING,
                              &Status,
                              &dwStatus
                              );

    BAIL_IF_ERROR(hr);

    if(dwStatus != 0){
        //
        // the correct scenario was found
        //
        goto cleanup;
    }
    hr = EvalPendingOperation(PENDING_STOP,
                              SERVICE_STOPPED,
                              SERVICE_STOP_PENDING,
                              &Status,
                              &dwStatus
                              );

    BAIL_IF_ERROR(hr);

    if(dwStatus != 0){
        //
        // the correct scenario was found
        //
        goto cleanup;
    }

    hr = EvalPendingOperation(PENDING_PAUSE,
                              SERVICE_PAUSED,
                              SERVICE_PAUSE_PENDING,
                              &Status,
                              &dwStatus
                              );

    BAIL_IF_ERROR(hr);

    if(dwStatus != 0){
        //
        // the correct scenario was found
        //
        goto cleanup;
    }

    hr = EvalPendingOperation(PENDING_CONTINUE,
                              SERVICE_RUNNING,
                              SERVICE_CONTINUE_PENDING,
                              &Status,
                              &dwStatus
                              );

    BAIL_IF_ERROR(hr);

    ADsAssert(dwStatus != 0); //we must find the appropriate scenario

cleanup:
    if(SUCCEEDED(hr)){
        //
        // instead of a conversion routine, we return WinNT Status Code
        //

        *plStatusCode = dwStatus;

    }
    RRETURN_EXP_IF_ERR(hr);
}



HRESULT
CWinNTService::EvalPendingOperation(
    THIS_ DWORD dwOpPending,
    DWORD dwStatusDone,
    DWORD dwStatusPending,
    LPSERVICE_STATUS pStatus,
    DWORD *pdwRetval
    )

{

    DWORD dwCurrentStatus;
    BOOL     fRetval;
    HRESULT  hr =S_OK;
    DWORD dwNow;

    dwCurrentStatus = pStatus->dwCurrentState;

    if(_dwOpPending == dwOpPending){

        if(dwCurrentStatus == dwStatusDone){
            //
            //was pending, is now completed
            //

            _dwOpPending = NOTPENDING;
            *pdwRetval = dwStatusDone;
            hr = WinNTCloseService();
            BAIL_ON_FAILURE(hr);
            _fValidHandle = FALSE;
            RRETURN(S_OK);

        }
        else if(dwCurrentStatus = dwStatusPending){
            //
            //see if progress has been made since the last time we checked
            //

            if(pStatus->dwCheckPoint !=_dwCheckPoint){
                //
                // progress was made
                //
                *pdwRetval = dwStatusPending;
                _dwCheckPoint = pStatus->dwCheckPoint;
                _dwWaitHint = pStatus->dwWaitHint;
                _dwTimeStarted = GetTickCount();
                RRETURN(S_OK);
            }

            dwNow = GetTickCount();


            if(2*_dwWaitHint < TickCountDiff(dwNow,_dwTimeStarted)){
                //
                // you can still wait
                //
                *pdwRetval = dwStatusPending;
                RRETURN(S_OK);
            }

            else{

                //
                // took too long without signs of progress
                //

                *pdwRetval = SERVICE_ERROR;
                _dwOpPending = NOTPENDING;
                hr = WinNTCloseService();
                BAIL_ON_FAILURE(hr);
                _fValidHandle = FALSE;
                RRETURN(S_OK);
            }
        }
        else{

            //
            // an operation is pending but we arent going anywhere
            // recover gracefully
            //

            _dwOpPending = NOTPENDING;
            hr = WinNTCloseService();
            BAIL_ON_FAILURE(hr);
            _fValidHandle = FALSE;
            *pdwRetval = SERVICE_ERROR;
            RRETURN(S_OK);
        }

    }
error:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cumiconn.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     cumiconn.cxx
//
//  Contents: Contains the UMI connection object implementation 
//
//  History:  03-02-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   CreateConnection
//
// Synopsis:   Creates a connection object. Called by class factory.
//
// Arguments:
//
// iid         Interface requested. Only interface supported is IUmiConnection.
// ppInterface Returns pointer to interface requested
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return a pointer to the interface requested
//
//----------------------------------------------------------------------------
HRESULT CUmiConnection::CreateConnection(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    CUmiConnection *pConn = NULL;
    HRESULT         hr = S_OK;

    ADsAssert(ppInterface);

    pConn = new CUmiConnection();
    if(NULL == pConn)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    // initialize connection object
    hr = pConn->FInit();
    BAIL_ON_FAILURE(hr);

    hr = pConn->QueryInterface(iid, ppInterface);
    BAIL_ON_FAILURE(hr);

    pConn->Release();

    RRETURN(S_OK);

error:

    if(pConn != NULL)
        delete pConn;

    RRETURN(hr);
}
   
//----------------------------------------------------------------------------
// Function:   CUmiConnection
//
// Synopsis:   Constructor. Initializes all member variables
//
// Arguments:
//
// None
//
// Returns:    Nothing. 
//
// Modifies:   Nothing. 
//
//---------------------------------------------------------------------------- 
CUmiConnection::CUmiConnection(void)
{
    m_pIUmiPropList = NULL;
    m_pCUmiPropList = NULL;
    m_ulErrorStatus = 0;
    m_pIADsOpenDSObj = NULL;
    m_fAlreadyOpened = FALSE;
    m_pszComputerName = NULL;
    m_pszDomainName = NULL;
}

//----------------------------------------------------------------------------
// Function:   ~CUmiConnection
//
// Synopsis:   Destructor. Frees member variables
//
// Arguments:
//
// None
//
// Returns:    Nothing.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
CUmiConnection::~CUmiConnection(void)
{
    if(m_pIUmiPropList != NULL)
        m_pIUmiPropList->Release();

    if(m_pszComputerName != NULL)
        FreeADsStr(m_pszComputerName);

    if(m_pszDomainName != NULL)
        FreeADsStr(m_pszDomainName);

    if(m_pIADsOpenDSObj != NULL)
        m_pIADsOpenDSObj->Release();

    // m_pCUmiPropList does not have to be deleted since the Release() above
    // has already done it.
}

//----------------------------------------------------------------------------
// Function:   FInit 
//
// Synopsis:   Initializes connection object. 
//
// Arguments:
//
// None
//
// Returns:    S_OK on success. Error code otherwise. 
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
HRESULT CUmiConnection::FInit(void)
{
    HRESULT      hr = S_OK;
    CUmiPropList *pPropList = NULL;

    pPropList = new CUmiPropList(ConnectionClass, g_dwConnectionTableSize);
    if(NULL == pPropList)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    hr = pPropList->FInit(NULL, g_UmiConUnImplProps);
    BAIL_ON_FAILURE(hr);

    hr = pPropList->QueryInterface(
                IID_IUmiPropList,
                (void **) &m_pIUmiPropList
                );
    BAIL_ON_FAILURE(hr);

    // DECLARE_STD_REFCOUNTING initializes the refcount to 1. Call Release()
    // on the created object, so that releasing the interface pointer will
    // free the object.
    pPropList->Release(); 

    m_pCUmiPropList = pPropList;

    hr = m_pCUmiPropList->SetDefaultConnProps();
    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:

    if(m_pIUmiPropList != NULL) {
        m_pIUmiPropList->Release();
        m_pIUmiPropList = NULL;
        m_pCUmiPropList = NULL;
    }
    else if(pPropList != NULL)
        delete pPropList;

    RRETURN(hr);
} 

//----------------------------------------------------------------------------
// Function:   QueryInterface 
//
// Synopsis:   Queries connection object for supported interfaces. Only 
//             IUmiConnection is supported. 
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiConnection::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(NULL == ppInterface)
        RRETURN(E_INVALIDARG);

    *ppInterface = NULL;

    if(IsEqualIID(iid, IID_IUnknown))
        *ppInterface = (IUmiConnection *) this;
    else if(IsEqualIID(iid, IID_IUmiConnection))
        *ppInterface = (IUmiConnection *) this;
    else if(IsEqualIID(iid, IID_IUmiBaseObject))
        *ppInterface = (IUmiBaseObject *) this;
    else if(IsEqualIID(iid, IID_IUmiPropList))
        *ppInterface = (IUmiPropList *) this;
    else
         RRETURN(E_NOINTERFACE);

    AddRef();
    RRETURN(S_OK);
}
     
//----------------------------------------------------------------------------
// Function:   GetLastStatus 
//
// Synopsis:   Returns status or error code from the last operation. Currently
//             only numeric status is returned i.e, no error objects are
//             returned. Implements IUmiBaseObject::GetLastStatus().
//
// Arguments:
//
// uFlags           Reserved. Must be 0 for now.
// puSpecificStatus Returns status code 
// riid             IID requested. Ignored currently.
// pStatusObj       Returns interface requested. Always returns NULL currently. 
//
// Returns:         UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:        *puSpecificStatus to return status code. 
//
//---------------------------------------------------------------------------- 
STDMETHODIMP CUmiConnection::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if(pStatusObj != NULL)
       *pStatusObj = NULL;

    if(puSpecificStatus != NULL)
        *puSpecificStatus = 0;

    if(uFlags != 0)
        RRETURN(UMI_E_INVALID_FLAGS);

    if(NULL == puSpecificStatus)
        RRETURN(UMI_E_INVALIDARG);

    *puSpecificStatus = m_ulErrorStatus;

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   GetInterfacePropList
//
// Synopsis:   Returns a pointer to the interface property list implementation
//             for the connection object. Implements 
//             IUmiBaseObject::GetInterfacePropList().
//
// Arguments:
//
// uFlags      Reserved. Must be 0 for now.
// pPropList   Returns pointer to IUmiPropertyList interface
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pPropList to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiConnection::GetInterfacePropList(
    ULONG uFlags,
    IUmiPropList **pPropList
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == pPropList)
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    ADsAssert(m_pIUmiPropList != NULL);

    hr = m_pIUmiPropList->QueryInterface(IID_IUmiPropList, (void **)pPropList);

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   SetLastStatus 
//
// Synopsis:   Sets the status of the last operation. 
//
// Arguments:
//
// ulStatus    Status to be set
//
// Returns:    Nothing 
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
void CUmiConnection::SetLastStatus(ULONG ulStatus)
{
    m_ulErrorStatus = ulStatus;

    return;
} 

//----------------------------------------------------------------------------
// Function:   Open 
//
// Synopsis:   Opens the object specified by a URL and gets the interface 
//             requested on this object. Implements IUmiConnection::Open(). 
//
// Arguments:
//
// pURL        Pointer to an IUmiURL interface
// uFlags      Reserved. Must be 0 for now.
// TargetIID   Interface requested
// ppInterface Returns pointer to interface requested
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiConnection::Open(
    IUmiURL *pURL,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppInterface
    )
{
    HRESULT  hr = UMI_S_NO_ERROR;
    LPWSTR   pszUserName = NULL, pszPassword = NULL;
    DWORD    dwBindFlags = 0, dwNumComponents = 0, dwIndex = 0;
    LPWSTR   *ppszClasses = NULL;
    WCHAR    pszUrl[MAX_URL+1];
    WCHAR    *pszLongUrl = pszUrl;
    ULONG    ulUrlLen = MAX_URL;
    IUnknown *pIUnknown = NULL;
    CWinNTNamespaceCF tmpNamCF;
    ULONGLONG PathType = 0;
    BOOL     fPrevAlreadyOpened = FALSE;
    LPWSTR   pszPrevComputer = NULL, pszPrevDomain = NULL;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);
 
    if( (NULL == pURL) || (NULL == ppInterface) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    *ppInterface = NULL;

    // Check if the user specified any interface properties for authentication
    hr = GetUserName(&pszUserName);
    BAIL_ON_FAILURE(hr);

    hr = GetPassword(&pszPassword);
    BAIL_ON_FAILURE(hr);

    hr = GetBindFlags(&dwBindFlags);
    BAIL_ON_FAILURE(hr);

    // check if this is a native path or UMI path
    hr = pURL->GetPathInfo(0, &PathType);
    BAIL_ON_FAILURE(hr);

    if(PathType & UMIPATH_INFO_NATIVE_STRING) {
    // Get the native path from the URL
        hr = pURL->Get(0, &ulUrlLen, pszUrl);

        if(WBEM_E_BUFFER_TOO_SMALL == hr) {
        // need to allocate more memory for URL
            pszLongUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
            if(NULL == pszLongUrl)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

            hr = pURL->Get(0, &ulUrlLen, pszLongUrl);
        }
        BAIL_ON_FAILURE(hr); 
    }
    else {
    // assume UMI path if not native
        hr = UmiToWinNTPath(
                pURL, 
                &pszLongUrl,
                &dwNumComponents,
                &ppszClasses
                );
        BAIL_ON_FAILURE(hr);
    }

    hr = tmpNamCF.CreateInstance(
                NULL,
                IID_IADsOpenDSObject,
                (void **) &m_pIADsOpenDSObj
                );
    BAIL_ON_FAILURE(hr);

    //
    // we need a way to distinguish between calls to OpenDSObject from UMI
    // vs ADSI. We use the bind flags for this purpose. If ADS_AUTH_RESERVED
    // is set, then the call is from UMI. ADSI clients are not allowed to use
    // this flag - OLEDB relies on this.
    // 

    hr = m_pIADsOpenDSObj->OpenDSObject(
                pszLongUrl,
                pszUserName,
                pszPassword,
                dwBindFlags | ADS_AUTH_RESERVED,
                (IDispatch **) &pIUnknown
                ); 
     BAIL_ON_FAILURE(hr);

     // save off state in case we need to restore it later
     fPrevAlreadyOpened = m_fAlreadyOpened;
     pszPrevComputer = m_pszComputerName;
     pszPrevDomain = m_pszDomainName;

     // ensure that the returned object is what the user requested and that the 
     // object is on the same domain/server that this connection is for
     hr = CheckObject(
             pIUnknown, 
             dwNumComponents, 
             ppszClasses
             );
     BAIL_ON_FAILURE(hr);

     hr = pIUnknown->QueryInterface(
                TargetIID,
                ppInterface
                );
     if(FAILED(hr)) {
         // restore state of connection
         m_fAlreadyOpened = fPrevAlreadyOpened;

         if(m_pszComputerName != pszPrevComputer) {
             if(m_pszComputerName != NULL)
                 FreeADsStr(m_pszComputerName);
             m_pszComputerName = pszPrevComputer;
         }
         if(m_pszDomainName != pszPrevDomain) {
             if(m_pszDomainName != NULL)
                 FreeADsStr(m_pszDomainName);
             m_pszDomainName = pszPrevDomain;
         }

         goto error;
     }

     // make interface properties read-only
     m_pCUmiPropList->DisableWrites();

error:

     if(pszUserName != NULL)
         FreeADsMem(pszUserName);

     if(pszPassword != NULL)
         FreeADsMem(pszPassword);

     if(pIUnknown != NULL)
         pIUnknown->Release();

     if( (pszLongUrl != NULL) && (pszLongUrl != pszUrl) )
         FreeADsMem(pszLongUrl);

     if(ppszClasses != NULL) {
         for(dwIndex = 0; dwIndex < dwNumComponents; dwIndex++) {
             if(ppszClasses[dwIndex] != NULL)
                 FreeADsStr(ppszClasses[dwIndex]);
         }
         FreeADsMem(ppszClasses);
     }

     if(FAILED(hr)) {
         SetLastStatus(hr);
         
         if(m_pIADsOpenDSObj != NULL) {
             m_pIADsOpenDSObj->Release();
             m_pIADsOpenDSObj = NULL;
         }
     }
     
     RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   GetUserName 
//
// Synopsis:   Gets the username from the interface property cache. If the
//             interface property was not set, the default username is 
//             returned. 
//
// Arguments:
//
// ppszUserName Returns pointer to the username 
//
// Returns:     UMI_S_NO_ERROR on success.  Error code otherwise.
//
// Modifies:    *ppszUserName to return the username. 
//
//----------------------------------------------------------------------------
HRESULT CUmiConnection::GetUserName(LPWSTR *ppszUserName)
{
    HRESULT             hr = UMI_S_NO_ERROR;
    UMI_PROPERTY_VALUES *pUmiProp = NULL;
    LPWSTR              pszUserName = NULL;

    ADsAssert(ppszUserName != NULL);

    *ppszUserName = NULL;

    hr = m_pIUmiPropList->Get(
                TEXT(CONN_INTF_PROP_USERNAME),
                0,
                &pUmiProp
                );

    if(FAILED(hr)) {
    // shouldn't happen
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);
    }

    ADsAssert(UMI_TYPE_LPWSTR == pUmiProp->pPropArray->uType);
    ADsAssert(pUmiProp->pPropArray->pUmiValue != NULL);

    pszUserName = pUmiProp->pPropArray->pUmiValue->pszStrValue[0];

    if(pszUserName != NULL) {
        *ppszUserName = AllocADsStr(pszUserName);
        if(NULL == *ppszUserName)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    }
    else
        *ppszUserName = NULL;

error:

    if(pUmiProp != NULL)
        m_pIUmiPropList->FreeMemory(0, pUmiProp); // ignore error return

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   GetPassword
//
// Synopsis:   Gets the password from the interface property cache. If the
//             interface property was not set, the default password is 
//             returned. 
//
// Arguments:
//
// ppszPassword Returns pointer to the password 
//
// Returns:     UMI_S_NO_ERROR on success.  Error code otherwise.
//
// Modifies:    *ppszPassword to return the password. 
//
//----------------------------------------------------------------------------
HRESULT CUmiConnection::GetPassword(LPWSTR *ppszPassword)
{
    HRESULT             hr = UMI_S_NO_ERROR;
    UMI_PROPERTY_VALUES *pUmiProp = NULL;
    LPWSTR              pszPassword = NULL;

    ADsAssert(ppszPassword != NULL);

    *ppszPassword = NULL;

    hr = m_pCUmiPropList->GetHelper(
                TEXT(CONN_INTF_PROP_PASSWORD),
                0,
                &pUmiProp,
                UMI_TYPE_NULL, // no-op
                TRUE           // this is an internal call to GetHelper
                );

    if(FAILED(hr)) {
    // shouldn't happen
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);
    }

    ADsAssert(UMI_TYPE_LPWSTR == pUmiProp->pPropArray->uType);
    ADsAssert(pUmiProp->pPropArray->pUmiValue != NULL);

    pszPassword = pUmiProp->pPropArray->pUmiValue->pszStrValue[0];

    if(pszPassword != NULL) { 
        *ppszPassword = AllocADsStr(pszPassword);
        if(NULL == *ppszPassword)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    }
    else
        *ppszPassword = NULL;

error:

    if(pUmiProp != NULL)
        m_pCUmiPropList->FreeMemory(0, pUmiProp); // ignore error return

    RRETURN(hr);
}
    

//----------------------------------------------------------------------------
// Function:   GetBindFlags
//
// Synopsis:   Gets the bind flags from the interface property cache. If the
//             interface properties were not set, the default bind flags are
//             returned.
//
// Arguments:
//
// pdwBindFlags Returns the bind flags. 
//
// Returns:     UMI_S_NO_ERROR on success.  Error code otherwise.
//
// Modifies:    *pdwBindFlags to return the bind flags. 
//
//----------------------------------------------------------------------------
HRESULT CUmiConnection::GetBindFlags(DWORD *pdwBindFlags)
{   
    HRESULT             hr = UMI_S_NO_ERROR;
    UMI_PROPERTY_VALUES *pUmiProp = NULL;
    DWORD               dwUmiBindFlags = 0;

    ADsAssert(pdwBindFlags != NULL);

    hr = m_pIUmiPropList->Get(
                TEXT(CONN_INTF_PROP_SECURE_AUTH),
                0,
                &pUmiProp
                );

    if(SUCCEEDED(hr)) {
        ADsAssert(UMI_TYPE_BOOL == pUmiProp->pPropArray->uType);
        ADsAssert(pUmiProp->pPropArray->pUmiValue != NULL);

        if(TRUE == pUmiProp->pPropArray->pUmiValue->bValue[0])
            dwUmiBindFlags |= ADS_SECURE_AUTHENTICATION;

        m_pIUmiPropList->FreeMemory(0, pUmiProp); // ignore error return
        pUmiProp = NULL;
    }
    else 
    // shouldn't happen 
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);    

    hr = m_pIUmiPropList->Get(
                TEXT(CONN_INTF_PROP_READONLY_SERVER),
                0,
                &pUmiProp
                );

    if(SUCCEEDED(hr)) {
        ADsAssert(UMI_TYPE_BOOL == pUmiProp->pPropArray->uType);
        ADsAssert(pUmiProp->pPropArray->pUmiValue != NULL);

        if(TRUE == pUmiProp->pPropArray->pUmiValue->bValue[0])
            dwUmiBindFlags |= ADS_READONLY_SERVER;

        m_pIUmiPropList->FreeMemory(0, pUmiProp); // ignore error return
        pUmiProp = NULL;
    }
    else 
    // shouldn't happen 
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);     

    *pdwBindFlags = dwUmiBindFlags;

error:

    if(pUmiProp != NULL)
        m_pIUmiPropList->FreeMemory(0, pUmiProp); // ignore error return

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   CheckObject 
//
// Synopsis:   Checks that the returned object is the same as what the user
//             requested, if the user passed in a UMI path i.e the classes 
//             of the components in the UMI path to the  object retrieved
//             should be the same as what the user requested. 
//             This function also checks to make sure that subsequent calls to
//             Open(), after the first call, specify the same server/domain
//             as the first call. If the path used in the first call to Open()
//             specifies only a domain name, then all subsequent Open() calls
//             should also specify only a domain name and no computer name.
//             If the first call to Open() specified only a computer name, then
//             all subsequent calls should specify the same computer name. If
//             the first call to Open specified the WinNT namespace path
//             (umi:///winnt or WinNT:), then subsequent Open() calls can 
//             connect to any domain/computer. Also, the namespace object can
//             be opened successfully even if we already connected to a 
//             computer/domain.
//
// Arguments:
//
// pUnknown    Pointer to the IUnknown of object retrieved
// dwNumComps  Number of components if the path is a UMI path. 0 otherwise.
// ppszClasses Array containing the class of each component, if the path is
//             a UMI path to an object other than the namespace obejct. 
//             NULL otherwise. 
//
// Returns:    S_OK on success.  Error code otherwise.
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
HRESULT CUmiConnection::CheckObject(
    IUnknown   *pUnknown,
    DWORD      dwNumComps,
    LPWSTR     *ppszClasses
    )
{
    HRESULT         hr = S_OK;
    IUmiADSIPrivate *pUmiPrivate = NULL;
    CCoreADsObject  *pCoreObj = NULL;
    LPWSTR          pszComputerName = NULL, pszDomainName = NULL;
    DWORD           dwIndex = 0, dwCoreIndex = 0;

    ADsAssert(pUnknown != NULL);

    hr = pUnknown->QueryInterface(
            IID_IUmiADSIPrivate,
            (LPVOID *) &pUmiPrivate
            );
    BAIL_ON_FAILURE(hr);

    hr = pUmiPrivate->GetCoreObject((void **) &pCoreObj);
    BAIL_ON_FAILURE(hr);

    if(ppszClasses != NULL) {
    // user specified a UMI path and it was not umi:///winnt. Make sure the 
    // classes are the same, as mentioned above.

        // walk the list of classes in reverse order. Reason for reverse order
        // is that the WinNT provider may tack on an additional component to
        // the ADsPath stored in the core object. For example, 
        // Open("WinNT://ntdsdc1") would return an ADsPath of 
        // "WinNT://ntdev/ntdsdc1".

        dwCoreIndex = pCoreObj->_dwNumComponents - 1;
        for(dwIndex = dwNumComps - 1; ((long) dwIndex) >= 0; dwIndex--) {
            if( _wcsicmp(
                  ppszClasses[dwIndex], 
                  pCoreObj->_CompClasses[dwCoreIndex]) ) {
                
                if( (0 == dwIndex) && (dwNumComps > 1) ) {

                    if(0 == _wcsicmp(pCoreObj->_CompClasses[1], 
                                     SCHEMA_CLASS_NAME)) {
                    // if the first component of a schema path doesn't match,
                    // make sure it is "Domain". Need this special case because
                    // of a bug in the WinNT provider. First component of a
                    // schema path is ignored and hence the UMI path always
                    // returns "Computer" as the class for this component. This
                    // special case allows binding using a path like 
                    // umi://winnt/domain=ntdev/schema=schema.
                        if(0 == _wcsicmp(ppszClasses[dwIndex], 
                                         DOMAIN_CLASS_NAME)) {
                            dwCoreIndex--;
                            continue;
                        }
                    }
                } 

                BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
            }

            dwCoreIndex--;
        }
    } // if(ppszClasses...)
                        
    // get the domain/computer name specified in the path
    if(pCoreObj->_dwNumComponents > 0) {
        for(dwIndex = pCoreObj->_dwNumComponents - 1; ((long) dwIndex) >= 0; 
                      dwIndex--) {
            if(0 == (_wcsicmp(
                    pCoreObj->_CompClasses[dwIndex],
                    SCHEMA_CLASS_NAME)) ) {
            // schema container is a special case. We can connect to the
            // schema on any computer/domain irrespective of where we are
            // connected currently. This is to allow for CIMOM to connect to
            // the schema container for a computer. Currently, the WinNT
            // provider returns WinNT://ntdev/schema as the schema path on the
            // object WinNT://ntdsdc1. Hence we need to allow CIMOM to connect
            // to ntdev even after connecting to ntdsdc1. 

                break; // pszComputerName and pszDomainName are both NULL
            }

            if(0 == (_wcsicmp(
                    pCoreObj->_CompClasses[dwIndex],
                    COMPUTER_CLASS_NAME)) ) {
                pszComputerName = 
                    pCoreObj->_ObjectInfo.DisplayComponentArray[dwIndex];
                break;
            }
            else if(0 == (_wcsicmp(
                    pCoreObj->_CompClasses[dwIndex],
                    DOMAIN_CLASS_NAME)) ) {
                pszDomainName = 
                    pCoreObj->_ObjectInfo.DisplayComponentArray[dwIndex];
                break;
            }
        } // for(..)
    } // if(pCoreObj...)

    if(FALSE == m_fAlreadyOpened) {
    // first call to Open()
        if(pszComputerName != NULL) {
            m_pszComputerName = AllocADsStr(pszComputerName);
            if(NULL == m_pszComputerName) {
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
            }
        }
        else if(pszDomainName != NULL) {
            m_pszDomainName = AllocADsStr(pszDomainName);
            if(NULL == m_pszDomainName) {
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
            }
        }

        m_fAlreadyOpened = TRUE;
    }
    else if( (pszComputerName != NULL) || (pszDomainName != NULL) ) {
    // Already opened connection and this is not the namespace object.
    // Make sure that the domain/computer is same as before.

        if(m_pszComputerName != NULL) {
            if( (NULL == pszComputerName) ||
                    (_wcsicmp(m_pszComputerName, pszComputerName)) ) {
                BAIL_ON_FAILURE(hr = UMI_E_MISMATCHED_SERVER);
            }
        }
        else if(m_pszDomainName != NULL) {
            if( (NULL == pszDomainName) ||
                    (_wcsicmp(m_pszDomainName, pszDomainName)) ) {
                BAIL_ON_FAILURE(hr = UMI_E_MISMATCHED_DOMAIN);
            }
        }
        else {
        // both m_pszComputerName and m_pszDomainName are NULL. Previous 
        // open() must have been for a namespace object.
            if(pszComputerName != NULL) {
                m_pszComputerName = AllocADsStr(pszComputerName);
                if(NULL == m_pszComputerName) {
                    BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
                }
            }
            else if(pszDomainName != NULL) {
                m_pszDomainName = AllocADsStr(pszDomainName);
                if(NULL == m_pszDomainName) {
                    BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
                }
            }
        } // else {

    } // else if(pszComputer...)

error:

    if(pUmiPrivate != NULL)
        pUmiPrivate->Release();

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cuas.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//  Class CWinNTUser

STDMETHODIMP CWinNTUser::get_BadLoginAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, BadLoginAddress);
}

STDMETHODIMP CWinNTUser::get_BadLoginCount(THIS_ long FAR* retval)
{
    GET_PROPERTY_LONG((IADsUser *)this, BadLoginCount);
}

STDMETHODIMP CWinNTUser::get_LastLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastLogin);
}

STDMETHODIMP CWinNTUser::get_LastLogoff(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastLogoff);
}

STDMETHODIMP CWinNTUser::get_LastFailedLogin(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, LastFailedLogin);
}

STDMETHODIMP CWinNTUser::get_PasswordLastChanged(THIS_ DATE FAR* retval)
{
    GET_PROPERTY_DATE((IADsUser *)this, PasswordLastChanged);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cumicurs.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     cumicurs.cxx
//
//  Contents: Contains the UMI cursor object implementation
//
//  History:  03-16-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   CreateCursor
//
// Synopsis:   Creates a cursor object. Called by IUmiContainer::CreateEnum(). 
//
// Arguments:
//
// pCredentials Credentials of the UMI object creating the cursor
// pCont       Pointer to container on which CreateEnum was called
// iid         Interface requested. Only interface supported is IUmiCursor.
// ppInterface Returns pointer to interface requested
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return a pointer to the interface requested
//
//----------------------------------------------------------------------------
HRESULT CUmiCursor::CreateCursor(
    CWinNTCredentials *pCredentials,
    IUnknown *pCont,
    REFIID iid,
    LPVOID *ppInterface
    )
{
    CUmiCursor *pCursor = NULL;
    HRESULT    hr = S_OK;

    ADsAssert(ppInterface != NULL);
    ADsAssert(pCont != NULL);

    pCursor = new CUmiCursor();
    if(NULL == pCursor)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    // initialize cursor object
    hr = pCursor->FInit(pCont, pCredentials);
    BAIL_ON_FAILURE(hr);

    hr = pCursor->QueryInterface(iid, ppInterface);
    BAIL_ON_FAILURE(hr);

    pCursor->Release();

    RRETURN(S_OK);

error:

    if(pCursor != NULL)
        delete pCursor;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   CUmiCursor
//
// Synopsis:   Constructor. Initializes all member variables
//
// Arguments:
//
// None
//
// Returns:    Nothing.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
CUmiCursor::CUmiCursor(void)
{
    m_pIUmiPropList = NULL;
    m_ulErrorStatus = 0;
    m_pUnkInner = NULL;
    m_pIID = NULL;
    m_pEnumerator = NULL;
}

//----------------------------------------------------------------------------
// Function:   ~CUmiCursor
//
// Synopsis:   Destructor. Frees member variables
//
// Arguments:
//
// None
//
// Returns:    Nothing.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
CUmiCursor::~CUmiCursor(void)
{
    if(m_pIUmiPropList != NULL)
        m_pIUmiPropList->Release();

    if(m_pUnkInner != NULL)
        m_pUnkInner->Release();

    if(m_pIID != NULL)
        FreeADsMem(m_pIID);

    if(m_pEnumerator != NULL)
        m_pEnumerator->Release();
}

//----------------------------------------------------------------------------
// Function:   FInit
//
// Synopsis:   Initializes cursor object.
//
// Arguments:
//
// pCont       Pointer to UMI container that created this cursor. 
// pCredentials Credentials of UMI object creating the cursor
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
HRESULT CUmiCursor::FInit(
    IUnknown *pCont,
    CWinNTCredentials *pCredentials
    )
{
    HRESULT      hr = S_OK;
    CUmiPropList *pPropList = NULL;

    ADsAssert(pCont != NULL);

    pPropList = new CUmiPropList(CursorClass, g_dwCursorTableSize);
    if(NULL == pPropList)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    hr = pPropList->FInit(NULL, NULL);
    BAIL_ON_FAILURE(hr);

    hr = pPropList->QueryInterface(
                IID_IUmiPropList,
                (void **) &m_pIUmiPropList
                );
    BAIL_ON_FAILURE(hr);

    // DECLARE_STD_REFCOUNTING initializes the refcount to 1. Call Release()
    // on the created object, so that releasing the interface pointer will
    // free the object.
    pPropList->Release();

    m_pUnkInner = pCont;
    pCont->AddRef();

    m_pCreds = pCredentials;

    RRETURN(S_OK);

error:

    if(m_pIUmiPropList != NULL) {
        m_pIUmiPropList->Release();
        m_pIUmiPropList = NULL;
    }

    if(pPropList != NULL)
        delete pPropList;
    
    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   Queries cursor object for supported interfaces. Only
//             IUmiCursor is supported.
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(NULL == ppInterface)
        RRETURN(E_INVALIDARG);

    *ppInterface = NULL;

    if(IsEqualIID(iid, IID_IUnknown))
        *ppInterface = (IUmiCursor *) this;
    else if(IsEqualIID(iid, IID_IUmiCursor))
        *ppInterface = (IUmiCursor *) this;
    else if(IsEqualIID(iid, IID_IUmiBaseObject))
        *ppInterface = (IUmiBaseObject *) this;
    else if(IsEqualIID(iid, IID_IUmiPropList))
        *ppInterface = (IUmiPropList *) this;
    else
         RRETURN(E_NOINTERFACE);

    AddRef();
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   GetLastStatus
//
// Synopsis:   Returns status or error code from the last operation. Currently
//             only numeric status is returned i.e, no error objects are
//             returned. Implements IUmiBaseObject::GetLastStatus().
//
// Arguments:
//
// uFlags           Reserved. Must be 0 for now.
// puSpecificStatus Returns status code
// riid             IID requested. Ignored currently.
// pStatusObj       Returns interface requested. Always returns NULL currently.
//
// Returns:         UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:        *puSpecificStatus to return status code.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if(pStatusObj != NULL)
       *pStatusObj = NULL;

   if(puSpecificStatus != NULL)
       *puSpecificStatus = 0;

   if(uFlags != 0)
       RRETURN(UMI_E_INVALID_FLAGS);

    if(NULL == puSpecificStatus)
        RRETURN(UMI_E_INVALIDARG);

    *puSpecificStatus = m_ulErrorStatus;

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   GetInterfacePropList
//
// Synopsis:   Returns a pointer to the interface property list implementation
//             for the connection object. Implements
//             IUmiBaseObject::GetInterfacePropList().
//
// Arguments:
//
// uFlags      Reserved. Must be 0 for now.
// pPropList   Returns pointer to IUmiPropertyList interface
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pPropList to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::GetInterfacePropList(
    ULONG uFlags,
    IUmiPropList **pPropList
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == pPropList)
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    ADsAssert(m_pIUmiPropList != NULL);

    hr = m_pIUmiPropList->QueryInterface(IID_IUmiPropList, (void **)pPropList);

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   SetLastStatus
//
// Synopsis:   Sets the status of the last operation.
//
// Arguments:
//
// ulStatus    Status to be set
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
void CUmiCursor::SetLastStatus(ULONG ulStatus)
{
    m_ulErrorStatus = ulStatus;

    return;
}

//----------------------------------------------------------------------------
// Function:   SetIID 
//
// Synopsis:   Sets the interface to be requested off each item returned by
//             the enumerator. Default is IID_IUmiObject. 
//
// Arguments:
//
// riid        IID of interface to request
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing. 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::SetIID(
    REFIID riid
    )
{
    SetLastStatus(0);

    if(NULL == m_pIID)
    {
       m_pIID = (IID *) AllocADsMem(sizeof(IID));
       if(NULL == m_pIID) {
           SetLastStatus(UMI_E_OUT_OF_MEMORY);
           RRETURN(UMI_E_OUT_OF_MEMORY);
       }
    }

    memcpy(m_pIID, &riid, sizeof(IID));

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   Reset 
//
// Synopsis:   Resets the enumerator to start from the beginning 
//
// Arguments:
//
// None
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::Reset(void)
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    // WinNT doesn't support Reset(). Keep the code below in case WinNT
    // Reset() gets implemented in the future. 
    BAIL_ON_FAILURE(hr = UMI_E_NOTIMPL); 

    // it is possible that m_pEnumerator may be NULL here if the user
    // called Reset before calling Next()
    if(NULL == m_pEnumerator)
        RRETURN(UMI_S_NO_ERROR);

    hr = m_pEnumerator->Reset();
    BAIL_ON_FAILURE(hr);

    RRETURN(UMI_S_NO_ERROR);

error:

    SetLastStatus(hr);
    
    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   GetFilter
//
// Synopsis:   Gets the filter from the interface property cache. If the
//             interface property was not set, an emty variant is returned. 
//
// Arguments:
//
// pvFilter    Returns variant containing the filter 
//
// Returns:    UMI_S_NO_ERROR on success.  Error code otherwise.
//
// Modifies:   *pvFilter to return the filter. 
//
//----------------------------------------------------------------------------
HRESULT CUmiCursor::GetFilter(VARIANT *pvFilter)
{
    HRESULT             hr = UMI_S_NO_ERROR;
    UMI_PROPERTY_VALUES *pUmiProp = NULL;
    LPWSTR              *ppszFilters = NULL;
    DWORD               dwNumFilters = 0;

    ADsAssert(pvFilter != NULL);

    VariantInit(pvFilter);

    hr = m_pIUmiPropList->Get(
                TEXT(CURSOR_INTF_PROP_FILTER),
                0,
                &pUmiProp
                );

    if(UMI_E_PROPERTY_NOT_FOUND == hr) 
    // interface property was not set. Return empty variant. 
        RRETURN(UMI_S_NO_ERROR);

    // check if there was some other error on Get()
    BAIL_ON_FAILURE(hr);

    ADsAssert(UMI_TYPE_LPWSTR == pUmiProp->pPropArray->uType);
    ADsAssert(pUmiProp->pPropArray->pUmiValue != NULL);

    ppszFilters = pUmiProp->pPropArray->pUmiValue->pszStrValue;
    dwNumFilters = pUmiProp->pPropArray->uCount;

    hr = ADsBuildVarArrayStr(ppszFilters, dwNumFilters, pvFilter);
    BAIL_ON_FAILURE(hr);

error:

    if(pUmiProp != NULL)
        m_pIUmiPropList->FreeMemory(0, pUmiProp); // ignore error return
   
    RRETURN(hr);
} 

//----------------------------------------------------------------------------
// Function:   Next 
//
// Synopsis:   Returns the next item(s) in the enumeration sequence.
//
// Arguments:
//
// uNumRequested Number of items requested
// pNumReturned  Returns actual number of objects returned
// ppObjects     Array of interface pointers of size *pNumReturned
//
// None
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pNumReturned to return the number of objects returned
//             *ppObjects to return the interface pointers 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::Next(
    ULONG uNumRequested,
    ULONG *puNumReturned,
    LPVOID *ppObjects
    )
{
    HRESULT   hr = UMI_S_NO_ERROR;
    VARIANT   vFilter, *pvResults = NULL;
    ULONG     ulIndex = 0, uNumReturned = 0, uNumResults = 0;
    IDispatch *pDisp = NULL;
    IUnknown  **pUnkArr = NULL, *pTmpUnk = NULL;
    IADsContainer *pIADsContainer = NULL;

    SetLastStatus(0);

    if( (NULL == puNumReturned) || (NULL == ppObjects) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    *puNumReturned = 0;
    *ppObjects = NULL;

    VariantInit(&vFilter);

    if(NULL == m_pEnumerator) {
    // first call to Next()

        ADsAssert(m_pUnkInner != NULL);

        hr = m_pUnkInner->QueryInterface(
                             IID_IADsContainer,
                             (void **) &pIADsContainer
                             );
        BAIL_ON_FAILURE(hr);

        // check if the user set a filter on the cursor 
        hr = GetFilter(&vFilter);
        BAIL_ON_FAILURE(hr);

        hr = pIADsContainer->put_Filter(vFilter);
        BAIL_ON_FAILURE(hr);

        m_pCreds->SetUmiFlag();

        hr = pIADsContainer->get__NewEnum((IUnknown **) &m_pEnumerator);

        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);
    }

    // allocate memory for variants to return objects
    pvResults = (VARIANT *) AllocADsMem(uNumRequested * sizeof(VARIANT));
    if(NULL == pvResults)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    hr = m_pEnumerator->Next(
        uNumRequested,
        pvResults,
        &uNumReturned
        );
    BAIL_ON_FAILURE(hr);

    // allocate memory for array of interface pointers to return
    pUnkArr = (IUnknown **) AllocADsMem(uNumReturned * sizeof(IUnknown *));
    if(NULL == pUnkArr)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    // convert the V_DISPATCH variants to the requested interface properties
    for(ulIndex = 0; ulIndex < uNumReturned; ulIndex++) {

        pDisp = V_DISPATCH(&pvResults[ulIndex]);
        ADsAssert(pDisp != NULL);

        if(m_pIID != NULL)
            hr = pDisp->QueryInterface(*m_pIID, (void **) &pTmpUnk);
        else
            hr = pDisp->QueryInterface(IID_IUmiObject, (void **) &pTmpUnk);

        if(FAILED(hr))
            continue;

        pUnkArr[uNumResults] = pTmpUnk;
        uNumResults++;
    }

    *puNumReturned = uNumResults;
    if(uNumResults > 0)
        *ppObjects = pUnkArr;
    else
        FreeADsMem(pUnkArr);
       
error:

    VariantClear(&vFilter);

    if(pvResults != NULL) {
        for(ulIndex = 0; ulIndex < uNumReturned; ulIndex++) 
            VariantClear(&pvResults[ulIndex]);

        FreeADsMem(pvResults);
    }

    if(pIADsContainer != NULL)
        pIADsContainer->Release();
            
    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}    

//----------------------------------------------------------------------------
// Function:   Count 
//
// Synopsis:   Counts the number of results returned by the enumerator.
//             Not implemented currently.
//
// Arguments:
//
// None
//
// Returns:    UMI_E_NOTIMPL for now.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::Count(
    ULONG *puNumObjects
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}       

//----------------------------------------------------------------------------
// Function:   Previous 
//
// Synopsis:   Returnss the previous object returned by the enumerator.
//             Not implemented currently.
//
// Arguments:
//
// None
//
// Returns:    UMI_E_NOTIMPL for now.
//
// Modifies:   Nothing.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiCursor::Previous(
    ULONG uFlags,
    LPVOID *pObj 
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cumiobj.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     cumiobj.cxx
//
//  Contents: Contains the implementation of IUmiObject. The methods are
//            encapsulated in one object. This object holds a pointer to 
//            the inner unknown of the corresponding WinNT object. 
//            The methods of IUmiContainer are also implemented on this 
//            same object, but will only be used if the underlying WinNT
//            object is a container. 
//
//  History:  03-06-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   CUmiObject
//
// Synopsis:   Constructor. Initializes member variable. 
//
// Arguments:  None 
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
CUmiObject::CUmiObject(void)
{
    m_pIntfProps = NULL;
    m_pObjProps = NULL;
    m_pUnkInner = NULL;
    m_pIADs = NULL;
    m_pIADsContainer = NULL;
    m_ulErrorStatus = 0;
    m_pCoreObj = NULL;
    m_pExtMgr = NULL;
    m_fOuterUnkSet = FALSE;
    m_pPropCache = NULL;
    m_fRefreshDone = FALSE;
}

//----------------------------------------------------------------------------
// Function:   ~CUmiObject
//
// Synopsis:   Destructor. Frees member variables. 
//
// Arguments:  None
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
CUmiObject::~CUmiObject(void)
{
    if(m_pIntfProps != NULL)
        m_pIntfProps->Release();

    if(m_pObjProps != NULL)
        delete m_pObjProps;

    if(m_pUnkInner != NULL)
        m_pUnkInner->Release(); 

    //
    // m_pIADs and m_pIADsContainer may now delegate to an outer unknown if
    // if the ADSI object has been aggregated in GetObjectByCLSID
    // subsequent to creation. Hence, we should not call Release() on either
    // of these pointers. Instead, call Release() on m_pUnkInner since this
    // is guaranteed to be a pointer to the non-delegating IUnknown.
    //
    if(m_pIADsContainer != NULL)
        m_pUnkInner->Release();

    if(m_pIADs != NULL)
        m_pUnkInner->Release();

    if(m_pPropCache != NULL)
        delete m_pPropCache;
}

//----------------------------------------------------------------------------
// Function:   FInit
//
// Synopsis:   Initializes UMI object. 
//
// Arguments: 
//
// Credentials  Credentials stored in the underlying WinNT object
// pSchema      Pointer to schema for this object
// dwSchemaSize Size of schema array 
// pPropCache   Pointer to property cache for this object
// pUnkInner    Pointer to inner unknown of underlying WinNT object
// pExtMgr      Pointer to extension manager of underlying WinNT object
// pCoreObj     Pointer to the core object of underlying WinNT object
// pClassInfo   Pointer to class information if this object is a class object.
//              NULL otherwise.
//
// Returns:     S_OK on success. Error code otherwise. 
//
// Modifies:    Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::FInit(
    CWinNTCredentials& Credentials,
    PPROPERTYINFO pSchema,
    DWORD dwSchemaSize,
    CPropertyCache *pPropertyCache,
    IUnknown *pUnkInner,
    CADsExtMgr *pExtMgr,
    CCoreADsObject *pCoreObj,
    CLASSINFO *pClassInfo
    )
{
    HRESULT      hr = S_OK;
    CUmiPropList *pIntfProps = NULL;

    ADsAssert(pCoreObj != NULL); // extension manager may be NULL for some 
                                 // WinNT objects

    if(pPropertyCache != NULL) {
    // some WinNT objects don't have a property cache associated with them.
    // Namespace and schema objects are examples. For these, we might 
    // create a proeprty cache in the 'else' clause below. Otherwise, we 
    // return UMI_E_NOTIMPL from IUmiPropList methods since m_pObjProps will be
    // NULL for these objects. 
        ADsAssert( (pSchema != NULL) && (dwSchemaSize > 0) && 
               (pUnkInner != NULL) );

        // Initialize property list for object properties 
        m_pObjProps = new CUmiPropList(pSchema, dwSchemaSize);
        if(NULL == m_pObjProps)
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        hr = m_pObjProps->FInit(pPropertyCache, NULL);
        BAIL_ON_FAILURE(hr);
    }
    else if(pSchema != NULL) {
    // Property, class, schema and syntax objects do not have a cache 
    // associated with them. But, they support a number of properties through
    // IDispatch. We want to expose these through UMI. So create a property
    // cache and populate it with these read-only properties. Thus,
    // m_pObjProps will be NULL only for namespace objects.

        ADsAssert( (pUnkInner != NULL) && (dwSchemaSize > 0) ); 

        hr = CreateObjectProperties(
                pSchema, 
                dwSchemaSize, 
                pUnkInner,
                pCoreObj
                );
        BAIL_ON_FAILURE(hr);
    }

    // Initialize property list for interface properties
    pIntfProps = new CUmiPropList(ObjClass, g_dwObjClassSize);
    if(NULL == pIntfProps)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    hr = pIntfProps->FInit(NULL, g_UmiObjUnImplProps);
    BAIL_ON_FAILURE(hr); 

    hr = pIntfProps->QueryInterface(
                IID_IUmiPropList,
                (void **) &m_pIntfProps
                );
    BAIL_ON_FAILURE(hr);

    // DECLARE_STD_REFCOUNTING initializes the refcount to 1. Call Release()
    // on the created object, so that releasing the interface pointer will
    // free the object.
    pIntfProps->Release();

    m_pUnkInner = pUnkInner;

    // Get pointers to IADs and IADsContainer interfaces on WinNT object
    hr = m_pUnkInner->QueryInterface(
                   IID_IADsContainer,
                   (void **) &m_pIADsContainer
                   );

    if(FAILED(hr))
        m_pIADsContainer = NULL;

    hr = m_pUnkInner->QueryInterface(
                   IID_IADs,
                   (void **) &m_pIADs
                   );

    if(FAILED(hr))
        m_pIADs = NULL;
    else {
        hr = pIntfProps->SetStandardProperties(m_pIADs, pCoreObj);
        BAIL_ON_FAILURE(hr);
    }

    pIntfProps->SetClassInfo(pClassInfo);

    // set the property count in the interface property cache
    hr = pIntfProps->SetPropertyCount(dwSchemaSize);
    BAIL_ON_FAILURE(hr);

    m_pExtMgr = pExtMgr;
    m_pCoreObj = pCoreObj;
    m_pCreds = &Credentials;

    RRETURN(S_OK);

error:

    if(m_pObjProps != NULL)
        delete m_pObjProps;

    if(m_pIntfProps != NULL)
        m_pIntfProps->Release();
    else if(pIntfProps != NULL)
        delete pIntfProps;        

    if(m_pIADsContainer != NULL)
        m_pIADsContainer->Release();

    if(m_pIADs != NULL)
        m_pIADs->Release();

    // make sure destructor doesn't free these again
    m_pObjProps = NULL;
    m_pIntfProps = NULL;
    m_pIADsContainer = NULL;
    m_pIADs = NULL;
    m_pUnkInner = NULL;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   CreateObjectProperties 
//
// Synopsis:   Creates a property cache and populates it with the properties
//             supported on the WinNT object's IDispatch interface. This is
//             used to expose properties on property, class and syntax objects
//             through UMI.  
//
// Arguments:
//
// pSchema      Pointer to schema for this object
// dwSchemaSize Size of schema array
// pUnkInner    Pointer to inner unknown of underlying WinNT object
// pCoreObj     Pointer to the core object of the WinNT object
//
// Returns:     S_OK on success. Error code otherwise.
//
// Modifies:    Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::CreateObjectProperties(
    PPROPERTYINFO pSchema,
    DWORD dwSchemaSize,
    IUnknown *pUnkInner,
    CCoreADsObject *pCoreObj
    )
{
    HRESULT    hr = S_OK;
    IDispatch  *pDispatch = NULL;
    DWORD      dwIndex = 0; 
    DISPID     DispId;
    DISPPARAMS DispParams = {NULL, NULL, 0, 0};
    VARIANT    var;
    CPropertyCache *pPropCache = NULL;

    ADsAssert( (pSchema != NULL) && (dwSchemaSize > 0) && 
               (pUnkInner != NULL) && (pCoreObj != NULL) );
   
    hr = CPropertyCache::createpropertycache(
            pSchema,
            dwSchemaSize,
            pCoreObj,
            &pPropCache);
    BAIL_ON_FAILURE(hr);

    hr = pUnkInner->QueryInterface(
        IID_IDispatch,
        (void **) &pDispatch
        );
    BAIL_ON_FAILURE(hr);

    for(dwIndex = 0; dwIndex < dwSchemaSize; dwIndex++) {
        hr = pDispatch->GetIDsOfNames(
                IID_NULL,
                &pSchema[dwIndex].szPropertyName,
                1,
                LOCALE_SYSTEM_DEFAULT,
                &DispId
                );
        BAIL_ON_FAILURE(hr);

        hr = pDispatch->Invoke(
                DispId,
                IID_NULL,
                LOCALE_SYSTEM_DEFAULT,
                DISPATCH_PROPERTYGET,
                &DispParams,
                &var,
                NULL,
                NULL
                );
        BAIL_ON_FAILURE(hr);

        hr = GenericPutPropertyManager(
                pPropCache,
                pSchema,
                dwSchemaSize,
                pSchema[dwIndex].szPropertyName,
                var,
                FALSE
                );

        VariantClear(&var);

        // If there is a multivalued ADSI interface property that has no values
        // (such as MandatoryProperties/Containment on a schema object), the 
        // call to Invoke above returns a variant which has a safearray with 
        // 0 elements in it. The call to GenericPutPropertyManager will fail
        // with E_ADS_BAD_PARAMETER in this case. In this case, don't store
        // anything in the property cache for this property. Trying to fetch
        // it later will return UMI_E_NOT_FOUND. 
 
        if(hr != E_ADS_BAD_PARAMETER)
            BAIL_ON_FAILURE(hr);
    }

    // Mark all properties as "not modified", since the client really hasn't
    // updated the cache, though we have.
    pPropCache->ClearModifiedFlags();
     
    // Initialize property list for object properties
    m_pObjProps = new CUmiPropList(pSchema, dwSchemaSize);
    if(NULL == m_pObjProps)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    hr = m_pObjProps->FInit(pPropCache, NULL);
    BAIL_ON_FAILURE(hr);
   
    m_pPropCache = pPropCache; 
    pDispatch->Release();
 
    RRETURN(S_OK);

error:

    if(pPropCache != NULL)
        delete pPropCache;

    if(pDispatch != NULL)
        pDispatch->Release();

    if(m_pObjProps != NULL) {
        delete m_pObjProps;
        m_pObjProps = NULL;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   QueryInterface 
//
// Synopsis:   Implements QI for the UMI object.  
//
// Arguments
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    HRESULT  hr = S_OK;
    IUnknown *pTmpIntfPtr = NULL;

    if(NULL == ppInterface)
        RRETURN(E_INVALIDARG); 

    *ppInterface = NULL;

    if(IsEqualIID(iid, IID_IUnknown))
        *ppInterface = (IUmiObject *) this;
    else if(IsEqualIID(iid, IID_IUmiObject))
        *ppInterface = (IUmiObject *) this;
    else if(IsEqualIID(iid, IID_IUmiContainer)) {
   // check if underlying WinNT object is a container
        if(m_pIADsContainer != NULL)
            *ppInterface = (IUmiContainer *) this;
        else
            RRETURN(E_NOINTERFACE);
    }
    else if(IsEqualIID(iid, IID_IUmiBaseObject))
        *ppInterface = (IUmiBaseObject *) this;
    else if(IsEqualIID(iid, IID_IUmiPropList))
        *ppInterface = (IUmiPropList *) this;
    else if(IsEqualIID(iid, IID_IUmiCustomInterfaceFactory)) 
        *ppInterface = (IUmiCustomInterfaceFactory *) this;
    else if(IsEqualIID(iid, IID_IUmiADSIPrivate))
        *ppInterface = (IUmiADSIPrivate *) this;
    else
        RRETURN(E_NOINTERFACE);

    AddRef();
    RRETURN(S_OK);
}
        
//----------------------------------------------------------------------------
// Function:   Clone 
//
// Synopsis:   Implements IUmiObject::Clone. Creates a new uncommitted object
//             and copies over all properties from the source to destination.
//             The source may be Refresh()ed if necessary.  
//
// Arguments
//
// uFlags      Flags for Clone(). Must be 0 for now.
// riid        Interface ID requested on the cloned object
// pCopy       Returns interface pointer requested 
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise. 
//
// Modifies:   *pCopy to return the interface requested. 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::Clone(
    ULONG uFlags,
    REFIID riid,
    LPVOID *pCopy
    )
{
    HRESULT       hr = UMI_S_NO_ERROR;
    BSTR          bstrADsPath = NULL, bstrParent = NULL;
    BSTR          bstrClass = NULL, bstrName = NULL;
    IUnknown      *pUnknown = NULL, *pUnkParent = NULL;
    IDispatch     *pDispatch = NULL;
    IADsContainer *pIADsCont = NULL;
    IUmiObject    *pUmiObj = NULL;
    IUmiADSIPrivate *pUmiPrivate = NULL;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == pCopy)
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if( (NULL == m_pCoreObj) || (NULL == m_pIADs) )
    // shouldn't happen, but just being paranoid
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    *pCopy = NULL;

    if(ADS_OBJECT_BOUND == m_pCoreObj->GetObjectState()) {
    // object exists on server
        if(FALSE == m_fRefreshDone) {
            hr = m_pCoreObj->ImplicitGetInfo();
            BAIL_ON_FAILURE(hr);
        }

        hr = m_pIADs->get_ADsPath(&bstrADsPath);
        BAIL_ON_FAILURE(hr);

        m_pCreds->SetUmiFlag();

        hr = GetObject(
                bstrADsPath,
                (LPVOID *) &pUnknown,
                *m_pCreds 
                );

        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);

        hr = pUnknown->QueryInterface(IID_IUmiObject, (LPVOID *) &pUmiObj);
        BAIL_ON_FAILURE(hr);
    }
    else if(ADS_OBJECT_UNBOUND == m_pCoreObj->GetObjectState()) {
    // object not yet committed to server. We don't have to refresh the
    // cache since the object is not yet committed. Get the parent container 
    // and call Create() on it.

        hr = m_pIADs->get_Parent(&bstrParent);
        BAIL_ON_FAILURE(hr);

        m_pCreds->SetUmiFlag();

        hr = GetObject(
                bstrParent,    
                (LPVOID *) &pUnkParent,
                *m_pCreds 
                );
        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);

        hr = pUnkParent->QueryInterface(
                IID_IUmiADSIPrivate, 
                (LPVOID *) &pUmiPrivate
                );
        BAIL_ON_FAILURE(hr);

        hr = pUmiPrivate->GetContainer((void **) &pIADsCont);
        BAIL_ON_FAILURE(hr);

        ADsAssert(pIADsCont != NULL);

        // get the class and name of this object
        hr = m_pIADs->get_Class(&bstrClass);
        BAIL_ON_FAILURE(hr);

        hr = m_pIADs->get_Name(&bstrName);
        BAIL_ON_FAILURE(hr);

        pUmiPrivate->SetUmiFlag();

        // now Create() the cloned object
        hr = pIADsCont->Create(
                bstrClass,
                bstrName,
                &pDispatch
                );

        pUmiPrivate->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);

        hr = pDispatch->QueryInterface(IID_IUmiObject, (LPVOID *) &pUmiObj);
        BAIL_ON_FAILURE(hr);
    }
    else // unknown state, shouldn't happen.
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // copy over the attributes in the property cache
    hr = CopyPropCache(pUmiObj, (IUmiObject *) this);
    BAIL_ON_FAILURE(hr);

    hr = pUmiObj->QueryInterface(riid, pCopy);
    BAIL_ON_FAILURE(hr);

error:

    if(bstrADsPath  != NULL)
        SysFreeString(bstrADsPath);

    if(bstrParent != NULL)
        SysFreeString(bstrParent);

    if(bstrClass != NULL)
        SysFreeString(bstrClass);
  
    if(bstrName != NULL)
        SysFreeString(bstrName);

    if(pUnknown != NULL)
        pUnknown->Release();

    if(pUnkParent != NULL)
        pUnkParent->Release();

    if(pDispatch != NULL)
        pDispatch->Release();

    if(pIADsCont != NULL)
        pIADsCont->Release();

    if(pUmiObj != NULL)
        pUmiObj->Release();

    if(pUmiPrivate != NULL)
        pUmiPrivate->Release();

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   CopyPropCache 
//
// Synopsis:   Copies the cache of one IUmiObject to another IUmiObject. 
//
// Arguments
//
// pDest       IUmiObject interface pointer of destination
// pSrc        IUmiObject interface pointer of source
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::CopyPropCache(
    IUmiObject *pDest,
    IUmiObject *pSrc
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulIndex = 0, ulPutFlag = 0;
    LPWSTR  pszPropName = NULL;
    UMI_PROPERTY_VALUES *pUmiPropNames = NULL, *pUmiProp = NULL;

    ADsAssert( (pDest != NULL) && (pSrc != NULL) );

    // get the names of the properties in cache.
    hr = pSrc->GetProps(
                NULL,
                0,
                UMI_FLAG_GETPROPS_NAMES,
                &pUmiPropNames
                );
    BAIL_ON_FAILURE(hr);

    // copy over each property
    for(ulIndex = 0; ulIndex < pUmiPropNames->uCount; ulIndex++) {
        pszPropName = pUmiPropNames->pPropArray[ulIndex].pszPropertyName;

        if(NULL == pszPropName)
        // shouldn't happen, just being paranoid.
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = pSrc->Get(
                pszPropName,
                UMI_FLAG_PROVIDER_CACHE,
                &pUmiProp
                );

        BAIL_ON_FAILURE(hr);

        // if the property was updated in cache, we need to mark it as updated 
        // in the destination object's cache also. Otherwise, mark the
        // property as clean in the destination object's cache.
        if(UMI_OPERATION_UPDATE == pUmiProp->pPropArray->uOperationType)
            ulPutFlag = 0;
        else
            ulPutFlag = UMI_INTERNAL_FLAG_MARK_AS_CLEAN;

        pUmiProp->pPropArray->uOperationType = UMI_OPERATION_UPDATE;

        hr = pDest->Put(
                pszPropName,
                ulPutFlag, 
                pUmiProp
                );
        BAIL_ON_FAILURE(hr);

        pSrc->FreeMemory(0, pUmiProp);
        pUmiProp = NULL;
    }

    pSrc->FreeMemory(0, pUmiPropNames);
         
error:

    if(FAILED(hr)) {
        if(pUmiProp != NULL)
            pSrc->FreeMemory(0, pUmiProp);
        if(pUmiPropNames != NULL)
            pSrc->FreeMemory(0, pUmiPropNames);
    }

    RRETURN(hr);
}                    

//----------------------------------------------------------------------------
// Function:   Refresh 
//
// Synopsis:   Implements IUmiObject::Refresh. Calls GetInfo on WinNT
//             object to refresh the cache. GetInfoEx is implemented by
//             just calling  GetInfo in the WinNT provider.
//
// Arguments
//
// uFlags      Flags for Refresh. Must be 0 for now.
// uNameCount  Number of attributes to refresh
// pszNames    Names of attributes to refresh
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::Refresh(
    ULONG uFlags,
    ULONG uNameCount,
    LPWSTR *pszNames
    )
{
    ULONG   i = 0;
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if( (uFlags != UMI_FLAG_REFRESH_ALL) && 
                    (uFlags != UMI_FLAG_REFRESH_PARTIAL) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if( ((NULL == pszNames) && (uNameCount != 0)) || 
                         ((pszNames != NULL) && (0 == uNameCount)) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    // ensure all attributes are valid
    for(i = 0; i < uNameCount; i++)
        if(NULL == pszNames[i])
            BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(UMI_FLAG_REFRESH_PARTIAL == uFlags) {
    // do an implicit GetInfo on the WinNT object
        if(NULL == m_pCoreObj)
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        if(uNameCount != 0) {
        // can't specify UMI_FLAG_REFRESH_PARTIAL and attribute names
            BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);
        }

        hr = m_pCoreObj->ImplicitGetInfo();
        BAIL_ON_FAILURE(hr);
    }
    else {
        if(NULL == m_pIADs) 
        // shouldn't happen, but just being paranoid
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);

        hr = m_pIADs->GetInfo();

        BAIL_ON_FAILURE(hr);
    }

    m_fRefreshDone = TRUE;

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   Commit 
//
// Synopsis:   Implements IUmiObject::Commit. Calls SetInfo on WinNT
//             object to commit changes made to the cache. 
//
// Arguments
//
// uFlags      Flags for Refresh.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::Commit(ULONG uFlags)
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    // CIMOM always calls with UMI_DONT_COMMIT_SECURITY_DESCRIPTOR set. Ignore
    // this flag as it is not meaningful on WinNT.
    if( (uFlags != 0) && (uFlags != UMI_DONT_COMMIT_SECURITY_DESCRIPTOR) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == m_pIADs)
    // shouldn't happen, but just being paranoid
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    hr = m_pIADs->SetInfo();
    BAIL_ON_FAILURE(hr);

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}   

//----------------------------------------------------------------------------
// IUmiPropList methods
//
// These are implemented by invoking the corresponding method in the
// CUmiPropList object that implements object properties. For a description
// of these methods, refer to cumiprop.cxx
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::Put(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProp
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->Put(
                pszName,
                uFlags,
                pProp
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus(  // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                ); 
           
         SetLastStatus(ulStatus);
    }
 
    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::Get(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->Get(
                pszName,
                uFlags,
                ppProp
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::GetAs(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uCoercionType,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->GetAs(
                pszName,
                uFlags,
                uCoercionType,
                ppProp
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::FreeMemory(
    ULONG uReserved,
    LPVOID pMem
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->FreeMemory(
                uReserved,
                pMem
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::GetAt(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uBufferLength,
    LPVOID pExistingMem 
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->GetAt(
                pszName,
                uFlags,
                uBufferLength,
                pExistingMem
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::GetProps(
    LPCWSTR *pszNames,
    ULONG uNameCount,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **pProps
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->GetProps(
                pszNames,
                uNameCount,
                uFlags,
                pProps
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::PutProps(
    LPCWSTR *pszNames,
    ULONG uNameCount,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProps
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->PutProps(
                pszNames,
                uNameCount,
                uFlags,
                pProps
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::PutFrom(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uBufferLength,
    LPVOID pExistingMem
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->PutFrom(
                pszName,
                uFlags,
                uBufferLength,
                pExistingMem
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

HRESULT CUmiObject::Delete(
    LPCWSTR pszName,
    ULONG uFlags
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    ULONG   ulStatus = 0;
    IID     iid;

    SetLastStatus(0);

    if(NULL == m_pObjProps) {
        SetLastStatus(UMI_E_NOTIMPL);
        RRETURN(UMI_E_NOTIMPL);
    }

    hr = m_pObjProps->Delete(
                pszName,
                uFlags
                );

    if(FAILED(hr)) {
         m_pObjProps->GetLastStatus( // ignore error return
                0,
                &ulStatus,
                iid,
                NULL
                );

         SetLastStatus(ulStatus);
    }

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   GetLastStatus
//
// Synopsis:   Returns status or error code from the last operation. Currently
//             only numeric status is returned i.e, no error objects are
//             returned. Implements IUmiBaseObject::GetLastStatus().
//
// Arguments:
//
// uFlags           Reserved. Must be 0 for now.
// puSpecificStatus Returns status code
// riid             IID requested. Ignored currently.
// pStatusObj       Returns interface requested. Always returns NULL currently.
//
// Returns:         UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:        *puSpecificStatus to return status code.
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if(pStatusObj != NULL)
       *pStatusObj = NULL;

    if(puSpecificStatus != NULL)
        *puSpecificStatus = 0;

    if(uFlags != 0)
        RRETURN(UMI_E_INVALID_FLAGS);

    if(NULL == puSpecificStatus)
        RRETURN(UMI_E_INVALIDARG);

    *puSpecificStatus = m_ulErrorStatus;

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   SetLastStatus
//
// Synopsis:   Sets the status of the last operation. 
//
// Arguments:
//
// ulStatus    Status to be set
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
void CUmiObject::SetLastStatus(ULONG ulStatus)
{
    m_ulErrorStatus = ulStatus;

    return;
}

//----------------------------------------------------------------------------
// Function:   GetInterfacePropList
//
// Synopsis:   Returns a pointer to the interface property list implementation
//             for the connection object. Implements
//             IUmiBaseObject::GetInterfacePropList().
//
// Arguments:
//
// uFlags      Reserved. Must be 0 for now.
// pPropList   Returns pointer to IUmiPropertyList interface
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pPropList to return interface pointer
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::GetInterfacePropList(
    ULONG uFlags,
    IUmiPropList **pPropList
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == pPropList)
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    ADsAssert(m_pIntfProps != NULL);

    hr = m_pIntfProps->QueryInterface(IID_IUmiPropList, (void **) pPropList);

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   IsRelativePath 
//
// Synopsis:   Checks if a path is relative or absolute 
//
// Arguments:
//
// pURL        IUmiURL interface containing the path
//
// Returns:    TRUE if the path is relative, FALSE otherwise 
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
BOOL CUmiObject::IsRelativePath(IUmiURL *pURL)
{
    HRESULT hr = S_OK;
    ULONGLONG PathType = 0;

    ADsAssert(pURL != NULL);

    hr = pURL->GetPathInfo(
        0,
        &PathType
        );
    BAIL_ON_FAILURE(hr);

    if(PathType & UMIPATH_INFO_RELATIVE_PATH)
        RRETURN(TRUE);
    else
        RRETURN(FALSE);

error:

    RRETURN(FALSE);
}

//----------------------------------------------------------------------------
// Function:   GetClassAndPath 
//
// Synopsis:   Obtains the class name and path from a relative UMI path. 
//             The class name and value are mandatory. The key is optional.
//
// Arguments:
//
// pszPath     String containing the path
// ppszClass   Returns string containing the class name
// ppszPath    Returns string containing the path
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise. 
//
// Modifies:   *ppszClass and *ppszPath 
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::GetClassAndPath(
    LPWSTR pszPath,
    LPWSTR *ppszClass,
    LPWSTR *ppszPath
    )
{
    HRESULT hr = UMI_S_NO_ERROR;
    WCHAR   *pSeparator = NULL, *pValSeparator = NULL;

    ADsAssert( (pszPath != NULL) && (ppszClass != NULL) && 
                                                (ppszPath != NULL) );

    *ppszClass = NULL;
    *ppszPath = NULL;

    // look for the '=' in the relative path
    if(NULL == (pValSeparator = wcschr(pszPath, VALUE_SEPARATOR)))
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);

    *pValSeparator = L'\0';
    *ppszPath = AllocADsStr(pValSeparator+1);
    if(NULL == *ppszPath)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY); 
        
    if(NULL == (pSeparator = wcschr(pszPath, CLASS_SEPARATOR))) {
    // path does not have a key in it
        *ppszClass = AllocADsStr(pszPath);
        if(NULL == *ppszClass)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    }
    else {
    // path has a key. Make sure it is "Name". 
        *pSeparator = L'\0';
       
        if(_wcsicmp(pSeparator+1, WINNT_KEY_NAME))
            BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
 
        *ppszClass = AllocADsStr(pszPath);
        if(NULL == *ppszClass)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    }

    RRETURN(UMI_S_NO_ERROR);

error:

    if(*ppszPath != NULL)
        FreeADsStr(*ppszPath);

    if(*ppszClass != NULL)
        FreeADsStr(*ppszClass);

    *ppszPath = *ppszClass = NULL;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   Open 
//
// Synopsis:   Opens the object specified by a URL. URL has to be a relative 
//             UMI path. Implements IUmiContainer::Open().
//
// Arguments:
//
// pURL        Pointer to an IUmiURL interface
// uFlags      Reserved. Must be 0 for now.
// TargetIID   Interface requested
// ppInterface Returns pointer to interface requested
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::Open(
    IUmiURL *pURL,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppInterface
    )
{
    BOOL      fIsRelPath = FALSE;
    HRESULT   hr = UMI_S_NO_ERROR;
    WCHAR     pszUrl[MAX_URL+1];
    WCHAR     *pszLongUrl = pszUrl;
    ULONG     ulUrlLen = MAX_URL;
    WCHAR     *pszClass = NULL, *pszPath = NULL;
    IDispatch *pIDispatch = NULL;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if( (NULL == pURL) || (NULL == ppInterface) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(NULL == m_pIADsContainer)
    // shouldn't happen, but just in case...
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // Get the path from the URL
    hr = pURL->Get(0, &ulUrlLen, pszUrl);

    if(WBEM_E_BUFFER_TOO_SMALL == hr) {
    // need to allocate more memory for URL
        pszLongUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
        if(NULL == pszLongUrl)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

        hr = pURL->Get(0, &ulUrlLen, pszLongUrl);
    }
    BAIL_ON_FAILURE(hr);

    // Check if the path is relative or absolute
    fIsRelPath = IsRelativePath(pURL);
    
    if(TRUE == fIsRelPath) {
        // check if the caller specified the class as part of the path 
        hr = GetClassAndPath(pszLongUrl, &pszClass, &pszPath);
        BAIL_ON_FAILURE(hr);

        m_pCreds->SetUmiFlag();

        hr = m_pIADsContainer->GetObject(
                    pszClass,
                    pszPath,
                    &pIDispatch
                    );

        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);

        hr = pIDispatch->QueryInterface(
                    TargetIID,
                    ppInterface
                    );
        BAIL_ON_FAILURE(hr); 
    } // if(TRUE == fIsRelPath
    else {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
    }

error:
 
    if(pIDispatch != NULL)
        pIDispatch->Release();

    if(pszClass != NULL)
        FreeADsMem(pszClass);

    if(pszPath != NULL)
        FreeADsMem(pszPath);

     if(pszLongUrl != pszUrl)
         FreeADsMem(pszLongUrl);

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}         
    

//----------------------------------------------------------------------------
// Function:   PutObject 
//
// Synopsis:   Commits an object into the container. Not implemented currently. 
//             Implements IUmiContainer::Put().
//
// Arguments:
//
// uFlags      Reserved. Must be 0 for now.
// TargetIID   IID of nterface pointer sent in
// pInterface  Interface pointer sent in 
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::PutObject(
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  pInterface
    )   
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}

//----------------------------------------------------------------------------
// Function:   DeleteObject 
//
// Synopsis:   Deletes the object specified by the relative UMI path. 
//             Implements IUmiContainer::Delete(). 
//
// Arguments:
//
// pURL        Pointer to an IUmiURL interface
// uFlags      Reserved. Must be 0 for now.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::DeleteObject(
    IUmiURL *pURL,
    ULONG   uFlags
    )
{
    ULONG    ulUrlLen = MAX_URL;
    WCHAR    pszUrl[MAX_URL+1], *pszClass = NULL, *pszPath = NULL;
    WCHAR    *pszLongUrl = pszUrl;
    BOOL     fIsRelPath = FALSE;
    HRESULT  hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == pURL)
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(NULL == m_pIADsContainer)
    // shouldn't happen, but just in case...
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // Get the path from the URL
    hr = pURL->Get(0, &ulUrlLen, pszUrl);

    if(WBEM_E_BUFFER_TOO_SMALL == hr) {
    // need to allocate more memory for URL
        pszLongUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
        if(NULL == pszLongUrl)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

        hr = pURL->Get(0, &ulUrlLen, pszLongUrl);
    }
    BAIL_ON_FAILURE(hr);

    // Check if the path is relative or absolute
    fIsRelPath = IsRelativePath(pURL);

    if(TRUE == fIsRelPath) {
        // check if the caller specified the class as part of the path
        hr = GetClassAndPath(pszLongUrl, &pszClass, &pszPath);
        BAIL_ON_FAILURE(hr);

        m_pCreds->SetUmiFlag();

        hr = m_pIADsContainer->Delete(
                    pszClass,
                    pszPath
                    );

        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);
    } // if(TRUE == fIsRelPath
    else {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
    }   

error:

    if(pszClass != NULL)
        FreeADsMem(pszClass);

    if(pszPath != NULL)
        FreeADsMem(pszPath);

    if(pszLongUrl != pszUrl)
        FreeADsMem(pszLongUrl);

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   Create
//
// Synopsis:   Creates the object specified by the relative UMI path. 
//             Implements IUmiContainer::Create().
//
// Arguments:
//
// pURL        Pointer to an IUmiURL interface
// uFlags      Reserved. Must be 0 for now.
// ppNewObj    Returns pointer to IUmiObject interface on new object
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pNewObject to return the IUmiObject interface 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::Create(
    IUmiURL *pURL,
    ULONG   uFlags,
    IUmiObject **ppNewObj
    )
{
    ULONG     ulUrlLen = MAX_URL;
    WCHAR     pszUrl[MAX_URL+1], *pszClass = NULL, *pszPath = NULL;
    WCHAR     *pszLongUrl = pszUrl;
    BOOL      fIsRelPath = FALSE;
    HRESULT   hr = UMI_S_NO_ERROR;
    IDispatch *pIDispatch = NULL;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if( (NULL == pURL) || (NULL == ppNewObj) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(NULL == m_pIADsContainer)
    // shouldn't happen, but just in case...
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // Get the path from the URL
    hr = pURL->Get(0, &ulUrlLen, pszUrl);

    if(WBEM_E_BUFFER_TOO_SMALL == hr) {
    // need to allocate more memory for URL
        pszLongUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
        if(NULL == pszLongUrl)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

        hr = pURL->Get(0, &ulUrlLen, pszLongUrl);
    }
    BAIL_ON_FAILURE(hr);

    // Check if the path is relative or absolute
    fIsRelPath = IsRelativePath(pURL);

    if(TRUE == fIsRelPath) {
        // check if the caller specified the class as part of the path
        hr = GetClassAndPath(pszLongUrl, &pszClass, &pszPath);
        BAIL_ON_FAILURE(hr);

        m_pCreds->SetUmiFlag();

        hr = m_pIADsContainer->Create(
                    pszClass,
                    pszPath,
                    &pIDispatch
                    );

        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);

        hr = pIDispatch->QueryInterface(
                    IID_IUmiObject,
                    (void **) ppNewObj 
                    );
        BAIL_ON_FAILURE(hr);
    } // if(TRUE == fIsRelPath
    else {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
    }

error:
 
    if(pIDispatch != NULL)
        pIDispatch->Release();

    if(pszClass != NULL)
        FreeADsMem(pszClass);

    if(pszPath != NULL)
        FreeADsMem(pszPath);

    if(pszLongUrl != pszUrl)
        FreeADsMem(pszLongUrl);

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   Move 
//
// Synopsis:   Moves a specified object into the container. Implements
//             IUmiContainer::Move().
//
// Arguments:
//
// uFlags      Reserved. Must be 0 for now.
// pOldURL     URL of the object to be moved
// pNewURL     New URL of the object within the container. If NULL, the new
//             name will be the same as the old one.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::Move(
    ULONG   uFlags,
    IUmiURL *pOldURL,
    IUmiURL *pNewURL
    )
{
    ULONG     ulUrlLen = MAX_URL;
    WCHAR     pszNewUrl[MAX_URL+1], pszOldUrl[MAX_URL+1];
    WCHAR     *pszLongNewUrl = pszNewUrl, *pszLongOldUrl = pszOldUrl;
    WCHAR     *pszDstPath = NULL, *pszTmpStr = NULL;
    WCHAR     *pszClass = NULL;
    BOOL      fIsRelPath = FALSE;
    IDispatch *pIDispatch = NULL;
    HRESULT   hr = UMI_S_NO_ERROR;
    ULONGLONG PathType = 0;
    WCHAR     *pSeparator = NULL;
    DWORD     dwNumComponents = 0, dwIndex = 0;
    LPWSTR    *ppszClasses = NULL;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if(NULL == pOldURL)
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(NULL == m_pIADsContainer)
    // shouldn't happen, but just in case...
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // Get the path from the URL
    if(pNewURL != NULL) {
        hr = pNewURL->Get(0, &ulUrlLen, pszNewUrl);

        if(WBEM_E_BUFFER_TOO_SMALL == hr) {
        // need to allocate more memory for URL
            pszLongNewUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
            if(NULL == pszLongNewUrl)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

            hr = pNewURL->Get(0, &ulUrlLen, pszLongNewUrl);
        }
        BAIL_ON_FAILURE(hr);

        // Check if the path is relative or absolute
        fIsRelPath = IsRelativePath(pNewURL);
    }
    else {
        fIsRelPath = TRUE;
        pszDstPath = NULL;
    }

    // check if old path is native or UMI path
    hr = pOldURL->GetPathInfo(0, &PathType);
    BAIL_ON_FAILURE(hr);

    if(PathType & UMIPATH_INFO_NATIVE_STRING) {
    // Get the native path from the URL
        ulUrlLen = MAX_URL;
        hr = pOldURL->Get(0, &ulUrlLen, pszOldUrl);

        if(WBEM_E_BUFFER_TOO_SMALL == hr) {
        // need to allocate more memory for URL
            pszLongOldUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
            if(NULL == pszLongOldUrl)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

            hr = pOldURL->Get(0, &ulUrlLen, pszLongOldUrl);
        }
        BAIL_ON_FAILURE(hr);
    }
    else {
    // assume UMI path if not native
        hr = UmiToWinNTPath(
                pOldURL, 
                &pszLongOldUrl,
                &dwNumComponents,
                &ppszClasses
                );
        BAIL_ON_FAILURE(hr);

        // check to ensure that the UMI path had the expected object classes
        hr = CheckClasses(dwNumComponents, ppszClasses);
        BAIL_ON_FAILURE(hr);
    }

    if(TRUE == fIsRelPath) {
        if(pNewURL != NULL) {
            hr = GetClassAndPath(pszLongNewUrl, &pszClass, &pszDstPath);
            BAIL_ON_FAILURE(hr);

            // Make sure that if the old path had a class specified in the path,
            // then the new path also if of the same class
            if(NULL == (pSeparator = wcschr(pszLongOldUrl, 
                                        NATIVE_CLASS_SEPARATOR))) { 
            // no class specified in the old path. Must have been a native path.
            // Append class to old path.     
                pszTmpStr = (WCHAR *) AllocADsMem( 
                                         (wcslen(pszLongOldUrl)+MAX_CLASS) *
                                         sizeof(WCHAR) );
                if(NULL == pszTmpStr)
                    BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

                wcscpy(pszTmpStr, pszLongOldUrl);
                wcscat(pszTmpStr, L",");
                wcscat(pszTmpStr, pszClass);

                if(pszLongOldUrl != pszOldUrl)
                    FreeADsMem(pszLongOldUrl);

                pszLongOldUrl = pszTmpStr;
            }
            else {
            // old path already had a class in it
                if(_wcsicmp(pSeparator+1, pszClass))
                    BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
            }
        } // if(pNewUrl != NULL)

        m_pCreds->SetUmiFlag();
            
        hr = m_pIADsContainer->MoveHere(
                    pszLongOldUrl,
                    pszDstPath,
                    &pIDispatch
                    );

        m_pCreds->ResetUmiFlag();

        BAIL_ON_FAILURE(hr);
    } // if(TRUE == fIsRelPath)
    else {
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
    }

error:

    if(pIDispatch != NULL)
        pIDispatch->Release();

    if(pszLongOldUrl != pszOldUrl)
        FreeADsMem(pszLongOldUrl);

    if(pszLongNewUrl != pszNewUrl)
        FreeADsMem(pszLongNewUrl);

    if(pszClass != NULL)
        FreeADsStr(pszClass);

    if(pszDstPath != NULL)
        FreeADsStr(pszDstPath);

    if(ppszClasses != NULL) {
        for(dwIndex = 0; dwIndex < dwNumComponents; dwIndex++) {
            if(ppszClasses[dwIndex] != NULL)
                FreeADsStr(ppszClasses[dwIndex]);
        }
        FreeADsMem(ppszClasses);
    }

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   CreateEnum 
//
// Synopsis:   Creates an enumerator within a container. The enumerator is
//             a IUmiCursor interface pointer. The caller can optionally set
//             a filter on the cursor and then enumerate the contents of the
//             container. The actual enumeration of the container does
//             not happen in this function. It is deferred to the point
//             when the cursor is used to enumerate the results.
//
// Arguments:
//
// pszEnumContext Not used. Must be NULL.
// uFlags         Reserved. Must be 0 for now.
// TargetIID      Interface requested. Has to be IUmiCursor.
// ppInterface    Returns the IUmiCursor interface pointer
//
// Returns:       UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:      *ppInterface to return the IUmiCursor interface 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::CreateEnum(
    IUmiURL *pszEnumContext,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppInterface
    )
{
    HRESULT  hr = UMI_S_NO_ERROR;
    IUnknown *pEnumerator = NULL;

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if( (pszEnumContext != NULL) || (NULL == ppInterface) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(!IsEqualIID(IID_IUmiCursor, TargetIID))
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    *ppInterface = NULL;

    if(NULL == m_pIADsContainer)
    // shouldn't happen, but just in case...
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    hr = CUmiCursor::CreateCursor(m_pCreds, m_pUnkInner, TargetIID, 
                                  ppInterface);
    BAIL_ON_FAILURE(hr);

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   ExecQuery 
//
// Synopsis:   Executes a query in a container. Not implemented on WinNT. 
//             Implements IUmiContainer::ExecQuery().
//
// Arguments:
//
// pQuery      IUmiQuery interface containing the query
// uFlags      Reserved. Must be 0 for now.
// TargetIID   Interface requested
// ppInterface Returns pointer to interface requested
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::ExecQuery(
    IUmiQuery *pQuery,
    ULONG   uFlags,
    REFIID  TargetIID,
    LPVOID  *ppInterface
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}

//----------------------------------------------------------------------------
// Function:   GetCLSIDForIID 
//
// Synopsis:   Returns the CLSID corresponding to a given interface IID. If
//             the interface is one of the interfaces implemented by the
//             underlying WinNT object, then CLSID_WinNTObject is returned.
//             If the IID is one of the interfaces implemented by an 
//             extension object, then the extension's CLSID is returned. 
//             Implements IUmiCustomInterfaceFactory::GetCLSIDForIID.
//
// Arguments:
//
// riid        Interface ID for which we want to find the CLSID 
// lFlags      Reserved. Must be 0.
// pCLSID      Returns the CLSID corresponding to the IID.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pCLSID to return CLSID.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::GetCLSIDForIID(
    REFIID riid,
    long lFlags,
    CLSID *pCLSID
    )
{
    HRESULT  hr = S_OK;
    IUnknown *pUnknown = NULL;

    SetLastStatus(0);

    if( (lFlags != 0) || (NULL == pCLSID) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(m_pExtMgr != NULL) {
    // check if there is any extension which supports this IID
        hr = m_pExtMgr->GetCLSIDForIID(
                riid,
                lFlags,
                pCLSID
                );
        if(SUCCEEDED(hr))
            RRETURN(UMI_S_NO_ERROR);
    }

    // check if the underlying WinNT object supports this IID
    hr = m_pUnkInner->QueryInterface(riid, (void **) &pUnknown);
    if(SUCCEEDED(hr)) {
        pUnknown->Release();
        memcpy(pCLSID, &CLSID_WinNTObject, sizeof(GUID));

        RRETURN(UMI_S_NO_ERROR);
    }

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}
     
//----------------------------------------------------------------------------
// Function:   GetObjectByCLSID
//
// Synopsis:   Returns a pointer to a requested interface on the object 
//             specified by a CLSID. The object specified by the CLSID is
//             aggregated by the specified outer unknown. The interface
//             returned is a non-delegating interface on the object.
//             Implements IUmiCustomInterfaceFactory::GetObjectByCLSID.
//
// Arguments:
//
// clsid       CLSID of object on which interface should be obtained
// pUnkOuter   Aggregating outer unknown. 
// dwClsContext Context for running executable code. 
// riid        Interface requested. Has to be IID_IUnknown.
// lFlags      Reserved. Must be 0.
// ppInterface Returns requested interface
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppInterface to return requested interface
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::GetObjectByCLSID(
    CLSID clsid,
    IUnknown *pUnkOuter,
    DWORD dwClsContext,
    REFIID riid,
    long lFlags,
    void **ppInterface
    )
{
    HRESULT  hr = S_OK;
    IUnknown *pCurOuterUnk = NULL;

    SetLastStatus(0);

    if( (lFlags != 0) || (NULL == pUnkOuter) || (NULL == ppInterface) ||
                         (dwClsContext != CLSCTX_INPROC_SERVER) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    // ensure outer unknown specified is same as what is on the WinNT object
    if(TRUE == m_fOuterUnkSet) {
        pCurOuterUnk = m_pCoreObj->GetOuterUnknown();

        if(pCurOuterUnk != pUnkOuter)
            BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);
    }

    // Interface requested has to be IID_IUnknown if there is an outer unknown
    if (!IsEqualIID(riid, IID_IUnknown)) 
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(!IsEqualCLSID(clsid, CLSID_WinNTObject)) {
    // has to be a CLSID of an extension object
        if(m_pExtMgr != NULL) {

            hr = m_pExtMgr->GetObjectByCLSID(
                clsid,
                pUnkOuter,
                riid,
                ppInterface
                );
            BAIL_ON_FAILURE(hr);

            // successfully got the interface
            m_pCoreObj->SetOuterUnknown(pUnkOuter); 
            m_fOuterUnkSet = TRUE;

            RRETURN(UMI_S_NO_ERROR);
        }
        else
            BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG); // bad CLSID
    }

    // CLSID == CLSID_WinNTObject. This has to be an interface on the
    // underlying WinNT object. 

    m_pCoreObj->SetOuterUnknown(pUnkOuter);
    m_fOuterUnkSet = TRUE;

    *ppInterface = m_pUnkInner;
    m_pUnkInner->AddRef();

    RRETURN(UMI_S_NO_ERROR);

error:

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   GetCLSIDForNames
//
// Synopsis:   Returns the CLSID of the object that supports a specified
//             method/property. Also returns DISPIDs for the property/method.
//             Implements IUmiCustomInterfaceFactory::GetCLSIDForNames.
//
// Arguments:
//
// rgszNames   Names to be mapped
// cNames      Number of names to be mapped
// lcid        Locale in which to interpret the names
// rgDispId    Returns DISPID
// lFlags      Reserved. Must be 0.
// pCLSID      Returns CLSID of object which supports this property/method.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pCLSID to return the CLSID.
//             *rgDispId to return the DISPIDs.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::GetCLSIDForNames(
    LPOLESTR *rgszNames,
    UINT cNames,
    LCID lcid,
    DISPID *rgDispId,
    long lFlags,
    CLSID *pCLSID
    )
{
    HRESULT   hr = S_OK;
    IDispatch *pDispatch = NULL;

    SetLastStatus(0);

    if( (lFlags != 0) || (NULL == pCLSID) ) 
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if(0 == cNames)
        RRETURN(UMI_S_NO_ERROR);

    if( (NULL == rgszNames) || (NULL == rgDispId) )
        RRETURN(UMI_S_NO_ERROR);

    if(m_pExtMgr != NULL) {
    // check if there is any extension which supports this IID
        hr = m_pExtMgr->GetCLSIDForNames(
                rgszNames,
                cNames,
                lcid,
                rgDispId,
                lFlags,
                pCLSID
                );
        if(SUCCEEDED(hr))
        // successfully got the CLSID and DISPIDs
            RRETURN(UMI_S_NO_ERROR);
    }

    // check if the underlying WinNT object supports this name 
    hr = m_pUnkInner->QueryInterface(IID_IDispatch, (void **) &pDispatch);
    if(FAILED(hr))
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    hr = pDispatch->GetIDsOfNames(
                 IID_NULL,
                 rgszNames,
                 cNames,
                 lcid,
                 rgDispId
                 );
    if(SUCCEEDED(hr)) {
        pDispatch->Release();
        memcpy(pCLSID, &CLSID_WinNTObject, sizeof(GUID));

        RRETURN(UMI_S_NO_ERROR);
    }


error:

    if(pDispatch != NULL)
        pDispatch->Release();

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}     

//----------------------------------------------------------------------------
// Function:   GetContainer
//
// Synopsis:   Returns a pointer to the IADsContainer interface of the 
//             underlying WinNT object. Used as a backdoor to get access to
//             the WinNT object from a UMI object. Implements
//             IUmiADSIPrivate::GetContainer(). 
//
// Arguments:
//
// ppContainer Returns pointer to IADsContainer interface on WinNT object
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppContainer to return the IADsContainer interface pointer. 
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::GetContainer(void **ppContainer)
{
    if(NULL == ppContainer)
        RRETURN(UMI_E_INVALIDARG);

    *ppContainer = (void *) m_pIADsContainer;
    if(m_pIADsContainer != NULL)
        m_pIADsContainer->AddRef();

    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   CopyTo 
//
// Synopsis:   Creates an uncommitted copy of an object at the location 
//             specified by a URL. This is the same as Clone except that
//             the new object has a different path than the old one. If the
//             cache is dirty in teh source object, then the destination will
//             also end up with a dirty cache. 
//
// Update:     This method will not be supported for now.
//
// Arguments:
//
// uFlags      Flags for CopyTo. Must be 0 for now.
// pURL        Destination path (native or UMI)
// riid        Interface requested from new object
// pCopy       Returns interface requested 
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pCopy to return requested interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::CopyTo(
    ULONG uFlags,
    IUmiURL *pURL,
    REFIID riid,
    LPVOID *pCopy
    )
{
    HRESULT       hr = UMI_S_NO_ERROR;
    ULONGLONG     PathType = 0;
    WCHAR         pszUrl[MAX_URL+1];
    WCHAR         *pszLongUrl = pszUrl;
    ULONG         ulUrlLen = MAX_URL;
    LPWSTR        RelName = NULL;
    BSTR          bstrClass = NULL;
    IUnknown      *pUnkParent = NULL;
    IADsContainer *pIADsCont = NULL;
    IDispatch     *pDispatch = NULL;
    IUmiObject    *pUmiObj = NULL;
    IUmiADSIPrivate *pUmiPrivate = NULL;
    OBJECTINFO    ObjectInfo;
    POBJECTINFO   pObjectInfo = NULL;
    CLexer        Lexer(NULL);
    DWORD         dwNumComponents = 0, dwIndex = 0, dwCoreIndex = 0;
    LPWSTR        *ppszClasses = NULL;
    CCoreADsObject *pCoreObj = NULL;

    SetLastStatus(UMI_E_NOTIMPL);
    RRETURN(UMI_E_NOTIMPL);

    SetLastStatus(0);

    if(uFlags != 0)
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if( (NULL == pCopy) || (NULL == pURL) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    if( (NULL == m_pCoreObj) || (NULL == m_pIADs) )
    // shouldn't happen, but just being paranoid
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    *pCopy = NULL;

    // check if this is a native path or UMI path
    hr = pURL->GetPathInfo(0, &PathType);
    BAIL_ON_FAILURE(hr);

    if(PathType & UMIPATH_INFO_NATIVE_STRING) {
    // Get the native path from the URL
        hr = pURL->Get(0, &ulUrlLen, pszUrl);

        if(WBEM_E_BUFFER_TOO_SMALL == hr) {
        // need to allocate more memory for URL
            pszLongUrl = (WCHAR *) AllocADsMem(ulUrlLen * sizeof(WCHAR));
            if(NULL == pszLongUrl)
                BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

            hr = pURL->Get(0, &ulUrlLen, pszLongUrl);
        }
        BAIL_ON_FAILURE(hr);
    }
    else {
    // assume UMI path if not native
        hr = UmiToWinNTPath(
                pURL, 
                &pszLongUrl,
                &dwNumComponents,
                &ppszClasses
                );
        BAIL_ON_FAILURE(hr);
    }

    // get the native path of the parent and the relative name of new object
 
    Lexer.SetBuffer(pszLongUrl);
    pObjectInfo = &ObjectInfo;
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    if(FAILED(hr)) {
        pObjectInfo = NULL; // so we don't attempt to free object info later
        goto error;
    }

    hr = BuildParent(pObjectInfo, pszLongUrl);
    BAIL_ON_FAILURE(hr);

    if(pObjectInfo->NumComponents != 0)
        RelName = 
          pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents - 1];
    else
    // can't have a parent for such a path
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // Decrement number of components since we are dealing with the parent
    dwNumComponents--;

    hr = GetObject(
            pszLongUrl,
            (LPVOID *) &pUnkParent,
            *m_pCreds
            );
    BAIL_ON_FAILURE(hr);

    hr = pUnkParent->QueryInterface(
            IID_IUmiADSIPrivate,
            (LPVOID *) &pUmiPrivate
            );
    BAIL_ON_FAILURE(hr);

    hr = pUmiPrivate->GetCoreObject((void **) &pCoreObj);
    BAIL_ON_FAILURE(hr);

    // walk the list of classes in reverse order. Reason for reverse order
    // is that the WinNT provider may tack on an additional component to
    // the ADsPath stored in the core object. For example,
    // Open("WinNT://ntdsdc1") would return an ADsPath of
    // "WinNT://ntdev/ntdsdc1".

    if(dwNumComponents > 0) {
        dwCoreIndex = pCoreObj->_dwNumComponents - 1;
        for(dwIndex = dwNumComponents - 1; ((long) dwIndex) >= 0; dwIndex--) {
            if( _wcsicmp(
                  ppszClasses[dwIndex],
                  pCoreObj->_CompClasses[dwCoreIndex]) ) {

                BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH);
            }

            dwCoreIndex--;
        }
    }

    hr = pUmiPrivate->GetContainer((void **) &pIADsCont);
    BAIL_ON_FAILURE(hr);

    if(NULL == pIADsCont)
    // parent object is not a container
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // get the class of this object
    hr = m_pIADs->get_Class(&bstrClass);
    BAIL_ON_FAILURE(hr);

    // make sure that the destination path mentioned the same class
    if(_wcsicmp(bstrClass, ppszClasses[dwNumComponents]))
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_PATH); 
   
    // now Create() the new object
    hr = pIADsCont->Create(
            bstrClass,
            RelName,
            &pDispatch
            );
    if(E_NOTIMPL == hr) // parent is namespace object
        hr = UMI_E_FAIL;
    BAIL_ON_FAILURE(hr);

    hr = pDispatch->QueryInterface(IID_IUmiObject, (LPVOID *) &pUmiObj);
    BAIL_ON_FAILURE(hr); 

    // if the source object is bound, refresh it if required
    if(ADS_OBJECT_BOUND == m_pCoreObj->GetObjectState()) {
    // object exists on server
        if(FALSE == m_fRefreshDone) {
            hr = m_pCoreObj->ImplicitGetInfo();
            BAIL_ON_FAILURE(hr);
        }
    }

    // copy over the attributes in the property cache
    hr = CopyPropCache(pUmiObj, (IUmiObject *) this);
    BAIL_ON_FAILURE(hr);

    hr = pUmiObj->QueryInterface(riid, pCopy);
    BAIL_ON_FAILURE(hr);

error:

    if( (pszLongUrl != NULL) && (pszLongUrl != pszUrl) )
        FreeADsMem(pszLongUrl);

    if(bstrClass != NULL)
        SysFreeString(bstrClass);

    if(pUnkParent != NULL)
        pUnkParent->Release();

    if(pIADsCont != NULL)
        pIADsCont->Release();

    if(pUmiObj != NULL)
        pUmiObj->Release();

    if(pUmiPrivate != NULL)
        pUmiPrivate->Release();

    if(pDispatch != NULL)
        pDispatch->Release();

    if(pObjectInfo != NULL)
        FreeObjectInfo(&ObjectInfo, TRUE);

    if(ppszClasses != NULL) {
        for(dwIndex = 0; dwIndex < dwNumComponents; dwIndex++) {
            if(ppszClasses[dwIndex] != NULL)
                FreeADsStr(ppszClasses[dwIndex]);
        }
        FreeADsMem(ppszClasses);
    }

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   GetCoreObject
//
// Synopsis:   Returns a pointer to the core object of the
//             underlying WinNT object. Used as a backdoor to get access to
//             the WinNT core object from a UMI object. Implements
//             IUmiADSIPrivate::GetCoreObject().
//
// Arguments:
//
// ppCoreObj   Returns pointer to core object of WinNT object
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppCoreObj to return the core object pointer.
//
//----------------------------------------------------------------------------
STDMETHODIMP CUmiObject::GetCoreObject(void **ppCoreObj)
{
    if(NULL == ppCoreObj)
        RRETURN(UMI_E_INVALIDARG);

    *ppCoreObj = NULL;

    if(NULL == m_pCoreObj)
    // shouldn't happen. Just being paranoid.
        RRETURN(UMI_E_FAIL);

    *ppCoreObj = (void *) m_pCoreObj;

    RRETURN(S_OK);
}
       
//----------------------------------------------------------------------------
// Function:   CheckClasses 
//
// Synopsis:   Checks that the classes specified in the UMI path passed to
//             Move are valid. Need a separate function for this because UMI
//             doesn't actually retrieve the object that is to be moved - it
//             is handled internally within ADSI. So, we need to check the 
//             classes before calling into ADSI. We make use of the fact that
//             the WinNT provider only supports moving user and group objects. 
//
// Arguments:
//
// dwNumComponents Number of components in the UMI path
// ppszClasses     Class of each component
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
HRESULT CUmiObject::CheckClasses(
    DWORD dwNumComponents,
    LPWSTR *ppszClasses
    )
{
    if(NULL == ppszClasses)
        RRETURN(UMI_E_INVALIDARG);

    if( (dwNumComponents != 2) && (dwNumComponents != 3) )
        RRETURN(UMI_E_INVALIDARG);

    // can only move users or groups
    if( _wcsicmp(ppszClasses[dwNumComponents - 1], USER_CLASS_NAME) &&
        _wcsicmp(ppszClasses[dwNumComponents - 1], GROUP_CLASS_NAME) )
        RRETURN(UMI_E_INVALIDARG);

    if(2 == dwNumComponents) {
        if( _wcsicmp(ppszClasses[0], DOMAIN_CLASS_NAME) &&
            _wcsicmp(ppszClasses[0], COMPUTER_CLASS_NAME) )
            RRETURN(UMI_E_INVALIDARG);
    } 

    if(3 == dwNumComponents) {
        if( _wcsicmp(ppszClasses[0], DOMAIN_CLASS_NAME) ||
            _wcsicmp(ppszClasses[1], COMPUTER_CLASS_NAME) )
            RRETURN(UMI_E_INVALIDARG);
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cuser.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuser.cxx
//
//  Contents:  Host user object code
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop


//  Class CWinNTUser

DEFINE_IDispatch_ExtMgr_Implementation(CWinNTUser)
DEFINE_IADsExtension_ExtMgr_Implementation(CWinNTUser)
DEFINE_IADs_TempImplementation(CWinNTUser)
DEFINE_IADs_PutGetImplementation(CWinNTUser,UserClass,gdwUserTableSize)
DEFINE_IADsPropertyList_Implementation(CWinNTUser,UserClass,gdwUserTableSize)

CWinNTUser::CWinNTUser():
        _pDispMgr(NULL),
        _pExtMgr(NULL),
        _pPropertyCache(NULL),
        _ParentType(0),
        _DomainName(NULL),
        _ServerName(NULL),
        _fPasswordSet(FALSE),   
        _pCCredentialsPwdHolder(NULL),
        _fUseCacheForAcctLocked(TRUE),
        _fComputerAcct(FALSE)
{
    ENLIST_TRACKING(CWinNTUser);
}

HRESULT
CWinNTUser::CreateUser(
    BSTR Parent,
    ULONG ParentType,
    BSTR DomainName,
    BSTR ServerName,
    BSTR UserName,
    DWORD dwObjectState,
    DWORD *pdwUserFlags,    // OPTIONAL
    LPWSTR szFullName,      // OPTIONAL
    LPWSTR szDescription,   // OPTIONAL
    PSID pSid,              // OPTIONAL
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTUser FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserObject(&pUser);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pUser->_pDispMgr);


    hr = pUser->InitializeCoreObject(
                Parent,
                UserName,
                USER_CLASS_NAME,
                USER_SCHEMA_NAME,
                CLSID_WinNTUser,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);


    pUser->_Credentials = Credentials;

    //
    // The server name will be NULL only when we create a user
    // by SID - WinNT://S-1-321-231-231. In this case we should
    // not ref the server. Parent type is used as an extra check.
    //
    if (!((ParentType == WINNT_COMPUTER_ID)
          && !ServerName)) {

        hr = pUser->_Credentials.Ref(ServerName, DomainName, ParentType);
        if (hr == HRESULT_FROM_WIN32(ERROR_BAD_ARGUMENTS)) {
            //
            // We had a rebind error.
            // This will happen in the case where the credentials
            // ref the current server which is a bdc, the users is
            // a member of a global group we are going through and
            // we end up trying to ref the PDC when we already have
            // a connection to this comp.
            hr = S_OK;
        }
    }

    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(DomainName, &pUser->_DomainName);

    BAIL_ON_FAILURE(hr);

    if (ParentType == WINNT_DOMAIN_ID)
    {
        pUser->_ParentType = WINNT_DOMAIN_ID;

        ADsAssert(DomainName && DomainName[0]!=L'\0');
    }
    else
    {
        pUser->_ParentType = WINNT_COMPUTER_ID;
        hr = ADsAllocString(ServerName, &pUser->_ServerName);

        BAIL_ON_FAILURE(hr);
    }


    //
    // Load ext mgr and extensions
    //

    hr = ADSILoadExtensionManager(
                USER_CLASS_NAME,
                (IADsUser *) pUser,
                pUser->_pDispMgr,
                Credentials,
                &pUser->_pExtMgr
                );
    BAIL_ON_FAILURE(hr);

    ADsAssert(pUser->_pExtMgr);

    //
    // Prepopulate the object
    //
    hr = pUser->Prepopulate(TRUE,
                            pdwUserFlags,
                            szFullName,
                            szDescription,
                            pSid);
    BAIL_ON_FAILURE(hr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
    //
    // we do not pass riid to InitUmiObject below. This is because UMI object
    // does not support IDispatch. There are several places in ADSI code where 
    // riid passed into this function is defaulted to IID_IDispatch - 
    // IADsContainer::Create for example. To handle these cases, we always
    // request IID_IUnknown from the UMI object. Subsequent code within UMI 
    // will QI for the appropriate interface.
    //
        if(3 == pUser->_dwNumComponents) {
            pUser->_CompClasses[0] = L"Domain";
            pUser->_CompClasses[1] = L"Computer";
            pUser->_CompClasses[2] = L"User";
        }
        else if(2 == pUser->_dwNumComponents) {
            if(NULL == DomainName) {
                pUser->_CompClasses[0] = L"Computer";
                pUser->_CompClasses[1] = L"User";
            }
            else if(NULL == ServerName) {
                pUser->_CompClasses[0] = L"Domain";
                pUser->_CompClasses[1] = L"User";
            }
            else
                BAIL_ON_FAILURE(hr = UMI_E_FAIL);
       }
       else
            BAIL_ON_FAILURE(hr = UMI_E_FAIL);
         
        hr = pUser->InitUmiObject(   
                pUser->_Credentials,
                UserClass,
                gdwUserTableSize,
                pUser->_pPropertyCache,
                (IUnknown *) (INonDelegatingUnknown *) pUser,
                pUser->_pExtMgr,
                IID_IUnknown,
                ppvObj
                );

        BAIL_ON_FAILURE(hr);

        //
        // UMI object was created and the interface was obtained successfully.
        // UMI object now has a reference to the inner unknown of IADs, since
        // the call to Release() below is not going to be made in this case.
        //
        RRETURN(hr); 
    }
 
    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();

    RRETURN(hr);

error:
    delete pUser;

    RRETURN_EXP_IF_ERR(hr);

}

HRESULT
CWinNTUser::CreateUser(
   BSTR Parent,
   ULONG ParentType,
   BSTR DomainName,
   BSTR ServerName,
   BSTR UserName,
   DWORD dwObjectState,
   REFIID riid,
   CWinNTCredentials& Credentials,
   void **ppvObj
   )
{
    HRESULT hr = S_OK;

    hr = CWinNTUser::CreateUser(
                           Parent,
                           ParentType,
                           DomainName,
                           ServerName,
                           UserName,
                           dwObjectState,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           riid,
                           Credentials,
                           ppvObj
                           );

    RRETURN_EXP_IF_ERR(hr);
}


CWinNTUser::~CWinNTUser( )
{
    ADsFreeString(_DomainName);
    ADsFreeString(_ServerName);

    delete _pExtMgr;                // created last, destroyed first

    delete _pDispMgr;

    delete _pPropertyCache;

    if (_pCCredentialsPwdHolder) {
        delete _pCCredentialsPwdHolder;
    }
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   If this object is aggregated within another object, then
//             all calls will delegate to the outer object. Otherwise, the
//             non-delegating QI is called
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
STDMETHODIMP CWinNTUser::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->QueryInterface(
                iid,
                ppInterface
                ));

    RRETURN(NonDelegatingQueryInterface(
            iid,
            ppInterface
            ));
}

//----------------------------------------------------------------------------
// Function:   AddRef
//
// Synopsis:   IUnknown::AddRef. If this object is aggregated within
//             another, all calls will delegate to the outer object. 
//             Otherwise, the non-delegating AddRef is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTUser::AddRef(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->AddRef());

    RRETURN(NonDelegatingAddRef());
}

//----------------------------------------------------------------------------
// Function:   Release 
//
// Synopsis:   IUnknown::Release. If this object is aggregated within
//             another, all calls will delegate to the outer object.
//             Otherwise, the non-delegating Release is called
//
// Arguments:
//
// None
//
// Returns:    New reference count
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWinNTUser::Release(void)
{
    if(_pUnkOuter != NULL)
        RRETURN(_pUnkOuter->Release());

    RRETURN(NonDelegatingRelease());
}

//----------------------------------------------------------------------------

STDMETHODIMP
CWinNTUser::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsUser))
    {
        *ppv = (IADsUser FAR *) this;
    }

    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyList))
    {
        *ppv = (IADsPropertyList FAR *) this;
    }

    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsUser FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if( (_pDispatch != NULL) &&
             IsEqualIID(iid, IID_IADsExtension) )
    {
        *ppv = (IADsExtension *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN(_pExtMgr->QueryInterface(iid,ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTUser::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsPropertyList) ||
        IsEqualIID(riid, IID_IADsUser)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

/* IADs methods */

STDMETHODIMP
CWinNTUser::SetInfo(THIS)
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    WCHAR szPDCName[MAX_PATH];
    WCHAR *pszPassword = NULL;
    WCHAR *pszServerName = _ServerName;

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        if (_ParentType == WINNT_DOMAIN_ID) {

            hr = WinNTGetCachedDCName(
                           _DomainName,
                           szPDCName,
                           _Credentials.GetFlags()
                            );
            BAIL_ON_FAILURE(hr);

            //
            // + 2 skips the backslashes when calling create
            //
            pszServerName = szPDCName + 2;
        }


        if (!_fPasswordSet) {


            hr = WinNTCreateUser(
                     pszServerName,
                     _Name
                     );

        } else {

            hr = getPrivatePassword(&pszPassword);
            BAIL_ON_FAILURE(hr);

            hr = WinNTCreateUser(
                     pszServerName,
                     _Name,
                     pszPassword
                     );
        }

        BAIL_ON_FAILURE(hr);


        SetObjectState(ADS_OBJECT_BOUND);
    }


    hr = SetInfo(3);

    if(SUCCEEDED(hr))
        _pPropertyCache->ClearModifiedFlags();

error:

    if (pszPassword) {
        SecureZeroMemory(pszPassword, sizeof(WCHAR) * wcslen(pszPassword));
        FreeADsStr(pszPassword);
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUser::GetInfo(THIS)
{
    HRESULT hr;

    _pPropertyCache->flushpropcache();

    // USER_INFO
    //

    hr = GetInfo(
                3,
                TRUE
                );

    BAIL_ON_FAILURE(hr);

    //
    // USER_MODAL_INFO0
    //

    hr =  GetInfo(
                10,
                TRUE
                );
    BAIL_ON_FAILURE(hr);

    //
    // USER_MODAL_INFO3
    //

    hr = GetInfo(
                13,
                TRUE
                );
    BAIL_ON_FAILURE(hr);
    
    //
    // objectSid. LookupAccountName fails for machine accounts on NT4, but
    // works on Win2K. In order for an explicit GetInfo to succeed against NT4
    // systems we do not check the error code returned below. If this call 
    // fails, a subsequent Get("ObjectSid") will return 
    // E_ADS_PROPERTY_NOT_FOUND. 
    //

    GetInfo(
        20,
        TRUE
        );

error :

    RRETURN(hr);
}

STDMETHODIMP
CWinNTUser::ImplicitGetInfo(THIS)
{
    HRESULT hr;

    // USER_INFO
    //

    hr = GetInfo(
                3,
                FALSE
                );

    BAIL_ON_FAILURE(hr);

    //
    // USER_MODAL_INFO0
    //

    hr =  GetInfo(
                10,
                FALSE
                );
    BAIL_ON_FAILURE(hr);

    //
    // USER_MODAL_INFO3
    //

    hr = GetInfo(
                13,
                FALSE
                );
    BAIL_ON_FAILURE(hr);

    //
    // objectSid
    //

    hr = GetInfo(
                20,
                FALSE
                );

error :

    RRETURN(hr);
}


HRESULT
CWinNTUser::AllocateUserObject(
    CWinNTUser ** ppUser
    )
{
    CWinNTUser FAR * pUser = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pUser = new CWinNTUser();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsUser,
                (IADsUser *)pUser,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyList,
                (IADsPropertyList *)pUser,
                DISPID_VALUE
                );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
             UserClass,
             gdwUserTableSize,
             (CCoreADsObject *)pUser,
             &pPropertyCache
             );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache(
                pPropertyCache
                );


    pUser->_pPropertyCache = pPropertyCache;
    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pPropertyCache;
    delete  pUser;

    RRETURN(hr);
}


//
// For current implementation in clocgroup:
// If this function is called as a public function (ie. by another
// modual/class), fExplicit must be FALSE since the cache is NOT
// flushed in this function.
//
// External functions should ONLY call GetInfo(no param) for explicit
// GetInfo. This will flush the cache properly.
//

STDMETHODIMP
CWinNTUser::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwApiLevel) {

    // GetInfo(1 or 2, fExplicit) in ADSI codes should be modified
    // to GetInfo(3, fExplicit) to minimize calls on wire.

    case 3:
        hr = GetStandardInfo(3, fExplicit);
        RRETURN_EXP_IF_ERR(hr);

    case 10:
        hr = GetModalInfo(0, fExplicit);
        RRETURN_EXP_IF_ERR(hr);

    case 13:
        hr = GetModalInfo(3, fExplicit);
        RRETURN_EXP_IF_ERR(hr);

    case 20:
        hr = GetSidInfo(fExplicit);
        RRETURN_EXP_IF_ERR(hr);

    default:
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);

    }

}



HRESULT
CWinNTUser::GetStandardInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    NET_API_STATUS nasStatus;
    LPBYTE lpBuffer = NULL;
    HRESULT hr;
    WCHAR szHostServerName[MAX_PATH];


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {

       hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
       BAIL_ON_FAILURE(hr);
    }

    nasStatus = NetUserGetInfo(
                    szHostServerName,
                    _Name,
                    dwApiLevel,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    hr = UnMarshall(
            lpBuffer,
            dwApiLevel,
            fExplicit
            );
    BAIL_ON_FAILURE(hr);

error:
    if (lpBuffer) {
        NetApiBufferFree(lpBuffer);
    }

    RRETURN_EXP_IF_ERR(hr);
}


HRESULT
CWinNTUser::UnMarshall(
    LPBYTE lpBuffer,
    DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    VARIANT_BOOL fBool;
    BSTR bstrData = NULL;
    LONG lnData = 0L;
    VARIANT vaData;
    DATE daDate = 0;

    ADsAssert(lpBuffer);
    switch (dwApiLevel) {

    // GetStandardInfo currently only be called with dwApiLevel=3. If
    // dwApiLevel = 1 or 2 is used, modify ADSI codes to 3.

    case 3:
        RRETURN(UnMarshall_Level3(fExplicit, (LPUSER_INFO_3)lpBuffer));
        break;

    default:
        RRETURN(E_FAIL);

    }
}


HRESULT
CWinNTUser::UnMarshall_Level3(
    BOOL fExplicit,
    LPUSER_INFO_3 pUserInfo3
    )
{
    HRESULT hr = S_OK;

    //
    // Begin Account Restrictions Properties
    //

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("UserFlags"),
                pUserInfo3->usri3_flags,
                fExplicit
                );

    if(SUCCEEDED(hr)) {
        _fUseCacheForAcctLocked = TRUE;
    }

    if( (pUserInfo3->usri3_flags & UF_WORKSTATION_TRUST_ACCOUNT) || 
        (pUserInfo3->usri3_flags & UF_SERVER_TRUST_ACCOUNT) ||
        (pUserInfo3->usri3_flags & UF_INTERDOMAIN_TRUST_ACCOUNT) ) {
            _fComputerAcct = TRUE;
    }


    //
    // If usri3_acct_expires == TIMEQ_FOREVER, it means we need
    // to ignore the acct expiration date, the account
    // can never expire.
    //

    if (pUserInfo3->usri3_acct_expires != TIMEQ_FOREVER) {

        hr = SetDATE70PropertyInCache(
                    _pPropertyCache,
                    TEXT("AccountExpirationDate"),
                    pUserInfo3->usri3_acct_expires,
                    fExplicit
                    );

    }

    hr = SetDelimitedStringPropertyInCache(
                _pPropertyCache,
                TEXT("LoginWorkstations"),
                pUserInfo3->usri3_workstations,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MaxStorage"),
                pUserInfo3->usri3_max_storage,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PasswordAge"),
                pUserInfo3->usri3_password_age,
                fExplicit
                );


    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PasswordExpired"),
                pUserInfo3->usri3_password_expired,
                fExplicit
                );

    hr = SetOctetPropertyInCache(
                _pPropertyCache,
                TEXT("LoginHours"),
                pUserInfo3->usri3_logon_hours,
                21,
                fExplicit
                );



    //
    // Begin Business Info Properties
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("FullName"),
                pUserInfo3->usri3_full_name,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Description"),
                pUserInfo3->usri3_comment,
                fExplicit
                );

    //
    // Begin Account Statistics Properties
    //

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("BadPasswordAttempts"),
                pUserInfo3->usri3_bad_pw_count,
                fExplicit
                );

    //
    // lasg_logon/off == 0 means user never logon/off or logon/off time unknown.
    //

    if (pUserInfo3->usri3_last_logon!=0) {

        hr = SetDATE70PropertyInCache(
                _pPropertyCache,
                TEXT("LastLogin"),
                pUserInfo3->usri3_last_logon,
                fExplicit
                );
    }


    if (pUserInfo3->usri3_last_logoff!=0) {

        hr = SetDATE70PropertyInCache(
                _pPropertyCache,
                TEXT("LastLogoff"),
                pUserInfo3->usri3_last_logoff,
                fExplicit
                );
    }


    //
    // Begin Other Info Properties
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("HomeDirectory"),
                pUserInfo3->usri3_home_dir,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("LoginScript"),
                pUserInfo3->usri3_script_path,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Profile"),
                pUserInfo3->usri3_profile,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("HomeDirDrive"),
                pUserInfo3->usri3_home_dir_drive,
                fExplicit
                );


    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Parameters"),
                pUserInfo3->usri3_parms,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PrimaryGroupID"),
                pUserInfo3->usri3_primary_group_id,
                fExplicit
                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    RRETURN(S_OK);
}


HRESULT
CWinNTUser::Prepopulate(
    BOOL fExplicit,
    DWORD *pdwUserFlags,    // OPTIONAL
    LPWSTR szFullName,      // OPTIONAL
    LPWSTR szDescription,   // OPTIONAL
    PSID pSid               // OPTIONAL
    )
{
    HRESULT hr = S_OK;

    DWORD dwErr = 0;
    DWORD dwSidLength = 0;
    
    //
    // Prepopulate the object with supplied info,
    // if available
    //
    if (pdwUserFlags) {
        hr = SetDWORDPropertyInCache(
                    _pPropertyCache,
                    TEXT("UserFlags"),
                    *pdwUserFlags,
                    TRUE
                    );                        
        BAIL_ON_FAILURE(hr);

        //
        // see comment on _fUseCacheForAcctLocked in cuser.hxx
        //
        _fUseCacheForAcctLocked = FALSE;
    }


    if (szFullName) {
        hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("FullName"),
                    szFullName,
                    TRUE
                    );                        
        BAIL_ON_FAILURE(hr);
    }


    if (szDescription) {
        hr = SetLPTSTRPropertyInCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    szDescription,
                    TRUE
                    );                        
        BAIL_ON_FAILURE(hr);
    }

    if (pSid) {

        //
        // On NT4 for some reason GetLengthSID does not set lasterror to 0
        //
        SetLastError(NO_ERROR);

        dwSidLength = GetLengthSid(pSid);

        //
        // This is an extra check to make sure that we have the
        // correct length.
        //
        dwErr = GetLastError();
        if (dwErr != NO_ERROR) {
            hr = HRESULT_FROM_WIN32(dwErr);
            BAIL_ON_FAILURE(hr);
        }
    
        hr = SetOctetPropertyInCache(
                    _pPropertyCache,
                    TEXT("objectSid"),
                    (PBYTE) pSid,
                    dwSidLength,
                    TRUE
                    );
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);

}

HRESULT
CWinNTUser::GetSidInfo(
    IN BOOL fExplicit
    )
{
    HRESULT hr = E_FAIL;
    WCHAR szHostServerName[MAX_PATH];

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    //
    // Get Server Name
    //

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {

       hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
       BAIL_ON_FAILURE(hr);
    }

    //
    // Get Sid of this user account and store in cache if fExplicit.
    //

    hr = GetSidIntoCache(
            szHostServerName,
            _Name,
            _pPropertyCache,
            fExplicit
            );
    BAIL_ON_FAILURE(hr);


error:

    RRETURN(hr);
}


HRESULT
CWinNTUser::SetInfo(THIS_ DWORD dwApiLevel)
{
    NET_API_STATUS nasStatus;
    HRESULT hr;
    LPBYTE lpBuffer = NULL;
    DWORD dwParamErr = 0;
    WCHAR szHostServerName[MAX_PATH];

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {
        hr = MakeUncName(
                 _ServerName,
                 szHostServerName
                 );
        BAIL_ON_FAILURE(hr);

    }

    nasStatus = NetUserGetInfo(
                    szHostServerName,
                    _Name,
                    dwApiLevel,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);


     hr = MarshallAndSet(szHostServerName, lpBuffer, dwApiLevel);
     BAIL_ON_FAILURE(hr);

error:

     if (lpBuffer) {
         NetApiBufferFree(lpBuffer);
     }


     RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTUser::MarshallAndSet(
    LPWSTR szHostServerName,
    LPBYTE lpBuffer,
    DWORD  dwApiLevel
    )
{
    ADsAssert(lpBuffer);
    switch (dwApiLevel) {

    //
    // dwApiLevel = 1 or 2 should change to 3 in caller codes to min
    // calls on wire

    case 3:
        RRETURN(Marshall_Set_Level3(szHostServerName, (LPUSER_INFO_3)lpBuffer));
        break;

    //
    // caae 10:
    // case 13:
    // USER_MODAL_INFO should be set at domain level,
    // Not at user level
    //

    //
    // case 20:
    // objectSid not writable
    //

    default:
        RRETURN(E_FAIL);

    }
}


HRESULT
CWinNTUser::Marshall_Set_Level3(
    LPWSTR szHostServerName,
    LPUSER_INFO_3 pUserInfo3
    )
{
    HRESULT hr;

    DWORD dwFlags = 0;
    DWORD dwAcctExpDate = 0;
    LPWSTR pszDescription = NULL;
    LPWSTR pszFullName = NULL;
    DWORD dwBadPwCount = 0;
    DWORD dwLastLogin = 0;
    DWORD dwLastLogoff = 0;
    LPWSTR pszHomeDir = NULL;
    LPWSTR pszScript = NULL;
    LPWSTR pszProfile = NULL;
    LPWSTR pszLoginWorkstations = NULL;
    DWORD dwMaxStorage = 0;
    LPWSTR pszHomeDirDrive = NULL;
    LPWSTR pszParameters = NULL;
    DWORD dwPrimaryGroupId = 0;
    DWORD dwPasswordExpired = 0;
	OctetString octetString;


    DWORD dwParmErr = 0;
    NET_API_STATUS nasStatus;

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("UserFlags"),
                    &dwFlags
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_flags = dwFlags;
    }

    hr = GetDATE70PropertyFromCache(
                    _pPropertyCache,
                    TEXT("AccountExpirationDate"),
                    &dwAcctExpDate
                    );
    if(SUCCEEDED(hr)){

        //
        // Pick an easy to remeber date to represent "account never expires" :
        // 1/1/70 at 0:00. (Range <= 86400 and >= 0xffffffff-86400 is +/- one
        // day from 1/1/70 at 0:00 to take time localization into account.)
        //

        if (dwAcctExpDate <=  86400 || dwAcctExpDate >= (0xffffffff-86400)) {
            pUserInfo3->usri3_acct_expires = TIMEQ_FOREVER;
        }
        else {
            pUserInfo3->usri3_acct_expires = dwAcctExpDate;
        }
    }

    hr = GetDWORDPropertyFromCache(
                   _pPropertyCache,
                   TEXT("PasswordExpired"),
                   &dwPasswordExpired
                   );
    if(SUCCEEDED(hr)){
       pUserInfo3->usri3_password_expired = dwPasswordExpired;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("MaxStorage"),
                    &dwMaxStorage
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_max_storage = dwMaxStorage;
    }

    hr = GetDelimitedStringPropertyFromCache(
                    _pPropertyCache,
                    TEXT("LoginWorkstations"),
                    &pszLoginWorkstations
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_workstations = pszLoginWorkstations;
    }

    //
    // Begin Business Information Properties
    //

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDescription
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_comment = pszDescription;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("FullName"),
                    &pszFullName
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_full_name = pszFullName;
    }

    hr = GetOctetPropertyFromCache(
                    _pPropertyCache,
                    TEXT("LoginHours"),
                    &octetString
                    );
    if(SUCCEEDED(hr)){
        //
        // We can only assume what the size of the usri3_logon_hours
        // buffer is, but according to MSDN, it should be 21 bytes.  
        // Make sure that no more than 21 bytes is copied.
        //
        memcpy(pUserInfo3->usri3_logon_hours,
               octetString.pByte,
               (octetString.dwSize>21)?21:octetString.dwSize);
        FreeADsMem(octetString.pByte);
    }


    /*
    //
    // Begin Account Statistics Properties - should not be writable.
    //

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("BadPasswordAttempts"),
                    &dwBadPwCount
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_bad_pw_count = dwBadPwCount;
    }

    hr = GetDATE70PropertyFromCache(
                    _pPropertyCache,
                    TEXT("LastLogin"),
                    &dwLastLogin
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_last_logon = dwLastLogin;
    }

    hr = GetDATE70PropertyFromCache(
                    _pPropertyCache,
                    TEXT("LastLogoff"),
                    &dwLastLogoff
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_last_logoff = dwLastLogoff;
    }
    */

    //
    // Begin Other Info Properties
    //


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("HomeDirectory"),
                    &pszHomeDir
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_home_dir = pszHomeDir;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("LoginScript"),
                    &pszScript
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_script_path = pszScript;
    }

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Profile"),
                    &pszProfile
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_profile = pszProfile;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("HomeDirDrive"),
                    &pszHomeDirDrive
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_home_dir_drive = pszHomeDirDrive;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Parameters"),
                    &pszParameters
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_parms = pszParameters;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PrimaryGroupID"),
                    &dwPrimaryGroupId
                    );
    if(SUCCEEDED(hr)){
        pUserInfo3->usri3_primary_group_id = dwPrimaryGroupId;
    }

    //
    // Now perform the Set call.
    //

    nasStatus = NetUserSetInfo(
                        szHostServerName,
                        _Name,
                        3,
                        (LPBYTE)pUserInfo3,
                        &dwParmErr
                        );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

error:

    if (pszDescription) {
        FreeADsStr(pszDescription);
    }

    if (pszFullName) {
        FreeADsStr(pszFullName);
    }

    if (pszHomeDir) {
        FreeADsStr(pszHomeDir);
    }

    if (pszScript) {
        FreeADsStr(pszScript);
    }

    if (pszProfile) {
        FreeADsStr(pszProfile);
    }

    if (pszLoginWorkstations) {
        FreeADsStr(pszLoginWorkstations);
    }

    if (pszParameters) {
        FreeADsStr(pszParameters);
    }

    if (pszHomeDirDrive) {
        FreeADsStr(pszHomeDirDrive);
    }



    RRETURN(hr);
}


HRESULT
CWinNTUser::Marshall_Create_Level1(
    LPWSTR szHostServerName,
    LPUSER_INFO_1 pUserInfo1
    )
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    DWORD dwParmErr;

    pUserInfo1->usri1_name =  _Name;
    pUserInfo1->usri1_password = NULL;
    pUserInfo1->usri1_password_age = DEF_MAX_PWAGE;
    pUserInfo1->usri1_priv = 1;
    pUserInfo1->usri1_home_dir = NULL;
    pUserInfo1->usri1_comment = NULL;
    pUserInfo1->usri1_flags = 0x00000201;
    pUserInfo1->usri1_script_path = NULL;

    nasStatus = NetUserAdd(
                    szHostServerName,
                    1,
                    (LPBYTE)pUserInfo1,
                    &dwParmErr
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);

    RRETURN(hr);
}





HRESULT
CWinNTUser::GetModalInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    NET_API_STATUS nasStatus;
    LPBYTE lpBuffer = NULL;
    HRESULT hr;
    WCHAR szPDCName[MAX_PATH];

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }


    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szPDCName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {

        hr = MakeUncName(
                 _ServerName,
                 szPDCName
                );
        BAIL_ON_FAILURE(hr);
    }

    nasStatus = NetUserModalsGet(
                    szPDCName,
                    dwApiLevel,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    hr = UnMarshallModalInfo(lpBuffer, dwApiLevel, fExplicit);
    BAIL_ON_FAILURE(hr);

error:
    if (lpBuffer) {
        NetApiBufferFree(lpBuffer);
    }

    RRETURN(hr);
}


HRESULT
CWinNTUser::UnMarshallModalInfo(
    LPBYTE lpBuffer,
    DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    ADsAssert(lpBuffer);
    switch (dwApiLevel) {
    case 0:
        RRETURN(UnMarshall_ModalLevel0(fExplicit, (LPUSER_MODALS_INFO_0)lpBuffer));
        break;

    case 2:
        RRETURN(UnMarshall_ModalLevel2(fExplicit, (LPUSER_MODALS_INFO_2)lpBuffer));
        break;


    case 3:
        RRETURN(UnMarshall_ModalLevel3(fExplicit, (LPUSER_MODALS_INFO_3)lpBuffer));
        break;

    default:
        RRETURN(E_FAIL);

    }
}



HRESULT
CWinNTUser::UnMarshall_ModalLevel0(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_0 pUserInfo0
    )
{

    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MinPasswordLength"),
                pUserInfo0->usrmod0_min_passwd_len,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MaxPasswordAge"),
                pUserInfo0->usrmod0_max_passwd_age,
                fExplicit
                );


    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MinPasswordAge"),
                pUserInfo0->usrmod0_min_passwd_age,
                fExplicit
                );


    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("PasswordHistoryLength"),
                pUserInfo0->usrmod0_password_hist_len,
                fExplicit
                );

    RRETURN(S_OK);
}



HRESULT
CWinNTUser::UnMarshall_ModalLevel2(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_2 pUserInfo2
    )
{
    RRETURN(S_OK);
}


HRESULT
CWinNTUser::UnMarshall_ModalLevel3(
    BOOL fExplicit,
    LPUSER_MODALS_INFO_3 pUserInfo3
    )
{
    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("AutoUnlockInterval"),
                pUserInfo3->usrmod3_lockout_duration,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("LockoutObservationInterval"),
                pUserInfo3->usrmod3_lockout_observation_window,
                fExplicit
                );

    hr = SetDWORDPropertyInCache(
                _pPropertyCache,
                TEXT("MaxBadPasswordsAllowed"),
                pUserInfo3->usrmod3_lockout_threshold,
                fExplicit
                );

    RRETURN(S_OK);
}


//
// This method is meant to set the password, so that new users
// can be created, their password set and then SetInfo can be
// called. This is necessary to allow creation of users when there
// are restrictions such as passwd should be present.
//
HRESULT
CWinNTUser::setPrivatePassword(
    PWSTR pszNewPassword
    )
{
    HRESULT hr = S_OK;

    // CCred safely stores password for us
    if (_pCCredentialsPwdHolder) {

        hr = _pCCredentialsPwdHolder->SetPassword(pszNewPassword);
        BAIL_ON_FAILURE(hr);

    } else
        _pCCredentialsPwdHolder = new CCredentials(NULL, pszNewPassword, 0);

    if (!_pCCredentialsPwdHolder) {
        hr = E_OUTOFMEMORY;
    } else
        _fPasswordSet = TRUE;

error:


    RRETURN(hr);
}

//
// This method is meant to set the password, so that new users
// can be created, their password set and then SetInfo can be
// called. This is necessary to allow creation of users when there
// are restrictions such as passwd should be present.
//
HRESULT
CWinNTUser::getPrivatePassword(
    PWSTR * ppszPassword
    )
{
    HRESULT hr = S_OK;

    if (_pCCredentialsPwdHolder && _fPasswordSet) {
        hr = _pCCredentialsPwdHolder->GetPassword(ppszPassword);
    } else
        hr = E_FAIL;

    RRETURN(hr);
}

HRESULT
CWinNTUser::GetUserFlags(
    DWORD *pdwUserFlags
    )
{
    HRESULT hr = S_OK;
    NET_API_STATUS nasStatus;
    LPBYTE lpBuffer = NULL;
    WCHAR szHostServerName[MAX_PATH];

    ADsAssert(pdwUserFlags != NULL);

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        RRETURN_EXP_IF_ERR(E_ADS_OBJECT_UNBOUND);
    }

    //
    // objects associated with invalid SIDs have neither a
    // corresponding server nor domain
    //
    if ((!_DomainName) && (!_ServerName)) {
        BAIL_ON_FAILURE(hr = E_ADS_INVALID_USER_OBJECT);
    }

    if (_ParentType == WINNT_DOMAIN_ID) {

        hr = WinNTGetCachedDCName(
                    _DomainName,
                    szHostServerName,
                    _Credentials.GetFlags()
                    );
        BAIL_ON_FAILURE(hr);

    }else {

       hr = MakeUncName(
                _ServerName,
                szHostServerName
                );
       BAIL_ON_FAILURE(hr);
    }

    nasStatus = NetUserGetInfo(
                    szHostServerName,
                    _Name,
                    3,
                    &lpBuffer
                    );
    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    *pdwUserFlags = ((LPUSER_INFO_3)lpBuffer)->usri3_flags;

error:
    if (lpBuffer) {
        NetApiBufferFree(lpBuffer);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cusers.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996
//
//  File:  cusers.cxx
//
//  Contents:  User Groups collection
//
//  History:   08-08-96     t-danal    Created from cgroups.cxx
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop
#include "winnt.hxx"

//  Class CWinNTUserGroupsCollection

DEFINE_IDispatch_Implementation(CWinNTUserGroupsCollection)


CWinNTUserGroupsCollection::CWinNTUserGroupsCollection():
        _ParentType(0),
        _ParentADsPath(NULL),
        _DomainName(NULL),
        _ServerName(NULL),
        _UserName(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CWinNTUserGroupsCollection);
}

CWinNTUserGroupsCollection::~CWinNTUserGroupsCollection( )
{
    if (_ParentADsPath)
        ADsFreeString(_ParentADsPath);
    if (_DomainName)
        ADsFreeString(_DomainName);
    if (_ServerName)
        ADsFreeString(_ServerName);
    if (_UserName)
        ADsFreeString(_UserName);
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

HRESULT
CWinNTUserGroupsCollection::CreateUserGroupsCollection(
    ULONG ParentType,
    BSTR ParentADsPath,
    BSTR DomainName,
    BSTR ServerName,
    BSTR UserName,
    REFIID riid,
    CWinNTCredentials& Credentials,
    void **ppvObj
    )
{
    CWinNTUserGroupsCollection FAR * pUserGroups = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserGroupsCollectionObject(&pUserGroups);
    BAIL_ON_FAILURE(hr);

    ADsAssert(pUserGroups);

    pUserGroups->_ParentType = ParentType;

    hr = ADsAllocString( ParentADsPath, &pUserGroups->_ParentADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(DomainName, &pUserGroups->_DomainName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ServerName , &pUserGroups->_ServerName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(UserName, &pUserGroups->_UserName);
    BAIL_ON_FAILURE(hr);
    
    pUserGroups->_Credentials = Credentials;
    hr = pUserGroups->_Credentials.Ref(ServerName, DomainName, ParentType);
    BAIL_ON_FAILURE(hr);


    hr = pUserGroups->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUserGroups->Release();
    RRETURN(hr);

error:
    delete pUserGroups;

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CWinNTUserGroupsCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

/* ISupportErrorInfo method */
STDMETHODIMP
CWinNTUserGroupsCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

STDMETHODIMP
CWinNTUserGroupsCollection::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CWinNTUserGroupsCollection::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CWinNTUserGroupsCollection::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr = VariantClear(&_vFilter);
    if (FAILED(hr))
        RRETURN_EXP_IF_ERR(hr);
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CWinNTUserGroupsCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;

    *retval = NULL;

    hr = CWinNTUserGroupsCollectionEnum::Create(
                (CWinNTUserGroupsCollectionEnum **)&penum,
                _ParentType,
                _ParentADsPath,
                _DomainName,
                _ServerName,
                _UserName,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:
    if (penum) {
        delete penum;
    }
    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CWinNTUserGroupsCollection::AllocateUserGroupsCollectionObject(
    CWinNTUserGroupsCollection ** ppUserGroups
    )
{
    CWinNTUserGroupsCollection FAR * pUserGroups = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pUserGroups = new CWinNTUserGroupsCollection();
    if (pUserGroups == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsMembers,
                           (IADsMembers *)pUserGroups,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pUserGroups->_pDispMgr = pDispMgr;
    *ppUserGroups = pUserGroups;

    RRETURN(hr);

error:
    delete pUserGroups;
    delete  pDispMgr;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define PUT_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\extension.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for ADs.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop


LPCWSTR lpszTopLevel = L"SOFTWARE\\Microsoft\\ADs\\Providers\\WinNT";
LPCWSTR lpszExtensions = L"Extensions";

PCLASS_ENTRY gpClassHead = NULL;


PCLASS_ENTRY
BuildClassesList()
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;
    HKEY hExtensionRootKey = NULL;

    HKEY hClassKey = NULL;

    DWORD dwIndex = 0;
    WCHAR lpszClassName[MAX_PATH];
    DWORD dwchClassName = 0;
    PCLASS_ENTRY pClassHead = NULL;
    PCLASS_ENTRY pClassEntry = NULL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     lpszTopLevel,
                     0,
                     KEY_READ,
                     &hTopLevelKey
                     ) != ERROR_SUCCESS)
    {
        goto CleanupAndExit;
    }

    if (RegOpenKeyEx(hTopLevelKey,
                     lpszExtensions,
                     0,
                     KEY_READ,
                     &hExtensionRootKey
                     ) != ERROR_SUCCESS)

    {
        goto CleanupAndExit;

    }

    memset(lpszClassName, 0, sizeof(lpszClassName));
    dwchClassName = sizeof(lpszClassName)/sizeof(WCHAR);

    while(RegEnumKeyEx(hExtensionRootKey,
                     dwIndex,
                     lpszClassName,
                     &dwchClassName,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hExtensionRootKey,
                         lpszClassName,
                         0,
                         KEY_READ,
                         &hClassKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        pClassEntry  = BuildClassEntry(
                                lpszClassName,
                                hClassKey
                                );

        if (pClassEntry) {

            pClassEntry->pNext = pClassHead;
            pClassHead = pClassEntry;
        }

        if (hClassKey) {
            CloseHandle(hClassKey);
        }

        memset(lpszClassName, 0, sizeof(lpszClassName));
        dwchClassName = sizeof(lpszClassName)/sizeof(WCHAR);
        dwIndex++;
    }

CleanupAndExit:

    if (hExtensionRootKey) {
        RegCloseKey(hExtensionRootKey);
    }

    if (hTopLevelKey) {
        RegCloseKey(hTopLevelKey);
    }

    return(pClassHead);
}


VOID
FreeClassesList(
    PCLASS_ENTRY pClassHead
    )
{
    PCLASS_ENTRY pDelete;

    while (pClassHead) {

        pDelete = pClassHead;
        pClassHead = pClassHead->pNext;

        FreeClassEntry(pDelete);
    }

    return;
}


PCLASS_ENTRY
BuildClassEntry(
    LPWSTR lpszClassName,
    HKEY hClassKey
    )
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;

    DWORD dwIndex = 0;
    DWORD dwchExtensionCLSID = 0;
    WCHAR lpszExtensionCLSID[MAX_PATH];
    PCLASS_ENTRY pClassEntry = NULL;
    PEXTENSION_ENTRY pExtensionHead = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;

    pClassEntry =  (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (!pClassEntry) {

        goto CleanupAndExit;
    }

    wcscpy(pClassEntry->szClassName, lpszClassName);

    memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
    dwchExtensionCLSID = sizeof(lpszExtensionCLSID)/sizeof(WCHAR);

    while(RegEnumKeyEx(hClassKey,
                     dwIndex,
                     lpszExtensionCLSID,
                     &dwchExtensionCLSID,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hClassKey,
                         lpszExtensionCLSID,
                         0,
                         KEY_READ,
                         &hExtensionKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        //
        // Read the Interfaces that this Extension supports
        //

        pExtensionEntry = BuildExtensionEntry(
                                lpszExtensionCLSID,
                                hExtensionKey
                                );

        if (pExtensionEntry) {

            wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);

            pExtensionEntry->pNext = pExtensionHead;
            pExtensionHead = pExtensionEntry;
        }


        if (hExtensionKey) {

            CloseHandle(hExtensionKey);
        }

        memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
        dwchExtensionCLSID = sizeof(lpszExtensionCLSID)/sizeof(WCHAR);
        dwIndex++;

    }

    pClassEntry->pExtensionHead = pExtensionHead;




CleanupAndExit:

    return(pClassEntry);
}


PEXTENSION_ENTRY
BuildExtensionEntry(
    LPWSTR lpszExtensionCLSID,
    HKEY hExtensionKey
    )
{
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pInterfaceHead = NULL;
    WCHAR lpszInterfaces[MAX_PATH];
    DWORD dwchInterfaces = 0;
    LPWSTR psz = NULL;
    WCHAR Interface[MAX_PATH];
    HRESULT hr = S_OK;


    pExtensionEntry =  (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (!pExtensionEntry) {

        goto CleanupAndExit;
    }

    memset(lpszInterfaces, 0, sizeof(lpszInterfaces));
    dwchInterfaces = sizeof(lpszInterfaces);

    RegQueryValueEx(
            hExtensionKey,
            L"Interfaces",
            NULL,
            NULL,
            (LPBYTE) lpszInterfaces,
            &dwchInterfaces
            );

    psz = lpszInterfaces;

    while (psz && *psz) {

       wcscpy(Interface, psz);

       // skip (length) + 1
       // lstrlen returns length sans '\0'


       pInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

       if (pInterfaceEntry) {

           wcscpy(pInterfaceEntry->szInterfaceIID, Interface);
           hr = IIDFromString(Interface, &(pInterfaceEntry->iid));

           pInterfaceEntry->pNext = pInterfaceHead;
           pInterfaceHead = pInterfaceEntry;

       }

       psz = psz + lstrlen(psz) + 1;

    }

    wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);
    hr = CLSIDFromString(lpszExtensionCLSID, &(pExtensionEntry->ExtCLSID));

    pExtensionEntry->pIID = pInterfaceHead;

CleanupAndExit:

    return(pExtensionEntry);
}


void
FreeInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    if (pInterfaceEntry) {

        FreeADsMem(pInterfaceEntry);
    }
}


void
FreeExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pTemp = NULL;

    if (pExtensionEntry) {

        pInterfaceEntry = pExtensionEntry->pIID;

        while (pInterfaceEntry) {

            pTemp = pInterfaceEntry->pNext;

            if (pInterfaceEntry) {

                FreeInterfaceEntry(pInterfaceEntry);
            }

            pInterfaceEntry = pTemp;

        }

        //
        // Now unload the Extension Object
        //

        if (pExtensionEntry->pUnknown) {

            //
            // Call non-delegating Release to release ref. count on innner
            // object (for pUnkown) -> inner object self destroy
            //
            (pExtensionEntry->pUnknown)->Release();

        }


        FreeADsMem(pExtensionEntry);
    }

    return;
}

void
FreeClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{

    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PEXTENSION_ENTRY pTemp = NULL;

    if (pClassEntry) {

        pExtensionEntry = pClassEntry->pExtensionHead;

        while (pExtensionEntry) {

            pTemp = pExtensionEntry->pNext;

            if (pExtensionEntry) {

                FreeExtensionEntry(pExtensionEntry);
            }

            pExtensionEntry = pTemp;

        }

        FreeADsMem(pClassEntry);
    }

    return;
}


PINTERFACE_ENTRY
MakeCopyofInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    pNewInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

    if (pNewInterfaceEntry) {

        wcscpy(pNewInterfaceEntry->szInterfaceIID, pInterfaceEntry->szInterfaceIID);
        memcpy(&(pNewInterfaceEntry->iid), &(pInterfaceEntry->iid), sizeof(GUID));
    }

    return(pNewInterfaceEntry);
}



PEXTENSION_ENTRY
MakeCopyofExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PINTERFACE_ENTRY pInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceHead = NULL;


    pInterfaceEntry = pExtensionEntry->pIID;

    while (pInterfaceEntry) {

        pNewInterfaceEntry = MakeCopyofInterfaceEntry(pInterfaceEntry);

        if (pNewInterfaceEntry) {

            pNewInterfaceEntry->pNext = pNewInterfaceHead;
            pNewInterfaceHead = pNewInterfaceEntry;
        }

        pInterfaceEntry = pInterfaceEntry->pNext;

    }

    pNewExtensionEntry = (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (pNewExtensionEntry) {

        wcscpy(
            pNewExtensionEntry->szExtensionCLSID,
            pExtensionEntry->szExtensionCLSID
            );

        memcpy(
            &(pNewExtensionEntry->ExtCLSID),
            &(pExtensionEntry->ExtCLSID),
            sizeof(GUID)
            );

        pNewExtensionEntry->pIID = pNewInterfaceHead;


        //
        // Initialize fields we won't know the values of until an instacne of
        // the extension is created and aggregated (loaded).
        //

        pNewExtensionEntry->pUnknown=NULL;
        pNewExtensionEntry->pPrivDisp=NULL;
        pNewExtensionEntry->pADsExt=NULL;
        pNewExtensionEntry->fDisp=FALSE;
        pNewExtensionEntry->dwExtensionID = (DWORD) -1; //invalid dwExtensionID

        //
        // let class entry handle pNext
        //
    }
    else
    {
        //
        // Clean up the copied interface entries because we couldn't allocate 
        // memory for the extension
        //
        pInterfaceEntry = pNewInterfaceHead;

        while (pInterfaceEntry) {
            
            PINTERFACE_ENTRY pTemp = pInterfaceEntry->pNext;

            if (pInterfaceEntry) {

                FreeInterfaceEntry(pInterfaceEntry);
            }

            pInterfaceEntry = pTemp;

        }
    }

    return(pNewExtensionEntry);
}


PCLASS_ENTRY
MakeCopyofClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{
    PCLASS_ENTRY pNewClassEntry = NULL;

    PEXTENSION_ENTRY pExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionHead = NULL;


    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pNewExtensionEntry = MakeCopyofExtensionEntry(pExtensionEntry);

        if (pNewExtensionEntry) {

            pNewExtensionEntry->pNext = pNewExtensionHead;
            pNewExtensionHead = pNewExtensionEntry;
        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    pNewClassEntry = (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (pNewClassEntry) {

        wcscpy(pNewClassEntry->szClassName, pClassEntry->szClassName);

        pNewClassEntry->pExtensionHead = pNewExtensionHead;

    }
    else
    {
        //
        // Clean up the copied extensions because we couldn't allocate memory
        // for the class.
        //
        pExtensionEntry = pNewExtensionHead;

        while (pExtensionEntry) {

            PEXTENSION_ENTRY pTemp = pExtensionEntry->pNext;

            if (pExtensionEntry) {

                FreeExtensionEntry(pExtensionEntry);
            }

            pExtensionEntry = pTemp;
        }        
    }

    return(pNewClassEntry);
}


CRITICAL_SECTION g_ExtCritSect;

#define ENTER_EXTENSION_CRITSECT()  EnterCriticalSection(&g_ExtCritSect)
#define LEAVE_EXTENSION_CRITSECT()  LeaveCriticalSection(&g_ExtCritSect)

HRESULT
ADSIGetExtensionList(
    LPWSTR pszClassName,
    PCLASS_ENTRY * ppClassEntry
    )
{

    PCLASS_ENTRY pTempClassEntry = NULL;
    PCLASS_ENTRY pClassEntry = NULL;
    ENTER_EXTENSION_CRITSECT();

    pTempClassEntry = gpClassHead;

    while (pTempClassEntry) {


        if (!_wcsicmp(pTempClassEntry->szClassName, pszClassName)) {

            //
            // Make a copy of this entire extension and
            // hand it over to the calling entity.
            //

            pClassEntry = MakeCopyofClassEntry(pTempClassEntry);

            *ppClassEntry = pClassEntry;

            LEAVE_EXTENSION_CRITSECT();

            RRETURN(S_OK);

        }

        pTempClassEntry = pTempClassEntry->pNext;

   }


   *ppClassEntry = NULL;

   LEAVE_EXTENSION_CRITSECT();

   RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cuoi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cuas.cxx
//
//  Contents:  User Object Account Statistics FunctionalSet
//
//  History:   11-1-95     krishnag    Created.
//
//
//    PROPERTY_RO(AccountExpiration, DATE, 1)       Implemented
//    PROPERTY_RO(BadLoginAddress, BSTR, 2)         NI
//    PROPERTY_RO(BadLoginCount, long, 3)           NI
//    PROPERTY_RO(BadPasswordAttempts, long, 4)     Implemented
//    PROPERTY_RO(LastLogin, DATE, 5)               Implemented
//    PROPERTY_RO(LastLogoff, DATE, 6)              Implemented
//    PROPERTY_RO(LastFailedLogin, DATE, 7)         NI
//    PROPERTY_RO(PasswordLastChanged, DATE, 8)     Implemented
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop


//  Class CWinNTUser


STDMETHODIMP CWinNTUser::get_EmailAddress(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, EmailAddress);
}

STDMETHODIMP CWinNTUser::put_EmailAddress(THIS_ BSTR bstrEmailAddress)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, EmailAddress);
}

STDMETHODIMP CWinNTUser::get_HomeDirectory(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);

}

STDMETHODIMP CWinNTUser::put_HomeDirectory(THIS_ BSTR bstrHomeDirectory)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, HomeDirectory);
}


STDMETHODIMP CWinNTUser::get_Languages(THIS_ VARIANT FAR* retval)
{
    GET_PROPERTY_VARIANT((IADsUser *)this, Languages);

}

STDMETHODIMP CWinNTUser::put_Languages(THIS_ VARIANT vLanguages)
{
    PUT_PROPERTY_VARIANT((IADsUser *)this, Languages);
}

STDMETHODIMP CWinNTUser::get_Profile(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, Profile);

}

STDMETHODIMP CWinNTUser::put_Profile(THIS_ BSTR bstrProfile)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, Profile);
}

STDMETHODIMP CWinNTUser::get_LoginScript(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, LoginScript);

}

STDMETHODIMP CWinNTUser::put_LoginScript(THIS_ BSTR bstrLoginScript)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, LoginScript);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\fpnwutil.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    fpnwutil.cxx

Abstract:

    Contains functions that are used by all ADS FPNW APIs

Author:

    Ram Viswanathan (ramv)     14-May-1996
    
    
Environment:

    User Mode -Win32

Notes:

    Much of it cloned off private\windows\mpr

Revision History:


--*/

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID


//
// global defines
//

#define FPNW_DLL_NAME TEXT("fpnwclnt.dll")

HMODULE  vhFpnwDll = NULL;
extern HANDLE FpnwLoadLibSemaphore;

PF_NwApiBufferFree   pfNwApiBufferFree = NULL; 
PF_NwServerGetInfo   pfNwServerGetInfo = NULL;
PF_NwServerSetInfo   pfNwServerSetInfo = NULL;
PF_NwVolumeAdd       pfNwVolumeAdd = NULL;
PF_NwVolumeDel       pfNwVolumeDel = NULL;
PF_NwVolumeEnum      pfNwVolumeEnum = NULL;
PF_NwVolumeGetInfo   pfNwVolumeGetInfo = NULL; 
PF_NwVolumeSetInfo   pfNwVolumeSetInfo = NULL;
PF_NwConnectionEnum  pfNwConnectionEnum = NULL;
PF_NwConnectionDel   pfNwConnectionDel = NULL;
PF_NwFileEnum      pfNwFileEnum = NULL;


//
// global functions
//

BOOL   MakeSureFpnwDllIsLoaded (VOID);
DWORD  FpnwEnterLoadLibCritSect (VOID);
DWORD  FpnwLeaveLoadLibCritSect (VOID);


DWORD ADsNwApiBufferFree (
    LPVOID pBuffer
    )
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwApiBufferFree == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwApiBufferFree = (PF_NwApiBufferFree)
                            GetProcAddress(vhFpnwDll, "NwApiBufferFree");
    }

    // if cannot get address, return error
    if (pfNwApiBufferFree == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwApiBufferFree)(pBuffer);
}



                             

DWORD ADsNwServerGetInfo (
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT PNWSERVERINFO *ppServerInfo
)
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwServerGetInfo == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwServerGetInfo = (PF_NwServerGetInfo)
                            GetProcAddress(vhFpnwDll, "NwServerGetInfo");
    }

    // if cannot get address, return error
    if (pfNwServerGetInfo == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwServerGetInfo)(pServerName,
                                dwLevel,
                                ppServerInfo);
}



DWORD ADsNwServerSetInfo (
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  PNWSERVERINFO pServerInfo
)
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwServerSetInfo == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwServerSetInfo = (PF_NwServerSetInfo)
                            GetProcAddress(vhFpnwDll, "NwServerSetInfo");
    }

    // if cannot get address, return error
    if (pfNwServerSetInfo == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwServerSetInfo)(pServerName,
                                dwLevel,
                                pServerInfo);

}

DWORD ADsNwVolumeAdd (
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  PNWVOLUMEINFO pVolumeInfo
)
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwVolumeAdd == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwVolumeAdd = (PF_NwVolumeAdd)
                            GetProcAddress(vhFpnwDll, "NwVolumeAdd");
    }

    // if cannot get address, return error
    if (pfNwVolumeAdd == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwVolumeAdd)(pServerName,
                            dwLevel,
                            pVolumeInfo);

}


DWORD ADsNwVolumeDel (
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName
)
{ 
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwVolumeDel == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwVolumeDel = (PF_NwVolumeDel)
                        GetProcAddress(vhFpnwDll, "NwVolumeDel");
    }

    // if cannot get address, return error
    if (pfNwVolumeDel == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwVolumeDel)(pServerName,
                            pVolumeName);

}

DWORD ADsNwVolumeEnum (
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT PNWVOLUMEINFO *ppVolumeInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwVolumeEnum == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwVolumeEnum = (PF_NwVolumeEnum)
                        GetProcAddress(vhFpnwDll, "NwVolumeEnum");
    }

    // if cannot get address, return error
    if (pfNwVolumeEnum == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwVolumeEnum)(pServerName ,
                             dwLevel,
                             ppVolumeInfo,
                             pEntriesRead,
                             resumeHandle );
}



DWORD ADsNwVolumeGetInfo (
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    OUT PNWVOLUMEINFO *ppVolumeInfo
)
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwVolumeGetInfo == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwVolumeGetInfo = (PF_NwVolumeGetInfo)
                        GetProcAddress(vhFpnwDll, "NwVolumeGetInfo");
    }

    // if cannot get address, return error
    if (pfNwVolumeGetInfo == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwVolumeGetInfo)(pServerName ,
                                pVolumeName,
                                dwLevel,
                                ppVolumeInfo );
}



DWORD ADsNwVolumeSetInfo (
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    IN  PNWVOLUMEINFO pVolumeInfo
)
{
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwVolumeSetInfo == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwVolumeSetInfo = (PF_NwVolumeSetInfo)
                        GetProcAddress(vhFpnwDll, "NwVolumeSetInfo");
    }

    // if cannot get address, return error
    if (pfNwVolumeSetInfo == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwVolumeSetInfo)(pServerName ,
                                pVolumeName,
                                dwLevel,
                                pVolumeInfo );
}    

DWORD ADsNwConnectionEnum (
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    OUT PNWCONNECTIONINFO *ppConnectionInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{ 
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwConnectionEnum == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwConnectionEnum = (PF_NwConnectionEnum)
                        GetProcAddress(vhFpnwDll, "NwConnectionEnum");
    }

    // if cannot get address, return error
    if (pfNwConnectionEnum == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwConnectionEnum)(pServerName ,
                                 dwLevel,
                                 ppConnectionInfo,
                                 pEntriesRead,
                                 resumeHandle );
}


DWORD ADsNwConnectionDel (
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwConnectionId
) 
{ 
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwConnectionDel == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwConnectionDel = (PF_NwConnectionDel)
                        GetProcAddress(vhFpnwDll, "NwConnectionDel");
    }

    // if cannot get address, return error
    if (pfNwConnectionDel == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwConnectionDel)(pServerName,
                                dwConnectionId);

}



DWORD ADsNwFileEnum (
    IN LPWSTR pServerName OPTIONAL,
    IN DWORD  dwLevel,
    IN LPWSTR pPathName OPTIONAL,
    OUT PNWFILEINFO *ppFileInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
)
{ 
    DWORD err ;

    // enter critical section to for global data
    err = FpnwEnterLoadLibCritSect();
    if (0 != err)
    {
        return err;
    }

    // if function has not been used before, get its address.
    if (pfNwFileEnum == NULL)
    {
        // make sure DLL Is loaded
        if (!MakeSureFpnwDllIsLoaded())
        {
            (void) FpnwLeaveLoadLibCritSect() ;
            return(GetLastError()) ;
        }

        pfNwFileEnum = (PF_NwFileEnum)
                        GetProcAddress(vhFpnwDll, "NwFileEnum");
    }

    // if cannot get address, return error
    if (pfNwFileEnum == NULL)
    {
        (void) FpnwLeaveLoadLibCritSect() ;
        return(GetLastError()) ;
    }

    // else call it
    (void) FpnwLeaveLoadLibCritSect() ;
    return (*pfNwFileEnum)(pServerName ,
                           dwLevel,
                           pPathName,
                           ppFileInfo,
                           pEntriesRead,
                           resumeHandle );
}


DWORD
FpnwEnterLoadLibCritSect (
    VOID
    )
/*++

Routine Description:

    This function enters the critical section defined by
    FpnwLoadLibrarySemaphore.

Arguments:

    none

Return Value:

    0 - The operation was successful.

    error code otherwise.

--*/

#define LOADLIBRARY_TIMEOUT 10000L
{
    switch( WaitForSingleObject( FpnwLoadLibSemaphore, LOADLIBRARY_TIMEOUT ))
    {
    case 0:
        return 0 ;

    case WAIT_TIMEOUT:
        return WN_FUNCTION_BUSY ;

    case 0xFFFFFFFF:
        return (GetLastError()) ;

    default:
        return WN_WINDOWS_ERROR ;
    }
}

DWORD
FpnwLeaveLoadLibCritSect (
    VOID
    )
/*++

Routine Description:

    This function leaves the critical section defined by
    FpnwLoadLibrarySemaphore.

Arguments:

    none

Return Value:

    0 - The operation was successful.

    error code otherwise.

--*/
{
    if (!ReleaseSemaphore( FpnwLoadLibSemaphore, 1, NULL ))
        return (GetLastError()) ;
    return 0 ;
}

/*******************************************************************

    NAME:   MakeSureFpnwDllIsLoaded

    SYNOPSIS:   loads the FPNWClnt dll if need.

    EXIT:   returns TRUE if dll already loaded, or loads
        successfully. Returns false otherwise. Caller
        should call GetLastError() to determine error.

    NOTES:      it is up to the caller to call FpnwEnterLoadLibCritSect
        before he calls this.

    HISTORY:
    chuckc  29-Jul-1992    Created
    ramv    14-May-1996    Cloned off windows\mpr\mprui.cxx
********************************************************************/

BOOL MakeSureFpnwDllIsLoaded(void)
{
    HMODULE handle ;

    // if already load, just return TRUE
    if (vhFpnwDll != NULL)
    return TRUE ;

    //
    // Construct a full path to the library.  It should be in the System32 
    // directory.
    //
    TCHAR szFullPathBuffer[MAX_PATH + 1];  // +1 to allow for NULL terminator according to GetSystemDirectory
    UINT uiPathLength = 0;
    if ((uiPathLength = GetSystemDirectory(szFullPathBuffer, MAX_PATH + 1)) == 0)
      return FALSE;

    if ((uiPathLength + 1 + _tcslen(FPNW_DLL_NAME)) > MAX_PATH) // +1 is for slash
      return FALSE;

    _tcscat(szFullPathBuffer, _T("\\"));
    _tcscat(szFullPathBuffer, FPNW_DLL_NAME);

    // load the library. if it fails, it would have done a SetLastError.
    if (!(handle = LoadLibrary(szFullPathBuffer)))
       return FALSE ;

    // we are cool.
    vhFpnwDll = handle ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\cumiprop.cxx ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:     cumiprop.cxx
//
//  Contents: Contains the property list implementation for UMI. This will
//            be used for both interface properties and object properties. 
//
//  History:  02-28-00    SivaramR  Created.
//
//----------------------------------------------------------------------------

#include "winnt.hxx"

//----------------------------------------------------------------------------
// Function:   CUmiPropList 
//
// Synopsis:   Constructor. Stores off schema (list of available properties,
//             their types etc.) and the size of the schema. 
//
// Arguments:  Self explanatory
//
// Returns:    Nothing 
//
// Modifies:   Nothing 
//
//----------------------------------------------------------------------------
CUmiPropList::CUmiPropList(PPROPERTYINFO pSchema, DWORD dwSchemaSize)
{
    m_pSchema = pSchema;
    m_dwSchemaSize = dwSchemaSize;
    m_pPropCache = NULL;
    m_fIsIntfPropObj = TRUE; 
    m_ulErrorStatus = 0;
    m_pszSchema = NULL;
    m_pClassInfo = NULL;
    m_fIsNamespaceObj = FALSE;
    m_fIsClassObj = FALSE;
    m_fDisableWrites = FALSE;
    m_ppszUnImpl = NULL;
}

//----------------------------------------------------------------------------
// Function:   CUmiPropList
//
// Synopsis:   Constructor. Stores off schema (list of available properties,
//             their types etc.) and the size of the schema.
//
// Arguments:  Self explanatory
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
CUmiPropList::~CUmiPropList(void)
{
    if( (m_pPropCache != NULL) && (TRUE == m_fIsIntfPropObj) )
        delete m_pPropCache;

    if(m_pszSchema != NULL)
        FreeADsStr(m_pszSchema);

    return;
}

//----------------------------------------------------------------------------
// Function:   QueryInterface
//
// Synopsis:   Queries property list object for supported interfaces. Only
//             IUmiPropList is supported.
//
// Arguments:
//
// iid         interface requested
// ppInterface Returns pointer to interface requested. NULL if interface
//             is not supported.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    if(NULL == ppInterface)
        RRETURN(E_INVALIDARG);

    *ppInterface = NULL;

    if(IsEqualIID(iid, IID_IUnknown))
        *ppInterface = (IUmiPropList *) this;
    else if(IsEqualIID(iid, IID_IUmiPropList))
        *ppInterface = (IUmiPropList *) this;
    else
         RRETURN(E_NOINTERFACE);

    AddRef();
    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
// Function:   FInit
// 
// Synopsis:   Initializes the property list object. 
//
// Arguments:
//
// pPropCache  Pointer to the property cache object. This argument will be
//             NULL if this object is for interface properties. In this case,
//             a new property cache is allocated by this function. If this
//             object is for object properties, then this argument points
//             to the property cache of the WinNT object.
// ppszUnImpl  Array of standard property names that are not implemented.
//             This is used on an interface property object to return E_NOTIMPL
//             as the error code.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::FInit(CPropertyCache *pPropCache, LPWSTR *ppszUnImpl)
{
    HRESULT hr = UMI_S_NO_ERROR;

    if(NULL == pPropCache) {
        hr = CPropertyCache::createpropertycache(
                m_pSchema,
                m_dwSchemaSize,
                NULL,    // this will ensure that the WinNT property cache
                         // won't do implicit GetInfo for interface properties
                &m_pPropCache);

        BAIL_ON_FAILURE(hr);

        m_ppszUnImpl = ppszUnImpl; 
    }
    else {
        m_fIsIntfPropObj = FALSE;
        m_pPropCache = pPropCache;
    }
       
    RRETURN(UMI_S_NO_ERROR);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   SetLastStatus
//
// Synopsis:   Sets the status of the last operation. 
//
// Arguments:
//
// ulStatus    Status to be set
//
// Returns:    Nothing
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
void CUmiPropList::SetLastStatus(ULONG ulStatus)
{
    m_ulErrorStatus = ulStatus;

    return;
}

//----------------------------------------------------------------------------
// Function:   GetLastStatus
//
// Synopsis:   Returns status or error code from the last operation. Currently
//             only numeric status is returned i.e, no error objects are
//             returned. 
//
// Arguments:
//
// uFlags           Reserved. Must be 0 for now.
// puSpecificStatus Returns status code
// riid             IID requested. Ignored currently.
// pStatusObj       Returns interface requested. Always returns NULL currently.
//
// Returns:         UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:        *puSpecificStatus to return status code.
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetLastStatus(
    ULONG uFlags,
    ULONG *puSpecificStatus,
    REFIID riid,
    LPVOID *pStatusObj
    )
{
    if(pStatusObj != NULL)
       *pStatusObj = NULL;

    if(puSpecificStatus != NULL)
        *puSpecificStatus = 0;

    if(uFlags != 0)
        RRETURN(UMI_E_INVALID_FLAGS);

    if(NULL == puSpecificStatus)
        RRETURN(UMI_E_INVALIDARG);

    *puSpecificStatus = m_ulErrorStatus;

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   Put 
//
// Synopsis:   Implements IUmiPropList::Put. Writes a property into the cache. 
//
// Arguments: 
//
// pszName     Name of the property
// uFlags      Flags for the Put operation. Unused currently.
// pProp       Pointer to the structure containing the value 
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise. 
//
// Modifies:   Nothing. 
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::Put( 
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProp
    )
{
    HRESULT      hr = UMI_S_NO_ERROR;
    DWORD        dwSyntaxId  = 0, dwIndex = 0;
    UMI_PROPERTY *pPropArray = NULL;
    LPNTOBJECT   pNtObject = NULL;
    BOOL         fMarkAsClean = FALSE;

    SetLastStatus(0);

    // fail if we have disabled writes
    if( (TRUE == m_fDisableWrites) && (TRUE == m_fIsIntfPropObj) )
        BAIL_ON_FAILURE(hr = UMI_E_READ_ONLY); 

    // check args
    hr = ValidatePutArgs(
            pszName,
            uFlags,
            pProp
            );
    BAIL_ON_FAILURE(hr);

    // is this a standard interface property that's not implemented?
    if(m_ppszUnImpl != NULL) {
        while(m_ppszUnImpl[dwIndex] != NULL) {
            if(0 == _wcsicmp(m_ppszUnImpl[dwIndex], pszName)) {
                BAIL_ON_FAILURE(hr = UMI_E_NOTIMPL);
            }
            dwIndex++;
        }
    }

    // check if the property is in the schema
    hr = ValidatePropertyinSchemaClass(
            m_pSchema,
            m_dwSchemaSize,
            (LPWSTR) pszName,
            &dwSyntaxId
            );
    BAIL_ON_FAILURE(hr);
    
    // check if the property is writeable. Do this only if the flags are not
    // set to UMI_INTERNAL_FLAG_MARK_AS_CLEAN. Otherwise, the call is from
    // Clone() and we want read-only attributes to be succesfully copied
    // into the cloned object's cache. This requires that the check below
    // for writeable properties should be skipped.
    if(uFlags != UMI_INTERNAL_FLAG_MARK_AS_CLEAN) {
        hr = ValidateIfWriteableProperty(
            m_pSchema,
            m_dwSchemaSize,
            (LPWSTR) pszName
            );
        BAIL_ON_FAILURE(hr);
    }

    pPropArray = pProp->pPropArray; 

    // convert UMI data into format that can be stored in the cache
    hr = UmiToWinNTType(
            dwSyntaxId,
            pPropArray,
            &pNtObject
            );
    BAIL_ON_FAILURE(hr);

    // Find the property in the cache. If it doesn't exist, add it.
    hr = m_pPropCache->findproperty((LPWSTR) pszName, &dwIndex);
    if(FAILED(hr))
    {
        hr = m_pPropCache->addproperty(
                 (LPWSTR) pszName,
                 dwSyntaxId,
                 pPropArray->uCount,
                 pNtObject
                 );
        BAIL_ON_FAILURE(hr);
    }

    if(UMI_INTERNAL_FLAG_MARK_AS_CLEAN == uFlags)
        fMarkAsClean = TRUE;

    // Update property in cache
    hr = m_pPropCache->putproperty(
                 (LPWSTR) pszName,
                 dwSyntaxId,
                 pPropArray->uCount,
                 pNtObject,
                 fMarkAsClean
                 );
    BAIL_ON_FAILURE(hr);

error:

    if(pNtObject)
        NTTypeFreeNTObjects(pNtObject, pPropArray->uCount);

    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}
    
//----------------------------------------------------------------------------
// Function:   ValidatePutArgs
//
// Synopsis:   Checks if the arguments to Put() are well-formed.
//
// Arguments:
//
// pszName     Name of the property
// uFlags      Flags for the Put operation. Unused currently.
// pProp       Pointer to the structure containing the value
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::ValidatePutArgs( 
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProp
    )
{
    UMI_PROPERTY *pPropArray = NULL;

    if( (NULL == pszName) || (NULL == pProp) )
        RRETURN(UMI_E_INVALIDARG);

    if( (uFlags != 0) && (uFlags != UMI_INTERNAL_FLAG_MARK_AS_CLEAN) )
        RRETURN(UMI_E_INVALID_FLAGS);

    if(pProp->uCount != 1)    // cannot update multiple properties using Put()
        RRETURN(UMI_E_INVALIDARG);

    pPropArray = pProp->pPropArray;
    if(NULL == pPropArray)
        RRETURN(UMI_E_INVALIDARG);

    // WinNT provider supports only property update. Cannot append, clear etc.
    if(pPropArray->uOperationType != UMI_OPERATION_UPDATE)
        RRETURN(UMI_E_UNSUPPORTED_OPERATION);

    if(pPropArray->pszPropertyName &&
            _wcsicmp(pPropArray->pszPropertyName, pszName))
        RRETURN(UMI_E_INVALID_PROPERTY);

    if(NULL == pPropArray->pUmiValue)
        RRETURN(UMI_E_INVALIDARG);

    // all is well
    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   Get
//
// Synopsis:   Implements IUmiPropList::Get. Reads a property from the cache.
//             Since the WinNT provider does not support incremental updates
//             using PutEx, Get() will never return
//             UMI_E_SYNCHRONIZATION_REQUIRED. If a property is modified in
//             cache, Get() returns the modified value from the cache, without
//             any error.
//
// Arguments:
//
// pszName     Name of the property
// uFlags      Flags for the Get operation. Unused currently.
// ppProp      Returns pointer to the structure containing the value
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppProp to return the address of UMI_PROPERT_VALUES structure.
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::Get(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    RRETURN( GetHelper(
                pszName,
                uFlags,
                ppProp,
                UMI_TYPE_NULL, // no-op
                FALSE          // not an internal call to GetHelper()
                ));
}

//----------------------------------------------------------------------------
// Function:   GetAs
//
// Synopsis:   Implements IUmiPropList::GetAs. Reads a property from the cache.
//             The data is converted to the type requested by the caller.
//             Since the WinNT provider does not support incremental updates
//             using PutEx, GetAs() will never return
//             UMI_E_SYNCHRONIZATION_REQUIRED. If a property is modified in
//             cache, GetAs() returns the modified value from the cache, without
//             any error. This method is not supported for interface properties.
//
// Update:     This method will not be supported on WinNT provider.
//
// Arguments:
//
// pszName       Name of the property
// uFlags        Flags for the GetAs operation. Unused currently.
// uCoercionType UMI type to convert the data to.
// ppProp        Returns pointer to the structure containing the value
//
// Returns:      UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:     *ppProp to return the address of UMI_PROPERT_VALUES structure.
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetAs(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uCoercionType,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    SetLastStatus(UMI_E_NOTIMPL);
    RRETURN(UMI_E_NOTIMPL);

    SetLastStatus(0);

    if(TRUE == m_fIsIntfPropObj) 
    // GetAs is only supported for object properties

        RRETURN(UMI_E_UNSUPPORTED_OPERATION);

    RRETURN( GetHelper(
                pszName,
                uFlags,
                ppProp,
                (UMI_TYPE) uCoercionType,
                FALSE,     // not an internal call to GetHelper()
                TRUE 
                ));
}

//----------------------------------------------------------------------------
// Function:   GetHelper
//
// Synopsis:   Implements  a helper function for Get() and GetAs().
//             Since the WinNT provider does not support incremental updates
//             using PutEx, Get()/GetAs() will never return 
//             UMI_E_SYNCHRONIZATION_REQUIRED. If a property is modified in
//             cache, Get()/GetAs() returns the modified value from the cache,
//             wthout any error.
//
// Arguments:
//
// pszName     Name of the property
// uFlags      Flags for the Get operation.
// ppProp      Returns pointer to the structure containing the value
// UmiDstType  UMI type to convert the NT value to. Used only by GetAs()
// fInternal   Flag to indicate if the call is through Get()/GetAs() or if it
//             is an internal call to this function from UMI.  Difference is
//             that internal calls can read passwords from the cache.
// fIsGetAs    Flag to indicate if the caller is GetAs (in which case
//             UmiType is used). FALSE by default.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppProp to return the address of UMI_PROPERT_VALUES structure. 
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetHelper(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **ppProp,
    UMI_TYPE UmiDstType,
    BOOL fInternal,
    BOOL fIsGetAs
    )
{
    HRESULT    hr = UMI_S_NO_ERROR;
    DWORD      dwSyntaxId = 0, dwNumValues = 0, dwIndex = 0;
    LPNTOBJECT pNtObject = NULL;
    UMI_TYPE   UmiType = UMI_TYPE_NULL;
    UMI_PROPERTY_VALUES *pProp = NULL;
    BOOL       fModified = FALSE;

    SetLastStatus(0);

    hr = ValidateGetArgs(
            pszName,
            uFlags,
            ppProp
            );
    BAIL_ON_FAILURE(hr);

    if(UMI_FLAG_PROPERTY_ORIGIN == uFlags) {
        hr = GetPropertyOrigin(pszName, ppProp);
        if(FAILED(hr))
            goto error;
        else
            RRETURN(UMI_S_NO_ERROR);
    }

    // is this a standard interface property that's not implemented?
    if(m_ppszUnImpl != NULL) {
        while(m_ppszUnImpl[dwIndex] != NULL) {
            if(0 == _wcsicmp(m_ppszUnImpl[dwIndex], pszName)) {
                BAIL_ON_FAILURE(hr = UMI_E_NOTIMPL);
            }
            dwIndex++;
        }
    }

    *ppProp = NULL;

    // __SCHEMA should return a IUmiObject pointer. This property is treated as
    // a special case since it is not actually retrieved from the property 
    // cache. This property will be requested only on an interface property 
    // object.
    if( (TRUE == m_fIsIntfPropObj) && 
        (0 == _wcsicmp((LPWSTR) pszName, TEXT(UMIOBJ_INTF_PROP_SCHEMA))) ) {
            hr = GetSchemaObject((LPWSTR) pszName, ppProp);
            BAIL_ON_FAILURE(hr);

            RRETURN(hr);
    }

    // make sure that passwords cannot be read by a user
    if( (TRUE == m_fIsIntfPropObj) && (FALSE == fInternal) && 
        (0 == _wcsicmp((LPWSTR) pszName, TEXT(CONN_INTF_PROP_PASSWORD))) )
 
        BAIL_ON_FAILURE(hr = UMI_E_FAIL);

    // retrieve property from cache. This might result in an implicit GetInfo()
    // if this is for object properties. For, interface properties, there is
    // no implicit GetInfo().
    hr = m_pPropCache->getproperty(
            (LPWSTR) pszName,
            &dwSyntaxId,
            &dwNumValues,
            &pNtObject,
            &fModified
            ); 

    BAIL_ON_FAILURE(hr);

    // map the NT type to a UMI type
    if(dwSyntaxId >= g_dwNumNTTypes)
        BAIL_ON_FAILURE(hr = UMI_E_FAIL); // shouldn't happen

    if(FALSE == fIsGetAs) 
    // get the UMI type corresponding to this NT type
        UmiType = g_mapNTTypeToUmiType[dwSyntaxId];
    else
    // try to convert to the type specified by the caller
        UmiType = UmiDstType;

    // allocate structure to return values
    pProp = (UMI_PROPERTY_VALUES *) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));
    if(NULL == pProp)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY); 
    memset(pProp, 0, sizeof(UMI_PROPERTY_VALUES));

    pProp->pPropArray = (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));
    if(NULL == pProp->pPropArray)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(pProp->pPropArray, 0, sizeof(UMI_PROPERTY));

    hr = WinNTTypeToUmi(
            pNtObject,
            dwNumValues,
            pProp->pPropArray,
            NULL,   // provider should allocate memory
            0,
            UmiType
            );
    BAIL_ON_FAILURE(hr);

    // Get fetches only one property at a time
    pProp->uCount = 1;

    // Fill in remaining fields of UMI_PROPERTY
    if(TRUE == fModified) {
    // WinNT only allows updates
        if( (uFlags != UMI_FLAG_PROVIDER_CACHE) && 
            (FALSE == m_fIsIntfPropObj) ) {
        // need to return error since cache is dirty
            FreeMemory(0, pProp); // ignore error return
            pProp = NULL;
            BAIL_ON_FAILURE(hr = UMI_E_SYNCHRONIZATION_REQUIRED);
        }

        pProp->pPropArray->uOperationType = UMI_OPERATION_UPDATE;
    }
    else
        pProp->pPropArray->uOperationType = 0;

    // not critical if this memory allocation fails. Property name doesn't
    // have to be returned to the caller.
    pProp->pPropArray->pszPropertyName = AllocADsStr(pszName); 
   
    *ppProp = pProp;
 
error:

    if(pNtObject)
        NTTypeFreeNTObjects(pNtObject, dwNumValues);

    if(FAILED(hr)) {
        if(pProp != NULL) {
            if(pProp->pPropArray != NULL)
                FreeADsMem(pProp->pPropArray);

            FreeADsMem(pProp);
        }

        SetLastStatus(hr);
    }

    RRETURN(MapHrToUmiError(hr));
}

//----------------------------------------------------------------------------
// Function:   ValidateGetArgs
//
// Synopsis:   Checks if the arguments to Get() are well-formed.
//
// Arguments:
//
// pszName     Name of the property
// uFlags      Flags for the Put operation. 
// ppProp      Returns pointer to the structure containing the value
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::ValidateGetArgs(
    LPCWSTR pszName,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    if( (NULL == pszName) || (NULL == ppProp) )
        RRETURN(UMI_E_INVALIDARG);

    // cannot combine UMI_FLAG_PROVIDER_CACHE and UMI_FLAG_PROPERTY_ORIGIN
    // since they are on the object property list and interface property list
    // respectively. So, don't need to AND with bitmasks to see if those flags
    // are set.
    if( (uFlags != 0) && (uFlags != UMI_FLAG_PROVIDER_CACHE) && 
        (uFlags != UMI_FLAG_PROPERTY_ORIGIN) )
        RRETURN(UMI_E_INVALID_FLAGS);

    if( (UMI_FLAG_PROVIDER_CACHE == uFlags) && (TRUE == m_fIsIntfPropObj) )
        RRETURN(UMI_E_INVALID_FLAGS);

    if(UMI_FLAG_PROPERTY_ORIGIN == uFlags) { 
    // can set this flag only on the interface property object of a class 
    // object.
        if( (FALSE == m_fIsIntfPropObj) || (NULL == m_pClassInfo) )
            RRETURN(UMI_E_INVALID_FLAGS);
    }

    // all is well
    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   FreeMemory 
//
// Synopsis:   Implements IUmiPropList::FreeMemory. Frees a UMI_PROPERTY_VALUES
//             structure previously returned to the user. 
//
// Arguments:
//
// uReserved   Unused currently. 
// pMem        Pointer to UMI_PROPERTY_VALUES structure to be freed.
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   Nothing
//
//---------------------------------------------------------------------------- 
HRESULT CUmiPropList::FreeMemory(
    ULONG uReserved,
    LPVOID pMem
    )
{
    UMI_PROPERTY_VALUES *pUmiPropVal = NULL;
    UMI_PROPERTY       *pPropArray = NULL;
    ULONG              i;
    LPWSTR             *pStrArray = NULL;
    UMI_OCTET_STRING   *pOctetStrArray = NULL;
    PUMI_COM_OBJECT    pUmiComObj = NULL;

    SetLastStatus(0);

    if( (NULL == pMem) || (uReserved != 0) ) {
        SetLastStatus(UMI_E_INVALIDARG);
        RRETURN(UMI_E_INVALIDARG);
    }

    // enclose in try/except to handle bad pointers sent in by caller
    __try {
        pUmiPropVal = (UMI_PROPERTY_VALUES *) pMem;

        for(i = 0; i < pUmiPropVal->uCount; i++) {
            pPropArray = pUmiPropVal->pPropArray + i;

            if(NULL == pPropArray)
                RRETURN(UMI_E_INVALID_POINTER);

            // GetProps returns a UMI_PROPERTY structure with just the
            // property name filled in and all other fields 0, when asked
            // for only property names.
            if(pPropArray->pszPropertyName != NULL)
            {
                FreeADsStr(pPropArray->pszPropertyName);
                pPropArray->pszPropertyName = NULL;
            }

            if(0 == pPropArray->uCount)
                continue;

            if(NULL == pPropArray->pUmiValue)
                RRETURN(UMI_E_INVALID_POINTER);
      
            // Free individual string values 
            if(UMI_TYPE_LPWSTR == pPropArray->uType) {
                pStrArray = pPropArray->pUmiValue->pszStrValue;
                for(i = 0; i < pPropArray->uCount; i++) {
                    if(pStrArray[i] != NULL) {
                        FreeADsStr(pStrArray[i]);                
                        pStrArray[i] = NULL;
                    }
                }
            }
            else if(UMI_TYPE_OCTETSTRING ==  pPropArray->uType) {
                pOctetStrArray = pPropArray->pUmiValue->octetStr;
                for(i = 0; i < pPropArray->uCount; i++) {
                    if(pOctetStrArray[i].lpValue != NULL) {
                        FreeADsMem(pOctetStrArray[i].lpValue);
                        pOctetStrArray[i].lpValue = NULL;
                    }
                }
            }
            else if(UMI_TYPE_IUNKNOWN == pPropArray->uType) {
                pUmiComObj = pPropArray->pUmiValue->comObject;
                for(i = 0; i < pPropArray->uCount; i++) {
                    if(pUmiComObj[i].priid != NULL) {
                        FreeADsMem(pUmiComObj[i].priid);
                        pUmiComObj[i].priid = NULL;
                    }
                    if(pUmiComObj[i].pInterface != NULL){
                        ((IUnknown *) pUmiComObj[i].pInterface)->Release();
                        pUmiComObj[i].pInterface = NULL;
                    }
                }
            }

            // Now free the UMI_VALUE structure
            FreeADsMem(pPropArray->pUmiValue);
            pPropArray->pUmiValue = NULL;
        } // for

        if(pUmiPropVal->pPropArray != NULL)
            FreeADsMem(pUmiPropVal->pPropArray);
        pUmiPropVal->pPropArray = NULL;

        FreeADsMem(pUmiPropVal);

    } __except( EXCEPTION_EXECUTE_HANDLER ) 

    {
        SetLastStatus(UMI_E_INTERNAL_EXCEPTION);

        RRETURN(UMI_E_INTERNAL_EXCEPTION);
    }

    RRETURN(UMI_S_NO_ERROR);
}

//----------------------------------------------------------------------------
// Function:   GetInterfacePropNames
//
// Synopsis:   Returns the names of all interface properties supported. 
//
// Arguments:
//
// pProps      Returns the names of the properties, without any data
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pProps to return the property names 
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetInterfacePropNames(
    UMI_PROPERTY_VALUES **pProps
    )
{
    UMI_PROPERTY_VALUES *pUmiPropVals = NULL;
    UMI_PROPERTY        *pUmiProps = NULL;
    HRESULT             hr = UMI_S_NO_ERROR;
    ULONG               ulIndex = 0, ulCount = 0;

    ADsAssert(pProps != NULL);
    ADsAssert(TRUE == m_fIsIntfPropObj);

    pUmiPropVals = (UMI_PROPERTY_VALUES *) AllocADsMem(
                          sizeof(UMI_PROPERTY_VALUES));
    if(NULL == pUmiPropVals)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memset(pUmiPropVals, 0, sizeof(UMI_PROPERTY_VALUES));

    if(0 == m_dwSchemaSize) {
    // no properties in cache
        *pProps = pUmiPropVals;
        RRETURN(UMI_S_NO_ERROR);
    }

    pUmiProps = (UMI_PROPERTY *) AllocADsMem(
                          m_dwSchemaSize * sizeof(UMI_PROPERTY));
    if(NULL == pUmiProps)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memset(pUmiProps, 0, m_dwSchemaSize * sizeof(UMI_PROPERTY));

    for(ulIndex = 0; ulIndex < m_dwSchemaSize; ulIndex++) {
        if( (0 == _wcsicmp((LPWSTR) m_pSchema[ulIndex].szPropertyName, 
                         TEXT(UMIOBJ_INTF_PROP_SCHEMA))) ||
            (0 == _wcsicmp((LPWSTR) m_pSchema[ulIndex].szPropertyName,
                         TEXT(UMIOBJ_INTF_PROP_SCHEMAPATH))) ) {
            if(NULL == m_pszSchema)
            // must be a schema object, so don't return __SCHEMA and
            // __PADS_SCHEMA_CONTAINER_PATH.
                continue;
        }

        if(0 == _wcsicmp((LPWSTR) m_pSchema[ulIndex].szPropertyName,
                          TEXT(UMIOBJ_INTF_PROP_SUPERCLASS))) {
            if(FALSE == m_fIsClassObj)
            // not a class object. Hence __SUPERCLASS is not exposed.
                continue;
        } 

        if( (0 == _wcsicmp((LPWSTR) m_pSchema[ulIndex].szPropertyName,
                          TEXT(UMIOBJ_INTF_PROP_KEY))) ||
            (0 == _wcsicmp((LPWSTR) m_pSchema[ulIndex].szPropertyName,
                          TEXT(UMIOBJ_INTF_PROP_PARENT))) )
            if(TRUE == m_fIsNamespaceObj)
            // namespace objects have no key and parent
                continue;
        
        pUmiProps[ulCount].pszPropertyName = 
            (LPWSTR) AllocADsStr(m_pSchema[ulIndex].szPropertyName);
        if(NULL == pUmiProps[ulCount].pszPropertyName)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
        ulCount++;
    }

    pUmiPropVals->uCount = ulCount;
    pUmiPropVals->pPropArray = pUmiProps;

    *pProps = pUmiPropVals; 

    RRETURN(UMI_S_NO_ERROR);

error:

    if(pUmiProps != NULL) { 
        for(ulIndex = 0; ulIndex < m_dwSchemaSize; ulIndex++)
            if(pUmiProps[ulIndex].pszPropertyName != NULL)
                FreeADsStr(pUmiProps[ulIndex].pszPropertyName);

        FreeADsMem(pUmiProps);
    }

    if(pUmiPropVals != NULL)
        FreeADsMem(pUmiPropVals);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   GetObjectPropNames
//
// Synopsis:   Returns the names of all object properties in the cache. 
//
// Arguments:
//
// pProps      Returns the names of the properties, without any data
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pProps to return the property names
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetObjectPropNames(
    UMI_PROPERTY_VALUES **pProps
    )
{
    ADsAssert(pProps != NULL);
    ADsAssert(FALSE == m_fIsIntfPropObj);

    RRETURN(m_pPropCache->GetPropNames(pProps));
}
         
//----------------------------------------------------------------------------
// Function:   GetProps 
//
// Synopsis:   Implements IUmiPropList::GetProps. Gets multiple properties.
//             This method will currently only support retrieving the names
//             of the properties supported. For interface property objects,
//             the names of all interface properties will be returned. For
//             object properties, the names of all properties in the cache will
//             be returned.
//             This method also supports retrieving class information if
//             the underlying object is a class object (in which case
//             m_pClassInfo will be non-NULL). This is supported only on an
//             interface property object. 
//
// Arguments:
//
// pszNames    Names of properties to retrieve. Should be NULL if only names
//             are requested.
// uNameCount  Number of properties in pszNames. Should be 0 if only names
//             are requested.
// uFlags      Should be UMI_FLAG_GETPROPS_NAMES to retrieve names of properties
//             and UMI_FLAG_GETPROPS_SCHEMA to get class information.
// pProps      Returns the names of the properties, without any data
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pProps to return the property names 
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetProps(
    LPCWSTR *pszNames,
    ULONG uNameCount,
    ULONG uFlags,
    UMI_PROPERTY_VALUES **pProps
    )
{
    HRESULT hr = UMI_S_NO_ERROR;

    SetLastStatus(0);

    if( (uFlags != ((ULONG) UMI_FLAG_GETPROPS_NAMES)) && 
        (uFlags != ((ULONG) UMI_FLAG_GETPROPS_SCHEMA)) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALID_FLAGS);

    if( (pszNames != NULL) || (uNameCount != 0) || (NULL == pProps) )
        BAIL_ON_FAILURE(hr = UMI_E_INVALIDARG);

    *pProps = NULL;

    if( ((ULONG) UMI_FLAG_GETPROPS_SCHEMA) == uFlags ) {
        if(NULL == m_pClassInfo) {
        // this is not a class object. This operation is not supported.
            BAIL_ON_FAILURE(hr = UMI_E_UNSUPPORTED_FLAGS);
        }
        else
            hr = GetClassInfo(pProps);
    }
    else {
        if(TRUE == m_fIsIntfPropObj)
            hr = GetInterfacePropNames(pProps);
        else
            hr = GetObjectPropNames(pProps);
    }

error:
 
    if(FAILED(hr))
        SetLastStatus(hr);

    RRETURN(MapHrToUmiError(hr));
}

//---------------------------------------------------------------------------
// Methods of IUmiPropList that are currently not implemented. 
//
//---------------------------------------------------------------------------
HRESULT CUmiPropList::GetAt(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uBufferLength,
    LPVOID pExistingMem
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}

HRESULT CUmiPropList::PutProps(
    LPCWSTR *pszNames,
    ULONG uNameCount,
    ULONG uFlags,
    UMI_PROPERTY_VALUES *pProps
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}

HRESULT CUmiPropList::PutFrom(
    LPCWSTR pszName,
    ULONG uFlags,
    ULONG uBufferLength,
    LPVOID pExistingMem
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}

HRESULT CUmiPropList::Delete(
    LPCWSTR pszName,
    ULONG uFlags
    )
{
    SetLastStatus(UMI_E_NOTIMPL);

    RRETURN(UMI_E_NOTIMPL);
}

//----------------------------------------------------------------------------
// Function:   SetStandardProperties
//
// Synopsis:   Sets standard interface properties supported by all UMI objects
//             in the cache.
//
// Arguments:
//
// pIADs       Pointer to IADs interface on object
// pCoreObj    Pointer to core object for this WinNT object
//
// Returns:    S_OK on success. Error code otherwise. 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::SetStandardProperties(
    IADs *pIADs,
    CCoreADsObject *pCoreObj
    )
{
    HRESULT    hr = S_OK;
    DWORD      dwIndex = 0;
    IDispatch  *pDispatch = NULL;
    DISPID     DispId;
    DISPPARAMS DispParams = {NULL, NULL, 0, 0};
    VARIANT    var;
    BSTR       bstrADsPath = NULL, bstrClass = NULL;
    LPWSTR     pFullUmiPath = NULL, pShortUmiPath = NULL, pRelUmiPath = NULL;
    LPWSTR     pFullRelUmiPath = NULL, pFullParentPath = NULL;
    DWORD      dwGenus = 0;
    BSTR       bstrName = NULL, bstrParent = NULL;
    WCHAR      *pSlash = NULL;
    LPWSTR     Classes[] = {NULL, L"Schema"};
    LPWSTR     pUmiSchemaPath = NULL;
    OBJECTINFO ObjectInfo;

    ADsAssert( (pIADs != NULL) && (TRUE == m_fIsIntfPropObj) );

    hr = pIADs->QueryInterface(
        IID_IDispatch,
        (void **) &pDispatch
        );
    BAIL_ON_FAILURE(hr);

    // First, set all properties supported on IADs. The names of these UMI
    // properties are not necessarily the same as the IADs properties, so
    // map the names appropriately.
    for(dwIndex = 0; dwIndex < g_dwIADsProperties; dwIndex++) {
        hr = pDispatch->GetIDsOfNames(
                IID_NULL,
                &g_IADsProps[dwIndex].IADsPropertyName,
                1,
                LOCALE_SYSTEM_DEFAULT,
                &DispId
                );
        BAIL_ON_FAILURE(hr);

        hr = pDispatch->Invoke(
                DispId,
                IID_NULL,
                LOCALE_SYSTEM_DEFAULT,
                DISPATCH_PROPERTYGET,
                &DispParams,
                &var,
                NULL,
                NULL
                );

        if(0 == _wcsicmp(g_IADsProps[dwIndex].IADsPropertyName, L"Schema")) {
            if(FAILED(hr))
            // Not a catastrophic failure. Can't get this property from the
            // cache. Only scenario where this should happen is when calling 
            // get_Schema on a schema/namespace object.
                continue;
            else {
            // store native path to schema in member variable
                m_pszSchema = AllocADsStr(V_BSTR(&var));
                VariantClear(&var);

                if(NULL == m_pszSchema)
                    BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

                // walk path backwards and get rid of last '/'
                pSlash = wcsrchr(m_pszSchema, L'/');
                if(NULL == pSlash) 
                // bad schema path
                    BAIL_ON_FAILURE(UMI_E_FAIL);

                *pSlash = L'\0';

                Classes[0] = pCoreObj->_CompClasses[0];
                ObjectInfo.DisplayComponentArray[0] = 
                          pCoreObj->_ObjectInfo.DisplayComponentArray[0];
                ObjectInfo.DisplayComponentArray[1] = SCHEMA_NAME;
                hr = ADsToUmiPath(
                        m_pszSchema,
                        &ObjectInfo,
                        Classes,
                        2,
                        FULL_UMI_PATH,
                        &pUmiSchemaPath
                        );

                *pSlash = L'/';

                BAIL_ON_FAILURE(hr);

                hr = SetLPTSTRPropertyInCache(
                        m_pPropCache,
                        TEXT(UMIOBJ_INTF_PROP_SCHEMAPATH),
                        pUmiSchemaPath,
                        TRUE
                        );
                BAIL_ON_FAILURE(hr);                

                continue;
            } // else 
        } // if(_wcsicmp...)

        BAIL_ON_FAILURE(hr); // if Invoke failed

        if(0 == _wcsicmp(g_IADsProps[dwIndex].IADsPropertyName, L"Parent")) {
        // convert the parent to a full UMI path
            if(0 == pCoreObj->_dwNumComponents) {
            // namespace object has no parent
                VariantClear(&var);
                continue;
            }
            else {
                bstrParent = V_BSTR(&var);

                hr = ADsToUmiPath(
                        bstrParent,
                        pCoreObj->_pObjectInfo,
                        pCoreObj->_CompClasses,
                        pCoreObj->_dwNumComponents - 1,
                        FULL_UMI_PATH,
                        &pFullParentPath
                        );
                VariantClear(&var);

                BAIL_ON_FAILURE(hr);

                hr = SetLPTSTRPropertyInCache(
                        m_pPropCache,
                        TEXT(UMIOBJ_INTF_PROP_PARENT),
                        pFullParentPath,
                        TRUE
                        );
                BAIL_ON_FAILURE(hr);

                continue;
            } // else
        } // if(0 ==

        hr = GenericPutPropertyManager(
                m_pPropCache,
                m_pSchema,
                m_dwSchemaSize,
                g_IADsProps[dwIndex].UMIPropertyName,
                var,
                FALSE
                );
        VariantClear(&var);

        BAIL_ON_FAILURE(hr);
    }
        
    // Now, set the remaining standard interface properties
    hr = pIADs->get_ADsPath(&bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsToUmiPath(
            bstrADsPath, 
            pCoreObj->_pObjectInfo,
            pCoreObj->_CompClasses, 
            pCoreObj->_dwNumComponents,
            FULL_UMI_PATH, 
            &pFullUmiPath
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsToUmiPath(
            bstrADsPath,
            pCoreObj->_pObjectInfo, 
            pCoreObj->_CompClasses,
            pCoreObj->_dwNumComponents, 
            SHORT_UMI_PATH, 
            &pShortUmiPath
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsToUmiPath(
            bstrADsPath,
            pCoreObj->_pObjectInfo, 
            pCoreObj->_CompClasses,
            pCoreObj->_dwNumComponents,
            RELATIVE_UMI_PATH, 
            &pRelUmiPath
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsToUmiPath(
            bstrADsPath,
            pCoreObj->_pObjectInfo,
            pCoreObj->_CompClasses,
            pCoreObj->_dwNumComponents,
            FULL_RELATIVE_UMI_PATH,
            &pFullRelUmiPath
            );
    BAIL_ON_FAILURE(hr);

    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_FULLURL),
            pFullUmiPath,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_URL), 
            pShortUmiPath,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_RELURL),
            pRelUmiPath,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_FULLRELURL),
            pFullRelUmiPath,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    // Relpath is the same as the full relative URL
    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_RELPATH),
            pFullRelUmiPath,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    // set the genus based on the class of the object
    hr = pIADs->get_Class(&bstrClass);
    BAIL_ON_FAILURE(hr);

    if(IsSchemaObject(bstrClass)) {
        dwGenus = UMI_GENUS_CLASS;

        // WMI requires that the value of __CLASS be the same on instances
        // and classes. Thus, on class objects, the value of __CLASS should
        // be "user" instead of "class". __SUPERCLASS is exposed only on
        // class objects. Its value is always NULL in the WinNT provider 
        // since there is no class hierarchy.

        if(IsClassObj(bstrClass)) {
            hr = pIADs->get_Name(&bstrName);
            BAIL_ON_FAILURE(hr);

            // overwrite the value of __CLASS already stored in cache above
            hr = SetLPTSTRPropertyInCache(
                m_pPropCache,
                TEXT(UMIOBJ_INTF_PROP_CLASS),
                bstrName,
                TRUE
                );
            BAIL_ON_FAILURE(hr);

            hr = SetLPTSTRPropertyInCache(
                m_pPropCache,
                TEXT(UMIOBJ_INTF_PROP_SUPERCLASS),
                NULL,
                TRUE
                );

            m_fIsClassObj = TRUE;

            BAIL_ON_FAILURE(hr);
        } // if(IsClassObj...)
    }
    else
        dwGenus = UMI_GENUS_INSTANCE;

    hr = SetDWORDPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_GENUS),
            dwGenus,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    // set the key property. For WinNT, it will always be "Name" except that
    // namespace objects have no key (since the UMI path to a namespace object
    // is just umi:///winnt - there is no component of the form class.key=val.
    if(!IsNamespaceObj(bstrClass)) {
        hr = SetLPTSTRPropertyInCache(
                m_pPropCache,
                TEXT(UMIOBJ_INTF_PROP_KEY),
                WINNT_KEY_NAME,
                TRUE 
                );

        BAIL_ON_FAILURE(hr);
    }
    else {
        m_fIsNamespaceObj = TRUE;
    }

    // Mark all properties as "not modified", since the client really hasn't
    // updated the cache, though we have.
    m_pPropCache->ClearModifiedFlags();

error:
    if(pDispatch != NULL)
        pDispatch->Release();

    if(bstrADsPath != NULL)
        SysFreeString(bstrADsPath);

    if(bstrClass != NULL)
        SysFreeString(bstrClass);

    if(pFullUmiPath != NULL)
        FreeADsStr(pFullUmiPath);

    if(pRelUmiPath != NULL)
        FreeADsStr(pRelUmiPath);

    if(pFullRelUmiPath != NULL)
        FreeADsStr(pFullRelUmiPath);

    if(pShortUmiPath != NULL)
        FreeADsStr(pShortUmiPath);

    if(pFullParentPath != NULL)
        FreeADsStr(pFullParentPath);

    if(bstrName != NULL)
        SysFreeString(bstrName);

    if(pUmiSchemaPath != NULL)
        FreeADsStr(pUmiSchemaPath);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   IsSchemaObject 
//
// Synopsis:   Returns whether an object of a specified class is a schema
//             object or not. 
//
// Arguments:
//
// bstrClass   Class of object
//
// Returns:    TRUE if it is a schema object. FALSE otherwise. 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
BOOL CUmiPropList::IsSchemaObject(
    BSTR bstrClass
    )
{
    ADsAssert(bstrClass != NULL);

    if( (!_wcsicmp(bstrClass, L"Schema")) ||
        (!_wcsicmp(bstrClass, L"Class")) ||
        (!_wcsicmp(bstrClass, L"Property")) ||
        (!_wcsicmp(bstrClass, L"Syntax")) ||
        (!_wcsicmp(bstrClass, L"Namespace")) )
        RRETURN(TRUE);

    RRETURN(FALSE);
}

//----------------------------------------------------------------------------
// Function:   GetSchemaObject
//
// Synopsis:   Returns a IUmiObject pointer pointing to the schema class object
//             corresponding to this WinNT object. If there is no class object,
//             returns error. 
//
// Arguments:
//
// pszName     Name of the schema property
// ppProp      Returns pointer to the structure containing the IUmiObject
//             pointer. 
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise. 
//
// Modifies:   *ppProp to return the address of UMI_PROPERTY_VALUES structure. 
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetSchemaObject(
    LPWSTR pszName,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT    hr = UMI_S_NO_ERROR;
    IUnknown   *pUnknown = NULL;
    IUmiObject *pUmiObj = NULL;
    UMI_PROPERTY_VALUES *pProp = NULL;

    PUMI_COM_OBJECT pUmiComObj = NULL;
    // use ADS_AUTH_RESERVED since the call is from UMI
    CWinNTCredentials Credentials(NULL, NULL, ADS_AUTH_RESERVED);

    ADsAssert( (ppProp != NULL) && (TRUE == m_fIsIntfPropObj) );

    *ppProp = NULL;

    if(NULL == m_pszSchema)
    // schema objects don't support __SCHEMA
        RRETURN(UMI_E_PROPERTY_NOT_FOUND);

    hr = GetObject(
            m_pszSchema,
            (LPVOID *) &pUnknown,
            Credentials
            ); 
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(IID_IUmiObject, (LPVOID *) &pUmiObj);
    BAIL_ON_FAILURE(hr);

    pUmiComObj = (PUMI_COM_OBJECT) AllocADsMem(sizeof(UMI_COM_OBJECT));
    if(NULL == pUmiComObj)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(pUmiComObj, 0, sizeof(UMI_COM_OBJECT));

    pUmiComObj->priid = (IID *) AllocADsMem(sizeof(IID));
    if(NULL == pUmiComObj->priid)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memcpy(pUmiComObj->priid, &IID_IUmiObject, sizeof(IID));
    pUmiComObj->pInterface = (LPVOID) pUmiObj;

    // allocate structure to return values
    pProp = (UMI_PROPERTY_VALUES *) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));
    if(NULL == pProp)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(pProp, 0, sizeof(UMI_PROPERTY_VALUES));

    pProp->pPropArray = (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));
    if(NULL == pProp->pPropArray)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(pProp->pPropArray, 0, sizeof(UMI_PROPERTY));

    pProp->pPropArray->pUmiValue = (UMI_VALUE *) pUmiComObj;

    // Get fetches only one property at a time
    pProp->uCount = 1;

    // Fill in remaining fields of UMI_PROPERTY
    pProp->pPropArray->uOperationType = 0;
    pProp->pPropArray->uType = UMI_TYPE_IUNKNOWN;
    pProp->pPropArray->uCount = 1;

    // not critical if this memory allocation fails. Property name doesn't
    // have to be returned to the caller.
    pProp->pPropArray->pszPropertyName = AllocADsStr(pszName);

    *ppProp = pProp;

error:

    if(pUnknown != NULL)
        pUnknown->Release();

    if(FAILED(hr)) {
        if(pUmiObj != NULL)
            pUmiObj->Release();

        if(pUmiComObj != NULL) {
            if(pUmiComObj->priid != NULL)
                FreeADsMem(pUmiComObj->priid);

            FreeADsMem(pUmiComObj);
        }

        if(pProp != NULL) {
            if(pProp->pPropArray != NULL) {
                if(pProp->pPropArray->pszPropertyName != NULL)
                    FreeADsStr(pProp->pPropArray->pszPropertyName);
                FreeADsMem(pProp->pPropArray);
            }

            FreeADsMem(pProp);
        }
    } // if(FAILED(hr)) 

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   SetClassInfo 
//
// Synopsis:   Initializes class info for this object. Class info will be
//             stored only for class schema objects.  
//
// Arguments:
//
// pClassInfo  Class info for the object (NULL if not a class object)
//
// Returns:    Nothing 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
void CUmiPropList::SetClassInfo(
    CLASSINFO *pClassInfo 
    )
{
    m_pClassInfo = pClassInfo;
    return;
} 
     
//----------------------------------------------------------------------------
// Function:   GetClassInfo
//
// Synopsis:   Returns the name and UMI type of all attributes in a given
//             WinNT class. This method will only be called on the interface
//             property object of a class object.
//
// Arguments:
//
// pProps      Returns the names and types of the attributes, without any data
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *pProps to return the property names 
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetClassInfo(
    UMI_PROPERTY_VALUES **pProps
    )
{
    UMI_PROPERTY_VALUES *pUmiPropVals = NULL;
    UMI_PROPERTY        *pUmiProps = NULL;
    HRESULT             hr = UMI_S_NO_ERROR;
    ULONG               ulIndex = 0;
    PPROPERTYINFO       pClassSchema = NULL;
    DWORD               dwClassSchemaSize = 0;

    ADsAssert(pProps != NULL);
    ADsAssert(TRUE == m_fIsIntfPropObj);
    ADsAssert(m_pClassInfo != NULL);

    pUmiPropVals = (UMI_PROPERTY_VALUES *) AllocADsMem(
                          sizeof(UMI_PROPERTY_VALUES));
    if(NULL == pUmiPropVals)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memset(pUmiPropVals, 0, sizeof(UMI_PROPERTY_VALUES));

    pClassSchema = m_pClassInfo->aPropertyInfo;
    dwClassSchemaSize = m_pClassInfo->cPropertyInfo;

    if(0 == dwClassSchemaSize) {
    // no properties in class
        *pProps = pUmiPropVals;
        RRETURN(UMI_S_NO_ERROR);
    }

    pUmiProps = (UMI_PROPERTY *) AllocADsMem(
                          dwClassSchemaSize * sizeof(UMI_PROPERTY));
    if(NULL == pUmiProps)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    memset(pUmiProps, 0, dwClassSchemaSize * sizeof(UMI_PROPERTY));

    for(ulIndex = 0; ulIndex < dwClassSchemaSize; ulIndex++) {
        pUmiProps[ulIndex].pszPropertyName = 
            (LPWSTR) AllocADsStr(pClassSchema[ulIndex].szPropertyName);
        if(NULL == pUmiProps[ulIndex].pszPropertyName)
            BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

        // map the NT type to a UMI type
        if(pClassSchema[ulIndex].dwSyntaxId >= g_dwNumNTTypes)
            BAIL_ON_FAILURE(hr = UMI_E_FAIL); // shouldn't happen

        pUmiProps[ulIndex].uType = 
            g_mapNTTypeToUmiType[pClassSchema[ulIndex].dwSyntaxId];
    }

    pUmiPropVals->uCount = dwClassSchemaSize;
    pUmiPropVals->pPropArray = pUmiProps;

    *pProps = pUmiPropVals; 

    RRETURN(UMI_S_NO_ERROR);

error:

    if(pUmiProps != NULL) { 
        for(ulIndex = 0; ulIndex < dwClassSchemaSize; ulIndex++)
            if(pUmiProps[ulIndex].pszPropertyName != NULL)
                FreeADsStr(pUmiProps[ulIndex].pszPropertyName);

        FreeADsMem(pUmiProps);
    }

    if(pUmiPropVals != NULL)
        FreeADsMem(pUmiPropVals);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   IsNamespaceObj
//
// Synopsis:   Returns whether an object of a specified class is a namespace 
//             object or not.
//
// Arguments:
//
// bstrClass   Class of object
//
// Returns:    TRUE if it is a namespace object. FALSE otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
BOOL CUmiPropList::IsNamespaceObj(
    BSTR bstrClass
    )
{
    ADsAssert(bstrClass != NULL);

    if(!_wcsicmp(bstrClass, L"Namespace"))
        RRETURN(TRUE);

    RRETURN(FALSE);
}

//----------------------------------------------------------------------------
// Function:   IsClassObj
//
// Synopsis:   Returns whether an object of a specified class is a class 
//             object or not.
//
// Arguments:
//
// bstrClass   Class of object
//
// Returns:    TRUE if it is a class object. FALSE otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
BOOL CUmiPropList::IsClassObj(
    BSTR bstrClass
    )
{
    ADsAssert(bstrClass != NULL);

    if(!_wcsicmp(bstrClass, L"Class"))
        RRETURN(TRUE);

    RRETURN(FALSE);
}

//----------------------------------------------------------------------------
// Function:   DisableWrites 
//
// Synopsis:   Disables writes on an interface property object. Used to disable
//             modification of connection interface properties after the
//             connection is opened. 
//
// Arguments:
//
// None
//
// Returns:    Nothing 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
void CUmiPropList::DisableWrites(void)
{
    ADsAssert(TRUE == m_fIsIntfPropObj);

    m_fDisableWrites = TRUE;
}

//----------------------------------------------------------------------------
// Function:   SetDefaultConnProps 
//
// Synopsis:   Sets the default connection interface properties on the
//             interface property object of a connection. 
//
// Arguments:
//
// None
//
// Returns:    S_OK on success. Error code otherwise. 
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::SetDefaultConnProps(void)
{
    HRESULT hr = S_OK;

    ADsAssert(TRUE == m_fIsIntfPropObj);

    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(CONN_INTF_PROP_USERNAME),
            CONN_INTF_PROP_DEFAULT_USERNAME,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    hr = SetLPTSTRPropertyInCache(
            m_pPropCache,
            TEXT(CONN_INTF_PROP_PASSWORD),
            CONN_INTF_PROP_DEFAULT_PASSWORD,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    hr = SetBOOLPropertyInCache(
            m_pPropCache,
            TEXT(CONN_INTF_PROP_SECURE_AUTH),
            CONN_INTF_PROP_DEFAULT_SECURE_AUTH,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    hr = SetBOOLPropertyInCache(
            m_pPropCache,
            TEXT(CONN_INTF_PROP_READONLY_SERVER),
            CONN_INTF_PROP_DEFAULT_READONLY_SERVER,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

    RRETURN(S_OK);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   SetPropertyCount
//
// Synopsis:   Sets the property count in the interface property object's
//             cache. The property count is the number of properties in the
//             schema class object. It is exposed on both schema objects and
//             instances. 
//
// Arguments:
//
// dwPropCount Property count 
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   Nothing
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::SetPropertyCount(DWORD dwPropCount)
{
    HRESULT hr = S_OK;

    hr = SetDWORDPropertyInCache(
            m_pPropCache,
            TEXT(UMIOBJ_INTF_PROP_PROPERTY_COUNT),
            dwPropCount,
            TRUE
            );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
// Function:   GetPropertyOrigin
//
// Synopsis:   Returns the class in the hierarchy that introduced a
//             property. Since WinNT does not have a class hierarchy, this
//             will always be the class on which this method is called. If
//             the property is not in the class, an error is returned. 
//
// Arguments:
//
// pszName     Name of the schema property
// ppProp      Returns pointer to the structure containing the class name 
//
// Returns:    UMI_S_NO_ERROR on success. Error code otherwise.
//
// Modifies:   *ppProp to return the address of UMI_PROPERTY_VALUES structure.
//
//----------------------------------------------------------------------------
HRESULT CUmiPropList::GetPropertyOrigin(
    LPCWSTR pszName,
    UMI_PROPERTY_VALUES **ppProp
    )
{
    HRESULT       hr = UMI_S_NO_ERROR;
    DWORD         dwIndex = 0;
    PPROPERTYINFO pClassSchema = NULL;
    DWORD         dwClassSchemaSize = 0;
    UMI_PROPERTY_VALUES *pProp = NULL;
    LPWSTR        *ppszClassArray = NULL;

    ADsAssert( (pszName != NULL) && (ppProp != NULL) && 
               (TRUE == m_fIsIntfPropObj) && (m_pClassInfo != NULL) );

    *ppProp = NULL;

    pClassSchema = m_pClassInfo->aPropertyInfo;
    dwClassSchemaSize = m_pClassInfo->cPropertyInfo;

    if(0 == dwClassSchemaSize) 
    // no properties in class
        BAIL_ON_FAILURE(hr = UMI_E_PROPERTY_NOT_FOUND);

    for(dwIndex = 0; dwIndex < dwClassSchemaSize; dwIndex++) {
        if(0 == _wcsicmp(pszName, pClassSchema[dwIndex].szPropertyName))
        // found the property
            break;
    }

    if(dwIndex == dwClassSchemaSize)
        BAIL_ON_FAILURE(hr = UMI_E_PROPERTY_NOT_FOUND);

    // allocate structure to return class name 
    pProp = (UMI_PROPERTY_VALUES *) AllocADsMem(sizeof(UMI_PROPERTY_VALUES));
    if(NULL == pProp)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(pProp, 0, sizeof(UMI_PROPERTY_VALUES));

    pProp->pPropArray = (UMI_PROPERTY *) AllocADsMem(sizeof(UMI_PROPERTY));
    if(NULL == pProp->pPropArray)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(pProp->pPropArray, 0, sizeof(UMI_PROPERTY));

    ppszClassArray = (LPWSTR *) AllocADsMem(sizeof(LPWSTR *));
    if(NULL == pProp->pPropArray)
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);
    memset(ppszClassArray, 0, sizeof(LPWSTR *));

    ppszClassArray[0] = AllocADsStr(m_pClassInfo->bstrName);
    if(NULL == ppszClassArray[0])
        BAIL_ON_FAILURE(hr = UMI_E_OUT_OF_MEMORY);

    pProp->pPropArray->pUmiValue = (UMI_VALUE *) ppszClassArray;

    // Get fetches only one property at a time
    pProp->uCount = 1;

    // Fill in remaining fields of UMI_PROPERTY
    pProp->pPropArray->uOperationType = 0;
    pProp->pPropArray->uType = UMI_TYPE_LPWSTR;
    pProp->pPropArray->uCount = 1;

    // not critical if this memory allocation fails. Property name doesn't
    // have to be returned to the caller.
    pProp->pPropArray->pszPropertyName = AllocADsStr(pszName);

    *ppProp = pProp;

error:

    if(FAILED(hr)) {
        if(pProp != NULL) {
            if(pProp->pPropArray != NULL) {
                if(pProp->pPropArray->pszPropertyName != NULL)
                    FreeADsStr(pProp->pPropArray->pszPropertyName);
                FreeADsMem(pProp->pPropArray);
            }

            FreeADsMem(pProp);
        }

        if(ppszClassArray != NULL) {
            if(ppszClassArray[0] != NULL)
                FreeADsStr(ppszClassArray[0]);

            FreeADsMem(ppszClassArray);
        }

    } // if(FAILED(hr))

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\guid.c ===
#define INITGUID


#include <ole2.h>

//--------------------------------------------------------------------------
//
//  WinNT CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(CLSID_WinNTNamespace,0x250E91A0L,0x0367,0x11CF,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(CLSID_WinNTDomain,0x01544ED0L,0xFD16,0x11CE,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(CLSID_WinNTProvider,0x8b20cd60L, 0x0f29, 0x11cf,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(CLSID_WinNTUser,0xD83F1060L,0x1E71,0x11CF,0xB1,0xF3,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(CLSID_WinNTGroup,0xD9C1AAD0L,0x1E71,0x11CF,0xB1,0xF3,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(CLSID_WinNTComputer,0xDA438DC0L,0x1E71,0x11CF,0xB1,0xF3,0x02,0x60,0x8C,0x9E,0x75,0x53);

//------------------------------------------------------------------------
//  GUIDS that come out of winnt.tlb.
//------------------------------------------------------------------------

DEFINE_GUID(CLSID_WinNTFSPrintQueueGenInfo,0x0D1E2F60L,0x122B,0x11CF,0xA9,0x85,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_WinNTFSPrintQueueDriverInfo,0x27BD67A0L,0x122B,0x11CF,0xA9,0x85,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_WinNTPrintQueue,0xA6226AF0L,0x122B,0x11CF,0xA9,0x85,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_WinNTFSPrintQueueOperation,0xA6227AF0L,0x122B,0x11CF,0xA9,0x85,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_WinNTPrintJob, 0x06b7c9e0L, 0x5b4f, 0x11cf, 0xa9, 0x98, 0x00, 0xaa, 0x00, 0x6b, 0xc1, 0x49);

DEFINE_GUID(CLSID_WinNTService,0xC3968E50L,0x4C66,0x11CF,0xA9,0x95,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_WinNTFileService,0xA75397A0L,0x4C81,0x11CF,0xA9,0x95,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_WinNTSchema,0x6dc32210,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_WinNTClass,0x6dc32211,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_WinNTProperty,0x6dc32214,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_WinNTSyntax,0x6dc32215,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_WinNTSession,0x6dc32216,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_WinNTResource,0x6dc32217,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_WinNTFileShare,0x6dc32218,0x4d19,0x11cf,0x9e,0x74,0x00,0xaa,0x00,0x4a,0x56,0x91);

DEFINE_GUID(CLSID_FPNWFileService,0xA117D530L,0xA1EB,0x11CF,0xA9,0xA5,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_FPNWSession,0xA819CB50L,0xA1EB,0x11CF,0xA9,0xA5,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_FPNWFileShare,0xADF040B0L,0xA1EB,0x11CF,0xA9,0xA5,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(CLSID_FPNWResource,0xB381F2A0L,0xA1EB,0x11CF,0xA9,0xA5,0x00,0xAA,0x00,0x6B,0xC1,0x49);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\grput2.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  Windows NT 3.5 GroupCollection Enumeration Code
//
//
//
//
//
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

DOMAIN_GROUP_MEMBER DomMember;

//
// This assumes that addr is an LPBYTE type.
//
#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((DWORD_PTR)addr & ~1))

DWORD DomainGrpMemberStrings[]=

                             {
                             FIELD_OFFSET(DOMAIN_GROUP_MEMBER, Parent),
                             FIELD_OFFSET(DOMAIN_GROUP_MEMBER, Computer),
                             FIELD_OFFSET(DOMAIN_GROUP_MEMBER, Domain),
                             FIELD_OFFSET(DOMAIN_GROUP_MEMBER, Name),
                             0xFFFFFFFF
                             };

BOOL
WinNTGlobalGroupOpen(
    LPWSTR szDomainName,
    LPWSTR szComputerName,
    LPWSTR szGroupName,
    PHANDLE phGroup
    )
{

    WCHAR szTempBuffer[MAX_PATH];
    PINI_DOM_GROUP pIniDomGrp;
    HRESULT hr;


    if (!phGroup) {
        return(FALSE);
    }
    pIniDomGrp = (PINI_DOM_GROUP)AllocADsMem(
                                        sizeof(INI_DOM_GROUP)
                                        );
    if (!pIniDomGrp) {
        return(FALSE);
    }

    hr = MakeUncName(
            szComputerName,
            szTempBuffer
            );
    BAIL_ON_FAILURE(hr);

    if (!(pIniDomGrp->szUncCompName =  AllocADsStr(szTempBuffer))){
        goto error;
    }

    if (!(pIniDomGrp->szDomainName = AllocADsStr(szDomainName))) {
        goto error;

    }

    if (!(pIniDomGrp->szComputerName =  AllocADsStr(szComputerName))){
        goto error;
    }

    if (!(pIniDomGrp->szGroupName = AllocADsStr(szGroupName))){
        goto error;
    }


    *phGroup =  (HANDLE)pIniDomGrp;

    return(TRUE);


error:
    if (pIniDomGrp) {
        FreeIniDomGroup(pIniDomGrp);
    }

    *phGroup = NULL;

    return(FALSE);

}


BOOL
WinNTGlobalGroupEnum(
    HANDLE hGroup,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{

    LPDOMAIN_GROUP_MEMBER * ppGroupMembers = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPDOMAIN_GROUP_MEMBER pBuffer = NULL;
    LPBYTE pEnd = NULL;
    DWORD dwError = 0;
    BOOL retVal = FALSE;

    ppGroupMembers = (LPDOMAIN_GROUP_MEMBER *)AllocADsMem(
                                sizeof(LPDOMAIN_GROUP_MEMBER)* dwRequested
                                );
    if (!ppGroupMembers) {
        return(FALSE);
    }

    for (i = 0; i < dwRequested; i++) {

        dwRet = WinNTGlobalGroupGetObject(
                        hGroup,
                        &ppGroupMembers[dwReturned]
                        );

        if (!dwRet) {

            dwError = GetLastError();
            if (dwError == ERROR_INVALID_SID) {
                continue;
            }

            //
            // it was not because of a bad sid
            // so break out, nothing more can be done
            //

            break;


        }

        dwReturned++;

    }

    dwRet = ComputeGlobalGroupDataSize(
                    ppGroupMembers,
                    dwReturned,
                    &dwSize
                    );

    pBuffer = (LPDOMAIN_GROUP_MEMBER)AllocADsMem(
                        dwSize
                        );

    if (pBuffer) {

        retVal = TRUE;
        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniDomGroupToDomGroup(
                            ppGroupMembers[i],
                            (LPBYTE)(pBuffer + i),
                            pEnd
                            );
        }
    }

    for (i = 0; i < dwReturned; i++ ) {
        FreeIntDomGroup(*(ppGroupMembers + i));
    }

    FreeADsMem(ppGroupMembers);

    //
    // This will be NULL if pBuffer alloc failed.
    //
    *ppBuffer = (LPBYTE)pBuffer;

    *pdwReturned  = retVal ? dwReturned : 0;

    if (!retVal) {
        return(FALSE);
    }

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }
}

BOOL
WinNTGlobalGroupGetObject(
    HANDLE hGroup,
    LPDOMAIN_GROUP_MEMBER * ppGroupMember
    )
{

    BOOL dwRet = FALSE;
    PINI_DOM_GROUP pIniDomGrp = (PINI_DOM_GROUP)hGroup;
    NET_API_STATUS nasStatus = 0;

    if ((!pIniDomGrp->_pBuffer) ||
        (pIniDomGrp->_dwCurrentObject == pIniDomGrp->_dwObjectReturned)) {

        if (pIniDomGrp->_bNoMore) {

            //
            // No more objects to return
            //
            return(FALSE);
        }

        if (pIniDomGrp->_pBuffer) {
            NetApiBufferFree(pIniDomGrp->_pBuffer);
            pIniDomGrp->_pBuffer = NULL;
        }

        pIniDomGrp->_dwObjectReturned = 0;
        pIniDomGrp->_dwCurrentObject = 0;
        pIniDomGrp->_dwTotalObjects = 0;

        nasStatus = NetGroupGetUsers(
                        pIniDomGrp->szUncCompName,
                        pIniDomGrp->szGroupName,
                        0,
                        &pIniDomGrp->_pBuffer,
                        MAX_PREFERRED_LENGTH,
                        &pIniDomGrp->_dwObjectReturned,
                        &pIniDomGrp->_dwTotalObjects,
                        &pIniDomGrp->_dwResumeHandle
                        );

        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)){
            SetLastError(nasStatus);
            return(FALSE);
        }

        if (nasStatus != ERROR_MORE_DATA) {
            pIniDomGrp->_bNoMore = TRUE;
        }

        //
        // If there are no more objects to return,
        // return FALSE
        //
        if (!pIniDomGrp->_dwObjectReturned) {
            return(FALSE);
        }


    }

    dwRet = BuildGlobalGroupMember(
                hGroup,
                (LPBYTE)((LPGROUP_USERS_INFO_0)pIniDomGrp->_pBuffer + pIniDomGrp->_dwCurrentObject),
                ppGroupMember
                );
    if (!dwRet) {

        SetLastError(ERROR_INVALID_SID);
        goto error;
    }

    pIniDomGrp->_dwCurrentObject++;

    return(TRUE);

error:

    return(FALSE);
}


BOOL
WinNTGlobalGroupClose(
    HANDLE hGroup
    )
{

    PINI_DOM_GROUP pIniDomGrp = (PINI_DOM_GROUP)hGroup;

    if (pIniDomGrp) {
        FreeIniDomGroup(pIniDomGrp);
    }
    return(TRUE);
}

void
FreeIniDomGroup(
    PINI_DOM_GROUP pIniDomGrp
    )
{
    if (pIniDomGrp->szDomainName) {

        FreeADsStr(pIniDomGrp->szDomainName);
    }

    if (pIniDomGrp->szComputerName) {

        FreeADsStr(pIniDomGrp->szComputerName);
    }


    if (pIniDomGrp->szGroupName) {

        FreeADsStr(pIniDomGrp->szGroupName);
    }

    if (pIniDomGrp->szUncCompName) {

        FreeADsStr(pIniDomGrp->szUncCompName);
    }


    if (pIniDomGrp->_pBuffer) {

        NetApiBufferFree(pIniDomGrp->_pBuffer);
    }


    if (pIniDomGrp) {

       FreeADsMem(pIniDomGrp);
    }

   return;
}

void
FreeIntDomGroup(
    LPDOMAIN_GROUP_MEMBER pCompGroupMember
    )
{
    if (pCompGroupMember->Parent) {

        FreeADsMem(pCompGroupMember->Parent);

    }


    if (pCompGroupMember->Computer) {

        FreeADsStr(pCompGroupMember->Computer);
    }


    if (pCompGroupMember->Domain) {

        FreeADsStr(pCompGroupMember->Domain);

    }


    if (pCompGroupMember->Name) {

        FreeADsStr(pCompGroupMember->Name);
    }


    FreeADsMem(pCompGroupMember);

}



BOOL
ComputeGlobalGroupDataSize(
        LPDOMAIN_GROUP_MEMBER * ppGroupMembers,
        DWORD  dwReturned,
        PDWORD pdwSize
        )
{

    DWORD i = 0;
    DWORD cb = 0;
    LPDOMAIN_GROUP_MEMBER pMember = NULL;

    for (i = 0; i < dwReturned; i++) {

        pMember = *(ppGroupMembers + i);

        cb += sizeof(DOMAIN_GROUP_MEMBER);

        if (pMember->Parent) {
            cb += wcslen(pMember->Parent)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Computer) {
            cb += wcslen(pMember->Computer)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Domain) {
            cb += wcslen(pMember->Domain)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Name) {
            cb += wcslen(pMember->Name)*sizeof(WCHAR) + sizeof(WCHAR);
        }
    }

    *pdwSize = cb;
    return(TRUE);
}


LPBYTE
CopyIniDomGroupToDomGroup(
    LPDOMAIN_GROUP_MEMBER  pIntDomGrp,
    LPBYTE  pExtDomGrp,
    LPBYTE  pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(DOMAIN_GROUP_MEMBER)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    LPDOMAIN_GROUP_MEMBER pDomGrpMember = (LPDOMAIN_GROUP_MEMBER)pExtDomGrp;

    memset(SourceStrings, 0, sizeof(DOMAIN_GROUP_MEMBER));
    *pSourceStrings++ = pIntDomGrp->Parent;
    *pSourceStrings++ = pIntDomGrp->Computer;
    *pSourceStrings++ = pIntDomGrp->Domain;
    *pSourceStrings++ = pIntDomGrp->Name;

    pEnd = PackStrings(
                SourceStrings,
                pExtDomGrp,
                DomainGrpMemberStrings,
                pEnd
                );

    pDomGrpMember->Type = pIntDomGrp->Type;

    return pEnd;
}


BOOL
BuildGlobalGroupMember(
    HANDLE hGroup,
    LPBYTE lpBuffer,
    LPDOMAIN_GROUP_MEMBER * ppGroupMember
    )
{
    LPINI_DOM_GROUP pGroup = (LPINI_DOM_GROUP)hGroup;
    LPDOMAIN_GROUP_MEMBER pGroupMember = NULL;
    LPGROUP_USERS_INFO_0 pGrpMem = (LPGROUP_USERS_INFO_0)lpBuffer;
    WCHAR szADsParent[MAX_PATH];
    LPWSTR pMemberName = NULL;
    DWORD cblen = 0;

    pGroupMember = (LPDOMAIN_GROUP_MEMBER)AllocADsMem(
                                       sizeof(DOMAIN_GROUP_MEMBER)
                                       );
    if (!pGroupMember) {

        goto error;
    }

    pGroupMember->Name = AllocADsStr(pGrpMem->grui0_name);
    pGroupMember->Computer = AllocADsStr(pGroup->szComputerName);
    pGroupMember->Domain = AllocADsStr(pGroup->szDomainName);

    wsprintf(
        szADsParent,
        L"%s://%s",
        szProviderName,
        pGroup->szDomainName
        );
    pGroupMember->Parent = AllocADsStr(szADsParent);
    pGroupMember->ParentType = WINNT_DOMAIN_ID;
    pGroupMember->Type = WINNT_USER_ID;

    *ppGroupMember =  pGroupMember;
    return(TRUE);

error:

    if (pGroupMember) {
        FreeIntDomGroup(pGroupMember);
    }

    *ppGroupMember = NULL;

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\grputils.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      cenumGroupCollection.cxx
//
//  Contents:  Windows NT 3.5 GroupCollection Enumeration Code
//
//
//
//
//
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

COMPUTER_GROUP_MEMBER CompMember;

//
// This assumes that addr is an LPBYTE type.
//
#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((DWORD_PTR)addr & ~1))

DWORD ComputerGrpMemberStrings[]=

                             {
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Parent),
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Computer),
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Domain),
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Name),
                             0xFFFFFFFF
                             };


DECLARE_INFOLEVEL(GrpUt)
DECLARE_DEBUG(GrpUt)
#define GrpUtDebugOut(x) GrpUtInlineDebugOut x


BOOL
WinNTLocalGroupOpen(
    LPWSTR szDomainName,
    LPWSTR szComputerName,
    LPWSTR szGroupName,
    PHANDLE phGroup
    )
{

    WCHAR szTempBuffer[MAX_PATH];
    PINI_COMP_GROUP pIniCompGrp;
    HRESULT hr;


    if (!phGroup) {
        return(FALSE);
    }
    pIniCompGrp = (PINI_COMP_GROUP)AllocADsMem(
                                        sizeof(INI_COMP_GROUP)
                                        );
    if (!pIniCompGrp) {
        return(FALSE);
    }

    hr = MakeUncName(
            szComputerName,
            szTempBuffer
            );
    BAIL_ON_FAILURE(hr);

    if (!(pIniCompGrp->szUncCompName =  AllocADsStr(szTempBuffer))){
        goto error;
    }

    // to guard against the case of domainName == NULL for no
    // workstation services
    if (szDomainName != NULL) {
        if (!(pIniCompGrp->szDomainName = AllocADsStr(szDomainName))) {
            goto error;
        }
    }

    if (!(pIniCompGrp->szComputerName =  AllocADsStr(szComputerName))){
        goto error;
    }

    if (!(pIniCompGrp->szGroupName = AllocADsStr(szGroupName))){
        goto error;
    }


    *phGroup =  (HANDLE)pIniCompGrp;

    return(TRUE);


error:
    if (pIniCompGrp) {
        FreeIniCompGroup(pIniCompGrp);
    }

    *phGroup = NULL;

    return(FALSE);

}


BOOL
WinNTLocalGroupEnum(
    HANDLE hGroup,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{

    LPCOMPUTER_GROUP_MEMBER * ppGroupMembers = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPCOMPUTER_GROUP_MEMBER pBuffer = NULL;
    LPBYTE pEnd = NULL;
    DWORD dwError;
    BOOL fretVal = FALSE;


    ppGroupMembers = (LPCOMPUTER_GROUP_MEMBER *)AllocADsMem(
                                sizeof(LPCOMPUTER_GROUP_MEMBER)* dwRequested
                                );
    if (!ppGroupMembers) {
        return(FALSE);
    }

    for (i = 0; i < dwRequested; i++) {

        dwRet = WinNTLocalGroupGetObject(
                        hGroup,
                        &ppGroupMembers[dwReturned]
                        );
        if (!dwRet) {

            dwError = GetLastError();
            if (dwError == ERROR_INVALID_SID) {
                continue;
            }

            //
            // it was not because of a bad sid
            // so break out, nothing more can be done
            //

            break;


        }

        dwReturned++;

    }

    dwRet = ComputeLocalGroupDataSize(
                    ppGroupMembers,
                    dwReturned,
                    &dwSize
                    );

    pBuffer = (LPCOMPUTER_GROUP_MEMBER)AllocADsMem(
                        dwSize
                        );

    if (pBuffer) {

        fretVal = TRUE;

        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniCompGroupToCompGroup(
                            ppGroupMembers[i],
                            (LPBYTE)(pBuffer + i),
                            pEnd
                            );
        }
    }

    for (i = 0; i < dwReturned; i++ ) {
        FreeIntCompGroup(*(ppGroupMembers + i));
    }

    FreeADsMem(ppGroupMembers);

    //
    // Will correctl set to NULL if alloc failed.
    //
    *ppBuffer = (LPBYTE)pBuffer;
    *pdwReturned  = fretVal ? dwReturned : 0;

    if (!fretVal) {
        return(FALSE);
    }

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }
}

BOOL
WinNTLocalGroupGetObject(
    HANDLE hGroup,
    LPCOMPUTER_GROUP_MEMBER * ppGroupMember
    )
{

    BOOL dwRet = FALSE;
    PINI_COMP_GROUP pIniCompGrp = (PINI_COMP_GROUP)hGroup;
    NET_API_STATUS nasStatus = 0;

    if ((!pIniCompGrp->_pBuffer) ||
        (pIniCompGrp->_dwCurrentObject == pIniCompGrp->_dwObjectReturned)) {

        if (pIniCompGrp->_bNoMore) {

            //
            // No more objects to return
            //
            return(FALSE);
        }

        if (pIniCompGrp->_pBuffer) {
            NetApiBufferFree(pIniCompGrp->_pBuffer);
            pIniCompGrp->_pBuffer = NULL;
        }

        pIniCompGrp->_dwObjectReturned = 0;
        pIniCompGrp->_dwCurrentObject = 0;
        pIniCompGrp->_dwTotalObjects = 0;

        nasStatus = NetLocalGroupGetMembers(
                            pIniCompGrp->szUncCompName,
                            pIniCompGrp->szGroupName,
                            2,
                            &pIniCompGrp->_pBuffer,
                            MAX_PREFERRED_LENGTH,
                            &pIniCompGrp->_dwObjectReturned,
                            &pIniCompGrp->_dwTotalObjects,
                            &pIniCompGrp->_dwResumeHandle
                            );
        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)){
            SetLastError(nasStatus);
            return(FALSE);
        }

        if (nasStatus != ERROR_MORE_DATA) {
            pIniCompGrp->_bNoMore = TRUE;
        }

        //
        // If there are no more objects to return,
        // return FALSE
        //
        if (!pIniCompGrp->_dwObjectReturned) {
            return(FALSE);
        }

    }

    while ( dwRet != TRUE &&
            (pIniCompGrp->_dwCurrentObject < pIniCompGrp->_dwTotalObjects))
     {

       dwRet = BuildLocalGroupMember(
                hGroup,
                (LPBYTE)((LPLOCALGROUP_MEMBERS_INFO_2)pIniCompGrp->_pBuffer
                                           + pIniCompGrp->_dwCurrentObject),
                 ppGroupMember
                );

       if (dwRet == FALSE) {
         if (GetLastError() == ERROR_INVALID_SID) {
           pIniCompGrp->_dwCurrentObject++;
           continue;
           //
           // proceed to the top of the while loop
           //
         }
         else
           goto error;
       }
    }
    //
    // the while loop
    //
    if (dwRet == FALSE)
       goto error;

    pIniCompGrp->_dwCurrentObject++;

    return(TRUE);

error:

    return(FALSE);
}


BOOL
WinNTLocalGroupClose(
    HANDLE hGroup
    )
{

    PINI_COMP_GROUP pIniCompGrp = (PINI_COMP_GROUP)hGroup;

    if (pIniCompGrp) {
        FreeIniCompGroup(pIniCompGrp);
    }
    return(TRUE);
}

void
FreeIniCompGroup(
    PINI_COMP_GROUP pIniCompGrp
    )
{
    if (pIniCompGrp->szDomainName) {

        FreeADsStr(pIniCompGrp->szDomainName);
    }

    if (pIniCompGrp->szComputerName) {

        FreeADsStr(pIniCompGrp->szComputerName);
    }


    if (pIniCompGrp->szGroupName) {

        FreeADsStr(pIniCompGrp->szGroupName);
    }

    if (pIniCompGrp->szUncCompName) {

        FreeADsStr(pIniCompGrp->szUncCompName);
    }


    if (pIniCompGrp->_pBuffer) {

        NetApiBufferFree(pIniCompGrp->_pBuffer);
    }


    if (pIniCompGrp) {

       FreeADsMem(pIniCompGrp);
    }

   return;
}

void
FreeIntCompGroup(
    LPCOMPUTER_GROUP_MEMBER pCompGroupMember
    )
{
    if (pCompGroupMember->Parent) {

        FreeADsMem(pCompGroupMember->Parent);

    }


    if (pCompGroupMember->Computer) {

        FreeADsStr(pCompGroupMember->Computer);
    }


    if (pCompGroupMember->Domain) {

        FreeADsStr(pCompGroupMember->Domain);

    }


    if (pCompGroupMember->Name) {

        FreeADsStr(pCompGroupMember->Name);
    }


    if (pCompGroupMember->Sid) {

        FreeADsMem(pCompGroupMember->Sid);
    }


    FreeADsMem(pCompGroupMember);


}



BOOL
ComputeLocalGroupDataSize(
        LPCOMPUTER_GROUP_MEMBER * ppGroupMembers,
        DWORD  dwReturned,
        PDWORD pdwSize
        )
{

    DWORD i = 0;
    DWORD cb = 0;
    LPCOMPUTER_GROUP_MEMBER pMember = NULL;

    for (i = 0; i < dwReturned; i++) {

        pMember = *(ppGroupMembers + i);

        cb += sizeof(COMPUTER_GROUP_MEMBER);

        if (pMember->Parent) {
            cb += wcslen(pMember->Parent)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Computer) {
            cb += wcslen(pMember->Computer)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Domain) {
            cb += wcslen(pMember->Domain)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Name) {
            cb += wcslen(pMember->Name)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Sid) {
            cb += GetLengthSid(pMember->Sid);
        }
    }

    *pdwSize = cb;
    return(TRUE);
}


LPBYTE
CopyIniCompGroupToCompGroup(
    LPCOMPUTER_GROUP_MEMBER  pIntCompGrp,
    LPBYTE  pExtCompGrp,
    LPBYTE  pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(COMPUTER_GROUP_MEMBER)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    LPCOMPUTER_GROUP_MEMBER pCompGrpMember = (LPCOMPUTER_GROUP_MEMBER)pExtCompGrp;
    DWORD dwSidLength = 0;

    memset(SourceStrings, 0, sizeof(COMPUTER_GROUP_MEMBER));
    *pSourceStrings++ = pIntCompGrp->Parent;
    *pSourceStrings++ = pIntCompGrp->Computer;
    *pSourceStrings++ = pIntCompGrp->Domain;
    *pSourceStrings++ = pIntCompGrp->Name;

    pEnd = PackStrings(
                SourceStrings,
                pExtCompGrp,
                ComputerGrpMemberStrings,
                pEnd
                );

    pCompGrpMember->Type = pIntCompGrp->Type;
    pCompGrpMember->ParentType = pIntCompGrp->ParentType;

    if (pIntCompGrp->Sid) {
        dwSidLength = GetLengthSid(pIntCompGrp->Sid);

        pEnd -= dwSidLength;

        memcpy(pEnd,
               pIntCompGrp->Sid,
               dwSidLength
               );
               
        pCompGrpMember->Sid = pEnd;
               
    }

    return pEnd;
}


BOOL
BuildLocalGroupMember(
    HANDLE hGroup,
    LPBYTE lpBuffer,
    LPCOMPUTER_GROUP_MEMBER * ppGroupMember
    )
{
    LPINI_COMP_GROUP pGroup = (LPINI_COMP_GROUP)hGroup;
    LPCOMPUTER_GROUP_MEMBER pGroupMember = NULL;
    LPLOCALGROUP_MEMBERS_INFO_2 pGrpMem = (LPLOCALGROUP_MEMBERS_INFO_2)lpBuffer;
    WCHAR szADsParent[MAX_PATH];
    LPWSTR pMemberName = NULL;
    LPWSTR pszSIDName = NULL;
    DWORD cblen = 0, dwLen = 0, dwLenDomAndName = 0;
    DWORD dwSidType = 0;
    DWORD dwSidLength = 0;
    BOOL fRet = FALSE;
    BOOL fError = FALSE;

    pGroupMember = (LPCOMPUTER_GROUP_MEMBER)AllocADsMem(
                                       sizeof(COMPUTER_GROUP_MEMBER)
                                       );
    if (!pGroupMember) {

        goto error;
    }

    dwSidType = pGrpMem->lgrmi2_sidusage;

    pMemberName = wcschr(pGrpMem->lgrmi2_domainandname, L'\\');

    cblen = wcslen(pGroup->szComputerName);

    //
    // Check to see if the lengthe of the domain name component in
    // lgrmi2_domainandname and the comptuername are the same if not
    // it cannot be a computer member object. We do this to catch the case
    // where foo.foodom is computer name. foodom\user will incorrectly
    // be identified as a local user rather than domain user
    //
    if (pMemberName) {
        *pMemberName = L'\0';
        dwLenDomAndName = wcslen(pGrpMem->lgrmi2_domainandname);
        *pMemberName = L'\\';
    }
    else {
        dwLenDomAndName = cblen;
    }


    if ((dwLenDomAndName == cblen) && !_wcsnicmp(pGroup->szComputerName, pGrpMem->lgrmi2_domainandname, cblen)) {

        //
        // This is the local user case
        //

      if (pMemberName) {

            pMemberName++;
        }
        else {

            pMemberName = pGrpMem->lgrmi2_domainandname ;
        }

        pGroupMember->Name = AllocADsStr(pMemberName);
        pGroupMember->Computer = AllocADsStr(pGroup->szComputerName);
        pGroupMember->Domain = AllocADsStr(pGroup->szDomainName);

        if (pGroupMember->Domain != NULL) {

            wsprintf(
                szADsParent,
                L"%s://%s/%s",
                szProviderName,
                pGroup->szDomainName,
                pGroup->szComputerName
                );

        } else {

            // Again we may have a null domain name for the case
            // where there are no workstations services
            wsprintf(
                szADsParent,
                L"%s://%s",
                szProviderName,
                pGroup->szComputerName
                );
        }

        pGroupMember->Parent = AllocADsStr(szADsParent);
        pGroupMember->ParentType = WINNT_COMPUTER_ID;
        //
        // Need to look at SID to see if this is a local group
        // in which case the sid will be alias.
        //

        if (dwSidType == SidTypeAlias) {
            pGroupMember->Type = WINNT_LOCALGROUP_ID;
        }
        else if (dwSidType == SidTypeUser) {
            pGroupMember->Type = WINNT_USER_ID;
        } else  {
            //
            // Unknown ??
            //
            SetLastError(ERROR_INVALID_SID);
            BAIL_ON_FAILURE(E_FAIL);

        }


    }else {

        //
        // This is the domain user, domain group case
        //

        pMemberName = wcschr(pGrpMem->lgrmi2_domainandname, L'\\');

        if (pMemberName) {

                *pMemberName = L'\0';
                pMemberName++;
                pGroupMember->Domain = AllocADsStr(pGrpMem->lgrmi2_domainandname);
                pGroupMember->Computer = NULL;


                wsprintf(
                    szADsParent,
                    L"%s://%s",
                    szProviderName,
                    pGrpMem->lgrmi2_domainandname
                    );
        }
        else {

            //
            // if name is well name like 'EveryOne' without the domain prefix,
            // we end up with using the local computer name
            //
            pMemberName = pGrpMem->lgrmi2_domainandname ;
            pGroupMember->Domain = NULL;
            pGroupMember->Computer = AllocADsStr(L"") ;

            wsprintf(
                szADsParent,
                L"WinNT:"
                );
        }

        pGroupMember->Name = AllocADsStr(pMemberName);


        pGroupMember->Parent = AllocADsStr(szADsParent);

        switch (dwSidType) {
        case SidTypeUser:
            pGroupMember->Type = WINNT_USER_ID;
            break;

        case SidTypeGroup:
        case SidTypeWellKnownGroup :
        case SidTypeAlias :
            pGroupMember->Type = WINNT_GROUP_ID;
            break;

        case SidTypeUnknown:
        case SidTypeDeletedAccount:

#if !defined(WIN95)
            //
            // In this case we want to use the stringized SID.
            // We use functions in sddl.h.
            //
            fRet = ConvertSidToStringSidWrapper(
                        pGrpMem->lgrmi2_sid,
                        &pszSIDName
                        );

            if (!fRet || !pszSIDName) {
                //
                // Not much we can do here
                //
                SetLastError(ERROR_INVALID_SID);
                fError = TRUE;
            } else {
                //
                // We are always going to return just the SID.
                //
                if (pGroupMember->Name) {
                    FreeADsStr(pGroupMember->Name);
                    pGroupMember->Name = NULL;
                }

                if (pGroupMember->Parent) {
                    FreeADsStr(pGroupMember->Parent);
                    pGroupMember->Parent = NULL;
                }

                if (pGroupMember->Domain) {
                    FreeADsStr(pGroupMember->Domain);
                    pGroupMember->Domain = NULL;
                }

                //
                // Got be either user so default to user.
                //
                pGroupMember->Type = WINNT_USER_ID;

                pGroupMember->Name = AllocADsStr(pszSIDName);
                pGroupMember->Parent = AllocADsStr(L"WinNT:");
                if (!pGroupMember->Name || ! pGroupMember->Parent) {
                    //
                    // Not enough mem - rather than ignore like we do
                    // in the rest of the places in this fn, will
                    // set the last error and hope we recover.
                    //
                    SetLastError(ERROR_INVALID_SID);
                    fError = TRUE;
                }
            }
#else
            SetLastError(ERROR_INVALID_SID);
            fError = TRUE;
#endif
            if (pszSIDName) {
                LocalFree(pszSIDName);
            }
            if (fError)
                goto error;
            break;

        default:
            SetLastError(ERROR_INVALID_SID);
            goto error;
            break;

        }

        //
        // Need to special case this as we cannot have a domain
        // name that is NULL.
        //
        if (dwSidType == SidTypeDeletedAccount
            || dwSidType == SidTypeUnknown) {
            pGroupMember->ParentType = WINNT_COMPUTER_ID;
        }
        else {
            pGroupMember->ParentType = WINNT_DOMAIN_ID;
        }

    }

    //
    // Copy the SID
    //
    if (pGrpMem->lgrmi2_sid) {

        //
        // On NT4 for some reason GetLengthSID does not set lasterror to 0
        //
        SetLastError(NO_ERROR);

        dwSidLength = GetLengthSid(pGrpMem->lgrmi2_sid);

        //
        // This is an extra check to make sure that we have the
        // correct length.
        //
        if (GetLastError() != NO_ERROR) {
            SetLastError(ERROR_INVALID_SID);
            BAIL_ON_FAILURE(E_FAIL);        
        }

        pGroupMember->Sid = AllocADsMem(dwSidLength);
        if (!pGroupMember->Sid) {
            SetLastError(ERROR_OUTOFMEMORY);
            BAIL_ON_FAILURE(E_OUTOFMEMORY);
        }

        memcpy(pGroupMember->Sid, pGrpMem->lgrmi2_sid, dwSidLength);
    }

    *ppGroupMember =  pGroupMember;
    return(TRUE);

error:

    if (pGroupMember) {

        FreeIntCompGroup(pGroupMember);
    }

    *ppGroupMember = NULL;
    return(FALSE);

}


LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    )
{
    DWORD cbStr;
    WORD_ALIGN_DOWN(pEnd);

    while (*DestOffsets != -1) {
        if (*pSource) {
            cbStr = wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
            pEnd -= cbStr;
            CopyMemory( pEnd, *pSource, cbStr);
            *(LPWSTR *)(pDest+*DestOffsets) = (LPWSTR)pEnd;
        } else {
            *(LPWSTR *)(pDest+*DestOffsets)=0;
        }
        pSource++;
        DestOffsets++;
    }
    return pEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\jobhlp.cxx ===
/*++
  Copyright (c) 1995-1996  Microsoft Corporation

  Module Name:

  jobhlp.cxx

  Abstract:
  Helper functions for Job Object

  Author:

  Ram Viswanathan (ramv) 11-18-95

  Revision History:

  --*/

#include "winnt.hxx"
#pragma hdrstop
#define INITGUID


//
// mapping WinNT Status Codes to ADs Status Codes and vice versa
//

typedef struct _JobStatusList {
    DWORD  dwWinNTJobStatus;
    DWORD dwADsJobStatus;
} JOB_STATUS_LIST, *PJOB_STATUS_LIST;


JOB_STATUS_LIST JobStatusList[] =
{
{JOB_STATUS_PAUSED, ADS_JOB_PAUSED },
{JOB_STATUS_ERROR, ADS_JOB_ERROR},
{JOB_STATUS_DELETING, ADS_JOB_DELETING},
{JOB_STATUS_SPOOLING, ADS_JOB_SPOOLING},
{JOB_STATUS_PRINTING, ADS_JOB_PRINTING},
{JOB_STATUS_OFFLINE, ADS_JOB_OFFLINE},
{JOB_STATUS_PAPEROUT, ADS_JOB_PAPEROUT},
{JOB_STATUS_PRINTED, ADS_JOB_PRINTED}
};

BOOL JobStatusWinNTToADs( DWORD dwWinNTStatus,
DWORD *pdwADsStatus)
{
    BOOL found = FALSE;
    int i;

    for (i=0;i<8;i++){

        if(dwWinNTStatus == JobStatusList[i].dwWinNTJobStatus){
            *pdwADsStatus = JobStatusList[i].dwADsJobStatus;
            found = TRUE;
            break;
        }
    }
    return (found);
}

BOOL JobStatusADsToWinNT( DWORD dwADsStatus,
                           DWORD *pdwWinNTStatus)

{
    BOOL found = FALSE;
    int i;

    for (i=0;i<8;i++){

        if(dwADsStatus == JobStatusList[i].dwADsJobStatus){
            *pdwWinNTStatus = JobStatusList[i].dwWinNTJobStatus;
            found = TRUE;
            break;
        }
    }
    return (found);

}




//+---------------------------------------------------------------------------
//
//  Function:   MarshallAndSet
//
//  Synopsis:   Marshalls information from a Print Job  object to a
//              JOB_INFO_2 structure and sets it
//
//  Arguments:  [lpJobInfo2] -- Pointer to a JOB_INFO_2 struct.
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11/09/95  RamV  Created
//
//-----------------------------------------------------------------

HRESULT
CWinNTPrintJob::MarshallAndSet(
    LPJOB_INFO_2 lpJobInfo2,
    BSTR bstrPrinterName,
    LONG lJobId
    )

{
    HRESULT hr =S_OK;
    LPTSTR pszUserName = NULL;
    LPTSTR pszDescription = NULL;
    LPTSTR pszNotify = NULL;
    LPTSTR pszDocument = NULL;
    DWORD dwPriority;
    DWORD dwPosition;
    DWORD dwStartTime;
    DWORD dwUntilTime;
    DWORD dwTotalPages;
    DWORD dwSize;
    DWORD dwPagesPrinted;
    SYSTEMTIME stTimeSubmitted;


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("User"),
                    &pszUserName
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->pUserName = pszUserName;
    }


    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Description"),
                    &pszDocument
                    );
    if(SUCCEEDED(hr)){
        lpJobInfo2->pDocument = pszDocument;
    }

    hr = GetLPTSTRPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Notify"),
                    &pszNotify
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->pNotifyName = pszNotify;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Priority"),
                    &dwPriority
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Priority = dwPriority;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Position"),
                    &dwPosition
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Position = dwPosition;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("TotalPages"),
                    &dwTotalPages
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->TotalPages = dwTotalPages;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("Size"),
                    &dwSize
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Size = dwSize;
    }

    hr = GetDWORDPropertyFromCache(
                    _pPropertyCache,
                    TEXT("PagesPrinted"),
                    &dwPagesPrinted
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->PagesPrinted = dwPagesPrinted;
    }

   hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("StartTime"),
                    &dwStartTime
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->StartTime = dwStartTime;
    }

   hr = GetDATEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("UntilTime"),
                    &dwUntilTime
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->UntilTime = dwUntilTime;
    }

   hr = GetSYSTEMTIMEPropertyFromCache(
                    _pPropertyCache,
                    TEXT("TimeSubmitted"),
                    &stTimeSubmitted
                    );

    if(SUCCEEDED(hr)){
        lpJobInfo2->Submitted = stTimeSubmitted;
    }

    //
    // set the relevant information
    //

    hr = Set(lpJobInfo2,
             bstrPrinterName,
             lJobId);

    if(pszUserName){
        FreeADsStr(pszUserName);
    }
    if(pszDescription){
        FreeADsStr(pszDescription);
    }
    if(pszNotify){
        FreeADsStr(pszNotify);
    }
    if(pszDocument){
        FreeADsStr(pszDocument);
    }

    RRETURN(hr);
}


//+----------------------------------------------------------------
//
//  Function:   UnmarshallLevel2
//
//  Synopsis:   Unmarshalls information from a JOB_INFO_2 to a
//              WinNT Print JOB  object.
//
//  Arguments:  [lpJobInfo2] -- Pointer to a JOB_INFO_2 struct
//
//  Returns:    HRESULT
//
//  Modifies:   GeneralInfo and Operation Functional sets
//
//  History:    11/08/95  RamV   Created
//
//----------------------------------------------------------------------------

HRESULT
CWinNTPrintJob::UnMarshallLevel2(
    LPJOB_INFO_2 lpJobInfo2,
    BOOL fExplicit
    )

{
    HRESULT hr S_OK;

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("TimeElapsed"),
                                lpJobInfo2->Time,
                                fExplicit
                                );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("PagesPrinted"),
                                lpJobInfo2->PagesPrinted,
                                fExplicit
                                );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("Position"),
                                lpJobInfo2->Position,
                                fExplicit
                                );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("HostPrintQueue"),
                                  _pszPrinterPath,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("User"),
                                  lpJobInfo2->pUserName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  lpJobInfo2->pDocument,
                                  fExplicit
                                  );

   hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Notify"),
                                  lpJobInfo2->pNotifyName,
                                  fExplicit
                                  );

   hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("Priority"),
                                lpJobInfo2->Priority,
                                fExplicit
                                );

   hr = SetDATEPropertyInCache(_pPropertyCache,
                               TEXT("StartTime"),
                               lpJobInfo2->StartTime,
                               fExplicit
                               );

   hr = SetDATEPropertyInCache(_pPropertyCache,
                               TEXT("UntilTime"),
                               lpJobInfo2-> UntilTime,
                               fExplicit
                               );

   hr = SetSYSTEMTIMEPropertyInCache(_pPropertyCache,
                                     TEXT("TimeSubmitted"),
                                     lpJobInfo2->Submitted,
                                     fExplicit
                                     );

   hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("TotalPages"),
                                lpJobInfo2->TotalPages,
                                fExplicit
                                );

   hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("Size"),
                                lpJobInfo2->Size,
                                fExplicit
                                );

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("Name"),
                _Name,
                fExplicit
                );

    RRETURN(S_OK);

}

HRESULT
CWinNTPrintJob::UnMarshallLevel1(
    LPJOB_INFO_1 lpJobInfo1,
    BOOL fExplicit
    )

{
    HRESULT hr;

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("PagesPrinted"),
                                lpJobInfo1->PagesPrinted,
                                fExplicit
                                );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                TEXT("Position"),
                                lpJobInfo1->Position,
                                fExplicit
                                );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("User"),
                                  lpJobInfo1->pUserName,
                                  fExplicit
                                  );

    hr = SetLPTSTRPropertyInCache(_pPropertyCache,
                                  TEXT("Description"),
                                  lpJobInfo1->pDocument,
                                  fExplicit
                                  );


    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("Priority"),
                                  lpJobInfo1->Priority,
                                  fExplicit
                                  );

    hr = SetDWORDPropertyInCache(_pPropertyCache,
                                  TEXT("TotalPages"),
                                  lpJobInfo1->TotalPages,
                                  fExplicit
                                  );

    hr = SetSYSTEMTIMEPropertyInCache(_pPropertyCache,
                                      TEXT("TimeSubmitted"),
                                      lpJobInfo1->Submitted,
                                      fExplicit
                                      );

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   Set
//
//  Synopsis:   Helper function called by CADsPrintJob:SetInfo
//
//  Arguments:
//
//  Returns:    HRESULT.
//
//  Modifies:
//
//  History:    11-08-95 RamV  Created
//
//----------------------------------------------------------------------------

HRESULT
Set(
    LPJOB_INFO_2 lpJobInfo2,
    BSTR         bstrPrinterName,
    LONG         lJobId
    )
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ALL_ACCESS};
    HANDLE hPrinter = NULL;
    HRESULT hr = S_OK;
    DWORD LastError = 0;

    ADsAssert(bstrPrinterName);

    fStatus = OpenPrinter((LPTSTR)bstrPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );


    if (!fStatus) {
        goto error;
    }

    fStatus = SetJob(hPrinter,
                     lJobId,
                     2,
                     (LPBYTE)lpJobInfo2,
                     0
                     );

    if (!fStatus) {
        goto error;
    }

    RRETURN(S_OK);

error:
    hr =HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);

}


HRESULT
GetJobInfo( DWORD dwLevel,
           LPBYTE *ppJobInfo,
           LPWSTR      pszPrinterName,
           LONG        lJobId)

{
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE |
                                            READ_CONTROL};
    BOOL fStatus = FALSE;
    DWORD dwPassed = 0, dwNeeded = 0;
    DWORD LastError = 0;
    HANDLE hPrinter = NULL;
    LPBYTE pMem = NULL;
    HRESULT hr = S_OK;


    ADsAssert(dwLevel ==1 || dwLevel == 2);

    fStatus = OpenPrinter(pszPrinterName,
                          &hPrinter,
                          &PrinterDefaults
                          );
    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {

        case ERROR_ACCESS_DENIED:
        {
            PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
            fStatus = OpenPrinter(pszPrinterName,
                                  &hPrinter,
                                  &PrinterDefaults
                                  );
            if (fStatus) {
                break;
            }
        }
        default:
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    pMem = (LPBYTE)AllocADsMem(dwPassed);

    if (!pMem) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    fStatus = GetJob(hPrinter,
                     lJobId,
                     dwLevel,
                     (LPBYTE)pMem,
                     dwPassed,
                     &dwNeeded
                     );
    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {
        case ERROR_INSUFFICIENT_BUFFER:
            if(pMem){
                FreeADsMem(pMem);
            }
            dwPassed = dwNeeded;
            pMem = (LPBYTE)AllocADsMem(dwPassed);

            if (!pMem) {
                hr = E_OUTOFMEMORY;
                goto cleanup;
            }

            fStatus = GetJob(hPrinter,
                             lJobId,
                             dwLevel,
                             (LPBYTE)pMem,
                             dwPassed,
                             &dwNeeded
                             );
            if (!fStatus) {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto cleanup;
            }
            break;

        default:
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto cleanup;

        }
    }

    *ppJobInfo = pMem;

cleanup:
    if(hPrinter)
        ClosePrinter(hPrinter);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for WinNT guids
//
//  History:    16-Jan-95   KrishnaG
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// WinNTOle CLSIDs
//
//-------------------------------------------


//
// WinNTOle objects
//

extern const CLSID CLSID_WinNTPrinter;

// uuids from winnt.tlb

extern const CLSID CLSID_WinNTDomain;

extern const CLSID CLSID_WinNTProvider;

extern const CLSID CLSID_WinNTNamespace;

extern const CLSID CLSID_WinNTUser;

extern const CLSID CLSID_WinNTComputer;

extern const CLSID CLSID_WinNTGroup;

extern const GUID LIBID_ADs;

extern const GUID CLSID_WinNTPrintQueue;

extern const GUID CLSID_WinNTPrintJob;

extern const GUID CLSID_WinNTService;
extern const GUID CLSID_WinNTFileService;

extern const GUID CLSID_WinNTSession;
extern const GUID CLSID_WinNTResource;
extern const GUID CLSID_WinNTFileShare;

extern const GUID CLSID_FPNWFileService;
extern const GUID CLSID_FPNWSession;
extern const GUID CLSID_FPNWResource;
extern const GUID CLSID_FPNWFileShare;

extern const GUID CLSID_WinNTSchema;
extern const GUID CLSID_WinNTClass;
extern const GUID CLSID_WinNTProperty;
extern const GUID CLSID_WinNTSyntax;

extern const GUID ADS_LIBIID_ADs;

// uuids from netole.tlb

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  getobj.cxx
//
//  Contents:  Windows NT 3.5 GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma hdrstop

extern WCHAR * szWinNTPrefix;

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:  Called by ResolvePathName to return an object
//
//  Arguments:  [LPWSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetObject(
    LPWSTR szBuffer,
    LPVOID *ppObject,
    CWinNTCredentials& Credentials
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);
    HRESULT hr;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = ValidateProvider(pObjectInfo);
    BAIL_IF_ERROR(hr);

    switch (pObjectInfo->ObjectType) {
    case TOKEN_DOMAIN:
        hr = GetDomainObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_USER:
        hr = GetUserObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_COMPUTER:
        hr = GetComputerObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_PRINTER:
        hr = GetPrinterObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_SERVICE:
        hr = GetServiceObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_FILESERVICE:
        hr = GetFileServiceObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_GROUP:
        hr = GetGroupObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_LOCALGROUP:
        hr = E_ADS_BAD_PATHNAME;
        //hr = GetLocalGroupObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_GLOBALGROUP:
        hr = E_ADS_BAD_PATHNAME;
        //hr = GetGlobalGroupObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_FILESHARE:
        hr = GetFileShareObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_SCHEMA:
        hr = GetSchemaObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_CLASS:
        hr = GetClassObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_PROPERTY:
        hr = GetPropertyObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_SYNTAX:
        hr = GetSyntaxObject(pObjectInfo, ppObject, Credentials);
        break;

    case TOKEN_WORKGROUP:
        hr = GetWorkGroupObject(pObjectInfo, ppObject, Credentials);
        break;

    default:
        hr = HeuristicGetObject(pObjectInfo, ppObject, Credentials);
        break;
    }

cleanup:

    FreeObjectInfo( &ObjectInfo, TRUE );
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    GetDomainObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetNamespaceObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr;

    hr = ValidateNamespaceObject(
                pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    // check if the call is from UMI
    if(Credentials.GetFlags() & ADS_AUTH_RESERVED) {
        hr = CWinNTNamespace::CreateNamespace(
                L"ADs:",
                L"WinNT:",
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                Credentials,
                ppObject
                );
    }
    else { // came in through ADSI
        hr = CoCreateInstance(CLSID_WinNTNamespace,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IUnknown,
                          (void **)ppObject );
    }

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:    GetDomainObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetDomainObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr;
    IUnknown *pUnknown = NULL;
    IADs *pADs = NULL;
    NET_API_STATUS nasStatus;
    WCHAR szHostServerName[MAX_PATH];
    WCHAR ADsParent[MAX_ADS_PATH];
    WCHAR szSAMName[MAX_ADS_PATH];

    szSAMName[0] = L'\0';

    *ppObject = NULL;

    if (pObjectInfo->NumComponents != 1) {
        RRETURN(E_ADS_INVALID_DOMAIN_OBJECT);
    }

    //
    // Verify that this object is really a domain
    //

    // We can try and ref the domain here but it will
    // anyway end up in WinNTGetCachedDCName call in
    // CWinNTCredentials::RefDomain, so there is no point in
    // doing that

    hr = WinNTGetCachedDCName(
                pObjectInfo->ComponentArray[0],
                szHostServerName,
                Credentials.GetFlags()
                );
    BAIL_ON_FAILURE(hr);

    if (szSAMName[0] != L'\0') {
        if (pObjectInfo->ComponentArray[0]) {
            FreeADsStr(pObjectInfo->ComponentArray[0]);
        }

        pObjectInfo->ComponentArray[0] = AllocADsStr(szSAMName);
        if (!pObjectInfo) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }


    hr = BuildParent(
            pObjectInfo,
            ADsParent
            );
    BAIL_ON_FAILURE(hr);


    hr = CWinNTDomain::CreateDomain(
                ADsParent,
                pObjectInfo->ComponentArray[0],
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                Credentials,
                (void **)&pUnknown
                );
    BAIL_ON_FAILURE(hr);


    *ppObject = pUnknown;

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:    GetWorkgroupObject
//
// Synopsis:    called by GetObject.
//              Note: We really don't have a workgroup object. But we
//              need to support a syntax such as @WinNT!workstation to
//              allow for IADsContainer interface methods. There is
//              no authentication that needs to done.
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
// History:    05-23-96  RamV  Created.
//
//----------------------------------------------------------------------------
HRESULT
GetWorkGroupObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{


    HRESULT hr;
    IUnknown *pUnknown = NULL;
    IADs *pADs = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    WCHAR szName[MAX_PATH];

    *ppObject = NULL;

    if (pObjectInfo->NumComponents != 1) {
        RRETURN(E_ADS_INVALID_DOMAIN_OBJECT);
    }

    //
    // any single component oleds path can be validated as a workgroup
    //

    hr = BuildParent(
            pObjectInfo,
            ADsParent
            );
    BAIL_ON_FAILURE(hr);


    hr = CWinNTDomain::CreateDomain(
                ADsParent,
                pObjectInfo->ComponentArray[0],
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                Credentials,
                (void **)&pUnknown
                );

    BAIL_ON_FAILURE(hr);


    *ppObject = pUnknown;

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetUserObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//              8-8-96   ramv         Modified.
//
//----------------------------------------------------------------------------
HRESULT
GetUserObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szUserName = NULL;
    DWORD  dwParentId = 0;
    WCHAR  szComputerParent[MAX_PATH];
    POBJECTINFO pUserObjectInfo = NULL;


    hr = ValidateUserObject(
                pObjectInfo,
                &dwParentId,
                Credentials
                );
    BAIL_ON_FAILURE(hr);

    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // could be user in computer or user in domain
        //
        if(dwParentId == WINNT_DOMAIN_ID){

            szDomainName = pObjectInfo->ComponentArray[0];
            szUserName = pObjectInfo->ComponentArray[1];
            szServerName = NULL;

            hr = BuildParent(pObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

        } else {

            //
            // user in a computer
            //

            hr = ConstructFullObjectInfo(pObjectInfo,
                                         &pUserObjectInfo,
                                         Credentials );
            if (SUCCEEDED(hr)) {

                hr = BuildParent(pUserObjectInfo, ADsParent);

                BAIL_ON_FAILURE(hr);

                szDomainName =  pUserObjectInfo->ComponentArray[0];
                szServerName =  pUserObjectInfo->ComponentArray[1];
                szUserName   =  pUserObjectInfo->ComponentArray[2];

            }
            else if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {

                // We alread know that the object is valid,
                // So we should set appropriate values and proceed to
                // create the object
                hr = BuildParent(pObjectInfo, ADsParent);

                BAIL_ON_FAILURE(hr);

                szDomainName = NULL;
                szServerName = pObjectInfo->ComponentArray[0];
                szUserName   = pObjectInfo->ComponentArray[1];

            }

        }

        break;


    case 3:
        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szUserName = pObjectInfo->ComponentArray[2];

        hr = BuildParent(pObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);
        break;
    }

    hr = CWinNTUser::CreateUser(ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szUserName,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    FreeObjectInfo(pUserObjectInfo);
    RRETURN(hr);

error:

    if (pUnknown) {
        pUnknown->Release();
    }
    *ppObject = NULL;

    FreeObjectInfo(pUserObjectInfo);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetUserObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    8-8-96   ramv    Created.
//
//----------------------------------------------------------------------------
HRESULT
GetUserObjectInDomain(
    LPWSTR pszHostServerName,
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szUserName = NULL;
    DWORD  dwParentId = WINNT_DOMAIN_ID;
    LPUSER_INFO_20 lpUI = NULL;
    NET_API_STATUS nasStatus;
    BOOL fRefAdded = FALSE;
    LPUSER_INFO_0 lpUI_0 = NULL;
    DWORD dwLevelUsed = 20;

    // At this point a \\ has been prepended to the host
    // we need to get rid of it.
    hr = Credentials.RefServer(pszHostServerName+2);
    if (SUCCEEDED(hr)) {
        fRefAdded = TRUE;
    }

    nasStatus = NetUserGetInfo(pszHostServerName,
                               pObjectInfo->ComponentArray[1],
                               20,
                               (LPBYTE *)&lpUI);

    if (nasStatus == ERROR_ACCESS_DENIED) {
        // try and drop down to level 0 as that may work

        dwLevelUsed = 0;
        nasStatus = NetUserGetInfo(
                        pszHostServerName,
                        pObjectInfo->ComponentArray[1],
                        0,
                        (LPBYTE *)&lpUI_0
                        );
    }

    // deref if necessary, note no error recovery possible
    if (fRefAdded) {
        Credentials.DeRefServer();
        fRefAdded = FALSE;
    }

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    // Need to use the name returned by the call as opposed
    // to the name given in the ADsPath
    if (dwLevelUsed == 20) {
        if (pObjectInfo->ComponentArray[1] && lpUI->usri20_name) {
            FreeADsStr(pObjectInfo->ComponentArray[1]);
            pObjectInfo->ComponentArray[1] = AllocADsStr(lpUI->usri20_name);
        }

        if (!pObjectInfo->ComponentArray[1])
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    // if it is not a level 20 call then we will just use
    // whatever the user gave us
    szDomainName = pObjectInfo->ComponentArray[0];
    szUserName = pObjectInfo->ComponentArray[1];
    szServerName = NULL;
    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CWinNTUser::CreateUser(ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szUserName,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;


error:
    if (FAILED(hr) && pUnknown) {
        pUnknown->Release();
        *ppObject = NULL;
    }

    if (lpUI)
        NetApiBufferFree((LPBYTE)lpUI);

    if (lpUI_0) {
        NetApiBufferFree((LPBYTE)lpUI_0);
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetUserObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//              8-8-96   ramv         Modified.
//
//----------------------------------------------------------------------------

HRESULT
GetUserObjectInComputer(
    LPWSTR pszHostServerName, // pdc name
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szUserName = NULL;
    DWORD  dwParentId = WINNT_COMPUTER_ID;
    WCHAR  szComputerParent[MAX_PATH];
    POBJECTINFO pUserObjectInfo = NULL;
    WCHAR lpszUncName[MAX_PATH];
    NET_API_STATUS nasStatus;
    LPBYTE lpUI = NULL;
    BOOL fRefAdded = FALSE;

    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // could be user in computer
        //
        //
        // first validate user
        //

        hr = Credentials.RefServer(pObjectInfo->ComponentArray[0]);
        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        MakeUncName(pObjectInfo->ComponentArray[0],
                    lpszUncName);

        nasStatus = NetUserGetInfo(lpszUncName,
                                   pObjectInfo->ComponentArray[1],
                                   20,
                                   &lpUI);

        if (fRefAdded) {
            Credentials.DeRefServer();
            fRefAdded = FALSE;
        }

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

        // Need to use the name returned by the call as opposed
        // to the name given in the ADsPath
        if (pObjectInfo->ComponentArray[1]
            && ((LPUSER_INFO_20)lpUI)->usri20_name) {

            FreeADsStr(pObjectInfo->ComponentArray[1]);
            pObjectInfo->ComponentArray[1]
                = AllocADsStr(((LPUSER_INFO_20)lpUI)->usri20_name);
        }

        if (!pObjectInfo->ComponentArray[1])
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        // This call will add the domain information to the
        // objectInfo blob, so that the ComponentArray[2] is valid

        hr = ConstructFullObjectInfo(pObjectInfo,
                                     &pUserObjectInfo,
                                     Credentials );
        BAIL_ON_FAILURE(hr);

        hr = BuildParent(pUserObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName =  pUserObjectInfo->ComponentArray[0];
        szServerName =  pUserObjectInfo->ComponentArray[1];
        szUserName   =  pUserObjectInfo->ComponentArray[2];

        break;


    case 3:

        //
        // ValidateComputerParent  and validate user in computer
        //

        hr = ValidateComputerParent(pObjectInfo->ComponentArray[0],
                                    pObjectInfo->ComponentArray[1],
                                    Credentials);
        BAIL_ON_FAILURE(hr);

        hr = Credentials.RefServer(pObjectInfo->ComponentArray[1]);
        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        MakeUncName(pObjectInfo->ComponentArray[1],
                    lpszUncName);

        nasStatus = NetUserGetInfo(lpszUncName,
                                   pObjectInfo->ComponentArray[2],
                                   20,
                                   (LPBYTE *)&lpUI);

        if (fRefAdded) {
            Credentials.DeRefServer();
            fRefAdded = FALSE;
        }

        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

        // Need to use the name returned by the call as opposed
        // to the name given in the ADsPath
        if (pObjectInfo->ComponentArray[2]
            && ((LPUSER_INFO_20)lpUI)->usri20_name) {

            FreeADsStr(pObjectInfo->ComponentArray[2]);
            pObjectInfo->ComponentArray[2]
                = AllocADsStr(((LPUSER_INFO_20)lpUI)->usri20_name);
        }

        if (!pObjectInfo->ComponentArray[2])
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        hr = BuildParent(pObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szUserName = pObjectInfo->ComponentArray[2];
        break;
    }
    hr = CWinNTUser::CreateUser(ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szUserName,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
error:
    if (FAILED(hr)) {
        if (pUnknown) {
            pUnknown->Release();
        }
        *ppObject = NULL;
    }
    else {
        *ppObject = pUnknown;
    }

    if (lpUI) {
        NetApiBufferFree(lpUI);
    }

    FreeObjectInfo(pUserObjectInfo);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetComputerObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetComputerObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];
    TCHAR  szUncName[MAX_PATH];
    NET_API_STATUS nasStatus;
    POBJECTINFO pComputerObjectInfo = NULL;
    BOOL fNoWksta = FALSE;
    WCHAR szCompName[MAX_PATH];
    DWORD dwSize = MAX_PATH;

    //
    // The following function call merely checks to see if the domain is
    // correct. If not, we can assume that the computer does not belong to
    // a domain.
    //

    hr = ValidateComputerObject(pObjectInfo, Credentials);

    if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted))
        fNoWksta = TRUE;
    else
        BAIL_ON_FAILURE(hr);

    // Normall we can expect that the workstation service will
    // be started. This will not be the case for minimum installs

    if (!fNoWksta) {

        if(pObjectInfo->NumComponents == 1){

            //
            // we need to supply the workgroup name for this computer
            // This is needed because EnumLocalGroups requires the
            // workgroup name to function properly
            //

            hr = ConstructFullObjectInfo(pObjectInfo,
                                         &pComputerObjectInfo,
                                         Credentials );

            BAIL_ON_FAILURE(hr);

            hr = BuildParent(pComputerObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

            hr = CWinNTComputer::CreateComputer(
                                ADsParent,
                                pComputerObjectInfo->ComponentArray[0],
                                pComputerObjectInfo->ComponentArray[1],
                                ADS_OBJECT_BOUND,
                                IID_IUnknown,
                                Credentials,
                                ppObject
                                );

        } else if(pObjectInfo->NumComponents == 2) {

            hr = BuildParent(pObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

            hr = CWinNTComputer::CreateComputer(
                                ADsParent,
                                pObjectInfo->ComponentArray[0],
                                pObjectInfo->ComponentArray[1],
                                ADS_OBJECT_BOUND,
                                IID_IUnknown,
                                Credentials,
                                ppObject);

        }
    } else {

        // Else clause for if(!fWksta)
        // This means that workstation services were not
        // started, we need to verify that the host computer
        // is the one they are interested in.

        if ((pObjectInfo->NumComponents != 1) || (!GetComputerName(szCompName, &dwSize))) {
            // We cannot get the computer name so bail
            BAIL_ON_FAILURE(hr);
        }

        // Compare the names before we continue
#ifdef WIN95
        if (_wcsicmp(szCompName, pObjectInfo->ComponentArray[0])) {
#else
        if (CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                szCompName,
                -1,
                pObjectInfo->ComponentArray[0],
                -1
                )  != CSTR_EQUAL ) {
#endif
            // names do not match
            BAIL_ON_FAILURE(hr);
        }

        hr = CWinNTComputer::CreateComputer(
                                 L"WinNT:",
                                 NULL,
                                 pObjectInfo->ComponentArray[0],
                                 ADS_OBJECT_BOUND,
                                 IID_IUnknown,
                                 Credentials,
                                 ppObject
                                 );
        BAIL_ON_FAILURE(hr);

    }

error:

    if(pComputerObjectInfo){
        FreeObjectInfo(pComputerObjectInfo);
    }
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetPrinterObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    01/03/96 Ramv  Created.
//
//----------------------------------------------------------------------------
HRESULT
GetPrinterObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR szADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szDomainName = NULL;
    LPWSTR szServerName = NULL;
    LPWSTR szPrinterName = NULL;
    DWORD  dwParentId = 0;
    LPWSTR szComputerParent[MAX_PATH];
    POBJECTINFO pPrinterObjectInfo = NULL;

    if (!(pObjectInfo->NumComponents == 3 ||pObjectInfo->NumComponents == 2)){

        RRETURN(E_ADS_BAD_PATHNAME);
    }

    // check to see that the printer is a valid one

    hr = ValidatePrinterObject(pObjectInfo, Credentials);

    BAIL_ON_FAILURE(hr);

    dwParentId = WINNT_COMPUTER_ID;

    if(pObjectInfo->NumComponents == 3) {

        hr = BuildParent(pObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szPrinterName= pObjectInfo->ComponentArray[2];

    } else if (pObjectInfo->NumComponents == 2){

        hr = ConstructFullObjectInfo(pObjectInfo,
                                     &pPrinterObjectInfo,
                                     Credentials );

        BAIL_ON_FAILURE(hr);

        hr = BuildParent(pPrinterObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pPrinterObjectInfo->ComponentArray[0];
        szServerName = pPrinterObjectInfo->ComponentArray[1];
        szPrinterName= pPrinterObjectInfo->ComponentArray[2];
    }
    hr = CWinNTPrintQueue::CreatePrintQueue(
                               szADsParent,
                               dwParentId,
                               szDomainName,
                               szServerName,
                               szPrinterName,
                               ADS_OBJECT_BOUND,
                               IID_IUnknown,
                               Credentials,
                               (void **)&pUnknown
                               );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    FreeObjectInfo(pPrinterObjectInfo);
    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }
    *ppObject = NULL;

    FreeObjectInfo(pPrinterObjectInfo);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetServiceObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    01/03/96 Ramv  Created.
//
//----------------------------------------------------------------------------
HRESULT
GetServiceObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR szADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szDomainName = NULL;
    LPWSTR szServerName = NULL;
    LPWSTR szServiceName = NULL;
    DWORD  dwParentId = 0;
    POBJECTINFO pServiceObjectInfo = NULL;

    //
    // check to see that the printer is in a valid server(computer) object
    //

    if(!(pObjectInfo->NumComponents == 3 ||
         pObjectInfo->NumComponents == 2))
    {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = ValidateServiceObject(pObjectInfo, Credentials);
    BAIL_ON_FAILURE(hr);

    dwParentId = WINNT_COMPUTER_ID;

    if(pObjectInfo->NumComponents == 3) {

        hr = BuildParent(pObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szServiceName= pObjectInfo->ComponentArray[2];

        hr = CWinNTService::Create(szADsParent,
                                   szDomainName,
                                   szServerName,
                                   szServiceName,
                                   ADS_OBJECT_BOUND,
                                   IID_IUnknown,
                                   Credentials,
                                   (void **)&pUnknown);
        BAIL_ON_FAILURE(hr);

    }  else if (pObjectInfo->NumComponents == 2) {

        hr = ConstructFullObjectInfo(pObjectInfo,
                                     &pServiceObjectInfo,
                                     Credentials );

        BAIL_ON_FAILURE(hr);

        hr = BuildParent(pServiceObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

        szServerName = pServiceObjectInfo->ComponentArray[1];
        szServiceName= pServiceObjectInfo->ComponentArray[2];

        hr = CWinNTService::Create(szADsParent,
                                   pServiceObjectInfo->ComponentArray[0],
                                   szServerName,
                                   szServiceName,
                                   ADS_OBJECT_BOUND,
                                   IID_IUnknown,
                                   Credentials,
                                   (void **)&pUnknown);
        BAIL_ON_FAILURE(hr);

    }

    *ppObject = pUnknown;
    if(pServiceObjectInfo){
        FreeObjectInfo(pServiceObjectInfo);
    }
    RRETURN(hr);

error:

    if(pServiceObjectInfo){
        FreeObjectInfo(pServiceObjectInfo);
    }
    if (pUnknown) {
        pUnknown->Release();
    }
    *ppObject = NULL;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetFileServiceObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    01/15/96 Ramv  Created.
//
//----------------------------------------------------------------------------

HRESULT
GetFileServiceObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR szADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szDomainName = NULL;
    LPWSTR szServerName = NULL;
    LPWSTR szFileServiceName = NULL;
    DWORD  dwParentId = 0;
    POBJECTINFO pFileServiceObjectInfo = NULL;
    //
    // check to see that the service is in a valid server(computer) object
    //

    if (!(pObjectInfo->NumComponents == 3 || pObjectInfo->NumComponents == 2))
       RRETURN(E_ADS_BAD_PATHNAME);

    hr = ValidateFileServiceObject(pObjectInfo, Credentials);
    BAIL_ON_FAILURE(hr);

    if (pObjectInfo->NumComponents == 3){
        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szFileServiceName= pObjectInfo->ComponentArray[2];

        hr = BuildParent(pObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

    }

    if (pObjectInfo->NumComponents == 2){

        hr = ConstructFullObjectInfo(pObjectInfo,
                                     &pFileServiceObjectInfo,
                                     Credentials );

        BAIL_ON_FAILURE(hr);

        hr = BuildParent(pFileServiceObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pFileServiceObjectInfo->ComponentArray[0];
        szServerName = pFileServiceObjectInfo->ComponentArray[1];
        szFileServiceName= pFileServiceObjectInfo->ComponentArray[2];
    }

    dwParentId = WINNT_COMPUTER_ID;

    if(_tcsicmp(szFileServiceName,TEXT("LanmanServer")) == 0) {
        hr = CWinNTFileService::CreateFileService(szADsParent,
                                                  dwParentId,
                                                  szDomainName,
                                                  szServerName,
                                                  szFileServiceName,
                                                  ADS_OBJECT_BOUND,
                                                  IID_IUnknown,
                                                  Credentials,
                                                  (void **)&pUnknown);
        BAIL_ON_FAILURE(hr);

    }
    else if(_tcsicmp(szFileServiceName,TEXT("FPNW")) == 0) {

        hr = CFPNWFileService::CreateFileService(szADsParent,
                                                 dwParentId,
                                                 szDomainName,
                                                 szServerName,
                                                 szFileServiceName,
                                                 ADS_OBJECT_BOUND,
                                                 IID_IUnknown,
                                                 Credentials,
                                                 (void **)&pUnknown);
        BAIL_ON_FAILURE(hr);
    }

    *ppObject = pUnknown;

    if(pFileServiceObjectInfo){
        FreeObjectInfo(pFileServiceObjectInfo);
    }

    RRETURN(hr);

error:

    if(pFileServiceObjectInfo){
        FreeObjectInfo(pFileServiceObjectInfo);
    }

    if (pUnknown) {
        pUnknown->Release();
    }
    *ppObject = NULL;

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetFileShareObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    01/15/96 Ramv  Created.
//
//----------------------------------------------------------------------------

HRESULT
GetFileShareObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR szADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPTSTR szDomainName = NULL;
    LPTSTR szServerName = NULL;
    LPTSTR szFileServiceName = NULL;
    LPTSTR szFileShareName = NULL;
    DWORD  dwParentId = 0;
    POBJECTINFO pFileShareObjectInfo = NULL;
    WCHAR lpszUncName[MAX_PATH];
    BOOL fRefAdded = FALSE;

    //
    // check to see that the share is in a valid fileservice
    //

    if (!(pObjectInfo->NumComponents == 4 ||
          pObjectInfo->NumComponents == 3)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    // The server is ref'ed in this routine.
    hr = ValidateFileShareObject(pObjectInfo, Credentials);
    BAIL_ON_FAILURE(hr);

    dwParentId = WINNT_SERVICE_ID;

    if(pObjectInfo->NumComponents == 4){

        hr = BuildParent(pObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);

        szServerName = pObjectInfo->ComponentArray[1];
        szFileServiceName= pObjectInfo->ComponentArray[2];
        szFileShareName  = pObjectInfo ->ComponentArray[3];

    } else if (pObjectInfo->NumComponents == 3){

        hr = ConstructFullObjectInfo(pObjectInfo,
                                     &pFileShareObjectInfo,
                                     Credentials );

        BAIL_ON_FAILURE(hr);

        hr = BuildParent(pFileShareObjectInfo, szADsParent);
        BAIL_ON_FAILURE(hr);


        szServerName = pObjectInfo->ComponentArray[0];
        szFileServiceName= pObjectInfo->ComponentArray[1];
        szFileShareName  = pObjectInfo ->ComponentArray[2];
    }


    if(_tcsicmp(szFileServiceName,TEXT("LanmanServer")) == 0){

        hr = CWinNTFileShare::Create(szADsParent,
                                     szServerName,
                                     szFileServiceName,
                                     szFileShareName,
                                     ADS_OBJECT_BOUND,
                                     IID_IUnknown,
                                     Credentials,
                                     (void **)&pUnknown);
        BAIL_ON_FAILURE(hr);
    }
    else {
        //
        // we have validated it already, it *has* to be an FPNW server
        //
        hr = CFPNWFileShare::Create(szADsParent,
                                    szServerName,
                                    szFileServiceName,
                                    szFileShareName,
                                    ADS_OBJECT_BOUND,
                                    IID_IUnknown,
                                    Credentials,
                                    (void **)&pUnknown);
        BAIL_ON_FAILURE(hr);
    }

    *ppObject = pUnknown;

    if(pFileShareObjectInfo){
        FreeObjectInfo(pFileShareObjectInfo);
    }

    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }

    if(pFileShareObjectInfo){
        FreeObjectInfo(pFileShareObjectInfo);
    }

    *ppObject = NULL;

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
// Function:   GetGroupObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetGroupObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szGroupName = NULL;
    DWORD  dwParentId = 0;
    ULONG uGroupType = 0;
    POBJECTINFO pGroupObjectInfo = NULL;

    hr = ValidateGroupObject(
                pObjectInfo,
                &uGroupType,
                &dwParentId,
                Credentials
                );
    BAIL_ON_FAILURE(hr);

    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // could be group in computer or group in domain
        //
        if(dwParentId == WINNT_DOMAIN_ID){

            szDomainName = pObjectInfo->ComponentArray[0];
            szGroupName = pObjectInfo->ComponentArray[1];
            szServerName = NULL;
            hr = BuildParent(pObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

        } else {

            //
            // group in a computer
            //

            hr = ConstructFullObjectInfo(pObjectInfo,
                                         &pGroupObjectInfo,
                                         Credentials );


            if (SUCCEEDED(hr)) {
                hr = BuildParent(pGroupObjectInfo, ADsParent);

                BAIL_ON_FAILURE(hr);

                szDomainName =  pGroupObjectInfo->ComponentArray[0];
                szServerName =  pGroupObjectInfo->ComponentArray[1];
                szGroupName   =  pGroupObjectInfo->ComponentArray[2];

            }
            else if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {
                //
                // We will build the info without the parent
                //
                hr = BuildParent(pObjectInfo, ADsParent);

                BAIL_ON_FAILURE(hr);

                szDomainName =  NULL;
                szServerName =  pObjectInfo->ComponentArray[0];
                szGroupName   = pObjectInfo->ComponentArray[1];

            }

            BAIL_ON_FAILURE(hr);

        }

        break;

    case 3:

        hr = BuildParent(pObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szGroupName = pObjectInfo->ComponentArray[2];
        break;

    }

    hr = CWinNTGroup::CreateGroup(
                          ADsParent,
                          dwParentId,
                          szDomainName,
                          szServerName,
                          szGroupName,
                          uGroupType,
                          ADS_OBJECT_BOUND,
                          IID_IUnknown,
                          Credentials,
                          (void **)&pUnknown
                          );

    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    *ppObject = NULL;

    RRETURN(hr);
}




//+---------------------------------------------------------------------------
// Function:   GetGroupObjectInComputer
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   ramv     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetGroupObjectInComputer(
    LPWSTR pszHostServerName, // pdc name
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials)
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szGroupName = NULL;
    DWORD  dwParentId = WINNT_COMPUTER_ID;
    ULONG uGroupType = 0;
    POBJECTINFO pGroupObjectInfo = NULL;
    WCHAR lpszUncName[MAX_PATH];


    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // group in a computer
        //

        MakeUncName(pObjectInfo->ComponentArray[0],
                    lpszUncName);

        hr = ValidateGlobalGroupObject(
                 lpszUncName,
                 &(pObjectInfo->ComponentArray[1]),
                 Credentials
                 );

        if (SUCCEEDED(hr)) {
            uGroupType = WINNT_GROUP_GLOBAL;

        }else{
            hr = ValidateLocalGroupObject(
                     lpszUncName,
                     &(pObjectInfo->ComponentArray[1]),
                     Credentials
                     );

            BAIL_ON_FAILURE(hr);
            uGroupType = WINNT_GROUP_LOCAL;
        }

        hr = ConstructFullObjectInfo(pObjectInfo,
                                     &pGroupObjectInfo,
                                     Credentials );
        BAIL_ON_FAILURE(hr);

        hr = BuildParent(pGroupObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName =  pGroupObjectInfo->ComponentArray[0];
        szServerName =  pGroupObjectInfo->ComponentArray[1];
        szGroupName   =  pGroupObjectInfo->ComponentArray[2];

        break;

    case 3:

        hr = ValidateComputerParent(pObjectInfo->ComponentArray[0],
                                    pObjectInfo->ComponentArray[1],
                                    Credentials);

        BAIL_ON_FAILURE(hr);

        MakeUncName(
                pObjectInfo->ComponentArray[1],
                lpszUncName
                );

        hr = ValidateGlobalGroupObject(
                        lpszUncName,
                        &(pObjectInfo->ComponentArray[2]),
                        Credentials
                        );

        if (SUCCEEDED(hr)) {
            uGroupType = WINNT_GROUP_GLOBAL;
        } else {
            hr = ValidateLocalGroupObject(
                           lpszUncName,
                           &(pObjectInfo->ComponentArray[2]),
                           Credentials
                           );

            BAIL_ON_FAILURE(hr);
            uGroupType = WINNT_GROUP_LOCAL;
        }

        hr = BuildParent(pObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szGroupName = pObjectInfo->ComponentArray[2];
        break;
    }

    if (uGroupType == WINNT_GROUP_LOCAL) {

        hr = CWinNTGroup::CreateGroup(ADsParent,
                                dwParentId,
                                szDomainName,
                                szServerName,
                                szGroupName,
                                uGroupType,
                                ADS_OBJECT_BOUND,
                                IID_IUnknown,
                                Credentials,
                                (void **)&pUnknown
                                );


    }else {

        hr = CWinNTGroup::CreateGroup(ADsParent,
                                dwParentId,
                                szDomainName,
                                szServerName,
                                szGroupName,
                                uGroupType,
                                ADS_OBJECT_BOUND,
                                IID_IUnknown,
                                Credentials,
                                (void **)&pUnknown
                                );


    }

    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    *ppObject = NULL;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetGroupObjectInDomain
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    8-8-96 Ramv     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetGroupObjectInDomain(
    LPWSTR pszHostServerName,
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szGroupName = NULL;
    DWORD  dwParentId = WINNT_DOMAIN_ID;
    ULONG uGroupType = 0;
    BOOL fRefAdded = FALSE;

    // At this point the host server name has a \\ prepended
    // so we need to get rid of it.
    hr = Credentials.RefServer(pszHostServerName+2);
    if (SUCCEEDED(hr)) {
        fRefAdded = TRUE;
    }

    hr = ValidateGlobalGroupObject(
             pszHostServerName,
             &(pObjectInfo->ComponentArray[1]),
             Credentials
             );

    if (FAILED(hr)) {
        hr = ValidateLocalGroupObject(
                    pszHostServerName,
                    &(pObjectInfo->ComponentArray[1]),
                    Credentials
                    );

        // DeRef if ref added, no recovery possible on failed deref
        if (fRefAdded) {
            Credentials.DeRefServer();
            fRefAdded = FALSE;
        }

        BAIL_ON_FAILURE(hr);
        uGroupType = WINNT_GROUP_LOCAL;
    }else {

        uGroupType = WINNT_GROUP_GLOBAL;
    }

    // DeRef if ref added, no recovery possible on failed deref
    if (fRefAdded) {
        Credentials.DeRefServer();
        fRefAdded = FALSE;
    }

    szDomainName = pObjectInfo->ComponentArray[0];
    szGroupName = pObjectInfo->ComponentArray[1];
    szServerName = NULL;
    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    if (uGroupType==WINNT_GROUP_LOCAL) {

        hr = CWinNTGroup::CreateGroup(
                            ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szGroupName,
                            uGroupType,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
    } else {

        hr = CWinNTGroup::CreateGroup(ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szGroupName,
                            uGroupType,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
    }
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }

    *ppObject = NULL;

    RRETURN(hr);
}




//+---------------------------------------------------------------------------
// Function:   GetSchemaObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSchemaObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;

    if (pObjectInfo->NumComponents != 2)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CWinNTSchema::CreateSchema( ADsParent,
                                     pObjectInfo->ComponentArray[1],
                                     ADS_OBJECT_BOUND,
                                     IID_IUnknown,
                                     Credentials,
                                     (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}







//+---------------------------------------------------------------------------
// Function:   GetClassObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetClassObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD i;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Look for the given class name
    //

    for ( i = 0; i < g_cWinNTClasses; i++ )
    {
         if ( _wcsicmp( g_aWinNTClasses[i].bstrName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( i == g_cWinNTClasses )
    {
        // Class name not found, return error

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Class name found, create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CWinNTClass::CreateClass( ADsParent,
                                   &g_aWinNTClasses[i],
                                   ADS_OBJECT_BOUND,
                                   IID_IUnknown,
                                   Credentials,
                                   (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetSyntaxObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSyntaxObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD i;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Look for the given syntax name
    //

    for ( i = 0; i < g_cWinNTSyntax; i++ )
    {
         if ( _wcsicmp( g_aWinNTSyntax[i].bstrName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( i == g_cWinNTSyntax )
    {
        // Syntax name not found, return error

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Syntax name found, create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CWinNTSyntax::CreateSyntax( ADsParent,
                                     &(g_aWinNTSyntax[i]),
                                     ADS_OBJECT_BOUND,
                                     IID_IUnknown,
                                     Credentials,
                                     (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetPropertyObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetPropertyObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials 
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    WCHAR ADsGrandParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD nClass, nProp;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We found the specified functional set, now see if we can locate
    // the given property name
    //

    for ( nProp = 0; nProp < g_cWinNTProperties; nProp++ )
    {
         if ( _wcsicmp(g_aWinNTProperties[nProp].szPropertyName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( nProp == g_cWinNTProperties )
    {
        // Return error because the given property name is not found

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }


    //
    // Property name is found, so create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);


    hr = CWinNTProperty::CreateProperty(
                             ADsParent,
                             &(g_aWinNTProperties[nProp]),
                             ADS_OBJECT_BOUND,
                             IID_IUnknown,
                             Credentials,
                             (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
HeuristicGetObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    WCHAR szHostServerName[MAX_PATH];
    DWORD dwElementType;
    WCHAR szName[MAX_PATH];
    WCHAR szSAMName[MAX_ADS_PATH];
    WCHAR lpszUncName[MAX_PATH];

    szSAMName[0] = L'\0';
    //
    // Case 0: Zero components - must be a namespace object
    //

    if (pObjectInfo->NumComponents == 0) {
        RRETURN(GetNamespaceObject(pObjectInfo, ppObject, Credentials));
    }

    //
    // Case 1: Single component - must be a domain object or
    // computer object
    //

    if (pObjectInfo->NumComponents == 1) {

        //
        // hr = WinNTGetCachedObject(type, hit/miss, pdcname/domain name)
        //
        // if (succeeded...
        // switch(type) .... call the appropriate
        // GetDomain or GetWorkGroup or GetComputer
        //

        hr = WinNTGetCachedName(
                 pObjectInfo->ComponentArray[0],
                 &dwElementType,
                 szHostServerName,
                 szSAMName,
                 Credentials
                 );

        BAIL_IF_ERROR(hr);

        // update the name to the one on SAM
        if (szSAMName[0] != L'\0') {
            FreeADsStr(pObjectInfo->ComponentArray[0]);
            pObjectInfo->ComponentArray[0] = AllocADsStr(szSAMName);
        }

        if (!pObjectInfo->ComponentArray[0]) {
            BAIL_IF_ERROR(hr = E_OUTOFMEMORY);
        }

        switch(dwElementType) {

        case DOMAIN_ENTRY_TYPE:
            hr = GetDomainObject(pObjectInfo, ppObject, Credentials);
            break;

        case COMPUTER_ENTRY_TYPE:
            hr = GetComputerObject(pObjectInfo, ppObject, Credentials);
            break;

        default:
            hr = GetWorkGroupObject(pObjectInfo, ppObject, Credentials);
            break;

        }
        goto cleanup;

    }

    //
    // Case 2: Two components - could be user, group, computer,
    // or any one of the computer's sub-objects.
    //


    if (pObjectInfo->NumComponents == 2) {

        hr = GetSchemaObject(pObjectInfo, ppObject, Credentials);

        if(SUCCEEDED(hr)){
            goto cleanup;
        }
        if(FAILED(hr)) {
            //
            // try doing a WinNTGetCachedDCName first
            // and if it goes through, then we have objects such as
            // user,group,computer in domain, otherwise it is the
            // computer case or workgroup case
            //

            // WinNtGetCachedObject will directly tell us to proceed or
            // not

            hr = WinNTGetCachedName(pObjectInfo->ComponentArray[0],
                                    &dwElementType,
                                    szHostServerName,
                                    szSAMName,
                                    Credentials );

            BAIL_IF_ERROR(hr);

            // Again we do not have to worry about the case of the
            // object name, it is handled by the GetObject calls

            switch(dwElementType) {

            case DOMAIN_ENTRY_TYPE:

                hr = GetUserObjectInDomain(szHostServerName,
                                           pObjectInfo,
                                           ppObject,
                                           Credentials);

                if (FAILED(hr)) {
                    hr = GetGroupObjectInDomain(szHostServerName,
                                                pObjectInfo,
                                                ppObject,
                                                Credentials);
                }

                if (FAILED(hr)) {
                    hr = GetComputerObject(pObjectInfo, ppObject, Credentials);
                }

                goto cleanup;

            case COMPUTER_ENTRY_TYPE:

                hr = GetPrinterObject(pObjectInfo, ppObject, Credentials);
                if (FAILED(hr)) {
                    hr = GetFileServiceObject(
                        pObjectInfo,
                        ppObject,
                        Credentials
                        );
                }
                if (FAILED(hr)) {
                    hr = GetServiceObject(pObjectInfo, ppObject, Credentials);
                }
                if(FAILED(hr)){
                    hr = GetUserObjectInComputer(
                             pObjectInfo->ComponentArray[0],
                             pObjectInfo,
                             ppObject,
                             Credentials
                             );
                }
                if (FAILED(hr)) {
                    hr = GetGroupObjectInComputer(
                             pObjectInfo->ComponentArray[0],
                             pObjectInfo,
                             ppObject,
                             Credentials
                             );
                }
                goto cleanup;

            case WORKGROUP_ENTRY_TYPE:

                hr = GetComputerObject(pObjectInfo, ppObject, Credentials);
                if (FAILED(hr)) {
                    if (hr == HRESULT_FROM_WIN32(NERR_BadTransactConfig)) {
                        // In this case I want to mask the error
                        // as it means it could not find the object
                        hr = E_ADS_UNKNOWN_OBJECT;
                    }
                }
                goto cleanup;

            default:
                hr = E_ADS_UNKNOWN_OBJECT;
                goto cleanup;

            }

        }
    } /* NumComponents == 2 */

    //
    // Case 3: Three components - could be user, group, printer,  fileservice
    // or service or fileshare for computer in a workgroup environment.
    //


    if (pObjectInfo->NumComponents == 3) {

        if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) == 0 ){
            hr = GetClassObject(pObjectInfo, ppObject, Credentials);

            if (FAILED(hr)) {

                hr = GetPropertyObject(pObjectInfo, ppObject, Credentials);
            }

            if (FAILED(hr)) {
                hr = GetSyntaxObject(pObjectInfo, ppObject, Credentials);
            }
        }
        else{
            hr = GetUserObjectInComputer(pObjectInfo->ComponentArray[1],
                                         pObjectInfo,
                                         ppObject,
                                         Credentials);

            if (FAILED(hr)) {
                hr = GetGroupObjectInComputer(pObjectInfo->ComponentArray[1],
                                              pObjectInfo,
                                              ppObject,
                                              Credentials);
            }

            if(FAILED(hr)){
                hr = GetPrinterObject(pObjectInfo, ppObject, Credentials);
            }

            if (FAILED(hr)) {
                hr = GetFileServiceObject(pObjectInfo, ppObject, Credentials);
            }

            if (FAILED(hr)) {
                hr = GetServiceObject(pObjectInfo, ppObject, Credentials);
            }

            if (FAILED(hr)) {
                hr = GetFileShareObject(pObjectInfo, ppObject, Credentials);
            }

        }
        if(FAILED(hr) ){
            RRETURN(hr);
        }
        else{
            RRETURN(S_OK);
        }
    }

    if (pObjectInfo->NumComponents == 4) {

        hr = GetFileShareObject(pObjectInfo, ppObject, Credentials);

        if(FAILED(hr)){
            RRETURN(hr);
        }
        else{
            RRETURN(S_OK);
        }

    }
    RRETURN (E_ADS_UNKNOWN_OBJECT);

cleanup:

    if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {

        //
        // There is a very good chance that this is a case
        // where they are trying to work on the local machine
        // when there are no workstation services. Note that this
        // means that a fully qualified name was not given.
        //
        hr = HeuristicGetObjectNoWksta(
                 pObjectInfo,
                 ppObject,
                 Credentials
                 );

    }

    //
    // Propagate the error code which we have rather than
    // mask it and return information of little value
    //
    if (FAILED(hr)) {

        // the error code NERR_BadTransactConfig means that the
        // object did not exist, we want to mask just that ecode
        if (hr == HRESULT_FROM_WIN32(NERR_BadTransactConfig)) {
            hr = E_ADS_UNKNOWN_OBJECT;
        }

        RRETURN(hr);

    } else {
        RRETURN(S_OK);
    }
}




//+---------------------------------------------------------------------------
// Function: HeuristicGetObjectNoWksta
//
// Synopsis: Tries to locate the object on local machine when there are no
//          workstation services. This will happen in a minimum install of NT.
//
// Arguments: POBJECTINFO -> data about object being located.
//            LPVOID      -> Object to be returned in this arg.
//            Credentials -> Credentials blob.
//
// Returns: Either S_OK or HR_From_Win32(NERR_WkstaNotStarted)
//
// Modifies:
//
// History:    08-03-98   AjayR     Created.
//
//----------------------------------------------------------------------------
HRESULT
HeuristicGetObjectNoWksta(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    HRESULT hrNoWksta = HRESULT_FROM_WIN32(NERR_WkstaNotStarted);
    WCHAR szHostServerName[MAX_PATH];
    DWORD dwElementType;
    WCHAR szName[MAX_PATH];
    WCHAR szSAMName[MAX_ADS_PATH];
    WCHAR lpszUncName[MAX_PATH];

    szSAMName[0] = L'\0';

    //
    // Case 0: Zero components - Should no be hit here.
    //

    if (pObjectInfo->NumComponents == 0) {
        RRETURN(hrNoWksta);
    }

    //
    // Case 1: Single component - Can only be a computer object
    //

    if (pObjectInfo->NumComponents == 1) {

        hr = GetComputerObject(pObjectInfo, ppObject, Credentials);
        goto cleanup;

    }

    //
    // Case 2: Two components - could be user or group for now.
    // Other possible objects - TBD.
    //


    if (pObjectInfo->NumComponents == 2) {


        hr = GetPrinterObject(pObjectInfo, ppObject, Credentials);

        if (FAILED(hr)) {
            hr = GetFileServiceObject(
                     pObjectInfo,
                     ppObject,
                     Credentials
                     );
                }

        if (FAILED(hr)) {
            hr = GetServiceObject(pObjectInfo, ppObject, Credentials);
        }

        if(FAILED(hr)){
            hr = GetUserObject(
                     pObjectInfo,
                     ppObject,
                     Credentials
                     );
        }
        if (FAILED(hr)) {
            hr = GetLocalGroupObject(
                     pObjectInfo,
                     ppObject,
                     Credentials
                     );
        }
        goto cleanup;

    } /* NumComponents == 2 */

    //
    // Case 3 or more : Three or more components - not possible
    //


    if (pObjectInfo->NumComponents > 2) {

        RRETURN(hrNoWksta);

    }

    RRETURN (E_ADS_UNKNOWN_OBJECT);

cleanup:
    //
    // Propagate the error code which we have rather than
    // mask it and return information of little value
    //
    if (FAILED(hr)) {
        // the error code NERR_BadTransactConfig means that the
        // object did not exist, we want to mask just that ecode
        if (hr == HRESULT_FROM_WIN32(NERR_BadTransactConfig)) {
            hr = E_ADS_UNKNOWN_OBJECT;
        }

        RRETURN(hr);

    } else {
        RRETURN(S_OK);
    }
}



HRESULT
BuildParent(
    POBJECTINFO pObjectInfo,
    LPWSTR szBuffer
    )
{
    DWORD i = 0;
    DWORD dwLen = 0;


    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer, L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents - 1) {

        dwLen = wcslen(pObjectInfo->ProviderName) + 3 + 
                wcslen(pObjectInfo->DisplayComponentArray[0]);
        if(dwLen >= MAX_ADS_PATH) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->DisplayComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents - 1); i++) {
            dwLen += (1 + wcslen(pObjectInfo->DisplayComponentArray[i]));
            if(dwLen >= MAX_ADS_PATH) {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->DisplayComponentArray[i]);
        }
    }
    RRETURN(S_OK);
}

HRESULT
BuildGrandParent(
    POBJECTINFO pObjectInfo,
    LPWSTR szBuffer
    )
{
    DWORD i = 0;

    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer, L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents - 2) {

        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->ComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents - 2); i++) {
            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->ComponentArray[i]);
        }
    }

    RRETURN(S_OK);
}


HRESULT
BuildADsPath(
    POBJECTINFO pObjectInfo,
    LPWSTR szBuffer
    )
{
    DWORD i = 0;

    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer, L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents) {

        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->DisplayComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents); i++) {
            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->DisplayComponentArray[i]);
        }
    }
    RRETURN(S_OK);
}



HRESULT
ValidateUserObject(
    POBJECTINFO pObjectInfo,
    PDWORD  pdwParentId,
    CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    LPUSER_INFO_20 lpUI = NULL;
    HRESULT hr;
    WCHAR lpszUncName[MAX_PATH];
    NET_API_STATUS nasStatus;
    WCHAR szSAMName[MAX_PATH];
    BOOL fRefAdded = FALSE;
    LPUSER_INFO_0 lpUI_0 = NULL;
    DWORD dwLevelUsed = 20;
    WCHAR szCompName[MAX_PATH];
    DWORD dwSize = MAX_PATH;

    szSAMName[0] = L'\0';

    switch (pObjectInfo->NumComponents) {
    case 2:

        //
        // if 2 components then either it is user in computer
        // or user in domain.

        hr = WinNTGetCachedDCName(
                        pObjectInfo->ComponentArray[0],
                        szHostServerName,
                        Credentials.GetFlags()
                        );


        if(SUCCEEDED(hr)){

            // Need to ref the server, note that RefServer
            // checks if the credentials are non null
            // We are not concerned about any error as we may
            // still succeed with default credentials.
            // The +2 is to skip the \\ at the head.
            hr = Credentials.RefServer(szHostServerName+2);
            if (SUCCEEDED(hr)) {
                fRefAdded = TRUE;
            }

            nasStatus = NetUserGetInfo(szHostServerName,
                                       pObjectInfo->ComponentArray[1],
                                       20,
                                       (LPBYTE *)&lpUI);
            //
            // This code is here because Level 20 reads the flags
            // and if you accessed WinNT://ntdev/foo with Redmond\foo
            // credentials, it will fail. This allow a bind but the
            // GetInfo will fail.
            //
            if (nasStatus == ERROR_ACCESS_DENIED) {
                // try and drop down to level 0 as that may work

                dwLevelUsed = 0;
                nasStatus = NetUserGetInfo(
                                szHostServerName,
                                pObjectInfo->ComponentArray[1],
                                0,
                                (LPBYTE *)&lpUI_0
                                );
            }

            // DeRef if ref added, no recovery possible on failed deref
            if (fRefAdded) {
                Credentials.DeRefServer();
                fRefAdded = FALSE;
            }

            hr = HRESULT_FROM_WIN32(nasStatus);

            BAIL_ON_FAILURE(hr);

            // Need to use the name returned by the call as opposed
            // to the name given in the ADsPath
            if (dwLevelUsed == 20 ) {
                if (pObjectInfo->ComponentArray[1] && lpUI->usri20_name) {
                    FreeADsStr(pObjectInfo->ComponentArray[1]);
                    pObjectInfo->ComponentArray[1]
                        = AllocADsStr(lpUI->usri20_name);
                }

                if (!pObjectInfo->ComponentArray[1])
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            *pdwParentId = WINNT_DOMAIN_ID;
        }

        //
        // if we are here with hr != S_OK it could be that we have
        // user in a  computer.
        //

        if(FAILED(hr)){
            hr = ValidateComputerParent(
                     NULL,
                     pObjectInfo->ComponentArray[0],
                     Credentials
                     );

            if (SUCCEEDED(hr)) {

                // Need to ref the server on which the object lives
                // Note that RefServer checks if Credentials are null.
                // Again, we are not concerned about any errors as we
                // will drop down to default credentials automatically.

                hr = Credentials.RefServer(pObjectInfo->ComponentArray[0]);
                if (SUCCEEDED(hr)) {
                    fRefAdded = TRUE;
                }

                MakeUncName(pObjectInfo->ComponentArray[0],
                            lpszUncName);

                nasStatus = NetUserGetInfo(lpszUncName,
                                           pObjectInfo->ComponentArray[1],
                                           20,
                                           (LPBYTE *)&lpUI);

                // DeRef if ref added, no recovery possible on failed deref
                if (fRefAdded) {
                    Credentials.DeRefServer();
                    fRefAdded = FALSE;
                }
                hr = HRESULT_FROM_WIN32(nasStatus);
                BAIL_ON_FAILURE(hr);

                // Need to use the name returned by the call as opposed
                // to the name given in the ADsPath
                if (pObjectInfo->ComponentArray[1] && lpUI->usri20_name) {
                    FreeADsStr(pObjectInfo->ComponentArray[1]);
                    pObjectInfo->ComponentArray[1]
                        = AllocADsStr(lpUI->usri20_name);
                }

                if (!pObjectInfo->ComponentArray[1])
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

                *pdwParentId = WINNT_COMPUTER_ID;
            }
            else if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {

                //
                // Need to see if the problem was not workstation
                // services in which case we need to still try and
                // locate user if the comptuer name matches.
                //

                if (!GetComputerName(szCompName, &dwSize)) {
                    //
                    // We could not get the computer name so bail
                    //
                    BAIL_ON_FAILURE(hr);
                }

                //
                // Test the name before continuing.
                //
#ifdef WIN95
                if (_wcsicmp(szCompName, pObjectInfo->ComponentArray[0])) {
#else
                if (CompareStringW(
                        LOCALE_SYSTEM_DEFAULT,
                        NORM_IGNORECASE,
                        szCompName,
                        -1,
                        pObjectInfo->ComponentArray[0],
                        -1
                        ) != CSTR_EQUAL ) {
#endif
                    // names do not match
                    BAIL_ON_FAILURE(hr);
                }

                //
                // Valid computer name, so we can try and check for user
                //

                MakeUncName(pObjectInfo->ComponentArray[0], lpszUncName);

                nasStatus = NetUserGetInfo(
                                lpszUncName,
                                pObjectInfo->ComponentArray[1],
                                20,
                                (LPBYTE *)&lpUI
                                );

                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));

                *pdwParentId = WINNT_COMPUTER_ID;

            }
        }

        BAIL_ON_FAILURE(hr);

        break;

    case 3:

        //
        // user in domain\computer or user in workgroup\computer
        //



        hr = ValidateComputerParent(
                 pObjectInfo->ComponentArray[0],
                 pObjectInfo->ComponentArray[1],
                 Credentials
                 );
        BAIL_ON_FAILURE(hr);

        // Again we need to ref the server

        hr = Credentials.RefServer(pObjectInfo->ComponentArray[1]);
        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        MakeUncName(pObjectInfo->ComponentArray[1],
                    lpszUncName);

        nasStatus = NetUserGetInfo(lpszUncName,
                                   pObjectInfo->ComponentArray[2],
                                   20,
                                   (LPBYTE *)&lpUI);

        // DeRef if ref added, no recovery possible on failed deref
        if (fRefAdded) {
            Credentials.DeRefServer();
            fRefAdded = FALSE;
        }
        hr = HRESULT_FROM_WIN32(nasStatus);
        BAIL_ON_FAILURE(hr);

        // Need to use the name returned by the call as opposed
        // to the name given in the ADsPath
        if (pObjectInfo->ComponentArray[2] && lpUI->usri20_name) {
            FreeADsStr(pObjectInfo->ComponentArray[2]);
            pObjectInfo->ComponentArray[2]
                = AllocADsStr(lpUI->usri20_name);
        }

        if (!pObjectInfo->ComponentArray[2])
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        *pdwParentId = WINNT_COMPUTER_ID;
        break;


    default:
        RRETURN(E_ADS_BAD_PATHNAME);
    }


  error:
    if (lpUI) {
        NetApiBufferFree((LPBYTE)lpUI);
    }

    if (lpUI_0) {
        NetApiBufferFree((LPBYTE)lpUI_0);
    }

    RRETURN(hr);

}



HRESULT
ValidateComputerParent(
    LPWSTR pszDomainName,
    LPWSTR pszComputerName,
    CWinNTCredentials& Credentials
    )

{
    HRESULT hr;
    NET_API_STATUS nasStatus;
    WCHAR szName[MAX_PATH];
    WCHAR szSAMName[MAX_PATH];
    WCHAR szCompName[MAX_PATH];
    DWORD dwSize = MAX_PATH;

    if(pszDomainName && (wcslen(pszDomainName) >= MAX_PATH))
    {
        hr = E_FAIL;
        goto error;
    }

    szSAMName[0] = szName[0] = L'\0';

    if(pszDomainName)
    {
        wcscpy(szName, pszDomainName);
    }

    hr = WinNTGetCachedComputerName(
             pszComputerName,
             szName,
             szSAMName,
             Credentials
             );

    if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {

        //
        // We want to see if the computer being validated is
        // the current host.
        //
        if (!GetComputerName(szCompName, &dwSize)
#ifdef WIN95
            || (_wcsicmp(szCompName, pszComputerName))
#else
            || (CompareStringW(
                    LOCALE_SYSTEM_DEFAULT,
                    NORM_IGNORECASE,
                    szCompName,
                    -1,
                    pszComputerName,
                    -1
                    ) != CSTR_EQUAL )
#endif
            )
            BAIL_ON_FAILURE(hr);

        hr = S_OK;

    }
    BAIL_ON_FAILURE(hr);


    if(pszDomainName == NULL){
        //
        // we are dealing with a case where we aren't supplied the
        // computer's parent. Just validate the computer
        //
        hr = S_OK;
        goto error;

    } else {

#ifdef WIN95


        //
        // No NetpNameCompare for Win9x
        //
        if (!_wcsicmp(pszDomainName, szName)) {
#else
        if ((CompareStringW(
                 LOCALE_SYSTEM_DEFAULT,
                 NORM_IGNORECASE,
                 pszDomainName,
                 -1,
                 szName,
                 -1
                 ) == CSTR_EQUAL )
             || (NetpNameCompare(
                     NULL,
                     pszDomainName,
                     szName,
                     NAMETYPE_DOMAIN,
                     0
                     ) == 0 )
            ) {
#endif
            hr = S_OK;
        }else {
            hr = E_ADS_BAD_PATHNAME;
        }
    }

error:
    RRETURN(hr);
}

// Overloaded ValidateComputerParent function.
// This is used when the case of pszComputerName on the SAM
// databsae is needed.
HRESULT
ValidateComputerParent(
    LPWSTR pszDomainName,
    LPWSTR pszComputerName,
    LPWSTR pszSAMName,
    CWinNTCredentials& Credentials
    )

{
    HRESULT hr;
    NET_API_STATUS nasStatus;
    WCHAR szName[MAX_PATH];
    WCHAR szSAMName[MAX_PATH];

    if(pszDomainName && wcslen(pszDomainName) >= MAX_PATH)
    {
        hr = E_FAIL;
        goto error;
    }

    szSAMName[0] = szName[0] = L'\0';

    if(pszDomainName)
    {
        wcscpy(szName, pszDomainName);
    }

    hr = WinNTGetCachedComputerName(
             pszComputerName,
             szName,
             szSAMName,
             Credentials
             );

    BAIL_ON_FAILURE(hr);

    if (szSAMName[0] != L'\0') {
        wcscpy(pszSAMName, szSAMName);
    }


    if(pszDomainName == NULL){
        //
        // we are dealing with a case where we aren't supplied the
        // computer's parent. Just validate the computer
        //
        hr = S_OK;
        goto error;

    } else {


#ifdef WIN95
        //
        // No NetpNameCompare for Win9x
        //
        if (!_wcsicmp(pszDomainName, szName)) {
#else
        if ((CompareStringW(
                LOCALE_SYSTEM_DEFAULT,
                NORM_IGNORECASE,
                pszDomainName,
                -1,
                szName,
                -1
                ) == CSTR_EQUAL ) 
            || (NetpNameCompare(
                     NULL,
                     pszDomainName,
                     szName,
                     NAMETYPE_DOMAIN,
                     0
                     ) == 0 )
            ) {
#endif

            hr = S_OK;
        }else {

            hr = E_FAIL;
        }
    }

error:
    RRETURN(hr);
}


HRESULT
ValidateGroupObject(
    POBJECTINFO pObjectInfo,
    PULONG puGroupType,
    PDWORD pdwParentId,
    CWinNTCredentials& Credentials
    )
{
    WCHAR szHostServerName[MAX_PATH];
    LPGROUP_INFO_0 lpGI = NULL;
    HRESULT hr;
    WCHAR lpszUncName[MAX_PATH];
    NET_API_STATUS nasStatus;
    ULONG uGroupType = 0L;
    WCHAR szSAMName[MAX_PATH];

    szSAMName[0] = L'\0';

    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // if 2 components then either it is a group in computer
        // or group in domain.
        //

        hr = WinNTGetCachedDCName(
                    pObjectInfo->ComponentArray[0],
                    szHostServerName,
                    Credentials.GetFlags()
                    );

        if(SUCCEEDED(hr)){
            //
            // must be a group in a domain
            //
            *pdwParentId = WINNT_DOMAIN_ID;

            hr = ValidateGlobalGroupObject(
                     szHostServerName,
                     &(pObjectInfo->ComponentArray[1]),
                     Credentials
                     );

            if (FAILED(hr)) {
                hr = ValidateLocalGroupObject(
                         szHostServerName,
                         &(pObjectInfo->ComponentArray[1]),
                         Credentials
                         );

                if(SUCCEEDED(hr)){
                    uGroupType = WINNT_GROUP_LOCAL;
                }

            }else{
                uGroupType = WINNT_GROUP_GLOBAL;
            }
        }

        if(FAILED(hr)){
            //
            // potentially a group in a computer
            //

            hr = ValidateComputerParent(NULL,
                                        pObjectInfo->ComponentArray[0],
                                        Credentials);
            BAIL_ON_FAILURE(hr);

            //
            // group in a computer
            //
            *pdwParentId = WINNT_COMPUTER_ID;

            MakeUncName(pObjectInfo->ComponentArray[0],
                        lpszUncName);

            hr = ValidateGlobalGroupObject(
                     lpszUncName,
                     &(pObjectInfo->ComponentArray[1]),
                     Credentials
                     );

            if (FAILED(hr)) {

                hr = ValidateLocalGroupObject(
                         lpszUncName,
                         &(pObjectInfo->ComponentArray[1]),
                         Credentials
                         );

                BAIL_ON_FAILURE(hr);
                uGroupType = WINNT_GROUP_LOCAL;

            }else{
                uGroupType = WINNT_GROUP_GLOBAL;
            }
        }
        break;

        case 3:

        //
        // if there are 3 components then we must have parentid
        // WINNT_COMPUTER_ID
        //
        *pdwParentId = WINNT_COMPUTER_ID;

        hr = ValidateComputerParent(pObjectInfo->ComponentArray[0],
                                    pObjectInfo->ComponentArray[1],
                                    Credentials);

        BAIL_ON_FAILURE(hr);

        MakeUncName(
                pObjectInfo->ComponentArray[1],
                lpszUncName
                );

        hr = ValidateGlobalGroupObject(
                        lpszUncName,
                        &(pObjectInfo->ComponentArray[2]),
                        Credentials
                        );

        if (FAILED(hr)) {

            hr = ValidateLocalGroupObject(
                           lpszUncName,
                           &(pObjectInfo->ComponentArray[2]),
                           Credentials
                           );

            BAIL_ON_FAILURE(hr);
            uGroupType = WINNT_GROUP_LOCAL;

        }else{
            uGroupType = WINNT_GROUP_GLOBAL;
        }
        break;


    default:
        RRETURN(E_ADS_BAD_PATHNAME);
    }


error:
    if (lpGI) {
        NetApiBufferFree((LPBYTE)lpGI);
    }

    *puGroupType = uGroupType;
    RRETURN(hr);

}



HRESULT
ValidatePrinterObject(
    POBJECTINFO pObjectInfo,
    CWinNTCredentials& Credentials
    )
{
    LPTSTR szDomainName = NULL;
    LPTSTR szServerName = NULL;
    LPTSTR szPrinterName = NULL;
    WCHAR szPrintObjectName[MAX_PATH];
    HRESULT hr = E_ADS_UNKNOWN_OBJECT;
    BOOL fStatus = FALSE;
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
    BOOLEAN fRefAdded = FALSE;

    if (!(pObjectInfo->NumComponents == 3 ||pObjectInfo->NumComponents == 2)){

        RRETURN(E_ADS_BAD_PATHNAME);
    }

    if(pObjectInfo->NumComponents == 3){
        //
        // printer in domain\computer or workgroup\computer
        //
        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szPrinterName = pObjectInfo->ComponentArray[2];

        hr = ValidateComputerParent(szDomainName,
                                    szServerName,
                                    Credentials);
        BAIL_IF_ERROR(hr);

    } else if ( pObjectInfo-> NumComponents == 2 ){

        szServerName = pObjectInfo->ComponentArray[0];
        szPrinterName = pObjectInfo->ComponentArray[1];
    }

    MakeUncName(szServerName, szPrintObjectName);
    wcscat(szPrintObjectName, TEXT("\\"));
    wcscat(szPrintObjectName, szPrinterName);


    //
    // validate the printer in computer now
    //

    hr = Credentials.RefServer(szServerName);

    if (SUCCEEDED(hr)) {
        fRefAdded = TRUE;
    }

    fStatus = OpenPrinter(szPrintObjectName,
                          &hPrinter,
                          &PrinterDefaults);

    if(!fStatus){
        hr = HRESULT_FROM_WIN32(GetLastError());
    } else {
        hr = S_OK;
    }



cleanup:
    if(hPrinter){
        ClosePrinter(hPrinter);
    }

    if (fRefAdded) {
        Credentials.DeRefServer();
        fRefAdded = FALSE;
    }
    
    RRETURN(hr);

}


HRESULT
ValidateServiceObject(
    POBJECTINFO pObjectInfo,
    CWinNTCredentials& Credentials
    )
{
    LPTSTR szDomainName = NULL;
    LPTSTR szServerName = NULL;
    LPTSTR szServiceName = NULL;
    SC_HANDLE schSCMHandle=NULL;
    SC_HANDLE schServiceHandle=NULL;
    HRESULT hr = S_OK;
    BOOLEAN fRefAdded = FALSE;

    if(!(pObjectInfo->NumComponents == 3 ||
         pObjectInfo->NumComponents == 2))
    {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    if(pObjectInfo->NumComponents == 3){

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szServiceName = pObjectInfo->ComponentArray[2];

        //
        // First check to see if the computer is in the right domain
        //

        hr = ValidateComputerParent(
                 szDomainName,
                 szServerName,
                 Credentials
                 );
        BAIL_ON_FAILURE(hr);

    } else if (pObjectInfo->NumComponents == 2){
        szServerName = pObjectInfo->ComponentArray[0];
        szServiceName = pObjectInfo->ComponentArray[1];
    }

    //
    // check to see if the service is valid by opening the active services
    // database on the server
    //
    hr = Credentials.RefServer(szServerName);

    if (SUCCEEDED(hr)) {
        fRefAdded = TRUE;
    }

    //
    // Open the Service Control Manager.
    //

    schSCMHandle = OpenSCManager(szServerName,
                                 NULL,
                                 GENERIC_READ);

    if (schSCMHandle == NULL)  {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    //
    // Need to ref the server before opening the service
    //

    //
    // try to open the service
    //

    schServiceHandle = OpenService(schSCMHandle,
                                   szServiceName,
                                   GENERIC_READ);

    if(schServiceHandle == NULL)  {

        CloseServiceHandle(schSCMHandle);
        schSCMHandle = NULL;
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

    CloseServiceHandle(schServiceHandle);
    CloseServiceHandle(schSCMHandle);

error:

    if (fRefAdded) {
        Credentials.DeRefServer();
        fRefAdded = FALSE;
    }
    RRETURN(hr);
}

HRESULT GetPrinterFromPath(LPTSTR *pszPrinter, LPWSTR szPathName)
{
    //
    // If passed an empty string, it returns an empty string
    //

    LPTSTR szRetval;

    *pszPrinter = NULL;
    szRetval = szPathName;

    ADsAssert(szPathName);

    while(!(*szRetval==L'\0' || *szRetval==L'\\')){
        szRetval++;
    }

    if(*szRetval != L'\\'){
        RRETURN(E_FAIL);
    }
    szRetval++;
    *pszPrinter = szRetval;
    RRETURN(S_OK);
}

HRESULT
ValidateComputerObject(
    POBJECTINFO pObjectInfo,
    CWinNTCredentials& Credentials)
{
    HRESULT hr;
    WCHAR szSAMName[MAX_PATH];

    szSAMName[0] = L'\0';

    if(!(pObjectInfo->NumComponents == 2 ||
         pObjectInfo->NumComponents == 1)){

        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

    if(pObjectInfo->NumComponents == 2){

        hr = ValidateComputerParent(
                 pObjectInfo->ComponentArray[0],
                 pObjectInfo->ComponentArray[1],
                 szSAMName,
                 Credentials
                 );
        BAIL_ON_FAILURE(hr);

        if (szSAMName[0] != L'\0') {
            FreeADsStr(pObjectInfo->ComponentArray[1]);
            pObjectInfo->ComponentArray[1] = AllocADsStr(szSAMName);
            if (!pObjectInfo->ComponentArray[1]) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }


    } else {

        hr = ValidateComputerParent(
                 NULL,
                 pObjectInfo->ComponentArray[0],
                 szSAMName,
                 Credentials
                 );
        BAIL_ON_FAILURE(hr);

        if (szSAMName[0] != L'\0') {
            FreeADsStr(pObjectInfo->ComponentArray[0]);
            pObjectInfo->ComponentArray[0] = AllocADsStr(szSAMName);
            if (!pObjectInfo->ComponentArray[0]) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }
        }

    }

error:
    RRETURN(hr);

}


HRESULT
ValidateFileServiceObject(
    POBJECTINFO pObjectInfo,
    CWinNTCredentials& Credentials
    )
{

    HRESULT hr = S_OK;

    //
    // check to see if it is a valid service
    //

    if(!(pObjectInfo->NumComponents == 3 ||
         pObjectInfo->NumComponents == 2))
    {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = ValidateServiceObject(pObjectInfo, Credentials);

    if(FAILED(hr))
      RRETURN(hr);

    //
    // check to see if it is the LanmanServer or FPNW service
    //

    if (pObjectInfo->NumComponents ==3){

        if(!(_wcsicmp(pObjectInfo->ComponentArray[2],
                      TEXT("LanmanServer"))== 0
             || _wcsicmp(pObjectInfo->ComponentArray[2],TEXT("FPNW"))==0)){
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if(pObjectInfo->NumComponents == 2) {

        if(!(_wcsicmp(pObjectInfo->ComponentArray[1],
                      TEXT("LanmanServer"))== 0
             || _wcsicmp(pObjectInfo->ComponentArray[1],TEXT("FPNW"))==0)){

            RRETURN(E_ADS_BAD_PATHNAME);
        }
    }

    RRETURN(hr);
}


HRESULT
ValidateFileShareObject(
    POBJECTINFO pObjectInfo,
    CWinNTCredentials& Credentials
    )
{

    NET_API_STATUS nasStatus;
    LPSHARE_INFO_1 lpShareInfo1 = NULL;
    PNWVOLUMEINFO  pVolumeInfo = NULL;
    LPTSTR         pszDomainName = NULL;
    LPTSTR         pszServerName = NULL;
    LPTSTR         pszShareName = NULL;
    LPTSTR         pszServerType = NULL;
    HRESULT        hr = S_OK;
    DWORD dwSharePos = 3;
    BOOL fRefAdded = FALSE;
    //
    // check to see if it is a valid file share
    //

    if (pObjectInfo->NumComponents == 4 ){
        pszDomainName = pObjectInfo->ComponentArray[0];
        pszServerName = pObjectInfo->ComponentArray[1];
        pszServerType = pObjectInfo->ComponentArray[2];
        pszShareName  = pObjectInfo->ComponentArray[3];
        dwSharePos = 3;

        hr = ValidateComputerParent(pszDomainName,
                                    pszServerName,
                                    Credentials);
        BAIL_ON_FAILURE(hr);

    }
    else if (pObjectInfo->NumComponents == 3 ){
        pszServerName = pObjectInfo->ComponentArray[0];
        pszServerType = pObjectInfo->ComponentArray[1];
        pszShareName  = pObjectInfo->ComponentArray[2];
        dwSharePos = 2;
    }
    else {
        hr = E_ADS_UNKNOWN_OBJECT;
        goto error;
    }

    if(_tcsicmp(pszServerType,TEXT("LanmanServer")) == 0){

        // Need to ref this server before we do the NetShareGetInfo
        // so that we can authenticate against the server.

        hr = Credentials.RefServer(pszServerName);
        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        nasStatus = NetShareGetInfo(pszServerName,
                                    pszShareName,
                                    1,
                                    (LPBYTE*)&lpShareInfo1);

        // DeRef if ref added, no recovery possible on failed deref
        if (fRefAdded) {
            hr = Credentials.DeRefServer();
            fRefAdded = FALSE;
        }

        if(nasStatus != NERR_Success){
                hr = HRESULT_FROM_WIN32(nasStatus);
            goto error;
        }
        else {
            // Need to use the name returned by the call as opposed
            // to the name given in the ADsPath
            if (pObjectInfo->ComponentArray[dwSharePos]
                && lpShareInfo1->shi1_netname) {

                FreeADsStr(pObjectInfo->ComponentArray[dwSharePos]);
                pObjectInfo->ComponentArray[dwSharePos]
                    = AllocADsStr(lpShareInfo1->shi1_netname);
            }

            if (!pObjectInfo->ComponentArray[dwSharePos])
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            hr = S_OK;
            goto error;
        }
    }
    else if(_tcsicmp(pszServerType,TEXT("FPNW")) == 0){

        hr = Credentials.RefServer(pszServerName);
        if (SUCCEEDED(hr)) {
            fRefAdded = TRUE;
        }

        nasStatus = ADsNwVolumeGetInfo(pszServerName,
                                         pszShareName,
                                         1,
                                         &pVolumeInfo);

        // need to deref, nothing we can do if deref fails
        if (fRefAdded) {
            hr = Credentials.DeRefServer();
            fRefAdded = FALSE;
        }

        if(nasStatus != NERR_Success){
                hr = HRESULT_FROM_WIN32(nasStatus);
            goto error;
        }
        else{
            // Need to use the name returned by the call as opposed
            // to the name given in the ADsPath
            if (pObjectInfo->ComponentArray[dwSharePos]
                && pVolumeInfo->lpPath) {

                FreeADsStr(pObjectInfo->ComponentArray[dwSharePos]);
                pObjectInfo->ComponentArray[dwSharePos]
                    = AllocADsStr(pVolumeInfo->lpPath);
            }

            if (!pObjectInfo->ComponentArray[dwSharePos])
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            hr = S_OK;
            goto error;
        }
    } else {
        hr = E_ADS_UNKNOWN_OBJECT ;
    }

error:
    if(pVolumeInfo){
        ADsNwApiBufferFree(pVolumeInfo);
    }

    if(lpShareInfo1){
        NetApiBufferFree(lpShareInfo1);
    }

    RRETURN(hr);
}



HRESULT
ValidateNamespaceObject(
    POBJECTINFO pObjectInfo
    )
{
    if (!_wcsicmp(pObjectInfo->ProviderName, szProviderName)) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}


HRESULT
ValidateLocalGroupObject(
    LPWSTR szServerName,
    LPWSTR *pszGroupName,
    CWinNTCredentials& Credentials
    )

{
    NET_API_STATUS nasStatus;
    LPLOCALGROUP_INFO_1 lpGI = NULL;
    HRESULT hr = S_OK;
    BOOL fRefAdded = FALSE;

    // At this point the host server name has a \\ prepended
    // so we need to get rid of it.
    hr = Credentials.RefServer(szServerName+2);

    if (SUCCEEDED(hr)) {
        fRefAdded = TRUE;
    }

    nasStatus = NetLocalGroupGetInfo(
                    szServerName,
                    *pszGroupName,
                    1,
                    (LPBYTE*)(&lpGI)
                    );

    //
    // if a ref has been added we need to delete if before
    // checking the error status.
    //
    if (fRefAdded) {
        hr = Credentials.DeRefServer();
        // even if we fail, we have no recovery path
        fRefAdded = FALSE;
    }

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    // Need to use the name returned by the call as opposed
    // to the name given in the ADsPath
    if ((*pszGroupName) && lpGI->lgrpi1_name) {
        FreeADsStr(*pszGroupName);
        *pszGroupName = AllocADsStr(lpGI->lgrpi1_name);
    }

    if (!(*pszGroupName))
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

error:

    if (lpGI) {
        NetApiBufferFree(lpGI);
    }

    RRETURN(hr);
}


HRESULT
ValidateGlobalGroupObject(
    LPWSTR szServerName,
    LPWSTR *pszGroupName,
    CWinNTCredentials& Credentials
    )

{
    NET_API_STATUS nasStatus;
    LPGROUP_INFO_1 lpGI = NULL;
    HRESULT hr = S_OK;
    BOOL fRefAdded = FALSE;

    // At this point the host server name has a \\ prepended
    // so we need to get rid of it.
    hr = Credentials.RefServer(szServerName+2);

    if (SUCCEEDED(hr)) {
        fRefAdded = TRUE;
    }

    nasStatus = NetGroupGetInfo(
                    szServerName,
                    *pszGroupName,
                    1,
                    (LPBYTE*)(&lpGI)
                    );

    //
    // if a ref has been added we need to delete if before
    // checking the error status.
    //
    if (fRefAdded) {
        hr = Credentials.DeRefServer();
        // even if we fail, we have no recovery path
        fRefAdded = FALSE;
    }

    hr = HRESULT_FROM_WIN32(nasStatus);
    BAIL_ON_FAILURE(hr);

    // Need to use the name returned by the call as opposed
    // to the name given in the ADsPath
    if ((*pszGroupName) && lpGI->grpi1_name) {
        FreeADsStr(*pszGroupName);
        *pszGroupName = AllocADsStr(lpGI->grpi1_name);
    }

    if (!(*pszGroupName))
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

error:

    if (lpGI) {
        NetApiBufferFree(lpGI);
    }

    RRETURN(hr);
}


HRESULT
GetComputerParent(
    LPTSTR pszComputerName,
    LPTSTR *ppszComputerParentName,
    CWinNTCredentials& Credentials
    )

{
    //
    // This function returns the computer parent irrespective of whether
    // the computer belongs to a domain or to a workgroup
    //

    HRESULT hr = S_OK;
    LPTSTR pszComputerParentName = NULL;
    WCHAR szDomainName[MAX_PATH];
    WCHAR szSAMName[MAX_PATH];

    szSAMName[0] = szDomainName[0] = L'\0';


    hr = WinNTGetCachedComputerName(pszComputerName,
                                    szDomainName,
                                    szSAMName,
                                    Credentials );

    BAIL_ON_FAILURE(hr);

    pszComputerParentName = AllocADsStr(szDomainName);

    if(!pszComputerParentName){
        hr = E_OUTOFMEMORY;
    }
    *ppszComputerParentName = pszComputerParentName;

error:
    RRETURN(hr);
}


HRESULT
ConstructFullObjectInfo(
    POBJECTINFO pObjectInfo,
    POBJECTINFO *ppFullObjectInfo,
    CWinNTCredentials& Credentials
    )
{

    //
    // used in the case where the domain name is not specified.
    // Here the assumption is that an objectinfo structure with
    // domain name not filled in is passed down. We create a new
    // object info structure with the domain/workgroup name filled
    // in


    HRESULT hr = S_OK;
    POBJECTINFO pTempObjectInfo = NULL;
    DWORD i;
    LPWSTR pszComputerParent = NULL;

    pTempObjectInfo = (POBJECTINFO)AllocADsMem(sizeof(OBJECTINFO));

    if (!pTempObjectInfo) {
        RRETURN(hr = E_OUTOFMEMORY);
    }

    memset(pTempObjectInfo, 0, sizeof(OBJECTINFO));

    if(!pObjectInfo){
        RRETURN(E_OUTOFMEMORY);
    }

    pTempObjectInfo->ProviderName = AllocADsStr(pObjectInfo->ProviderName);
        if(!pTempObjectInfo->ProviderName){
                hr = E_OUTOFMEMORY;
                goto error;
        }
    pTempObjectInfo->ObjectType = pObjectInfo->ObjectType;
    pTempObjectInfo->NumComponents = pObjectInfo->NumComponents +1;

    for(i=0; i<MAXCOMPONENTS-1; i++){
        if(pObjectInfo->ComponentArray[i]) {
            pTempObjectInfo->ComponentArray[i+1] =
                AllocADsStr(pObjectInfo->ComponentArray[i]);

            if(!pTempObjectInfo->ComponentArray[i+1]){
                hr = E_OUTOFMEMORY;
                goto error;
            }
        }
        if(pObjectInfo->DisplayComponentArray[i]) {
            pTempObjectInfo->DisplayComponentArray[i+1] =
                AllocADsStr(pObjectInfo->DisplayComponentArray[i]);

            if(!pTempObjectInfo->DisplayComponentArray[i+1]){
                hr = E_OUTOFMEMORY;
                goto error;
            }
        }
    }

    hr = GetComputerParent(pObjectInfo->ComponentArray[0],
                           &(pTempObjectInfo->ComponentArray[0]),
                           Credentials );

    BAIL_ON_FAILURE(hr);

    hr = GetDisplayName(pTempObjectInfo->ComponentArray[0],
                        &(pTempObjectInfo->DisplayComponentArray[0]) );

    *ppFullObjectInfo = pTempObjectInfo ;

    RRETURN(S_OK);

error:

    FreeObjectInfo( pTempObjectInfo );
    *ppFullObjectInfo = NULL;
    RRETURN(hr);

}



//+---------------------------------------------------------------------------
// Function:   GetGroupObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetLocalGroupObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szGroupName = NULL;
    DWORD  dwParentId = 0;
    ULONG uGroupType = 0;
    POBJECTINFO pGroupObjectInfo = NULL;

    hr = ValidateGroupObject(
                pObjectInfo,
                &uGroupType,
                &dwParentId,
                Credentials
                );
    BAIL_ON_FAILURE(hr);

    if (uGroupType !=  WINNT_GROUP_LOCAL) {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);

    }



    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // could be group in computer or group in domain
        //
        if(dwParentId == WINNT_DOMAIN_ID){

            szDomainName = pObjectInfo->ComponentArray[0];
            szGroupName = pObjectInfo->ComponentArray[1];
            szServerName = NULL;
            hr = BuildParent(pObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

        } else {

            //
            // group in a computer
            //

            hr = ConstructFullObjectInfo(pObjectInfo,
                                         &pGroupObjectInfo,
                                         Credentials );

            if (hr == HRESULT_FROM_WIN32(NERR_WkstaNotStarted)) {

                //
                // Case when there are no workstation services.
                //

                hr = BuildParent(pObjectInfo, ADsParent);
                BAIL_ON_FAILURE(hr);

                szDomainName = NULL;
                szServerName = pObjectInfo->ComponentArray[0];
                szGroupName = pObjectInfo->ComponentArray[1];

            } else {

                BAIL_ON_FAILURE(hr);

                hr = BuildParent(pGroupObjectInfo, ADsParent);
                BAIL_ON_FAILURE(hr);

                szDomainName =  pGroupObjectInfo->ComponentArray[0];
                szServerName =  pGroupObjectInfo->ComponentArray[1];
                szGroupName   =  pGroupObjectInfo->ComponentArray[2];

            }
        }

        break;

    case 3:

        hr = BuildParent(pObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szGroupName = pObjectInfo->ComponentArray[2];
        break;

    }
    hr = CWinNTGroup::CreateGroup(ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szGroupName,
                            uGroupType,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    *ppObject = NULL;

    RRETURN(hr);
}





//+---------------------------------------------------------------------------
// Function:   GetGroupObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetGlobalGroupObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject,
    CWinNTCredentials& Credentials
    )
{

    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    LPWSTR szServerName = NULL;
    LPWSTR szDomainName = NULL;
    LPWSTR szGroupName = NULL;
    DWORD  dwParentId = 0;
    ULONG uGroupType = 0;
    POBJECTINFO pGroupObjectInfo = NULL;

    hr = ValidateGroupObject(
                pObjectInfo,
                &uGroupType,
                &dwParentId,
                Credentials
                );
    BAIL_ON_FAILURE(hr);

    if (uGroupType != WINNT_GROUP_GLOBAL) {

        hr  = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }


    switch (pObjectInfo->NumComponents) {
    case 2:
        //
        // could be group in computer or group in domain
        //
        if(dwParentId == WINNT_DOMAIN_ID){

            szDomainName = pObjectInfo->ComponentArray[0];
            szGroupName = pObjectInfo->ComponentArray[1];
            szServerName = NULL;
            hr = BuildParent(pObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

        } else {

            //
            // group in a computer
            //

            hr = ConstructFullObjectInfo(pObjectInfo,
                                         &pGroupObjectInfo,
                                         Credentials );
            BAIL_ON_FAILURE(hr);

            hr = BuildParent(pGroupObjectInfo, ADsParent);
            BAIL_ON_FAILURE(hr);

            szDomainName =  pGroupObjectInfo->ComponentArray[0];
            szServerName =  pGroupObjectInfo->ComponentArray[1];
            szGroupName   =  pGroupObjectInfo->ComponentArray[2];

        }
        break;

    case 3:

        hr = BuildParent(pObjectInfo, ADsParent);
        BAIL_ON_FAILURE(hr);

        szDomainName = pObjectInfo->ComponentArray[0];
        szServerName = pObjectInfo->ComponentArray[1];
        szGroupName = pObjectInfo->ComponentArray[2];
        break;

    }
    hr = CWinNTGroup::CreateGroup(ADsParent,
                            dwParentId,
                            szDomainName,
                            szServerName,
                            szGroupName,
                            uGroupType,
                            ADS_OBJECT_BOUND,
                            IID_IUnknown,
                            Credentials,
                            (void **)&pUnknown
                            );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    RRETURN(hr);

error:
    if (pUnknown) {
        pUnknown->Release();
    }

    if(pGroupObjectInfo){
        FreeObjectInfo(pGroupObjectInfo);
    }

    *ppObject = NULL;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\globals.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       globals.cxx
//
//  Contents:   Global Variables for WinNT
//
//  Functions:
//
//  History:    25-March-96   KrishnaG   Created.
//  Updated:    4-May-2000    sivaramr  Added a property called Name to all
//              classes in order to support keys in UMI.
//              13-Aug-2000   AjayR Added support to dynamically load
//              functions that are not on earlier NT versions.        
//
//----------------------------------------------------------------------------

#include "winnt.hxx"
#pragma hdrstop

//
// Global variabled needed to keep track of dynamically
// loaded libs.
//
HANDLE g_hDllNetapi32;
HANDLE g_hDllAdvapi32;
CRITICAL_SECTION g_csLoadLibs;
BOOL g_fDllsLoaded;
FRTLENCRYPTMEMORY g_pRtlEncryptMemory = NULL;
FRTLDECRYPTMEMORY g_pRtlDecryptMemory = NULL;

WCHAR *szProviderName = TEXT("WinNT");

#define MAX_LONG    (0x7FFFFFFF)
#define MIN_LONG    (0x80000000)
#define MAX_BOOLEAN 1
#define MAX_STRLEN  (256)

PROPERTYINFO DomainClass[] =
    { { TEXT("MinPasswordLength"),  // FSDomainPassword
        TEXT(""), TEXT("Integer"), LM20_PWLEN+1, 0, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MinPasswordAge"),
        TEXT(""), TEXT("Interval"), TIMEQ_FOREVER, 0, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxPasswordAge"),
        TEXT(""),TEXT("Interval"), TIMEQ_FOREVER, ONE_DAY, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxBadPasswordsAllowed"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
      //
      // NetAPI state DEF_MAX_PWHIST (8), but NetAPI devlpr confirm
      // current is 1024. Ignore Net Account - UNIQUEPWD limit.
      // Use DEF_MAX_PWHIST to be safe for now
      //
      { TEXT("PasswordHistoryLength"),
        TEXT(""), TEXT("Integer"), DEF_MAX_PWHIST, 0, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD},
      { TEXT("AutoUnlockInterval"),
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("LockoutObservationInterval"),
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwDomainTableSize = sizeof(DomainClass)/sizeof(PROPERTYINFO);

PROPERTYINFO ComputerClass[] =
    { { TEXT("Owner"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Division"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("OperatingSystem"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR},
      { TEXT("OperatingSystemVersion"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Processor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ProcessorCount"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Name"), 
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 4, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwComputerTableSize = sizeof(ComputerClass)/sizeof(PROPERTYINFO);

PROPERTYINFO UserClass[] =
    { // USER_INFO3
      { TEXT("Description"), // FSUserBusinessInfo
        TEXT(""), TEXT("String"), MAXCOMMENTSZ+1, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR },
      { TEXT("FullName"),
        TEXT(""), TEXT("String"), MAXCOMMENTSZ+1, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("AccountExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DATE_1970},
      { TEXT("PasswordAge"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD},
      { TEXT("UserFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD},
      { TEXT("LoginWorkstations"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DelimitedString },
      { TEXT("BadPasswordAttempts"),   // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxLogins"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxStorage"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
                                                  // USER_MAX_STORAGE_UNLIMITED
      { TEXT("PasswordExpired"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },

      { TEXT("PasswordExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DATE_1970 },

      { TEXT("LastLogin"),          // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_DATE_1970 },
      { TEXT("LastLogoff"),         // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_DATE_1970 },
      { TEXT("HomeDirectory"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Profile"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Parameters"),
        TEXT(""), TEXT("String"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("HomeDirDrive"),
        TEXT(""), TEXT("String"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("LoginScript"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR },
     { TEXT("LoginHours"),
       TEXT(""), TEXT("OctetString"), 0, 0, FALSE,
       PROPERTY_RW, 3, NT_SYNTAX_ID_OCTETSTRING},
      { TEXT("PrimaryGroupID"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },


      //
      // USER_MODAL_INFO0
      // NOTE!! - user_modal_info0 CANNOT (!!) be changed in USER class
      //          since they are meant for the entire domain.
      //        - user_modal_info0 CAN (!!) be changed in DOMAIN class
      //          only. Ref NetApi.
      //

      { TEXT("MinPasswordLength"),  // FSDomainPassword
        TEXT(""), TEXT("Integer"), LM20_PWLEN+1, 0, FALSE,
        PROPERTY_READABLE, 10, NT_SYNTAX_ID_DWORD },
      { TEXT("MinPasswordAge"),
        TEXT(""), TEXT("Interval"), TIMEQ_FOREVER, 0, FALSE,
        PROPERTY_READABLE, 10, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxPasswordAge"),
        TEXT(""),TEXT("Interval"), TIMEQ_FOREVER, ONE_DAY, FALSE,
        PROPERTY_READABLE, 10, NT_SYNTAX_ID_DWORD },
      //
      // NetAPI state DEF_MAX_PWHIST (8), but NetAPI devlpr confirm
      // current is 1024. Ignore Net Account - UNIQUEPWD limit.
      // Use DEF_MAX_PWHIST to be safe for now
      //
      { TEXT("PasswordHistoryLength"),
        TEXT(""), TEXT("Integer"), DEF_MAX_PWHIST, 0, FALSE,
        PROPERTY_READABLE, 10, NT_SYNTAX_ID_DWORD},


      //
      // USER_MODAL_INFO3
      // NOTE!! - user_modal_info3 CANNOT (!!) be changed in USER class
      //          since they are meant for the entire domain.
      //        - user_modal_info3 CAN (!!) be changed in DOMAIN class
      //          only. Ref NetApi.
      //

      { TEXT("MaxBadPasswordsAllowed"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 13, NT_SYNTAX_ID_DWORD },
      { TEXT("AutoUnlockInterval"),
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 13, NT_SYNTAX_ID_DWORD },
      { TEXT("LockoutObservationInterval"),
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 13, NT_SYNTAX_ID_DWORD },


     //
     // Not for USER_INFO or USER_MODAL_INFO
     //

     { TEXT("objectSid"),
       TEXT(""), TEXT("OctetString"), 0, 0, FALSE,
       PROPERTY_READABLE, 20, NT_SYNTAX_ID_OCTETSTRING},

      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwUserTableSize = sizeof(UserClass)/sizeof(PROPERTYINFO);


PROPERTYINFO GroupClass[] =
    {
      { TEXT("Description"),            // FSGroupGeneralInfo
        TEXT(""), TEXT("String"), MAXCOMMENTSZ+1, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },

     { TEXT("objectSid"),
       TEXT(""), TEXT("OctetString"), 0, 0, FALSE,
       PROPERTY_READABLE, 20, NT_SYNTAX_ID_OCTETSTRING},

     { TEXT("groupType"),
       TEXT(""), TEXT("Integer"), 0, 0, FALSE,
       PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD},

     { TEXT("Name"),
       TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
       PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };


DWORD gdwGroupTableSize = sizeof(GroupClass)/sizeof(PROPERTYINFO);


PROPERTYINFO ServiceClass[] =
    { { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("DisplayName"),
        TEXT(""), TEXT("String"), 256, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("StartType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Path"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ErrorControl"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("LoadOrderGroup"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceAccountName"),
        TEXT(""), TEXT("String"), DNLEN+UNLEN+2, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Dependencies"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_NulledString},
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwServiceTableSize = sizeof(ServiceClass)/sizeof(PROPERTYINFO);


PROPERTYINFO FileServiceClass[] =
    { { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("DisplayName"),
        TEXT(""), TEXT("String"), 256, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Version"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("StartType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Path"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ErrorControl"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("LoadOrderGroup"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceAccountName"),
        TEXT(""), TEXT("String"), DNLEN+UNLEN+2, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Dependencies"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_NulledString},
      { TEXT("Description"),            // FSFileServiceGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwFileServiceTableSize = sizeof(FileServiceClass)/sizeof(PROPERTYINFO);

PROPERTYINFO SessionClass[] =
    { { TEXT("User"), // ro, FSSessionGeneralInfo
        TEXT(""), TEXT("String"), UNLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Computer"), // ro
        TEXT(""), TEXT("String"), UNCLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("ConnectTime"),   // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DATE },
      { TEXT("IdleTime"),      // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DATE},
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwSessionTableSize = sizeof(SessionClass)/sizeof(PROPERTYINFO);

PROPERTYINFO ResourceClass[] =
    { { TEXT("User"), // ro, FSResourceGeneralInfo
        TEXT(""), TEXT("String"), UNLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Path"),     // ro
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("LockCount"), // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwResourceTableSize = sizeof(ResourceClass)/sizeof(PROPERTYINFO);


PROPERTYINFO FileShareClass[] =
    { { TEXT("CurrentUserCount"), // ro, FSFileShareGeneralInfo
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("HostComputer"),
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Path"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, -1, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwFileShareTableSize = sizeof(FileShareClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FPNWFileServiceClass[] =
    { { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("DisplayName"),
        TEXT(""), TEXT("String"), 256, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Version"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("StartType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Path"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ErrorControl"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("LoadOrderGroup"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceAccountName"),
        TEXT(""), TEXT("String"), DNLEN+UNLEN+2, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Dependencies"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_NulledString},
      { TEXT("Description"),            // FSFileServiceGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwFPNWFileServiceTableSize = sizeof(FPNWFileServiceClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FPNWSessionClass[] =
    { { TEXT("User"), // ro, FSSessionGeneralInfo
        TEXT(""), TEXT("String"), UNLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Computer"), // ro
        TEXT(""), TEXT("String"), UNCLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("ConnectTime"),   // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DATE },
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };


DWORD gdwFPNWSessionTableSize = sizeof(FPNWSessionClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FPNWResourceClass[] =
    { { TEXT("User"), // ro, FSResourceGeneralInfo
        TEXT(""), TEXT("String"), UNLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Path"),     // ro
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("LockCount"), // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwFPNWResourceTableSize = sizeof(FPNWResourceClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FPNWFileShareClass[] =
    { { TEXT("CurrentUserCount"), // ro, FSFileShareGeneralInfo
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("HostComputer"),
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Path"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, -1, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwFPNWFileShareTableSize = sizeof(FPNWFileShareClass)/sizeof(PROPERTYINFO);

PROPERTYINFO PrintQueueClass[] =
    { { TEXT("PrinterPath"),    // FSPrintQueueGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrinterName"),    // friendly name
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Model"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Datatype"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintProcessor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Location"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("DefaultJobPriority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD},
      { TEXT("JobCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD},
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Attributes"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD},
      { TEXT("BannerPage"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintDevices"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DelimitedString } ,


      { TEXT("ObjectGUID"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 7, NT_SYNTAX_ID_LPTSTR },

      { TEXT("Action"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 7, NT_SYNTAX_ID_DWORD },

      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwPrinterTableSize = sizeof(PrintQueueClass)/sizeof(PROPERTYINFO);

PROPERTYINFO PrintJobClass[] =
    { { TEXT("HostPrintQueue"),     // ro, FSPrintJobGeneralInfo
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("User"),               // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeSubmitted"),      // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_SYSTEMTIME },
      { TEXT("TotalPages"),         // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Size"),               // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD},
      { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("Notify"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeElapsed"),        // ro
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("PagesPrinted"),       // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Position"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },

      { TEXT("ObjectGUID"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 7, NT_SYNTAX_ID_LPTSTR },

      { TEXT("Action"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 7, NT_SYNTAX_ID_DWORD },

      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR }
    };

DWORD gdwJobTableSize = sizeof(PrintJobClass)/sizeof(PROPERTYINFO);


CLASSINFO g_aWinNTClasses[] =
{

  // Domain
  { DOMAIN_SCHEMA_NAME, &CLSID_WinNTDomain, &IID_IADsDomain,
    TEXT(""), FALSE,

    NULL,

    TEXT("MinPasswordLength,MinPasswordAge,MaxPasswordAge,MaxBadPasswordsAllowed,")
    TEXT("PasswordHistoryLength,AutoUnlockInterval,LockoutObservationInterval,Name"),

    NULL, TEXT("Computer,User,Group"),TRUE,
    TEXT(""), 0,
    DomainClass, sizeof(DomainClass)/sizeof(PROPERTYINFO) },


  // Computer
  { COMPUTER_SCHEMA_NAME, &CLSID_WinNTComputer, &IID_IADsComputer,
    TEXT(""), FALSE,

    NULL,

    TEXT("Owner,Division,OperatingSystem,OperatingSystemVersion,")
    TEXT("Processor,ProcessorCount,Name"),

    TEXT("Domain"), TEXT("User,Group,Service,FileService,PrintQueue"), TRUE,
    TEXT(""), 0,
    ComputerClass, sizeof(ComputerClass)/sizeof(PROPERTYINFO) },


  // User
  { USER_SCHEMA_NAME, &CLSID_WinNTUser, &IID_IADsUser,
    TEXT(""), FALSE,

    NULL,

    TEXT("Description,FullName,AccountExpirationDate,")
    TEXT("BadPasswordAttempts,HomeDirDrive,HomeDirectory,")
    TEXT("LastLogin,LastLogoff,LoginHours,LoginScript,LoginWorkstations,")
    TEXT("MaxLogins,MaxPasswordAge,MaxStorage,")
    TEXT("MinPasswordAge,MinPasswordLength,objectSid,")
    TEXT("Parameters,PasswordAge,PasswordExpired,")
    TEXT("PasswordHistoryLength,PrimaryGroupID,Profile,UserFlags,")
    TEXT("Name"),


    TEXT("Domain,Computer"), NULL, FALSE,
    TEXT(""), 0,
    UserClass, sizeof(UserClass)/sizeof(PROPERTYINFO) },


  // Group
  { GROUP_SCHEMA_NAME, &CLSID_WinNTGroup, &IID_IADsGroup,
    TEXT(""), FALSE,


    TEXT("groupType"),

    TEXT("Description,objectSid,Name"),

    TEXT("Domain,Computer"), NULL, FALSE,
    TEXT(""), 0,
    GroupClass, sizeof(GroupClass)/sizeof(PROPERTYINFO) },


  { SERVICE_SCHEMA_NAME, &CLSID_WinNTService, &IID_IADsService,
    TEXT(""), FALSE,

    TEXT("StartType,ServiceType,")
    TEXT("DisplayName,Path,ErrorControl"),


    TEXT("HostComputer,")
    TEXT("LoadOrderGroup,ServiceAccountName,")
    TEXT("Dependencies,Name"),


    TEXT("Computer"), NULL, FALSE,
    TEXT(""), 0,
    ServiceClass, sizeof(ServiceClass)/sizeof(PROPERTYINFO) },

  { FILESERVICE_SCHEMA_NAME, &CLSID_WinNTFileService, &IID_IADsFileService,
    TEXT(""), FALSE,


    NULL,


    TEXT("HostComputer,DisplayName,Version,ServiceType,StartType,")
    TEXT("ErrorControl,LoadOrderGroup,ServiceAccountName,Dependencies,")
    TEXT("Description,MaxUserCount,Name"),


    TEXT("Computer"), TEXT("FileShare"), TRUE,
    TEXT(""), 0,
    FileServiceClass, sizeof(FileServiceClass)/sizeof(PROPERTYINFO) },

  { SESSION_SCHEMA_NAME, &CLSID_WinNTSession, &IID_IADsSession,
    TEXT(""), FALSE,


    NULL,


    TEXT("User,Computer,ConnectTime,IdleTime,Name"),


    NULL, NULL, FALSE,
    TEXT(""), 0,
    SessionClass, sizeof(SessionClass)/sizeof(PROPERTYINFO) },

  { RESOURCE_SCHEMA_NAME, &CLSID_WinNTResource, &IID_IADsResource,
    TEXT(""), FALSE,



    NULL,


    TEXT("User,Path,LockCount,Name"),


    NULL, NULL, FALSE,
    TEXT(""), 0,
    ResourceClass, sizeof(ResourceClass)/sizeof(PROPERTYINFO) },

  { FILESHARE_SCHEMA_NAME,  &CLSID_WinNTFileShare,  &IID_IADsFileShare,
    TEXT(""), FALSE,

    TEXT("Path,MaxUserCount"),


    TEXT("CurrentUserCount,Description,HostComputer,Name"),


    TEXT("FileService"),
    NULL, FALSE,
    TEXT(""), 0,
    FileShareClass, sizeof(FileShareClass)/sizeof(PROPERTYINFO) },

  { FPNW_FILESERVICE_SCHEMA_NAME, &CLSID_WinNTFileService, &IID_IADsFileService,
    TEXT(""), FALSE,


    NULL,


    TEXT("HostComputer,DisplayName,Version,ServiceType,")
    TEXT("StartType,Path,ErrorControl,LoadOrderGroup,")
    TEXT("Description,MaxUserCount,Name"),


    TEXT("Computer"), TEXT("FileShare"), TRUE,
    TEXT(""), 0,
    FileServiceClass, sizeof(FileServiceClass)/sizeof(PROPERTYINFO) },

  { FPNW_SESSION_SCHEMA_NAME, &CLSID_WinNTSession, &IID_IADsSession,
    TEXT(""), FALSE,


    NULL,


    TEXT("User,Computer,ConnectTime,Name"),


    NULL, NULL, FALSE,
    TEXT(""), 0,
    SessionClass, sizeof(SessionClass)/sizeof(PROPERTYINFO) },

  { FPNW_RESOURCE_SCHEMA_NAME, &CLSID_WinNTResource, &IID_IADsResource,
    TEXT(""), FALSE,



    NULL,


    TEXT("User,Path,LockCount,Name"),


    NULL, NULL, FALSE,
    TEXT(""), 0,
    ResourceClass, sizeof(ResourceClass)/sizeof(PROPERTYINFO) },

  { FPNW_FILESHARE_SCHEMA_NAME,  &CLSID_WinNTFileShare,  &IID_IADsFileShare,
    TEXT(""), FALSE,


    TEXT("Path,MaxUserCount"),


    TEXT("CurrentUserCount,HostComputer,Name"),


    TEXT("FileService"),

    NULL, FALSE,
    TEXT(""), 0,
    FileShareClass, sizeof(FileShareClass)/sizeof(PROPERTYINFO) },

  { PRINTER_SCHEMA_NAME, &CLSID_WinNTPrintQueue, &IID_IADsPrintQueue,
    TEXT(""), FALSE,

    TEXT("PrinterName,Model,Datatype,")
    TEXT("PrintProcessor,PrintDevices"),

    TEXT("HostComputer,Description,")
    TEXT("Location,StartTime,UntilTime,DefaultJobPriority,JobCount,Priority,")
    TEXT("Attributes,BannerPage,ObjectGUID,Action,Name"),


    TEXT("Computer"), NULL, FALSE,
    TEXT(""), 0,
    PrintQueueClass, sizeof(PrintQueueClass)/sizeof(PROPERTYINFO) },

  { PRINTJOB_SCHEMA_NAME, &CLSID_WinNTPrintJob, &IID_IADsPrintJob,
    TEXT(""), FALSE,


    NULL,


    TEXT("HostPrintQueue,User,TimeSubmitted,TotalPages,Size,Description,")
    TEXT("Priority,StartTime,UntilTime,Notify,TimeElapsed,PagesPrinted,")
    TEXT("Position,Name"),


    NULL, NULL, FALSE,
    TEXT(""), 0,
    PrintJobClass, sizeof(PrintJobClass)/sizeof(PROPERTYINFO) }
};

SYNTAXINFO g_aWinNTSyntax[] =
{ {  TEXT("Boolean"),       VT_BOOL },
  {  TEXT("Counter"),       VT_I4 },
  {  TEXT("ADsPath"),     VT_BSTR },
  {  TEXT("EmailAddress"),  VT_BSTR },
  {  TEXT("FaxNumber"),     VT_BSTR },
  {  TEXT("Integer"),       VT_I4 },
  {  TEXT("Interval"),      VT_I4 },
  {  TEXT("List"),          VT_VARIANT },  // VT_BSTR | VT_ARRAY
  {  TEXT("NetAddress"),    VT_BSTR },
  {  TEXT("OctetString"),   VT_VARIANT },  // VT_UI1| VT_ARRAY
  {  TEXT("Path"),          VT_BSTR },
  {  TEXT("PhoneNumber"),   VT_BSTR },
  {  TEXT("PostalAddress"), VT_BSTR },
  {  TEXT("SmallInterval"), VT_I4 },
  {  TEXT("String"),        VT_BSTR },
  {  TEXT("Time"),          VT_DATE }
};

DWORD g_cWinNTClasses = (sizeof(g_aWinNTClasses)/sizeof(g_aWinNTClasses[0]));
DWORD g_cWinNTSyntax = (sizeof(g_aWinNTSyntax)/sizeof(g_aWinNTSyntax[0]));


CObjNameCache *  pgPDCNameCache = NULL;


PROPERTYINFO g_aWinNTProperties[] =
//
// domain properties
//
    { { TEXT("MinPasswordLength"),  // FSDomainPassword
        TEXT(""), TEXT("Integer"), LM20_PWLEN+1, 0, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MinPasswordAge"),
        TEXT(""), TEXT("Interval"), TIMEQ_FOREVER, 0, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxPasswordAge"),
        TEXT(""),TEXT("Interval"), TIMEQ_FOREVER, ONE_DAY, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxBadPasswordsAllowed"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },

      //
      // NetAPI state DEF_MAX_PWHIST (8), but NetAPI devlpr confirm
      // current is 1024. Ignore Net Account - UNIQUEPWD limit.
      // User DEF_MAX_PWHIST to be safe for now.
      // not repeated for user ??
      //
      { TEXT("PasswordHistoryLength"),
        TEXT(""), TEXT("Integer"), DEF_MAX_PWHIST, 0, FALSE,
        PROPERTY_RW, 0, NT_SYNTAX_ID_DWORD},

      { TEXT("AutoUnlockInterval"),
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("LockoutObservationInterval"),
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },

    // Computer Properties

      { TEXT("Owner"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Division"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("OperatingSystem"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR},
      { TEXT("OperatingSystemVersion"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Processor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ProcessorCount"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 4, NT_SYNTAX_ID_LPTSTR },


    // User Properties

     { TEXT("Description"), // FSUserBusinessInfo
        TEXT(""), TEXT("String"), MAXCOMMENTSZ+1, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR },
      { TEXT("FullName"),
        TEXT(""), TEXT("String"), MAXCOMMENTSZ+1, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("AccountExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DATE_1970},
      { TEXT("PasswordAge"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DATE_1970},
      { TEXT("UserFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD},
      { TEXT("LoginWorkstations"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DelimitedString },
      { TEXT("BadPasswordAttempts"),    //ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxLogins"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
      { TEXT("MaxStorage"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
                                                  // USER_MAX_STORAGE_UNLIMITED
      { TEXT("PasswordExpired"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },


      { TEXT("PasswordExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DATE_1970 },

      { TEXT("LastLogin"),          // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_DATE_1970 },
      { TEXT("LastLogoff"),         // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 3, NT_SYNTAX_ID_DATE_1970 },
      { TEXT("HomeDirectory"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Profile"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Parameters"),
        TEXT(""), TEXT("String"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("HomeDirDrive"),
        TEXT(""), TEXT("String"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR},
      { TEXT("LoginScript"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_LPTSTR },
      { TEXT("LoginHours"),
       TEXT(""), TEXT("OctetString"), 0, 0, FALSE,
       PROPERTY_RW, 3, NT_SYNTAX_ID_OCTETSTRING},
      { TEXT("PrimaryGroupID"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 3, NT_SYNTAX_ID_DWORD },
     { TEXT("objectSid"),
       TEXT(""), TEXT("OctetString"), 0, 0, FALSE,
       PROPERTY_READABLE, 20, NT_SYNTAX_ID_OCTETSTRING},

    // Group Properties

     { TEXT("groupType"),
       TEXT(""), TEXT("Integer"), 0, 0, FALSE,
       PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },

       //
      // Description (User)
      //

    // Service Properties

     { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("DisplayName"),
        TEXT(""), TEXT("String"), 256, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD},
      { TEXT("StartType"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Path"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ErrorControl"),
        TEXT(""), TEXT("Integer"), MAX_LONG, MIN_LONG, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("LoadOrderGroup"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("ServiceAccountName"),
        TEXT(""), TEXT("String"), DNLEN+UNLEN+2, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("Dependencies"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_NulledString},

    // File Service Properties
      //
      // HostComputer(Service
      //
      //
      // DisplayName (Service)
      //
      { TEXT("Version"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_LPTSTR },
      //
      // ServiceType (service)
      //
      // StartType (service)
      //
      //
      // Path (Service)
      //
      //
      // ErrorControl (service)
      //
      //
      // LoadOrderGroup(service)
      //
      //
      // ServiceAccountName (service)
      //
      //
      // Dependencies (Service)
      //
      // Description (user)
      //
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },

    // Session Properties

     { TEXT("User"), // ro, FSSessionGeneralInfo
        TEXT(""), TEXT("String"), UNLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Computer"), // ro
        TEXT(""), TEXT("String"), UNCLEN+1, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR},
      { TEXT("ConnectTime"),   // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DATE },
      { TEXT("IdleTime"),      // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DATE},


    // Resource Properties
      //
      // User (session)
      //
      // Path (service)
      //
      { TEXT("LockCount"), // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DWORD},



    // FileShareClass

     { TEXT("CurrentUserCount"), // ro, FSFileShareGeneralInfo
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },

      //
      // Description (User)
      //
      //
      // HostComputer(Service)
      //
      //
      // Path (service)
      //
      //
      // MaxUserCount(FileService)
      //

     // FPNWFileServiceClass

      //
      // HostComputer (Service)
      //
      //
      // DisplayName (Service)
      //
      // Version (FileService)
      //
      //
      // ServiceType (service)
      //
      // StartType (service)
      //
      //
      // Path (Service)
      //
      //
      // ErrorControl (Service)
      //
      //
      // LoadOrderGroup (Service)
      //
      //
      // ServiceAccountName (service)
      //
      //
      // Dependencies (service)
      //
      //
      // Description (User)
      //
      //
      // MaxUserCount(FileService)
      //

    // FPNWSession Class
      //
      // User (Session)
      //
      //
      // Computer (session)
      //
      // ConnectTime (session)

    // FPNWResourceClass

      //
      // User (Session)
      //
      //
      // Path (Service)
      //
      //
      // LockCount (resource)
      //

    // FPNWFileShareClass

      // CurrentUserCount (FileShare)

      //
      // HostComputer(Service)
      //
      //
      // Path (service)
      //
      //
      // MaxUserCount (FileService)
      //

    // PrintQueueClass

     { TEXT("PrinterPath"), // FSPrintQueueGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR },
     { TEXT("PrinterName"), // friendly name
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Model"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Datatype"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintProcessor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },

      { TEXT("ObjectGUID"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 7, NT_SYNTAX_ID_LPTSTR },

      { TEXT("Action"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 7, NT_SYNTAX_ID_DWORD },



      //
      // Description (user)
      //
      { TEXT("Location"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("DefaultJobPriority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD},
      { TEXT("JobCount"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD},
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Attributes"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("BannerPage"),
        TEXT(""), TEXT("Path"), MAX_PATH, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintDevices"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DelimitedString },

    // PrintJobClass

      { TEXT("HostPrintQueue"),     // ro, FSPrintJobGeneralInfo
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeSubmitted"),      // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_SYSTEMTIME },
      { TEXT("TotalPages"),         // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_DWORD },
      { TEXT("Size"),               // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD},
      //
      // Description (User)
      //
      //
      // Priority (PrintQueue)
      //
      // StartTime (PrintQueue)
      //
      // UntilTime (PrintQueue)
      //
      { TEXT("Notify"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeElapsed"),        // ro
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("PagesPrinted"),       // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Position"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },

      // Name is common to all classes. Add one entry here for it.
      { TEXT("Name"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 0, NT_SYNTAX_ID_LPTSTR }

    };

DWORD g_cWinNTProperties = sizeof(g_aWinNTProperties)/sizeof(PROPERTYINFO);

//
// Support routines for dynamically loading entry points.
//
void BindToDlls()
{
    DWORD dwErr = 0;

    if (!g_fDllsLoaded) {
        //
        // Construct a full path to the netapi32.dll
        //
        TCHAR szFullPathBufferNetAPI32[MAX_PATH + 1];  // +1 to allow for NULL terminator according to GetSystemDirectory
        TCHAR szFullPathBufferADVAPI32[MAX_PATH + 1];
        UINT uiPathLength = 0;
        if ((uiPathLength = GetSystemDirectory(szFullPathBufferNetAPI32, MAX_PATH + 1)) == 0)
          return;

        //
        // Only checking the length of the full path with the NETAPI32.DLL
        // file.  We know that ADVAPI32.DLL has the same number of characters
        // as NETAPI32.DLL so if one fits in the buffer, so will the other one.
        //
        if ((uiPathLength + 1 + _tcslen(TEXT("NETAPI32.DLL"))) > MAX_PATH) // +1 is for slash
          return;

        _tcscat(szFullPathBufferNetAPI32, TEXT("\\"));

        _tcscpy(szFullPathBufferADVAPI32, szFullPathBufferNetAPI32);

        _tcscat(szFullPathBufferNetAPI32, TEXT("NETAPI32.DLL"));
        _tcscat(szFullPathBufferADVAPI32, TEXT("ADVAPI32.DLL"));

        EnterCriticalSection(&g_csLoadLibs);
        if (!g_fDllsLoaded) {
            g_hDllNetapi32 = LoadLibrary(szFullPathBufferNetAPI32);
            if (!g_hDllNetapi32) {
                dwErr = GetLastError();
            }

            if (g_hDllAdvapi32 = LoadLibrary(szFullPathBufferADVAPI32)) {
                if (dwErr) {
                    //
                    // Set the last error for whatever it is worth.
                    // This does not really matter cause any dll we
                    // cannot load, we will not get functions on that
                    // dll. If secur32 load failed, then that call
                    // would have set a relevant last error.
                    //
                    SetLastError(dwErr);
                }
            }

            g_fDllsLoaded = TRUE;
            LeaveCriticalSection(&g_csLoadLibs);
        }
    }
}

//
// Locates entry points in NetApi32.
//
PVOID LoadNetApi32Function(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllNetapi32) {
        return((PVOID*) GetProcAddress((HMODULE) g_hDllNetapi32, function));
    }

    return NULL;
}

//
// Locates entry points in advapi32
//
PVOID LoadAdvapi32Function(CHAR *function)
{
    if (!g_fDllsLoaded) {
        BindToDlls();
    }

    if (g_hDllAdvapi32) {
        return((PVOID*) GetProcAddress((HMODULE) g_hDllAdvapi32, function));
    }

    return NULL;
}

//
// DsUnquoteRdnValueWrapper
//
BOOL ConvertStringSidToSidWrapper(
    IN LPCWSTR   StringSid,
    OUT PSID   *Sid
    )
{
    static PF_ConvertStringSidToSid pfConvertStringSidToSid = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfConvertStringSidToSid == NULL) {
        pfConvertStringSidToSid
            = (PF_ConvertStringSidToSid)
                    LoadAdvapi32Function(CONVERT_STRING_TO_SID_API);

        f_LoadAttempted = TRUE;
    }

    if (pfConvertStringSidToSid != NULL) {
        return ((*pfConvertStringSidToSid)(
                      StringSid,
                      Sid
                      )
                );
    }
    else {
        SetLastError(ERROR_GEN_FAILURE);
        return (FALSE);
    }
}

BOOL ConvertSidToStringSidWrapper(
    IN  PSID     Sid,
    OUT LPWSTR  *StringSid
    )
{
    static PF_ConvertSidToStringSid pfConvertSidToSidString = NULL;
    static BOOL f_LoadAttempted = FALSE;

    //
    // Load the fn and set the variables accordingly.
    //
    if (!f_LoadAttempted && pfConvertSidToSidString == NULL) {
        pfConvertSidToSidString =
            (PF_ConvertSidToStringSid)
                LoadAdvapi32Function(CONVERT_SID_TO_STRING_API);
        f_LoadAttempted = TRUE;
    }

    if (pfConvertSidToSidString != NULL) {
        return ((*pfConvertSidToSidString)(
                      Sid,
                      StringSid
                      )
                );
    }
    else {
        SetLastError(ERROR_GEN_FAILURE);
        return (FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\grput3.cxx ===
#include "winnt.hxx"
#pragma hdrstop



WINNT_GROUP WinNTGroup;

//
// This assumes that addr is an LPBYTE type.
//
#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((DWORD_PTR)addr & ~1))

DWORD WinNTGroupStrings[]=

                    {
                    FIELD_OFFSET(WINNT_GROUP, Parent),
                    FIELD_OFFSET(WINNT_GROUP, Computer),
                    FIELD_OFFSET(WINNT_GROUP, Domain),
                    FIELD_OFFSET(WINNT_GROUP, Name),
                    0xFFFFFFFF
                    };


BOOL
WinNTComputerOpen(
    LPWSTR szDomainName,
    LPWSTR szComputerName,
    ULONG  uGroupParent,
    PHANDLE phComputer
    )
{
    WCHAR szTempBuffer[MAX_PATH];
    PINICOMPUTER pIniComputer;
    HRESULT hr;


    if (!phComputer || (szComputerName == NULL) ) {
        return(FALSE);
    }

    pIniComputer = (PINICOMPUTER)AllocADsMem(
                                        sizeof(INICOMPUTER)
                                        );
    if (!pIniComputer) {
        return(FALSE);
    }

    hr = MakeUncName(
            szComputerName,
            szTempBuffer
            );
    BAIL_ON_FAILURE(hr);

    if (!(pIniComputer->szUncCompName =  AllocADsStr(szTempBuffer))){
        goto error;
    }

    if (szDomainName != NULL) {
        if (!(pIniComputer->szDomainName = AllocADsStr(szDomainName))) {
            goto error;
        }
    }

    if (!(pIniComputer->szComputerName =  AllocADsStr(szComputerName))){
        goto error;
    }

    pIniComputer->uGroupParent = uGroupParent;

    *phComputer =  (HANDLE)pIniComputer;

    return(TRUE);


error:
    if (pIniComputer) {
        FreeIniComputer(pIniComputer);
    }

    *phComputer = NULL;

    return(FALSE);

}



BOOL
WinNTEnumGlobalGroups(
    HANDLE hComputer,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{

    LPWINNT_GROUP * ppGroup = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPWINNT_GROUP pBuffer = NULL;
    LPBYTE pEnd = NULL;
    BOOL retVal = FALSE;

    ppGroup = (LPWINNT_GROUP *)AllocADsMem(
                                sizeof(LPWINNT_GROUP)* dwRequested
                                );
    if (!ppGroup) {
        return(FALSE);
    }

    for (i = 0; i < dwRequested; i++) {

        dwRet = WinNTComputerGetGlobalGroup(
                        hComputer,
                        &ppGroup[i]
                        );
        if (!dwRet) {
            break;
        }

    }

    dwReturned = i;

    dwRet = ComputeWinNTGroupDataSize(
                    ppGroup,
                    dwReturned,
                    &dwSize
                    );

    pBuffer = (LPWINNT_GROUP)AllocADsMem(
                        dwSize
                        );
    if (pBuffer) {

        retVal = TRUE;

        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniWinNTGroupToWinNTGroup(
                            ppGroup[i],
                            (LPBYTE)(pBuffer + i),
                            pEnd
                            );
        }
    }

    for (i = 0; i < dwReturned; i++ ) {
        FreeIntWinNTGroup(*(ppGroup + i));
    }

    FreeADsMem(ppGroup);

    //
    // Will assign to NULL correctly if alloc failed.
    //
    *ppBuffer = (LPBYTE)pBuffer;
    *pdwReturned  = retVal ? dwReturned : 0;

    if (!retVal) {
        return(FALSE);
    }

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }
}

BOOL
WinNTComputerGetGlobalGroup(
    HANDLE hComputer,
    LPWINNT_GROUP * ppGroup
    )
{
    BOOL dwRet = FALSE;
    PINICOMPUTER pIniComp = (PINICOMPUTER)hComputer;   
    NET_API_STATUS nasStatus = 0;
    GROUP_INFO_2 *pGroupInfo2 = NULL;    
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdomainInfo = NULL; 
    DWORD dwResult = ERROR_SUCCESS;
    HRESULT hr = S_OK;

    if ((!pIniComp->_pBuffer) ||
        (pIniComp->_dwCurrentObject == pIniComp->_dwObjectReturned)) {

        if (pIniComp->_bNoMore) {

            //
            // No more objects to return
            //
            return(FALSE);
        }

        if (pIniComp->_pBuffer) {
            NetApiBufferFree(pIniComp->_pBuffer);
            pIniComp->_pBuffer = NULL;
        }

        pIniComp->_dwObjectReturned = 0;
        pIniComp->_dwCurrentObject = 0;
        pIniComp->_dwTotalObjects = 0;

        nasStatus = NetGroupEnum(
                            pIniComp->szUncCompName,
                            2,
                            &pIniComp->_pBuffer,
                            MAX_PREFERRED_LENGTH,
                            &pIniComp->_dwObjectReturned,
                            &pIniComp->_dwTotalObjects,
                            &pIniComp->_dwResumeHandle
                            );
        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)){
            SetLastError(nasStatus);
            return(FALSE);
        }

        if (nasStatus != ERROR_MORE_DATA) {
            pIniComp->_bNoMore = TRUE;
        }

        pGroupInfo2 = (PGROUP_INFO_2) pIniComp->_pBuffer;

        if ( (!pIniComp->_dwObjectReturned)) {

            //
            // We get success code (ERROR_SUCCESS) but the buffer was NULL:
            // -> no global group was enumerated from the svr
            //

            return(FALSE);

        } else if ( (1 == pIniComp->_dwTotalObjects) &&
                    (DOMAIN_GROUP_RID_USERS == pGroupInfo2->grpi2_group_id) ) {
        // check if this is the none group. Only returned by non-DCs.

            dwResult = DsRoleGetPrimaryDomainInformation(
                                     pIniComp->szUncCompName,                      
                                     DsRolePrimaryDomainInfoBasic,   // InfoLevel
                                     (PBYTE*)&pdomainInfo            // pBuffer
                                   );    
            hr = HRESULT_FROM_WIN32(dwResult);
            BAIL_ON_FAILURE(hr);

            if(!( (pdomainInfo->MachineRole == DsRole_RoleBackupDomainController) ||
                (pdomainInfo->MachineRole == DsRole_RolePrimaryDomainController) ) ) {

                    DsRoleFreeMemory(pdomainInfo);
                    (pIniComp->_dwCurrentObject)++;
                    return (FALSE);
            }
            else // it is a DC. Fall through.
                ;
        }
    }

    dwRet = BuildWinNTGroupFromGlobalGroup(
                hComputer,
                (LPBYTE)((PGROUP_INFO_2) pIniComp->_pBuffer + pIniComp->_dwCurrentObject),
                ppGroup
                );
    if (!dwRet) {
        goto error;
    }

    pIniComp->_dwCurrentObject++;

    if(pdomainInfo)
    {
        DsRoleFreeMemory(pdomainInfo);
    }

    return(TRUE);

error:

    if(pdomainInfo)
    {
        DsRoleFreeMemory(pdomainInfo);
    }

    return(FALSE);
}

BOOL
WinNTEnumLocalGroups(
    HANDLE hComputer,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{

    LPWINNT_GROUP * ppGroup = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPWINNT_GROUP pBuffer = NULL;
    LPBYTE pEnd = NULL;
    BOOL fretVal = FALSE;


    ppGroup = (LPWINNT_GROUP *)AllocADsMem(
                                sizeof(LPWINNT_GROUP)* dwRequested
                                );
    if (!ppGroup) {
        return(FALSE);
    }

    for (i = 0; i < dwRequested; i++) {

        dwRet = WinNTComputerGetLocalGroup(
                        hComputer,
                        &ppGroup[i]
                        );
        if (!dwRet) {
            break;
        }

    }

    dwReturned = i;

    dwRet = ComputeWinNTGroupDataSize(
                    ppGroup,
                    dwReturned,
                    &dwSize
                    );

    pBuffer = (LPWINNT_GROUP)AllocADsMem(
                        dwSize
                        );

    if (pBuffer) {

        fretVal = TRUE;
        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniWinNTGroupToWinNTGroup(
                            ppGroup[i],
                            (LPBYTE)(pBuffer + i),
                            pEnd
                            );
        }
    }

    for (i = 0; i < dwReturned; i++ ) {
        FreeIntWinNTGroup(*(ppGroup + i));
    }

    FreeADsMem(ppGroup);

    //
    // Will correctly assign to NULL if alloc failed.
    //
    *ppBuffer = (LPBYTE)pBuffer;
    *pdwReturned  = fretVal ? dwReturned : 0;

    if (!fretVal) {
        return(FALSE);
    }

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }
}


BOOL
WinNTComputerGetLocalGroup(
    HANDLE hComputer,
    LPWINNT_GROUP * ppGroup
    )
{
    BOOL dwRet = FALSE;
    PINICOMPUTER pIniComp = (PINICOMPUTER)hComputer;
    NET_API_STATUS nasStatus = 0;
    LPGROUP_INFO_0 pGroupInfo0 = NULL;

    if ((!pIniComp->_pBuffer) ||
        (pIniComp->_dwCurrentObject == pIniComp->_dwObjectReturned)) {

        if (pIniComp->_bNoMore) {

            //
            // No more objects to return
            //
            return(FALSE);
        }

        if (pIniComp->_pBuffer) {
            NetApiBufferFree(pIniComp->_pBuffer);
            pIniComp->_pBuffer = NULL;
        }

        pIniComp->_dwObjectReturned = 0;
        pIniComp->_dwCurrentObject = 0;
        pIniComp->_dwTotalObjects = 0;

        nasStatus = NetLocalGroupEnum(
                            pIniComp->szUncCompName,
                            0,
                            &pIniComp->_pBuffer,
                            MAX_PREFERRED_LENGTH,
                            &pIniComp->_dwObjectReturned,
                            &pIniComp->_dwTotalObjects,
                            &pIniComp->_dwResumeHandle
                            );
        if ((nasStatus != ERROR_SUCCESS) && (nasStatus != ERROR_MORE_DATA)){
            SetLastError(nasStatus);
            return(FALSE);
        }

        if (nasStatus != ERROR_MORE_DATA) {
            pIniComp->_bNoMore = TRUE;
        }


        pGroupInfo0 = (LPGROUP_INFO_0) pIniComp->_pBuffer;

        if ( (!pIniComp->_dwObjectReturned)) {

            //
            // We get success code (ERROR_SUCCESS) but the buffer was NULL:
            // -> no global group was enumerated from the svr
            //

            return(FALSE);
        }

        // we will never get none group as a local group

    }

    dwRet = BuildWinNTGroupFromLocalGroup(
                hComputer,
                (LPBYTE)((LPLOCALGROUP_INFO_0)pIniComp->_pBuffer + pIniComp->_dwCurrentObject),
                ppGroup
                );
    if (!dwRet) {
        goto error;
    }

    pIniComp->_dwCurrentObject++;

    return(TRUE);

error:

    return(FALSE);
}


LPBYTE
CopyIniWinNTGroupToWinNTGroup(
    LPWINNT_GROUP  pIntGrp,
    LPBYTE  pExtGrp,
    LPBYTE  pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(WINNT_GROUP)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings=SourceStrings;
    LPWINNT_GROUP pWinNTGrp = (LPWINNT_GROUP)pExtGrp;

    memset(SourceStrings, 0, sizeof(WINNT_GROUP));
    *pSourceStrings++ = pIntGrp->Parent;
    *pSourceStrings++ = pIntGrp->Computer;
    *pSourceStrings++ = pIntGrp->Domain;
    *pSourceStrings++ = pIntGrp->Name;

    pEnd = PackStrings(
                SourceStrings,
                pExtGrp,
                WinNTGroupStrings,
                pEnd
                );

    pWinNTGrp->Type = pIntGrp->Type;

    return pEnd;
}

BOOL
BuildWinNTGroupFromGlobalGroup(
    HANDLE hComputer,
    LPBYTE lpBuffer,
    LPWINNT_GROUP * ppGroup
    )
{
    LPINICOMPUTER pComputer = (LPINICOMPUTER)hComputer;
    LPWINNT_GROUP pGroup = NULL;
    PGROUP_INFO_2 pGrp = (PGROUP_INFO_2)lpBuffer;
    WCHAR szADsParent[MAX_PATH];
    LPWSTR pMemberName = NULL;
    DWORD cblen = 0;

    pGroup = (LPWINNT_GROUP)AllocADsMem(
                                       sizeof(WINNT_GROUP)
                                       );
    if (!pGroup) {
        return(FALSE);
    }

    //
    // Begin Global Group -> WinNT Group Mapping
    //

    pGroup->Name = AllocADsStr(pGrp->grpi2_name);
    pGroup->Computer = AllocADsStr(pComputer->szComputerName);
    pGroup->Domain = AllocADsStr(pComputer->szDomainName);

    if (pComputer->uGroupParent == WINNT_DOMAIN_ID) {
        wsprintf(
            szADsParent,
            L"%s://%s",
            szProviderName,
            pComputer->szDomainName
            );

    }else {
        wsprintf(
            szADsParent,
            L"%s://%s/%s",
            szProviderName,
            pComputer->szDomainName,
            pComputer->szComputerName
            );
    }
    pGroup->Parent = AllocADsStr(szADsParent);
    pGroup->Type = WINNT_GROUP_GLOBAL;


    //
    //  End Global Group -> WinNT Group Mapping
    //

    *ppGroup =  pGroup;
    return(TRUE);

// error:

    return(FALSE);

}


BOOL
BuildWinNTGroupFromLocalGroup(
    HANDLE hComputer,
    LPBYTE lpBuffer,
    LPWINNT_GROUP * ppGroup
    )
{
    LPINICOMPUTER pComputer = (LPINICOMPUTER)hComputer;
    LPWINNT_GROUP pGroup = NULL;
    LPLOCALGROUP_INFO_0 pGrp = (LPLOCALGROUP_INFO_0)lpBuffer;
    WCHAR szADsParent[MAX_PATH];
    LPWSTR pMemberName = NULL;
    DWORD cblen = 0;

    pGroup = (LPWINNT_GROUP)AllocADsMem(
                                       sizeof(WINNT_GROUP)
                                       );
    if (!pGroup) {
        return(FALSE);
    }


    //
    // Begin Local Group -> WinNT Group Mapping
    //

    pGroup->Name = AllocADsStr(pGrp->lgrpi0_name);
    pGroup->Computer = AllocADsStr(pComputer->szComputerName);
    pGroup->Domain = AllocADsStr(pComputer->szDomainName);

    if (pComputer->uGroupParent == WINNT_DOMAIN_ID) {
        wsprintf(
            szADsParent,
            L"%s://%s",
            szProviderName,
            pComputer->szDomainName
            );

    }else {
        if (pComputer->szDomainName !=NULL) {

            wsprintf(
                szADsParent,
                L"%s://%s/%s",
                szProviderName,
                pComputer->szDomainName,
                pComputer->szComputerName
                );
        } else {
            // This is a case where domain is null, the
            // workstation service has not been started
            wsprintf(
                szADsParent,
                L"%s://%s",
                szProviderName,
                pComputer->szComputerName
                );
        }
    }
    pGroup->Parent = AllocADsStr(szADsParent);
    pGroup->Type = WINNT_GROUP_LOCAL;


    //
    //  End Local Group -> WinNT Group Mapping
    //


    *ppGroup =  pGroup;
    return(TRUE);


// error:

    return(FALSE);

}


BOOL
ComputeWinNTGroupDataSize(
    LPWINNT_GROUP * ppGroups,
    DWORD  dwReturned,
    PDWORD pdwSize
    )
{

    DWORD i = 0;
    DWORD cb = 0;
    LPWINNT_GROUP pGroup = NULL;

    for (i = 0; i < dwReturned; i++) {

        pGroup = *(ppGroups + i);

        cb += sizeof(WINNT_GROUP);

        if (pGroup->Parent) {
            cb += wcslen(pGroup->Parent)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pGroup->Computer) {
            cb += wcslen(pGroup->Computer)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pGroup->Domain) {
            cb += wcslen(pGroup->Domain)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pGroup->Name) {
            cb += wcslen(pGroup->Name)*sizeof(WCHAR) + sizeof(WCHAR);
        }
    }

    *pdwSize = cb;
    return(TRUE);
}



BOOL
WinNTCloseComputer(
    HANDLE hComputer
    )
{
    PINICOMPUTER pIniComputer = (PINICOMPUTER)hComputer;

    if (pIniComputer) {
        FreeIniComputer(pIniComputer);
    }
    return(TRUE);
}


void
FreeIniComputer(
    PINICOMPUTER pIniComputer
    )
{

    if (pIniComputer->szDomainName) {

        FreeADsStr(pIniComputer->szDomainName);
    }

    if (pIniComputer->szComputerName) {

        FreeADsStr(pIniComputer->szComputerName);
    }


    if (pIniComputer->szUncCompName) {

        FreeADsStr(pIniComputer->szUncCompName);
    }


    if (pIniComputer->_pBuffer) {
        NetApiBufferFree(pIniComputer->_pBuffer);
    }

    FreeADsMem(pIniComputer);

    return;
}

void
FreeIntWinNTGroup(
    LPWINNT_GROUP pGroup
    )
{
    if (pGroup->Parent) {

        FreeADsStr(pGroup->Parent);
    }

    if (pGroup->Computer) {

        FreeADsStr(pGroup->Computer);
    }


    if (pGroup->Domain) {

        FreeADsStr(pGroup->Domain);
    }


    if (pGroup->Name) {

        FreeADsStr(pGroup->Name);
    }


    if (pGroup) {

        FreeADsMem(pGroup);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\nt2ods.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nw2ods.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------
#include "winnt.hxx"
#pragma  hdrstop


HRESULT
NTTypeToAdsTypeCopyString(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNtSrcObject->NTValue.pszValue
                                );
    RRETURN(hr);
}



HRESULT
NTTypeToAdsTypeCopyBoolean(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean =
                        lpNtSrcObject->NTValue.fValue;

    RRETURN(hr);
}


HRESULT
NTTypeToAdsTypeCopyInteger(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNtSrcObject->NTValue.dwValue;

    RRETURN(hr);

}


HRESULT
NTTypeToAdsTypeCopyOctetString(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    DWORD dwLen = 0;

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwLen = lpNtSrcObject->NTValue.octetstring.dwSize;

    lpAdsDestValue->OctetString.dwLength = dwLen;

    if (lpNtSrcObject->NTValue.octetstring.pByte) {

        lpAdsDestValue->OctetString.lpValue = (LPBYTE) AllocADsMem(dwLen);

        if (!lpAdsDestValue->OctetString.lpValue) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memcpy(
            lpAdsDestValue->OctetString.lpValue,
            lpNtSrcObject->NTValue.octetstring.pByte,
            dwLen
            );
    }
    else {
        lpAdsDestValue->OctetString.lpValue = NULL;
    }

error:

    RRETURN(hr);

}

HRESULT
NTTypeToAdsTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {

    case NT_SYNTAX_ID_BOOL:
        hr = NTTypeToAdsTypeCopyBoolean(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = NTTypeToAdsTypeCopyInteger(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = NTTypeToAdsTypeCopyString(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;
        
    case NT_SYNTAX_ID_DelimitedString:
        hr = NTTypeToAdsTypeCopyString(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = NTTypeToAdsTypeCopyOctetString(
                 lpNtSrcObject,
                 lpAdsDestValue
                 );
        break;
    /*
    case NT_SYNTAX_ID_SYSTEMTIME:
    case NT_SYNTAX_ID_DATE:
    case NT_SYNTAX_ID_NW312TIME:
        hr = NTTypeToAdsTypeCopyNDSSynId4(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = NTTypeToAdsTypeCopyNDSSynId5(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;
    */

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
NTTypeToAdsTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    LPADSVALUE * ppAdsDestValues
    )
{

    DWORD i = 0;
    LPADSVALUE pAdsDestValues = NULL;
    HRESULT hr = S_OK;

    if (!dwNumObjects) {
        *ppAdsDestValues = NULL;
        RRETURN(S_OK);
    }

    pAdsDestValues = (LPADSVALUE)AllocADsMem(
                                    dwNumObjects * sizeof(ADSVALUE)
                                    );

    if (!pAdsDestValues) {
        RRETURN(E_OUTOFMEMORY);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = NTTypeToAdsTypeCopy(
                    pNtSrcObjects + i,
                    pAdsDestValues + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppAdsDestValues = pAdsDestValues;

     RRETURN(S_OK);

error:

     if (pAdsDestValues) {
        AdsFreeAdsValues(
            pAdsDestValues,
            dwNumObjects
            );
        FreeADsMem(pAdsDestValues);
     }

     *ppAdsDestValues = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\winnt\macro.h ===
#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}




#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(GetInfo());                                               \
}





#define DEFINE_IADs_TempImplementation(cls)                           \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(GetInfo());                                               \
}





#define DEFINE_IADs_PutGetImplementation(cls, SchemaClassTable, dwTableSize)                   \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericGetPropertyManager(                                   \
                _pPropertyCache,                                      \
                bstrName,                                             \
                pvProp                                                \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericPutPropertyManager(                                   \
                _pPropertyCache,                                      \
                SchemaClassTable,                                     \
                dwTableSize,                                          \
                bstrName,                                             \
                vProp                                                 \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericGetExPropertyManager(                                 \
                GetObjectState(),                                     \
                _pPropertyCache,                                      \
                bstrName,                                             \
                pvProp                                                \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericPutExPropertyManager(                                 \
                _pPropertyCache,                                      \
                SchemaClassTable,                                     \
                dwTableSize,                                          \
                bstrName,                                             \
                vProp                                                 \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}

#define DEFINE_IADsPropertyList_Implementation(cls, SchemaClassTable, dwTableSize)                 \
STDMETHODIMP                                                                                       \
cls::get_PropertyCount(THIS_ long  FAR * plCount)                                                  \
{                                                                                                  \
    HRESULT hr = E_FAIL;                                                                           \
                                                                                                   \
    hr = GenericPropCountPropertyManager(                                                          \
                _pPropertyCache,                                                                   \
                plCount                                                                            \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Next(THI