NT CchMsiPcwPropertyString ( MSIHANDLE hdb, LPTSTR szName )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szName));

	return (CchMsiTableString(hdb, TEXT("`Properties`"),
			TEXT("`Name`"), TEXT("`Value`"), szName));
}


/* ********************************************************************** */
UINT IdsMsiGetPcwPropertyString ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue, UINT cch )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szName));
	Assert(szValue != szNull);
	Assert(cch > 1);

	return (IdsMsiGetTableString(hdb, TEXT("`Properties`"),
			TEXT("`Name`"), TEXT("`Value`"), szName, szValue, cch));
}


/* ********************************************************************** */
UINT IdsMsiGetPcwPropertyInteger ( MSIHANDLE hdb, LPTSTR szName, int * pi )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szName));
	Assert(pi != (int*)NULL);

	TCHAR rgch[MAX_PATH];
	UINT  idsRet = IdsMsiGetPcwPropertyString(hdb, szName, rgch, sizeof(rgch)/sizeof(TCHAR));
	if (idsRet != IDS_OKAY)
		return (idsRet);

	LPTSTR sz = rgch;

	BOOL fNegative = fFalse;
	if (*sz == TEXT('-'))
		{
		fNegative = fTrue;
		sz = CharNext(sz);
		}
	
	*pi = 0;
	while (*sz != TEXT('\0') && *sz >= TEXT('0') && *sz <= TEXT('9'))
		{
		*pi = (*pi * 10) + (UINT)(*sz - TEXT('0'));
		sz = CharNext(sz);
		}

	if (fNegative)
		*pi = *pi * (-1);

	return (IDS_OKAY);
}


/* ********************************************************************** */
UINT IdsMsiSetPcwPropertyString ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szName));
	Assert(!FEmptySz(szValue));

	MSIHANDLE hrec = MsiCreateRecord(2);
	if (hrec == NULL)
		return (IDS_CANT_CREATE_RECORD);

	if (MsiRecordSetString(hrec, 1, szName) != MSI_OKAY
			|| MsiRecordSetString(hrec, 2, szValue) != MSI_OKAY)
		{
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
		return (IDS_CANT_SET_RECORD_FIELD);
		}

	return (IdsMsiSetTableRecord(hdb, TEXT("`Properties`"), TEXT("`Name`,`Value`"), TEXT("`Name`"), szName, hrec));
}



static BOOL FSzColumnExists     ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, BOOL fMsg );
static BOOL FIntColumnExists    ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, BOOL fMsg );
static BOOL FBinaryColumnExists ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, LPTSTR szPKey, BOOL fMsg );

#define TableExists(szT)  if (!FTableExists(hdb,szT,fTrue))             return (fFalse); szTable = szT
#define SzColExists(szC)  if (!FSzColumnExists(hdb,szTable,szC,fTrue))  return (fFalse)
#define IntColExists(szC) if (!FIntColumnExists(hdb,szTable,szC,fTrue)) return (fFalse)

static BOOL FCopyRecordsFromFileDataToUFOD ( MSIHANDLE hdb );

/* ********************************************************************** */
static BOOL FValidateInputMsiSchema ( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	LPTSTR szTable;

	TableExists (TEXT("Properties"));
	SzColExists (TEXT("Name"));
	SzColExists (TEXT("Value"));

	TableExists (TEXT("ImageFamilies"));
	SzColExists (TEXT("Family"));
	SzColExists (TEXT("MediaSrcPropName"));
	IntColExists(TEXT("MediaDiskId"));
	IntColExists(TEXT("FileSequenceStart"));
	if (!FSzColumnExists(hdb, szTable, TEXT("DiskPrompt"), fFalse))
		{
		if (!FAddColumnToTable(hdb, szTable, TEXT("`DiskPrompt`"), STRING, PERSIST))
			return (fFalse);
		}
	if (!FSzColumnExists(hdb, szTable, TEXT("VolumeLabel"), fFalse))
		{
		if (!FAddColumnToTable(hdb, szTable, TEXT("`VolumeLabel`"), STRING, PERSIST))
			return (fFalse);
		}

	TableExists (TEXT("UpgradedImages"));
	SzColExists (TEXT("Upgraded"));
	SzColExists (TEXT("MsiPath"));
	SzColExists (TEXT("Family"));
	if (!FSzColumnExists(hdb, szTable, TEXT("PatchMsiPath"), fFalse))
		{
		if (!FAddColumnToTable(hdb, szTable, TEXT("`PatchMsiPath`"), STRING, PERSIST))
			return (fFalse);
		}
	if (!FSzColumnExists(hdb, szTable, TEXT("SymbolPaths"), fFalse))
		{
		if (!FAddColumnToTable(hdb, szTable, TEXT("`SymbolPaths`"), STRING, PERSIST))
			return (fFalse);
		}

	TableExists (TEXT("TargetImages"));
	SzColExists (TEXT("Target"));
	SzColExists (TEXT("MsiPath"));
	SzColExists (TEXT("Upgraded"));
	IntColExists(TEXT("Order"));
	SzColExists (TEXT("ProductValidateFlags"));
	if (!FSzColumnExists(hdb, szTable, TEXT("SymbolPaths"), fFalse))
		{
		if (!FAddColumnToTable(hdb, szTable, TEXT("`SymbolPaths`"), STRING, PERSIST))
			return (fFalse);
		}
	if (!FIntColumnExists(hdb, szTable, TEXT("IgnoreMissingSrcFiles"), fFalse))
		{
		if (!FAddColumnToTable(hdb, szTable, TEXT("`IgnoreMissingSrcFiles`"), INTEGER, PERSIST))
			return (fFalse);
		}

	if (FTableExists(hdb, TEXT("ExternalFiles"), fFalse))
		{
		szTable = TEXT("ExternalFiles");
		SzColExists (TEXT("Family"));
		SzColExists (TEXT("FTK"));
		SzColExists (TEXT("FilePath"));
		if (!FIntColumnExists(hdb, szTable, TEXT("Order"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`Order`"), INTEGER, PERSIST))
				return (fFalse);
			}
		if (!FSzColumnExists(hdb, szTable, TEXT("SymbolPaths"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`SymbolPaths`"), STRING, PERSIST))
				return (fFalse);
			}
		if (!FSzColumnExists(hdb, szTable, TEXT("IgnoreOffsets"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`IgnoreOffsets`"), STRING, PERSIST))
				return (fFalse);
			}
		if (!FSzColumnExists(hdb, szTable, TEXT("IgnoreLengths"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`IgnoreLengths`"), STRING, PERSIST))
				return (fFalse);
			}
		if (!FSzColumnExists(hdb, szTable, TEXT("RetainOffsets"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`RetainOffsets`"), STRING, PERSIST))
				return (fFalse);
			}
		}
	else if (!FExecSqlCmd(hdb, TEXT("CREATE TABLE `ExternalFiles` ( `Family` CHAR(13) NOT NULL, `FTK` CHAR(128) NOT NULL, `FilePath` CHAR(128) NOT NULL, `SymbolPaths` CHAR(128), `IgnoreOffsets` CHAR(128), `IgnoreLengths` CHAR(128), `RetainOffsets` CHAR(128), `Order` INTEGER PRIMARY KEY `Family`, `FTK`, `FilePath` )")))
		return (fFalse);

	if (FTableExists(hdb, TEXT("UpgradedFiles_OptionalData"), fFalse))
		{
		szTable = TEXT("UpgradedFiles_OptionalData");
		SzColExists (TEXT("Upgraded"));
		SzColExists (TEXT("FTK"));
		SzColExists (TEXT("SymbolPaths"));
		if (FIntColumnExists(hdb, szTable, TEXT("IgnoreErrors"), fFalse))
			{
#ifdef DEBUG
			OutputDebugString(TEXT("The IgnoreErrors column has been dropped from the UpgradedFiles_OptionalData table; ignoring column in current PCP.  Use 'AllowIgnoreOnPatchError' column."));
#endif /* DEBUG */
			FWriteLogFile(TEXT("  WARNING - ignoring 'IgnoreErrors' column in UpgradedFiles_OptionalData table.\r\n"));
			if (!FIntColumnExists(hdb, szTable, TEXT("AllowIgnoreOnPatchError"), fFalse))
				{
				if (!FAddColumnToTable(hdb, szTable, TEXT("`AllowIgnoreOnPatchError`"), INTEGER, PERSIST))
					return (fFalse);
				}
			}
		else
			IntColExists(TEXT("AllowIgnoreOnPatchError"));
		IntColExists(TEXT("IncludeWholeFile"));
		if (FTableExists(hdb, TEXT("FileData"), fFalse))
			return (fFalse);
		}
	else if (!FExecSqlCmd(hdb, TEXT("CREATE TABLE `UpgradedFiles_OptionalData` ( `Upgraded` CHAR(13) NOT NULL, `FTK` CHAR(128) NOT NULL, `SymbolPaths` CHAR(128), `AllowIgnoreOnPatchError` INTEGER, `IncludeWholeFile` INTEGER PRIMARY KEY `Upgraded`, `FTK` )")))
		return (fFalse);
	else if (FTableExists(hdb, TEXT("FileData"), fFalse))
		{
		szTable = TEXT("FileData");
		SzColExists (TEXT("Upgraded"));
		SzColExists (TEXT("FTK"));
		IntColExists(TEXT("AllowIgnoreOnPatchError"));
		if (!FSzColumnExists(hdb, szTable, TEXT("SymbolPaths"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`SymbolPaths`"), STRING, PERSIST))
				return (fFalse);
			}
		if (!FIntColumnExists(hdb, szTable, TEXT("IncludeWholeFile"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`IncludeWholeFile`"), INTEGER, PERSIST))
				return (fFalse);
			}
		if (!FCopyRecordsFromFileDataToUFOD(hdb))
			return (fFalse);
		if (!FExecSqlCmd(hdb, TEXT("DROP TABLE `FileData`")))
			return (fFalse);
		}

	if (FTableExists(hdb, TEXT("UpgradedFilesToIgnore"), fFalse))
		{
		szTable = TEXT("UpgradedFilesToIgnore");
		SzColExists (TEXT("Upgraded"));
		SzColExists (TEXT("FTK"));
		}
	else if (!FExecSqlCmd(hdb, TEXT("CREATE TABLE `UpgradedFilesToIgnore` ( `Upgraded` CHAR(13) NOT NULL, `FTK` CHAR(128) NOT NULL PRIMARY KEY `Upgraded`, `FTK` )")))
		return (fFalse);

	if (FTableExists(hdb, TEXT("TargetFiles_OptionalData"), fFalse))
		{
		szTable = TEXT("TargetFiles_OptionalData");
		SzColExists (TEXT("Target"));
		SzColExists (TEXT("FTK"));
		SzColExists (TEXT("SymbolPaths"));
		if (!FSzColumnExists(hdb, szTable, TEXT("IgnoreOffsets"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`IgnoreOffsets`"), STRING, PERSIST))
				return (fFalse);
			}
		if (!FSzColumnExists(hdb, szTable, TEXT("IgnoreLengths"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`IgnoreLengths`"), STRING, PERSIST))
				return (fFalse);
			}
		if (!FSzColumnExists(hdb, szTable, TEXT("RetainOffsets"), fFalse))
			{
			if (!FAddColumnToTable(hdb, szTable, TEXT("`RetainOffsets`"), STRING, PERSIST))
				return (fFalse);
			}
		}
	else if (!FExecSqlCmd(hdb, TEXT("CREATE TABLE `TargetFiles_OptionalData` ( `Target` CHAR(13) NOT NULL, `FTK` CHAR(128) NOT NULL, `SymbolPaths` CHAR(128), `IgnoreOffsets` CHAR(128), `IgnoreLengths` CHAR(128), `RetainOffsets` CHAR(128) PRIMARY KEY `Target`, `FTK` )")))
		return (fFalse);

	if (FTableExists(hdb, TEXT("FamilyFileRanges"), fFalse))
		{
		szTable = TEXT("FamilyFileRanges");
		SzColExists (TEXT("Family"));
		SzColExists (TEXT("FTK"));
		SzColExists (TEXT("RetainOffsets"));
		SzColExists (TEXT("RetainLengths"));
		}
	else if (!FExecSqlCmd(hdb, TEXT("CREATE TABLE `FamilyFileRanges` ( `Family` CHAR(13) NOT NULL, `FTK` CHAR(128) NOT NULL, `RetainOffsets` CHAR(128), `RetainLengths` CHAR(128) PRIMARY KEY `Family`, `FTK` )")))
		return (fFalse);

	return (fTrue);
}


/* ********************************************************************** */
BOOL FTableExists ( MSIHANDLE hdb, LPTSTR szTable, BOOL fMsg )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));

	MSIHANDLE hrec;
	UINT ids = MsiDatabaseGetPrimaryKeys(hdb, szTable, &hrec);
	if (ids == IDS_OKAY && hrec != NULL)
		{
		EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
		return (fTrue);
		}

#ifdef DEBUG
	if (fMsg)
		{
		TCHAR rgch[256];
		wsprintf(rgch, TEXT("Input-Msi is missing a table: '%s'."), szTable);
		OutputDebugString(rgch);
		}
#endif

	return (fFalse);
}


/* ********************************************************************** */
static BOOL FSzColumnExists ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, BOOL fMsg )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szColumn));

	TCHAR rgchTable[MAX_PATH];
	wsprintf(rgchTable, TEXT("`%s`"), szTable);

	TCHAR rgchColumn[MAX_PATH];
	wsprintf(rgchColumn, TEXT("`%s`"), szColumn);
	
	BOOL fExist = fFalse;
	UINT ids = IdsMsiExistTableRecords(hdb, rgchTable,
			rgchColumn, TEXT("bogus_value"), &fExist);

#ifdef DEBUG
	if (fMsg && ids != IDS_OKAY)
		{
		TCHAR rgch[256];
		wsprintf(rgch, TEXT("Input-Msi table '%s' is missing a string column: '%s'."), szTable, szColumn);
		OutputDebugString(rgch);
		}
#endif

	return (ids == IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FIntColumnExists ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, BOOL fMsg )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szColumn));

	TCHAR rgchTable[MAX_PATH];
	wsprintf(rgchTable, TEXT("`%s`"), szTable);

	TCHAR rgchColumn[MAX_PATH];
	wsprintf(rgchColumn, TEXT("`%s`"), szColumn);
	
	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("WHERE `%s` = 7"), szColumn);
	
	BOOL fExist = fFalse;
	UINT ids = IdsMsiExistTableRecordsWhere(hdb, rgchTable,
			rgchColumn, rgchWhere, &fExist);

#ifdef DEBUG
	if (fMsg && ids != IDS_OKAY)
		{
		TCHAR rgch[256];
		wsprintf(rgch, TEXT("Input-Msi table '%s' is missing an integer column: '%s'."), szTable, szColumn);
		OutputDebugString(rgch);
		}
#endif

	return (ids == IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FBinaryColumnExists ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szColumn, LPTSTR szPKey, BOOL fMsg )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szColumn));
	Assert(!FEmptySz(szPKey));

	TCHAR rgchTable[MAX_PATH];
	wsprintf(rgchTable, TEXT("`%s`"), szTable);

	TCHAR rgchColumn[MAX_PATH];
	wsprintf(rgchColumn, TEXT("`%s`"), szColumn);
	
	
	TCHAR rgchWhere[MAX_PATH];
	wsprintf(rgchWhere, TEXT("WHERE `%s` = 'foo'"), szPKey);
	
	BOOL fExist = fFalse;
	UINT ids = IdsMsiExistTableRecordsWhere(hdb, rgchTable,
			rgchColumn, rgchWhere, &fExist);

#ifdef DEBUG
	if (fMsg && ids != IDS_OKAY)
		{
		TCHAR rgch[256];
		wsprintf(rgch, TEXT("Input-Msi table '%s' is missing a binary column: '%s'."), szTable, szColumn);
		OutputDebugString(rgch);
		}
#endif

	return (ids == IDS_OKAY);
}


static UINT IdsCopyRecordsFromFileDataToUFOD ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FCopyRecordsFromFileDataToUFOD ( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	return (IDS_OKAY == IdsMsiEnumTable(hdb, TEXT("`FileData`"),
				TEXT("`Upgraded`,`FTK`,`SymbolPaths`,`IgnoreErrors`,`IncludeWholeFile`"),
				szNull, IdsCopyRecordsFromFileDataToUFOD, (LPARAM)(hdb), 0L) );
}


/* ********************************************************************** */
static UINT IdsCopyRecordsFromFileDataToUFOD ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	MSIHANDLE hdb = (MSIHANDLE)lp1;
	Assert(hdb != NULL);

	TCHAR rgchUpgradedImage[64];
	DWORD dwcch = 64;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchUpgradedImage, &dwcch);
	if (uiRet != MSI_OKAY || FEmptySz(rgchUpgradedImage))
		return (IDS_CANCEL);

	TCHAR rgchFTK[128];
	dwcch = 128;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	if (uiRet != MSI_OKAY || FEmptySz(rgchFTK))
		return (IDS_CANCEL);

	TCHAR rgchSymbolPaths[MAX_PATH+MAX_PATH];
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchSymbolPaths, &dwcch);
	if (uiRet != MSI_OKAY)
		return (IDS_CANCEL);

	TCHAR rgchIgnoreErrors[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 4, rgchIgnoreErrors, &dwcch);
	if (uiRet != MSI_OKAY || FEmptySz(rgchIgnoreErrors))
		return (IDS_CANCEL);

	TCHAR rgchIncludeWholeFile[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 5, rgchIncludeWholeFile, &dwcch);
	if (uiRet != MSI_OKAY)
		return (IDS_CANCEL);
	if (FEmptySz(rgchIncludeWholeFile))
		lstrcpy(rgchIncludeWholeFile, TEXT("0"));

	TCHAR rgchQuery[MAX_PATH+MAX_PATH+MAX_PATH];
	wsprintf(rgchQuery, TEXT("INSERT INTO `UpgradedFiles_OptionalData` ( `Upgraded`, `FTK`, `SymbolPaths`, `AllowIgnoreOnPatchError`, `IncludeWholeFile` ) VALUES ( '%s', '%s', '%s', %s, %s )"),
			rgchUpgradedImage, rgchFTK, rgchSymbolPaths, rgchIgnoreErrors, rgchIncludeWholeFile);
	if (!FExecSqlCmd(hdb, rgchQuery))
		return (IDS_CANCEL);

	return (IDS_OKAY);
}




static MSIHANDLE hdbInput = NULL;

static UINT UiValidateAndLogPCWProperties  ( MSIHANDLE hdbInput, LPTSTR szPcpPath, LPTSTR szPatchPath, LPTSTR szTempFolder, LPTSTR szTempFName );
static int  IGetOrderMax                   ( MSIHANDLE hdbInput );
static UINT IdsValidateFamilyRecords       ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateFamilyRangeRecords  ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateUpgradedRecords     ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateTargetRecords       ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateExternalFileRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateUFileDataRecords    ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateUFileIgnoreRecords  ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsValidateTFileDataRecords    ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

static UINT IdsValidateTargetProductCodesAgainstList ( MSIHANDLE hdb );

static BOOL FNoUpgradedImages                  ( MSIHANDLE hdb );
static BOOL FCheckForProductCodeMismatches     ( MSIHANDLE hdb );
static BOOL FCheckForProductVersionMismatches  ( MSIHANDLE hdb );
static BOOL FCheckForProductCodeMismatchWithVersionMatch (MSIHANDLE hdb );
static void FillInListOfTargetProductCodes     ( MSIHANDLE hdb );

/* ********************************************************************** */
UINT UiValidateInputRecords ( MSIHANDLE hdb, LPTSTR szPcpPath, LPTSTR szPatchPath, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szPcpPath));
	Assert(FFileExist(szPcpPath));
	Assert(!FEmptySz(szPatchPath));
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);

	UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, szEmpty, szEmpty);
	UpdateStatusMsg(0, TEXT("Table: Properties"), szNull);
	UINT ids = UiValidateAndLogPCWProperties(hdb, szPcpPath, szPatchPath, szTempFolder, szTempFName);
	if (ids != IDS_OKAY)
		return (ids);

	hdbInput = hdb;

	iOrderMax = IGetOrderMax(hdbInput);
	Assert(iOrderMax > 0);

	UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, TEXT("Table: ImageFamilies"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`ImageFamilies`"),
					TEXT("`Family`,`MediaSrcPropName`,`MediaDiskId`,`FileSequenceStart`"),
					szNull, IdsValidateFamilyRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, TEXT("Table: FamilyFileRanges"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`FamilyFileRanges`"),
					TEXT("`Family`,`FTK`,`RetainOffsets`,`RetainLengths`,`RetainCount`"),
					szNull, IdsValidateFamilyRangeRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, TEXT("Table: UpgradedImages"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`,`MsiPath`,`Family`,`PatchMsiPath`"),
					szNull, IdsValidateUpgradedRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(0, TEXT("Table: TargetImages"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`MsiPath`,`Upgraded`,`ProductValidateFlags`,`Order`,`IgnoreMissingSrcFiles`"),
					szNull, IdsValidateTargetRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(0, TEXT("Table: ExternalFiles"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`ExternalFiles`"),
					TEXT("`Family`,`FTK`,`FilePath`,`Order`,`IgnoreOffsets`,`IgnoreLengths`,`RetainOffsets`,`IgnoreCount`"),
					szNull, IdsValidateExternalFileRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(0, TEXT("Table: UpgradedFiles_OptionalData"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`UpgradedFiles_OptionalData`"),
					TEXT("`Upgraded`,`FTK`,`IncludeWholeFile`"),
					szNull, IdsValidateUFileDataRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(0, TEXT("Table: UpgradedFilesToIgnore"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`UpgradedFilesToIgnore`"),
					TEXT("`Upgraded`,`FTK`"),
					szNull, IdsValidateUFileIgnoreRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(0, TEXT("Table: TargetFiles_OptionalData"), szEmpty);
	ids = IdsMsiEnumTable(hdb, TEXT("`TargetFiles_OptionalData`"),
					TEXT("`Target`,`FTK`,`IgnoreOffsets`,`IgnoreLengths`,`RetainOffsets`,`IgnoreCount`"),
					szNull, IdsValidateTFileDataRecords, 0L, 0L);
	if (ids != IDS_OKAY)
		return (ids);

	UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, TEXT("Table: UpgradedImages"), szEmpty);
	if (FNoUpgradedImages(hdb))
		return (UiLogError(ERROR_PCW_NO_UPGRADED_IMAGES_TO_PATCH, NULL, NULL));
	
	if (!FCheckForProductCodeMismatches(hdb))
		return (UiLogError(ERROR_PCW_MISMATCHED_PRODUCT_CODES, NULL, NULL));
	if (!FCheckForProductVersionMismatches(hdb))
		return (UiLogError(ERROR_PCW_MISMATCHED_PRODUCT_VERSIONS, NULL, NULL));
	if (!FCheckForProductCodeMismatchWithVersionMatch(hdb))
		return (UiLogError(ERROR_PCW_MATCHED_PRODUCT_VERSIONS, NULL, NULL));

	FillInListOfTargetProductCodes(hdb);

	ids = IdsValidateTargetProductCodesAgainstList(hdb);
	if (ids != IDS_OKAY)
		return (ids);

	return (ERROR_SUCCESS);
}


static UINT IdsGetMaxOrder ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static int IGetOrderMax ( MSIHANDLE hdbInput )
{
	Assert(hdbInput != NULL);

	int iMax = 0;

	EvalAssert( IDS_OKAY == IdsMsiEnumTable(hdbInput, TEXT("`TargetImages`"),
					TEXT("`Order`"), szNull, IdsGetMaxOrder, (LPARAM)(&iMax), 0L) );
	EvalAssert( IDS_OKAY == IdsMsiEnumTable(hdbInput, TEXT("`ExternalFiles`"),
					TEXT("`Order`"), szNull, IdsGetMaxOrder, (LPARAM)(&iMax), 0L) );

	return (iMax+1);
}


/* ********************************************************************** */
static UINT IdsGetMaxOrder ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0L);

	int* piMax = (int*)lp1;
	Assert(piMax != NULL);
	Assert(*piMax >= 0);

	int iOrder = MsiRecordGetInteger(hrec, 1);
	if (iOrder != MSI_NULL_INTEGER && iOrder > *piMax)
		*piMax = iOrder;

	return (IDS_OKAY);
}


static BOOL FValidName         ( LPTSTR sz, int cchMax );
#define FValidFamilyName(sz)   FValidName(sz,MAX_LENGTH_IMAGE_FAMILY_NAME)
#define FValidImageName(sz)    FValidName(sz,MAX_LENGTH_TARGET_IMAGE_NAME)

static BOOL FUniqueImageName   ( LPTSTR sz, MSIHANDLE hdbInput );
static BOOL FUniquePackageCode ( LPTSTR sz, MSIHANDLE hdbInput );
static BOOL FValidPropertyName ( LPTSTR sz );
static BOOL FValidDiskId       ( LPTSTR sz );

/* ********************************************************************** */
static UINT IdsValidateFamilyRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchFamily[MAX_LENGTH_IMAGE_FAMILY_NAME + 1];
	DWORD dwcch = MAX_LENGTH_IMAGE_FAMILY_NAME + 1;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchFamily, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_IMAGE_FAMILY_NAME_TOO_LONG, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ImageFamilies.Family"), szNull));

	UpdateStatusMsg(0, 0, rgchFamily);

	if (!FValidFamilyName(rgchFamily))
		return (UiLogError(ERROR_PCW_BAD_IMAGE_FAMILY_NAME, rgchFamily, szNull));

	if (!FUniqueImageName(rgchFamily, hdbInput))
		return (UiLogError(ERROR_PCW_DUP_IMAGE_FAMILY_NAME, rgchFamily, szNull));

	int iMinimumMsiVersion = 100;
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyInteger(hdbInput, TEXT("MinimumRequiredMsiVersion"), &iMinimumMsiVersion) );

	TCHAR rgchPropName[MAX_PATH];
	dwcch = MAX_PATH;
	if (MsiRecordIsNull(hrec, 2) && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch targets Windows Installer 2.0 or greater

		// MediaSrcPropName is not required since sequence conflict management handles 
		// this automatically
		}
	else
		{
		// author chose to author this value so we will validate it; or author is not
		// targeting the patch for Windows Installer 2.0 or greater

		uiRet = MsiRecordGetString(hrec, 2, rgchPropName, &dwcch);
		if (uiRet == ERROR_MORE_DATA)
			return (UiLogError(ERROR_PCW_BAD_IMAGE_FAMILY_SRC_PROP, rgchFamily, szNull));
		if (uiRet != MSI_OKAY)
			return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ImageFamilies.MediaSrcPropName"), szNull));
		if (!FValidPropertyName(rgchPropName))
			return (UiLogError(ERROR_PCW_BAD_IMAGE_FAMILY_SRC_PROP, rgchPropName, rgchFamily));
		}

	if (MsiRecordIsNull(hrec, 3) && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch targets Windows Installer 2.0 or greater

		// MediaDiskId is not required since sequence conflict management handles
		// this automatically
		}
	else
		{
		// author chose to author this value so we will validate it; or author is not
		// targeting the patch for Windows Installer 2.0 or greater

		int iDiskId = MsiRecordGetInteger(hrec, 3);
		if (iDiskId == MSI_NULL_INTEGER || iDiskId < 2)
			return (UiLogError(ERROR_PCW_BAD_IMAGE_FAMILY_DISKID, rgchFamily, szNull));
		}

	if (MsiRecordIsNull(hrec, 4) && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch targets Windows Installer 2.0 or greater

		// FileSequenceStart is not required since sequence conflict management handles
		// this automatically
		}
	else
		{
		// author chose to author this value so we will validate it; or author is not
		// targeting the patch for Windows Installer 2.0 or greater

		int iSeqStart = MsiRecordGetInteger(hrec, 4);
		if (iSeqStart == MSI_NULL_INTEGER || iSeqStart < 2)
			return (UiLogError(ERROR_PCW_BAD_IMAGE_FAMILY_FILESEQSTART, rgchFamily, szNull));
		}

	return (IDS_OKAY);
}


static int ICountRangeElements ( LPTSTR sz, BOOL fAllowZeros );

/* ********************************************************************** */
static UINT IdsValidateFamilyRangeRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchFamily[MAX_LENGTH_IMAGE_FAMILY_NAME + 1];
	DWORD dwcch = MAX_LENGTH_IMAGE_FAMILY_NAME + 1;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchFamily, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_NAME_TOO_LONG, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("FamilyFileRanges.Family"), szNull));
	if (!FValidFamilyName(rgchFamily))
		return (UiLogError(ERROR_PCW_BAD_FAMILY_RANGE_NAME, rgchFamily, szNull));

	UpdateStatusMsg(0, 0, rgchFamily);

	int iMinimumMsiVersion = 100;
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyInteger(hdbInput, TEXT("MinimumRequiredMsiVersion"), &iMinimumMsiVersion) );

	int iDiskId;
	uiRet = IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
				TEXT("`Family`"), TEXT("`MediaDiskId`"), rgchFamily, &iDiskId);
	Assert(uiRet == IDS_OKAY);

	if (iDiskId == MSI_NULL_INTEGER && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch targets Windows Installer 2.0 so a NULL MediaDiskId is allowed
		iDiskId = 2;
		}

	if (iDiskId < 2)
		return (UiLogError(ERROR_PCW_BAD_FAMILY_RANGE_NAME, rgchFamily, szNull));
	Assert(iDiskId != MSI_NULL_INTEGER && iDiskId >= 2);

	TCHAR rgchFTK[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_LONG_FILE_TABLE_KEY, rgchFamily, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("FamilyFileRanges.FTK"), szNull));
	if (FEmptySz(rgchFTK))
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_BLANK_FILE_TABLE_KEY, rgchFamily, szNull));

	TCHAR rgchRetainOffsets[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchRetainOffsets, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_OFFSETS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("FamilyFileRanges.RetainOffsets"), szNull));
	if (FEmptySz(rgchRetainOffsets))
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_OFFSETS, rgchFamily, rgchFTK));

	int cRetainOffsets = ICountRangeElements(rgchRetainOffsets, fTrue);
	if (cRetainOffsets <= 0)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_OFFSETS, rgchFamily, rgchFTK));
	Assert(cRetainOffsets < 256);

	TCHAR rgchRetainLengths[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 4, rgchRetainLengths, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_LENGTHS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("FamilyFileRanges.RetainLengths"), szNull));
	if (FEmptySz(rgchRetainLengths))
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_LENGTHS, rgchFamily, rgchFTK));

	int cRetainLengths = ICountRangeElements(rgchRetainLengths, fFalse);
	if (cRetainLengths <= 0)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_LENGTHS, rgchFamily, rgchFTK));
	Assert(cRetainLengths < 256);

	if (cRetainOffsets != cRetainLengths)
		return (UiLogError(ERROR_PCW_FAMILY_RANGE_COUNT_MISMATCH, rgchFamily, rgchFTK));

	// TODO - could check for overlaps in ranges

	EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 5, cRetainOffsets) );
	EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );

	return (IDS_OKAY);
}


/* ********************************************************************** */
static int ICountRangeElements ( LPTSTR sz, BOOL fAllowZeros )
{
	Assert(sz != szNull);

	CharLower(sz);

	int iCount = 0;
	while (!FEmptySz(sz))
		{
		ULONG ul = UlGetRangeElement(&sz);
		if (sz == szNull)
			{
			Assert(ul == (ULONG)(-1));
			return (-1);
			}
		if (ul == 0L && !fAllowZeros)
			return (-1);
		iCount++;
		}

	return (iCount);
}


/* ********************************************************************** */
ULONG UlGetRangeElement ( LPTSTR* psz )
{
	Assert(psz != NULL);

	LPTSTR sz = *psz;
	Assert(!FEmptySz(sz));

	BOOL fHex = FMatchPrefix(sz, TEXT("0x"));
	if (fHex)
		sz += 2;

	ULONG ulRet  = 0L;
	ULONG ulMult = (fHex) ? 16L : 10L;
	TCHAR ch = *sz;
	do	{
		ULONG ulNext;
		if (ch >= TEXT('0') && ch <= TEXT('9'))
			ulNext = (ULONG)(ch - TEXT('0'));
		else if (fHex && ch >= TEXT('a') && ch <= TEXT('f'))
			ulNext = (ULONG)(ch - TEXT('a') + 10);
		else
			{
			*psz = szNull;
			return ((ULONG)(-1));
			}
		// TODO - watch for overflow
		Assert(ulRet < ((ULONG)(-1) / ulMult));
		ulRet = (ulRet * ulMult) + ulNext;
		ch = *(++sz);
		}  while (ch != TEXT('\0') && ch != TEXT(','));

	if (ch == TEXT(','))
		{
		sz++;
		while (*sz == TEXT(' '))
			sz++;
		}

	Assert(ulRet != (ULONG)(-1));
	*psz = sz;

	return (ulRet);
}


#define MSISOURCE_SFN         0x0001
#define MSISOURCE_COMPRESSED  0x0002

static BOOL FValidGUID ( LPTSTR sz, BOOL fList, BOOL fLeadAsterisk, BOOL fSemiColonSeparated );
static BOOL FValidProductVersion ( LPTSTR sz, UINT iFields );
static BOOL FEnsureAllSrcFilesExist ( MSIHANDLE hdb, LPTSTR szFolder, BOOL fLfn );

/* ********************************************************************** */
static UINT IdsValidateUpgradedRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchUpgraded[MAX_LENGTH_TARGET_IMAGE_NAME + 1];
	DWORD dwcch = MAX_LENGTH_TARGET_IMAGE_NAME + 1;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchUpgraded, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_NAME_TOO_LONG, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedImages.Upgraded"), szNull));

	UpdateStatusMsg(0, 0, rgchUpgraded);

	if (!FValidImageName(rgchUpgraded))
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_NAME, rgchUpgraded, szNull));

	TCHAR rgchFamily[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchFamily, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY, rgchUpgraded, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedImages.Family"), szNull));
	if (!FValidFamilyName(rgchFamily))
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY, rgchUpgraded, rgchFamily));

	// TODO for each file in this image that exists, check all
	//   UpgradedImages in this family with non-blank PackageCode fields
	//   for same file and FileName

	if (!FUniqueImageName(rgchUpgraded, hdbInput))
		return (UiLogError(ERROR_PCW_DUP_UPGRADED_IMAGE_NAME, rgchUpgraded, szNull));

	TCHAR rgchMsiPath[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchMsiPath, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_TOO_LONG, rgchUpgraded, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedImages.MsiPath"), szNull));

	if (FEmptySz(rgchMsiPath))
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_EMPTY, rgchUpgraded, szNull));
	EvalAssert( FFixupPath(rgchMsiPath) );
	if (FEmptySz(rgchMsiPath))
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_EMPTY, rgchUpgraded, szNull));

	if (!FFileExist(rgchMsiPath))
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_EXIST, rgchMsiPath, szNull));

	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
			TEXT("MsiPath"), rgchMsiPath, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	MSIHANDLE hSummaryInfo = NULL;
	uiRet = MsiGetSummaryInformation(NULL, rgchMsiPath, 0, &hSummaryInfo);
	if (uiRet != MSI_OKAY || hSummaryInfo == NULL)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));

	UINT uiType;
	INT  intRet;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_MSISOURCE, &uiType, &intRet, NULL, NULL, NULL);
	if (uiRet != MSI_OKAY || uiType != VT_I4 || intRet > 7)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	if (intRet & MSISOURCE_COMPRESSED)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_COMPRESSED, rgchMsiPath, szNull));

	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("LFN"), (intRet & MSISOURCE_SFN) ? TEXT("No") : TEXT("Yes"),
				TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	TCHAR rgchData[MAX_PATH+MAX_PATH];
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_REVNUMBER, &uiType, NULL, NULL, rgchData, &dwcch);
	if (uiRet != MSI_OKAY || uiType != VT_LPTSTR)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("PackageCode"), rgchData, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);
	if (!FUniquePackageCode(rgchData, hdbInput))
		return (UiLogError(ERROR_PCW_DUP_UPGRADED_IMAGE_PACKCODE, rgchUpgraded, rgchData));

	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_SUBJECT, &uiType, NULL, NULL, rgchData, &dwcch);
	if (uiRet != MSI_OKAY || uiType != VT_LPTSTR)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("SummSubject"), rgchData, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_COMMENTS, &uiType, NULL, NULL, rgchData, &dwcch);
	if (uiRet != MSI_OKAY || uiType != VT_LPTSTR)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("SummComments"), rgchData, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	EvalAssert( MsiCloseHandle(hSummaryInfo) == MSI_OKAY );

	MSIHANDLE hdb = NULL;
	uiRet = MsiOpenDatabase(rgchMsiPath, MSIDBOPEN_READONLY, &hdb);
	if (uiRet != MSI_OKAY)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	Assert(hdb != NULL);

	// NYI bug 9392 - could call ICE24 validation on this

	EvalAssert( MSI_OKAY == IdsMsiGetPropertyString(hdb, TEXT("ProductCode"), rgchData, MAX_PATH) );
	if (!FValidGUID(rgchData, fFalse, fFalse, fFalse))
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_CODE, rgchUpgraded, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("ProductCode"), rgchData, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	EvalAssert( MSI_OKAY == IdsMsiGetPropertyString(hdb, TEXT("ProductVersion"), rgchData, MAX_PATH) );
	if (!FValidProductVersion(rgchData, 4))
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_VERSION, rgchUpgraded, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("ProductVersion"), rgchData, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	EvalAssert( MSI_OKAY == IdsMsiGetPropertyString(hdb, TEXT("UpgradeCode"), rgchData, MAX_PATH) );
	if (!FEmptySz(rgchData) && !FValidGUID(rgchData, fFalse, fFalse, fFalse))
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_UPGRADE_CODE, rgchUpgraded, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("UpgradeCode"), rgchData, TEXT("Upgraded"), rgchUpgraded);
	Assert(uiRet == MSI_OKAY);

	wsprintf(rgchData, TEXT("Upgraded image: %s"), rgchUpgraded);
	UpdateStatusMsg(IDS_STATUS_VALIDATE_IMAGES, rgchData, szEmpty);
	lstrcpy(rgchData, rgchMsiPath);
	*SzFindFilenameInPath(rgchData) = TEXT('\0');
//	if (!FEnsureAllSrcFilesExist(hdb, rgchData, !(intRet & MSISOURCE_SFN)))
//		return (UiLogError(ERROR_PCW_UPGRADED_MISSING_SRC_FILES, rgchData, szNull));
//	UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, TEXT("Table: UpgradedImages"), rgchUpgraded);


	int iMinimumMsiVersion = 100;
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyInteger(hdbInput, TEXT("MinimumRequiredMsiVersion"), &iMinimumMsiVersion) );

	int iDiskId;
	uiRet = IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
				TEXT("`Family`"), TEXT("`MediaDiskId`"), rgchFamily, &iDiskId);
	Assert(uiRet == IDS_OKAY);

	if (iDiskId == MSI_NULL_INTEGER && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch targets Windows Installer 2.0, MediaDiskId can be NULL
		iDiskId = 2;
		}

	if (iDiskId < 2)
		return (UiLogError(ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY, rgchUpgraded, rgchFamily));
	Assert(iDiskId != MSI_NULL_INTEGER && iDiskId >= 2);

	int iFileSeqStart;
	uiRet = IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
				TEXT("`Family`"), TEXT("`FileSequenceStart`"), rgchFamily, &iFileSeqStart);
	Assert(uiRet == IDS_OKAY);

	if (iFileSeqStart == MSI_NULL_INTEGER && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch targets Windows Installer 2.0, FileSequenceStart can be NULL
		iFileSeqStart = 2;
	}

	Assert(iFileSeqStart != MSI_NULL_INTEGER && iFileSeqStart >= 2);

	// verify ImageFamilies.FileSequenceStart (pcp) > Media.LastSequence (upgraded image)
	// -- only matters when not targeting Windows XP or greater since XP or greater has conflict mgmt
	if (iMinimumMsiVersion < iWindowsInstallerXP)
		{
		PMSIHANDLE hViewMedia = 0;
		PMSIHANDLE hRecMedia  = 0;
		EvalAssert( MsiDatabaseOpenView(hdb, TEXT("SELECT `LastSequence` FROM `Media`"), &hViewMedia) == MSI_OKAY );
		EvalAssert( MsiViewExecute(hViewMedia, 0) == MSI_OKAY );

		int iMediaLargestLastSequence = 0;
		int iSequence = 0;

		while (ERROR_SUCCESS == (uiRet = MsiViewFetch(hViewMedia, &hRecMedia)))
			{
			iSequence = MsiRecordGetInteger(hRecMedia, 1);
			if (iSequence > iMediaLargestLastSequence)
				{
				iMediaLargestLastSequence = iSequence;
				}
			}
		Assert( ERROR_NO_MORE_ITEMS == uiRet );

		if (iFileSeqStart <= iMediaLargestLastSequence)
			{
			// overlapping sequence numbers
			return (UiLogError(ERROR_PCW_BAD_FILE_SEQUENCE_START, rgchFamily, rgchUpgraded)); 
			}
		}	


	// TODO ensure all Media.DiskId, PatchPackage.PatchId < iDiskId
	//  ensure all File.Sequence < iFileSeqStart
	//  assert that ExecuteSequence tables have InstallFiles actions
	//  assert that if PatchFiles is present it comes after InstallFiles

	// EvalAssert( MsiCloseHandle(hdb) == MSI_OKAY );

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 4, rgchMsiPath, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_TOO_LONG, rgchUpgraded, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedImages.PatchMsiPath"), szNull));

	if (!FEmptySz(rgchMsiPath))
		{
		EvalAssert( FFixupPath(rgchMsiPath) );
		Assert(!FEmptySz(rgchMsiPath));
		if (!FFileExist(rgchMsiPath))
			return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_EXIST, rgchMsiPath, szNull));

		uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("UpgradedImages"),
				TEXT("PatchMsiPath"), rgchMsiPath, TEXT("Upgraded"), rgchUpgraded);
		Assert(uiRet == MSI_OKAY);

		hSummaryInfo = NULL;
		uiRet = MsiGetSummaryInformation(NULL, rgchMsiPath, 0, &hSummaryInfo);
		if (uiRet != MSI_OKAY || hSummaryInfo == NULL)
			return (UiLogError(ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_MSI, rgchMsiPath, szNull));

		EvalAssert( MsiCloseHandle(hSummaryInfo) == MSI_OKAY );
		}

	EvalAssert( MsiCloseHandle(hdb) == MSI_OKAY );
	
	return (IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FValidProductVersion ( LPTSTR sz, UINT iFields )
{
	Assert(iFields <= 4);

	if (FEmptySz(sz))
		return (iFields < 4);

	if (*sz < TEXT('0') || *sz > TEXT('9'))
		return (fFalse);

	DWORD dw = 0;
	while (*sz >= TEXT('0') && *sz <= TEXT('9'))
		{
		dw = (dw * 10) + (*sz - TEXT('0'));
		if (dw > 65535)
			return (fFalse);
		sz = CharNext(sz);
		}

	if (*sz == TEXT('.'))
		sz = CharNext(sz);
	else if (*sz != TEXT('\0'))
		return (fFalse);

	return (FValidProductVersion(sz, --iFields));
}


static BOOL FValidProdValValue  ( LPTSTR sz );

/* ********************************************************************** */
static UINT IdsValidateTargetRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchTarget[MAX_LENGTH_TARGET_IMAGE_NAME + 1];
	DWORD dwcch = MAX_LENGTH_TARGET_IMAGE_NAME + 1;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_NAME_TOO_LONG, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetImages.Target"), szNull));

	UpdateStatusMsg(0, 0, rgchTarget);

	if (!FValidImageName(rgchTarget))
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_NAME, rgchTarget, szNull));

	if (!FUniqueImageName(rgchTarget, hdbInput))
		return (UiLogError(ERROR_PCW_DUP_TARGET_IMAGE_NAME, rgchTarget, szNull));

	TCHAR rgchMsiPath[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchMsiPath, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_TOO_LONG, rgchTarget, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetImages.MsiPath"), szNull));

	if (FEmptySz(rgchMsiPath))
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_EMPTY, rgchTarget, szNull));
	EvalAssert( FFixupPath(rgchMsiPath) );
	if (FEmptySz(rgchMsiPath))
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_EMPTY, rgchTarget, szNull));

	if (!FFileExist(rgchMsiPath))
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_NOT_EXIST, rgchMsiPath, szNull));

	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
			TEXT("MsiPath"), rgchMsiPath, TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);

	MSIHANDLE hSummaryInfo = NULL;
	uiRet = MsiGetSummaryInformation(NULL, rgchMsiPath, 0, &hSummaryInfo);
	if (uiRet != MSI_OKAY || hSummaryInfo == NULL)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));

	UINT uiType;
	INT  intRet;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_MSISOURCE, &uiType, &intRet, NULL, NULL, NULL);
	if (uiRet != MSI_OKAY || uiType != VT_I4 || intRet > 7)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	if (intRet & MSISOURCE_COMPRESSED)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_COMPRESSED, rgchMsiPath, szNull));

	TCHAR rgchData[MAX_PATH+MAX_PATH];
	dwcch = MAX_PATH+MAX_PATH;
	uiRet = MsiSummaryInfoGetProperty(hSummaryInfo, PID_REVNUMBER, &uiType, NULL, NULL, rgchData, &dwcch);
	if (uiRet != MSI_OKAY || uiType != VT_LPTSTR)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("PackageCode"), rgchData, TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);
	if (!FUniquePackageCode(rgchData, hdbInput))
		return (UiLogError(ERROR_PCW_DUP_TARGET_IMAGE_PACKCODE, rgchTarget, rgchData));

	EvalAssert( MsiCloseHandle(hSummaryInfo) == MSI_OKAY );

	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("LFN"), (intRet & MSISOURCE_SFN) ? TEXT("No") : TEXT("Yes"),
				TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);

	MSIHANDLE hdb = NULL;
	uiRet = MsiOpenDatabase(rgchMsiPath, MSIDBOPEN_READONLY, &hdb);
	if (uiRet != MSI_OKAY)
		return (UiLogError(ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI, rgchMsiPath, szNull));
	Assert(hdb != NULL);

	// NYI bug 9392 - could call ICE24 validation on this

	EvalAssert( MSI_OKAY == IdsMsiGetPropertyString(hdb, TEXT("ProductCode"), rgchData, MAX_PATH) );
	if (!FValidGUID(rgchData, fFalse, fFalse, fFalse))
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_CODE, rgchTarget, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("ProductCode"), rgchData, TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);

	EvalAssert( MSI_OKAY == IdsMsiGetPropertyString(hdb, TEXT("ProductVersion"), rgchData, MAX_PATH) );
	if (!FValidProductVersion(rgchData, 4))
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_VERSION, rgchTarget, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("ProductVersion"), rgchData, TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);

	EvalAssert( MSI_OKAY == IdsMsiGetPropertyString(hdb, TEXT("UpgradeCode"), rgchData, MAX_PATH) );
	if (!FEmptySz(rgchData) && !FValidGUID(rgchData, fFalse, fFalse, fFalse))
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_UPGRADE_CODE, rgchTarget, szNull));
	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("UpgradeCode"), rgchData, TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);

	wsprintf(rgchData, TEXT("Target image: %s"), rgchTarget);
	UpdateStatusMsg(IDS_STATUS_VALIDATE_IMAGES, rgchData, szEmpty);
	lstrcpy(rgchData, rgchMsiPath);
	*SzFindFilenameInPath(rgchData) = TEXT('\0');

//	int iIgnoreMissingSrcFiles = MsiRecordGetInteger(hrec, 6);
//	if (iIgnoreMissingSrcFiles == MSI_NULL_INTEGER || iIgnoreMissingSrcFiles == 0)
//		{
//		if (!FEnsureAllSrcFilesExist(hdb, rgchData, !(intRet & MSISOURCE_SFN)))
//			return (UiLogError(ERROR_PCW_TARGET_MISSING_SRC_FILES, rgchData, szNull));
//		UpdateStatusMsg(IDS_STATUS_VALIDATE_INPUT, TEXT("Table: TargetImages"), rgchTarget);
//		}

	EvalAssert( MsiCloseHandle(hdb) == MSI_OKAY );


	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchData, &dwcch); // Upgraded
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED, rgchTarget, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetImages.Upgraded"), szNull));
	if (!FValidImageName(rgchData))
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED, rgchTarget, rgchData));

	TCHAR rgchFamily[32];
	uiRet = IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
				TEXT("`Upgraded`"), TEXT("`Family`"), rgchData, rgchFamily, 32);
	Assert(uiRet == IDS_OKAY);
	if (!FValidFamilyName(rgchFamily))
		return (UiLogError(ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED, rgchTarget, rgchData));

	uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("Family"), rgchFamily,	TEXT("Target"), rgchTarget);
	Assert(uiRet == MSI_OKAY);

	int iDiskId;
	uiRet = IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
				TEXT("`Family`"), TEXT("`MediaDiskId`"), rgchFamily, &iDiskId);
	Assert(uiRet == IDS_OKAY);
	Assert(iDiskId != MSI_NULL_INTEGER && iDiskId >= 2);

	int iFileSeqStart;
	uiRet = IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
				TEXT("`Family`"), TEXT("`FileSequenceStart`"), rgchFamily, &iFileSeqStart);
	Assert(uiRet == IDS_OKAY);
	Assert(iFileSeqStart != MSI_NULL_INTEGER && iFileSeqStart >= 2);

	// TODO ensure all Media.DiskId, PatchPackage.PatchId < iDiskId
	//  ensure all File.Sequence < iFileSeqStart
	//  assert that ExecuteSequence tables have InstallFiles actions
	//  assert that if PatchFiles is present it comes after InstallFiles

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 4, rgchData, &dwcch); // ProductValidateFlags
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TARGET_BAD_PROD_VALIDATE, rgchTarget, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetImages.ProductValidateFlags"), szNull));
	if (FEmptySz(rgchData))
		{
		Assert(FValidProdValValue(TEXT("0x00000922")));
		uiRet = IdsMsiUpdateTableRecordSz(hdbInput, TEXT("TargetImages"),
				TEXT("ProductValidateFlags"), TEXT("0x00000922"), TEXT("Target"), rgchTarget);
		Assert(uiRet == MSI_OKAY);
		g_fValidateProductCodeIncluded = TRUE;
		}
	else
		{
		if (!FValidHexValue(rgchData) || !FValidProdValValue(rgchData))
			return (UiLogError(ERROR_PCW_TARGET_BAD_PROD_VALIDATE, rgchTarget, szNull));

		// see if MSITRANSFORM_VALIDATE_PRODUCT is included (0x00000002)
		ULONG ulFlags = UlFromHexSz(rgchData);
		if (ulFlags & MSITRANSFORM_VALIDATE_PRODUCT)
			{
			g_fValidateProductCodeIncluded = TRUE;
			}
		}


	Assert(iOrderMax > 0);
	int iOrder = MsiRecordGetInteger(hrec, 5);
	if (iOrder == MSI_NULL_INTEGER || iOrder < 0)
		{
		uiRet = IdsMsiUpdateTableRecordInt(hdbInput, TEXT("TargetImages"), TEXT("Order"), iOrderMax-1, TEXT("Target"), rgchTarget);
		Assert(uiRet == MSI_OKAY);
		}
	Assert(iOrder < iOrderMax);

	return (IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FValidProdValValue ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));
	Assert(FValidHexValue(sz));

	ULONG ulFlags = UlFromHexSz(sz);
	if (ulFlags > 0x00000FFF)
		EvalAssert( FWriteLogFile(TEXT("   WARNING: TargetImages.ProductValidateFlags contains unknown bits above 0x00000FFF that might cause patch to fail.\r\n")) );

	UINT cVerFlags = 0;
	if (ulFlags & MSITRANSFORM_VALIDATE_MAJORVERSION)
		cVerFlags++;
	if (ulFlags & MSITRANSFORM_VALIDATE_MINORVERSION)
		cVerFlags++;
	if (ulFlags & MSITRANSFORM_VALIDATE_UPDATEVERSION)
		cVerFlags++;

	UINT cCompFlags = 0;
	if (ulFlags & MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION)
		cCompFlags++;
	if (ulFlags & MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION)
		cCompFlags++;
	if (ulFlags & MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION)
		cCompFlags++;
	if (ulFlags & MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION)
		cCompFlags++;
	if (ulFlags & MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION)
		cCompFlags++;

	// prevent specification of product version check without comparison flag
	if (cVerFlags >= 1 && cCompFlags == 0)
		{
		EvalAssert( FWriteLogFile(TEXT("   ERROR: TargetImages.ProductValidateFlags specifies validation of the product version but does not also include a product version comparison flag.\r\n")) );
		return FALSE;
		}

	return (cVerFlags <= 1 && cCompFlags <= 1);
}


#ifdef UNUSED

static LPTSTR g_szFolder = szNull;
static LPTSTR g_szFName  = szNull;

static UINT IdsCheckFileExists ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FEnsureAllSrcFilesExist ( MSIHANDLE hdb, LPTSTR szFolder, BOOL fLfn )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szFolder));
	Assert(FFolderExist(szFolder));

	g_szFolder = szFolder;
	g_szFName  = szFolder + lstrlen(szFolder);

	UINT ids = IdsMsiEnumTable(hdb, TEXT("`File`"),
					TEXT("`File`,`Component_`,`FileName`"),
					szNull, IdsCheckFileExists,
					(LPARAM)(hdb), (LPARAM)(fLfn));

	return (ids == MSI_OKAY);
}


/* ********************************************************************** */
static UINT IdsCheckFileExists ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	MSIHANDLE hdb = (MSIHANDLE)(lp1);
	Assert(hdb != NULL);

	BOOL fLfn = (BOOL)(lp2);

	Assert(!FEmptySz(g_szFolder));
	Assert(g_szFName != szNull);
	Assert(g_szFName > g_szFolder);
	*g_szFName = TEXT('\0');
	Assert(FFolderExist(g_szFolder)); // true but expensive to test repeatedly

	TCHAR rgchComponent[MAX_PATH];
	TCHAR rgchFName[MAX_PATH];

	DWORD dwcch = MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchFName, &dwcch);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchFName));

	UpdateStatusMsg(0, 0, rgchFName);

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchComponent, &dwcch);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchComponent));

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchFName, &dwcch);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchFName));

	uiRet = IdsResolveSrcFilePathSzs(hdb, g_szFName, rgchComponent, rgchFName, fLfn, szNull);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(g_szFName));

	return ((FFileExist(g_szFolder)) ? IDS_OKAY : IDS_CANCEL);
}
#endif /* UNUSED */


static UINT IdsResolveSrcDir ( MSIHANDLE hdb, LPTSTR szDir, LPTSTR szBuf, BOOL fLfn, LPTSTR szFullSubFolder );

/* ********************************************************************** */
UINT IdsResolveSrcFilePathSzs ( MSIHANDLE hdb, LPTSTR szBuf, LPTSTR szComponent, LPTSTR szFName, BOOL fLfn, LPTSTR szFullSubFolder )
{
	Assert(hdb != NULL);
	Assert(szBuf != szNull);
	Assert(!FEmptySz(szComponent));
	Assert(!FEmptySz(szFName));
	Assert(*szFName != TEXT('\\'));
	Assert(*SzLastChar(szFName) != TEXT('\\'));

	*szBuf = TEXT('\0');
	if (szFullSubFolder != szNull)
		*szFullSubFolder = TEXT('\0');

	TCHAR rgchDir[MAX_PATH];
	UINT  ids = IdsMsiGetTableString(hdb, TEXT("`Component`"), TEXT("`Component`"), TEXT("`Directory_`"), szComponent, rgchDir, MAX_PATH);
	Assert(ids == MSI_OKAY);
	Assert(!FEmptySz(rgchDir));

	ids = IdsResolveSrcDir(hdb, rgchDir, szBuf, fLfn, szFullSubFolder);
	Assert(ids == MSI_OKAY);
	Assert(!FEmptySz(szBuf));

	LPTSTR szBar = szFName;
	while (*szBar != TEXT('\0') && *szBar != TEXT('|'))
		szBar = CharNext(szBar);

	if (!fLfn)
		*szBar = TEXT('\0');

	if (*szBar == TEXT('\0'))
		lstrcat(szBuf, szFName);
	else
		{
		Assert(fLfn);
		Assert(*CharNext(szBar) != TEXT('\0'));
		Assert(*CharNext(szBar) != TEXT('\\'));
		lstrcat(szBuf, CharNext(szBar));
		}

	return (MSI_OKAY);
}


/* ********************************************************************** */
static UINT IdsResolveSrcDir ( MSIHANDLE hdb, LPTSTR szDir, LPTSTR szBuf, BOOL fLfn, LPTSTR szFullSubFolder )
{
	/* RECURSION WARNING */

	Assert(hdb != NULL);
	Assert(!FEmptySz(szDir));
	Assert(szBuf != szNull);
	Assert(*szBuf == TEXT('\0'));

	TCHAR rgchData[MAX_PATH];
	UINT  ids = IdsMsiGetTableString(hdb, TEXT("`Directory`"), TEXT("`Directory`"), TEXT("`Directory_Parent`"), szDir, rgchData, MAX_PATH);
	Assert(ids == MSI_OKAY);

	if (!FEmptySz(rgchData) && lstrcmp(rgchData, szDir))
		{
		ids = IdsResolveSrcDir(hdb, rgchData, szBuf, fLfn, szFullSubFolder);
		Assert(ids == MSI_OKAY);
		Assert(!FEmptySz(szBuf));
		Assert(*SzLastChar(szBuf) == TEXT('\\'));
		if (szFullSubFolder != szNull)
			{
			Assert(!FEmptySz(szFullSubFolder));
			Assert(*SzLastChar(szFullSubFolder) == TEXT('\\'));
			}
		}

	ids = IdsMsiGetTableString(hdb, TEXT("`Directory`"), TEXT("`Directory`"), TEXT("`DefaultDir`"), szDir, rgchData, MAX_PATH);
	Assert(ids == MSI_OKAY);
	Assert(!FEmptySz(rgchData));
	Assert(*rgchData != TEXT('\\'));
	Assert(*rgchData != TEXT('|'));
	Assert(*SzLastChar(rgchData) != TEXT('\\'));

	LPTSTR szCur = rgchData;
	if (szFullSubFolder != szNull)
		lstrcat(szFullSubFolder, rgchData);

	while (*szCur != TEXT('\0') && *szCur != TEXT(':'))
		szCur = CharNext(szCur);

	if (*szCur == TEXT(':'))
		{
		lstrcpy(rgchData, CharNext(szCur));
		Assert(!FEmptySz(rgchData));
		Assert(*rgchData != TEXT('\\'));
		Assert(*rgchData != TEXT('|'));
		}
	
	if (szFullSubFolder != szNull)
		{
		Assert(*SzLastChar(szFullSubFolder) != TEXT('\\'));
		lstrcat(szFullSubFolder, TEXT("\\"));
		}

	szCur = rgchData;
	while (*szCur != TEXT('\0') && *szCur != TEXT('|'))
		szCur = CharNext(szCur);

	if (!fLfn)
		*szCur = TEXT('\0');

	if (*szCur == TEXT('\0'))
		szCur = rgchData;
	else
		{
		Assert(fLfn);
		Assert(*CharNext(szCur) != TEXT('\0'));
		Assert(*CharNext(szCur) != TEXT('\\'));
		szCur = CharNext(szCur);
		}
	if (!lstrcmp(szCur, TEXT("SOURCEDIR")) || !lstrcmp(szCur, TEXT("SourceDir")))
		lstrcpy(szBuf, TEXT("."));
	else
		lstrcat(szBuf, szCur);

	Assert(*SzLastChar(szBuf) != TEXT('\\'));
	lstrcat(szBuf, TEXT("\\"));

	return (MSI_OKAY);
}


/* ********************************************************************** */
static UINT IdsValidateExternalFileRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchFamily[MAX_PATH];
	DWORD dwcch = MAX_PATH;
	UINT  uiRet = MsiRecordGetString(hrec, 1, rgchFamily, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ExternalFiles.Family"), szNull));
	if (!FValidFamilyName(rgchFamily))
		return (UiLogError(ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD, rgchFamily, szNull));

	int iMinimumMsiVersion = 100;
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyInteger(hdbInput, TEXT("MinimumRequiredMsiVersion"), &iMinimumMsiVersion) );

	int iDiskId;
	uiRet = IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
				TEXT("`Family`"), TEXT("`MediaDiskId`"), rgchFamily, &iDiskId);
	Assert(uiRet == IDS_OKAY);

	if (iDiskId == MSI_NULL_INTEGER && iMinimumMsiVersion >= iWindowsInstallerXP)
		{
		// patch is targeted to Windows Installer 2.0 so MediaDiskId can be NULL
		iDiskId = 2;
		}

	if (iDiskId <= 0)
		return (UiLogError(ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD, rgchFamily, szNull));

	TCHAR rgchFTK[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_EXTFILE_LONG_FILE_TABLE_KEY, rgchFamily, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ExternalFiles.FTK"), szNull));
	if (FEmptySz(rgchFTK))
		return (UiLogError(ERROR_PCW_EXTFILE_BLANK_FILE_TABLE_KEY, rgchFamily, szNull));

	TCHAR rgchPath[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchPath, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_EXTFILE_LONG_PATH_TO_FILE, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ExternalFiles.FilePath"), szNull));
	if (FEmptySz(rgchPath))
		return (UiLogError(ERROR_PCW_EXTFILE_BLANK_PATH_TO_FILE, rgchFamily, rgchFTK));
	EvalAssert( FFixupPath(rgchPath) );
	if (FEmptySz(rgchPath))
		return (UiLogError(ERROR_PCW_EXTFILE_BLANK_PATH_TO_FILE, rgchFamily, rgchFTK));
	if (!FFileExist(rgchPath))
		return (UiLogError(ERROR_PCW_EXTFILE_MISSING_FILE, rgchPath, rgchFamily));

	EvalAssert( MSI_OKAY == MsiRecordSetString(hrec, 3, rgchPath) );

	Assert(iOrderMax > 0);
	int iOrder = MsiRecordGetInteger(hrec, 4);
	if (iOrder == MSI_NULL_INTEGER || iOrder < 0)
		EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 4, iOrderMax-1) );
	Assert(iOrder < iOrderMax);

	TCHAR rgchOffsets[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 5, rgchOffsets, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_EXTFILE_LONG_IGNORE_OFFSETS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ExternalFiles.IgnoreOffsets"), szNull));

	int cOffsets = ICountRangeElements(rgchOffsets, fTrue);
	if (cOffsets < 0)
		return (UiLogError(ERROR_PCW_EXTFILE_BAD_IGNORE_OFFSETS, rgchFamily, rgchFTK));
	Assert(cOffsets < 256);

	TCHAR rgchLengths[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 6, rgchLengths, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_EXTFILE_LONG_IGNORE_LENGTHS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ExternalFiles.IgnoreLengths"), szNull));

	int cLengths = ICountRangeElements(rgchLengths, fFalse);
	if (cLengths < 0)
		return (UiLogError(ERROR_PCW_EXTFILE_BAD_IGNORE_LENGTHS, rgchFamily, rgchFTK));
	Assert(cLengths < 256);

	if (cOffsets != cLengths)
		return (UiLogError(ERROR_PCW_EXTFILE_IGNORE_COUNT_MISMATCH, rgchFamily, rgchFTK));

	EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 8, cOffsets) );

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 7, rgchOffsets, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_EXTFILE_LONG_RETAIN_OFFSETS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("ExternalFiles.RetainOffsets"), szNull));

	cOffsets = ICountRangeElements(rgchOffsets, fTrue);
	if (cOffsets < 0)
		return (UiLogError(ERROR_PCW_EXTFILE_BAD_RETAIN_OFFSETS, rgchFamily, rgchFTK));
	Assert(cOffsets < 256);

	if (cOffsets > 0)
		{
		wsprintf(rgchLengths, TEXT("`Family`='%s' AND `FTK`='%s'"), rgchFamily, rgchFTK);
		uiRet = IdsMsiGetTableIntegerWhere(hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainCount`"), rgchLengths, &cLengths);
		Assert(uiRet == MSI_OKAY);

		if (cOffsets != cLengths)
			return (UiLogError(ERROR_PCW_EXTFILE_IGNORE_COUNT_MISMATCH, rgchFamily, rgchFTK));
		}

	// TODO - could check for overlaps in ranges

	EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );

	return (IDS_OKAY);
}


static BOOL FFileRecordExistsInImage ( MSIHANDLE hdbInput, LPTSTR szFile, LPTSTR szImage, BOOL fUpgradedImage );

/* ********************************************************************** */
static UINT IdsValidateUFileDataRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchUpgraded[MAX_PATH];
	DWORD dwcch = MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchUpgraded, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedFiles_OptionalData.Upgraded"), szNull));
	if (!FValidImageName(rgchUpgraded))
		return (UiLogError(ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD, rgchUpgraded, szNull));

	TCHAR rgchFTK[MAX_PATH];
	uiRet = IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
				TEXT("`Upgraded`"), TEXT("`Family`"), rgchUpgraded, rgchFTK, MAX_PATH);
	Assert(uiRet == IDS_OKAY);
	if (FEmptySz(rgchFTK))
		return (UiLogError(ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD, rgchUpgraded, szNull));

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UFILEDATA_LONG_FILE_TABLE_KEY, rgchUpgraded, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedFiles_OptionalData.FTK"), szNull));
	if (FEmptySz(rgchFTK))
		return (UiLogError(ERROR_PCW_UFILEDATA_BLANK_FILE_TABLE_KEY, rgchUpgraded, szNull));
	if (!FFileRecordExistsInImage(hdbInput, rgchFTK, rgchUpgraded, fTrue))
		return (UiLogError(ERROR_PCW_UFILEDATA_MISSING_FILE_TABLE_KEY, rgchFTK, rgchUpgraded));

	int iWholeFile = MsiRecordGetInteger(hrec, 3);
	if (iWholeFile == MSI_NULL_INTEGER)
		{
		EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 3, 0) );
		EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );
		}

	return (IDS_OKAY);
}


static BOOL FValidIgnoreFTK ( LPTSTR szFTK );

/* ********************************************************************** */
static UINT IdsValidateUFileIgnoreRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchUpgraded[MAX_PATH];
	DWORD dwcch = MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchUpgraded, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedFilesToIgnore.Upgraded"), szNull));

	TCHAR rgchFTK[MAX_PATH];
	if (lstrcmp(rgchUpgraded, TEXT("*")))
		{
		if (!FValidImageName(rgchUpgraded))
			return (UiLogError(ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD, rgchUpgraded, szNull));

		uiRet = IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`"), TEXT("`Family`"), rgchUpgraded, rgchFTK, MAX_PATH);
		Assert(uiRet == IDS_OKAY);
		if (FEmptySz(rgchFTK))
			return (UiLogError(ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD, rgchUpgraded, szNull));
		}

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_UFILEIGNORE_LONG_FILE_TABLE_KEY, rgchUpgraded, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("UpgradedFilesToIgnore.FTK"), szNull));
	if (FEmptySz(rgchFTK))
		return (UiLogError(ERROR_PCW_UFILEIGNORE_BLANK_FILE_TABLE_KEY, rgchUpgraded, szNull));
	if (!FValidIgnoreFTK(rgchFTK))
		return (UiLogError(ERROR_PCW_UFILEIGNORE_BAD_FILE_TABLE_KEY, rgchUpgraded, rgchFTK));
		
	return (IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FValidIgnoreFTK ( LPTSTR szFTK )
{
	Assert(!FEmptySz(szFTK));

	BOOL fEndsInAsterisk = (*SzLastChar(szFTK) == TEXT('*'));

	if (fEndsInAsterisk)
		*SzLastChar(szFTK) = TEXT('\0');
	Assert(!FEmptySz(szFTK));

	BOOL fRet = fTrue;
	while (*szFTK != TEXT('\0'))
		{
		if (*szFTK == TEXT('*'))
			fRet = fFalse;
		szFTK = CharNext(szFTK);
		}

	if (fEndsInAsterisk)
		lstrcpy(szFTK, TEXT("*"));

	return (fRet);
}

/* ********************************************************************** */
static UINT IdsValidateTargetProductCodesAgainstList( MSIHANDLE hdb )
{
	if (!g_fValidateProductCodeIncluded)
		{
		// MSITRANSFORM_VALIDATE_PRODUCT isn't included anywhere
		// so it doesn't matter whether or not some target product
		// codes in ListOfTargetProductCodes are missing from the TargetImages
		// table
		return (IDS_OKAY);
		}

	UINT cchProp = CchMsiPcwPropertyString(hdb, TEXT("ListOfTargetProductCodes")) + 1; //length + null terminator

	LPTSTR rgchProp = (LPTSTR)LocalAlloc(LPTR, cchProp*sizeof(TCHAR));
	if (!rgchProp)
		return (IDS_OOM);

	UINT ids = IdsMsiGetPcwPropertyString(hdb, TEXT("ListOfTargetProductCodes"), rgchProp, cchProp);
	Assert(ids == IDS_OKAY);

	if (!FEmptySz(rgchProp))
		{
		TCHAR* pch = rgchProp;
		TCHAR* pchBegin = pch;
		TCHAR* pchCur = NULL;

		BOOL fRecExists = FALSE;

		// ListOfTargetProductCodes is a delimited list of Guids, so no DBCS chars here
		while (*pch != '\0')
			{
			if (*pch == ';')
				{
				pchCur = pch;
				*pchCur = '\0';
				pch++; // for ';'

				// check for presence of product code in TargetImages table
				fRecExists = FALSE;
				EvalAssert( IDS_OKAY == IdsMsiExistTableRecords(hdbInput, TEXT("TargetImages"), TEXT("ProductCode"), pchBegin, &fRecExists) );
				if (!fRecExists)
					{
					// patch won't work right
					EvalAssert( NULL == LocalFree((HLOCAL)rgchProp) );
					return (UiLogError(ERROR_PCW_TARGET_BAD_PROD_CODE_VAL, pchBegin, szNull));
					}

				pchBegin = pch; // start of next guid
				}
			else
				{
				pch++;
				}
			}

		// complete last check
		fRecExists = FALSE;
		EvalAssert( IDS_OKAY == IdsMsiExistTableRecords(hdbInput, TEXT("TargetImages"), TEXT("ProductCode"), pchBegin, &fRecExists) );
		if (!fRecExists)
			{
			// patch won't work right
			EvalAssert( NULL == LocalFree((HLOCAL)rgchProp) );
			return (UiLogError(ERROR_PCW_TARGET_BAD_PROD_CODE_VAL, pchBegin, szNull));
			}
		}
       
	EvalAssert( NULL == LocalFree((HLOCAL)rgchProp) );

	return (IDS_OKAY);
}

/* ********************************************************************** */
static UINT IdsValidateTFileDataRecords ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp1 == 0L);
	Assert(lp2 == 0L);

	Assert(hdbInput != NULL);

	TCHAR rgchTarget[MAX_PATH];
	DWORD dwcch = MAX_PATH;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD, szNull, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetFiles_OptionalData.Upgraded"), szNull));
	if (!FValidImageName(rgchTarget))
		return (UiLogError(ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD, rgchTarget, szNull));

	TCHAR rgchFamily[MAX_PATH];
	uiRet = IdsMsiGetTableString(hdbInput, TEXT("`TargetImages`"),
				TEXT("`Target`"), TEXT("`Family`"), rgchTarget, rgchFamily, MAX_PATH);
	Assert(uiRet == IDS_OKAY);
	if (FEmptySz(rgchFamily))
		return (UiLogError(ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD, rgchTarget, szNull));

	TCHAR rgchFTK[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 2, rgchFTK, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TFILEDATA_LONG_FILE_TABLE_KEY, rgchTarget, szNull));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetFiles_OptionalData.FTK"), szNull));
	if (FEmptySz(rgchFTK))
		return (UiLogError(ERROR_PCW_TFILEDATA_BLANK_FILE_TABLE_KEY, rgchTarget, szNull));
	if (!FFileRecordExistsInImage(hdbInput, rgchFTK, rgchTarget, fFalse))
		return (UiLogError(ERROR_PCW_TFILEDATA_MISSING_FILE_TABLE_KEY, rgchFTK, rgchTarget));

	TCHAR rgchOffsets[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 3, rgchOffsets, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TFILEDATA_LONG_IGNORE_OFFSETS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetFiles_OptionalData.IgnoreOffsets"), szNull));

	int cOffsets = ICountRangeElements(rgchOffsets, fTrue);
	if (cOffsets < 0)
		return (UiLogError(ERROR_PCW_TFILEDATA_BAD_IGNORE_OFFSETS, rgchFamily, rgchFTK));
	Assert(cOffsets < 256);

	TCHAR rgchLengths[MAX_PATH];
	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 4, rgchLengths, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TFILEDATA_LONG_IGNORE_LENGTHS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetFiles_OptionalData.IgnoreLengths"), szNull));

	int cLengths = ICountRangeElements(rgchLengths, fFalse);
	if (cLengths < 0)
		return (UiLogError(ERROR_PCW_TFILEDATA_BAD_IGNORE_LENGTHS, rgchFamily, rgchFTK));
	Assert(cLengths < 256);

	if (cOffsets != cLengths)
		return (UiLogError(ERROR_PCW_TFILEDATA_IGNORE_COUNT_MISMATCH, rgchFamily, rgchFTK));

	EvalAssert( MSI_OKAY == MsiRecordSetInteger(hrec, 6, cOffsets) );

	dwcch = MAX_PATH;
	uiRet = MsiRecordGetString(hrec, 5, rgchOffsets, &dwcch);
	if (uiRet == ERROR_MORE_DATA)
		return (UiLogError(ERROR_PCW_TFILEDATA_LONG_RETAIN_OFFSETS, rgchFamily, rgchFTK));
	if (uiRet != MSI_OKAY)
		return (UiLogError(IDS_CANT_GET_RECORD_FIELD, TEXT("TargetFiles_OptionalData.RetainOffsets"), szNull));

	cOffsets = ICountRangeElements(rgchOffsets, fTrue);
	if (cOffsets < 0)
		return (UiLogError(ERROR_PCW_TFILEDATA_BAD_RETAIN_OFFSETS, rgchFamily, rgchFTK));
	Assert(cOffsets < 256);

	if (cOffsets > 0)
		{
		wsprintf(rgchLengths, TEXT("`Family`='%s' AND `FTK`='%s'"), rgchFamily, rgchFTK);
		uiRet = IdsMsiGetTableIntegerWhere(hdbInput, TEXT("`FamilyFileRanges`"),
					TEXT("`RetainCount`"), rgchLengths, &cLengths);
		Assert(uiRet == MSI_OKAY);

		if (cOffsets != cLengths)
			return (UiLogError(ERROR_PCW_TFILEDATA_IGNORE_COUNT_MISMATCH, rgchFamily, rgchFTK));
		}

	// TODO - could check for overlaps in ranges

	EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );

	return (IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FFileRecordExistsInImage ( MSIHANDLE hdbInput, LPTSTR szFile, LPTSTR szImage, BOOL fUpgradedImage )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szFile));
	Assert(!FEmptySz(szImage));

	MSIHANDLE hdb = HdbReopenMsi(hdbInput, szImage, fUpgradedImage, fFalse);
	Assert(hdb != NULL);

	BOOL fExists = fFalse;
	EvalAssert( IDS_OKAY == IdsMsiExistTableRecords(hdb, TEXT("`File`"), TEXT("`File`"), szFile, &fExists) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdb) );

	return (fExists);
}


/* ********************************************************************** */
static BOOL FValidName ( LPTSTR sz, int cchMax )
{
	Assert(sz != szNull);

	if (FEmptySz(sz) || lstrlen(sz) > cchMax
			|| *sz == TEXT('_') || *SzLastChar(sz) == TEXT('_'))
		{
		return (fFalse);
		}

	while (!FEmptySz(sz))
		{
		TCHAR ch = *sz;
		if ((ch < TEXT('a') || ch > TEXT('z'))
				&& (ch < TEXT('A') || ch > TEXT('Z'))
				&& (ch < TEXT('0') || ch > TEXT('9'))
				&& ch != TEXT('_') )
			{
			return (fFalse);
			}
		sz = CharNext(sz);
		}

	return (fTrue);
}


/* ********************************************************************** */
static BOOL FUniqueImageName ( LPTSTR sz, MSIHANDLE hdbInput )
{
	Assert(!FEmptySz(sz));
	Assert(FValidImageName(sz));
	Assert(lstrlen(sz) < 32);
	Assert(hdbInput != NULL);

	TCHAR rgch[32];
	lstrcpy(rgch, sz);
	CharUpper(rgch);

	BOOL fExist = fFalse;
	UINT ids = IdsMsiExistTableRecords(hdbInput, TEXT("`TempImageNames`"),
				TEXT("`ImageName`"), rgch, &fExist);
	Assert(ids == MSI_OKAY);

	if (!fExist)
		{
		TCHAR rgchQuery[MAX_PATH];
		wsprintf(rgchQuery, TEXT("INSERT INTO `TempImageNames` ( `ImageName` ) VALUES ( '%s' )"), rgch);
		EvalAssert( FExecSqlCmd(hdbInput, rgchQuery) );
		}

	return (!fExist);
}


/* ********************************************************************** */
static BOOL FUniquePackageCode ( LPTSTR sz, MSIHANDLE hdbInput )
{
	Assert(!FEmptySz(sz));
	Assert(lstrlen(sz) < 64);
	Assert(hdbInput != NULL);

	TCHAR rgch[64];
	lstrcpy(rgch, sz);
	CharUpper(rgch);

	BOOL fExist = fFalse;
	UINT ids = IdsMsiExistTableRecords(hdbInput, TEXT("`TempPackCodes`"),
				TEXT("`PackCode`"), rgch, &fExist);
	Assert(ids == MSI_OKAY);

	if (!fExist)
		{
		TCHAR rgchQuery[MAX_PATH];
		wsprintf(rgchQuery, TEXT("INSERT INTO `TempPackCodes` ( `PackCode` ) VALUES ( '%s' )"), rgch);
		EvalAssert( FExecSqlCmd(hdbInput, rgchQuery) );
		}

	return (!fExist);
}


/* ********************************************************************** */
static BOOL FNoUpgradedImages ( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	BOOL fExists = fFalse;
	EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput, TEXT("`UpgradedImages`"), TEXT("`Upgraded`"), TEXT(" "), &fExists) );

#ifdef DEBUG
	if (fExists)
		{
		BOOL fExistsTarget = fFalse;
		EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput, TEXT("`TargetImages`"), TEXT("`Target`"), TEXT(" "), &fExistsTarget) );
		Assert(fExistsTarget);

		fExistsTarget = fFalse;
		EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdbInput, TEXT("`ImageFamilies`"), TEXT("`Family`"), TEXT(" "), &fExistsTarget) );
		Assert(fExistsTarget);
		}
#endif

	return (!fExists);
}

static UINT IdsCheckPCodeAndVersion( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FCheckForProductCodeMismatchWithVersionMatch( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	UINT ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`Upgraded`,`ProductCode`,`ProductVersion`"),
					szNull, IdsCheckPCodeAndVersion, (LPARAM)(hdb), 0L);
	if (ids == IDS_OKAY)
		return (fTrue);

	return (fFalse);
}

static UINT IdsCheckProductCode ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FCheckForProductCodeMismatches ( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	TCHAR rgch[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdb, TEXT("AllowProductCodeMismatches"), rgch, MAX_PATH) );

	if ((!FEmptySz(rgch)) && (*rgch != TEXT('0')))
		return (fTrue);

	UINT ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`Upgraded`,`ProductCode`"),
					szNull, IdsCheckProductCode, (LPARAM)(hdb), 0L);
	Assert(ids == IDS_OKAY || ids == IDS_CANCEL);
	if (ids == IDS_OKAY)
		return (fTrue);

	if (IDNO == IMessageBoxIds(HdlgStatus(), IDS_PRODUCTCODES_DONT_MATCH, MB_YESNO | MB_ICONQUESTION))
		{
		FWriteLogFile(TEXT("  ERROR - ProductCodes do not match between Target and Upgraded images.\r\n"));
		return (fFalse);
		}

	FWriteLogFile(TEXT("  User supressed error for ProductCodes not matching between Target and Upgraded images.\r\n"));

	return (fTrue);
}

static int ICompareVersions ( LPTSTR szUpgradedPC, LPTSTR szTargetPC );

/* ********************************************************************** */
static UINT IdsCheckPCodeAndVersion( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2   == 0L);

	MSIHANDLE hdb = (MSIHANDLE)(lp1);
	Assert(hdb != NULL);

	DWORD dwcch = 64;

	TCHAR rgchUpgradedImage[64] = {0};
	TCHAR rgchTargetPC[40] = {0};
	TCHAR rgchUpgradePC[40] = {0};
	TCHAR rgchTargetPV[32] = {0};
	TCHAR rgchUpgradePV[32] = {0};

	UINT uiRet = MsiRecordGetString(hrec, 2, rgchUpgradedImage, &dwcch);
	Assert(uiRet == MSI_OKAY && !FEmptySz(rgchUpgradedImage));

	dwcch = 40;
	uiRet = MsiRecordGetString(hrec, 3, rgchTargetPC, &dwcch);
	Assert(uiRet == MSI_OKAY && !FEmptySz(rgchTargetPC));

	dwcch = 32;
	uiRet = MsiRecordGetString(hrec, 4, rgchTargetPV, &dwcch);
	Assert(uiRet == MSI_OKAY && !FEmptySz(rgchTargetPV));

	dwcch = 40;
	uiRet = IdsMsiGetTableString(hdb, TEXT("`UpgradedImages`"),
				TEXT("`Upgraded`"), TEXT("`ProductCode`"),
				rgchUpgradedImage, rgchUpgradePC, 40);
	Assert(uiRet == MSI_OKAY && !FEmptySz(rgchUpgradePC));

	dwcch = 32;
	uiRet = IdsMsiGetTableString(hdb, TEXT("`UpgradedImages`"),
				TEXT("`Upgraded`"), TEXT("`ProductVersion`"),
				rgchUpgradedImage, rgchUpgradePV, 32);
	Assert(uiRet == MSI_OKAY && !FEmptySz(rgchUpgradePV));

	// report an error when the product codes differ but the product versions are the same
	// -- patch would generally be okay, but we want to err on the side of caution
	// -- see Whistler bug #355521
	// -- at least one of the 3 fields of the ProductVersion must change to use the Upgrade table
	//    which enables major update functionality (which coincidentally, requires a ProductCode change)
	//
	if (0 != lstrcmpi(rgchTargetPC, rgchUpgradePC)
		&& 0 == ICompareVersions(rgchUpgradePV, rgchTargetPV))
		return (ERROR_PCW_MATCHED_PRODUCT_VERSIONS);

	return (IDS_OKAY);
}

/* ********************************************************************** */
static UINT IdsCheckProductCode ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2   == 0L);

	MSIHANDLE hdb = (MSIHANDLE)(lp1);
	Assert(hdb != NULL);

	TCHAR rgchUpgradedImage[64];
	DWORD dwcch = 64;
	UINT uiRet = MsiRecordGetString(hrec, 2, rgchUpgradedImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchUpgradedImage));

	TCHAR rgchTargetPC[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 3, rgchTargetPC, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchTargetPC));

	TCHAR rgchUpgradedPC[64];
	uiRet = IdsMsiGetTableString(hdb, TEXT("`UpgradedImages`"),
				TEXT("`Upgraded`"), TEXT("`ProductCode`"),
				rgchUpgradedImage, rgchUpgradedPC, 64);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchUpgradedPC));

	Assert(MSI_OKAY == IDS_OKAY);
	Assert(uiRet == IDS_OKAY);
	if (lstrcmpi(rgchTargetPC, rgchUpgradedPC))
		uiRet = IDS_CANCEL;

	return (uiRet);
}

static UINT IdsCheckProductVersion ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static BOOL FCheckForProductVersionMismatches ( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	BOOL fLower = fFalse;
	UINT ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`Upgraded`,`ProductVersion`"),
					szNull, IdsCheckProductVersion, (LPARAM)(hdb), (LPARAM)(&fLower));
	Assert(ids == IDS_OKAY || ids == IDS_CANCEL);
	if (ids == IDS_OKAY)
		return (fTrue);

	if (fLower)
		{
		if (IDNO == IMessageBoxIds(HdlgStatus(), IDS_PRODUCTVERSION_INVERSION, MB_YESNO | MB_ICONQUESTION))
			{
			FWriteLogFile(TEXT("  ERROR - Target ProductVersion is greater than Upgraded image.\r\n"));
			return (fFalse);
			}

		FWriteLogFile(TEXT("  User supressed error for Target ProductVersion greater than Upgraded image.\r\n"));
		return (fTrue);
		}

	TCHAR rgch[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdb, TEXT("AllowProductVersionMajorMismatches"), rgch, MAX_PATH) );
	
	if ((!FEmptySz(rgch)) && (*rgch != TEXT('0')))
		return (fTrue);

	if (IDNO == IMessageBoxIds(HdlgStatus(), IDS_PRODUCTVERSIONS_DONT_MATCH, MB_YESNO | MB_ICONQUESTION))
		{
		FWriteLogFile(TEXT("  ERROR - ProductVersions do not match between Target and Upgraded images.\r\n"));
		return (fFalse);
		}

	FWriteLogFile(TEXT("  User supressed error for ProductVersions not matching between Target and Upgraded images.\r\n"));

	return (fTrue);
}


/* ********************************************************************** */
static UINT IdsCheckProductVersion ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	MSIHANDLE hdb = (MSIHANDLE)(lp1);
	Assert(hdb != NULL);
	PBOOL pfLower = (PBOOL)(lp2);
	Assert(pfLower != NULL);

	TCHAR rgchUpgradedImage[64];
	DWORD dwcch = 64;
	UINT uiRet = MsiRecordGetString(hrec, 2, rgchUpgradedImage, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchUpgradedImage));

	TCHAR rgchTargetPV[64];
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 3, rgchTargetPV, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchTargetPV));

	TCHAR rgchUpgradedPV[64];
	uiRet = IdsMsiGetTableString(hdb, TEXT("`UpgradedImages`"),
				TEXT("`Upgraded`"), TEXT("`ProductVersion`"),
				rgchUpgradedImage, rgchUpgradedPV, 64);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchUpgradedPV));

	Assert(MSI_OKAY == IDS_OKAY);
	Assert(uiRet == IDS_OKAY);
	int i = ICompareVersions(rgchUpgradedPV, rgchTargetPV);
	if (i != 0)
		{
		uiRet = IDS_CANCEL;
		if (i < 0)
			*pfLower = fTrue;
		}

	return (uiRet);
}


/* ********************************************************************** */
static int ICompareVersions ( LPTSTR szUpgradedPC, LPTSTR szTargetPC )
{
	// compares the next field of the 2 versions.
	// if they match, make a recursive call to compare the next field
	
	Assert(szUpgradedPC != szNull);
	Assert(szTargetPC != szNull);
	if (*szUpgradedPC == TEXT('\0') && *szTargetPC == TEXT('\0'))
		return (0);

	LPTSTR szUpgradedNext = szUpgradedPC;
	while (*szUpgradedNext != TEXT('\0') && *szUpgradedNext != TEXT('.'))
		szUpgradedNext = CharNext(szUpgradedNext);
	if(*szUpgradedNext != TEXT('\0'))
	{
		*szUpgradedNext = TEXT('\0');
		szUpgradedNext++;
	}

	LPTSTR szTargetNext = szTargetPC;
	while (*szTargetNext != TEXT('\0') && *szTargetNext != TEXT('.'))
		szTargetNext = CharNext(szTargetNext);
	if(*szTargetNext != TEXT('\0'))
	{
		*szTargetNext = TEXT('\0');
		szTargetNext++;
	}

	int iUpgradedField = _ttoi(szUpgradedPC);
	int iTargetField   = _ttoi(szTargetPC);
	
	if(iUpgradedField < iTargetField)
		return (-1);
	else if(iUpgradedField > iTargetField)
		return (1);
	else
		return (ICompareVersions(szUpgradedNext, szTargetNext));
}


static UINT IdsCountTargets ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );
static UINT IdsCatTargetProductCode ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
static void FillInListOfTargetProductCodes ( MSIHANDLE hdb )
{
	Assert(hdb != NULL);

	UINT cchCur;
	cchCur = CchMsiPcwPropertyString(hdb, TEXT("ListOfTargetProductCodes"));
	if (cchCur < 63)
		cchCur = 64;
	else
		cchCur++;

	LPTSTR rgchCur = (LPTSTR)LocalAlloc(LPTR, cchCur*sizeof(TCHAR));
	Assert(rgchCur != szNull);
	if (rgchCur == szNull)
		return;


	UINT ids = IdsMsiGetPcwPropertyString(hdb, TEXT("ListOfTargetProductCodes"), rgchCur, cchCur);
	Assert(ids == IDS_OKAY);
	if (FEmptySz(rgchCur) || *rgchCur == TEXT('*'))
		{
		if (*rgchCur == TEXT('*'))
			{
			Assert(*(rgchCur+1) == TEXT('\0') || *(rgchCur+1) == TEXT(';'));
			if (*(rgchCur+1) == TEXT('\0'))
				*rgchCur = TEXT('\0');
			else if (*(rgchCur+1) == TEXT(';'))
				lstrcpy(rgchCur, rgchCur+2);
			else
				lstrcpy(rgchCur, rgchCur+1);
			}

		UINT cTargets = 0;
		ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`ProductCode`"), szNull,
					IdsCountTargets, (LPARAM)(&cTargets), 0);
		Assert(ids == IDS_OKAY);
		if (cTargets < 4)
			cTargets = 4;
		if (cTargets > 512)
			{
			AssertFalse();
			cTargets = 512;
			}

		LPTSTR rgchNew = (LPTSTR)LocalAlloc(LPTR, (cTargets*64 + cchCur)*sizeof(TCHAR));
		Assert(rgchNew != szNull);
		if (rgchNew == szNull)
			{
			EvalAssert( NULL == LocalFree((HLOCAL)rgchCur) );
			return;
			}


		*rgchNew = TEXT('\0');
		ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`ProductCode`"), szNull,
					IdsCatTargetProductCode, (LPARAM)(rgchNew),
					(LPARAM)(cTargets*64));
		Assert(ids == IDS_OKAY);
		Assert(!FEmptySz(rgchNew));

		if (!FEmptySz(rgchCur))
			{
			lstrcat(rgchNew, TEXT(";"));
			lstrcat(rgchNew, rgchCur);
			}

		ids = IdsMsiSetPcwPropertyString(hdb, TEXT("ListOfTargetProductCodes"), rgchNew);
		Assert(ids == IDS_OKAY);

		EvalAssert( NULL == LocalFree((HLOCAL)rgchNew) );
		}

	EvalAssert( NULL == LocalFree((HLOCAL)rgchCur) );
}


/* ********************************************************************** */
static UINT IdsCountTargets ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);
	Assert(lp2 == 0);

	UINT* pcTargets = (UINT*)(lp1);
	Assert(pcTargets != NULL);

	TCHAR rgch[64];
	DWORD dwcch = 64;
	UINT uiRet = MsiRecordGetString(hrec, 2, rgch, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgch));

	(*pcTargets)++;

	return (IDS_OKAY);
}


/* ********************************************************************** */
static UINT IdsCatTargetProductCode ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	LPTSTR szBuf  = (LPTSTR)(lp1);
	int    cchBuf = (int)(lp2);
	Assert(szBuf != szNull);
	Assert(cchBuf > 0);
	Assert(lstrlen(szBuf) < cchBuf);

	TCHAR rgch[64];
	DWORD dwcch = 64;
	UINT uiRet = MsiRecordGetString(hrec, 2, rgch, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgch));

	if (lstrlen(szBuf) + lstrlen(rgch) + 2 >= cchBuf)
		{
		AssertFalse();
		return (IDS_CANCEL);
		}

	LPTSTR sz = szBuf;
	while (!FEmptySz(sz))
		{
		Assert(lstrlen(sz) >= lstrlen(rgch));
		if (FMatchPrefix(sz, rgch))
			return (IDS_OKAY);
		sz += lstrlen(rgch);
		if (!FEmptySz(sz))
			{
			Assert(*sz == TEXT(';'));
			sz++;
			Assert(!FEmptySz(sz));
			}
		}

	if (!FEmptySz(szBuf))
		lstrcat(szBuf, TEXT(";"));
	lstrcat(szBuf, rgch);

	return (IDS_OKAY);
}


static UINT IdsCopyUpgradeMsi ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 );

/* ********************************************************************** */
UINT UiCopyUpgradedMsiToTempFolderForEachTarget ( MSIHANDLE hdb, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);

	hdbInput = hdb;

	UINT ids = IdsMsiEnumTable(hdb, TEXT("`TargetImages`"),
					TEXT("`Target`,`Upgraded`,`MsiPathUpgradedCopy`"),
					szNull, IdsCopyUpgradeMsi,
					(LPARAM)(szTempFolder), (LPARAM)(szTempFName));
	if (ids != IDS_OKAY)
		return (ids);

	return (ERROR_SUCCESS);
}


static UINT UiCreatePatchingTables ( MSIHANDLE hdb, LPTSTR szFamily, LPTSTR szTempFolder, LPTSTR szTempFName );

/* ********************************************************************** */
static UINT IdsCopyUpgradeMsi ( MSIHANDLE hview, MSIHANDLE hrec, LPARAM lp1, LPARAM lp2 )
{
	Assert(hview != NULL);
	Assert(hrec  != NULL);

	LPTSTR szTempFolder = (LPTSTR)(lp1);
	LPTSTR szTempFName  = (LPTSTR)(lp2);
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);
	Assert(szTempFolder != szTempFName);

	Assert(hdbInput != NULL);

	TCHAR rgchTarget[64];
	DWORD dwcch = 64;
	UINT uiRet = MsiRecordGetString(hrec, 1, rgchTarget, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchTarget));
	Assert(FValidImageName(rgchTarget));

	lstrcpy(szTempFName, rgchTarget);
	lstrcat(szTempFName, TEXT(".MSI"));
	Assert(!FFileExist(szTempFolder));
	Assert(!FFolderExist(szTempFolder));

#define rgchUpgraded rgchTarget // reuse buffer
	dwcch = 64;
	uiRet = MsiRecordGetString(hrec, 2, rgchUpgraded, &dwcch);
	Assert(uiRet != ERROR_MORE_DATA);
	Assert(uiRet == MSI_OKAY);
	Assert(!FEmptySz(rgchUpgraded));
	Assert(FValidImageName(rgchUpgraded));

	TCHAR rgchUpgradedMsi[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput,
					TEXT("`UpgradedImages`"), TEXT("`Upgraded`"),
					TEXT("`PatchMsiPath`"), rgchUpgraded, rgchUpgradedMsi, MAX_PATH) );
	if (FEmptySz(rgchUpgradedMsi))
		{
		EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput,
						TEXT("`UpgradedImages`"), TEXT("`Upgraded`"),
						TEXT("`MsiPath`"), rgchUpgraded, rgchUpgradedMsi, MAX_PATH) );
		Assert(!FEmptySz(rgchUpgradedMsi));
		}
	Assert(FFileExist(rgchUpgradedMsi));

	if (!CopyFile(rgchUpgradedMsi, szTempFolder, fFalse))
		return (UiLogError(ERROR_PCW_OODS_COPYING_MSI, rgchUpgradedMsi, szTempFolder));

	SetFileAttributes(szTempFolder, FILE_ATTRIBUTE_NORMAL);

	MSIHANDLE hdb = NULL;
	EvalAssert( MSI_OKAY == MsiOpenDatabase(szTempFolder, MSIDBOPEN_DIRECT, &hdb) );
	Assert(hdb != NULL);

	EvalAssert( MSI_OKAY == MsiRecordSetString(hrec, 3, szTempFolder) );
	EvalAssert( MSI_OKAY == MsiViewModify(hview, MSIMODIFY_UPDATE, hrec) );

#define rgchPackageCode rgchUpgradedMsi // reuse buffer
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`"), TEXT("`PackageCode`"), rgchUpgraded,
					rgchPackageCode, MAX_PATH) );
	EvalAssert( IDS_OKAY == IdsMsiSetPropertyString(hdb,
					TEXT("PATCHNEWPACKAGECODE"), rgchPackageCode) );

#define rgchSummSubject rgchUpgradedMsi // reuse buffer
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`"), TEXT("`SummSubject`"), rgchUpgraded,
					rgchSummSubject, MAX_PATH) );
	EvalAssert( IDS_OKAY == IdsMsiSetPropertyString(hdb,
					TEXT("PATCHNEWSUMMARYSUBJECT"), rgchSummSubject) );

#define rgchSummComments rgchUpgradedMsi // reuse buffer
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`"), TEXT("`SummComments`"), rgchUpgraded,
					rgchSummComments, MAX_PATH) );
	EvalAssert( IDS_OKAY == IdsMsiSetPropertyString(hdb,
					TEXT("PATCHNEWSUMMARYCOMMENTS"), rgchSummComments) );

#define rgchFamily rgchUpgradedMsi // reuse buffer
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`UpgradedImages`"),
					TEXT("`Upgraded`"), TEXT("`Family`"), rgchUpgraded,
					rgchFamily, 64) );
	Assert(!FEmptySz(rgchFamily));
	Assert(FValidFamilyName(rgchFamily));

	uiRet = UiCreatePatchingTables(hdb, rgchFamily, szTempFolder, szTempFName);

	EvalAssert( MSI_OKAY == MsiDatabaseCommit(hdb) );
	EvalAssert( MSI_OKAY == MsiCloseHandle(hdb) );

	return (uiRet);
}


static BOOL FValidPatchTableFormat  ( MSIHANDLE hdb, pteEnum ptePatchTable );
static void UpdatePatchPackageTable ( MSIHANDLE hdb, MSIHANDLE hdbInput, LPTSTR szFamily );
static void UpdateMediaTable        ( MSIHANDLE hdb, MSIHANDLE hdbInput, LPTSTR szFamily );
static void InsertPatchFilesActionIntoTable ( MSIHANDLE hdb, LPTSTR szTable );

/* ********************************************************************** */
static UINT UiCreatePatchingTables ( MSIHANDLE hdb, LPTSTR szFamily, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szFamily));
	Assert(FValidFamilyName(szFamily));
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);
	Assert(szTempFolder != szTempFName);

	lstrcpy(szTempFName, TEXT("Patch.idt"));
	Assert(FFileExist(szTempFolder));
	lstrcpy(szTempFName, TEXT("PPackage.idt"));
	Assert(FFileExist(szTempFolder));
	lstrcpy(szTempFName, TEXT("MsiPatch.idt"));
	Assert(FFileExist(szTempFolder));
	*szTempFName = TEXT('\0');

	if (FTableExists(hdb, TEXT("Patch"), fFalse) && !FValidPatchTableFormat(hdb, ptePatch))
		{
		// drop the Patch table 
		MSIHANDLE hViewPatch = NULL;
		EvalAssert( MSI_OKAY == MsiDatabaseOpenView(hdb, TEXT("DROP TABLE `Patch`"), &hViewPatch) );
		EvalAssert( MSI_OKAY == MsiViewExecute(hViewPatch, 0) );
		EvalAssert( MSI_OKAY == MsiViewClose(hViewPatch) );
		EvalAssert( MSI_OKAY == MsiCloseHandle(hViewPatch) );
		EvalAssert( MSI_OKAY == MsiDatabaseCommit(hdb) );
		}

	EvalAssert( ERROR_SUCCESS == MsiDatabaseImport(hdb, szTempFolder, TEXT("Patch.idt")) );
	Assert(FTableExists(hdb, TEXT("Patch"), fFalse));
	Assert(FValidPatchTableFormat(hdb, ptePatch));

	if (!FTableExists(hdb, TEXT("PatchPackage"), fFalse))
		{
		EvalAssert( ERROR_SUCCESS == MsiDatabaseImport(hdb, szTempFolder, TEXT("PPackage.idt")) );
		Assert(FTableExists(hdb, TEXT("PatchPackage"), fFalse));
		}
	Assert(FValidPatchTableFormat(hdb, ptePatchPackage));

	if (!FTableExists(hdb, TEXT("MsiPatchHeaders"), fFalse))
		{
		EvalAssert( ERROR_SUCCESS == MsiDatabaseImport(hdb, szTempFolder, TEXT("MsiPatch.idt")) );
		Assert(FTableExists(hdb, TEXT("MsiPatchHeaders"), fFalse));
		}
	Assert(FValidPatchTableFormat(hdb, pteMsiPatchHeaders));

	Assert(hdbInput != NULL);
	UpdatePatchPackageTable(hdb, hdbInput, szFamily);
	UpdateMediaTable(hdb, hdbInput, szFamily);
	InsertPatchFilesActionIntoTable(hdb, TEXT("`InstallExecuteSequence`"));
	InsertPatchFilesActionIntoTable(hdb, TEXT("`AdminExecuteSequence`"));

	return (IDS_OKAY);
}


/* ********************************************************************** */
BOOL FExecSqlCmd ( MSIHANDLE hdb, LPTSTR sz )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(sz));

	MSIHANDLE hview = NULL;
	UINT      uiRet = MsiDatabaseOpenView(hdb, sz, &hview);
	if (uiRet != MSI_OKAY)
		{
		AssertFalse();
		return (fFalse);
		}
	uiRet = MsiViewExecute(hview, 0);
	if (uiRet != IDS_OKAY)
		{
		AssertFalse();
		return (fFalse);
		}
	EvalAssert( MSI_OKAY == MsiCloseHandle(hview) );

	return (fTrue);
}


/* ********************************************************************** */
static void UpdatePatchPackageTable ( MSIHANDLE hdb, MSIHANDLE hdbInput, LPTSTR szFamily )
{
	Assert(hdb != NULL);
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szFamily));
	Assert(FValidFamilyName(szFamily));

	int iDiskId;
	EvalAssert( IDS_OKAY == IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), TEXT("`MediaDiskId`"), szFamily, &iDiskId) );

	if (iDiskId == MSI_NULL_INTEGER)
		{
		// assume this is a Windows Installer 2.0 targeted patch; we have validation elsewhere to catch this
		// iDiskId is set to 2 (always) in this case.  The sequence conflict management feature of Windows
		// Installer 2.0 can handle this

		iDiskId = 2;
		}
	Assert(iDiskId > 1);

	TCHAR rgch[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput, TEXT("PatchGUID"), rgch, MAX_PATH) );
	Assert(!FEmptySz(rgch));
	CharUpper(rgch);

	MSIHANDLE hrec = MsiCreateRecord(2);
	Assert(hrec != NULL);
	EvalAssert( MsiRecordSetString(hrec, 1, rgch) == MSI_OKAY );
	EvalAssert( MsiRecordSetInteger(hrec, 2, iDiskId) == MSI_OKAY );

	TCHAR rgchQuery[MAX_PATH];
	wsprintf(rgchQuery, TEXT("SELECT %s FROM %s WHERE %s='%s'"),
			TEXT("`PatchId`,`Media_`"), TEXT("`PatchPackage`"),
			TEXT("`PatchId`"), rgch);
	Assert(lstrlen(rgchQuery) < sizeof(rgchQuery)/sizeof(TCHAR));

	MSIHANDLE hview = NULL;
	EvalAssert( MsiDatabaseOpenView(hdb, rgchQuery, &hview) == MSI_OKAY );
	Assert(hview != NULL);
	EvalAssert( MsiViewExecute(hview, 0) == MSI_OKAY );
	EvalAssert( MsiViewModify(hview, MSIMODIFY_ASSIGN, hrec) == MSI_OKAY );

	EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);
}


/* ********************************************************************** */
static void UpdateMediaTable ( MSIHANDLE hdb, MSIHANDLE hdbInput, LPTSTR szFamily )
{
	Assert(hdb != NULL);
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szFamily));
	Assert(FValidFamilyName(szFamily));

	int iDiskId;
	EvalAssert( IDS_OKAY == IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), TEXT("`MediaDiskId`"), szFamily, &iDiskId) );

	if (iDiskId == MSI_NULL_INTEGER)
		{
		// assume WI 2.0 targeted patch (MediaDiskId can be NULL); validation elsewhere -- sequence conflict management
		// feature of WI 2.0 handles this, set to 2 always in this case
		iDiskId = 2;
		}
	Assert(iDiskId > 1);

	int iFileSeqStart;
	EvalAssert( IDS_OKAY == IdsMsiGetTableInteger(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), TEXT("`FileSequenceStart`"), szFamily, &iFileSeqStart) );

	if (iFileSeqStart == MSI_NULL_INTEGER)
		{
		// assume WI 2.0 targeted patch (FileSequenceStart can be NULL); validation elsewhere -- sequence conflict management
		// feature of WI 2.0 handles this, set to 2 always in this case
		iFileSeqStart = 2;
		}
	Assert(iFileSeqStart > 1);

	TCHAR rgchCabName[MAX_PATH];
	wsprintf(rgchCabName, TEXT("#PCW_CAB_%s"), szFamily);

	MSIHANDLE hrec = MsiCreateRecord(6);
	Assert(hrec != NULL);
	EvalAssert( MsiRecordSetInteger(hrec, 1, iDiskId) == MSI_OKAY );
	EvalAssert( MsiRecordSetInteger(hrec, 2, iFileSeqStart) == MSI_OKAY ); // to be updated later
	EvalAssert( MsiRecordSetString(hrec,  3, rgchCabName) == MSI_OKAY );

	TCHAR rgch[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), TEXT("`MediaSrcPropName`"), szFamily, rgch, MAX_PATH) );
	if (!FEmptySz(rgch))
		{
		EvalAssert( MsiRecordSetString(hrec,  4, rgch) == MSI_OKAY );
		}
	else
		{
		// else WI 2.0 targeted patch (MediaSrcPropName can be NULL); validation elsewhere -- sequence conflict management feature
		// of WI 2.0 handles this, set to PATCHMediaSrcProp always in this case
		EvalAssert( MsiRecordSetString(hrec, 4, szPatchMediaSrcProp) == MSI_OKAY );
		}

	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), TEXT("`DiskPrompt`"), szFamily, rgch, MAX_PATH) );
	EvalAssert( MsiRecordSetString(hrec,  5, rgch) == MSI_OKAY );

	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, TEXT("`ImageFamilies`"),
					TEXT("`Family`"), TEXT("`VolumeLabel`"), szFamily, rgch, MAX_PATH) );
	EvalAssert( MsiRecordSetString(hrec,  6, rgch) == MSI_OKAY );

#define rgchQuery rgchCabName // reuse buffer
	wsprintf(rgchQuery, TEXT("SELECT %s FROM %s WHERE %s=%d"),
			TEXT("`DiskId`,`LastSequence`,`Cabinet`,`Source`,`DiskPrompt`,`VolumeLabel`"),
			TEXT("`Media`"), TEXT("`DiskId`"), iDiskId);
	Assert(lstrlen(rgchQuery) < sizeof(rgchQuery)/sizeof(TCHAR));

	MSIHANDLE hview = NULL;
	EvalAssert( MsiDatabaseOpenView(hdb, rgchQuery, &hview) == MSI_OKAY );
	Assert(hview != NULL);
	EvalAssert( MsiViewExecute(hview, 0) == MSI_OKAY );
	EvalAssert( MsiViewModify(hview, MSIMODIFY_ASSIGN, hrec) == MSI_OKAY );

	EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);
}


/* ********************************************************************** */
static void InsertPatchFilesActionIntoTable ( MSIHANDLE hdb, LPTSTR szTable )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!lstrcmp(szTable, TEXT("`InstallExecuteSequence`"))
				|| !lstrcmp(szTable, TEXT("`AdminExecuteSequence`")));

	BOOL fExists = fFalse;
	EvalAssert( IDS_OKAY == IdsMsiExistTableRecords(hdb, szTable,
					TEXT("`Action`"), TEXT("PatchFiles"), &fExists) );
	if (fExists)
		return;

	int iSeq = 0;
	EvalAssert( IDS_OKAY == IdsMsiGetTableInteger(hdb, szTable,
					TEXT("`Action`"), TEXT("`Sequence`"),
					TEXT("InstallFiles"), &iSeq) );
	Assert(iSeq > 0);

	MSIHANDLE hrec = MsiCreateRecord(2);
	Assert(hrec != NULL);
	EvalAssert( MsiRecordSetString(hrec, 1, TEXT("PatchFiles")) == MSI_OKAY );
	EvalAssert( MsiRecordSetInteger(hrec, 2, iSeq + 1) == MSI_OKAY );

	TCHAR rgchQuery[MAX_PATH];
	wsprintf(rgchQuery, TEXT("SELECT %s FROM %s WHERE %s='%s'"),
			TEXT("`Action`,`Sequence`"), szTable,
			TEXT("`Action`"), TEXT("PatchFiles"));
	Assert(lstrlen(rgchQuery) < sizeof(rgchQuery)/sizeof(TCHAR));

	MSIHANDLE hview = NULL;
	EvalAssert( MsiDatabaseOpenView(hdb, rgchQuery, &hview) == MSI_OKAY );
	Assert(hview != NULL);
	EvalAssert( MsiViewExecute(hview, 0) == MSI_OKAY );
	EvalAssert( MsiViewModify(hview, MSIMODIFY_ASSIGN, hrec) == MSI_OKAY );

	EvalAssert(MsiCloseHandle(hrec) == MSI_OKAY);
	EvalAssert(MsiCloseHandle(hview) == MSI_OKAY);
}


static void LogSzProp  ( MSIHANDLE hdbInput, LPTSTR szProp, LPTSTR szBuf, LPTSTR szBufLog );
static UINT UiCreatePatchingTableExportFile ( MSIHANDLE hdbInput, pteEnum ptePatchTable, LPTSTR szTempFolder, LPTSTR szTempFName );

#define BIGPROPERTYSIZE (49*1024)

/* ********************************************************************** */
static UINT UiValidateAndLogPCWProperties ( MSIHANDLE hdbInput, LPTSTR szPcpPath, LPTSTR szPatchPath, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szPcpPath));
	Assert(!FEmptySz(szPatchPath));
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);
	*szTempFName = TEXT('\0');
	Assert(!FEmptySz(szTempFolder));

	EvalAssert( FSprintfToLog(TEXT("Input-PCP path                     = '%s'"), szPcpPath, szEmpty, szEmpty, szEmpty) );
	EvalAssert( FSprintfToLog(TEXT("Patch-MSP path                     = '%s'"), szPatchPath, szEmpty, szEmpty, szEmpty) );
	EvalAssert( FSprintfToLog(TEXT("Temp Folder                        = '%s'"), szTempFolder, szEmpty, szEmpty, szEmpty) );

	TCHAR rgchLog[BIGPROPERTYSIZE+64];

	TCHAR rgch[BIGPROPERTYSIZE];
	UINT ids;

	UpdateStatusMsg(0, szNull, TEXT("PatchGUID"));
	ids = IdsMsiGetPcwPropertyString(hdbInput, TEXT("PatchGUID"), rgch, MAX_PATH);
	Assert(ids == IDS_OKAY);
	CharUpper(rgch);
	if (FEmptySz(rgch))
		return (UiLogError(ERROR_PCW_MISSING_PATCH_GUID, NULL, NULL));
	if (!FValidGUID(rgch, fFalse, fFalse, fFalse))
		return (UiLogError(ERROR_PCW_BAD_PATCH_GUID, rgch, NULL));

	wsprintf(rgchLog, TEXT("Patch GUID                         = '%s'\r\n"), rgch);
	EvalAssert( FWriteLogFile(rgchLog) );
	EvalAssert( FUniquePackageCode(rgch, hdbInput) ); // first entry

	UpdateStatusMsg(0, szNull, TEXT("ListOfPatchGUIDsToReplace"));
	ids = IdsMsiGetPcwPropertyString(hdbInput, TEXT("ListOfPatchGUIDsToReplace"), rgch, BIGPROPERTYSIZE);
	Assert(ids == IDS_OKAY);
	CharUpper(rgch);
	if (FEmptySz(rgch))
		lstrcpy(rgch, TEXT("<none>"));
	else if (!FValidGUID(rgch, fTrue, fFalse, fFalse))
		return (UiLogError(ERROR_PCW_BAD_GUIDS_TO_REPLACE, rgch, NULL));

	wsprintf(rgchLog, TEXT("ListOfPatchGUIDsToReplace          = '%s'\r\n"), rgch);
	EvalAssert( FWriteLogFile(rgchLog) );

	UpdateStatusMsg(0, szNull, TEXT("ListOfTargetProductCodes"));
	// zzz this could overflow buffer
	ids = IdsMsiGetPcwPropertyString(hdbInput, TEXT("ListOfTargetProductCodes"), rgch, BIGPROPERTYSIZE);
	Assert(ids == IDS_OKAY);
	CharUpper(rgch);
	if (FEmptySz(rgch))
		lstrcpy(rgch, TEXT("*"));
	if (!FValidGUID(rgch, fTrue, fTrue, fTrue))
		return (UiLogError(ERROR_PCW_BAD_TARGET_PRODUCT_CODE_LIST, rgch, NULL));

	wsprintf(rgchLog, TEXT("ListOfTargetProductCodes           = '%s'\r\n"), rgch);
	EvalAssert( FWriteLogFile(rgchLog) );

	LogSzProp(hdbInput, TEXT("PatchSourceList"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("AllowProductCodeMismatches"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("AllowProductVersionMajorMismatches"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("OptimizePatchSizeForLargeFiles"), rgch, rgchLog);

	UpdateStatusMsg(0, szNull, TEXT("ApiPatchingSymbolFlags"));
	ids = IdsMsiGetPcwPropertyString(hdbInput, TEXT("ApiPatchingSymbolFlags"), rgch, MAX_PATH);
	Assert(ids == IDS_OKAY);
	if (FEmptySz(rgch))
		lstrcpy(rgch, TEXT("<blank>"));
	else if (!FValidHexValue(rgch) || !FValidApiPatchSymbolFlags(UlFromHexSz(rgch)))
		return (UiLogError(ERROR_PCW_BAD_API_PATCHING_SYMBOL_FLAGS, rgch, NULL));
	wsprintf(rgchLog, TEXT("ApiPatchingSymbolFlags             = '%s'\r\n"), rgch);
	EvalAssert( FWriteLogFile(rgchLog) );

	LogSzProp(hdbInput, TEXT("MsiFileToUseToCreatePatchTables"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("SqlCmdToCreatePatchTable"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("SqlCmdToCreatePatchPackageTable"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("SqlCmdToCreateMsiPatchHeadersTable"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("DontRemoveTempFolderWhenFinished"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("IncludeWholeFilesOnly"), rgch, rgchLog);
	LogSzProp(hdbInput, TEXT("MinimumRequiredMsiVersion"), rgch, rgchLog);
	EvalAssert( FWriteLogFile(TEXT("\r\n")) );

	ids = UiCreatePatchingTableExportFile(hdbInput, ptePatch, szTempFolder, szTempFName);
	if (ids != IDS_OKAY)
		return (ids);
	ids = UiCreatePatchingTableExportFile(hdbInput, ptePatchPackage, szTempFolder, szTempFName);
	if (ids != IDS_OKAY)
		return (ids);
	ids = UiCreatePatchingTableExportFile(hdbInput, pteMsiPatchHeaders, szTempFolder, szTempFName);
	if (ids != IDS_OKAY)
		return (ids);
	*szTempFName = TEXT('\0');
	EvalAssert( FWriteLogFile(TEXT("\r\n")) );

	return (ERROR_SUCCESS);
}


static BOOL FHexChars ( LPTSTR * psz, UINT cch, BOOL fAllowLower );

/* ********************************************************************** */
static BOOL FValidGUID ( LPTSTR sz, BOOL fList, BOOL fLeadAsterisk, BOOL fSemiColonSeparated )
{
	Assert(sz != szNull);

	if (fLeadAsterisk && *sz == TEXT('*'))
		{
		Assert(fList);
		Assert(fSemiColonSeparated);
		sz = CharNext(sz);
		if (*sz == TEXT('\0'))
			return (fTrue);
		if (*sz != TEXT(';'))
			return (fFalse);
		return (FValidGUID(CharNext(sz), fTrue, fFalse, fTrue));
		}

	if (*sz != TEXT('{'))
		return (fFalse);
	sz = CharNext(sz);

	if (!FHexChars(&sz, 8, fFalse))
		return (fFalse);

	if (*sz != TEXT('-'))
		return (fFalse);
	sz = CharNext(sz);

	if (!FHexChars(&sz, 4, fFalse))
		return (fFalse);

	if (*sz != TEXT('-'))
		return (fFalse);
	sz = CharNext(sz);

	if (!FHexChars(&sz, 4, fFalse))
		return (fFalse);

	if (*sz != TEXT('-'))
		return (fFalse);
	sz = CharNext(sz);

	if (!FHexChars(&sz, 4, fFalse))
		return (fFalse);

	if (*sz != TEXT('-'))
		return (fFalse);
	sz = CharNext(sz);

	if (!FHexChars(&sz, 12, fFalse))
		return (fFalse);

	if (*sz != TEXT('}'))
		return (fFalse);
	sz = CharNext(sz);

	if (*sz != TEXT('\0'))
		{
		if (!fList)
			return (fFalse);
		if (fSemiColonSeparated && *sz != TEXT(';'))
			return (fFalse);
		if (fSemiColonSeparated)
			sz = CharNext(sz);

		return (FValidGUID(sz, fList, fFalse, fSemiColonSeparated));
		}

	return (fTrue);
}


/* ********************************************************************** */
BOOL FValidHexValue ( LPTSTR sz )
{
	Assert(sz != szNull);

	return (*sz++ == TEXT('0') && *sz++ == TEXT('x') && FHexChars(&sz, 8, fTrue) && *sz == TEXT('\0'));
}


/* ********************************************************************** */
static BOOL FHexChars ( LPTSTR * psz, UINT cch, BOOL fAllowLower )
{
	Assert(psz != NULL);
	Assert(*psz != szNull);
	Assert(cch == 4 || cch == 8 || cch == 12);

	LPTSTR sz = *psz;
	while (cch--)
		{
		if (*sz >= TEXT('0') && *sz <= TEXT('9'))
			;
		else if (*sz >= TEXT('A') && *sz <= TEXT('F'))
			;
		else if (fAllowLower && *sz >= TEXT('a') && *sz <= TEXT('f'))
			;
		else
			return (fFalse);
		sz = CharNext(sz);
		}

	*psz = sz;

	return (fTrue);
}


/* ********************************************************************** */
static BOOL FValidPropertyName ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));

	if (lstrlen(sz) > 70)
		return (fFalse);

	TCHAR rgch[128];
	lstrcpy(rgch, sz);
	sz = rgch;
	CharUpper(sz);

	TCHAR ch = *sz++;
	if (ch != TEXT('_') && (ch < TEXT('A') || ch > TEXT('Z')))
		return (fFalse);

	while ((ch = *sz++) != TEXT('\0'))
		{
		if (ch != TEXT('_') && ch != TEXT('.')
				&& (ch < TEXT('A') || ch > TEXT('Z'))
				&& (ch < TEXT('0') || ch > TEXT('9')))
			{
			return (fFalse);
			}
		}

	return (fTrue);
}


/* ********************************************************************** */
static BOOL FValidDiskId ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));

	DWORD dw = 0;
	while (*sz != TEXT('\0'))
		{
		TCHAR ch = *sz++;
		if (ch < TEXT('0') || ch > TEXT('9'))
			return (fFalse);
		if (dw > 3276)
			return (fFalse);
		dw = (dw * 10) + (DWORD)(ch - TEXT('0'));
		}

	return (dw <= 32767 && dw > 0);
}


/* ********************************************************************** */
ULONG UlFromHexSz ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));
	Assert(FValidHexValue(sz));
	Assert(FMatchPrefix(sz, TEXT("0x")));
	sz += lstrlen(TEXT("0x"));

	ULONG ul = 0L;

	while (*sz != TEXT('\0'))
		{
		TCHAR ch = *sz, chBase;
		if (ch >= TEXT('0') && ch <= TEXT('9'))
			chBase = TEXT('0');
		else if (ch >= TEXT('A') && ch <= TEXT('F'))
			chBase = TEXT('A') - 10;
		else if (ch >= TEXT('a') && ch <= TEXT('f'))
			chBase = TEXT('a') - 10;
		else
			{ AssertFalse(); }

		ul = (ul * 16) + (ch - chBase);
		sz = CharNext(sz);
		}

	return (ul);
}


/* ********************************************************************** */
BOOL FValidApiPatchSymbolFlags ( ULONG ul )
{
	if (ul > (PATCH_SYMBOL_NO_IMAGEHLP + PATCH_SYMBOL_NO_FAILURES + PATCH_SYMBOL_UNDECORATED_TOO))
		return (fFalse);

	return (fTrue);
}


/* ********************************************************************** */
static void LogSzProp ( MSIHANDLE hdbInput, LPTSTR szProp, LPTSTR szBuf, LPTSTR szBufLog )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szProp));
	Assert(szBuf != szNull);
	Assert(szBufLog != szNull);

	UpdateStatusMsg(0, szNull, szProp);
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput, szProp, szBuf, MAX_PATH) );
	if (FEmptySz(szBuf))
		lstrcpy(szBuf, TEXT("<blank>"));
	wsprintf(szBufLog, TEXT("%-34s = '%s'\r\n"), szProp, szBuf);
	EvalAssert( FWriteLogFile(szBufLog) );
}


static BOOL FMsiExistAnyTableRecords ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField );

/* ********************************************************************** */
static UINT UiCreatePatchingTableExportFile ( MSIHANDLE hdbInput, pteEnum ptePatchTable, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szTempFolder));
	Assert(szTempFName != szNull);
	Assert(szTempFolder != szTempFName);
	Assert(ptePatchTable > pteFirstEnum && ptePatchTable < pteNextEnum);

	LPTSTR szTable        = TEXT("Patch");
	LPTSTR szField        = TEXT("`PatchSize`");
	LPTSTR szFName        = TEXT("Patch.idt");
	LPTSTR szCreateSqlCmd = TEXT("CREATE TABLE `Patch` ( `File_` CHAR(72) NOT NULL, `Sequence` INTEGER NOT NULL, `PatchSize` LONG NOT NULL, `Attributes` INTEGER NOT NULL, `Header` OBJECT, `StreamRef_` CHAR(72)  PRIMARY KEY `File_`, `Sequence` )");
	LPTSTR szDropSqlCmd   = TEXT("DROP   TABLE `Patch`");
	LPTSTR szEmptySqlCmd  = TEXT("DELETE FROM  `Patch`");
	if (ptePatchPackage == ptePatchTable)
		{
		szTable        = TEXT("PatchPackage");
		szField        = TEXT("`PatchId`");
		szFName        = TEXT("PPackage.idt");
		szCreateSqlCmd = TEXT("CREATE TABLE `PatchPackage` ( `PatchId` CHAR(38) NOT NULL, `Media_` INTEGER NOT NULL PRIMARY KEY `PatchId` )");
		szDropSqlCmd   = TEXT("DROP   TABLE `PatchPackage`");
		szEmptySqlCmd  = TEXT("DELETE FROM  `PatchPackage`");
		}
	else if (pteMsiPatchHeaders == ptePatchTable)
		{
		szTable        = TEXT("MsiPatchHeaders");
		szField        = TEXT("`StreamRef`");
		szFName        = TEXT("MsiPatch.idt");
		szCreateSqlCmd = TEXT("CREATE TABLE `MsiPatchHeaders` ( `StreamRef` CHAR(38) NOT NULL, `Header` OBJECT NOT NULL PRIMARY KEY `StreamRef` )");
		szDropSqlCmd   = TEXT("DROP   TABLE `MsiPatchHeaders`");
		szEmptySqlCmd  = TEXT("DELETE FROM  `MsiPatchHeaders`");
		}

	if (FTableExists(hdbInput, szTable, fFalse))
		{
		if (FValidPatchTableFormat(hdbInput, ptePatchTable))
			{
			if (FMsiExistAnyTableRecords(hdbInput, szTable, szField))
				{
				EvalAssert( FSprintfToLog(TEXT("WARNING (22): PCP: ignoring records in table '%s'."), szTable, szEmpty, szEmpty, szEmpty) );
				EvalAssert( FExecSqlCmd(hdbInput, szEmptySqlCmd) );
				}
			EvalAssert( FSprintfToLog(TEXT("Using '%s' table from PCP."), szTable, szEmpty, szEmpty, szEmpty) );
			goto LTableExists;
			}
		EvalAssert( FSprintfToLog(TEXT("WARNING (21): PCP: bad table syntax for '%s'; ignoring."), szTable, szEmpty, szEmpty, szEmpty) );
		EvalAssert( FExecSqlCmd(hdbInput, szDropSqlCmd) );
		Assert(!FTableExists(hdbInput, szTable, fFalse));
		}


	BOOL fUsingDefaultMsi;
	fUsingDefaultMsi = fFalse;
	TCHAR rgchMsiPath[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput, TEXT("MsiFileToUseToCreatePatchTables"), rgchMsiPath, MAX_PATH) );
	if (!FEmptySz(rgchMsiPath))
		{
		MSIHANDLE hdb;
		hdb = NULL;
		TCHAR rgchFullPath[MAX_PATH];
		if (MSI_OKAY != MsiOpenDatabase(rgchMsiPath, MSIDBOPEN_READONLY, &hdb))
			{
			Assert(hdb == NULL);
LHandleRelativePath:
			hdb = NULL;
			if (FFixupPathEx(rgchMsiPath, rgchFullPath))
				MsiOpenDatabase(rgchFullPath, MSIDBOPEN_READONLY, &hdb);
			// should we try DLL's folder instead of just CWD??
			}
		else
			lstrcpy(rgchFullPath, rgchMsiPath);

		if (hdb != NULL)
			{
			if (FTableExists(hdb, szTable, fFalse))
				{
				if (!FValidPatchTableFormat(hdb, ptePatchTable))
					{
					EvalAssert( FSprintfToLog(TEXT("WARNING (23): bad table syntax for '%s' found in file '%s'; ignoring."), szTable, rgchFullPath, szEmpty, szEmpty) );
					}
				else
					{
					LPTSTR szFNameTmp = (ptePatch == ptePatchTable) ? TEXT("export1.idt") : ((ptePatchPackage == ptePatchTable) ? TEXT("export2.idt") : TEXT("export3.idt"));
					lstrcpy(szTempFName, szFNameTmp);
					Assert(!FFileExist(szTempFolder));
					*szTempFName = TEXT('\0');

					UINT uiRet = MsiDatabaseExport(hdb, szTable, szTempFolder, szFNameTmp);
					lstrcpy(szTempFName, szFNameTmp);
					if (!FFileExist(szTempFolder))
						{
						EvalAssert( FSprintfToLog(TEXT("WARNING (24): unable to export table '%s' from file '%s'; ignoring."), szTable, rgchFullPath, szEmpty, szEmpty) );
						}
					else
						{
						Assert(uiRet == MSI_OKAY);
						*szTempFName = TEXT('\0');
						EvalAssert( MSI_OKAY == MsiDatabaseImport(hdbInput, szTempFolder, szFNameTmp) );
						Assert(FTableExists(hdbInput, szTable, fFalse));
						Assert(FValidPatchTableFormat(hdbInput, ptePatchTable));
						EvalAssert( FExecSqlCmd(hdbInput, szEmptySqlCmd) );
						// wait to goto LTableExists; until hdb closed
						}
					}
				}

			MsiCloseHandle(hdb);
			hdb = NULL;

			if (FTableExists(hdbInput, szTable, fFalse))
				{
				EvalAssert( FSprintfToLog(TEXT("Exported '%s' table from MSI file '%s'."), szTable, rgchFullPath, szEmpty, szEmpty) );
				goto LTableExists;
				}
			}
		else if (ptePatch == ptePatchTable && !fUsingDefaultMsi)
			{
			EvalAssert( FSprintfToLog(TEXT("WARNING (25): unable to find MSI file '%s' to export 'Patch' and/or 'PatchPackage' tables; ignoring."), rgchFullPath, szEmpty, szEmpty, szEmpty) );
			}
		}

	if (FEmptySz(rgchMsiPath) && lstrcmpi(rgchMsiPath, TEXT("patch.msi")))
		{
		lstrcpy(rgchMsiPath, TEXT("patch.msi"));
		fUsingDefaultMsi = fTrue;
		goto LHandleRelativePath;
		}


#define rgchPropSqlCmd rgchMsiPath // reuse buffer
	LPTSTR szPcpSqlPropName;
	szPcpSqlPropName = (ptePatch == ptePatchTable) ? TEXT("SqlCmdToCreatePatchTable") : ((ptePatchPackage == ptePatchTable) ? TEXT("SqlCmdToCreatePatchPackageTable") : TEXT("SqlCmdToCreateMsiPatchHeadersTable"));
	EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput, szPcpSqlPropName, rgchPropSqlCmd, MAX_PATH) );
	if (!FEmptySz(rgchPropSqlCmd))
		{
		if (!FExecSqlCmd(hdbInput, rgchPropSqlCmd))
			{
			EvalAssert( FSprintfToLog(TEXT("WARNING (26): could not execute PCP SQL command: '%s'; ignoring."), szPcpSqlPropName, szEmpty, szEmpty, szEmpty) );
			}
		else if (!FTableExists(hdbInput, szTable, fFalse))
			{
			EvalAssert( FSprintfToLog(TEXT("WARNING (27): no table created by PCP SQL command: '%s'; ignoring."), szPcpSqlPropName, szEmpty, szEmpty, szEmpty) );
			}
		else if (!FValidPatchTableFormat(hdbInput, ptePatchTable))
			{
			EvalAssert( FSprintfToLog(TEXT("WARNING (28): bad table format created by PCP SQL command: '%s'; ignoring."), szPcpSqlPropName, szEmpty, szEmpty, szEmpty) );
			EvalAssert( FExecSqlCmd(hdbInput, szDropSqlCmd) );
			Assert(!FTableExists(hdbInput, szTable, fFalse));
			}
		else
			{
			EvalAssert( FSprintfToLog(TEXT("Using SQL cmd from PCP's Properties to create '%s' table."), szTable, szEmpty, szEmpty, szEmpty) );
			goto LTableExists;
			}
		}

	EvalAssert( FSprintfToLog(TEXT("Using internal SQL cmd to create '%s' table."), szTable, szEmpty, szEmpty, szEmpty) );
	EvalAssert( FExecSqlCmd(hdbInput, szCreateSqlCmd) );

LTableExists:
	Assert(FTableExists(hdbInput, szTable, fFalse));
	Assert(FValidPatchTableFormat(hdbInput, ptePatchTable));
	Assert(!FMsiExistAnyTableRecords(hdbInput, szTable, szField));

	*szTempFName = TEXT('\0');
	EvalAssert( ERROR_SUCCESS == MsiDatabaseExport(hdbInput, szTable, szTempFolder, szFName) );

	lstrcpy(szTempFName, szFName);
	Assert(FFileExist(szTempFolder));

	EvalAssert( FExecSqlCmd(hdbInput, szDropSqlCmd) );

	return (IDS_OKAY);
}


/* ********************************************************************** */
static BOOL FMsiExistAnyTableRecords ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField )
{
	Assert(hdb != NULL);
	Assert(!FEmptySz(szTable));
	Assert(!FEmptySz(szField));
	Assert(*szField == TEXT('`'));
	Assert(*SzLastChar(szField) == TEXT('`'));
	Assert(lstrlen(szField) >= 3);

	BOOL fExists = fFalse;
	EvalAssert( IDS_OKAY == IdsMsiExistTableRecordsWhere(hdb, szTable, szField, TEXT(""), &fExists) );

	return (fExists);
}


/* ********************************************************************** */
static BOOL FValidPatchTableFormat ( MSIHANDLE hdb, pteEnum ptePatchTable )
{
	Assert(hdb != NULL);
	Assert(ptePatchTable > pteFirstEnum && ptePatchTable < pteNextEnum);

	LPTSTR szTable = (ptePatch == ptePatchTable) ? TEXT("Patch") : ((ptePatchPackage == ptePatchTable) ? TEXT("PatchPackage") : TEXT("MsiPatchHeaders"));

	Assert(FTableExists(hdb, szTable, fFalse));

	if (ptePatch == ptePatchTable)
		{
		return (FSzColumnExists(hdb, szTable, TEXT("File_"), fFalse)
				&& FIntColumnExists(hdb, szTable, TEXT("Sequence"), fFalse)
				&& FIntColumnExists(hdb, szTable, TEXT("PatchSize"), fFalse)
				&& FIntColumnExists(hdb, szTable, TEXT("Attributes"), fFalse)
				&& FBinaryColumnExists(hdb, szTable, TEXT("Header"), TEXT("File_"), fFalse)
				&& FSzColumnExists(hdb, szTable, TEXT("StreamRef_"), fFalse));
		}
	else if (ptePatchPackage == ptePatchTable)
		{
		return (FSzColumnExists(hdb, szTable, TEXT("PatchId"), fFalse)
				&& FIntColumnExists(hdb, szTable, TEXT("Media_"), fFalse));
		}

	return (FSzColumnExists(hdb, szTable, TEXT("StreamRef"), fFalse)
			&& FBinaryColumnExists(hdb, szTable, TEXT("Header"), TEXT("StreamRef"), fFalse));
}


/* ********************************************************************** */
MSIHANDLE HdbReopenMsi ( MSIHANDLE hdbInput, LPTSTR szImage, BOOL fUpgradedImage, BOOL fTargetUpgradedCopy )
{
	Assert(hdbInput != NULL);
	Assert(!FEmptySz(szImage));
	Assert(!fUpgradedImage || !fTargetUpgradedCopy);

	LPTSTR szTable   = TEXT("`TargetImages`");
	LPTSTR szPKey    = TEXT("`Target`");
	LPTSTR szMsiPath = TEXT("`MsiPath`");
	if (fUpgradedImage)
		{
		szTable = TEXT("`UpgradedImages`");
		szPKey  = TEXT("`Upgraded`");
		}
	else if (fTargetUpgradedCopy)
		szMsiPath = TEXT("`MsiPathUpgradedCopy`");

	TCHAR rgch[MAX_PATH];
	EvalAssert( IDS_OKAY == IdsMsiGetTableString(hdbInput, szTable, szPKey, szMsiPath, szImage, rgch, MAX_PATH) );
	Assert(!FEmptySz(rgch));
	Assert(FFileExist(rgch));

	MSIHANDLE hdb = NULL;
	EvalAssert( MSI_OKAY == MsiOpenDatabase(rgch, (fTargetUpgradedCopy) ? MSIDBOPEN_DIRECT : MSIDBOPEN_READONLY, &hdb) );
	Assert(hdb != NULL);

	return (hdb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\patchwiz\patchwiz.cpp ===
#pragma message("Windows Installer Patch Creation DLL")
#if 0  // makefile definitions
DESCRIPTION = PatchWiz patch generation tool
MODULENAME  = PatchWiz
ADDCPP = fileptch,msistuff,pwutils
FILEVERSION = msi
ENTRY = UiCreatePatchPackageA,UiCreatePatchPackageW
LINKLIBS = MSPATCHC.LIB
!include "..\..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f patchwiz.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 DLL project
//      2. Add the patching source files to the project (SDK\Patching\Source)
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib, mspatchc.lib, and version.lib to the library list in the
//          Project Settings dialog (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------

# pragma warning (disable:4553)

#include "patchdll.h"

#ifndef RC_INVOKED

EnableAsserts


static UINT UiInitPatchingModule ( LPTSTR szLogPath, HWND hwndStatus, LPTSTR szTempFolder, LPTSTR* pszTempFName, LPTSTR szTempFolderInput, BOOL fRemoveTempFolderIfPresent );
static UINT UiValidatePatchPath  ( MSIHANDLE hdb, LPTSTR szPatchPath );
static void TerminatePatchModule ( MSIHANDLE hdbInput, HWND hwnd, LPTSTR szTempFolder, LPTSTR szTempFName );


UINT UiCreatePatchPackageEx ( LPTSTR szPcpPath, LPTSTR szPatchPath, LPTSTR szLogPath, HWND hwndStatus, LPTSTR szTempFolder, BOOL fRemoveTempFolderIfPresent );

/* ********************************************************************** */
UINT UiCreatePatchPackageEx ( LPTSTR szPcpPath, LPTSTR szPatchPath, LPTSTR szLogPath, HWND hwndStatus, LPTSTR szTempFolder, BOOL fRemoveTempFolderIfPresent )
{
	TCHAR  rgchTempFolder[MAX_PATH + MAX_PATH];
	LPTSTR szTempFName = szNull;
	MSIHANDLE hdbInput = NULL;
	UINT   uiRet = UiInitPatchingModule(szLogPath, hwndStatus, rgchTempFolder, &szTempFName, szTempFolder, fRemoveTempFolderIfPresent);
	if (uiRet != ERROR_SUCCESS)
		goto LEarlyReturn;

	uiRet = UiOpenInputPcp(szPcpPath, rgchTempFolder, szTempFName, &hdbInput);
	if (uiRet != ERROR_SUCCESS)
		goto LEarlyReturn;
	Assert(hdbInput != NULL);

	TCHAR rgchPatchPath[MAX_PATH];
	lstrcpy(rgchPatchPath, szPatchPath);
	uiRet = UiValidatePatchPath(hdbInput, rgchPatchPath);
	if (uiRet != ERROR_SUCCESS)
		goto LEarlyReturn;

	uiRet = UiValidateInputRecords(hdbInput, szPcpPath, rgchPatchPath, rgchTempFolder, szTempFName);
	if (uiRet != ERROR_SUCCESS)
		goto LEarlyReturn;

	UpdateStatusMsg(IDS_STATUS_COPY_UPGRADED_MSI, szEmpty, szEmpty);
	uiRet = UiCopyUpgradedMsiToTempFolderForEachTarget(hdbInput, rgchTempFolder, szTempFName);
	if (uiRet != ERROR_SUCCESS)
		goto LEarlyReturn;

	uiRet = UiMakeFilePatchesCabinetsTransformsAndStuffIntoPatchPackage(
					hdbInput, rgchPatchPath, rgchTempFolder, szTempFName);

LEarlyReturn:
	TerminatePatchModule(hdbInput, hwndStatus, rgchTempFolder, szTempFName);

	return (uiRet);
}


/* ********************************************************************** */
UINT __declspec(dllexport) WINAPI UiCreatePatchPackageA ( LPSTR  szaPcpPath, LPSTR  szaPatchPath, LPSTR  szaLogPath, HWND hwndStatus, LPSTR szaTempFolder, BOOL fRemoveTempFolderIfPresent )
{
#ifndef UNICODE
	CHAR rgchTempFolder[MAX_PATH + 1];

	if (szaTempFolder)
		{
		*rgchTempFolder    = '\0';
		strncat(rgchTempFolder, szaTempFolder, MAX_PATH);
		}
	return (UiCreatePatchPackageEx(szaPcpPath, szaPatchPath, szaLogPath, hwndStatus, 
			szaTempFolder ? rgchTempFolder : szaTempFolder, fRemoveTempFolderIfPresent));
#else
	WCHAR rgchPcpPath[MAX_PATH];
	WCHAR rgchPatchPath[MAX_PATH];
	WCHAR rgchLogPath[MAX_PATH];
	WCHAR rgchTempFolder[MAX_PATH];

	*rgchPcpPath    = L'\0';
	*rgchPatchPath  = L'\0';
	*rgchLogPath    = L'\0';
	*rgchTempFolder = L'\0';

	if (szaPcpPath != NULL && *szaPcpPath != '\0')
		{
		EvalAssert( MultiByteToWideChar(CP_ACP, MB_USEGLYPHCHARS,
				szaPcpPath, -1, rgchPcpPath, MAX_PATH) );
		}

	if (szaPatchPath != NULL && *szaPatchPath != '\0')
		{
		EvalAssert( MultiByteToWideChar(CP_ACP, MB_USEGLYPHCHARS,
				szaPatchPath, -1, rgchPatchPath, MAX_PATH) );
		}

	if (szaLogPath != NULL && *szaLogPath != '\0')
		{
		EvalAssert( MultiByteToWideChar(CP_ACP, MB_USEGLYPHCHARS,
				szaLogPath, -1, rgchLogPath, MAX_PATH) );
		}

	if (szaTempFolder != NULL && *szaTempFolder != '\0')
		{
		EvalAssert( MultiByteToWideChar(CP_ACP, MB_USEGLYPHCHARS,
				szaTempFolder, -1, rgchTempFolder, MAX_PATH) );
		}

	return (UiCreatePatchPackageEx(rgchPcpPath, rgchPatchPath, rgchLogPath, hwndStatus, rgchTempFolder, fRemoveTempFolderIfPresent));
#endif
}
	
	
/* ********************************************************************** */
UINT __declspec(dllexport) WINAPI UiCreatePatchPackageW ( LPWSTR szwPcpPath, LPWSTR szwPatchPath, LPWSTR szwLogPath, HWND hwndStatus, LPWSTR szwTempFolder, BOOL fRemoveTempFolderIfPresent )
{
#ifdef UNICODE
	WCHAR rgchTempFolder[MAX_PATH + 1];

	if (szwTempFolder)
		{
		*rgchTempFolder    = L'\0';
		wcsncat(rgchTempFolder, szwTempFolder, MAX_PATH);
		}
	return (UiCreatePatchPackageEx(szwPcpPath, szwPatchPath, szwLogPath, hwndStatus, 
			szwTempFolder ? rgchTempFolder : szwTempFolder , fRemoveTempFolderIfPresent));
#else
	CHAR rgchPcpPath[MAX_PATH];
	CHAR rgchPatchPath[MAX_PATH];
	CHAR rgchLogPath[MAX_PATH];
	CHAR rgchTempFolder[MAX_PATH];

	*rgchPcpPath    = '\0';
	*rgchPatchPath  = '\0';
	*rgchLogPath    = '\0';
	*rgchTempFolder = '\0';

	if (szwPcpPath != NULL && *szwPcpPath != L'\0')
		{
		EvalAssert( WideCharToMultiByte(CP_ACP, 0, szwPcpPath, -1,
				rgchPcpPath, MAX_PATH, NULL, NULL) );
		}

	if (szwPatchPath != NULL && *szwPatchPath != L'\0')
		{
		EvalAssert( WideCharToMultiByte(CP_ACP, 0, szwPatchPath, -1,
				rgchPatchPath, MAX_PATH, NULL, NULL) );
		}

	if (szwLogPath != NULL && *szwLogPath != L'\0')
		{
		EvalAssert( WideCharToMultiByte(CP_ACP, 0, szwLogPath, -1,
				rgchLogPath, MAX_PATH, NULL, NULL) );
		}

	if (szwTempFolder != NULL && *szwTempFolder != L'\0')
		{
		EvalAssert( WideCharToMultiByte(CP_ACP, 0, szwTempFolder, -1,
				rgchTempFolder, MAX_PATH, NULL, NULL) );
		}

	return (UiCreatePatchPackageEx(rgchPcpPath, rgchPatchPath, rgchLogPath, hwndStatus, rgchTempFolder, fRemoveTempFolderIfPresent));
#endif
}


static UINT UiInitLogFile ( LPTSTR szLogPath );
static BOOL FEndLogFile   ( void );
static void CloseLogFile  ();


/* ********************************************************************** */
static UINT UiInitPatchingModule ( LPTSTR szLogPath, HWND hwndStatus, LPTSTR szTempFolder, LPTSTR* pszTempFName, LPTSTR szTempFolderInput, BOOL fRemoveTempFolderIfPresent )
{
	Assert(szTempFolder != szNull);
	Assert(pszTempFName != NULL);

	InitStatusMsgs(hwndStatus);

	if (!FSetTempFolder(szTempFolder, pszTempFName, hwndStatus, szTempFolderInput, fRemoveTempFolderIfPresent))
		return (ERROR_PCW_CANT_CREATE_TEMP_FOLDER);
	Assert(!FEmptySz(szTempFolder));
	Assert(*pszTempFName != szNull);

	TCHAR rgch[MAX_PATH];
	EvalAssert( GetModuleFileName(NULL, rgch, MAX_PATH) );
	*SzFindFilenameInPath(rgch) = TEXT('\0');
	Assert(lstrlen(rgch) > 0);
	Assert(*SzLastChar(rgch) == TEXT('\\'));
	lstrcat(rgch, TEXT("MAKECAB.EXE"));
	Assert(FFileExist(rgch));

	lstrcpy(*pszTempFName, TEXT("MAKECAB.EXE"));
	Assert(!FFileExist(szTempFolder));
	Assert(!FFolderExist(szTempFolder));

	EvalAssert( CopyFile(rgch, szTempFolder, fFalse) );
	Assert(FFileExist(szTempFolder));
	**pszTempFName = TEXT('\0');

	return (UiInitLogFile(szLogPath));
}


/* ********************************************************************** */
static void TerminatePatchModule ( MSIHANDLE hdbInput, HWND hwnd, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(!FEmptySz(szTempFolder));
//	Assert(szTempFName != szNull);

	UpdateStatusMsg(IDS_STATUS_CLEANUP, szEmpty, szEmpty);

	TCHAR rgch[MAX_PATH + MAX_PATH];
	if (hdbInput != NULL)
		{
		if (FTableExists(hdbInput, TEXT("TempPackCodes"), fFalse))
			EvalAssert( FExecSqlCmd(hdbInput, TEXT("DROP TABLE `TempPackCodes`")) );
		if (FTableExists(hdbInput, TEXT("TempImageNames"), fFalse))
			EvalAssert( FExecSqlCmd(hdbInput, TEXT("DROP TABLE `TempImageNames`")) );
		Assert(szTempFName != szNull);
		EvalAssert( IDS_OKAY == IdsMsiGetPcwPropertyString(hdbInput, TEXT("DontRemoveTempFolderWhenFinished"), rgch, MAX_PATH) );
		}
	else if (szTempFName != szNull)
		lstrcpy(rgch, TEXT("0")); // remove temp folder; PCP never opened.
	else
		lstrcpy(rgch, TEXT("1")); // don't attempt to remove temp folder; it was never created.
	
#ifdef DEBUG
	if (hdbInput != NULL)
		MsiDatabaseCommit(hdbInput);
#endif

	MsiCloseAllHandles();
	EvalAssert( FEndLogFile() );

	CloseLogFile();

	if (FEmptySz(rgch) || *rgch == TEXT('0'))
		{
		Assert(szTempFName != szNull);
		*szTempFName = TEXT('\0');
#ifdef DEBUG
		wsprintf(rgch, TEXT("Temp folder is about to be cleaned out and deleted:\n   '%s'"), szTempFolder);
		OutputDebugString(rgch);
#endif

		EvalAssert( FDeleteTempFolder(szTempFolder) );
		}

	EndStatusMsgs();
}


/* ********************************************************************** */
static UINT UiValidatePatchPath ( MSIHANDLE hdb, LPTSTR szPatchPath )
{
	Assert(hdb != NULL);

	if (FEmptySz(szPatchPath))
		{
		UINT ids = IdsMsiGetPcwPropertyString(hdb, TEXT("PatchOutputPath"), szPatchPath, MAX_PATH);
		if (ids != IDS_OKAY || FEmptySz(szPatchPath))
			return (UiLogError(ERROR_PCW_MISSING_PATCH_PATH, NULL, NULL));
		}

	if (FFileExist(szPatchPath))
		{
		EvalAssert( FFixupPath(szPatchPath) );
		}

	if (FFolderExist(szPatchPath))
		return (UiLogError(ERROR_PCW_CANT_OVERWRITE_PATCH, szPatchPath, NULL));

	return (ERROR_SUCCESS);
}


static TCHAR rgchLogFile[MAX_PATH] = TEXT("");

/* ********************************************************************** */
static UINT UiInitLogFile ( LPTSTR szLogPath )
{
	Assert(FEmptySz(rgchLogFile));

	if (!FEmptySz(szLogPath))
		{
		TCHAR rgch[MAX_PATH];
		EvalAssert( FFixupPathEx(szLogPath, rgch) );

		LPTSTR szFName = SzFindFilenameInPath(rgch);
		if (FEmptySz(szFName))
			{
			AssertFalse();
			return (ERROR_SUCCESS);
			}

		*szFName = TEXT('\0');
		if (!FEnsureFolderExists(rgch))
			{
			AssertFalse();
			return (ERROR_SUCCESS);
			}

		EvalAssert( FFixupPathEx(szLogPath, rgchLogFile) );
		if (FFileExist(rgchLogFile))
			SetFileAttributes(rgchLogFile, FILE_ATTRIBUTE_NORMAL);

		SYSTEMTIME st;
		GetLocalTime(&st);
		wsprintf(rgch, TEXT("\r\n***** Log starting: %4d-%02d-%02d %02d:%02d:%02d *****\r\n\r\n"),
				st.wYear, st.wMonth, st.wDay,
				st.wHour, st.wMinute, st.wSecond);

		if (!FWriteLogFile(rgch))
			{
			AssertFalse();
			*rgchLogFile = TEXT('\0');
			return (ERROR_SUCCESS);
			}
		}

	return (ERROR_SUCCESS);
}


//log file handle open all the time...

HANDLE g_hf = NULL;

/* ********************************************************************** */
BOOL FWriteLogFile ( LPTSTR szLine )
{
	Assert(!FEmptySz(szLine));

	if (FEmptySz(rgchLogFile))
		return (fTrue);

	// use global handle and don't reopen/close, that is expensive!
	if (!g_hf) //if first time
		{
		g_hf = CreateFile(rgchLogFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

		if (g_hf == INVALID_HANDLE_VALUE)
			return (fFalse);
		
		// handle concatenation of log files
		SetFilePointer(g_hf, 0, NULL, FILE_END);
		}

	if (g_hf == INVALID_HANDLE_VALUE)
		return (fFalse);


	BOOL fRet = fTrue;

	DWORD dwWritten = 0;
	DWORD dwSize = lstrlen(szLine)*sizeof(TCHAR);
	if (!WriteFile(g_hf, (LPVOID)szLine, dwSize, &dwWritten, NULL) || dwWritten != dwSize)
		fRet = fFalse;

	// file handle is closed by CloseLogFile() in TerminatePatchModule(...)
	return (fRet);
}


//add new function to close log file at end...
void CloseLogFile()
{
  if (g_hf && (g_hf != INVALID_HANDLE_VALUE))
  {
     CloseHandle(g_hf);     
	 g_hf = NULL;
  }
}

/* ********************************************************************** */
BOOL FSprintfToLog ( LPTSTR szLine, LPTSTR szData1, LPTSTR szData2, LPTSTR szData3, LPTSTR szData4 )
{
	Assert(!FEmptySz(szLine));
	Assert(szData1 != szNull);
	Assert(szData2 != szNull);
	Assert(szData3 != szNull);
	Assert(szData4 != szNull);
	Assert(lstrlen(szLine) + lstrlen(szData1) + lstrlen(szData2) + lstrlen(szData3) + lstrlen(szData4) < 1020);

	TCHAR rgch[1024];
	wsprintf(rgch, szLine, szData1, szData2, szData3, szData4);
	lstrcat(rgch, TEXT("\r\n"));
	Assert(lstrlen(rgch) < 1024);

	return (FWriteLogFile(rgch));
}


/* ********************************************************************** */
UINT UiLogError ( UINT ids, LPTSTR szData, LPTSTR szData2 )
{
	LPTSTR szT;
	switch (ids)
		{
	case ERROR_PCW_PCP_DOESNT_EXIST:
		if (szData == NULL)
			szT = TEXT(".PCP file does not exist (or was not specified)");
		else
			{
			Assert(!FEmptySz(szData));
			szT = TEXT(".PCP file '%s' does not exist.");
			}
		break;
	case ERROR_PCW_PCP_BAD_FORMAT:
		Assert(!FEmptySz(szData));
		szT = TEXT("The .pcp file '%s' is invalid.");
		break;
	case ERROR_PCW_CANT_CREATE_TEMP_FOLDER:
		Assert(!FEmptySz(szData));
		szT = TEXT("Cannot create folder: '%s'.");
		break;
	case ERROR_PCW_MISSING_PATCH_PATH:
		szT = TEXT("The PatchOutputPath property is missing from the Properties table of the .pcp file.  No other patch output path was specified, so this property is required.");
		break;
	case ERROR_PCW_CANT_OVERWRITE_PATCH:
		Assert(!FEmptySz(szData));
		szT = TEXT("Cannot overwrite patch '%s'. Check the permissions to make sure that patchwiz will have access to the file. (Note, this path cannot be a folder.)");
		break;
	case ERROR_PCW_CANT_CREATE_PATCH_FILE:
		Assert(!FEmptySz(szData));
		szT = TEXT("Unable to create patch '%s'.");
		break;
	case ERROR_PCW_MISSING_PATCH_GUID:
		szT = TEXT("PatchGUID property is missing from the Properties table of the .pcp file. This is a required property");
		break;
	case ERROR_PCW_BAD_PATCH_GUID:
		Assert(!FEmptySz(szData));
		szT = TEXT("The PatchGUID '%s' in the Properties table of the .pcp file is an invalid GUID.");
		break;
	case ERROR_PCW_BAD_GUIDS_TO_REPLACE:
		Assert(!FEmptySz(szData));
		szT = TEXT("At least one of the GUIDs '%s' defined in the ListOfPatchGUIDsToReplace property in the Properties table of the .pcp file is invalid.");
		break;
	case ERROR_PCW_BAD_TARGET_PRODUCT_CODE_LIST:
		Assert(!FEmptySz(szData));
		szT = TEXT("At least one of the GUIDs '%s' defined in the ListOfTargetProductCodes property in the Properties table of the .pcp file is invalid.");
		break;
	case ERROR_PCW_NO_UPGRADED_IMAGES_TO_PATCH:
		szT = TEXT("No upgraded images are present in the UpgradedImages table of the .pcp file.");
		break;
	case ERROR_PCW_BAD_API_PATCHING_SYMBOL_FLAGS:
		Assert(!FEmptySz(szData));
		szT = TEXT("Bad ApiPatchingSymbolFlags = '%s'.");
		break;
	case ERROR_PCW_OODS_COPYING_MSI:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("Possible out of disk space condition.  Unable to copy '%s' to '%s'.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_NAME_TOO_LONG:
		if (szData == szNull)
			szT = TEXT("UpgradedImages.Upgraded string is way too long; use 1 to 13 alphanumeric characters.");
		else
			{
			Assert(!FEmptySz(szData));
			szT = TEXT("UpgradedImages.Upgraded string '%s' is too long; use 1 to 13 alphanumeric characters.");
			}
		break;
	case ERROR_PCW_BAD_UPGRADED_IMAGE_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.Upgraded string '%s' is invalid; use 1 to 13 alphanumeric characters.");
		break;
	case ERROR_PCW_DUP_UPGRADED_IMAGE_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.Upgraded string '%s' is a duplicate.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATH_TOO_LONG:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.MsiPath string is too long; Upgraded = '%s'.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATH_EMPTY:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.MsiPath field is empty; Upgraded = '%s'.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_EXIST:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.MsiPath '%s' does not exist.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.MsiPath '%s' is not a proper MSI.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_COMPRESSED:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.MsiPath '%s' is marked as having compressed files (PID_WORDCOUNT property of Summary Information stream). PatchWiz is unable to patch files compressed in a cabinet.");
		break;
	case ERROR_PCW_TARGET_IMAGE_NAME_TOO_LONG:
		if (szData == szNull)
			szT = TEXT("TargetImages.Target string is way too long; use 1 to 13 alphanumeric characters.");
		else
			{
			Assert(!FEmptySz(szData));
			szT = TEXT("TargetImages.Target string '%s' is too long; use 1 to 13 alphanumeric characters.");
			}
		break;
	case ERROR_PCW_BAD_TARGET_IMAGE_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.Target string '%s' is invalid; use 1 to 13 alphanumeric characters.");
		break;
	case ERROR_PCW_DUP_TARGET_IMAGE_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.Target string '%s' is a duplicate.");
		break;
	case ERROR_PCW_TARGET_IMAGE_PATH_TOO_LONG:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.MsiPath string is too long; Target = '%s'.");
		break;
	case ERROR_PCW_TARGET_IMAGE_PATH_EMPTY:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.MsiPath field is empty; Target = '%s'.");
		break;
	case ERROR_PCW_TARGET_IMAGE_PATH_NOT_EXIST:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.MsiPath '%s' does not exist.");
		break;
	case ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.MsiPath '%s' is not a proper MSI.");
		break;
	case ERROR_PCW_TARGET_IMAGE_COMPRESSED:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.MsiPath '%s' is marked as having compressed files (PID_WORDCOUNT property of Summary Information stream). PatchWiz is unable to patch files compressed in a cabinet.");
		break;
	case ERROR_PCW_TARGET_BAD_PROD_VALIDATE:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.ProductValidateFlags for '%s' is invalid; it should be an eight digit hex value of the form 0x12345678 and be valid.");
		break;
	case ERROR_PCW_TARGET_BAD_PROD_CODE_VAL:
		Assert(!FEmptySz(szData));
		szT = TEXT("The product code '%s' in ListOfTargetProductCodes is not referenced by a target image. This creates an invalid patch for this product because at least one of the TargetImages records contains MSITRANSFORM_VALIDATE_PRODUCT in its ProductValidateFlags.");
		break;
	case ERROR_PCW_UPGRADED_MISSING_SRC_FILES:
		Assert(!FEmptySz(szData));
		szT = TEXT("Cannot find Upgraded image source file: '%s'.");
		break;
	case ERROR_PCW_TARGET_MISSING_SRC_FILES:
		Assert(!FEmptySz(szData));
		szT = TEXT("Cannot find Target image source file: '%s'.");
		break;
	case ERROR_PCW_IMAGE_FAMILY_NAME_TOO_LONG:
		if (szData == szNull)
			szT = TEXT("ImageFamilies.Family string is way too long; use 1 to 8 alphanumeric characters.");
		else
			{
			Assert(!FEmptySz(szData));
			szT = TEXT("ImageFamilies.Family string '%s' is too long; use 1 to 8 alphanumeric characters.");
			}
		break;
	case ERROR_PCW_BAD_IMAGE_FAMILY_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("ImageFamilies.Family string '%s' is invalid; use 1 to 8 alphanumeric characters.");
		break;
	case ERROR_PCW_DUP_IMAGE_FAMILY_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("ImageFamilies.Family string '%s' is a duplicate.");
		break;
	case ERROR_PCW_BAD_IMAGE_FAMILY_SRC_PROP:
		Assert(szData != szNull);
		if (szData2 == szNull)
			{
			Assert(!FEmptySz(szData));
			szT = TEXT("ImageFamilies.MediaSrcPropName string is way too long; use 1 to 36 alphanumeric characters. Family: '%s'.");
			}
		else if (FEmptySz(szData))
			{
			Assert(!FEmptySz(szData2));
			szT = TEXT("ImageFamilies.MediaSrcPropName string is blank; use 1 to 36 alphanumeric characters. Family: '%s%s'.");
			}
		else
			{
			Assert(!FEmptySz(szData2));
			szT = TEXT("ImageFamilies.MediaSrcPropName string '%s' is invalid; use 1 to 36 alphanumeric characters. Family: '%s'.");
			}
		break;
	case ERROR_PCW_UFILEDATA_LONG_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedFiles_OptionalData: FTK is too long; Upgraded image: '%s'.");
		break;
	case ERROR_PCW_UFILEDATA_BLANK_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedFiles_OptionalData: FTK is blank; Upgraded image: '%s'.");
		break;
	case ERROR_PCW_UFILEDATA_MISSING_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("UpgradedFiles_OptionalData: FTK '%s' record is missing from image; Upgraded image: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_LONG_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("ExternalFiles: FTK is too long; Family: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_BLANK_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("ExternalFiles: FTK is blank; Family: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD:
		if (szData == szNull)
			szT = TEXT("ExternalFiles.Family string is way too long; use 1 to 8 alphanumeric characters.");
		else if (FEmptySz(szData))
			szT = TEXT("ExternalFiles.Family string is blank; use 1 to 8 alphanumeric characters.");
		else
			szT = TEXT("ExternalFiles.Family string is invalid or does not match a Family record; use 1 to 8 alphanumeric characters. Family: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_LONG_PATH_TO_FILE:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: FilePath is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_BLANK_PATH_TO_FILE:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: FilePath is blank; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_MISSING_FILE:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: Cannot find FilePath: '%s'; Family: '%s'.");
		break;
	case ERROR_PCW_BAD_FILE_SEQUENCE_START:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("The starting sequence value (FileSequenceStart) for the family '%s' in the ImageFamilies table overlaps the greatest last sequence value in the upgraded image '%s' Media table.");
		break;
	case ERROR_PCW_CANT_COPY_FILE_TO_TEMP_FOLDER:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("Cannot copy file from '%s' to '%s'.");
		break;
	case ERROR_PCW_CANT_CREATE_ONE_PATCH_FILE:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("Cannot create patch file for '%s' at '%s'.");
		break;
	case ERROR_PCW_BAD_IMAGE_FAMILY_DISKID:
		Assert(!FEmptySz(szData));
		szT = TEXT("ImageFamilies.MediaDiskId is invalid. Family: '%s'.");
		break;
	case ERROR_PCW_BAD_IMAGE_FAMILY_FILESEQSTART:
		Assert(!FEmptySz(szData));
		szT = TEXT("ImageFamilies.FileSequenceStart is invalid. Family: '%s'.");
		break;
	case ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY:
		Assert(!FEmptySz(szData));
		if (szData2 == szNull)
			szT = TEXT("UpgradedImages.Family string is way too long; use 1 to 8 alphanumeric characters. Upgraded image: '%s'.");
		else if (FEmptySz(szData2))
			szT = TEXT("UpgradedImages.Family string is blank; use 1 to 8 alphanumeric characters. Upgraded image: '%s'.");
		else
			szT = TEXT("UpgradedImages.Family string is invalid or does not match a Family record; use 1 to 8 alphanumeric characters. Upgraded image: '%s'; Family: '%s'.");
		break;
	case ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED:
		Assert(!FEmptySz(szData));
		if (szData2 == szNull)
			szT = TEXT("TargetImages.Upgraded string is way too long; use 1 to 13 alphanumeric characters. Target image: '%s'.");
		else if (FEmptySz(szData2))
			szT = TEXT("TargetImages.Upgraded string is blank; use 1 to 13 alphanumeric characters. Target image: '%s'.");
		else
			szT = TEXT("TargetImages.Upgraded string is invalid or does not match an Upgraded record; use 1 to 8 alphanumeric characters. Target image: '%s'; Upgraded image: '%s'.");
		break;
	case ERROR_PCW_DUP_TARGET_IMAGE_PACKCODE:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetImages.Target = '%s': PackageCode %s is not unique.");
		break;
	case ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD:
		if (szData == szNull)
			szT = TEXT("UpgradedFiles_OptionalData.Upgraded string is way too long; use 1 to 13 alphanumeric characters.");
		else if (FEmptySz(szData))
			szT = TEXT("UpgradedFiles_OptionalData.Upgraded string is blank; use 1 to 13 alphanumeric characters.");
		else
			szT = TEXT("UpgradedFiles_OptionalData.Upgraded string is invalid or does not match an Upgraded record; use 1 to 13 alphanumeric characters. Upgraded image: '%s'.");
		break;
	case ERROR_PCW_MISMATCHED_PRODUCT_CODES:
		szT = TEXT("The product code differs between the target and upgraded images. Set AllowProductCodeMismatches in the Properties table of the .pcp file to 1 to allow mismatches.");
		break;
	case ERROR_PCW_MISMATCHED_PRODUCT_VERSIONS:
		szT = TEXT("The product version differs between the target and upgraded images. Set AllowProductVersionMismatches in the Properties table of the .pcp file to 1 to allow mismatches.");
		break;
	case ERROR_PCW_CANNOT_WRITE_DDF:
		szT = TEXT("Cannot write to DDF file for MAKECAB.EXE.");
		break;
	case ERROR_PCW_CANNOT_RUN_MAKECAB:
		szT = TEXT("Cannot execute MAKECAB.EXE.");
		break;
	case ERROR_PCW_WRITE_SUMMARY_PROPERTIES:
		szT = TEXT("Cannot write Summary Properties to Patch Package.");
		break;
	case ERROR_PCW_TFILEDATA_LONG_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetFiles_OptionalData: FTK is too long; Target image: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_BLANK_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetFiles_OptionalData: FTK is blank; Target image: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_MISSING_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: FTK '%s' record is missing from image; Target image: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD:
		if (szData == szNull)
			szT = TEXT("TargetFiles_OptionalData.Target string is way too long; use 1 to 13 alphanumeric characters.");
		else if (FEmptySz(szData))
			szT = TEXT("TargetFiles_OptionalData.Target string is blank; use 1 to 13 alphanumeric characters.");
		else
			szT = TEXT("TargetFiles_OptionalData.Target string is invalid or does not match an Target record; use 1 to 13 alphanumeric characters. Target image: '%s'.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_TOO_LONG:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.PatchMsiPath string is too long; Upgraded = '%s'.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_EXIST:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.PatchMsiPath '%s' does not exist.");
		break;
	case ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_MSI:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.PatchMsiPath '%s' is not a proper MSI.");
		break;
	case ERROR_PCW_DUP_UPGRADED_IMAGE_PACKCODE:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("UpgradedImages.Upgraded = '%s': PackageCode %s is not unique.");
		break;
	case ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD:
		if (szData == szNull)
			szT = TEXT("UpgradedFilesToIgnore.Upgraded string is way too long; use 1 to 13 alphanumeric characters or '*' for all images.");
		else if (FEmptySz(szData))
			szT = TEXT("UpgradedFilesToIgnore.Upgraded string is blank; use 1 to 13 alphanumeric characters or '*' for all images.");
		else
			szT = TEXT("UpgradedFilesToIgnore.Upgraded string is invalid or does not match an Upgraded record; use 1 to 13 alphanumeric characters or '*' for all images. Upgraded image: '%s'.");
		break;
	case ERROR_PCW_UFILEIGNORE_LONG_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedFilesToIgnore: FTK is too long; Upgraded image: '%s'.");
		break;
	case ERROR_PCW_UFILEIGNORE_BLANK_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedFilesToIgnore: FTK is blank; Upgraded image: '%s'.");
		break;
	case ERROR_PCW_UFILEIGNORE_BAD_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("UpgradedFilesToIgnore: FTK can only have a trailing asterisk; Upgraded image: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_NAME_TOO_LONG:
		if (szData == szNull)
			szT = TEXT("FamilyFileRanges.Family string is way too long; use 1 to 8 alphanumeric characters.");
		else
			{
			Assert(!FEmptySz(szData));
			szT = TEXT("FamilyFileRanges.Family string '%s' is too long; use 1 to 8 alphanumeric characters.");
			}
		break;
	case ERROR_PCW_BAD_FAMILY_RANGE_NAME:
		Assert(!FEmptySz(szData));
		szT = TEXT("FamilyFileRanges.Family string '%s' is invalid; use 1 to 8 alphanumeric characters; must match a record in ImageFamilies table.");
		break;
	case ERROR_PCW_FAMILY_RANGE_LONG_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("FamilyFileRanges: FTK is too long; Family: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_BLANK_FILE_TABLE_KEY:
		Assert(!FEmptySz(szData));
		szT = TEXT("FamilyFileRanges: FTK is blank; Family: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: RetainOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: RetainOffsets is blank; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: RetainOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: RetainLengths is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: RetainLengths is blank; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: RetainLengths is badly formatted - use comma deliminated numbers, no zeros; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_FAMILY_RANGE_COUNT_MISMATCH:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("FamilyFileRanges: Number of elements in RetainOffsets does not match RetainLengths; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_LONG_IGNORE_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: IgnoreOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_BAD_IGNORE_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: IgnoreOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_LONG_IGNORE_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: IgnoreOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_BAD_IGNORE_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: IgnoreOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_IGNORE_COUNT_MISMATCH:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: Number of elements in IgnoreOffsets does not match IgnoreLengths; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_LONG_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: RetainOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_EXTFILE_BAD_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("ExternalFiles: RetainOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_LONG_IGNORE_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: IgnoreOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_BAD_IGNORE_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: IgnoreOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_LONG_IGNORE_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: IgnoreOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_BAD_IGNORE_LENGTHS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: IgnoreOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_IGNORE_COUNT_MISMATCH:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: Number of elements in IgnoreOffsets does not match IgnoreLengths; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_LONG_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: RetainOffsets is too long; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_TFILEDATA_BAD_RETAIN_OFFSETS:
		Assert(!FEmptySz(szData));
		Assert(!FEmptySz(szData2));
		szT = TEXT("TargetFiles_OptionalData: RetainOffsets is badly formatted - use comma deliminated numbers; Family: '%s'; FTK: '%s'.");
		break;
	case ERROR_PCW_CANT_GENERATE_TRANSFORM:
		szT = TEXT("Cannot generate a primary transform.");
		break;
	case ERROR_PCW_CANT_CREATE_SUMMARY_INFO:
		szT = TEXT("Cannot create Summary Info for primary transform.");
		break;
	case ERROR_PCW_CANT_GENERATE_TRANSFORM_POUND:
		szT = TEXT("Cannot generate a pound transform.");
		break;
	case ERROR_PCW_CANT_CREATE_SUMMARY_INFO_POUND:
		szT = TEXT("Cannot create Summary Info for pound transform.");
		break;
	case ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_CODE:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.Upgraded = '%s': ProductCode is not a valid GUID.");
		break;
	case ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_VERSION:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.Upgraded = '%s': ProductVersion is not valid.");
		break;
	case ERROR_PCW_BAD_UPGRADED_IMAGE_UPGRADE_CODE:
		Assert(!FEmptySz(szData));
		szT = TEXT("UpgradedImages.Upgraded = '%s': UpgradeCode is not a valid GUID.");
		break;
	case ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_CODE:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.Target = '%s': ProductCode is not a valid GUID.");
		break;
	case ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_VERSION:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.Target = '%s': ProductVersion is not valid.");
		break;
	case ERROR_PCW_BAD_TARGET_IMAGE_UPGRADE_CODE:
		Assert(!FEmptySz(szData));
		szT = TEXT("TargetImages.Target = '%s': UpgradeCode is not a valid GUID.");
		break;
	case ERROR_PCW_MATCHED_PRODUCT_VERSIONS:
		szT = TEXT("The product codes between the target and upgrade images changed, but the product versions remain the same. At least one of the three fields of the ProductVersion must change for a major upgrade patch.");
		break;

	case IDS_CANT_GET_RECORD_FIELD:
		Assert(!FEmptySz(szData));
		szT = TEXT("Cannot get record field: '%s'.");
		break;
	default:
		AssertFalse();
		return (ids);
		}

	TCHAR rgch[MAX_PATH+128];
	lstrcpy(rgch, TEXT("  ERROR: "));
	wsprintf(rgch+lstrlen(TEXT("  ERROR: ")), szT, szData, szData2);
	lstrcat(rgch, TEXT("\r\n"));

	EvalAssert( FWriteLogFile(rgch) );

	return (ids);
}


/* ********************************************************************** */
static BOOL FEndLogFile ( void )
{
	if (!FEmptySz(rgchLogFile))
		{
		SYSTEMTIME st;
		GetLocalTime(&st);

		TCHAR rgch[MAX_PATH];
		wsprintf(rgch, TEXT("\r\n***** Log finishing: %4d-%02d-%02d %02d:%02d:%02d *****\r\n\r\n"),
				st.wYear, st.wMonth, st.wDay,
				st.wHour, st.wMinute, st.wSecond);
	
		EvalAssert( FWriteLogFile(rgch) );

// annoying!  don't see the need to make this read only
//		if (FFileExist(rgchLogFile))
//			SetFileAttributes(rgchLogFile, FILE_ATTRIBUTE_READONLY);

		*rgchLogFile = TEXT('\0');
		}

	return (fTrue);
}

#else // RC_INVOKED, end of source code, start of resources
//#include <winver.h>
STRINGTABLE DISCARDABLE
BEGIN
  IDS_STATUS_VALIDATE_INPUT           "Validating MSI input file..."
  IDS_STATUS_VALIDATE_IMAGES          "Checking for source files in images..." 
  IDS_STATUS_VALIDATE_FILE_RANGES     "Validating file retain/ignore ranges..."
  IDS_STATUS_DETERMINE_SEQUENCE_START "Determining file sequence starting number..."
  IDS_STATUS_EXPAND_OVERLAP_RECORDS   "Checking for file overlaps between upgraded images..."
  IDS_STATUS_COPY_UPGRADED_MSI        "Copying upgraded MSI to temp-target location..."
  IDS_STATUS_CREATE_FILE_PATCHES      "Creating file patches..."
  IDS_STATUS_CREATE_TRANSFORMS        "Generating transforms (MSTs)..."
  IDS_STATUS_CREATE_CABINET           "Creating cabinet file..."
  IDS_STATUS_CLEANUP                  "Cleaning up temporary files..."

  IDS_TITLE                           "Patch Creation Wizard"
  IDS_PRODUCTCODES_DONT_MATCH         "ProductCodes between Target and Upgraded images do not match; do you want to proceed anyway?"
  IDS_PRODUCTVERSIONS_DONT_MATCH      "ProductVersions between Target and Upgraded images do not match; do you want to proceed anyway?"
  IDS_PRODUCTVERSION_INVERSION        "Target ProductVersion is greater than the Upgraded image; do you want to proceed anyway?"
END
#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\patchwiz\patchcache.cpp ===
// PatchCache.cpp


//include patching DLL headers...
#include "patchdll.h"

#include "patchcache.h"

#include <tchar.h> //for _tcscpy _tcscat


//IMPLEMENTATION that is not exposed to outside callers.... Moved this to here from header...
//REVIEW this length, may be too much.  May a checksum instead???

struct PCIFILEINFO
{
  TCHAR szFilePath[MAX_PATH];
  DWORD dwVersionHigh;
  DWORD dwVersionLow;
  DWORD dwSizeHigh;
  DWORD dwSizeLow;
  FILETIME ftCreationTime;
  FILETIME ftLastWriteTime;
};


struct CACHEDPATCHFILELOCATIONS
{
  TCHAR szPATFilePath[MAX_PATH];
  TCHAR szHDRFilePath[MAX_PATH];
};

typedef CACHEDPATCHFILELOCATIONS PATCHFILELOCATIONS;

struct PCIFILEFORMAT
{
  PCIFILEINFO SourceInfo;
  PCIFILEINFO TargetInfo;
  CACHEDPATCHFILELOCATIONS Locations;
};
  
BOOL PatchInCache(TCHAR *szSourceLFN, TCHAR *szTargetLFN, TCHAR *szPCIFileName, PCIFILEFORMAT *pPciFile);

//populate PCI struct for patches...
BOOL  PopulatePCIFileInfoForCurrentPatch(TCHAR *lpszLFN, PCIFILEINFO *pFilePCI);

//pass by ref for all struct params for speed...  No changes are done to struct...
DWORD ReadPCIFileFromCache(TCHAR *pciPath, PCIFILEFORMAT *pPciFile);
DWORD WritePCIInfoToCache(TCHAR *pciPath, PCIFILEFORMAT *pPciFile);

//pass by ref for all struct params for speed...  No changes are done to struct...
BOOL ComparePCIInfos(PCIFILEINFO *pCurFilePCI, PCIFILEINFO *pCachedFilePCI);


//cache/temp file updating functions
BOOL CopyPatchesToCache(CACHEDPATCHFILELOCATIONS *pCacheFileLocations, PATCHFILELOCATIONS *pTempFileLocations);
BOOL CopyPatchesFromCache(PATCHFILELOCATIONS *pTempFileLocations, CACHEDPATCHFILELOCATIONS *pCacheFileLocations);

//i/o return contants for functions reading/writing to .PCI files...
#define PCI_SUCCESS          0
#define ERR_PCI_FILENOTFOUND 1
#define ERR_PCI_FILECORRUPT  2


TCHAR g_szSourceLFN[MAX_PATH] = { 0 };
TCHAR g_szDestLFN[MAX_PATH] = { 0 };

BOOL  g_bPatchCacheEnabled = FALSE;
TCHAR g_szPatchCacheDir[MAX_PATH] = TEXT(""); 

//end IMPLEMENTATION


BOOL PopulatePCIFileInfoForCurrentPatch(TCHAR *lpszLFN, PCIFILEINFO *pPCIFileInfo)
{
	BOOL bRet = TRUE;

	Assert(lpszLFN);
	Assert(pPCIFileInfo);

	_tcscpy(pPCIFileInfo->szFilePath, lpszLFN);

	GetFileVersion(lpszLFN, &pPCIFileInfo->dwVersionHigh, &pPCIFileInfo->dwVersionLow);
  
	HANDLE hf1 = CreateFile(lpszLFN, GENERIC_READ, FILE_SHARE_READ,
							NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);
	Assert(hf1 != INVALID_HANDLE_VALUE);

	pPCIFileInfo->dwSizeLow = GetFileSize(hf1, &pPCIFileInfo->dwSizeHigh);
	Assert(pPCIFileInfo->dwSizeLow != 0xffffffff || GetLastError() == NO_ERROR);

	BY_HANDLE_FILE_INFORMATION finfo;
	bRet = GetFileInformationByHandle(hf1, &finfo);
	Assert(bRet)
	if (!bRet)
		{
		DWORD dwErr = GetLastError();
		Assert(1); //should assert and tell we got an error
		}
	else
		{
		pPCIFileInfo->ftCreationTime  = finfo.ftCreationTime;
		pPCIFileInfo->ftLastWriteTime = finfo.ftLastWriteTime;
		}

	CloseHandle(hf1);
  
	return bRet;
}


DWORD ReadPCIInfoFromCache(TCHAR *pciPath, PCIFILEFORMAT *pPciFile)
{
	DWORD dwReturn = PCI_SUCCESS;
	Assert(pPciFile);

	HANDLE hf1 = CreateFile(pciPath, GENERIC_READ, FILE_SHARE_READ,
							NULL, OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

	//annoying assert for many files...
	//  Assert(hf1 != INVALID_HANDLE_VALUE);
	if (INVALID_HANDLE_VALUE == hf1)
	{
		return ERR_PCI_FILENOTFOUND;
	}

	DWORD dwRead;
	BOOL bRet;

	bRet = ReadFile(hf1, (LPVOID)pPciFile, sizeof(PCIFILEFORMAT), &dwRead, NULL);
  
	Assert(bRet);
	Assert(dwRead == sizeof(PCIFILEFORMAT));
	if (bRet && dwRead != sizeof(PCIFILEFORMAT))
		{
		dwReturn = ERR_PCI_FILECORRUPT;
		}

	if (!bRet)
		{
		//ERR_PCI_UNKNOWN
		dwReturn = GetLastError();
		}

	CloseHandle(hf1);
	return dwReturn;
}


DWORD WritePCIInfoToCache(TCHAR *pciPath, PCIFILEFORMAT *pPciFile)
{
	DWORD dwReturn = PCI_SUCCESS;

	Assert(pPciFile);


	HANDLE hf1 = CreateFile(pciPath, GENERIC_WRITE, FILE_SHARE_READ,
							NULL, CREATE_ALWAYS, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

	Assert(hf1 != INVALID_HANDLE_VALUE);
	if (INVALID_HANDLE_VALUE == hf1)
		{
		return ERR_PCI_FILENOTFOUND;
		}

	DWORD dwWritten;
	BOOL bRet;

	bRet = WriteFile(hf1, (LPVOID)pPciFile, sizeof(PCIFILEFORMAT), &dwWritten, NULL);
  
	Assert(bRet);
	Assert(dwWritten == sizeof(PCIFILEFORMAT));
	if (bRet && dwWritten != sizeof(PCIFILEFORMAT))
		{
		dwReturn = ERR_PCI_FILECORRUPT;
		}

	if (!bRet)
		{
		//ERR_PCI_UNKNOWN
		dwReturn = GetLastError();
		}

	CloseHandle(hf1);
	return dwReturn;
}


BOOL ComparePCIInfos(PCIFILEINFO *pCurFilePCI, PCIFILEINFO *pCachedFilePCI)
{
	Assert(pCurFilePCI);
	Assert(pCachedFilePCI);

	if (0 == memcmp(pCurFilePCI, pCachedFilePCI, sizeof(PCIFILEINFO)))
		return TRUE;

	return FALSE;

}


BOOL PatchInCache(TCHAR *szSourceLFN, TCHAR *szTargetLFN, TCHAR *szPCIFileName, PCIFILEFORMAT *pPciFile)
{
	BOOL bPatchInCache = FALSE;

	struct PCIFILEINFO CurSourceFilePCI = { 0 };
	struct PCIFILEINFO CurTargetFilePCI = { 0 };

	BOOL bRet;
	bRet = PopulatePCIFileInfoForCurrentPatch(szSourceLFN, &CurSourceFilePCI);
	Assert(bRet);

	bRet = PopulatePCIFileInfoForCurrentPatch(szTargetLFN, &CurTargetFilePCI);
	Assert(bRet);

	DWORD dwResult;
	dwResult = ReadPCIInfoFromCache(szPCIFileName, pPciFile);
	if (PCI_SUCCESS == dwResult)
		{
		BOOL bRet = ComparePCIInfos(&pPciFile->SourceInfo, &CurSourceFilePCI);
		if (bRet)
			{
			bRet = ComparePCIInfos(&pPciFile->TargetInfo, &CurTargetFilePCI);
			if (bRet)
				bPatchInCache = TRUE;
			}
		}
	else //error, check dwResult... 
		{
		}

	if (!bPatchInCache) //will need to copy files to cache, they are not in it!
		{
		pPciFile->SourceInfo = CurSourceFilePCI;
		pPciFile->TargetInfo = CurTargetFilePCI;

		BOOL bRet;
		TCHAR tempname[MAX_PATH];

		GetTempFileName(g_szPatchCacheDir, TEXT("PC"), 0, tempname);
		Assert(ERROR_SUCCESS == GetLastError());

		 
		_tcscpy(pPciFile->Locations.szPATFilePath, tempname);

		TCHAR tempname2[MAX_PATH];

		GetTempFileName(g_szPatchCacheDir, TEXT("HC"), 0, tempname2);
		Assert(ERROR_SUCCESS == GetLastError());

		bRet = DeleteFile(tempname);
		Assert(bRet);

		bRet = DeleteFile(tempname2);
		Assert(bRet);

		_tcscpy(pPciFile->Locations.szHDRFilePath, tempname2);
		}

	return bPatchInCache;
}


BOOL CopyPatches(PATCHFILELOCATIONS *pSource, PATCHFILELOCATIONS *pDest)
{
	BOOL bRet = FALSE;

	if (!FEmptySz(pSource->szPATFilePath))
		{
		bRet = CopyFile(pSource->szPATFilePath, pDest->szPATFilePath, FALSE);
		Assert(bRet);
		if (!bRet)
			{
			DWORD dwError = GetLastError();
			//todo: trace dwError possibly
			}

		}

	if (!FEmptySz(pSource->szHDRFilePath))
		{
		bRet = CopyFile(pSource->szHDRFilePath, pDest->szHDRFilePath, FALSE);
		Assert(bRet);
		if (!bRet)
			{
			DWORD dwError = GetLastError();
			//todo: trace dwError possibly
			}
		}

	return bRet;
}


BOOL CopyPatchesFromCache(CACHEDPATCHFILELOCATIONS *pCacheFileLocations, PATCHFILELOCATIONS *pTempFileLocations)
{
	return CopyPatches(pCacheFileLocations, pTempFileLocations);
}


BOOL CopyPatchesToCache(PATCHFILELOCATIONS *pTempFileLocations, CACHEDPATCHFILELOCATIONS *pCacheFileLocations)
{
	return CopyPatches(pTempFileLocations, pCacheFileLocations);
}


UINT PatchCacheEntryPoint( MSIHANDLE hdbInput, LPTSTR szFTK, LPTSTR szSrcPath, int iFileSeqNum, LPTSTR szTempFolder, LPTSTR szTempFName )
{
	Assert(g_szDestLFN[0]);
	Assert(g_szSourceLFN[0]);

	UINT ui = IDS_OKAY;

	Assert(szFTK);

	BOOL bRet;
	PCIFILEFORMAT PciFile = { 0 };

	TCHAR szPCIFN[MAX_PATH];

	_tcscpy(szPCIFN, g_szPatchCacheDir);

	_tcscat(szPCIFN, szFTK);

	_tcscat(szPCIFN, TEXT(".PCI"));

	PATCHFILELOCATIONS templocation = { 0 };

	TCHAR filename[MAX_PATH];
	wsprintf(filename, TEXT("%05i.PAT"), iFileSeqNum);
	_tcscpy(templocation.szPATFilePath, szTempFolder);

	_tcscat(templocation.szPATFilePath, filename);

	wsprintf(filename, TEXT("%05i.HDR"), iFileSeqNum);
	_tcscpy(templocation.szHDRFilePath, szTempFolder);

	_tcscat(templocation.szHDRFilePath, filename);

	bRet = PatchInCache(g_szSourceLFN, g_szDestLFN, szPCIFN, &PciFile);
	if (bRet) //patch was in cache, get it from there...
		{
		//get the patch files from cache and copy them to the temp dir...
		//don't do the patch code...
		bRet = CopyPatchesFromCache(&PciFile.Locations, &templocation);
		Assert(bRet);
		}
	else
		{
		//do patch code like before...
		ui = UiGenerateOnePatchFile(hdbInput, szFTK, szSrcPath, iFileSeqNum,
									szTempFolder, szTempFName);

		//patch creation successful???
		if (ui == IDS_OKAY)
			{
			bRet = CopyPatchesToCache(&templocation, &PciFile.Locations);
			if (bRet) //copy was a success!!!  Create FTK.PCI file...
				{
				//write out info file for patch and the two files patch was for...

				DWORD dwReturn = WritePCIInfoToCache(szPCIFN, &PciFile);
				if (PCI_SUCCESS != dwReturn)
					{
					//todo: trace dwResult...
					}
				}
			}
		}
    
	return ui;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\patchwiz\patchdll.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//--------------------------------------------------------------------------

  /* PATCHDLL.H - internal header file for PATCHWIZ.DLL */

#ifndef _PATCHDLL_H_3AA1E0C9_FE2F_4A53_AE2F_CC71C7E7ABB5
#define _PATCHDLL_H_3AA1E0C9_FE2F_4A53_AE2F_CC71C7E7ABB5

#include <windows.h>
#include <ole2.h>
#include "patchwiz.h"
#include "patchres.h"

#define hwndNull  ((HWND)NULL)
#define szNull    ((LPTSTR)NULL)
#define pfNull    ((PBOOL)NULL)
#define fTrue     TRUE
#define fFalse    FALSE
#define szEmpty   (TEXT(""))
#define szMsgBoxTitle (TEXT("Patch Creation Wizard"))

static LPCTSTR _sz = szNull;
#define FEmptySz(sz) ((BOOL)(((_sz=(sz))==szNull)||(*_sz==TEXT('\0'))))

#ifndef RC_INVOKED
#include "myassrtc.h"
#include "msiquery.h"
#define MSI_OKAY ERROR_SUCCESS
#include "patchapi.h"
#include "tchar.h"
#endif  // !RC_INVOKED


extern TCHAR  rgchTempFolder[MAX_PATH + MAX_PATH];
extern LPTSTR szTempFileName;
extern TCHAR  rgchPatchPath[MAX_PATH];
extern int    iOrderMax;


UINT UiLogError     ( UINT ids, LPTSTR szData, LPTSTR szData2 );
BOOL FWriteLogFile  ( LPTSTR szLine );
BOOL FSprintfToLog  ( LPTSTR szLine, LPTSTR szData1, LPTSTR szData2, LPTSTR szData3, LPTSTR szData4 );
BOOL FValidHexValue ( LPTSTR sz );


/* UTILS.CPP */

#define IDS_STATUS_MIN    IDS_STATUS_VALIDATE_INPUT
#define IDS_STATUS_MAX    IDS_STATUS_CLEANUP+1

void InitStatusMsgs         ( HWND hwndStatus );
void UpdateStatusMsg        ( UINT ids, LPTSTR szData1, LPTSTR szData2 );
void EndStatusMsgs          ( void );
HWND HdlgStatus             ( void );

void MyYield                ( void );

BOOL FLoadString            ( UINT ids, LPTSTR rgch, UINT cch );
int  IMessageBoxIds         ( HWND hwnd, UINT ids, UINT uiType );

LPTSTR SzLastChar           ( LPTSTR sz );
LPTSTR SzDupSz              ( LPTSTR sz );
LPSTR  SzaDupSz             ( LPTSTR sz );
BOOL   FFileExist           ( LPTSTR sz );
BOOL   FFolderExist         ( LPTSTR sz );
LPTSTR SzFindFilenameInPath ( LPTSTR sz );

BOOL   FDeleteFiles         ( LPTSTR sz );
BOOL   FEnsureFolderExists  ( LPTSTR sz );

BOOL   FSetTempFolder       ( LPTSTR szBuf, LPTSTR *pszFName, HWND hwnd, LPTSTR szTempFolder, BOOL fRemoveTempFolderIfPresent );
BOOL   FDeleteTempFolder    ( LPTSTR sz );
BOOL   FMatchPrefix         ( LPTSTR sz, LPTSTR szPrefix );

BOOL   FFixupPath           ( LPTSTR sz );
BOOL   FFixupPathEx         ( LPTSTR szIn, LPTSTR szOut );


/* FILEPTCH.CPP */

const int cchMaxGuid       = 39;
const int cchMaxStreamName = 62;
const int iMinMsiPatchHeadersVersion = 200;
const int iWindowsInstallerME = 120;
const int iWindowsInstallerXP = 200;

UINT UiMakeFilePatchesCabinetsTransformsAndStuffIntoPatchPackage (
			MSIHANDLE hdbInput, LPTSTR szPatchPath, LPTSTR szTempFolder, LPTSTR szTempFName );


/* MSISTUFF.CPP */

#define MAX_LENGTH_IMAGE_FAMILY_NAME 8
#define MAX_LENGTH_TARGET_IMAGE_NAME 13

#define IDS_OKAY        0
#define MSI_OKAY        ERROR_SUCCESS

#define IDS_CANCEL      7
#define IDS_MATCH       IDS_CANCEL
#define IDS_NOMATCH     IDS_OKAY

#define IDS_OOM                             34
#define IDS_CANT_OPEN_MSI                   40
#define IDS_CANT_APPLY_MST                  41
#define IDS_CANT_OPEN_VIEW					42
#define IDS_CANT_EXECUTE_VIEW				43
#define IDS_CANT_CREATE_RECORD				44
#define IDS_CANT_FETCH_RECORD				45
#define IDS_CANT_SET_RECORD_FIELD			46
#define IDS_CANT_GET_RECORD_FIELD			47
#define IDS_CANT_ASSIGN_RECORD_IN_VIEW		48
#define IDS_CANT_DELETE_RECORD_IN_VIEW		49
#define IDS_CANT_GENERATE_MST				50
#define IDS_CANT_SAVE_MSI					51
#define IDS_BUFFER_IS_TOO_SHORT				52
#define IDS_BAD_DEST_FOLDER                 53
#define IDS_BAD_DIRECTORY_NAME              54
#define IDS_MISSING_INSTALLSEQ_RECORD       55

UINT UiOpenInputPcp           ( LPTSTR szPcpPath, LPTSTR szTempFldrBuf, LPTSTR szTempFName, MSIHANDLE* phdbInput );

UINT UiValidateInputRecords   ( MSIHANDLE hdb, LPTSTR szMsiPath, LPTSTR szPatchPath, LPTSTR szTempFolder, LPTSTR szTempFName );
UINT IdsResolveSrcFilePathSzs ( MSIHANDLE hdb, LPTSTR szBuf, LPTSTR szComponent, LPTSTR szFName, BOOL fLfn, LPTSTR szFullSubFolder );

ULONG UlFromHexSz               ( LPTSTR sz );
ULONG UlGetRangeElement         ( LPTSTR* psz );
BOOL  FValidApiPatchSymbolFlags ( ULONG ul );

UINT UiCopyUpgradedMsiToTempFolderForEachTarget ( MSIHANDLE hdb, LPTSTR szTempFolder, LPTSTR szTempFName );

BOOL FExecSqlCmd  ( MSIHANDLE hdb, LPTSTR sz );
BOOL FTableExists ( MSIHANDLE hdb, LPTSTR szTable, BOOL fMsg );

UINT CchMsiTableString             ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szPKey, LPTSTR szFieldName, LPTSTR szPKeyValue );
UINT CchMsiTableStringWhere        ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFieldName, LPTSTR szWhere );
UINT IdsMsiGetTableString          ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szPKey, LPTSTR szFieldName, LPTSTR szPKeyValue, LPTSTR szBuf, UINT cch );
UINT IdsMsiGetTableInteger         ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szPKey, LPTSTR szFieldName, LPTSTR szPKeyValue, int * pi );
UINT IdsMsiGetTableStringWhere     ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFieldName, LPTSTR szWhere, LPTSTR szBuf, UINT cch );
UINT IdsMsiGetTableIntegerWhere    ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFieldName, LPTSTR szWhere, int * pi );
UINT IdsMsiSetTableRecord          ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFields, LPTSTR szPrimaryField, LPTSTR szKey, MSIHANDLE hrec );
UINT IdsMsiSetTableRecordWhere     ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szFields, LPTSTR szWhere, MSIHANDLE hrec );
UINT IdsMsiUpdateTableRecordSz     ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szValue, LPTSTR szPKeyField, LPTSTR szPKeyValue );
UINT IdsMsiUpdateTableRecordInt    ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, int iValue, LPTSTR szPKeyField, LPTSTR szPKeyValue );
UINT IdsMsiUpdateTableRecordIntPkeyInt ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, int iValue, LPTSTR szPKeyField, int iPKeyValue );
UINT IdsMsiDeleteTableRecords      ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szKey );
UINT IdsMsiDeleteTableRecordsWhere ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szWhere );
typedef UINT (*PIEMTPROC)          ( MSIHANDLE, MSIHANDLE, LPARAM, LPARAM );
UINT IdsMsiEnumTable               ( MSIHANDLE hdb, LPTSTR szTable,
			LPTSTR szFields, LPTSTR szWhere, PIEMTPROC pIemtProc, LPARAM lp1, LPARAM lp2 );
UINT IdsMsiExistTableRecordsWhere  ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szWhere, PBOOL pf );
UINT IdsMsiExistTableRecords       ( MSIHANDLE hdb, LPTSTR szTable, LPTSTR szField, LPTSTR szValue, PBOOL pf );

UINT IdsMsiGetPropertyString       ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue, UINT cch );
UINT IdsMsiSetPropertyString       ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue );

UINT CchMsiPcwPropertyString       ( MSIHANDLE hdb, LPTSTR szName );
UINT IdsMsiGetPcwPropertyString    ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue, UINT cch );
UINT IdsMsiGetPcwPropertyInteger   ( MSIHANDLE hdb, LPTSTR szName, int * pi );
UINT IdsMsiSetPcwPropertyString    ( MSIHANDLE hdb, LPTSTR szName, LPTSTR szValue );

MSIHANDLE HdbReopenMsi ( MSIHANDLE hdbInput, LPTSTR szImage, BOOL fUpgradedImage, BOOL fTargetUpgradedCopy );


#define PID_SUBJECT      3
#define PID_KEYWORDS     5
#define PID_COMMENTS     6
#define PID_TEMPLATE     7
#define PID_LASTAUTHOR   8
#define PID_REVNUMBER    9
#define PID_PAGECOUNT   14
#define PID_MSISOURCE   15
#define PID_WORDCOUNT   15

#ifdef UNICODE
#define VT_LPTSTR    VT_LPSTR
#else
#define VT_LPTSTR    VT_LPSTR
#endif

const TCHAR szPatchMediaSrcProp[] = TEXT("PATCHMediaSrcProp");

#endif //_PATCHDLL_H_3AA1E0C9_FE2F_4A53_AE2F_CC71C7E7ABB5
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\patchwiz\patchwiz.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999
//
//--------------------------------------------------------------------------

  /* PATCHWIZ.H - public header file for PATCHWIZ.DLL */

/*
**	UINT WINAPI UiCreatePatchPackage ( LPTSTR szPcpPath,
**		LPTSTR szPatchPath, LPTSTR szLogPath, HWND hwndStatus,
**		LPTSTR szTempFolder, BOOL fRemoveTempFolderIfPresent );
**
**	Arguments:
**	  szPcpPath - full absolute path to Windows Installer database
**		(PCP file) that contains appropriate tables of input-data for
**		Patch creation process such as Properties and TargetImages.
**	  szPatchPath - optional, full absolute path to Patching Package
**		file (MSP file) to create and stuff with output.  If this
**		NULL or an empty string, the api will try to use
**		Properties.Value where Properties.Name = PatchOutputPath
**		from the PCP file.
**	  szLogPath - optional, full absolute path to text log file to
**		append to.  Caller should truncate file if wanted.
**	  hwndStatus - optional, window handle to display status text.
**		More details to come later.
**	  szTempFolder - optional location to use for temp files.
**		Default is %TEMP%\~pcw_tmp.tmp\.
**	  fRemoveTempFolderIfPresent - remove temp folder (and all its
**		contents) if present.  If FALSE and folder is present, api
**		will fail.
**		
**	Return Values: ERROR_SUCCESS, plus ERROR_PCW_* that follow.
*/
#define ERROR_PCW_BASE                                 0xC00E5101

#define ERROR_PCW_PCP_DOESNT_EXIST                    (ERROR_PCW_BASE + 0x00)
#define ERROR_PCW_PCP_BAD_FORMAT                      (ERROR_PCW_BASE + 0x01)
#define ERROR_PCW_CANT_CREATE_TEMP_FOLDER             (ERROR_PCW_BASE + 0x02)
#define ERROR_PCW_MISSING_PATCH_PATH                  (ERROR_PCW_BASE + 0x03)
#define ERROR_PCW_CANT_OVERWRITE_PATCH                (ERROR_PCW_BASE + 0x04)
#define ERROR_PCW_CANT_CREATE_PATCH_FILE              (ERROR_PCW_BASE + 0x05)
#define ERROR_PCW_MISSING_PATCH_GUID                  (ERROR_PCW_BASE + 0x06)
#define ERROR_PCW_BAD_PATCH_GUID                      (ERROR_PCW_BASE + 0x07)
#define ERROR_PCW_BAD_GUIDS_TO_REPLACE                (ERROR_PCW_BASE + 0x08)
#define ERROR_PCW_BAD_TARGET_PRODUCT_CODE_LIST        (ERROR_PCW_BASE + 0x09)
#define ERROR_PCW_NO_UPGRADED_IMAGES_TO_PATCH         (ERROR_PCW_BASE + 0x0a)
//#define ERROR_PCW_BAD_API_PATCHING_OPTION_FLAGS       (ERROR_PCW_BASE + 0x0b) -- obsolete
#define ERROR_PCW_BAD_API_PATCHING_SYMBOL_FLAGS       (ERROR_PCW_BASE + 0x0c)
#define ERROR_PCW_OODS_COPYING_MSI                    (ERROR_PCW_BASE + 0x0d)
#define ERROR_PCW_UPGRADED_IMAGE_NAME_TOO_LONG        (ERROR_PCW_BASE + 0x0e)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_NAME             (ERROR_PCW_BASE + 0x0f)

#define ERROR_PCW_DUP_UPGRADED_IMAGE_NAME             (ERROR_PCW_BASE + 0x10)
#define ERROR_PCW_UPGRADED_IMAGE_PATH_TOO_LONG        (ERROR_PCW_BASE + 0x11)
#define ERROR_PCW_UPGRADED_IMAGE_PATH_EMPTY           (ERROR_PCW_BASE + 0x12)
#define ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_EXIST       (ERROR_PCW_BASE + 0x13)
#define ERROR_PCW_UPGRADED_IMAGE_PATH_NOT_MSI         (ERROR_PCW_BASE + 0x14)
#define ERROR_PCW_UPGRADED_IMAGE_COMPRESSED           (ERROR_PCW_BASE + 0x15)
#define ERROR_PCW_TARGET_IMAGE_NAME_TOO_LONG          (ERROR_PCW_BASE + 0x16)
#define ERROR_PCW_BAD_TARGET_IMAGE_NAME               (ERROR_PCW_BASE + 0x17)
#define ERROR_PCW_DUP_TARGET_IMAGE_NAME               (ERROR_PCW_BASE + 0x18)
#define ERROR_PCW_TARGET_IMAGE_PATH_TOO_LONG          (ERROR_PCW_BASE + 0x19)
#define ERROR_PCW_TARGET_IMAGE_PATH_EMPTY             (ERROR_PCW_BASE + 0x1a)
#define ERROR_PCW_TARGET_IMAGE_PATH_NOT_EXIST         (ERROR_PCW_BASE + 0x1b)
#define ERROR_PCW_TARGET_IMAGE_PATH_NOT_MSI           (ERROR_PCW_BASE + 0x1c)
#define ERROR_PCW_TARGET_IMAGE_COMPRESSED             (ERROR_PCW_BASE + 0x1d)
#define ERROR_PCW_TARGET_BAD_PROD_VALIDATE            (ERROR_PCW_BASE + 0x1e)
#define ERROR_PCW_TARGET_BAD_PROD_CODE_VAL            (ERROR_PCW_BASE + 0x1f)

#define ERROR_PCW_UPGRADED_MISSING_SRC_FILES          (ERROR_PCW_BASE + 0x20)
#define ERROR_PCW_TARGET_MISSING_SRC_FILES            (ERROR_PCW_BASE + 0x21)
#define ERROR_PCW_IMAGE_FAMILY_NAME_TOO_LONG          (ERROR_PCW_BASE + 0x22)
#define ERROR_PCW_BAD_IMAGE_FAMILY_NAME               (ERROR_PCW_BASE + 0x23)
#define ERROR_PCW_DUP_IMAGE_FAMILY_NAME               (ERROR_PCW_BASE + 0x24)
#define ERROR_PCW_BAD_IMAGE_FAMILY_SRC_PROP           (ERROR_PCW_BASE + 0x25)
#define ERROR_PCW_UFILEDATA_LONG_FILE_TABLE_KEY       (ERROR_PCW_BASE + 0x26)
#define ERROR_PCW_UFILEDATA_BLANK_FILE_TABLE_KEY      (ERROR_PCW_BASE + 0x27)
#define ERROR_PCW_UFILEDATA_MISSING_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x28)
#define ERROR_PCW_EXTFILE_LONG_FILE_TABLE_KEY         (ERROR_PCW_BASE + 0x29)
#define ERROR_PCW_EXTFILE_BLANK_FILE_TABLE_KEY        (ERROR_PCW_BASE + 0x2a)
#define ERROR_PCW_EXTFILE_BAD_FAMILY_FIELD            (ERROR_PCW_BASE + 0x2b)
#define ERROR_PCW_EXTFILE_LONG_PATH_TO_FILE           (ERROR_PCW_BASE + 0x2c)
#define ERROR_PCW_EXTFILE_BLANK_PATH_TO_FILE          (ERROR_PCW_BASE + 0x2d)
#define ERROR_PCW_EXTFILE_MISSING_FILE                (ERROR_PCW_BASE + 0x2e)
//#define ERROR_PCW_FILERANGE_LONG_FILE_TABLE_KEY       (ERROR_PCW_BASE + 0x2f) -- obsolete

//#define ERROR_PCW_FILERANGE_BLANK_FILE_TABLE_KEY      (ERROR_PCW_BASE + 0x30) -- obsolete
//#define ERROR_PCW_FILERANGE_MISSING_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x31) -- obsolete
//#define ERROR_PCW_FILERANGE_LONG_PATH_TO_FILE         (ERROR_PCW_BASE + 0x32) -- obsolete
//#define ERROR_PCW_FILERANGE_MISSING_FILE              (ERROR_PCW_BASE + 0x33) -- obsolete
//#define ERROR_PCW_FILERANGE_INVALID_OFFSET            (ERROR_PCW_BASE + 0x34) -- obsolete
//#define ERROR_PCW_FILERANGE_INVALID_SIZE              (ERROR_PCW_BASE + 0x35) -- obsolete
//#define ERROR_PCW_FILERANGE_INVALID_RETAIN            (ERROR_PCW_BASE + 0x36) -- obsolete
//#define ERROR_PCW_BAD_MEDIA_SRC_PROP_NAME             (ERROR_PCW_BASE + 0x37) -- obsolete
//#define ERROR_PCW_BAD_MEDIA_DISK_ID                   (ERROR_PCW_BASE + 0x38) -- obsolete
#define ERROR_PCW_BAD_FILE_SEQUENCE_START             (ERROR_PCW_BASE + 0x39)
#define ERROR_PCW_CANT_COPY_FILE_TO_TEMP_FOLDER       (ERROR_PCW_BASE + 0x3a)
#define ERROR_PCW_CANT_CREATE_ONE_PATCH_FILE          (ERROR_PCW_BASE + 0x3b)
#define ERROR_PCW_BAD_IMAGE_FAMILY_DISKID             (ERROR_PCW_BASE + 0x3c)
#define ERROR_PCW_BAD_IMAGE_FAMILY_FILESEQSTART       (ERROR_PCW_BASE + 0x3d)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_FAMILY           (ERROR_PCW_BASE + 0x3e)
#define ERROR_PCW_BAD_TARGET_IMAGE_UPGRADED           (ERROR_PCW_BASE + 0x3f)

#define ERROR_PCW_DUP_TARGET_IMAGE_PACKCODE           (ERROR_PCW_BASE + 0x40)
#define ERROR_PCW_UFILEDATA_BAD_UPGRADED_FIELD        (ERROR_PCW_BASE + 0x41)
#define ERROR_PCW_MISMATCHED_PRODUCT_CODES            (ERROR_PCW_BASE + 0x42)
#define ERROR_PCW_MISMATCHED_PRODUCT_VERSIONS         (ERROR_PCW_BASE + 0x43)
#define ERROR_PCW_CANNOT_WRITE_DDF                    (ERROR_PCW_BASE + 0x44)
#define ERROR_PCW_CANNOT_RUN_MAKECAB                  (ERROR_PCW_BASE + 0x45)
//#define ERROR_PCW_CANNOT_CREATE_STORAGE               (ERROR_PCW_BASE + 0x46) -- obsolete
//#define ERROR_PCW_CANNOT_CREATE_STREAM                (ERROR_PCW_BASE + 0x47) -- obsolete
//#define ERROR_PCW_CANNOT_WRITE_STREAM                 (ERROR_PCW_BASE + 0x48) -- obsolete
//#define ERROR_PCW_CANNOT_READ_CABINET                 (ERROR_PCW_BASE + 0x49) -- obsolete
#define ERROR_PCW_WRITE_SUMMARY_PROPERTIES            (ERROR_PCW_BASE + 0x4a)
#define ERROR_PCW_TFILEDATA_LONG_FILE_TABLE_KEY       (ERROR_PCW_BASE + 0x4b)
#define ERROR_PCW_TFILEDATA_BLANK_FILE_TABLE_KEY      (ERROR_PCW_BASE + 0x4c)
#define ERROR_PCW_TFILEDATA_MISSING_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x4d)
#define ERROR_PCW_TFILEDATA_BAD_TARGET_FIELD          (ERROR_PCW_BASE + 0x4e)
#define ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_TOO_LONG  (ERROR_PCW_BASE + 0x4f)

#define ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_EXIST (ERROR_PCW_BASE + 0x50)
#define ERROR_PCW_UPGRADED_IMAGE_PATCH_PATH_NOT_MSI   (ERROR_PCW_BASE + 0x51)
#define ERROR_PCW_DUP_UPGRADED_IMAGE_PACKCODE         (ERROR_PCW_BASE + 0x52)
#define ERROR_PCW_UFILEIGNORE_BAD_UPGRADED_FIELD      (ERROR_PCW_BASE + 0x53)
#define ERROR_PCW_UFILEIGNORE_LONG_FILE_TABLE_KEY     (ERROR_PCW_BASE + 0x54)
#define ERROR_PCW_UFILEIGNORE_BLANK_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x55)
#define ERROR_PCW_UFILEIGNORE_BAD_FILE_TABLE_KEY      (ERROR_PCW_BASE + 0x56)
#define ERROR_PCW_FAMILY_RANGE_NAME_TOO_LONG          (ERROR_PCW_BASE + 0x57)
#define ERROR_PCW_BAD_FAMILY_RANGE_NAME               (ERROR_PCW_BASE + 0x58)
#define ERROR_PCW_FAMILY_RANGE_LONG_FILE_TABLE_KEY    (ERROR_PCW_BASE + 0x59)
#define ERROR_PCW_FAMILY_RANGE_BLANK_FILE_TABLE_KEY   (ERROR_PCW_BASE + 0x5a)
#define ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_OFFSETS    (ERROR_PCW_BASE + 0x5b)
#define ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_OFFSETS   (ERROR_PCW_BASE + 0x5c)
#define ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_OFFSETS     (ERROR_PCW_BASE + 0x5d)
#define ERROR_PCW_FAMILY_RANGE_LONG_RETAIN_LENGTHS    (ERROR_PCW_BASE + 0x5e)
#define ERROR_PCW_FAMILY_RANGE_BLANK_RETAIN_LENGTHS   (ERROR_PCW_BASE + 0x5f)

#define ERROR_PCW_FAMILY_RANGE_BAD_RETAIN_LENGTHS     (ERROR_PCW_BASE + 0x60)
#define ERROR_PCW_FAMILY_RANGE_COUNT_MISMATCH         (ERROR_PCW_BASE + 0x61)
#define ERROR_PCW_EXTFILE_LONG_IGNORE_OFFSETS         (ERROR_PCW_BASE + 0x62)
#define ERROR_PCW_EXTFILE_BAD_IGNORE_OFFSETS          (ERROR_PCW_BASE + 0x63)
#define ERROR_PCW_EXTFILE_LONG_IGNORE_LENGTHS         (ERROR_PCW_BASE + 0x64)
#define ERROR_PCW_EXTFILE_BAD_IGNORE_LENGTHS          (ERROR_PCW_BASE + 0x65)
#define ERROR_PCW_EXTFILE_IGNORE_COUNT_MISMATCH       (ERROR_PCW_BASE + 0x66)
#define ERROR_PCW_EXTFILE_LONG_RETAIN_OFFSETS         (ERROR_PCW_BASE + 0x67)
#define ERROR_PCW_EXTFILE_BAD_RETAIN_OFFSETS          (ERROR_PCW_BASE + 0x68)
//#define ERROR_PCW_EXTFILE_RETAIN_COUNT_MISMATCH       (ERROR_PCW_BASE + 0x69) -- obsolete
#define ERROR_PCW_TFILEDATA_LONG_IGNORE_OFFSETS       (ERROR_PCW_BASE + 0x6a)
#define ERROR_PCW_TFILEDATA_BAD_IGNORE_OFFSETS        (ERROR_PCW_BASE + 0x6b)
#define ERROR_PCW_TFILEDATA_LONG_IGNORE_LENGTHS       (ERROR_PCW_BASE + 0x6c)
#define ERROR_PCW_TFILEDATA_BAD_IGNORE_LENGTHS        (ERROR_PCW_BASE + 0x6d)
#define ERROR_PCW_TFILEDATA_IGNORE_COUNT_MISMATCH     (ERROR_PCW_BASE + 0x6e)
#define ERROR_PCW_TFILEDATA_LONG_RETAIN_OFFSETS       (ERROR_PCW_BASE + 0x6f)

#define ERROR_PCW_TFILEDATA_BAD_RETAIN_OFFSETS        (ERROR_PCW_BASE + 0x70)
//#define ERROR_PCW_TFILEDATA_RETAIN_COUNT_MISMATCH     (ERROR_PCW_BASE + 0x71) -- obsolete
#define ERROR_PCW_CANT_GENERATE_TRANSFORM             (ERROR_PCW_BASE + 0x72)
#define ERROR_PCW_CANT_CREATE_SUMMARY_INFO            (ERROR_PCW_BASE + 0x73)
#define ERROR_PCW_CANT_GENERATE_TRANSFORM_POUND       (ERROR_PCW_BASE + 0x74)
#define ERROR_PCW_CANT_CREATE_SUMMARY_INFO_POUND      (ERROR_PCW_BASE + 0x75)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_CODE     (ERROR_PCW_BASE + 0x76)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_PRODUCT_VERSION  (ERROR_PCW_BASE + 0x77)
#define ERROR_PCW_BAD_UPGRADED_IMAGE_UPGRADE_CODE     (ERROR_PCW_BASE + 0x78)
#define ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_CODE       (ERROR_PCW_BASE + 0x79)
#define ERROR_PCW_BAD_TARGET_IMAGE_PRODUCT_VERSION    (ERROR_PCW_BASE + 0x7a)
#define ERROR_PCW_BAD_TARGET_IMAGE_UPGRADE_CODE       (ERROR_PCW_BASE + 0x7b)
#define ERROR_PCW_MATCHED_PRODUCT_VERSIONS            (ERROR_PCW_BASE + 0x7c)
#define ERROR_PCW_NEXTxd           (ERROR_PCW_BASE + 0x7d)
#define ERROR_PCW_NEXTxe           (ERROR_PCW_BASE + 0x7e)
#define ERROR_PCW_NEXTxf           (ERROR_PCW_BASE + 0x7f)

/* 
#define ERROR_PCW_NEXTx0           (ERROR_PCW_BASE + 0x80)
#define ERROR_PCW_NEXTx1           (ERROR_PCW_BASE + 0x81)
#define ERROR_PCW_NEXTx2           (ERROR_PCW_BASE + 0x82)
#define ERROR_PCW_NEXTx3           (ERROR_PCW_BASE + 0x83)
#define ERROR_PCW_NEXTx4           (ERROR_PCW_BASE + 0x84)
#define ERROR_PCW_NEXTx5           (ERROR_PCW_BASE + 0x85)
#define ERROR_PCW_NEXTx6           (ERROR_PCW_BASE + 0x86)
#define ERROR_PCW_NEXTx7           (ERROR_PCW_BASE + 0x87)
#define ERROR_PCW_NEXTx8           (ERROR_PCW_BASE + 0x88)
#define ERROR_PCW_NEXTx9           (ERROR_PCW_BASE + 0x89)
#define ERROR_PCW_NEXTxa           (ERROR_PCW_BASE + 0x8a)
#define ERROR_PCW_NEXTxb           (ERROR_PCW_BASE + 0x8b)
#define ERROR_PCW_NEXTxc           (ERROR_PCW_BASE + 0x8c)
#define ERROR_PCW_NEXTxd           (ERROR_PCW_BASE + 0x8d)
#define ERROR_PCW_NEXTxe           (ERROR_PCW_BASE + 0x8e)
#define ERROR_PCW_NEXTxf           (ERROR_PCW_BASE + 0x8f)
*/


/*  Control IDs for hwndStatus child Text controls; title is required */
#define IDC_STATUS_TITLE                     (0x1cf0)
#define IDC_STATUS_DATA1                     (0x1cf1)
#define IDC_STATUS_DATA2                     (0x1cf2)



#ifdef __cplusplus
extern "C" {
#endif

extern UINT __declspec(dllexport) WINAPI UiCreatePatchPackageA ( LPSTR  szaPcpPath, LPSTR  szaPatchPath, LPSTR  szaLogPath, HWND hwndStatus, LPSTR  szaTempFolder, BOOL fRemoveTempFolderIfPresent );
extern UINT __declspec(dllexport) WINAPI UiCreatePatchPackageW ( LPWSTR szwPcpPath, LPWSTR szwPatchPath, LPWSTR szwLogPath, HWND hwndStatus, LPWSTR szwTempFolder, BOOL fRemoveTempFolderIfPresent );

#ifdef __cplusplus
} /* end extern "C" */
#endif


#ifdef UNICODE
#define UiCreatePatchPackage  UiCreatePatchPackageW
#else
#define UiCreatePatchPackage  UiCreatePatchPackageA
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\patchwiz\pwutils.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999-2000
//
//--------------------------------------------------------------------------

  /* PWUTILS.CPP -- Patch Creation Wizard DLL Utilities */

#pragma warning (disable:4553)

#include "patchdll.h"
#include <tchar.h>

EnableAsserts


static HINSTANCE hinstDll = NULL;

/* ********************************************************************** */
BOOL WINAPI DllMain ( HANDLE hModule, DWORD dwReason, LPVOID lpReserved )
{
	Unused(lpReserved);

	if (dwReason == DLL_PROCESS_ATTACH)
		{
		if ( ::CoInitialize(NULL) != S_OK )
			return (0);
		hinstDll = (HINSTANCE)hModule;
		}
	else if (dwReason == DLL_PROCESS_DETACH)
		{
		::CoUninitialize();
		}

	return (1);
}


static HWND  hdlgStatus        = hwndNull;
static HWND  hwndStatusTitle   = hwndNull;
static HWND  hwndStatusData1   = hwndNull;
static HWND  hwndStatusData2   = hwndNull;
static DWORD dwTicksStatusEnd  = 0;
static UINT  idsStatusTitleCur = 0;

/* ********************************************************************** */
void InitStatusMsgs ( HWND hwndStatus )
{
	Assert(hdlgStatus == hwndNull);
	Assert(idsStatusTitleCur == 0);

	if (hwndStatus == hwndNull)
		return;

	hwndStatusTitle  = GetDlgItem(hwndStatus, IDC_STATUS_TITLE);
	Assert(hwndStatusTitle != hwndNull);
	if (hwndStatusTitle == hwndNull)
		return;

	hdlgStatus       = hwndStatus;
	dwTicksStatusEnd = GetTickCount() + 1000L;  /* 1 second */
	hwndStatusData1  = GetDlgItem(hwndStatus, IDC_STATUS_DATA1);
	hwndStatusData2  = GetDlgItem(hwndStatus, IDC_STATUS_DATA2);
}


/* **************************************************************** */
void UpdateStatusMsg ( UINT ids, LPTSTR szData1, LPTSTR szData2 )
{
    Assert(ids == 0 || ids >= IDS_STATUS_MIN);
	Assert(ids == 0 || ids <  IDS_STATUS_MAX);
	Assert(szData1 != szNull || szData2 != szNull);

	if (hdlgStatus == hwndNull)
		return;

	Assert(hwndStatusTitle != hwndNull);

	if (ids != 0 && ids != idsStatusTitleCur)
		{
		Assert(szData1 != szNull);
		Assert(szData2 != szNull);

		TCHAR rgch[256];
		EvalAssert( FLoadString(ids, rgch, 256) );

		while (GetTickCount() < dwTicksStatusEnd)
			MyYield();

		SetWindowText(hwndStatusTitle, rgch);
		dwTicksStatusEnd = GetTickCount() + 1000L;  /* 1 second */
		}

	if (szData1 != szNull && hwndStatusData1 != hwndNull)
		SetWindowText(hwndStatusData1, szData1);

	if (szData2 != szNull && hwndStatusData2 != hwndNull)
		SetWindowText(hwndStatusData2, szData2);

	MyYield();
}


/* **************************************************************** */
void EndStatusMsgs ( void )
{
    if (hdlgStatus != hwndNull && idsStatusTitleCur != 0)
		{
		Assert(dwTicksStatusEnd > 0);
		Assert(hwndStatusTitle != hwndNull);

		while (GetTickCount() < dwTicksStatusEnd)
			MyYield();
		}

	hdlgStatus        = hwndNull;
	hwndStatusTitle   = hwndNull;
	hwndStatusData1   = hwndNull;
	hwndStatusData2   = hwndNull;
	dwTicksStatusEnd  = 0;
	idsStatusTitleCur = 0;
}


/* **************************************************************** */
HWND HdlgStatus ( void )
{
	return (hdlgStatus);
}


/* **************************************************************** */
void MyYield ( void )
{
	MSG msg;
	while (PeekMessage(&msg, hwndNull, 0, 0, PM_REMOVE))
		{
		if (hdlgStatus != hwndNull && IsDialogMessage(hdlgStatus, &msg))
			continue;

		TranslateMessage(&msg);
		DispatchMessage(&msg);
		}
}


/* ********************************************************************** */
BOOL FLoadString ( UINT ids, LPTSTR rgch, UINT cch )
{
    Assert(hinstDll != NULL);
    Assert(rgch != szNull);
    Assert(cch > 0);

    return (LoadString(hinstDll, ids, rgch, cch));
}


/* ********************************************************************** */
int IMessageBoxIds ( HWND hwnd, UINT ids, UINT uiType )
{
	TCHAR rgchMsg[MAX_PATH];
	EvalAssert( FLoadString(ids, rgchMsg, MAX_PATH) );

	TCHAR rgchTitle[MAX_PATH];
	EvalAssert( FLoadString(IDS_TITLE, rgchTitle, MAX_PATH) );

	return (MessageBox(hwnd, rgchMsg, rgchTitle, uiType));
}


/* ********************************************************************** */
LPTSTR SzLastChar ( LPTSTR sz )
{
    Assert(sz != szNull);
	Assert(*sz != TEXT('\0'));

    LPTSTR szNext = CharNext(sz);
    while (*szNext != TEXT('\0'))
        {
        sz = szNext;
        szNext = CharNext(sz);
        }

    return (sz);
}


/* ********************************************************************** */
LPTSTR SzDupSz ( LPTSTR sz )
{
	Assert(sz != szNull);

	UINT   cch = lstrlen(sz) + 1;
	LPTSTR szNew = (LPTSTR)LocalAlloc(LPTR, cch*sizeof(TCHAR));
	if (szNew != szNull)
		lstrcpy(szNew, sz);

	return (szNew);
}


/* ********************************************************************** */
LPSTR SzaDupSz ( LPTSTR sz )
{
	Assert(sz != szNull);

#ifdef UNICODE
	// nyi - convert to ansi and dup that
	return 0;
#else
	return (SzDupSz(sz));
#endif
}


/* ********************************************************************** */
BOOL FFileExist ( LPTSTR sz )
{
	if (sz == NULL || *sz == TEXT('\0'))
		return (fFalse);

	return (!(GetFileAttributes(sz) & FILE_ATTRIBUTE_DIRECTORY));
}


/* ********************************************************************** */
BOOL FFolderExist ( LPTSTR sz )
{
	if (sz == NULL || *sz == TEXT('\0'))
		return (fFalse);

	DWORD dwRet = GetFileAttributes(sz);

	return (dwRet != 0xffffffff && (dwRet & FILE_ATTRIBUTE_DIRECTORY));
}


/* ********************************************************************** */
BOOL FDeleteTempFolder ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));
	Assert(FFolderExist(sz));

	TCHAR rgch[MAX_PATH];
	lstrcpy(rgch, sz);

	LPTSTR szTail = SzLastChar(rgch);
	Assert(*szTail == TEXT('\\'));

	lstrcat(szTail, TEXT("*.*"));
	if (!FDeleteFiles(rgch))
		{
		AssertFalse();
		return (fFalse);
		}

	RemoveDirectory(sz);
	*szTail = TEXT('\0');
	RemoveDirectory(rgch);
	Assert(!FFolderExist(sz));

	return (!FFolderExist(sz));
}


/* ********************************************************************** */
BOOL FDeleteFiles ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));
	Assert(*SzLastChar(sz) != TEXT('\\'));

	TCHAR rgch[MAX_PATH];
	lstrcpy(rgch, sz);

	LPTSTR szTail = SzFindFilenameInPath(rgch);
	Assert(!FEmptySz(szTail));
	Assert(*szTail != TEXT('\\'));

	WIN32_FIND_DATA ffd;
	HANDLE hff = FindFirstFile(sz, &ffd);
	while (hff != INVALID_HANDLE_VALUE)
		{
		if (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
			{
			lstrcpy(szTail, ffd.cFileName);
			Assert(lstrlen(rgch) < MAX_PATH);
			SetFileAttributes(rgch, FILE_ATTRIBUTE_NORMAL);
			DeleteFile(rgch);
			Assert(!FFileExist(rgch));
			}
		else if (lstrcmp(ffd.cFileName, TEXT(".")) && lstrcmp(ffd.cFileName, TEXT("..")))
			{
			lstrcpy(szTail, ffd.cFileName);
			lstrcat(szTail, TEXT("\\"));
			EvalAssert( FDeleteTempFolder(rgch) );
			}

		if (!FindNextFile(hff, &ffd))
			{
			Assert(GetLastError() == ERROR_NO_MORE_FILES);
			EvalAssert( FindClose(hff) );
			hff = INVALID_HANDLE_VALUE;
			}
		}

	return (fTrue);
}


/* ********************************************************************** */
BOOL FEnsureFolderExists ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));
	Assert(*SzLastChar(sz) == TEXT('\\'));

	if (*sz == TEXT('\0') || *SzLastChar(sz) != TEXT('\\'))
		return (fFalse);

	/* RECURSION WARNING */

	if (FFolderExist(sz))
		return (fTrue);

	LPTSTR szLast = SzLastChar(sz);
	Assert(!FEmptySz(szLast));
	Assert(*szLast == TEXT('\\'));
	*szLast = TEXT('\0');

	LPTSTR szFName = SzFindFilenameInPath(sz);
	Assert(!FEmptySz(szFName));
	TCHAR chSav = *szFName;
	*szFName = TEXT('\0');

	BOOL fRet = FEnsureFolderExists(sz);

	*szFName = chSav;
	if (fRet && !FFolderExist(sz))
		fRet = CreateDirectory(sz, NULL);

	*szLast = TEXT('\\');

	return (fRet);
}


/* ********************************************************************** */
LPTSTR SzFindFilenameInPath ( LPTSTR sz )
{
	Assert(sz != szNull);

	LPTSTR szSlash = szNull;
	LPTSTR szCur   = sz;

	while (*szCur != TEXT('\0'))
		{
		LPTSTR szNext = CharNext(szCur);
		if (*szCur == TEXT('\\') && *szNext != TEXT('\0'))
			szSlash = szCur;
		szCur = szNext;
		}

	if (szSlash != szNull)
		return (CharNext(szSlash));

	return (sz);
}


/*
**	Windows API GetTempPath() can return unusable stuff if the TMP or
**	TEMP environment variables are set to garbage.
*/
/* ********************************************************************** */
BOOL FSetTempFolder ( LPTSTR szBuf, LPTSTR *pszFName, HWND hwnd, LPTSTR szTempFolder, BOOL fRemoveTempFolderIfPresent )
{
	Assert(szBuf != szNull);
	Assert(pszFName != NULL);

	TCHAR rgchPath[MAX_PATH + MAX_PATH];
	if (!FEmptySz(szTempFolder))
		{
		wsprintf(rgchPath, TEXT("Bad szTempFolder argument: '%s'."), szTempFolder);
		if (*SzLastChar(szTempFolder) == TEXT('\\'))
			*SzLastChar(szTempFolder) = TEXT('\0');
		while (*SzLastChar(szTempFolder) == TEXT('.'))
			{
			*SzLastChar(szTempFolder) = TEXT('\0');
			if (*SzLastChar(szTempFolder) == TEXT('\\'))
				*SzLastChar(szTempFolder) = TEXT('\0');
			else
				break;
			}
		if (FEmptySz(szTempFolder) || *szTempFolder == TEXT(':')
				|| *SzLastChar(szTempFolder) == TEXT('\\')
				|| *SzLastChar(szTempFolder) == TEXT(':'))
			{
LFailureReturn:
			*pszFName = szNull;
			if (hwnd != hwndNull)
				MessageBox(hwnd, rgchPath, szMsgBoxTitle, MB_OK | MB_ICONEXCLAMATION);
			return (fFalse);
			}
		if (*szTempFolder == TEXT('\\'))
			{
			LPTSTR sz = CharNext(szTempFolder);
			if (*sz == TEXT('\\')) //  \\server\share\subfolder
				{
				sz = CharNext(sz);
				if (*sz == TEXT('\\'))
					goto LFailureReturn;
				while (*sz != TEXT('\\'))
					{
					if (*sz == TEXT('\0'))
						goto LFailureReturn;
					sz = CharNext(sz);
					}
				sz = CharNext(sz);
				if (*sz == TEXT('\\'))
					goto LFailureReturn;
				while (*sz != TEXT('\\'))
					{
					if (*sz == TEXT('\0'))
						goto LFailureReturn;
					sz = CharNext(sz);
					}
				sz = CharNext(sz);
				if (*sz == TEXT('\0') || *sz == TEXT('\\'))
					goto LFailureReturn;
				}
			else if (*sz == TEXT(':'))
				goto LFailureReturn;
			}

		LPTSTR szFName = szNull;
		// could use _tfullpath()
		DWORD  dwRet   = GetFullPathName(szTempFolder, MAX_PATH, szBuf, &szFName);
		if (0 == dwRet)
			goto LFailureReturn;
		if (!FEmptySz(szFName))
			goto LGotFolderPath;
		}

	UINT uiRet;
	uiRet = GetTempPath(MAX_PATH, szBuf);
	Assert(uiRet > 0);
	Assert(uiRet < MAX_PATH);
	
	LPTSTR szLast;
	szLast = SzLastChar(szBuf);
	Assert(szLast != szNull);
	if (*szLast != TEXT('\\'))
		lstrcat(szLast, TEXT("\\"));

	if (!FEnsureFolderExists(szBuf))
		goto LUseWinDir;

	if (!GetTempFileName(szBuf, TEXT("SPH"), 0, rgchPath))
		goto LUseWinDir;
	Assert(lstrlen(rgchPath) < MAX_PATH);
	if (!FFileExist(rgchPath))
		goto LUseWinDir;
	DeleteFile(rgchPath);
	if (FFileExist(rgchPath))
		{
LUseWinDir:
		uiRet = GetWindowsDirectory(szBuf, MAX_PATH);
		Assert(uiRet > 0);
		Assert(uiRet < MAX_PATH);
		szLast = SzLastChar(szBuf);
		Assert(szLast != szNull);
		if (*szLast != TEXT('\\'))
			lstrcat(szLast, TEXT("\\"));
		Assert(FFolderExist(szBuf));
		}

	lstrcat(szBuf, TEXT("~PCW_TMP.TMP"));

LGotFolderPath:
	EvalAssert( FFixupPath(szBuf) );
	wsprintf(rgchPath, TEXT("Cannot delete file: '%s'."), szBuf);
	while (FFileExist(szBuf))
		{
		SetFileAttributes(szBuf, FILE_ATTRIBUTE_NORMAL);
		DeleteFile(szBuf);
		if (FFileExist(szBuf))
			{
			if (hwnd == hwndNull || IDRETRY != MessageBox(hwnd, rgchPath, szMsgBoxTitle, MB_RETRYCANCEL | MB_ICONEXCLAMATION))
				return (fFalse);
			}
		}

	lstrcat(szBuf, TEXT("\\"));
	*pszFName = szBuf + lstrlen(szBuf);

	if (FFolderExist(szBuf))
		{
		if (!fRemoveTempFolderIfPresent)
			{
			wsprintf(rgchPath, TEXT("PCW temp folder already exists: '%s'."), szBuf);
			goto LFailureReturn;
			}
		else if (!FDeleteTempFolder(szBuf))
			{
			wsprintf(rgchPath, TEXT("Cannot delete PCW temp folder: '%s'."), szBuf);
			goto LFailureReturn;
			}
		}

	wsprintf(rgchPath, TEXT("Cannot create folder: '%s'."), szBuf);
	while (!FEnsureFolderExists(szBuf))
		{
		if (hwnd == hwndNull || IDRETRY != MessageBox(hwnd, rgchPath, szMsgBoxTitle, MB_RETRYCANCEL | MB_ICONEXCLAMATION))
			return (fFalse);
		}

	return (fTrue);
}


/* ********************************************************************** */
BOOL FMatchPrefix ( LPTSTR sz, LPTSTR szPrefix )
{
	Assert(sz != szNull);
	Assert(!FEmptySz(szPrefix));

	while (*szPrefix != TEXT('\0'))
		{
		if (*szPrefix != *sz)
			return (fFalse);
		sz       = CharNext(sz);
		szPrefix = CharNext(szPrefix);
		}

	return (fTrue);
}


/* ********************************************************************** */
BOOL FFixupPath ( LPTSTR sz )
{
	Assert(!FEmptySz(sz));

	TCHAR rgch[MAX_PATH];

	BOOL fRet = FFixupPathEx(sz, rgch);
	if (fRet)
		lstrcpy(sz, rgch);

	return (fRet);
}


/* ********************************************************************** */
BOOL FFixupPathEx ( LPTSTR szIn, LPTSTR szOut )
{
	Assert(!FEmptySz(szIn));
	Assert(szOut != szNull);

	return (NULL != _tfullpath(szOut, szIn, MAX_PATH));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\patchwiz\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=patchwiz
TARGETTYPE=DYNLINK

!INCLUDE ..\..\..\MsiMake.inc

UMTYPE=windows
DLLDEF=..\patchwiz.def
DLLENTRY=_DllMainCRTStartup

C_DEFINES=$(C_DEFINES) -DWIN32 -D_WIN32 
INCLUDES=$(INCLUDES);..;$(INC_DIR);$(RES_OBJDIR)

USE_LIBCMT=1

SOURCES=\
    ..\patchwiz.rc  \
    ..\fileptch.cpp \
    ..\msistuff.cpp \
    ..\patchwiz.cpp \
    ..\pwutils.cpp \
    ..\patchcache.cpp 

TARGETLIBS= \
       $(SDK_LIB_PATH)\kernel32.lib \
       $(SDK_LIB_PATH)\advapi32.lib \
       $(SDK_LIB_PATH)\user32.lib   \
       $(SDK_LIB_PATH)\version.lib  \
       $(SDK_LIB_PATH)\ole32.lib  \
       $(SDK_LIB_PATH)\msi.lib \
       $(SDK_LIB_PATH)\mspatchc.lib          

!if "$(MAKEDLL)"=="1"
MISCFILES=\
       $(BUILD_DIR)\patchwiz.lib
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\regmsi\sources.inc ===
TARGETNAME=regmsi
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=windows
UMENTRY=winmain

TARGETPATH=$(MSI_BUILD_TARGET)

TARGETLIBS=\
	$(SDK_LIB_PATH)\msi.lib \
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\OLE32.lib

C_DEFINES=$(C_DEFINES)
USE_LIBCMT=1

INCLUDES=$(INCLUDES);$(INC_DIR);$(RES_OBJDIR);$(BUILD_COMMONDIR);$(TOOLS_INC_DIR)

SOURCES=..\regmsi.cpp \
	..\regmsi.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\regmsi\regmsi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998
//
//  File:       regmsi.cpp
//
//--------------------------------------------------------------------------

/* regmsi.cpp - Registers/unregisters MsiComponents
____________________________________________________________________________*/

#undef UNICODE

#include "common.h"  // names of standard DLLs
#include "tools.h"   // names of tool DLLs
#define MSI_AUTOAPI_NAME   "AutoApi.dll"  // temporary until merged with kernel

const char szRegisterEntry[]   = "DllRegisterServer";
const char szUnregisterEntry[] = "DllUnregisterServer";

const char szCmdOptions[] = "AaSsEeHhPpCcLlGgTtIiKk/-UuQqDdBb";  // pairs of equivalent options
enum rfEnum // must track each pair of letters above
{
/* Aa */ rfAutomation = 1,
/* Ss */ rfServices   = 2,
/* Ee */ rfEngine     = 4,
/* Hh */ rfHandler    = 8,
/* Pp */ rfPatch      = 16,
/* Cc */ rfAcmeConv   = 32,
/* Ll */ rfLocalize   = 64,
/* Gg */ rfGenerate   = 128,
/* Tt */ rfUtilities  = 256,
/* Ii */ rfInstaller  = 512,
/* Kk */ rfKernel     = 1024,
/* /- */ rfNoOp       = 2048,
/* Uu */ rfUnregister = 4096,
/* Qq */ rfQuiet      = 8192,
/* Dd */ rfDebug      = 16384,
/* Bb */ rfLego       = 32768,
			rfCoreModules = rfAutomation + rfKernel + rfHandler,
			rfAllModules = rfCoreModules + rfServices + rfEngine + rfAcmeConv + rfPatch
												  + rfUtilities + rfInstaller + rfLocalize + rfGenerate
};
const char* rgszModule[] = // must track enum above
{
/* rfAutomation */ MSI_AUTOMATION_NAME,
/* rfServices   */ TEXT("MsiSrv.dll"),
/* rfEngine     */ TEXT("MsiEng.dll"),
/* rfHandler    */ MSI_HANDLER_NAME,
/* rfPatch      */ MSI_PATCH_NAME,
/* rfAcmeConv   */ MSI_ACMECONV_NAME,
/* rfLocalize   */ MSI_LOCALIZE_NAME,
/* rfGenerate   */ MSI_GENERATE_NAME,
/* rfUtilities  */ MSI_UTILITIES_NAME,
/* rfInstaller  */ MSI_AUTOAPI_NAME,
/* rfKernel     */ MSI_KERNEL_NAME,
/* 0 terminator */ 0,
/* rfUnregister */ szUnregisterEntry,
/* rfQuiet      */ "Quiet, no error display",
/* rfDebug      */ "(ignored)",
/* rfLego       */ "(ignored)",
};

enum reEnum
{
	reNoError    = 0,
	reCmdOption  = 1,
	reModuleLoad = 2,
	reEntryPoint = 3,
	reRegFailure = 4,
};
const char* rgszError[] = // must track reEnum
{
	"",
	"Invalid command line option",
	"Error loading module",
	"Could not obtain module entry: %s",
	"Execution failed: %s"
};

reEnum CallModule(const char* szModule, const char* szEntry)
{
	HINSTANCE hLib;
	FARPROC pEntry;
	hLib = WIN::LoadLibraryEx(szModule,0, LOAD_WITH_ALTERED_SEARCH_PATH);
	if (!hLib)
	{
		char szPath[MAX_PATH];
		WIN::GetModuleFileName(0, szPath, sizeof(szPath));
		char* pch = szPath + lstrlenA(szPath);
		while (*(pch-1) != '\\')
			pch--;
		IStrCopy(pch, szModule);
		hLib = WIN::LoadLibraryEx(szPath ,0, LOAD_WITH_ALTERED_SEARCH_PATH);
	}
	if (!hLib)
		return reModuleLoad;
	reEnum reReturn = reNoError;
	if ((pEntry = WIN::GetProcAddress(hLib, szEntry)) == 0)
		reReturn = reEntryPoint;
	else if ((*pEntry)() != 0)
		reReturn  = reRegFailure;
	FreeLibrary(hLib);
	return reReturn;
}

INT WINAPI
WinMain(HINSTANCE /*hInst*/, HINSTANCE/*hPrev*/, char* cmdLine, INT/*show*/)
{
	int rfCmdOptions = 0;
	reEnum reStat = reNoError;;
	for (; *cmdLine; cmdLine++)
	{
		if (*cmdLine == ' ')
			continue;
		if (*cmdLine == '?')
		{
			char szHelp[1024];
			char* pchHelp = szHelp;
			const char** pszModule = rgszModule;
			for (const char* pch = szCmdOptions; *pch; pszModule++, pch += 2)
			{
				if (*pszModule != 0)
					pchHelp += wsprintf(pchHelp, "%c\t%s\r", *pch, *pszModule);
			}
			WIN::MessageBox(0, szHelp, WIN::GetCommandLine(), MB_OK);
			return 0;
		}
		for (const char* pch = szCmdOptions; *pch != *cmdLine; pch++)
			if (*pch == 0)
			{
				WIN::MessageBox(0, rgszError[reCmdOption], WIN::GetCommandLine(), MB_OK);
				return 2;
			}
		rfCmdOptions |= 1 << (pch - szCmdOptions)/2;
	}
	if ((rfCmdOptions & rfAllModules) == 0)
		rfCmdOptions |= rfCoreModules;
	//!! will test TestAutomation flags and set the environment variable only if that flag is set
	//!! for now set it all the time until tests are updated
	WIN::SetEnvironmentVariable("_MSI_TEST", "R");
	const char* szEntry    = (rfCmdOptions & rfUnregister) ? szUnregisterEntry : szRegisterEntry;
	const char** pszModule = rgszModule;
	for (int iOptions = rfCmdOptions; *pszModule; pszModule++, iOptions >>= 1)
	{
		if ((iOptions & 1) && (reStat = CallModule(*pszModule, szEntry)) != reNoError)
		{
			char buf[80];
			wsprintf(buf, rgszError[reStat], szEntry);
			int iStat;
			if ((rfCmdOptions & rfQuiet)
			 || (iStat = WIN::MessageBox(0, buf, *pszModule, MB_ABORTRETRYIGNORE)) == IDABORT)
				break;
			if (iStat == IDRETRY)
				pszModule--;
			else // IDIGNORE
				reStat = reNoError;
		}
	}
	return reStat != reNoError;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\setup.exe\resource.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#ifndef _RESOURCE_H_39383913_1926_4E7F_9741_8F454BD9A99C_
#define _RESOURCE_H_39383913_1926_4E7F_9741_8F454BD9A99C_

#define IDS_APP_TITLE                  11
#define IDS_OUTOFMEM                   12
#define IDS_NOMSI                      13
#define IDS_CANCEL                     14
#define IDS_MISSING_RESOURCE           15
#define IDS_BANNER_TEXT                16
#define IDS_DEFAULT_PRODUCT            17
#define IDS_DOWNLOADING_PACKAGE        18
#define IDS_VALIDATING_SIGNATURE       19
#define IDS_REQUIRES_NEWER_VERSION     20
#define IDS_NO_WINTRUST                21
#define IDS_UNTRUSTED                  22
#define IDS_INVALID_PATH               23
#define IDS_USER_CANCELLED             24
#define IDS_INVALID_VER_STR            25
#define IDS_REQUIRES_ADMIN_PRIV        26
#define IDS_DOWNLOADING_INSTMSI        27
#define IDS_NOINSTMSI                  28
#define IDS_FAILED_TO_UPGRADE_MSI      29
#define IDS_REBOOT_REQUIRED            30
#define IDS_INCORRECT_INSTMSI          31
#define IDS_INSTALL_ERROR              32
#define IDS_ALLOW_MSI_UPDATE           33
#define IDS_INVALID_OPERATION          34
#define IDS_USAGE                      35

#define IDI_INSTALLER                  99

#define IDC_DOWNLOAD_ICON             101
#define IDC_DOWNLOAD_CANCEL           102
#define IDC_DOWNLOAD_BANNER           103
#define IDC_DOWNLOAD_PROGRESSBAR      104
#define IDC_DOWNLOAD_ACTIONTEXT       105

#define IDD_PROGRESS                 1101

#endif //_RESOURCE_H_39383913_1926_4E7F_9741_8F454BD9A99C_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\setup.exe\common.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       common.h
//
//--------------------------------------------------------------------------

#ifndef __COMMON_H_5F90F583_B9A4_4A8F_91BC_618DE6696231_
#define __COMMON_H_5F90F583_B9A4_4A8F_91BC_618DE6696231_

#include <windows.h>

/*--------------------------------------------------------------------------
 *
 * Predefined Resource Types
 *
 --------------------------------------------------------------------------*/
#define RT_INSTALL_PROPERTY  MAKEINTRESOURCE(40)

/*--------------------------------------------------------------------------
 *
 * Predefined Resource Names
 *
 --------------------------------------------------------------------------*/
#define ISETUPPROPNAME_BASEURL              TEXT("BASEURL")
#define ISETUPPROPNAME_DATABASE             TEXT("DATABASE")
#define ISETUPPROPNAME_OPERATION            TEXT("OPERATION")
#define ISETUPPROPNAME_MINIMUM_MSI          TEXT("MINIMUM_MSI")
#define ISETUPPROPNAME_INSTLOCATION         TEXT("INSTLOCATION")
#define ISETUPPROPNAME_INSTMSIA             TEXT("INSTMSIA")
#define ISETUPPROPNAME_INSTMSIW             TEXT("INSTMSIW")
#define ISETUPPROPNAME_PRODUCTNAME          TEXT("PRODUCTNAME")
#define ISETUPPROPNAME_PROPERTIES           TEXT("PROPERTIES")
#define ISETUPPROPNAME_PATCH                TEXT("PATCH")

/*--------------------------------------------------------------------------
 *
 * Common Prototypes
 *
 ---------------------------------------------------------------------------*/
UINT LoadResourceString(HINSTANCE hInst, LPCSTR lpType, LPCSTR lpName, LPSTR lpBuf, DWORD *pdwBufSize);
UINT SetupLoadResourceString(HINSTANCE hInst, LPCSTR lpName, LPSTR *lppBuf, DWORD dwBufSize);

#endif //__COMMON_H_5F90F583_B9A4_4A8F_91BC_618DE6696231_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\setup.exe\sources.inc ===
TARGETNAME=Setup
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=windows
UMENTRY=$(MSI_WINENTRY)

USE_LIBCMT=1

TARGETLIBS=\
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\wininet.lib \
	$(SDK_LIB_PATH)\urlmon.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\comctl32.lib \
	$(SDK_LIB_PATH)\version.lib \
	$(SDK_LIB_PATH)\advapi32.lib


C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(INC_DIR);$(RES_OBJDIR);$(INCLUDES)

SOURCES=\
	..\setup.cpp \
	..\vertrust.cpp \
	..\setupui.cpp \
	..\utils.cpp \
	..\setup.rc \
	..\upgrdmsi.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\setup.exe\setupui.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       setupui.cpp
//
//  Implementation of CDownloadUI class
//--------------------------------------------------------------------------

#define WIN // scope W32 API
#define COMCTL32 // scope COMCTRL32

#include "resource.h"
#include "setupui.h"
#include <commctrl.h>

//{B506A5D1-9716-4F35-8ED5-9ECB0E9A55F8}
const GUID IID_IDownloadBindStatusCallback = {0xB506A5D1L,0x9716,0x4F35,{0x8E,0xD5,0x9E,0xCB,0x0E,0x9A,0x55,0xF8}};
//{00000000-9716-4F35-8ED5-9ECB0E9A55F8}
const GUID IID_IUnknown = {0x00000000L,0x9716,0x4F35,{0x8E,0xD5,0x9E,0xCB,0x0E,0x9A,0x55,0xF8}};


/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::CDownloadUI constructor
//

CDownloadUI::CDownloadUI() : m_hwndProgress(0), m_hwndParent(0), m_hInst(0),
                            m_fInitialized(false), m_fUserCancel(false),
                            m_ulProgressMax(0), m_ulProgressSoFar(0)
{
    lstrcpy(m_szCaption, "");
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::~CDownloadUI destructor
//

CDownloadUI::~CDownloadUI()
{
}

/////////////////////////////////////////////////////////////////////////////
// ProgressProc - callback routine for IDD_PROGRESS dialog
//

BOOL CALLBACK ProgressProc(HWND hDlg, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    if (uiMsg == WM_INITDIALOG)
    {
        return TRUE;
    }
    else if (uiMsg == WM_COMMAND && wParam == IDCANCEL)
    {
        ((CDownloadUI*)lParam)->SetUserCancel();
        return TRUE;
    }
    else if (uiMsg == WM_SETCURSOR)
    {
        // always display WAIT cursor if mouse not over Cancel button
        if ( (HWND)wParam != WIN::GetDlgItem(hDlg, IDC_DOWNLOAD_CANCEL))
        {
            WIN::SetCursor(WIN::LoadCursor(0, MAKEINTRESOURCE(IDC_WAIT)));
            return TRUE;
        }
    }
    else if (uiMsg == WM_CLOSE)
    {

    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// GetScreenCenterCoord
//

bool GetScreenCenterCoord(HWND hDlg, int& iDialogLeft, int& iDialogTop, int& iDialogWidth, int& iDialogHeight)
{
    RECT rcDialog;
    if (!WIN::GetWindowRect(hDlg, &rcDialog))
        return false;

    RECT rcScreen;
    if (!WIN::SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, 0))
    {
        rcScreen.left = 0;
        rcScreen.top = 0;
        rcScreen.right = WIN::GetSystemMetrics(SM_CXSCREEN);
        rcScreen.bottom = WIN::GetSystemMetrics(SM_CYSCREEN);
    }
    iDialogWidth = rcDialog.right - rcDialog.left;
    iDialogHeight = rcDialog.bottom - rcDialog.top;
    iDialogLeft = rcScreen.left + (rcScreen.right - rcScreen.left - iDialogWidth)/2;
    iDialogTop = rcScreen.top + (rcScreen.bottom - rcScreen.top - iDialogHeight)/2;

    return true;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::Initialize
//

bool CDownloadUI::Initialize(HINSTANCE hInst, HWND hwndParent, LPCSTR szCaption)
{
    INITCOMMONCONTROLSEX iccData = {sizeof(INITCOMMONCONTROLSEX), ICC_PROGRESS_CLASS};
    COMCTL32::InitCommonControlsEx(&iccData);

    char szText[MAX_STR_CAPTION] = {0};

    // set member variables
    m_hwndParent = hwndParent;
    m_hInst = hInst;

    if (MAX_STR_CAPTION < lstrlen(szCaption))
    {
        lstrcpyn(m_szCaption, szCaption, MAX_STR_CAPTION);
    }
    else
    {
        lstrcpy(m_szCaption, szCaption);
    }

    if (!m_hwndProgress)
    {
        // create Progress Dialog
        m_hwndProgress = WIN::CreateDialogParam(m_hInst, MAKEINTRESOURCE(IDD_PROGRESS), m_hwndParent, (DLGPROC)ProgressProc, (LPARAM)this);
        if (!m_hwndProgress)
            return false;

        // set window caption
        WIN::SetWindowText(m_hwndProgress, m_szCaption);

        // center dialog on screen
        int iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight;
        ::GetScreenCenterCoord(m_hwndProgress, iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight);
        WIN::MoveWindow(m_hwndProgress, iDialogLeft, iDialogTop, iDialogWidth, iDialogHeight, TRUE);

        // set CANCEL button text
        WIN::LoadString(m_hInst, IDS_CANCEL, szText, MAX_STR_CAPTION);
        WIN::SetDlgItemText(m_hwndProgress, IDC_DOWNLOAD_CANCEL, szText);

        // set to foreground and make visible all controls
        WIN::SetFocus(WIN::GetDlgItem(m_hwndProgress, IDC_DOWNLOAD_PROGRESSBAR));
        WIN::ShowWindow(WIN::GetDlgItem(m_hwndProgress, IDC_DOWNLOAD_CANCEL), SW_SHOW);
        WIN::SetForegroundWindow(m_hwndProgress);
        WIN::ShowWindow(WIN::GetDlgItem(m_hwndProgress, IDC_DOWNLOAD_PROGRESSBAR), SW_SHOW);

        // set icon
        HICON hIcon = (HICON) WIN::LoadIcon(m_hInst, MAKEINTRESOURCE(IDI_INSTALLER));
        if (hIcon)
            WIN::SendMessage(m_hwndProgress, WM_SETICON, ICON_BIG, (LPARAM)hIcon);

        // make window visible
        WIN::ShowWindow(m_hwndProgress, SW_SHOW);
    }

    // message pump
    MSG msg;
    while (WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
    {
        if (!WIN::IsDialogMessage(m_hwndProgress, &msg))
        {
            WIN::TranslateMessage(&msg);
            WIN::DispatchMessage(&msg);
        }
    }

    m_fInitialized = true;

    return true;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::Terminate
//

bool CDownloadUI::Terminate()
{
    if (m_hwndProgress)
    {
        // destroy the progress window
        WIN::DestroyWindow(m_hwndProgress);
        m_hwndProgress = 0;
    }

    m_hInst                 = 0;
    m_hwndParent            = 0;
    m_fInitialized          = false;
    m_fUserCancel           = false;
    m_ulProgressMax         = 0;
    m_ulProgressSoFar       = 0;

    return true;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::GetCurrentWindow
//

HWND CDownloadUI::GetCurrentWindow()
{
    return (m_hwndProgress) ? m_hwndProgress : m_hwndParent;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::SetUserCancel
//

void CDownloadUI::SetUserCancel()
{
    m_fUserCancel = true;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::HasUserCanceled
//

bool CDownloadUI::HasUserCanceled()
{
    return (m_fUserCancel);
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::SetBannerText
//

irmProgress CDownloadUI::SetBannerText(LPCSTR szBanner)
{
    if (!m_fInitialized)
        return irmNotInitialized;

    if (m_fUserCancel)
        return irmCancel;

    WIN::SetDlgItemText(m_hwndProgress, IDC_DOWNLOAD_BANNER, szBanner);

    return irmOK;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::SetActionText
//

irmProgress CDownloadUI::SetActionText(LPCSTR szAction)
{
    if (!m_fInitialized)
        return irmNotInitialized;

    if (m_fUserCancel)
        return irmCancel;

    WIN::SetDlgItemText(m_hwndProgress, IDC_DOWNLOAD_ACTIONTEXT, szAction);

    return irmOK;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::InitProgressBar
//

void CDownloadUI::InitProgressBar(ULONG ulProgressMax)
{
    // init progress bar values
    m_ulProgressMax         = ulProgressMax;
    m_ulProgressSoFar       = 0;

    // set range on progress bar of [0, ulProgressMax]
    HWND hwndProgBar = WIN::GetDlgItem(m_hwndProgress, IDC_DOWNLOAD_PROGRESSBAR);
    WIN::SendMessage(hwndProgBar, PBM_SETRANGE, /* WPARAM = */ 0, /* LPARAM = */ MAKELPARAM( 0, m_ulProgressMax));

    // initialize the position of the progress bar -- forward direction, so set at 0
    WIN::SendMessage(hwndProgBar, PBM_SETPOS, /* WPARAM = */ (WPARAM)0, /* LPARAM = */ 0);

    // message pump
    MSG msg;
    while (WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
    {
        if (!WIN::IsDialogMessage(m_hwndProgress, &msg))
        {
            WIN::TranslateMessage(&msg);
            WIN::DispatchMessage(&msg);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadUI::IncrementProgressBar
//

void CDownloadUI::IncrementProgressBar(ULONG ulProgress)
{
    // increment progress bar

    HWND hwndProgBar = WIN::GetDlgItem(m_hwndProgress, IDC_DOWNLOAD_PROGRESSBAR);
    WIN::SendMessage(hwndProgBar, PBM_DELTAPOS, /* WPARAM = */ (WPARAM) (ulProgress), /* LPARAM = */ 0);

    m_ulProgressSoFar += ulProgress;

    // message pump
    MSG msg;
    while (WIN::PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
    {
        if (!WIN::IsDialogMessage(m_hwndProgress, &msg))
        {
            WIN::TranslateMessage(&msg);
            WIN::DispatchMessage(&msg);
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadBindStatusCallback::CDownloadBindStatusCallback constructor
//

CDownloadBindStatusCallback::CDownloadBindStatusCallback(CDownloadUI* pDownloadUI) : m_pDownloadUI(pDownloadUI), m_iRefCnt(1), m_ulProgressSoFar(0)
{
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadBindStatusCallback::~CDownloadBindStatusCallback destructor
//

CDownloadBindStatusCallback::~CDownloadBindStatusCallback()
{
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadBindStatusCallback::QueryInterface
//

HRESULT CDownloadBindStatusCallback::QueryInterface(const IID& riid, void** ppvObj)
{
    if (riid == IID_IUnknown || riid == IID_IDownloadBindStatusCallback)
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    *ppvObj = 0;
    return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadBindStatusCallback::AddRef
//

unsigned long CDownloadBindStatusCallback::AddRef()
{
    return ++m_iRefCnt;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadBindStatusCallback::Release
//

unsigned long CDownloadBindStatusCallback::Release()
{
    if (--m_iRefCnt != 0)
        return m_iRefCnt;
    delete this;
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CDownloadBindStatusCallback::OnProgress
//

HRESULT CDownloadBindStatusCallback::OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR /*szStatusText*/)
{
    switch (ulStatusCode)
    {
    case BINDSTATUS_BEGINDOWNLOADDATA:
        {
            // initialize progress bar with max # of ticks
            m_pDownloadUI->InitProgressBar(ulProgressMax);

            // init progress so far
            m_ulProgressSoFar = 0;

            // check for cancel
            if (m_pDownloadUI->HasUserCanceled())
                return E_ABORT;

            // fall through
        }
    case BINDSTATUS_DOWNLOADINGDATA:
        {
            // calculate how far we have moved since the last time
            ULONG ulProgIncrement = ulProgress - m_ulProgressSoFar;

            // set progress so far to current value
            m_ulProgressSoFar = ulProgress;

            // send progress message (if we have progressed)
            if (ulProgIncrement > 0)
                m_pDownloadUI->IncrementProgressBar(ulProgIncrement);

            // check for cancel
            if(m_pDownloadUI->HasUserCanceled())
                return E_ABORT;

            break;
        }
    case BINDSTATUS_ENDDOWNLOADDATA:
        {
            // send any remaining progress to complete download portion of progress bar
            ULONG ulProgIncrement = ulProgressMax - m_ulProgressSoFar;
            if (ulProgIncrement > 0)
                m_pDownloadUI->IncrementProgressBar(ulProgIncrement);
            
            // check for cancel
            if(m_pDownloadUI->HasUserCanceled())
                return E_ABORT;

            break;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\setup.exe\setupui.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       setupui.h
//
//--------------------------------------------------------------------------

#ifndef _SETUPUI_H_3E24CC91_BC41_4182_BEBA_785BBB28B677_
#define _SETUPUI_H_3E24CC91_BC41_4182_BEBA_785BBB28B677_

#include <windows.h>
#include <urlmon.h>

/*---------------------------------------------------------------------------
 *
 * Constants
 *
 ---------------------------------------------------------------------------*/
#define MAX_STR_CAPTION 256

/*---------------------------------------------------------------------------
 *
 * Enums
 *
 ---------------------------------------------------------------------------*/
enum irmProgress // progress dialog return messages
{
    irmNotInitialized = -1, // dialog was not initialized
    irmOK             =  0, // ok
    irmCancel         =  1, // user depressed cancel button
};

/*---------------------------------------------------------------------------
 *
 * CDownloadUI class
 *
 ---------------------------------------------------------------------------*/
class CDownloadUI
{
public:
     CDownloadUI();
     ~CDownloadUI();

    bool Initialize(HINSTANCE hInst, HWND hwndParent, LPCSTR szCaption);
    bool Terminate();
    HWND GetCurrentWindow();
    bool HasUserCanceled();
    void SetUserCancel();
    void InitProgressBar(ULONG ulProgressMax);
    void IncrementProgressBar(ULONG ulProgress);

    irmProgress SetBannerText(LPCSTR szBanner);
    irmProgress SetActionText(LPCSTR szAction);

private:
    HINSTANCE m_hInst;  // handle to instance containing resources

    HWND  m_hwndProgress;    // handle to progress dialog
    HWND  m_hwndParent;      // handle to parent window
    char  m_szCaption[MAX_STR_CAPTION]; // caption
    bool  m_fInitialized;    // whether dialog has been initialized
    bool  m_fUserCancel;     // whether user has chosen to cancel
    ULONG m_ulProgressMax;   // maximum number of ticks on progress bar
    ULONG m_ulProgressSoFar; // current progress
};

/*---------------------------------------------------------------------------
 *
 * CDownloadBindStatusCallback class
 *
 ---------------------------------------------------------------------------*/

class CDownloadBindStatusCallback : public IBindStatusCallback
{
 public: // IUnknown implemented virtual functions
     HRESULT         __stdcall QueryInterface(const IID& riid, void** ppvObj);
     unsigned long   __stdcall AddRef();
     unsigned long   __stdcall Release();
 public: // IBindStatusCallback implemented virtual functions
     CDownloadBindStatusCallback(CDownloadUI* piDownloadUI);
    ~CDownloadBindStatusCallback();

    HRESULT __stdcall OnStartBinding(DWORD, IBinding*) {return S_OK;}
    HRESULT __stdcall GetPriority(LONG*) {return S_OK;}
    HRESULT __stdcall OnLowResource(DWORD ) {return S_OK;}
    HRESULT __stdcall OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText);
    HRESULT __stdcall OnStopBinding(HRESULT, LPCWSTR ) {return S_OK;}
    HRESULT __stdcall GetBindInfo(DWORD*, BINDINFO*) {return S_OK;}
    HRESULT __stdcall OnDataAvailable(DWORD, DWORD, FORMATETC*, STGMEDIUM*) {return S_OK;}
    HRESULT __stdcall OnObjectAvailable(REFIID, IUnknown*) {return S_OK;}
 private:
    CDownloadUI* m_pDownloadUI; // pointer to actual UI
    int          m_iRefCnt;
    ULONG        m_ulProgressSoFar;
};

#endif //_SETUPUI_H_3E24CC91_BC41_4182_BEBA_785BBB28B677_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\setup.exe\setup.h ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       setup.h
//
//--------------------------------------------------------------------------

#ifndef __SETUP_H_58FA8147_50A0_4FDC_BD83_17C3A2525E0A_
#define __SETUP_H_58FA8147_50A0_4FDC_BD83_17C3A2525E0A_

#include "setupui.h"

#include <windows.h>
#include <wincrypt.h>

/*--------------------------------------------------------------------------
 *
 * Constants
 *
 --------------------------------------------------------------------------*/
#define MAX_STR_LENGTH 1024
#define MINIMUM_SUPPORTED_MSI_VERSION 150
#define MAX_LENGTH_GUID 40

const char szUrlPathSep[] = "/";
const char szPathSep[] = "\\";

const char szDefaultOperation[] = "DEFAULT";
const char szInstallOperation[] = "INSTALL";
const char szMinPatchOperation[] = "MINPATCH";
const char szMajPatchOperation[] = "MAJPATCH";
const char szInstallUpdOperation[] = "INSTALLUPD";

const char szDefaultMinPatchCommandLine[] = "REINSTALL=ALL REINSTALLMODE=omus";
const char szDefaultInstallUpdCommandLine[] = "REINSTALL=ALL REINSTALLMODE=vomus";
const char szAdminInstallProperty[] = " ACTION=ADMIN";

const char sqlProductCode[] = "SELECT `Value` FROM `Property` WHERE `Property`='ProductCode'";

/*--------------------------------------------------------------------------
 *
 * Enums
 *
 --------------------------------------------------------------------------*/
enum itvEnum
{
    itvWintrustNotOnMachine = 0,
    itvTrusted = 1,
    itvUnTrusted = 2
};

// Execution modes.
enum emEnum
{
    emPreset = 0,
    emHelp = 1,
    emVerify = 2,
    emAdminInstall = 3
};

/*--------------------------------------------------------------------------
 *
 * Prototypes
 *
 --------------------------------------------------------------------------*/

DWORD VerifyFileSignature (LPCSTR lpszModule, LPSTR lpszCmdLine);
emEnum GetExecutionMode (LPCSTR lpszCmdLine);
DWORD GetNextArgument (LPCSTR pszCmdLine, LPCSTR *ppszArgStart, LPCSTR *ppszArgEnd, bool * pfQuoted);
DWORD GetAdminInstallInfo (bool fPatch, LPSTR lpszCmdLine, LPCSTR * ppszAdminImagePath);
bool AlreadyInProgress();
void DisplayUsage (HINSTANCE hInst, HWND hwndOwner, LPCSTR szCaption);
DWORD GetFileVersionNumber(LPSTR szFilename, DWORD *pdwMSVer, DWORD *pdwLSVer);
bool IsOSWin9X(int *piMajVer);
bool IsAdmin(bool fWin9X, int iMajorVersion);
bool AcquireShutdownPrivilege();

/////////////////////////////////////////////////////////////////////////////
//
// WinVerifyTrust functions
//
/////////////////////////////////////////////////////////////////////////////
itvEnum IsPackageTrusted(LPCSTR szSetupEXE, LPCSTR szPackage, HWND hwndParent);
itvEnum IsFileTrusted(LPCWSTR szwFile, HWND hwndParent, DWORD dwUIChoice, bool *pfIsSigned, PCCERT_CONTEXT *ppcSigner);

/////////////////////////////////////////////////////////////////////////////
//
// InstMsi upgrade functions
//
/////////////////////////////////////////////////////////////////////////////
bool IsMsiUpgradeNecessary(ULONG ulReqMsiMinVer);
DWORD ExecuteUpgradeMsi(LPSTR szUpgradeMsi);
DWORD ExecuteVerifyInstMsi(LPCSTR szModuleFile, LPCSTR szInstMsiCachePath);
DWORD WaitForProcess(HANDLE handle);
bool IsInstMsiRequiredVersion(LPSTR szFilename, ULONG ulMinVer);
UINT UpgradeMsi(HINSTANCE hInst, CDownloadUI *piDownloadUI, LPCSTR szAppTitle, LPCSTR szInstLocation, LPCSTR szInstMsi, ULONG ulMinVer);
UINT DownloadAndUpgradeMsi(HINSTANCE hInst, CDownloadUI *piDownloadUI, LPCSTR szAppTitle, LPCSTR szBaseInstMsi, LPCSTR szInstMsi, LPCSTR szModuleFile, ULONG ulMinVer);
UINT ValidateInstmsi(HINSTANCE hInst, CDownloadUI *piDownloadUI, LPCSTR szAppTitle, LPSTR szInstMsiPath, LPCSTR szModuleFile, ULONG ulMinVer);

/////////////////////////////////////////////////////////////////////////////
//
// Error handling functions
//
/////////////////////////////////////////////////////////////////////////////
void ReportErrorOutOfMemory(HINSTANCE hInst, HWND hwndOwner, LPCSTR szCaption);
void PostResourceNotFoundError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, LPCSTR szName);
void ReportUserCancelled(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle);
void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId);
void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, int iValue);
void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, LPCSTR szValue);
void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, LPCSTR szValue, int iValue);
void PostMsiError(HINSTANCE hInst, HINSTANCE hMsi, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId);
void PostFormattedError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, LPCSTR szValue);

/////////////////////////////////////////////////////////////////////////////
//
// Msi DLL registration location -- HKLM
//
//  HKLM\Software\Microsoft\Windows\CurrentVersion\Installer
//      InstallerLocation : REG_SZ
//
/////////////////////////////////////////////////////////////////////////////
const char szInstallerKey[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Installer";
const char szInstallerLocationValueName[] = "InstallerLocation";
const char szMsiDll[] = "\\msi.dll";

/////////////////////////////////////////////////////////////////////////////
//
// InstMsi command line options
//
//
/////////////////////////////////////////////////////////////////////////////
const char szDelayReboot[] = " /c:\"msiinst /delayreboot\"";
const char szDelayRebootQuiet[] = " /c:\"msiinst /delayrebootq\"";


/////////////////////////////////////////////////////////////////////////////
//
// Debugging Functions
//
//
/////////////////////////////////////////////////////////////////////////////
void DebugMsg(LPCSTR szFormat, ...);
const char szDebugEnvVar[] = "_MSI_WEB_BOOTSTRAP_DEBUG";


#endif //__SETUP_H_58FA8147_50A0_4FDC_BD83_17C3A2525E0A_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\setup.exe\vertrust.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       vertrust.cpp
//
//--------------------------------------------------------------------------

#define WIN // scope W32 API
#define MSI // scope MSI API

#include <windows.h>
#include <tchar.h>

#include "setup.h" // for itvEnum
#include "common.h"

// package trust
#include "wintrust.h"
#include "softpub.h"

//--------------------------------------------------------------------------------------
// CRYPTO API -- delay load
//--------------------------------------------------------------------------------------

#define CRYPT32_DLL "crypt32.dll"

#define CRYPTOAPI_CertDuplicateCertificateContext "CertDuplicateCertificateContext"
typedef PCCERT_CONTEXT (WINAPI* PFnCertDuplicateCertificateContext)(PCCERT_CONTEXT pCertContext);

#define CRYPTOAPI_CertCompareCertificate "CertCompareCertificate"
typedef BOOL (WINAPI* PFnCertCompareCertificate)(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2);

#define CRYPTOAPI_CertFreeCertificateContext "CertFreeCertificateContext"
typedef BOOL (WINAPI* PFnCertFreeCertificateContext)(PCCERT_CONTEXT pCertContext);

//--------------------------------------------------------------------------------------
// WINTRUST API -- delay load
//--------------------------------------------------------------------------------------

#define WINTRUST_DLL "wintrust.dll"

#define WINTRUSTAPI_WinVerifyTrust "WinVerifyTrust"
typedef HRESULT (WINAPI *PFnWinVerifyTrust)(HWND hwnd, GUID *pgActionID, WINTRUST_DATA *pWinTrustData);

#define WINTRUSTAPI_WTHelperProvDataFromStateData "WTHelperProvDataFromStateData"
typedef PCRYPT_PROVIDER_DATA (WINAPI *PFnWTHelperProvDataFromStateData)(HANDLE hStateData);

#define WINTRUSTAPI_WTHelperGetProvSignerFromChain "WTHelperGetProvSignerFromChain"
typedef PCRYPT_PROVIDER_SGNR (WINAPI *PFnWTHelperGetProvSignerFromChain)(PCRYPT_PROVIDER_DATA pProvData, DWORD idxSigner, BOOL fCounterSigner, DWORD idxCounterSigner);

#define WINTRUSTAPI_WTHelperGetProvCertFromChain "WTHelperGetProvCertFromChain"
typedef PCRYPT_PROVIDER_CERT (WINAPI* PFnWTHelperGetProvCertFromChain)(PCRYPT_PROVIDER_SGNR pSgnr, DWORD idxCert);

//--------------------------------------------------------------------------------------
// download provider
//--------------------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// IsFileTrusted
//
itvEnum IsFileTrusted(LPCWSTR lpwFile, HWND hwndParent, DWORD dwUIChoice, bool *pfIsSigned, PCCERT_CONTEXT *ppcSigner)
{
    char szDebugOutput[MAX_STR_LENGTH] = {0};

    itvEnum itv = itvUnTrusted;

    if (pfIsSigned)
        *pfIsSigned = false;
    if (ppcSigner)
        *ppcSigner  = 0;

    GUID guidAction = WINTRUST_ACTION_GENERIC_VERIFY_V2;

    WINTRUST_FILE_INFO sWintrustFileInfo;
    WINTRUST_DATA      sWintrustData;
    HRESULT            hr;

    memset((void*)&sWintrustFileInfo, 0x00, sizeof(WINTRUST_FILE_INFO)); // zero out
    memset((void*)&sWintrustData, 0x00, sizeof(WINTRUST_DATA)); // zero out

    sWintrustFileInfo.cbStruct = sizeof(WINTRUST_FILE_INFO);
    sWintrustFileInfo.pcwszFilePath = lpwFile;
    sWintrustFileInfo.hFile = NULL;

    sWintrustData.cbStruct            = sizeof(WINTRUST_DATA);
    sWintrustData.dwUIChoice          = dwUIChoice;
    sWintrustData.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
    sWintrustData.dwUnionChoice       = WTD_CHOICE_FILE;
    sWintrustData.pFile               = &sWintrustFileInfo;
    sWintrustData.dwStateAction       = (ppcSigner) ? WTD_STATEACTION_VERIFY : 0;

    HMODULE hWinTrust = LoadLibrary(WINTRUST_DLL);
    if (!hWinTrust)
    {
        // WinTrust is unavailable on the machine
        return itvWintrustNotOnMachine;
    }
    PFnWinVerifyTrust pfnWinVerifyTrust = (PFnWinVerifyTrust)GetProcAddress(hWinTrust, WINTRUSTAPI_WinVerifyTrust);
    PFnWTHelperProvDataFromStateData pfnWTHelperProvDataFromStateData= (PFnWTHelperProvDataFromStateData)GetProcAddress(hWinTrust, WINTRUSTAPI_WTHelperProvDataFromStateData);
    PFnWTHelperGetProvSignerFromChain pfnWTHelperGetProvSignerFromChain = (PFnWTHelperGetProvSignerFromChain)GetProcAddress(hWinTrust, WINTRUSTAPI_WTHelperGetProvSignerFromChain);
    PFnWTHelperGetProvCertFromChain pfnWTHelperGetProvCertFromChain = (PFnWTHelperGetProvCertFromChain)GetProcAddress(hWinTrust, WINTRUSTAPI_WTHelperGetProvCertFromChain);
    if (!pfnWinVerifyTrust || !pfnWTHelperProvDataFromStateData || !pfnWTHelperGetProvSignerFromChain || !pfnWTHelperGetProvCertFromChain)
    {
        // WinTrust is unavailable on the machine
        FreeLibrary(hWinTrust);
        return itvWintrustNotOnMachine;
    }

    hr = pfnWinVerifyTrust(/* UI Window Handle */ (dwUIChoice == WTD_UI_NONE) ? (HWND)INVALID_HANDLE_VALUE : hwndParent, &guidAction, &sWintrustData);
    DebugMsg("[WVT] WVT returned 0x%X\n", hr);

    itv = (TRUST_E_PROVIDER_UNKNOWN == hr) ? itvWintrustNotOnMachine : ((S_OK == hr) ? itvTrusted : itvUnTrusted); 

    if (itvWintrustNotOnMachine == itv)
    {
        FreeLibrary(hWinTrust);
        return itv; // return immediately
    }

    if (pfIsSigned)
        *pfIsSigned = (TRUST_E_NOSIGNATURE == hr) ? false : true;

    if (TRUST_E_NOSIGNATURE == hr)
    {
        FreeLibrary(hWinTrust);
        return itv;
    }

    if (ppcSigner)
    {
        CRYPT_PROVIDER_DATA const *psProvData     = NULL;
        CRYPT_PROVIDER_SGNR       *psProvSigner   = NULL;
        CRYPT_PROVIDER_CERT       *psProvCert     = NULL;

        // grab the provider data
        psProvData = pfnWTHelperProvDataFromStateData(sWintrustData.hWVTStateData);
        if (psProvData)
        {
            // grab the signer data from the CRYPT_PROV_DATA
            psProvSigner = pfnWTHelperGetProvSignerFromChain((PCRYPT_PROVIDER_DATA)psProvData, 0 /*first signer*/, FALSE /* not a counter signer */, 0);
            if (psProvSigner)
            {
                // grab the signer cert from CRYPT_PROV_SGNR (pos 0 = signer cert; pos csCertChain-1 = root cert)
                psProvCert = pfnWTHelperGetProvCertFromChain(psProvSigner, 0);
            }
        }
    
        if (!psProvCert)
        {
            // some failure in obtaining the signer cert data
            *ppcSigner = 0;
        }
        else
        {
            // duplicate the cert
            HMODULE hCrypt32 = LoadLibrary(CRYPT32_DLL);
            if (hCrypt32)
            {
                PFnCertDuplicateCertificateContext pfnCertDuplicateCertificateContext = (PFnCertDuplicateCertificateContext)GetProcAddress(hCrypt32, CRYPTOAPI_CertDuplicateCertificateContext);
                if (pfnCertDuplicateCertificateContext)
                    *ppcSigner = pfnCertDuplicateCertificateContext(psProvCert->pCert);
                FreeLibrary(hCrypt32);
            }
        }

        // release state data
        sWintrustData.dwUIChoice = WTD_UI_NONE;
        sWintrustData.dwStateAction = WTD_STATEACTION_CLOSE;
        pfnWinVerifyTrust((HWND)INVALID_HANDLE_VALUE, &guidAction, &sWintrustData);
    }

    FreeLibrary(hWinTrust);
    return itv;
}

/////////////////////////////////////////////////////////////////////////////
// IsPackageTrusted
//

itvEnum IsPackageTrusted(LPCSTR szSetupExe, LPCSTR szPackage, HWND hwndParent)
{
    WCHAR *szwSetup   = 0;
    WCHAR *szwPackage = 0;
    int   cchWide     = 0;

    bool    fPackageIsTrusted = false;
    bool    fSetupExeIsSigned = false;
    bool    fPackageIsSigned  = false;
    itvEnum itv               = itvUnTrusted;

    DWORD dwUILevel = 0;

    char szDebugOutput[MAX_STR_LENGTH] = {0};

    PCCERT_CONTEXT pcExeSigner = 0;
    PCCERT_CONTEXT pcMsiSigner = 0;

    HMODULE hCrypt32 = LoadLibrary(CRYPT32_DLL);
    if (!hCrypt32)
    {
        // no crypto on the machine
        return itvWintrustNotOnMachine;
    }
    PFnCertCompareCertificate pfnCertCompareCertificate = (PFnCertCompareCertificate)GetProcAddress(hCrypt32, CRYPTOAPI_CertCompareCertificate);
    PFnCertFreeCertificateContext pfnCertFreeCertificateContext = (PFnCertFreeCertificateContext)GetProcAddress(hCrypt32, CRYPTOAPI_CertFreeCertificateContext);
    if (!pfnCertCompareCertificate || !pfnCertFreeCertificateContext)
    {
        // no crypt on the machine
        return itvWintrustNotOnMachine;
    }

    // convert szSetupExe to WIDE
    cchWide = MultiByteToWideChar(CP_ACP, 0, szSetupExe, -1, 0, 0);
    szwSetup = new WCHAR[cchWide];
    if (!szwSetup)
    {
        // out of memory
        return itvUnTrusted;
    }
    MultiByteToWideChar(CP_ACP, 0, szSetupExe, -1, szwSetup, cchWide);

    //
    // step 1: silently call WinVerifyTrust on szSetupExe, ignore return value - except for ivtWintrustNotOnMachine
    //

    DebugMsg("[WVT] step 1: silently call WinVerifyTrust on szSetupExe, ignoring return value\n");

    if (itvWintrustNotOnMachine == (itv = IsFileTrusted(szwSetup, hwndParent, WTD_UI_NONE, &fSetupExeIsSigned, &pcExeSigner)))
    {
        goto CleanUp;
    }

    DebugMsg("[WVT] fSetupExeIsSigned = %s\n", fSetupExeIsSigned ? "TRUE" : "FALSE");

    // convert szPackage to WIDE
    cchWide = MultiByteToWideChar(CP_ACP, 0, szPackage, -1, 0, 0);
    szwPackage = new WCHAR[cchWide];
    if (!szwPackage)
    {
        // out of memory
        return itvUnTrusted;
    }
    MultiByteToWideChar(CP_ACP, 0, szPackage, -1, szwPackage, cchWide);

    //
    // step 2: silently call WinVerifyTrust on szPackage, ignore return value - except for ivtWintrustNotOnMachine
    //

    if (fSetupExeIsSigned)
    {
        DebugMsg("[WVT] step2: silently call WinVerifyTrust on szPackage, ignoring return value\n");
        if (itvWintrustNotOnMachine == (itv = IsFileTrusted(szwPackage, hwndParent, WTD_UI_NONE, &fPackageIsSigned, &pcMsiSigner)))
        {
            goto CleanUp;
        }

        DebugMsg("[WVT] fPackageIsSigned = %s\n", fPackageIsSigned ? "TRUE" : "FALSE");
    }

    //
    // step 3: call WinVerifyTrust on szPackage, return value matters; use proper UI-level
    //

    if ( !fSetupExeIsSigned  // exe is not signed
        || !fPackageIsSigned // package is not signed
        || !pcExeSigner      // exe signer cert is missing
        || !pcMsiSigner      // package signer cert is missing
        || !pfnCertCompareCertificate(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, pcExeSigner->pCertInfo, pcMsiSigner->pCertInfo)) // signed by different certs
    {
        // always show UI
        DebugMsg("[WVT] step3: last call to WinVerifyTrust using full UI\n");
        dwUILevel = WTD_UI_ALL;
    }
    else
    {
        // show UI only if bad
        DebugMsg("[WVT] step3: last call to WinVerifyTrust showing UI only if something is wrong\n");
        dwUILevel = WTD_UI_NOGOOD;
    }

    itv = IsFileTrusted(szwPackage, hwndParent, dwUILevel, NULL, NULL);

    //
    // cleanup
    //

CleanUp:
    if (szwPackage)
        delete [] szwPackage;
    if (szwSetup)
        delete [] szwSetup;

    if (pcExeSigner)
        pfnCertFreeCertificateContext(pcExeSigner);
    if (pcMsiSigner)
        pfnCertFreeCertificateContext(pcMsiSigner);

    return itv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\setup.exe\utils.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       utils.cpp
//
//--------------------------------------------------------------------------

#include "setup.h"
#include "resource.h"
#include "common.h"

#include "msi.h"

#include <assert.h>
#include <tchar.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>

#define WIN // scope W32 API

/////////////////////////////////////////////////////////////////////////////
// VerifyFileSignature
//
DWORD VerifyFileSignature (LPCSTR lpszModule, LPSTR lpszCmdLine)
{
    LPCSTR  pszFirstArgEnd;
    LPCSTR  pszFileName;
    LPCSTR  pszEnd;
    DWORD   Status;
    
    //
    // When this function is called, the first argument has already
    // been verified. So skip the first argument.
    //
    GetNextArgument (lpszCmdLine, NULL, &pszFirstArgEnd, NULL);
    
    // Now get the name of the file whose signature needs to be verified.
    Status = GetNextArgument (CharNextA(pszFirstArgEnd), &pszFileName, &pszEnd, NULL);
    
    // Must supply a filename
    if (ERROR_NO_MORE_ITEMS == Status)
        return ERROR_BAD_ARGUMENTS;
    
    // Should not have any more arguments
    if ('\0' != *(CharNextA(pszEnd)) &&
        ERROR_NO_MORE_ITEMS != GetNextArgument (CharNextA(CharNextA(pszEnd)), NULL, NULL, NULL))
    {
        return ERROR_BAD_ARGUMENTS;
    }
    
    // We have the right arguments. Null terminate the filename.
    *(CharNextA(pszEnd)) = '\0';
    
    switch (IsPackageTrusted(lpszModule, pszFileName, NULL))
    {
    case itvWintrustNotOnMachine:
        return TRUST_E_PROVIDER_UNKNOWN;
    case itvTrusted:
        return ERROR_SUCCESS;
    case itvUnTrusted:
    default:
        return TRUST_E_SUBJECT_NOT_TRUSTED;
    }
}

/////////////////////////////////////////////////////////////////////////////
// GetExecutionMode
//
emEnum GetExecutionMode (LPCSTR lpszCmdLine)
{
    LPCSTR  pszStart = NULL;
    LPCSTR  pszEnd = NULL;
    DWORD   dwStatus = ERROR_SUCCESS;
    bool    fQuoted = false;
    //
    // Check the first argument and set the execution mode accordingly.
    // When run without arguments, it is assumed that the default install
    // preset by the package publisher needs to be performed.
    //
    // In case an invalid option is provided, the help dialog describing the
    // usage must be displayed.
    //
    dwStatus = GetNextArgument (lpszCmdLine, &pszStart, &pszEnd, &fQuoted);
    
    if (ERROR_NO_MORE_ITEMS == dwStatus)
        return emPreset;
    
    // The only allowed values in the first argument are /a, /v and /?
    if (pszEnd != CharNextA(pszStart) || fQuoted)
        return emHelp;
    
    if ('/' != (*pszStart) && '-' != (*pszStart))
        return emHelp;
    
    switch (*pszEnd)
    {
    case 'a':
    case 'A':
        return emAdminInstall;
    case 'v':
    case 'V':
        return emVerify;
    default:
        return emHelp;
    }
}

/////////////////////////////////////////////////////////////////////////////
// GetNextArgument
//
DWORD GetNextArgument (LPCSTR pszCmdLine, LPCSTR *ppszArgStart, LPCSTR *ppszArgEnd, bool * pfQuoted)
{
    bool    fInQuotes = false;
    bool    fFoundArgEnd = false;
    LPCSTR  pszChar = pszCmdLine;
    LPCSTR  pszFirst = NULL;
    LPCSTR  pszLast = NULL;
    
    if (NULL == pszChar)
        return ERROR_NO_MORE_ITEMS;
    
    // Skip leading spaces.
    while (' ' == *pszChar || '\t' == *pszChar)
        pszChar = CharNextA(pszChar);
    
    // Check if we have run out of arguments.
    if ('\0' == (*pszChar))
        return ERROR_NO_MORE_ITEMS;
    
    // Check if we this argument has been enclosed in quotes
    if ('\"' == (*pszChar))
    {
        fInQuotes = true;
        pszChar = CharNextA (pszChar);
    }
        
    pszFirst = pszChar;
    
    // Now look for the end of the argument
    while (! fFoundArgEnd)
    {
        pszChar = CharNextA(pszChar);
        
        if ('\0' == (*pszChar))
            fFoundArgEnd = true;
        
        if (fInQuotes && '\"' == (*pszChar))
            fFoundArgEnd = true;
        
        if (!fInQuotes && ' ' == (*pszChar))
            fFoundArgEnd = true;
        
        if (!fInQuotes && '\t' == (*pszChar))
            fFoundArgEnd = true;
    }
    
    pszLast = CharPrevA (pszFirst, pszChar);
    
    if (ppszArgStart)
        *ppszArgStart = pszFirst;
    
    if (ppszArgEnd)
        *ppszArgEnd = pszLast;
    
    if (pfQuoted)
        *pfQuoted = fInQuotes;
    
    return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
//
//
DWORD GetAdminInstallInfo (bool fPatch, LPSTR lpszCmdLine, LPCSTR * ppszAdminImagePath)
{
    LPCSTR  pszFirstArgEnd;
    LPCSTR  pszFileName;
    LPCSTR  pszEnd;
    DWORD   Status;
    
    //
    // When this function is called, the first argument has already been
    // verified. So skip the first argument.
    //
    GetNextArgument (lpszCmdLine, NULL, &pszFirstArgEnd, NULL);
    
    // See if there is another argument
    Status = GetNextArgument (CharNextA(pszFirstArgEnd), &pszFileName, &pszEnd, NULL);
    
    // If it is not a patch, there should not be any more arguments.
    if (!fPatch)
    {
        if (ERROR_NO_MORE_ITEMS != Status)
            return ERROR_BAD_ARGUMENTS;
        
        // If we are here, then we are done, because we have all the information we need.
        if (ppszAdminImagePath)
            *ppszAdminImagePath = NULL;
        return ERROR_SUCCESS;
    }
    
    // If we are here, this is a patch. Get the path to the admin. install.
    if (ERROR_NO_MORE_ITEMS == Status)
        return ERROR_BAD_ARGUMENTS;     // No path was supplied.
    
    // Should not have any more arguments.
    if ('\0' != *(CharNextA(pszEnd)) &&
        ERROR_NO_MORE_ITEMS != GetNextArgument (CharNextA(CharNextA(pszEnd)), NULL, NULL, NULL))
    {
        return ERROR_BAD_ARGUMENTS;
    }
    
    // We have the right arguments. Null terminate the pathname.
    *(CharNextA(pszEnd)) = '\0';
    
    if (ppszAdminImagePath)
        *ppszAdminImagePath = pszFileName;
    
    return ERROR_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// LoadResourceString
//
UINT LoadResourceString(HINSTANCE hInst, LPCSTR lpType, LPCSTR lpName, LPSTR lpBuf, DWORD *pdwBufSize)
{
    HRSRC   hRsrc   = 0;
    HGLOBAL hGlobal = 0;
    WCHAR   *pch    = 0;

    if ((hRsrc = WIN::FindResource(hInst, lpName, lpType)) != 0
        && (hGlobal = WIN::LoadResource(hInst, hRsrc)) != 0)
    {
        // resource exists
        if ((pch = (WCHAR*)LockResource(hGlobal)) != 0)
        {
            unsigned int cch = WideCharToMultiByte(CP_ACP, 0, pch, -1, NULL, 0, NULL, NULL);
            if (cch > *pdwBufSize)
            {
                *pdwBufSize = cch;
                return ERROR_MORE_DATA;
            }

            WideCharToMultiByte(CP_ACP, 0, pch, -1, lpBuf, *pdwBufSize, NULL, NULL);
            *pdwBufSize = cch;

        }
        else
        {
            if (1 > *pdwBufSize)
            {
                *pdwBufSize = 1;
                return ERROR_MORE_DATA;
            }

            *pdwBufSize = 1;
            *lpBuf = 0;
        }
        
        DebugMsg("[Resource] lpName = %s, lpBuf = %s\n", lpName, lpBuf);

        return ERROR_SUCCESS;
    }

    // resource does not exist
    DebugMsg("[Resource] lpName = %s NOT FOUND\n", lpName);

    return ERROR_RESOURCE_NAME_NOT_FOUND;
}

/////////////////////////////////////////////////////////////////////////////
// SetupLoadResourceString
//

UINT SetupLoadResourceString(HINSTANCE hInst, LPCSTR lpName, LPSTR *lppBuf, DWORD dwBufSize)
{
    UINT uiStat = 0;
    if (!*lppBuf)
    {
        dwBufSize = (dwBufSize > 0) ? dwBufSize : 256;
        *lppBuf = new char[dwBufSize];
        if (!*lppBuf)
            return ERROR_OUTOFMEMORY;
    }

    if (ERROR_SUCCESS != (uiStat = LoadResourceString(hInst, RT_INSTALL_PROPERTY, lpName, *lppBuf, &dwBufSize)))
    {
        if (uiStat != ERROR_MORE_DATA)
            return uiStat;

        // resize and try again
        delete [] *lppBuf;
        *lppBuf = new char[dwBufSize];
        if (!*lppBuf)
            return ERROR_OUTOFMEMORY;

        uiStat = LoadResourceString(hInst, RT_INSTALL_PROPERTY, lpName, *lppBuf, &dwBufSize);
    }

    return uiStat;
}

/////////////////////////////////////////////////////////////////////////////
// PostResourceNotFoundError
//

void PostResourceNotFoundError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, LPCSTR szName)
{
    char szError[MAX_STR_LENGTH]  = {0};
    char szFormat[MAX_STR_LENGTH] = {0};

    WIN::LoadString(hInst, IDS_MISSING_RESOURCE, szFormat, sizeof(szFormat)/sizeof(char));
    wsprintf(szError, szFormat, szName);
    MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONEXCLAMATION);
}

/////////////////////////////////////////////////////////////////////////////
// ReportUserCancelled
//

void ReportUserCancelled(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle)
{
    char szError[MAX_STR_LENGTH] = {0};

    WIN::LoadString(hInst, IDS_USER_CANCELLED, szError, sizeof(szError)/sizeof(char));
    MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONEXCLAMATION);
}

/////////////////////////////////////////////////////////////////////////////
// PostError
//

void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId)
{
    char szError[MAX_STR_LENGTH]  = {0};

    WIN::LoadString(hInst, uiErrorId, szError, sizeof(szError)/sizeof(char));
    MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONERROR);
}

/////////////////////////////////////////////////////////////////////////////
// PostError
//

void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, LPCSTR szValue)
{
    char szError[MAX_STR_LENGTH]  = {0};
    char szFormat[MAX_STR_LENGTH] = {0};

    WIN::LoadString(hInst, uiErrorId, szFormat, sizeof(szFormat)/sizeof(char));
    wsprintf(szError, szFormat, szValue);
    MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONERROR);
}

/////////////////////////////////////////////////////////////////////////////
// PostError
//

void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, LPCSTR szValue, int iValue)
{
    char szError[MAX_STR_LENGTH]  = {0};
    char szFormat[MAX_STR_LENGTH] = {0};

    WIN::LoadString(hInst, uiErrorId, szFormat, sizeof(szFormat)/sizeof(char));
    wsprintf(szError, szFormat, szValue, iValue);
    MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONERROR);
}

/////////////////////////////////////////////////////////////////////////////
// PostError
//

void PostError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, int iValue)
{
    char szError[MAX_STR_LENGTH]  = {0};
    char szFormat[MAX_STR_LENGTH] = {0};

    WIN::LoadString(hInst, uiErrorId, szFormat, sizeof(szFormat)/sizeof(char));
    wsprintf(szError, szFormat, iValue);
    MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONERROR);
}

/////////////////////////////////////////////////////////////////////////////
// PostFormattedError
//

void PostFormattedError(HINSTANCE hInst, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId, LPCSTR szValue)
{
    char szFormat[MAX_STR_LENGTH] = {0};
    const char* szArgs[1] = {szValue};
    LPVOID lpMessage = 0;;

    WIN::LoadString(hInst, uiErrorId, szFormat, sizeof(szFormat)/sizeof(char));
    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, (LPVOID)szFormat, 0, 0, (LPSTR)&lpMessage, 0, (va_list*)szArgs);
    if (!lpMessage)
    {
        ReportErrorOutOfMemory(hInst, hwndOwner, szTitle);
        return;
    }
    MessageBox(hwndOwner, (LPCSTR)lpMessage, szTitle, MB_OK | MB_ICONERROR);
    LocalFree(lpMessage);
}

/////////////////////////////////////////////////////////////////////////////
// PostMsiError
//

void PostMsiError(HINSTANCE hInst, HINSTANCE hMsi, HWND hwndOwner, LPCSTR szTitle, UINT uiErrorId)
{
    switch (uiErrorId)
    {
    case ERROR_INSTALL_SUSPEND:
    case ERROR_INSTALL_USEREXIT:
    case ERROR_INSTALL_FAILURE:
    case ERROR_SUCCESS_REBOOT_REQUIRED:
    case ERROR_SUCCESS_REBOOT_INITIATED:
    case ERROR_APPHELP_BLOCK:
        break;
    case ERROR_FILE_NOT_FOUND:
    case ERROR_INVALID_NAME:
    case ERROR_PATH_NOT_FOUND:
        uiErrorId = ERROR_INSTALL_PACKAGE_OPEN_FAILED;
    default:
        {
            char szError[MAX_STR_LENGTH] = {0};
            if (0 == WIN::LoadString(hMsi, uiErrorId, szError, sizeof(szError)/sizeof(char)))
            {
                // error string does not exist, use default
                PostError(hInst, hwndOwner, szTitle, IDS_INSTALL_ERROR, uiErrorId);
            }
            else
            {
                MessageBox(hwndOwner, szError, szTitle, MB_OK | MB_ICONERROR);
            }
            return;
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
// AlreadyInProgress
//
//  Attempts to create the MSISETUP mutex. Returns TRUE
//  if mutex already exists
//

bool AlreadyInProgress()
{
    char szUniqueName[] = "_MSISETUP_{2956EBA1-9B5A-4679-8618-357136DA66CA}";

    HANDLE hMutex = 0;
    DWORD  dwErr  = 0;

    hMutex = WIN::CreateMutex(NULL, FALSE, szUniqueName);
    dwErr = GetLastError();
    if (ERROR_ALREADY_EXISTS == dwErr)
        return true;

    return false;
}

/////////////////////////////////////////////////////////////////////////////
// DisplayUsage
//
void DisplayUsage (HINSTANCE hInst, HWND hwndOwner, LPCSTR szCaption)
{
    char szMessage[MAX_STR_LENGTH];

    WIN::LoadString(hInst, IDS_USAGE, szMessage, sizeof(szMessage)/sizeof(char));
    WIN::MessageBox(hwndOwner, szMessage, szCaption, MB_OK | MB_ICONINFORMATION);
}

/////////////////////////////////////////////////////////////////////////////
// ReportErrorOutOfMemory
//

void ReportErrorOutOfMemory(HINSTANCE hInst, HWND hwndOwner, LPCSTR szCaption)
{
    char szError[MAX_STR_LENGTH];

    WIN::LoadString(hInst, IDS_OUTOFMEM, szError, sizeof(szError)/sizeof(char));
    WIN::MessageBox(hwndOwner, szError, szCaption, MB_OK | MB_ICONERROR);
}


/////////////////////////////////////////////////////////////////////////////
// GetFileVersionNumber
//

DWORD GetFileVersionNumber(LPSTR szFilename, DWORD * pdwMSVer, DWORD * pdwLSVer)
{
    DWORD             dwResult = NOERROR;
    unsigned          uiSize;
    DWORD             dwVerInfoSize;
    DWORD             dwHandle;
    BYTE              *prgbVersionInfo = NULL;
    VS_FIXEDFILEINFO  *lpVSFixedFileInfo = NULL;

    DWORD dwMSVer = 0xffffffff;
    DWORD dwLSVer = 0xffffffff;

    dwVerInfoSize = GetFileVersionInfoSize(szFilename, &dwHandle);
    if (0 != dwVerInfoSize)
    {
        prgbVersionInfo = (LPBYTE) WIN::GlobalAlloc(GPTR, dwVerInfoSize);
        if (NULL == prgbVersionInfo)
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto Finish;
        }

        // Read version stamping info
        if (GetFileVersionInfo(szFilename, dwHandle, dwVerInfoSize, prgbVersionInfo))
        {
            // get the value for Translation
            if (VerQueryValue(prgbVersionInfo, "\\", (LPVOID*)&lpVSFixedFileInfo, &uiSize) && (uiSize != 0))
            {
                dwMSVer = lpVSFixedFileInfo->dwFileVersionMS;
                dwLSVer = lpVSFixedFileInfo->dwFileVersionLS;
            }
        }
        else
        {
            dwResult = GetLastError();
            goto Finish;
        }
    }
    else
    {
        dwResult = GetLastError();
    }

#ifdef DEBUG
    char szVersion[255];
    wsprintf(szVersion, "%s is version %d.%d.%d.%d\n", szFilename, HIWORD(dwMSVer), LOWORD(dwMSVer), HIWORD(dwLSVer), LOWORD(dwLSVer));
    DebugMsg("[INFO] %s", szVersion);
#endif // DEBUG

Finish:
    if (NULL != prgbVersionInfo)
        WIN::GlobalFree(prgbVersionInfo);
    if (pdwMSVer)
        *pdwMSVer = dwMSVer;
    if (pdwLSVer)
        *pdwLSVer = dwLSVer;

    return dwResult;
}

/////////////////////////////////////////////////////////////////////////////
// IsOSWin9X
//
//  Returns true if running on a Win9X platform
//  Returns false if running on a WinNT platform
//

bool IsOSWin9X(int *piMajVer)
{
    OSVERSIONINFO sInfoOS;
    memset((void*)&sInfoOS, 0x00, sizeof(OSVERSIONINFO));

    sInfoOS.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    WIN::GetVersionEx(&sInfoOS);

    if (piMajVer)
        *piMajVer = sInfoOS.dwMajorVersion;

    if (VER_PLATFORM_WIN32_NT == sInfoOS.dwPlatformId)
        return false;
    else
        return true;
}

//--------------------------------------------------------------------------------------
// ADVAPI32 API -- delay load
//--------------------------------------------------------------------------------------

#define ADVAPI32_DLL "advapi32.dll"

#define ADVAPI32API_CheckTokenMembership "CheckTokenMembership"
typedef BOOL (WINAPI* PFnCheckTokenMembership)(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);

#define ADVAPI32API_AdjustTokenPrivileges "AdjustTokenPrivileges"
typedef BOOL (WINAPI* PFnAdjustTokenPrivileges)(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength);

#define ADVAPI32API_OpenProcessToken "OpenProcessToken"
typedef BOOL (WINAPI* PFnOpenProcessToken)(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);

#define ADVAPI32API_LookupPrivilegeValue "LookupPrivilegeValueA"
typedef BOOL (WINAPI* PFnLookupPrivilegeValue)(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid);

/////////////////////////////////////////////////////////////////////////////
// IsAdmin
//
//  Returns true if current user is an administrator (or if on Win9X)
//  Returns false if current user is not an adminstrator
//
//  implemented as per KB Q118626
//

bool IsAdmin(bool fWin9X, int iMajorVersion)
{
    if (fWin9X)
    {
        // convention: always admin on Win9X
        return true;
    }

    // get the administrator sid
    PSID psidAdministrators;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    if(!AllocateAndInitializeSid(&siaNtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &psidAdministrators))
        return false;

    // on NT5, use the CheckTokenMembershipAPI to correctly handle cases where
    // the Adiminstrators group might be disabled. bIsAdmin is BOOL for 
    BOOL bIsAdmin = FALSE;
    if (iMajorVersion >= 5) 
    {
        // CheckTokenMembership checks if the SID is enabled in the token. NULL for
        // the token means the token of the current thread. Disabled groups, restricted
        // SIDS, and SE_GROUP_USE_FOR_DENY_ONLY are all considered. If the function
        // returns false, ignore the result.

        HMODULE hAdvapi32 = LoadLibrary(ADVAPI32_DLL);
        if (!hAdvapi32)
            bIsAdmin = FALSE;
        else
        {
            PFnCheckTokenMembership pfnCheckTokenMembership = (PFnCheckTokenMembership)GetProcAddress(hAdvapi32, ADVAPI32API_CheckTokenMembership);
            if (!pfnCheckTokenMembership || !pfnCheckTokenMembership(NULL, psidAdministrators, &bIsAdmin))
                bIsAdmin = FALSE;
        }
    }
    else
    {
        // NT4, check groups of user
        HANDLE hAccessToken = 0;
        UCHAR *szInfoBuffer = new UCHAR[1024]; // may need to resize if TokenInfo too big
        DWORD dwInfoBufferSize = 1024;
        DWORD dwRetInfoBufferSize = 0;
        UINT x=0;

        if (szInfoBuffer && WIN::OpenProcessToken(WIN::GetCurrentProcess(), TOKEN_READ, &hAccessToken))
        {
            bool bSuccess = false;
            bSuccess = WIN::GetTokenInformation(hAccessToken, TokenGroups, szInfoBuffer, dwInfoBufferSize, &dwRetInfoBufferSize) == TRUE;

            if(dwRetInfoBufferSize > dwInfoBufferSize)
            {
                delete [] szInfoBuffer;
                szInfoBuffer = new UCHAR[dwRetInfoBufferSize];
                if (szInfoBuffer)
                {
                    dwInfoBufferSize = dwRetInfoBufferSize;
                    bSuccess = WIN::GetTokenInformation(hAccessToken, TokenGroups, szInfoBuffer, dwInfoBufferSize, &dwRetInfoBufferSize) == TRUE;
                }
            }

            WIN::CloseHandle(hAccessToken);
            
            if (bSuccess)
            {
                PTOKEN_GROUPS ptgGroups = (PTOKEN_GROUPS)(UCHAR*)szInfoBuffer;
                for(x=0;x<ptgGroups->GroupCount;x++)
                {
                    if( WIN::EqualSid(psidAdministrators, ptgGroups->Groups[x].Sid) )
                    {
                        bIsAdmin = TRUE;
                        break;
                    }

                }
            }
        }
    }
    
    WIN::FreeSid(psidAdministrators);
    return bIsAdmin ? true : false;

}

/////////////////////////////////////////////////////////////////////////////
// AcquireShutdownPrivilege
//
//  Attempts to enable the SE_SHUTDOWN_NAME privilege in the process token
//
bool AcquireShutdownPrivilege()
{
    HANDLE hToken = 0;
    TOKEN_PRIVILEGES tkp;

    HMODULE hAdvapi32 = LoadLibrary(ADVAPI32_DLL);
    if (!hAdvapi32)
        return false;

    PFnOpenProcessToken pfnOpenProcessToken = (PFnOpenProcessToken)GetProcAddress(hAdvapi32, ADVAPI32API_OpenProcessToken);
    PFnLookupPrivilegeValue pfnLookupPrivilegeValue = (PFnLookupPrivilegeValue)GetProcAddress(hAdvapi32, ADVAPI32API_LookupPrivilegeValue);
    PFnAdjustTokenPrivileges pfnAdjustTokenPrivileges = (PFnAdjustTokenPrivileges)GetProcAddress(hAdvapi32, ADVAPI32API_AdjustTokenPrivileges);
    if (!pfnOpenProcessToken || !pfnLookupPrivilegeValue || !pfnAdjustTokenPrivileges)
    {
        FreeLibrary(hAdvapi32);
        return false;
    }

    // grab this process's token
    if (!pfnOpenProcessToken(WIN::GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
    {
        FreeLibrary(hAdvapi32);
        return false;
    }

    // get the LUID for the shutdown privilege
    pfnLookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);

    tkp.PrivilegeCount = 1; // one privilege to set
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    // get the shutdown privilege for this process
    pfnAdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);

    // cannot test return value of AdjustTokenPrivileges
    if (ERROR_SUCCESS != WIN::GetLastError())
    {
        FreeLibrary(hAdvapi32);
        return false;
    }

    FreeLibrary(hAdvapi32);

    return true;
}

/////////////////////////////////////////////////////////////////////////////
// SetDiagnosticMode
//
//  Turns on debug output if first char of szDebugEnvVar is set to 1
//

int g_dmDiagnosticMode = -1; // -1 until set, then DebugMsg skips fn call if 0

void SetDiagnosticMode()
{
    g_dmDiagnosticMode = 0; // disable DebugMsg to start

    char rgchBuf[64] = {0};
    if (0 != WIN::GetEnvironmentVariable(szDebugEnvVar, rgchBuf, sizeof(rgchBuf)/sizeof(char))
        && rgchBuf[0] == '1')
    {
        g_dmDiagnosticMode = 1; // enable DebugMsg output
    }
}

/////////////////////////////////////////////////////////////////////////////
// DebugMsg
//
//  Outputs debugging string to debugger if debug output is enabled
//

void DebugMsg(LPCSTR szFormat, ...)
{
    if (-1 == g_dmDiagnosticMode)
    {
        SetDiagnosticMode();
    }

    if (0 == g_dmDiagnosticMode)
        return; // debug output is not enabled

    size_t dwBuf = 512;
    char *szDebug = new char[dwBuf];
    if (!szDebug)
        return ; // out of memory
    
    // store the result debug string
    va_list listDebugArg; 
    va_start(listDebugArg, szFormat); 
    while (-1 == _vsnprintf(szDebug, dwBuf, szFormat, listDebugArg))
    {
        dwBuf *= 2;
        delete[] szDebug;
        szDebug = new char[dwBuf];
        if (!szDebug)
        {
            va_end(listDebugArg);
            return; // out of memory
        }
    }
    va_end(listDebugArg);

    OutputDebugString(szDebug);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\setup.exe\setup.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       setup.cpp
//
//--------------------------------------------------------------------------

#define WIN // scope W32 API
#define MSI // scope MSI API

#include <windows.h>
#include <tchar.h>
#include <assert.h>

// internet download
#include "wininet.h"  // DeleteUrlCacheEntry, InternetCanonicalizeUrl
#include "urlmon.h"   // URLDownloadToCacheFile

// package trust
#include "wintrust.h"
#include "softpub.h"

// msi installation
#include "msidefs.h"
#include "msiquery.h"
#include "msi.h"

// setup.exe
#include "common.h"
#include "setup.h"
#include "setupui.h"
#include "resource.h"

//--------------------------------------------------------------------------------------
// MSI API -- delay load
//--------------------------------------------------------------------------------------

#define MSI_DLL "msi.dll"

#define MSIAPI_MsiSetInternalUI "MsiSetInternalUI"
typedef INSTALLUILEVEL (WINAPI* PFnMsiSetInternalUI)(INSTALLUILEVEL dwUILevel, HWND *phWnd);

#define MSIAPI_MsiInstallProduct "MsiInstallProductA"
typedef UINT (WINAPI* PFnMsiInstallProduct)(LPCSTR szPackagePath, LPCSTR szCommandLine);

#define MSIAPI_MsiApplyPatch "MsiApplyPatchA"
typedef UINT (WINAPI* PFnMsiApplyPatch)(LPCSTR szPatchPackage, LPCSTR szInstallPackage, INSTALLTYPE eInstallType, LPCSTR szCommandLine);

#define MSIAPI_MsiReinstallProduct "MsiReinstallProductA"
typedef UINT (WINAPI* PFnMsiReinstallProduct)(LPCSTR szProduct, DWORD dwReinstallMode);

#define MSIAPI_MsiQueryProductState "MsiQueryProductStateA"
typedef INSTALLSTATE (WINAPI* PFnMsiQueryProductState)(LPCSTR szProduct);

#define MSIAPI_MsiOpenDatabase "MsiOpenDatabaseA"
typedef UINT (WINAPI* PFnMsiOpenDatabase)(LPCSTR szDatabasePath, LPCSTR szPersist, MSIHANDLE *phDatabase);

#define MSIAPI_MsiDatabaseOpenView "MsiDatabaseOpenViewA"
typedef UINT (WINAPI* PFnMsiDatabaseOpenView)(MSIHANDLE hDatabase, LPCSTR szQuery, MSIHANDLE *phView);

#define MSIAPI_MsiViewExecute "MsiViewExecute"
typedef UINT (WINAPI* PFnMsiViewExecute)(MSIHANDLE hView, MSIHANDLE hRecord);

#define MSIAPI_MsiViewFetch "MsiViewFetch"
typedef UINT (WINAPI* PFnMsiViewFetch)(MSIHANDLE hView, MSIHANDLE *phRecord);

#define MSIAPI_MsiRecordGetString "MsiRecordGetStringA"
typedef UINT (WINAPI* PFnMsiRecordGetString)(MSIHANDLE hRecord, unsigned int uiField, LPSTR szValue, DWORD *pcchValueBuf);

#define MSIAPI_MsiCloseHandle "MsiCloseHandle"
typedef UINT (WINAPI* PFnMsiCloseHandle)(MSIHANDLE h);

/////////////////////////////////////////////////////////////////////////////
// WinMain -- Application Entry Point
//

extern "C" int __stdcall WinMain(HINSTANCE hInst, HINSTANCE hPrevInst , LPSTR lpszCmdLine, int nCmdShow)
{

//-----------------------------------------------------------------------------------------------------------------
//  VARIABLES
//
//-----------------------------------------------------------------------------------------------------------------
    UINT    uiRet = ERROR_SUCCESS;
    HRESULT hr    = S_OK;

    char *szMsiFile          = 0;
    char *szBaseURL          = 0;
    char *szInstallPath      = 0;
    char *szMsiCacheFile     = 0;
    char *szOperation        = 0;
    char *szProductName      = 0;
    char *szMinimumMsi       = 0;
    char *szProperties       = 0;
    char *szInstProperties   = 0;
    char *szTempPath         = 0;
    char *szFilePart         = 0;
    char *szBaseInstMsi      = 0;
    char *szInstMsi          = 0;

    char *szRegisteredMsiFolder = 0;
    char *szMsiDllLocation      = 0;

    char szAppTitle[MAX_STR_CAPTION]    = {0};
    char szError[MAX_STR_LENGTH]        = {0};
    char szText[MAX_STR_CAPTION]        = {0};
    char szBanner[MAX_STR_LENGTH]       = {0};
    char szAction[MAX_STR_LENGTH]       = {0};
    char szUserPrompt[MAX_STR_LENGTH]   = {0};
    char szProductCode[MAX_LENGTH_GUID] = {0};

    char szModuleFile[MAX_PATH]         = {0};
    DWORD dwModuleFileSize       = MAX_PATH;
    
    DWORD dwMsiFileSize          = 0;
    DWORD dwBaseURLSize          = 0;
    DWORD cchInstallPath         = 0;
    DWORD dwMsiCacheFileSize     = 0;
    DWORD dwOperationSize        = 0;
    DWORD dwProductNameSize      = 0;
    DWORD dwMinimumMsiSize       = 0;
    DWORD dwPropertiesSize       = 0;
    DWORD cchInstProperties      = 0;
    DWORD cchTempPath            = 0;
    DWORD dwLastError            = 0;
    DWORD cchReturn              = 0;
    DWORD dwBaseInstMsiSize      = 0;
    DWORD dwInstMsiSize          = 0;
    DWORD dwResult               = 0;
    DWORD dwType                 = 0;
    DWORD dwProductCodeSize      = MAX_LENGTH_GUID;

    DWORD dwRegisteredMsiFolderSize  = 0;
    DWORD dwMsiDllLocationSize       = 0;

    ULONG ulMsiMinVer        = 0;
    char *szStopScan         = NULL;

    int         iMajorVersion      = 0;
    bool        fUpgradeMsi        = false;
    bool        fWin9X             = false;
    bool        fAdmin             = false;
    bool        fDelayRebootReq    = false;
    bool        fPatch             = false;
    bool        fQFE               = false;
    emEnum      emExecMode         = emPreset;

    HKEY hInstallerKey = 0;

    char *pch = 0;

    HMODULE hMsi = 0;
    PFnMsiSetInternalUI pfnMsiSetInternalUI = 0;
    PFnMsiInstallProduct pfnMsiInstallProduct = 0;
    PFnMsiApplyPatch pfnMsiApplyPatch = 0;
    PFnMsiReinstallProduct pfnMsiReinstallProduct = 0;
    PFnMsiQueryProductState pfnMsiQueryProductState = 0;
    PFnMsiOpenDatabase pfnMsiOpenDatabase = 0;
    PFnMsiDatabaseOpenView pfnMsiDatabaseOpenView = 0;
    PFnMsiViewExecute pfnMsiViewExecute = 0;
    PFnMsiViewFetch pfnMsiViewFetch = 0;
    PFnMsiRecordGetString pfnMsiRecordGetString = 0;
    PFnMsiCloseHandle pfnMsiCloseHandle = 0;

    MSIHANDLE hDatabase = 0;
    MSIHANDLE hView = 0;
    MSIHANDLE hRec = 0;

    INSTALLSTATE isProduct = INSTALLSTATE_UNKNOWN;
    
    const char * szAdminImagePath = 0;



//-----------------------------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------------------------
    // create our UI object
    CDownloadUI DownloadUI;

    // Load our AppTitle (caption)
    WIN::LoadString(hInst, IDS_APP_TITLE, szAppTitle, sizeof(szAppTitle)/sizeof(char));

    // Obtain path we are running from
    if (0 == WIN::GetModuleFileName(hInst, szModuleFile, dwModuleFileSize))
    {
        // No UI displayed. Silent failure.
        uiRet = GetLastError();
        goto CleanUp;
    }
    DebugMsg("[Info] we are running from --> %s\n", szModuleFile);

    // Figure out what we want to do
    emExecMode = GetExecutionMode (lpszCmdLine);
    
    if (emVerify == emExecMode)
    {
        //
        // We don't want any UI to be displayed in this case. The return value
        // from the exe is the result of the verification. Therefore, this
        // should be done before initializing the UI.
        //
        uiRet = VerifyFileSignature (szModuleFile, lpszCmdLine);
        if (ERROR_BAD_ARGUMENTS != uiRet)
            goto CleanUp;
    }
    
    if (ERROR_BAD_ARGUMENTS == uiRet || emHelp == emExecMode)
    {
        DisplayUsage(hInst, NULL, szAppTitle);
        goto CleanUp;
    }
    
    //
    // NOTE:
    // Delay handling admin. installs until we have determined if we are
    // patching an existing install or if we are doing a default install.
    //
 
    // initialize our UI object with desktop as parent
    DownloadUI.Initialize(hInst, /* hwndParent = */ 0, szAppTitle);

    // only run one instance at a time
    if (AlreadyInProgress())
    {
        // silently return - correct return code ?
        return ERROR_INSTALL_ALREADY_RUNNING;
    }

    // other initializations
    fWin9X = IsOSWin9X(&iMajorVersion);
    fAdmin = IsAdmin(fWin9X, iMajorVersion);

    DebugMsg("[Info] fWin9X = %s, fAdmin = %s\n", fWin9X ? "TRUE" : "FALSE", fAdmin ? "TRUE" : "FALSE");

    // determine operation, default (if not present) is INSTALL
    if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_OPERATION, &szOperation, dwOperationSize)))
    {
        ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        goto CleanUp;
    }
    if (ERROR_SUCCESS != uiRet)
    {
        // set operation to default which is install
        if (!szOperation)
        {
            szOperation = new char[lstrlen(szDefaultOperation) + 1];
            if (!szOperation)
            {
                ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                goto CleanUp;
            }
        }
        if (sizeof(szOperation)/sizeof(char) <= lstrlen(szDefaultOperation))
        {
            delete [] szOperation;
            szOperation = new char[lstrlen(szDefaultOperation) + 1];
            if (!szOperation)
            {
                ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                goto CleanUp;
            }
        }
        lstrcpy(szOperation, szDefaultOperation);
    }

    // obtain name of product
    if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_PRODUCTNAME, &szProductName, dwProductNameSize)))
    {
        ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        goto CleanUp;
    }
    if (ERROR_SUCCESS != uiRet)
    {
        // use default
        WIN::LoadString(hInst, IDS_DEFAULT_PRODUCT, szProductName, MAX_STR_CAPTION);
    }

    // set banner text
    WIN::LoadString(hInst, IDS_BANNER_TEXT, szText, MAX_STR_CAPTION);
    wsprintf(szBanner, szText, szProductName);
    if (irmCancel == DownloadUI.SetBannerText(szBanner))
    {
        ReportUserCancelled(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_INSTALL_USEREXIT;
        goto CleanUp;
    }

    // Determine if this is a patch or a normal install.
    if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_DATABASE, &szMsiFile, dwMsiFileSize)))
    {
        ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        goto CleanUp;
    }
    else if (ERROR_SUCCESS != uiRet)
    {
        // look for patch
        if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_PATCH, &szMsiFile, dwMsiFileSize)))
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            goto CleanUp;
        }
        else if (ERROR_SUCCESS != uiRet)
        {
            PostResourceNotFoundError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, ISETUPPROPNAME_DATABASE);
            goto CleanUp;
        }

        fPatch = true;
    }
    
    //
    // If we are here, this is either an admin. install or a default install.
    // File signature verification, help and other invalid parameters have
    // already been taken care of above.
    //
    if (emAdminInstall == emExecMode)
    {
        uiRet = GetAdminInstallInfo (fPatch, lpszCmdLine, &szAdminImagePath);
        if (ERROR_BAD_ARGUMENTS == uiRet)
        {
            DisplayUsage(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            goto CleanUp;
        }
    }
    
    //
    // At this point, the validation of the commandline arguments is complete
    // and we have all the information we need.
    //

    // obtain minimum required MSI version
    if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_MINIMUM_MSI, &szMinimumMsi, dwMinimumMsiSize)))
    {
        ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        goto CleanUp;
    }
    else if (ERROR_SUCCESS != uiRet)
    {
        PostResourceNotFoundError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, ISETUPPROPNAME_MINIMUM_MSI);
        goto CleanUp;
    }

    // make sure required Msi version is a valid value -- must be >= 150
    ulMsiMinVer = strtoul(szMinimumMsi, &szStopScan, 10);
    if (!szStopScan || (szStopScan == szMinimumMsi) || (*szStopScan != 0) || ulMsiMinVer < MINIMUM_SUPPORTED_MSI_VERSION)
    {
        // invalid minimum version string
        PostError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_INVALID_VER_STR, szMinimumMsi, MINIMUM_SUPPORTED_MSI_VERSION);
        uiRet = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    DebugMsg("[Resource] Minimum Msi Value = %d\n", ulMsiMinVer);

    // compare minimum required MSI version to that which is on the machine
    if ((fUpgradeMsi = IsMsiUpgradeNecessary(ulMsiMinVer)))
    {
        DebugMsg("[Info] Upgrade of Windows Installer is requested\n");

        // make sure this is admin -- must have admin priviledges to upgrade Windows Installer
        if (!fAdmin)
        {
            PostError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_REQUIRES_ADMIN_PRIV);
            uiRet = ERROR_INSTALL_FAILURE;
            goto CleanUp;
        }

        // since instmsi hides the cancel button, ask the user if they want to upgrade the installer
        WIN::LoadString(hInst, IDS_ALLOW_MSI_UPDATE, szUserPrompt, MAX_STR_LENGTH);
        if (IDYES != WIN::MessageBox(DownloadUI.GetCurrentWindow(), szUserPrompt, szAppTitle, MB_YESNO|MB_ICONQUESTION))
        {
            // user decided to cancel
            ReportUserCancelled(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_INSTALL_USEREXIT;
            goto CleanUp;
        }

        if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, fWin9X ? ISETUPPROPNAME_INSTMSIA : ISETUPPROPNAME_INSTMSIW, &szInstMsi, dwInstMsiSize)))
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            goto CleanUp;
        }
        else if (ERROR_SUCCESS != uiRet)
        {
            PostResourceNotFoundError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, fWin9X ? ISETUPPROPNAME_INSTMSIA : ISETUPPROPNAME_INSTMSIW);
            goto CleanUp;
        }

        // determine if we need to download instmsi.exe from the web -- based on presence of INSTLOCATION property
        if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_INSTLOCATION, &szBaseInstMsi, dwBaseInstMsiSize)))
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            goto CleanUp;
        }
        else if (ERROR_SUCCESS == uiRet)
        {
            // presence of INSTLOCATION property indicates assumption of URL source
            if (ERROR_SUCCESS != (uiRet = DownloadAndUpgradeMsi(hInst, &DownloadUI, szAppTitle, szBaseInstMsi, szInstMsi, szModuleFile, ulMsiMinVer)))
            {
                if (ERROR_SUCCESS_REBOOT_REQUIRED == uiRet)
                {
                    // successful, but must reboot at end
                    fDelayRebootReq = true;
                }
                else
                    goto CleanUp;
            }
        }
        else
        {
            // lack of INSTLOCATION property indicates assumption of Media source
            if (ERROR_SUCCESS != (uiRet = UpgradeMsi(hInst, &DownloadUI, szAppTitle, szModuleFile, szInstMsi, ulMsiMinVer)))
            {
                if (ERROR_SUCCESS_REBOOT_REQUIRED == uiRet)
                {
                    // successful, but must reboot at end
                    fDelayRebootReq = true;
                }
                else
                    goto CleanUp;
            }
        }
    }

    DebugMsg("[Info] Windows Installer has been upgraded, or was already correct version\n");

    // perform some extra authoring validation
    if (fPatch && 0 != lstrcmpi(szOperation, szMinPatchOperation) && 0 != lstrcmpi(szOperation, szMajPatchOperation) && 0 != lstrcmpi(szOperation, szDefaultOperation))
    {
        // wrong operation
        DebugMsg("[Error] Operation %s is not valid for a patch\n", szOperation);
        PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_INVALID_OPERATION, szOperation);
        uiRet = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }
    else if (!fPatch && 0 != lstrcmpi(szOperation, szInstallOperation) && 0 != lstrcmpi(szOperation, szInstallUpdOperation) && 0 != lstrcmpi(szOperation, szDefaultOperation))
    {
        // wrong operation
        DebugMsg("[Error] Operation %s is not valid for a package\n", szOperation);
        PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_INVALID_OPERATION, szOperation);
        uiRet = ERROR_INVALID_PARAMETER;
        goto CleanUp;
    }

    // by now we either have a MSI or a MSP
    if (0 == lstrcmpi(szOperation, szMinPatchOperation) || 0 == lstrcmpi(szOperation, szInstallUpdOperation)
        || (fPatch && 0 == lstrcmpi(szOperation, szDefaultOperation)))
        fQFE = true;

    // obtain base URL
    if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_BASEURL, &szBaseURL, dwBaseURLSize)))
    {
        ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        goto CleanUp;
    }
    else if (ERROR_SUCCESS == uiRet)
    {
        // presence of BASEURL property indicates assumption of URL source . . .

        // generate the path to the installation package == baseURL + msiFile
        //   note: msiFile is a relative path
        cchTempPath = lstrlen(szBaseURL) + lstrlen(szMsiFile) + 2; // 1 for slash, 1 for null
        szTempPath = new char[cchTempPath ];
        if (!szTempPath)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }
        lstrcpy(szTempPath, szBaseURL);
        // check for trailing slash on szBaseURL
        char *pch = szBaseURL + lstrlen(szBaseURL) + 1; // put at null terminator
        pch = CharPrev(szBaseURL, pch);
        if (*pch != '/')
            lstrcat(szTempPath, szUrlPathSep);
        lstrcat(szTempPath, szMsiFile);

        // canocialize the URL path
        cchInstallPath = cchTempPath*2;
        szInstallPath = new char[cchInstallPath];
        if (!szInstallPath)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }

        dwLastError = 0; // success
        if (!InternetCanonicalizeUrl(szTempPath, szInstallPath, &cchInstallPath, 0))
        {
            dwLastError = GetLastError();
            if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
            {
                // try again
                delete [] szInstallPath;
                szInstallPath = new char[cchInstallPath];
                if (!szInstallPath)
                {
                    ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                    uiRet = ERROR_OUTOFMEMORY;
                    goto CleanUp;
                }
                dwLastError = 0; // reset to success for 2nd attempt
                if (!InternetCanonicalizeUrl(szTempPath, szInstallPath, &cchInstallPath, 0))
                    dwLastError = GetLastError();
            }
        }
        if (0 != dwLastError)
        {
            // error -- invalid path/Url
            PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
            uiRet = dwLastError;
            goto CleanUp;
        }

        // set action text for download
        WIN::LoadString(hInst, IDS_DOWNLOADING_PACKAGE, szText, MAX_STR_CAPTION);
        wsprintf(szAction, szText, szMsiFile);
        if (irmCancel == DownloadUI.SetActionText(szAction))
        {
            ReportUserCancelled(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_INSTALL_USEREXIT;
            goto CleanUp;
        }

        // download the msi file so we can attempt a trust check -- must be local for WinVerifyTrust
        DebugMsg("[Info] Downloading msi file %s for WinVerifyTrust check\n", szInstallPath);

        szMsiCacheFile = new char[MAX_PATH];
        dwMsiCacheFileSize = MAX_PATH;
        if (!szMsiCacheFile)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }

        hr = WIN::URLDownloadToCacheFile(NULL, szInstallPath, szMsiCacheFile, dwMsiCacheFileSize, 0, /* IBindStatusCallback = */ &CDownloadBindStatusCallback(&DownloadUI));
        if (DownloadUI.HasUserCanceled())
        {
            ReportUserCancelled(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_INSTALL_USEREXIT;
            goto CleanUp;
        }
        if (FAILED(hr))
        {
            // error during download -- probably because file not found (or lost connection)
            PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_NOMSI, szInstallPath);
            uiRet = ERROR_FILE_NOT_FOUND;
            goto CleanUp;
        }

        DebugMsg("[Info] Msi file was cached to %s\n", szMsiCacheFile);

        // set action text for trust verification
        WIN::LoadString(hInst, IDS_VALIDATING_SIGNATURE, szText, MAX_STR_CAPTION);
        wsprintf(szAction, szText, szMsiFile);
        if (irmCancel == DownloadUI.SetActionText(szAction))
        {
            ReportUserCancelled(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_INSTALL_USEREXIT;
            goto CleanUp;
        }

        // perform trust check 
        itvEnum itv = IsPackageTrusted(szModuleFile, szMsiCacheFile, DownloadUI.GetCurrentWindow());
        if (itvWintrustNotOnMachine == itv)
        {
            PostError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_NO_WINTRUST);
            uiRet = ERROR_CALL_NOT_IMPLEMENTED;
            goto CleanUp;
        }
        else if (itvUnTrusted == itv)
        {
            PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_UNTRUSTED, szInstallPath);
            uiRet = HRESULT_CODE(TRUST_E_SUBJECT_NOT_TRUSTED);
            goto CleanUp;
        }
    }
    else
    {
        // lack of BASEURL property indicates assumption of Media source

        // generate the path to the Msi file =  szModuleFile + msiFile
        //   note: msiFile is a relative path
        cchTempPath = lstrlen(szModuleFile) + lstrlen(szMsiFile) + 2; // 1 for null terminator, 1 for back slash
        szTempPath = new char[cchTempPath];
        if (!szTempPath)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }

        // find 'setup.exe' in the path so we can remove it
        if (0 == GetFullPathName(szModuleFile, cchTempPath, szTempPath, &szFilePart))
        {
            uiRet = GetLastError();
            PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
            goto CleanUp;
        }
        if (szFilePart)
            *szFilePart = '\0';

        lstrcat(szTempPath, szMsiFile);

        cchInstallPath = 2*cchTempPath;
        szInstallPath = new char[cchInstallPath];
        if (!szInstallPath)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }

        // normalize the path
        cchReturn = GetFullPathName(szTempPath, cchInstallPath, szInstallPath, &szFilePart);
        if (cchReturn > cchInstallPath)
        {
            // try again, with larger buffer
            delete [] szInstallPath;
            cchInstallPath = cchReturn;
            szInstallPath = new char[cchInstallPath];
            if (!szInstallPath)
            {
                ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                uiRet = ERROR_OUTOFMEMORY;
                goto CleanUp;
            }
            cchReturn = GetFullPathName(szTempPath, cchInstallPath, szInstallPath, &szFilePart);
        }
        if (0 == cchReturn)
        {
            // error -- invalid path
            PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
            uiRet = dwLastError;
            goto CleanUp;
        }

        // no download is necessary -- but we can check for the file's existence
        DWORD dwFileAttrib = GetFileAttributes(szInstallPath);
        if (0xFFFFFFFF == dwFileAttrib)
        {
            // package is missing
            PostFormattedError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_NOMSI, szInstallPath);
            uiRet = ERROR_FILE_NOT_FOUND;
            goto CleanUp;
        }
    }

    //
    // good to go -- terminate our UI and let the Windows Installer take over
    //

    // retrieve the optional command line PROPERTY = VALUE strings if available
    if (ERROR_OUTOFMEMORY == (uiRet = SetupLoadResourceString(hInst, ISETUPPROPNAME_PROPERTIES, &szProperties, dwPropertiesSize)))
    {
        ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_OUTOFMEMORY;
        goto CleanUp;
    }
    else if (ERROR_SUCCESS != uiRet)
    {
        // PROPERTY=VALUE pairs not specified
        if (szProperties)
            delete [] szProperties;
        szProperties = NULL;
    }

    DownloadUI.Terminate();

    //
    // perform install -- use registered location of msi.dll so that we can make use of the "delay-reboot"
    //                     upgrade Msi feature
    //


    // find registered location of Msi.dll
    if (ERROR_SUCCESS == (uiRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szInstallerKey, 0, KEY_READ, &hInstallerKey)))
    {
        szRegisteredMsiFolder = new char[MAX_PATH];
        dwRegisteredMsiFolderSize = MAX_PATH;
        if (!szRegisteredMsiFolder)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }

        if (ERROR_MORE_DATA == (uiRet = RegQueryValueEx(hInstallerKey, szInstallerLocationValueName, NULL, &dwType, (BYTE*)szRegisteredMsiFolder, &dwRegisteredMsiFolderSize)))
        {
            // try again with larger buffer
            delete [] szRegisteredMsiFolder;
            szRegisteredMsiFolder = new char[dwRegisteredMsiFolderSize];
            if (!szRegisteredMsiFolder)
            {
                ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                uiRet = ERROR_OUTOFMEMORY;
                goto CleanUp;
            }
            uiRet = RegQueryValueEx(hInstallerKey, szInstallerLocationValueName, NULL, &dwType, (BYTE*)szRegisteredMsiFolder, &dwRegisteredMsiFolderSize);
        }

        if (ERROR_SUCCESS == uiRet && dwType == REG_SZ && dwRegisteredMsiFolderSize > 0)
        {
            // load Msi.dll from registered location
            dwMsiDllLocationSize = dwRegisteredMsiFolderSize + lstrlen(szMsiDll) + 1;
            szMsiDllLocation = new char[dwMsiDllLocationSize];
            if (!szMsiDllLocation)
            {
                ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                uiRet = ERROR_OUTOFMEMORY;
                goto CleanUp;
            }
            lstrcpy(szMsiDllLocation, szRegisteredMsiFolder);
            lstrcat(szMsiDllLocation, szMsiDll);
            hMsi = LoadLibrary(szMsiDllLocation);
        }
        else
        {
            // load Msi.dll from default location
            hMsi = LoadLibrary(MSI_DLL);
        }
    }
    else
    {
        // use default location for loading Msi.dll
        hMsi = LoadLibrary(MSI_DLL);
    }

    if (hMsi)
    {
        pfnMsiSetInternalUI = (PFnMsiSetInternalUI)GetProcAddress(hMsi, MSIAPI_MsiSetInternalUI);
        pfnMsiInstallProduct = (PFnMsiInstallProduct)GetProcAddress(hMsi, MSIAPI_MsiInstallProduct);
        pfnMsiApplyPatch = (PFnMsiApplyPatch)GetProcAddress(hMsi, MSIAPI_MsiApplyPatch);
        pfnMsiReinstallProduct = (PFnMsiReinstallProduct)GetProcAddress(hMsi, MSIAPI_MsiReinstallProduct);
        pfnMsiQueryProductState = (PFnMsiQueryProductState)GetProcAddress(hMsi, MSIAPI_MsiQueryProductState);
        pfnMsiOpenDatabase = (PFnMsiOpenDatabase)GetProcAddress(hMsi, MSIAPI_MsiOpenDatabase);
        pfnMsiDatabaseOpenView = (PFnMsiDatabaseOpenView)GetProcAddress(hMsi, MSIAPI_MsiDatabaseOpenView);
        pfnMsiViewExecute = (PFnMsiViewExecute)GetProcAddress(hMsi, MSIAPI_MsiViewExecute);
        pfnMsiViewFetch = (PFnMsiViewFetch)GetProcAddress(hMsi, MSIAPI_MsiViewFetch);
        pfnMsiRecordGetString = (PFnMsiRecordGetString)GetProcAddress(hMsi, MSIAPI_MsiRecordGetString);
        pfnMsiCloseHandle = (PFnMsiCloseHandle)GetProcAddress(hMsi, MSIAPI_MsiCloseHandle);
    }
    if (!hMsi || !pfnMsiSetInternalUI || !pfnMsiInstallProduct || !pfnMsiApplyPatch || !pfnMsiReinstallProduct || !pfnMsiQueryProductState
        || !pfnMsiDatabaseOpenView || !pfnMsiViewExecute || !pfnMsiViewFetch || !pfnMsiRecordGetString || !pfnMsiCloseHandle)
    {
        PostError(hInst, DownloadUI.GetCurrentWindow(), szAppTitle, IDS_FAILED_TO_UPGRADE_MSI);
        uiRet = ERROR_INSTALL_FAILURE;
        goto CleanUp;
    }

    DebugMsg("[Info] Setting Internal UI level to FULL...\n");
    pfnMsiSetInternalUI(INSTALLUILEVEL_FULL, 0);

    if (!fPatch)
    {
        // performing install or reinstall/recache
        DebugMsg("[Info] Calling MsiInstallProduct with szInstallPath = %s", szInstallPath); 
        DebugMsg(" and szCommandLine = %s\n", szProperties ? szProperties : "{null}");

        // default operation for a package is INSTALL

        if (fQFE)
        {
            // check to see if this product is already installed
            if (ERROR_SUCCESS == pfnMsiOpenDatabase(szMsiCacheFile ? szMsiCacheFile : szInstallPath, MSIDBOPEN_READONLY, &hDatabase)
                && ERROR_SUCCESS == pfnMsiDatabaseOpenView(hDatabase, sqlProductCode, &hView)
                && ERROR_SUCCESS == pfnMsiViewExecute(hView, 0)
                && ERROR_SUCCESS == pfnMsiViewFetch(hView, &hRec)
                && ERROR_SUCCESS == pfnMsiRecordGetString(hRec, 1, szProductCode, &dwProductCodeSize))
            {
                isProduct = pfnMsiQueryProductState(szProductCode);
                DebugMsg("[Info] MsiQueryProductState returned %d\n", isProduct);
                if (INSTALLSTATE_ADVERTISED != isProduct && INSTALLSTATE_DEFAULT != isProduct)
                {
                    // product is unknown, so this will be a first time install
                    DebugMsg("[Info] The product code '%s' is unknown. Will use first time install logic...\n", szProductCode);
                    fQFE = false;
                }
                else
                {
                    // product is known, use QFE syntax
                    DebugMsg("[Info] The product code '%s' is known. Will use QFE recache and reinstall upgrade logic...\n", szProductCode);
                }
            }
            else
            {
                // some failure occurred when processing the product code, so treat as non-QFE
                DebugMsg("[Info] Unable to process product code. Will treat as first time install...\n");
                fQFE = false;
            }
            if (hDatabase)
                pfnMsiCloseHandle(hDatabase);
            if (hView)
                pfnMsiCloseHandle(hView);
            if (hRec)
                pfnMsiCloseHandle(hRec);
        }
        
        //
        // Set up the properties to be passed into MSIInstallProduct
        //
        if (fQFE && !szProperties)
            cchInstProperties = lstrlen (szDefaultInstallUpdCommandLine);
        else if (szProperties)
            cchInstProperties = lstrlen (szProperties);
        if (emAdminInstall == emExecMode)
            cchInstProperties += lstrlen (szAdminInstallProperty);
        
        szInstProperties = new char[cchInstProperties + 1];
        if (! szInstProperties)
        {
            ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }
        
        if (fQFE && !szProperties)
            lstrcpy (szInstProperties, szDefaultInstallUpdCommandLine);
        else if (szProperties)
            lstrcpy (szInstProperties, szProperties);
        else
            szInstProperties[0] = '\0';
        if (emAdminInstall == emExecMode)
            lstrcat (szInstProperties, szAdminInstallProperty);

        uiRet = pfnMsiInstallProduct(szInstallPath, szInstProperties);
        if (ERROR_SUCCESS != uiRet)
        {
            // attempt to display an error message stored in msi.dll
            PostMsiError(hInst, hMsi, DownloadUI.GetCurrentWindow(), szAppTitle, uiRet);
        }

        DebugMsg("[Info] MsiInstallProduct returned %d\n", uiRet);
    }
    else
    {
        // default Operation for a patch is MINPATCH

        // if szProperties is NULL, use our default value for QFE patches
        if (!szProperties && fQFE)
        {
            DebugMsg("[Info] Patch is a MINPATCH (small or minor update patch) so using default command line '%s'\n", szDefaultMinPatchCommandLine);

            szProperties = new char[lstrlen(szDefaultMinPatchCommandLine) + 1];
            if (!szProperties)
            {
                ReportErrorOutOfMemory(hInst, DownloadUI.GetCurrentWindow(), szAppTitle);
                uiRet = ERROR_OUTOFMEMORY;
                goto CleanUp;
            }
            lstrcpy(szProperties, szDefaultMinPatchCommandLine);
        }

        if (emAdminInstall == emExecMode)
        {
			// performing a patch
			DebugMsg("[Info] Calling MsiApplyPatch with szPatchPackage = %s", szMsiCacheFile);
			DebugMsg(" and szInstallPackage = %s and eInstallType = INSTALLTYPE_NETWORK_IMAGE", szAdminImagePath);
			DebugMsg(" and szCommandLine = %s\n", szProperties ? szProperties : "{null}");

            uiRet = pfnMsiApplyPatch(szMsiCacheFile, szAdminImagePath, INSTALLTYPE_NETWORK_IMAGE, szProperties);
        }
        else
        {
			// performing a patch
			DebugMsg("[Info] Calling MsiApplyPatch with szPatchPackage = %s", szInstallPath);
			DebugMsg(" and szInstallPackage = {null} and eInstallType = INSTALLTYPE_DEFAULT");
			DebugMsg(" and szCommandLine = %s\n", szProperties ? szProperties : "{null}");

            uiRet = pfnMsiApplyPatch(szInstallPath, NULL, INSTALLTYPE_DEFAULT, szProperties);
        }
        if (ERROR_SUCCESS != uiRet)
        {
            // attempt to display an error message stored in msi.dll
            PostMsiError(hInst, hMsi, DownloadUI.GetCurrentWindow(), szAppTitle, uiRet);
        }

        DebugMsg("[Info] MsiApplyPatch returned %d\n", uiRet);
    }

    if (fDelayRebootReq)
    {
        // need to reboot machine for instmsi changes
        WIN::LoadString(hInst, IDS_REBOOT_REQUIRED, szAction, MAX_STR_LENGTH);
        if (IDYES == MessageBox(NULL, szAction, szAppTitle, MB_YESNO|MB_ICONQUESTION))
        {
            if (!fWin9X)
            {
                // must first aquire system shutdown privileges on NT/Win2K
                AcquireShutdownPrivilege();
            }
            // initiate system shutdown for reboot
            WIN::ExitWindowsEx(EWX_REBOOT, 0);
        }
    }

CleanUp:

    if (szMsiFile)
        delete [] szMsiFile;
    if (szBaseURL)
        delete [] szBaseURL;
    if (szInstallPath)
        delete [] szInstallPath;
    if (szMsiCacheFile)
    {
        WIN::DeleteUrlCacheEntry(szMsiCacheFile);
        delete [] szMsiCacheFile;
    }
    if (szProductName)
        delete [] szProductName;
    if (szMinimumMsi)
        delete [] szMinimumMsi;
    if (szProperties)
        delete [] szProperties;
    if (szTempPath)
        delete [] szTempPath;
    if (szBaseInstMsi)
        delete [] szBaseInstMsi;
    if (szInstMsi)
        delete [] szInstMsi;
    if (szRegisteredMsiFolder)
        delete [] szRegisteredMsiFolder;
    if (szMsiDllLocation)
        delete [] szMsiDllLocation;

    if (hMsi)
        FreeLibrary(hMsi);

    DebugMsg("[Info] Setup exit code is %d\n", uiRet);

    return uiRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\setup.exe\upgrdmsi.cpp ===
//+-------------------------------------------------------------------------
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       upgrdmsi.cpp
//
//--------------------------------------------------------------------------

#include "setup.h"
#include "resource.h"

// internet download
#include "wininet.h"  // DeleteUrlCacheEntry, InternetCanonicalizeUrl
#include "urlmon.h"   // URLDownloadToCacheFile

#include "wintrust.h" // WTD_UI_NONE
#include <assert.h>
#include <stdlib.h>

#define WIN // scope W32 API

#define MSISIPAPI_DllRegisterServer "DllRegisterServer"
typedef HRESULT (WINAPI* PFnMsiSIPDllRegisterServer)();
/////////////////////////////////////////////////////////////////////////////
// IsMsiUpgradeNecessary
//

bool IsMsiUpgradeNecessary(ULONG ulReqMsiMinVer)
{
    // attempt to load msi.dll in the system directory

    char szSysMsiDll[MAX_PATH] = {0};
    char szSystemFolder[MAX_PATH] = {0};

    DWORD dwRet = WIN::GetSystemDirectory(szSystemFolder, MAX_PATH);
    if (MAX_PATH < dwRet)
    {
        assert(0); // -- bigger buffer
    }

    lstrcpy(szSysMsiDll, szSystemFolder);
    lstrcat(szSysMsiDll, "\\MSI.DLL");

    HINSTANCE hinstMsiSys = LoadLibrary(szSysMsiDll);
    if (0 == hinstMsiSys)
    {
        // can't load msi.dll; assume upgrade is necessary
        DebugMsg("[Info] Can't load msi.dll; assuming upgrade is necessary");

        return true;
    }
    FreeLibrary(hinstMsiSys);

    // get version on msi.dll
    DWORD dwInstalledMSVer;
    dwRet = GetFileVersionNumber(szSysMsiDll, &dwInstalledMSVer, NULL);
    if (ERROR_SUCCESS != dwRet)
    {
        // can't obtain version information; assume upgrade is necessary
        DebugMsg("[Info] Can't obtain version information; assuming upgrade is necessary");

        return true;
    }

    // compare version in system to the required minimum
    ULONG ulInstalledVer = HIWORD(dwInstalledMSVer) * 100 + LOWORD(dwInstalledMSVer);
    if (ulInstalledVer < ulReqMsiMinVer)
    {
        // upgrade is necessary
        char szDebugOutput[MAX_STR_LENGTH] = {0};
        DebugMsg("[Info] Windows Installer upgrade is required.  System Version = %d, Minimum Version = %d.\n", ulInstalledVer, ulReqMsiMinVer);

        return true;
    }

    // no upgrade is necessary
    DebugMsg("[Info] No upgrade is necessary.  System version meets minimum requirements\n");
    return false;
}

/////////////////////////////////////////////////////////////////////////////
// UpgradeMsi
//

UINT UpgradeMsi(HINSTANCE hInst, CDownloadUI *piDownloadUI, LPCSTR szAppTitle, LPCSTR szInstLocation, LPCSTR szInstMsi, ULONG ulMinVer)
{
    char *szTempPath    = 0;
    char *szInstMsiPath = 0;
    char *szFilePart    = 0;

    DWORD cchTempPath    = 0;
    DWORD cchInstMsiPath = 0;
    DWORD cchReturn      = 0;
    DWORD dwLastError    = 0;
    DWORD dwFileAttrib   = 0;
    UINT  uiRet          = 0;

    // generate the path to the InstMsi file =  szInstLocation + szInstMsi
    //   note: szInstMsi is a relative path

    cchTempPath = lstrlen(szInstLocation) + lstrlen(szInstMsi) + 2; // 1 for null terminator, 1 for back slash
    szTempPath = new char[cchTempPath];
    if (!szTempPath)
    {
        ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_OUTOFMEMORY;
        goto CleanUp;
    }
    memset((void*)szTempPath, 0x00, cchTempPath);

    // find 'setup.exe' in the path so we can remove it -- this is an already expanded path, that represents
    //  our current running location.  It includes our executable name -- we want to find that and get rid of it
    if (0 == GetFullPathName(szInstLocation, cchTempPath, szTempPath, &szFilePart))
    {
        uiRet = GetLastError();
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
        goto CleanUp;
    }
    if (szFilePart)
        *szFilePart = '\0';

    lstrcat(szTempPath, szInstMsi);

    cchInstMsiPath = 2*cchTempPath;
    szInstMsiPath = new char[cchInstMsiPath];
    if (!szInstMsiPath)
    {
        ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_OUTOFMEMORY;
        goto CleanUp;
    }

    // normalize the path
    cchReturn = GetFullPathName(szTempPath, cchInstMsiPath, szInstMsiPath, &szFilePart);
    if (cchReturn > cchInstMsiPath)
    {
        // try again, with larger buffer
        delete [] szInstMsiPath;
        cchInstMsiPath = cchReturn;
        szInstMsiPath = new char[cchInstMsiPath];
        if (!szInstMsiPath)
        {
            ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
            uiRet = ERROR_OUTOFMEMORY;
            goto CleanUp;
        }
        cchReturn = GetFullPathName(szTempPath, cchInstMsiPath, szInstMsiPath, &szFilePart);
    }
    if (0 == cchReturn)
    {
        uiRet = GetLastError();
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
        goto CleanUp;
    }

    // no download is necessary -- but we can check for the file's existence
    dwFileAttrib = GetFileAttributes(szInstMsiPath);
    if (0xFFFFFFFF == dwFileAttrib)
    {
        // instmsi executable is missing
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_NOINSTMSI, szInstMsiPath);
        uiRet = ERROR_FILE_NOT_FOUND;
        goto CleanUp;
    }

    uiRet = ValidateInstmsi(hInst, piDownloadUI, szAppTitle, szInstMsiPath, szInstMsiPath, ulMinVer);

CleanUp:
    if (szTempPath)
        delete [] szTempPath;
    if (szInstMsiPath)
        delete [] szInstMsiPath;

    return uiRet;
}

/////////////////////////////////////////////////////////////////////////////
// DownloadAndUpgradeMsi
//

UINT DownloadAndUpgradeMsi(HINSTANCE hInst, CDownloadUI *piDownloadUI, LPCSTR szAppTitle, LPCSTR szBaseInstMsi, LPCSTR szInstMsi, LPCSTR szModuleFile, ULONG ulMinVer)
{
    char *szTempPath         = 0;
    char *szInstMsiPath      = 0;
    char *szInstMsiCacheFile = 0;
    const char *pch          = 0;

    DWORD cchTempPath         = 0;
    DWORD cchInstMsiPath      = 0;
    DWORD cchInstMsiCacheFile = 0;
    DWORD dwLastError         = 0;
    UINT  uiRet               = 0;
    HRESULT hr                = 0;
    DWORD Status              = ERROR_SUCCESS;

    char szDebugOutput[MAX_STR_LENGTH] = {0};
    char szText[MAX_STR_CAPTION]       = {0};

    // generate the path to the instmsi == INSTLOCATION + szInstMsi
    //   note: szInstMsi is a relative path
    cchTempPath = lstrlen(szBaseInstMsi) + lstrlen(szInstMsi) + 2; // 1 for slash, 1 for null
    szTempPath = new char[cchTempPath];
    if (!szTempPath)
    {
        ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_OUTOFMEMORY;
        goto CleanUp;
    }
    lstrcpy(szTempPath, szBaseInstMsi);
    // check for trailing slash on szBaseInstMsi
    pch = szBaseInstMsi + lstrlen(szBaseInstMsi) + 1; // put at null terminator
    pch = CharPrev(szBaseInstMsi, pch);
    if (*pch != '/')
        lstrcat(szTempPath, szUrlPathSep);
    lstrcat(szTempPath, szInstMsi);

    // canocialize the URL path
    cchInstMsiPath = cchTempPath*2;
    szInstMsiPath = new char[cchInstMsiPath];
    if (!szInstMsiPath)
    {
        ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_OUTOFMEMORY;
        goto CleanUp;
    }

    if (!InternetCanonicalizeUrl(szTempPath, szInstMsiPath, &cchInstMsiPath, 0))
    {
        dwLastError = GetLastError();
        if (ERROR_INSUFFICIENT_BUFFER == dwLastError)
        {
            // try again
            delete [] szInstMsiPath;
            szInstMsiPath = new char[cchInstMsiPath];
            if (!szInstMsiPath)
            {
                ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
                uiRet = ERROR_OUTOFMEMORY;
                goto CleanUp;
            }
            dwLastError = 0; // reset to success for 2nd attempt
            if (!InternetCanonicalizeUrl(szTempPath, szInstMsiPath, &cchInstMsiPath, 0))
                dwLastError = GetLastError();
        }
    }
    if (0 != dwLastError)
    {
        // error -- invalid path/Url
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_INVALID_PATH, szTempPath);
        uiRet = dwLastError;
        goto CleanUp;
    }

    DebugMsg("[Info] Downloading instmsi from --> %s\n", szInstMsiPath);

    // set action text for download
    WIN::LoadString(hInst, IDS_DOWNLOADING_INSTMSI, szText, MAX_STR_CAPTION);
    if (irmCancel == piDownloadUI->SetActionText(szText))
    {
        ReportUserCancelled(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_INSTALL_USEREXIT;
        goto CleanUp;
    }

    // download the instmsi file so we can run it -- must be local to execute
    szInstMsiCacheFile = new char[MAX_PATH];
    cchInstMsiCacheFile = MAX_PATH;
    if (!szInstMsiCacheFile)
    {
        ReportErrorOutOfMemory(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_OUTOFMEMORY;
        goto CleanUp;
    }

    hr = WIN::URLDownloadToCacheFile(NULL, szInstMsiPath, szInstMsiCacheFile, cchInstMsiCacheFile, 0, /* IBindStatusCallback = */ &CDownloadBindStatusCallback(piDownloadUI));
    if (piDownloadUI->HasUserCanceled())
    {
        ReportUserCancelled(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
        uiRet = ERROR_INSTALL_USEREXIT;
        goto CleanUp;
    }
    if (FAILED(hr))
    {
        // error during download -- probably because file not found (or lost connection)
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_NOINSTMSI, szInstMsiPath);
        uiRet = ERROR_FILE_NOT_FOUND;
        goto CleanUp;
    }


    //
    // Perform trust check on MSI. Note, this must be done in a separate process.
    // This is because MSI 2.0 and higher register sip callbacks for verifying
    // digital signatures on msi files. At this point, it is quite likely that
    // the SIP callbacks have not been registered. So we don't want to load
    // wintrust.dll into this process's image yet, otherwise it will remain unaware
    // of the sip callbacks registered by instmsi and will fail later when it tries
    // to verify the signature on the msi file downloaded from the web.
    //
    Status = ExecuteVerifyInstMsi(szModuleFile, szInstMsiCacheFile);
    if (TRUST_E_PROVIDER_UNKNOWN == Status)
    {
        PostError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_NO_WINTRUST);
        uiRet = ERROR_CALL_NOT_IMPLEMENTED;
        goto CleanUp;
    }
    else if (ERROR_SUCCESS != Status)
    {
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_UNTRUSTED, szInstMsiCacheFile);
        uiRet = HRESULT_CODE(TRUST_E_SUBJECT_NOT_TRUSTED);
        goto CleanUp;
    }

    // continue other validations
    uiRet = ValidateInstmsi(hInst, piDownloadUI, szAppTitle, szInstMsiCacheFile, szModuleFile, ulMinVer);

CleanUp:
    if (szTempPath)
        delete [] szTempPath;
    if (szInstMsiPath)
        delete [] szInstMsiPath;
    if (szInstMsiCacheFile)
    {
        WIN::DeleteUrlCacheEntry(szInstMsiCacheFile);
        delete [] szInstMsiCacheFile;
    }

    return uiRet;
}

/////////////////////////////////////////////////////////////////////////////
// IsInstMsiRequiredVersion
//
//  instmsi version is stamped as rmj+10.rmm.rup.rin
//

bool IsInstMsiRequiredVersion(LPSTR szFilename, ULONG ulMinVer)
{
    // get version on instmsi
    DWORD dwInstMsiMSVer;
    DWORD dwRet = GetFileVersionNumber(szFilename, &dwInstMsiMSVer, NULL);
    if (ERROR_SUCCESS != dwRet)
    {
        // can't obtain version information; assume not proper version
        DebugMsg("[Info] Can't obtain version information for instmsi; assuming it is not the proper version\n");
        return false;
    }

    // compare version at source to required minimum
    ULONG ulSourceVer = (HIWORD(dwInstMsiMSVer) - 10) * 100 + LOWORD(dwInstMsiMSVer);
    if (ulSourceVer < ulMinVer)
    {
        // source version won't get us to our minimum version
        char szDebugOutput[MAX_STR_LENGTH] = {0};
        DebugMsg("[Info] InstMsi is improper version for upgrade. InstMsi Version = %d, Minimum Version = %d.\n", ulSourceVer, ulMinVer);
        
        return false;
    }

    return true;
}

/////////////////////////////////////////////////////////////////////////////
// ValidateInstmsi
//

UINT ValidateInstmsi(HINSTANCE hInst, CDownloadUI *piDownloadUI, LPCSTR szAppTitle, LPSTR szInstMsiPath, LPCSTR szModuleFile, ULONG ulMinVer)
{
    UINT uiRet = ERROR_SUCCESS;

    char szShortPath[MAX_PATH]          = {0};

    // ensure instmsi is right version for Windows Installer upgrade
    if (!IsInstMsiRequiredVersion(szInstMsiPath, ulMinVer))
    {
        // instmsi won't get us the right upgrade
        PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_INCORRECT_INSTMSI, szInstMsiPath);
        return ERROR_INVALID_PARAMETER;
    }

    // upgrade msi
    uiRet = ExecuteUpgradeMsi(szInstMsiPath);
    switch (uiRet)
    {
    case ERROR_SUCCESS:
    case ERROR_SUCCESS_REBOOT_REQUIRED:
    case ERROR_SUCCESS_REBOOT_INITIATED:
//    case ERROR_INSTALL_REBOOT_NOW:
//    case ERROR_INSTALL_REBOOT:
        {
            // nothing required at this time
            break;
        }
    case ERROR_FILE_NOT_FOUND:
        {
            // instmsi executable not found
            PostFormattedError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_NOINSTMSI, szInstMsiPath);
            break;
        }
    case ERROR_INSTALL_USEREXIT:
        {
            // user cancelled the instmsi upgrade
            ReportUserCancelled(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle);
            break;
        }
    default: // failure
        {
            // report error
            PostError(hInst, piDownloadUI->GetCurrentWindow(), szAppTitle, IDS_FAILED_TO_UPGRADE_MSI);
            break;
        }
    }
    return uiRet;
}

/////////////////////////////////////////////////////////////////////////////
// ExecuteUpgradeMsi
//

DWORD ExecuteUpgradeMsi(LPSTR szUpgradeMsi)
{
    DebugMsg("[Info] Running instmsi from --> %s\n", szUpgradeMsi);

    DWORD dwResult = 0;

    // build up CreateProcess structures
    STARTUPINFO          sui;
    PROCESS_INFORMATION  pi;

    memset((void*)&pi, 0x00, sizeof(PROCESS_INFORMATION));
    memset((void*)&sui, 0x00, sizeof(STARTUPINFO));
    sui.cb          = sizeof(STARTUPINFO);
    sui.dwFlags     = STARTF_USESHOWWINDOW;
    sui.wShowWindow = SW_SHOW;

    //
    // build command line and specify delayreboot option to instmsi
    char *szCommandLine = new char[lstrlen(szUpgradeMsi) + lstrlen(szDelayReboot) + 1];

    if (!szCommandLine)
        return ERROR_OUTOFMEMORY;
    
    lstrcpy(szCommandLine, szUpgradeMsi);
    lstrcat(szCommandLine, szDelayReboot);

    //
    // run instmsi process
    if(!WIN::CreateProcess(NULL, szCommandLine, NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE, NULL, NULL, &sui, &pi))
    {
        // failed to launch.
        dwResult = GetLastError();
        return dwResult;
    }

    dwResult = WaitForProcess(pi.hProcess);
    if(ERROR_SUCCESS != dwResult)
    {
        return dwResult;
    }

    DWORD dwExitCode = 0;
    WIN::GetExitCodeProcess(pi.hProcess, &dwExitCode);

    WIN::CloseHandle(pi.hProcess);

    return dwExitCode;
}

/////////////////////////////////////////////////////////////////////////////
// ExecuteVerifyInstMsi
//
DWORD ExecuteVerifyInstMsi(LPCSTR szModuleFile, LPCSTR szInstMsiCachePath)
{
    DWORD dwResult = 0;

    // build up CreateProcess structures
    STARTUPINFO          sui;
    PROCESS_INFORMATION  pi;

    memset((void*)&pi, 0x00, sizeof(PROCESS_INFORMATION));
    memset((void*)&sui, 0x00, sizeof(STARTUPINFO));
    sui.cb          = sizeof(STARTUPINFO);
    sui.dwFlags     = STARTF_USESHOWWINDOW;
    sui.wShowWindow = SW_SHOW;

    //
    // Build command line and specify delayreboot option to instmsi
    // The seven extra characters are required for the following:
    //      2 for /v
    //      2 for the spaces before and after /v
    //      2 for the quotes enclosing the instmsi path
    //      1 for the terminating null.
    //
    char *szCommandLine = new char[lstrlen(szModuleFile) + lstrlen(szInstMsiCachePath) + 7 * sizeof(char)];

    if (!szCommandLine)
        return ERROR_OUTOFMEMORY;
    
    lstrcpy(szCommandLine, szModuleFile);
    lstrcat(szCommandLine, " /v \"");
    lstrcat(szCommandLine, szInstMsiCachePath);
    lstrcat(szCommandLine, "\"");

    //
    // Run the verification process. We use a copy of ourselves to do this.
    //
    if(!WIN::CreateProcess(NULL, szCommandLine, NULL, NULL, FALSE, CREATE_DEFAULT_ERROR_MODE, NULL, NULL, &sui, &pi))
    {
        // failed to launch.
        dwResult = GetLastError();
        return dwResult;
    }

    dwResult = WaitForProcess(pi.hProcess);
    if(ERROR_SUCCESS != dwResult)
    {
        return dwResult;
    }

    DWORD dwExitCode = 0;
    WIN::GetExitCodeProcess(pi.hProcess, &dwExitCode);

    WIN::CloseHandle(pi.hProcess);

    DebugMsg("[Info] Verification of InstMsi returned %d\n", dwExitCode);
    return dwExitCode;
}

/////////////////////////////////////////////////////////////////////////////
// WaitForProcess
//

DWORD WaitForProcess(HANDLE handle)
{
    DWORD dwResult = NOERROR;

    MSG msg;
    memset((void*)&msg, 0x00, sizeof(MSG));

    //loop forever to wait
    while (true)
    {
        //wait for object
        switch (WIN::MsgWaitForMultipleObjects(1, &handle, false, INFINITE, QS_ALLINPUT))
        {
        //success!
        case WAIT_OBJECT_0:
            goto Finish;

        //not the process that we're waiting for
        case (WAIT_OBJECT_0 + 1):
            {
                if (WIN::PeekMessage(&msg, NULL, NULL, NULL, PM_REMOVE))
                {
                    WIN::TranslateMessage(&msg);
                    WIN::DispatchMessage(&msg);
                }

                break;
            }
        //did not return an OK; return error status
        default:
            {
                dwResult = WIN::GetLastError();
                goto Finish;
            }
        }
    }

Finish:
    return dwResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\clientpp.cpp ===
// ClientPP.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "ClientPP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CClientPropertyPage property page

IMPLEMENT_DYNCREATE(CClientPropertyPage, CPropertyPage)

CClientPropertyPage::CClientPropertyPage() : CPropertyPage(CClientPropertyPage::IDD)
{
	//{{AFX_DATA_INIT(CClientPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_bClientPropSortUp = TRUE;
	m_iClientLastColumnClick = 0;
	m_iClientLastColumnClickCache = 0;

	m_bCurrentSortUp = FALSE;
	m_pCurrentListSorting = NULL;
	m_pcstrClientPropNameArray = NULL;
}

CClientPropertyPage::~CClientPropertyPage()
{
}

void CClientPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CClientPropertyPage)
	DDX_Control(pDX, IDC_CLIENTPROP, m_lstClientProp);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CClientPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CClientPropertyPage)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_CLIENTPROP, OnColumnClickClientProp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CClientPropertyPage message handlers

BOOL CClientPropertyPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	

	RECT r;
	m_lstClientProp.GetClientRect(&r);

	int widthCol1;
	int widthCol2;

	//col 1 & 2 takes up around half of area...
	widthCol1 = widthCol2 = ((r.right - r.left) / 2);
	
	m_lstClientProp.InsertColumn(0, "Property", LVCFMT_LEFT, widthCol1);
	m_lstClientProp.InsertColumn(1, "Value", LVCFMT_LEFT, widthCol2);

    //autosize last column for best look and to get rid of scroll bar
	m_lstClientProp.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);

	m_lstClientProp.SetExtendedStyle(m_lstClientProp.GetExtendedStyle() | LVS_EX_FULLROWSELECT);

	int i, count;
	if (m_pcstrClientPropNameArray)
	{
  	   count = m_pcstrClientPropNameArray->GetSize();
	   for (i = 0; i < count; i++)
	   {
          m_lstClientProp.InsertItem(i, m_pcstrClientPropNameArray->GetAt(i), 0);
		  m_lstClientProp.SetItemData(i, i);
          m_lstClientProp.SetItemText(i, 1, m_pcstrClientPropValueArray->GetAt(i));
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//nmanis, for sorting of columns...
int CALLBACK CClientPropertyPage::CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CClientPropertyPage *pDlg; //we pass "this" in to this callback...
    pDlg = (CClientPropertyPage *) lParamSort; 

    LV_FINDINFO FindItem1;
    LV_FINDINFO FindItem2;

    ZeroMemory(&FindItem1, sizeof(LV_FINDINFO));
    ZeroMemory(&FindItem2, sizeof(LV_FINDINFO));

    FindItem1.flags  = LVFI_PARAM;
    FindItem1.lParam = lParam1;

    FindItem2.flags = LVFI_PARAM;
    FindItem2.lParam = lParam2;

    int iIndexItem1 = pDlg->m_pCurrentListSorting->FindItem(&FindItem1);
    int iIndexItem2 = pDlg->m_pCurrentListSorting->FindItem(&FindItem2);

	if (pDlg->m_pCurrentListSorting)
	{
      CString str1 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem1, pDlg->m_iCurrentColumnSorting);
      CString str2 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem2, pDlg->m_iCurrentColumnSorting);
      switch (pDlg->m_iCurrentColumnSorting)
	  {
        case 0: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     
              break;

        case 1: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

              break;  //no needed, just in case we forget...
	  }
	}

    return 0;
}
//end nmanis, sorting function


void CClientPropertyPage::OnColumnClickClientProp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iClientLastColumnClick = pNMListView->iSubItem;
    if (m_iClientLastColumnClickCache == m_iClientLastColumnClick) //if click on different column, don't toggle
	{
       m_bClientPropSortUp = !m_bClientPropSortUp;  //toggle it...
	}


    m_iClientLastColumnClickCache = m_iClientLastColumnClick;  //save last header clicked

    m_pCurrentListSorting = &m_lstClientProp;
	m_iCurrentColumnSorting = m_iClientLastColumnClick;
	m_bCurrentSortUp = m_bClientPropSortUp;

    //we are going to do a custom sort...
    m_lstClientProp.SortItems(CompareFunc, (LPARAM) this);
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\loganald.cpp ===
// LogAnalD.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "LogAnalD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "PropD.h"
#include "StatesD.h"
#include "util.h"

/////////////////////////////////////////////////////////////////////////////
// CLogAnalyzeDlg dialog


CLogAnalyzeDlg::CLogAnalyzeDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CLogAnalyzeDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CLogAnalyzeDlg)
	m_cstrSolution = _T("");
	m_cstrError = _T("");
	m_cstrDateTime = _T("");
	m_cstrUser = _T("");
	m_cstrClientCMD = _T("");
	m_bAdminRights = FALSE;
	m_cstrVersion = _T("");
	m_cstrClientPrivDetail = _T("");
	m_cstrServerPrivDetail = _T("");
	m_bShowIgnoredDebugErrors = FALSE;
	//}}AFX_DATA_INIT

//m_cstrProduct = _T(""); 5-16-2001, no longer used...
	m_LineCount = 0;
	m_bErrorFound = FALSE;

	CWILogUtilApp *pApp = (CWILogUtilApp *) AfxGetApp();
	if (pApp)
	{
       m_cstrOutputDir = pApp->GetOutputDirectory();
	}

    m_cstrLegendName = "legend.htm";
	m_cstrDetailsName = "details_";

//does the tool support future versions of WI?
	m_bLogVersionAllowed = TRUE;

	m_dwVersionMajorReject = 3; //reject versions 3.01 and higher by default...  Change in GUI...
	m_dwVersionMinorReject = 01;  

    m_dwVersionMajorLogCreated = 0;
	m_dwVersionMinorLogCreated = 0;
	m_dwVersionBuildLogCreated = 0;

//if we don't find anything, have it set to (none)
	m_cstrUser = _T("(none)");
//	m_cstrProduct = _T("(none)"); //5-16-2001, no longer used...
	m_cstrClientPrivDetail = _T("(none)");
	m_cstrServerPrivDetail = _T("(none)");
}


void CLogAnalyzeDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLogAnalyzeDlg)
	DDX_Text(pDX, IDC_SOLUTION, m_cstrSolution);
	DDX_Text(pDX, IDC_ERROR, m_cstrError);
	DDX_Text(pDX, IDC_DATETIME, m_cstrDateTime);
	DDX_Text(pDX, IDC_USER, m_cstrUser);
	DDX_Text(pDX, IDC_CLIENTCMDLINE, m_cstrClientCMD);
	DDX_Check(pDX, IDC_ADMINRIGHTS, m_bAdminRights);
	DDX_Text(pDX, IDC_VERSION, m_cstrVersion);
	DDX_Text(pDX, IDC_CLIENTPRIVILEDGEDETAIL, m_cstrClientPrivDetail);
	DDX_Text(pDX, IDC_SERVERPRIVILEDGEDETAIL, m_cstrServerPrivDetail);
	DDX_Check(pDX, IDC_SHOW_IGNORED_ERRORS, m_bShowIgnoredDebugErrors);
	//}}AFX_DATA_MAP

	//DDX_Text(pDX, IDC_PRODUCT, m_cstrProduct); //5-16-2001, no longer used...
}


BEGIN_MESSAGE_MAP(CLogAnalyzeDlg, CDialog)
	//{{AFX_MSG_MAP(CLogAnalyzeDlg)
	ON_BN_CLICKED(IDC_SHOWSTATES, OnShowstates)
	ON_BN_CLICKED(IDC_SHOWPROP, OnShowprop)
	ON_BN_CLICKED(IDC_EXPLAINLOG, OnExplainlog)
	ON_BN_CLICKED(IDC_POLICIES, OnPolicies)
	ON_BN_CLICKED(IDC_NEXTERROR, OnNexterror)
	ON_BN_CLICKED(IDC_PREVIOUSERROR, OnPreviouserror)
	ON_COMMAND(ID_OPERATIONS_OPTIONS, OnOperationsOptions)
	ON_COMMAND(ID_OPERATIONS_GENERATEHTMLOUTPUT, OnOperationsGeneratehtmloutput)
	ON_COMMAND(ID_OPERATIONS_SHOWPOLICIES, OnOperationsShowpolicies)
	ON_COMMAND(ID_OPERATIONS_SHOWPROPERTIES, OnOperationsShowproperties)
	ON_COMMAND(ID_OPERATIONS_SHOWSTATES, OnOperationsShowstates)
	ON_BN_CLICKED(IDC_SHOW_IGNORED_ERRORS, OnShowIgnoredErrors)
	ON_BN_CLICKED(IDC_PROPTEST, OnProptest)
	ON_BN_CLICKED(IDC_SAVERESULTS, OnSaveresults)
	ON_BN_CLICKED(IDC_SHOWINTERNALERRORSHELP, OnShowinternalerrorshelp)
	ON_BN_CLICKED(IDC_DELETEOUTPUTDIRCONTENTS, OnDeleteoutputdircontents)
	ON_BN_CLICKED(IDC_SHOWHELP, OnShowhelp)
	ON_BN_CLICKED(IDC_SHOWHOWTOREADLOG, OnShowhowtoreadlog)
	//}}AFX_MSG_MAP

//5-9-2001, add tooltips!!!
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT,0,0xFFFF,OnToolTipNotify)
END_MESSAGE_MAP()


void CLogAnalyzeDlg::ShowLogRejectedMessage()
{
   if (!g_bRunningInQuietMode)
   {
	  CString strVersion;
	  CString strVersionReject;

	  strVersion.Format("Log Version: %d.%d\n", m_dwVersionMajorLogCreated, m_dwVersionMinorLogCreated);
	  strVersionReject.Format("Non-supported versions and higher: %d.%d", m_dwVersionMajorReject, m_dwVersionMinorReject);

	  CString strMessage = "Log file created with version higher than this tool supports\n\n";
	  CString strWarning = strMessage + strVersion + strVersionReject;

	  if (!g_bRunningInQuietMode)
	  {
	     AfxMessageBox(strWarning);
	  }
   }
}

BOOL CLogAnalyzeDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

//5-16-2001
	if (g_bShowEverything)
	{
	    CWnd *pWnd = GetDlgItem(IDC_SHOWPROP);
		if (pWnd)
		{
			pWnd->ShowWindow(SW_SHOW);
		}

		pWnd = GetDlgItem(IDC_DELETEOUTPUTDIRCONTENTS);
		if (pWnd)
		{
			pWnd->ShowWindow(SW_SHOW);
		}
	}
//end 5-16-2001

	AnalyzeLog(); //do the parsing and analysis

	EnableToolTips(TRUE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CLogAnalyzeDlg::OnToolTipNotify(UINT id, NMHDR *pNMH, LRESULT *pResult)
{
       TOOLTIPTEXT *pText = (TOOLTIPTEXT *)pNMH;
       int control_id =  ::GetDlgCtrlID((HWND)pNMH->idFrom);
       if(control_id)
       {
           pText->lpszText = MAKEINTRESOURCE(control_id);
           pText->hinst = AfxGetInstanceHandle();
           return TRUE;
       }
       return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CLogAnalyzeDlg message handlers
void CLogAnalyzeDlg::OnShowstates() 
{
  if (!m_bLogVersionAllowed)
  {
	 ShowLogRejectedMessage();
	 return;
  }

  CStatesDlg dlg;

  dlg.SetComponentNames(&this->m_cstrComponentNameArray);
  dlg.SetComponentInstalled(&this->m_cstrComponentInstalledArray);
  dlg.SetComponentRequest(&this->m_cstrComponentRequestArray);
  dlg.SetComponentAction(&this->m_cstrComponentActionArray);

  dlg.SetFeatureNames(&this->m_cstrFeatureNameArray);
  dlg.SetFeatureInstalled(&this->m_cstrFeatureInstalledArray);
  dlg.SetFeatureRequest(&this->m_cstrFeatureRequestArray);
  dlg.SetFeatureAction(&this->m_cstrFeatureActionArray);

  //5-3-2001, don't show in quiet mode...
  if (!g_bRunningInQuietMode)
	 dlg.DoModal();
}


void CLogAnalyzeDlg::OnShowprop() 
{
  if (!m_bLogVersionAllowed)
  {
	 ShowLogRejectedMessage();
	 return;
  }

  CPropDlg dlg;

  dlg.SetClientPropNames(&this->m_cstrClientPropNameArray);
  dlg.SetClientPropValues(&this->m_cstrClientPropValueArray);

  dlg.SetServerPropNames(&this->m_cstrServerPropNameArray);
  dlg.SetServerPropValues(&this->m_cstrServerPropValueArray);

  dlg.SetNestedPropNames(&this->m_cstrNestedPropNameArray);
  dlg.SetNestedPropValues(&this->m_cstrNestedPropValueArray);

  //5-3-2001, don't show in quiet mode...
  if (!g_bRunningInQuietMode)
     dlg.DoModal();
}


void CLogAnalyzeDlg::DoInitialization()
{
	m_cstrClientPropNameArray.RemoveAll();
	m_cstrClientPropValueArray.RemoveAll();
	
	m_cstrServerPropNameArray.RemoveAll();
	m_cstrServerPropValueArray.RemoveAll();

	m_cstrNestedPropNameArray.RemoveAll();
	m_cstrNestedPropValueArray.RemoveAll();

	m_iTotalNonIgnoredErrors = 0;
	m_iCurrentNonIgnoredError = 0;

    m_iCurrentIgnoredError = 0;
	m_iTotalIgnoredErrors = 0;

	InitMachinePolicySettings(m_MachinePolicySettings);
	InitUserPolicySettings(m_UserPolicySettings);

//init the colors to use when generating HTML...
	InitColorMembers();

	CWILogUtilApp *pApp = (CWILogUtilApp *) AfxGetApp();
	if (pApp)
	{
	   m_cstrIgnoredErrors = pApp->GetIgnoredErrors();
	}
}

void CLogAnalyzeDlg::DoResults()
{
	if (m_iTotalNonIgnoredErrors > 1)
	{
		m_iCurrentNonIgnoredError = 1;
		CWnd *pWnd;
		pWnd = GetDlgItem(IDC_NEXTERROR);
		if (pWnd)
		   pWnd->EnableWindow();

		WIErrorInfo *pErrorInfo;
		pErrorInfo = m_arNonIgnorableErrorArray.GetAt(m_iCurrentNonIgnoredError);
		if (pErrorInfo)
		{
  	 	   m_cstrError = pErrorInfo->cstrError;
           m_cstrSolution = pErrorInfo->cstrSolution;
		}
	}
	else if (m_iTotalNonIgnoredErrors == 1)
	{
		m_iCurrentNonIgnoredError = 1;

		WIErrorInfo *pErrorInfo;
		pErrorInfo = m_arNonIgnorableErrorArray.GetAt(m_iCurrentNonIgnoredError);
		if (pErrorInfo)
		{
  	 	   m_cstrError = pErrorInfo->cstrError;
           m_cstrSolution = pErrorInfo->cstrSolution;
		}
	}
	else if (m_iTotalNonIgnoredErrors == 0)
	{
 	   m_cstrError.LoadString(IDS_NOERRORFOUND);
       m_cstrSolution.LoadString(IDS_NOSOLUTION_NEEDED);
	}

    CString str;
	str.Format("%d", m_iCurrentNonIgnoredError);
	CWnd *pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
	if (pWnd)
	{
		pWnd->SetWindowText(str);
	}                

	str.Format("%d", this->m_iTotalNonIgnoredErrors);
	pWnd = GetDlgItem(IDC_TOTAL_ERRORS);
	if (pWnd)
	{
		pWnd->SetWindowText(str);
	}

	if (m_iTotalIgnoredErrors) //and also a tracker for where current pos is in ignored errors...
	   m_iCurrentIgnoredError = 1;

    if (!g_bRunningInQuietMode)
	   UpdateData(FALSE);
}

//5-4-2001
void CLogAnalyzeDlg::DoSummaryResults(CString &cstrFileName)
{
	FILE *fptr;
    fptr = fopen(cstrFileName, "w");
	if (fptr)
	{
	   CString cstrLine;
	   cstrLine.Format("Summary for log file %s\r\n", m_cstrLogFileName);
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n";
	   fputs(cstrLine, fptr);

	   cstrLine.Format("MSI Version : %s\r\n\r\n", m_cstrVersion) ;
	   fputs(cstrLine, fptr);

   	   cstrLine.Format("Date & Time : %s\r\n\r\n", m_cstrDateTime) ;
	   fputs(cstrLine, fptr);

//5-16-2001, no longer used...
//	   cstrLine.Format("Product     : %s\r\n\r\n", m_cstrProduct);
//	   fputs(cstrLine, fptr);

	   cstrLine.Format("Command Line: %s\r\n\r\n", m_cstrClientCMD);
	   fputs(cstrLine, fptr);

	   cstrLine.Format("User        : %s\r\n\r\n", m_cstrUser);
	   fputs(cstrLine, fptr);

	   CString cstrAnswer = "Yes";
	   if (!m_bAdminRights)
	   {
          cstrAnswer = "No";
	   }
	   
	   cstrLine.Format("Admin Rights: %s\r\n\r\n", cstrAnswer);
   	   fputs(cstrLine, fptr);

	   cstrLine.Format("Client Priviledge Details: %s\r\n\r\n", m_cstrClientPrivDetail);
	   fputs(cstrLine, fptr);

	   cstrLine.Format("Server Priviledge Details: %s\r\n\r\n", m_cstrServerPrivDetail);
	   fputs(cstrLine, fptr);

	   cstrLine = "======================================================\r\n";
	   fputs(cstrLine, fptr);

  	   CString cstrError = "No Error Found!";
	   CString cstrSolution = "No Solution Needed!";

       WIErrorInfo *pErrorInfo = NULL;
	   int iSize = m_arNonIgnorableErrorArray.GetSize();
	   if (iSize) //print out first error found...
 		  pErrorInfo = m_arNonIgnorableErrorArray.GetAt(1); //HACKHACK, 0 is no error record, 1 is first error

	   if (pErrorInfo)
	   {
          cstrError    = pErrorInfo->cstrError;
          cstrSolution = pErrorInfo->cstrSolution;
	   }

   	   cstrLine.Format("Believed Error Found:\r\n\r\n%s\r\n\r\n", cstrError);
	   fputs(cstrLine, fptr);

   	   cstrLine.Format("Proposed Solution To Error:\r\n  %s\r\n\r\n", cstrSolution);
	   fputs(cstrLine, fptr);

       fclose(fptr);
	   fptr = NULL;
	}
}
//end 5-4-2001

//5-4-2001
void CLogAnalyzeDlg::DoPolicyResults(CString &cstrFileName)
{
	FILE *fptr;
    fptr = fopen(cstrFileName, "w");
	if (fptr)
	{
	   CString cstrLine;
	   cstrLine.Format("Policies Set For Log File %s\r\n", m_cstrLogFileName);
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n\r\n";
	   fputs(cstrLine, fptr);

	   cstrLine = "Machine Policies\r\n";
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n";
	   fputs(cstrLine, fptr);

	   int iSize = m_MachinePolicySettings.iNumberMachinePolicies;
	   CString cstrValue;
	   for (int i =0; i < iSize; i++)
	   {
           if (m_MachinePolicySettings.MachinePolicy[i].bSet == -1)
			  cstrValue = "?";
		   else 
			  cstrValue.Format("%d", m_MachinePolicySettings.MachinePolicy[i].bSet);

		   cstrLine.Format("%-25s: %s\r\n", m_MachinePolicySettings.MachinePolicy[i].PolicyName, cstrValue);
		   fputs(cstrLine, fptr);
	   }

	   cstrLine = "\r\nUser Policies\r\n";
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n";
	   fputs(cstrLine, fptr);

   	   int iSize2 = m_UserPolicySettings.iNumberUserPolicies;
	   for (int j =0; j < iSize2; j++)
	   {
           if (m_UserPolicySettings.UserPolicy[j].bSet == -1)
			  cstrValue = "?";
		   else 
			  cstrValue.Format("%d", m_UserPolicySettings.UserPolicy[j].bSet);

		   cstrLine.Format("%-25s: %s\r\n", m_UserPolicySettings.UserPolicy[j].PolicyName, cstrValue);
           fputs(cstrLine, fptr);
	   }

       fclose(fptr);
	   fptr = NULL;
	}
}
//5-4-2001


void CLogAnalyzeDlg::DoErrorResults(CString &cstrFileName)
{
	FILE *fptr;
    fptr = fopen(cstrFileName, "w");
	if (fptr)
	{
	   CString cstrLine;
	   cstrLine.Format("Errors Found For Log File %s\r\n", m_cstrLogFileName);
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n\r\n";
	   fputs(cstrLine, fptr);

	   cstrLine.Format("%d Non-Ignored Errors\r\n", m_iTotalNonIgnoredErrors);
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n";
	   fputs(cstrLine, fptr);


	   {
       CString cstrError = "No Error Found!";
	   CString cstrSolution = "No Solution Needed!";

       WIErrorInfo *pErrorInfo = NULL;
	   int iSize = m_arNonIgnorableErrorArray.GetSize();
	   if (iSize) //print out first error found...
 		  pErrorInfo = m_arNonIgnorableErrorArray.GetAt(1); //HACKHACK, 0 is no error record, 1 is first error

	   if (iSize)
	   {
	     for (int i =1; i < iSize; i++)
		 {
			 pErrorInfo = m_arNonIgnorableErrorArray.GetAt(i);
	         if (pErrorInfo)
			 {
                cstrError    = pErrorInfo->cstrError;
                cstrSolution = pErrorInfo->cstrSolution;
			 }

			 cstrLine = "-------------------------------------------------\r\n";
             fputs(cstrLine, fptr);

             cstrLine.Format("Believed Error Found:\r\n%s\r\n\r\n", cstrError);
	         fputs(cstrLine, fptr);

             cstrLine.Format("Proposed Solution To Error:\r\n  %s\r\n\r\n", cstrSolution);
	         fputs(cstrLine, fptr);
		 }
	   }
	   else //no error!!!
	   {
	       cstrLine = "-------------------------------------------------\r\n";
           fputs(cstrLine, fptr);

  	       cstrLine.Format("Believed Error Found:\r\n%s\r\n\r\n", cstrError);
	       fputs(cstrLine, fptr);

           cstrLine.Format("Proposed Solution To Error:\r\n  %s\r\n\r\n", cstrSolution);
           fputs(cstrLine, fptr);
	   }
	   }
		
   	   cstrLine.Format("\r\n%d Ignored Errors\r\n", m_iTotalIgnoredErrors);
	   fputs(cstrLine, fptr);

   	   cstrLine = "======================================================\r\n";
	   fputs(cstrLine, fptr);

	   {
       CString cstrError = "No Error Found!";
	   CString cstrSolution = "No Solution Needed!";

       WIErrorInfo *pErrorInfo = NULL;
	   int iSize = m_arIgnorableErrorArray.GetSize();
	   if (iSize) //print out first error found...
 		  pErrorInfo = m_arIgnorableErrorArray.GetAt(1); //HACKHACK, 0 is no error record, 1 is first error

	   if (iSize)
	   {
	     for (int i =1; i < iSize; i++)
		 {
			 pErrorInfo = m_arIgnorableErrorArray.GetAt(i);
	         if (pErrorInfo)
			 {
                cstrError    = pErrorInfo->cstrError;
                cstrSolution = pErrorInfo->cstrSolution;
			 }

			 cstrLine = "-------------------------------------------------\r\n";
             fputs(cstrLine, fptr);

             cstrLine.Format("Believed Error Found:\r\n%s\r\n\r\n", cstrError);
	         fputs(cstrLine, fptr);

             cstrLine.Format("Proposed Solution To Error:\r\n  %s\r\n\r\n", cstrSolution);
	         fputs(cstrLine, fptr);
		 }
	   }
	   else //no error!!!
	   {
		   cstrLine = "-------------------------------------------------\r\n";
           fputs(cstrLine, fptr);

		   cstrLine.Format("Believed Error Found:\r\n%s\r\n\r\n", cstrError);
	       fputs(cstrLine, fptr);

           cstrLine.Format("Proposed Solution To Error:\r\n  %s\r\n\r\n", cstrSolution);
           fputs(cstrLine, fptr);
	   }
	   }

       fclose(fptr);
	   fptr = NULL;
	}	
}


void CLogAnalyzeDlg::DoQuietModeResults()
{
	CString cstrFileName;

	//get only log file name...
	int iPos = m_cstrLogFileName.ReverseFind('\\');
	CString strLogNameOnly;

	strLogNameOnly = m_cstrLogFileName;

	char *lpszBuffer = { 0 };
	lpszBuffer = m_cstrLogFileName.GetBuffer(MAX_PATH);

	if (iPos > 0)
	   strLogNameOnly = &lpszBuffer[iPos+1];
    m_cstrLogFileName.ReleaseBuffer();

	CString cstrLogSummary;
	cstrLogSummary = strLogNameOnly + "_Summary.txt";
	cstrFileName =  m_cstrOutputDir + cstrLogSummary;
    DoSummaryResults(cstrFileName);

    CString cstrLogPolicies;
	cstrLogPolicies = strLogNameOnly + "_Policies.txt";
	cstrFileName =  m_cstrOutputDir + cstrLogPolicies;
	DoPolicyResults(cstrFileName);

    CString cstrLogErrors;
	cstrLogErrors = strLogNameOnly + "_Errors.txt";
	cstrFileName =  m_cstrOutputDir + cstrLogErrors;
    DoErrorResults(cstrFileName);
}



BOOL CLogAnalyzeDlg::DoDetectError(char *szLine, BOOL *pbIgnorableError)
{
	BOOL bRet = FALSE;

	int indexStop = LINES_ERROR; 

	if (m_LineCount >= LINES_ERROR)
	{
	  for (int i = 0; i < LINES_ERROR-1; i++)
          strcpy(&m_szErrorLines[i][0], &m_szErrorLines[i+1][0]);

	  strcpy(&m_szErrorLines[i][0], szLine);
	}
	else
	{
//first few lines are header of log...
	   indexStop =  m_LineCount+1;
	   strcpy(&m_szErrorLines[m_LineCount][0], szLine);
	}


	BOOL bInternalInstallerError = FALSE;
	BOOL bOtherError = FALSE;

	int iErrorNumber;

	char szSolutions[SOLUTIONS_BUFFER] = "Could not determine solution";
	bRet = m_LogParser.DetectCustomActionError(szLine, szSolutions, pbIgnorableError);
    if (!bRet) //check the other types of possible errors...
	{
		bRet = m_LogParser.DetectInstallerInternalError(szLine, szSolutions, pbIgnorableError, &iErrorNumber);
        if (!bRet)
		{
		   bRet = m_LogParser.DetectWindowsError(szLine, szSolutions, pbIgnorableError);
		   if (!bRet)
		   {
              bRet = m_LogParser.DetectOtherError(szLine, szSolutions, pbIgnorableError, &iErrorNumber);
			  if (bRet)
                 bOtherError = TRUE; //1601, etc...
		   }
		}
	    else
		{
  	   	   bInternalInstallerError = TRUE; //2351, etc...
		}
	}

	if (bRet)
	{
  	   m_cstrError = &m_szErrorLines[0][0];

	   CString temp;
	   int len;
       for (int i=1; i < indexStop; i++)
	   {
           len = strlen(&m_szErrorLines[i][0]);

		   temp = &m_szErrorLines[i][0];
           
//5-10-2001...
           if (i == indexStop-1)
		   {
              if ((!bInternalInstallerError && !bOtherError) || //not an error we are going to provide HTML link to?
				  g_bRunningInQuietMode) //don't put HTML tags in error number if running in quiet mode...
                 m_cstrError += temp;
			  else //not quiet mode and an error we can generate an HTML jump tag too in our error help file..
			  {
			     if (bInternalInstallerError)
				 {
/*
					char szLine[8192];
					char *szErrFound;

					strcpy(szLine, &m_szErrorLines[i][0]);

					CString strErr;
					strErr.Format("%d", iErrorNumber);
					szErrFound = strstr(szLine, strErr);
					if (szErrFound)
					{
                       //replace the error with an HREF!!!
                       CString strURL;

	  	  	  	       CString cstrOut;
                       cstrOut = m_cstrOutputDir + "\\" + "InternalWIErrors.html";
					   cstrOut.Replace('\\', '/');

					   strURL.Format("file:///%s#ERR%d", cstrOut, iErrorNumber);

//					   strURL.Format("http://www.msn.com");
//					   strURL.Format("file:///%s#ERR%d", cstrOut, iErrorNumber);

	                  
					   int n;
					   char szFirstPart[8192];
					   n = szErrFound - szLine;
					   strncpy(szFirstPart, szLine, n);
                       szFirstPart[n] = '\0';
 
                       CString cstrOutLine;
					   cstrOutLine.Format("%s %s %s", szFirstPart, strURL, szErrFound+4);

					   m_cstrError += cstrOutLine;
					}
*/
					m_cstrError += temp;
				 } 

			     if (bOtherError)
				 {
                    m_cstrError += temp;
				 }
			  }
		   }
		   else
		   {
              m_cstrError += temp;
		   }
//end 5-10-2001...
	   }

       m_cstrSolution = szSolutions;

	   WIErrorInfo *pErrorInfo = new WIErrorInfo;
	   if (pErrorInfo)
	   {
 	      pErrorInfo->cstrError = m_cstrError;
	      pErrorInfo->cstrSolution = szSolutions;
		  pErrorInfo->bIgnorableError = *pbIgnorableError;

//hack hack, makes easier to handle next/previous as this makes array become 1 based, not 0.
		  if ((m_iTotalNonIgnoredErrors == 0) && (!*pbIgnorableError))
		  {
			 WIErrorInfo *pErrorInfo2 = new WIErrorInfo;

			 pErrorInfo2->cstrError.LoadString(IDS_NOERRORFOUND);
			 pErrorInfo2->cstrSolution.LoadString(IDS_NOSOLUTION_NEEDED);
             pErrorInfo2->bIgnorableError = TRUE;

             m_arNonIgnorableErrorArray.Add(pErrorInfo2); //adds first one twice...
		  }

  		  if ((m_iTotalIgnoredErrors == 0) && (*pbIgnorableError))
		  {
			 WIErrorInfo *pErrorInfo2 = new WIErrorInfo;
			 pErrorInfo2->cstrError = "No Error Found!";
    		 pErrorInfo2->cstrSolution = "No solution needed!";
             pErrorInfo2->bIgnorableError = TRUE;

             m_arIgnorableErrorArray.Add(pErrorInfo2); //adds first one twice...
		  }

		 if (!*pbIgnorableError)
		 {
            m_arNonIgnorableErrorArray.Add(pErrorInfo);
            m_iTotalNonIgnoredErrors++;			
		 }
		 else
		 {
            m_arIgnorableErrorArray.Add(pErrorInfo);

			m_iTotalIgnoredErrors++;
		 }
	   }
	   else
	   {
		   //out of memory!!!
	   }
	}

	return bRet;
}


//this is tricky shit...
BOOL CLogAnalyzeDlg::DoDetectProperty(char *szLine)
{
	BOOL bRet = FALSE;

    char szPropName[128] = { 0 };
    char szPropValue[8192] = { 0 };

	int iPropType;

	bRet = m_LogParser.DetectProperty(szLine, szPropName, szPropValue, &iPropType);
	if (bRet)
	{
		if (SERVER_PROP == iPropType)
		{
		   m_cstrServerPropNameArray.Add(szPropName);
		   m_cstrServerPropValueArray.Add(szPropValue);
		}

		if (CLIENT_PROP == iPropType)//client prop
		{
      	   m_cstrClientPropNameArray.Add(szPropName);
		   m_cstrClientPropValueArray.Add(szPropValue);
		}

		if (NESTED_PROP == iPropType)
		{
      	   m_cstrNestedPropNameArray.Add(szPropName);
		   m_cstrNestedPropValueArray.Add(szPropValue);
		}
	}

	return bRet;
}


BOOL CLogAnalyzeDlg::DoDetectStates(char *szLine)
{
	BOOL bRet = FALSE;
	static BOOL bFeatureStateLast = FALSE;
    static BOOL bFeatreState = TRUE;

    char szName[128] = { 0 };
    char szInstalled[64] = { 0 };
	char szRequest[64] = { 0 };
	char szAction[64] = { 0 };

	bRet = m_LogParser.DetectFeatureStates(szLine, szName, szInstalled, szRequest, szAction);
	if (bRet)
	{
	   m_cstrFeatureNameArray.Add(szName);
	   m_cstrFeatureInstalledArray.Add(szInstalled);
	   m_cstrFeatureRequestArray.Add(szRequest);
	   m_cstrFeatureActionArray.Add(szAction);
	}
	else
	{
	   BOOL bInternalComponent = FALSE;
 	   bRet = m_LogParser.DetectComponentStates(szLine, szName, szInstalled, szRequest, szAction, &bInternalComponent);
	   if (bRet)
	   {
//5-16-2001
          if (!g_bShowEverything && bInternalComponent)
		  {
             //don't show it in our UI, but do in HTML.
			 //it was an internal component and verbose switch is not set by end user...
		  }
//end 5-16-2001
		  else
		  {
  		     m_cstrComponentNameArray.Add(szName);
		     m_cstrComponentInstalledArray.Add(szInstalled);
		     m_cstrComponentRequestArray.Add(szRequest);
		     m_cstrComponentActionArray.Add(szAction);
		  }
	   }
	}

	return bRet;
}


BOOL CLogAnalyzeDlg::DoDetectPolicy(char *szLine)
{
	BOOL bRet = FALSE;

    bRet = m_LogParser.DetectPolicyValue(szLine, m_MachinePolicySettings, m_UserPolicySettings);
    return bRet;
}


BOOL CLogAnalyzeDlg::DoDetectElevatedInstall(char *szLine)
{
	BOOL bRet = FALSE;
	BOOL bElevatedInstall = FALSE;
	BOOL bClient = FALSE;

    bRet = m_LogParser.DetectElevatedInstall(szLine, &bElevatedInstall, &bClient);
	if (bRet)
	{
		m_bAdminRights = bElevatedInstall;
        StripLineFeeds(szLine);

		if (bClient)
  	       m_cstrClientPrivDetail = szLine;
		else
		{
		   m_cstrServerPrivDetail = m_cstrLastLine;
           m_cstrServerPrivDetail += szLine;
		}

		if (!g_bRunningInQuietMode)
		   UpdateData(FALSE); //update controls...
	}

    return bRet;
}


//header is in first ten lines or so...
#define HEADER_END 10

//first see if version of log is supported
//we parse the date/time, product, user and the commandline
//Then we will start parsing each line in log
BOOL CLogAnalyzeDlg::DoParse(char *ansibuffer)
{
    int iLineLength = strlen(ansibuffer);

    //line is read in now
    BOOL bState = FALSE;

//following is done to speed up parsing by not doing header stuff every time...
	if (m_LineCount == 1) //parsing first line in file?
	{
       bState = m_LogParser.DetectWindowInstallerVersion(ansibuffer, &m_dwVersionMajorLogCreated, &m_dwVersionMinorLogCreated,  &m_dwVersionBuildLogCreated);

	   m_cstrVersion.Format("%d.%d.%d", m_dwVersionMajorLogCreated, m_dwVersionMinorLogCreated,  m_dwVersionBuildLogCreated);

	   if (!g_bShowEverything)  //go ahead and try to parse any version if hidden switch is on...
	   {
	      if (m_dwVersionMajorLogCreated > m_dwVersionMajorReject) //major version is too great...
		  {
             m_bLogVersionAllowed = FALSE; //stop the logging process...
		     bState = TRUE;
		     return bState;
		  }

	      //major version may be equal or greater and minor version may be too high...
	      if ( (m_dwVersionMajorLogCreated >= m_dwVersionMajorReject) && 
		     (m_dwVersionMinorLogCreated >= m_dwVersionMinorReject))
		  {
             m_bLogVersionAllowed = FALSE; //stop the logging process...
 		     bState = TRUE;
		     return bState; 
		  }
	   }
	}

/*  5-16-2001
	//do date/time
  	if (m_LineCount == 1)				
	{
 		char szDateTime[256];
        bState = m_LogParser.DoDateTimeParse(ansibuffer, szDateTime);              
		if (bState)
		{
			m_cstrDateTime = szDateTime;
		}
	}
*/
//end optimization...

//maybe we could speed up further by checking if m_cstrProduct is non-null?
//nmanis, 2-13-2001, added check below...

//5-16-2001, deemed that this info is not too useful
/*
	//do product parse (everytime until we find it...)
	if (!bState && m_cstrProduct.IsEmpty())
	{
	   char *lpszProduct;
	   lpszProduct = new char[iLineLength];

       bState = m_LogParser.DoProductParse(ansibuffer, lpszProduct);
	   if (bState)
	   {
		  m_cstrProduct = lpszProduct;
	   }

	   delete lpszProduct;
	}
*/

    //do user parse...
    if (!bState)
	{
	   char *lpszUser;
	   lpszUser = new char[iLineLength];

       bState = m_LogParser.DoUserParse(ansibuffer, lpszUser);
	   if (bState)
	   {
		  m_cstrUser = lpszUser;
	   }

	   delete lpszUser;
	}

	//do client command line
	if (m_LineCount <= HEADER_END && !bState)
	{
	   char *lpszCommandLine;
	   lpszCommandLine = new char[iLineLength];
 
	   bState = m_LogParser.DoCommandLineParse(ansibuffer, lpszCommandLine);
	   if (bState)
	   {
          m_cstrClientCMD = lpszCommandLine;
	   }

	   delete lpszCommandLine;
	}

	if (!bState)
	{
       BOOL bIgnorableError = FALSE;
	   
//Added next line back as of Ver 1.0.9
	   bState = DoDetectError(ansibuffer, &bIgnorableError);
	   if (!bState)
	   {
	      bState = DoDetectProperty(ansibuffer);
		  if (!bState)
		  {
             bState = DoDetectStates(ansibuffer);
		     if (!bState)
			 {
                bState = DoDetectPolicy(ansibuffer);
  		        if (!bState)
				{
				    bState = DoDetectElevatedInstall(ansibuffer);
					if (!bState)
					{
                       AddGenericLineToHTML(ansibuffer); //who knows...  annotate with usual stuff...
					}
					else
                    {
                       AddGenericLineToHTML(ansibuffer); //still add line as a generic line to HTML, this could change however...
					}
				}
				else //hit policy line
				{
					AddPolicyLineToHTML(ansibuffer);
				}
			 }
			 else //hit state line...
			 {
                AddStateLineToHTML(ansibuffer);
			 }
		  }
		  else //hit property line...
		  {
             AddPropLineToHTML(ansibuffer);
		  }
	   }
	   else //hit error line...
	   {
          AddErrorLineToHTML(ansibuffer, bIgnorableError);
		  m_bErrorFound = TRUE; //mark current log as having an error we found...
	   }
	}
	else //5-16-2001, make sure header is added too...
	{
       AddGenericLineToHTML(ansibuffer); //still add line as a generic line to HTML, this could change however...
	}

	return bState;
}


BOOL CLogAnalyzeDlg::AnalyzeLog()
{
	//5-3-2001
	DoInitialization();

	BOOL bRet = DetermineLogType(m_cstrLogFileName, &m_bIsUnicodeLog);
	if (bRet)
	{
		//Tell parser object what kind of log we are looking at...
		m_LogParser.SetLogType(m_bIsUnicodeLog);

		char *szOpenMode = "rb";
	    if (!m_bIsUnicodeLog) //logs are different on NT vs.Win9x.  On NT, they are written in UNICODE, open them differently...
           szOpenMode = "r"; //don't open binary if Win9x...

	    FILE *fptr = fopen(m_cstrLogFileName, szOpenMode);
	    if (fptr) //open log...
		{
	       char ansibuffer[LOG_BUF_READ_SIZE+1]; //+1, room to grow...

	       BOOL bEndFile = FALSE;
		   BOOL bError = FALSE;
		   char  *pos = NULL;
		   WCHAR *wpos = NULL;

		   CWaitCursor *pwc = NULL;
	
		   //need to make sure wait cursor does not appear when in quiet mode...
           if (!g_bRunningInQuietMode)
		   {
  	          pwc = new CWaitCursor; //show wait cursor while reading/processing file...
		   }

		   do //start reading log
		   {
		     if (m_bIsUnicodeLog) //logs are different on NT vs. Win9x.  On NT, they are written in UNICODE...
			 {
			    const int HalfBufSize = LOG_BUF_READ_SIZE/2;
		        WCHAR widebuffer[HalfBufSize];

			    wpos = fgetws(widebuffer, HalfBufSize, fptr);
			    bError = wpos ? 0 : 1;

				//convert string to ANSI string, all parsing is done with ANSI strings...
		        WideCharToMultiByte(CP_ACP, 0, widebuffer, HalfBufSize, ansibuffer, LOG_BUF_READ_SIZE, NULL, NULL);
			 }
		     else
			 {
		        //do line by line read with fgets()
		        pos = fgets(ansibuffer, LOG_BUF_READ_SIZE, fptr);
			    bError = pos ? 0 : 1;

//minor hack...
				StripLineFeeds(ansibuffer);
				strcat(ansibuffer, "\r\n");
//minor hack...
			 }

 			 if (!bError) //if line read ok...
			 {
				m_LineCount++; //if no error increment line number just read
				bRet = DoParse(ansibuffer); //bRet will be true if was able to figure out what the line was...

				m_cstrLastLine = ansibuffer; //save last line... 2-13-2001
			 }

		     bEndFile = feof(fptr);
		   }
		   while (!bEndFile && !bError && m_bLogVersionAllowed);

		   if (!g_bRunningInQuietMode)
		   {
  	          if (pwc)
			  {
				  delete pwc;
				  pwc = NULL;
			  }
		   }

		   if (!bEndFile && !bError) //error occured...
		   {
#ifdef _DEBUG
		      if (!g_bRunningInQuietMode)
			  {
				 if (fptr)
				 {
  		            int iError = ferror(fptr);

		            CString cstrErr;
		            cstrErr.Format("Unexpected Error reading file, error = %d", iError);

                    AfxMessageBox(cstrErr);
				 }
			  }
#endif
		   }

		   fclose(fptr);

		   if (m_bLogVersionAllowed) //if this log is allowed, we will update GUI
		   {
  		      if (!m_bErrorFound)
			  {
                 AddErrorLineSuccessToHTML(); //no error hit, update Error area too...
		         m_cstrError = "No Error was found!  Install succeeded?";
			  }

	   	      //update GUI with info now...
              if (!g_bRunningInQuietMode)
                 UpdateData(FALSE);
		   }
		   else
		   {
			   ShowLogRejectedMessage(); //5-16-2001
		   }
		}
	    else  //error opening file, unexpected...
		{
		   if (!g_bRunningInQuietMode)
		   {
		      DWORD dwErr = GetLastError();		  

		      CString cstrErr;
		      cstrErr.Format("Unexpected Error reading file, error = %d", dwErr);

              AfxMessageBox(cstrErr);

		      //do something with dwErr
		   }
		}
	}
	else
	{
		//something wrong with log file, unexpected...  Can't tell if UNICODE or ANSI log
		ASSERT(1);

		 if (!g_bRunningInQuietMode)
		 {
		    //AfxMessageBox("Could not determine if log is UNICODE or ANSI");
		 }
	}

	//5-3-2001
    if (!g_bRunningInQuietMode)
	{
       DoResults();
	}
	else
	{
       //dump the output to HTML File...
       CString cstrOutputHTMLFile;
       DumpHTMLToFile(cstrOutputHTMLFile); //output HTMLized log file...

	   //generate quite mode results...
	   DoQuietModeResults();
	}
	//end, 5-3-2001

	return bRet;
}


//--------------------------------------------------------------------------------------------------
//
//
//  HTML Processing functions below here...
//
//
//--------------------------------------------------------------------------------------------------

/*
Each line in the log file begins with:

	MSI (a) (bbcdd):

where:
a is the type of process (c - client, s - service, a - custom action server)
bb is the last two hex digits of the process id
c is : for a thread acting as itself and ! for a thread acting in the context of a custom action request,
dd is the last two hex digits of the thread id in process bb, unless c is !, in which case it is the last two digits of the thread id in the process hosting the custom action on whose behalf the current thread is acting.

With the understanding that this information is subject to change without notice, you can 
use this information however you wish. Color coding is one possibility. Most of it is not 
very interesting because in the log file it is usually all the same (except for 
client/service). When monitoring debug output, it can be more interesting.

Chris Gouge
*/

enum 
{
	client = 'c', service = 's', customaction = 'a'
} ProcessTypesEnum;


void FormatFontColorIntoHTML(CString &strFontTag, COLORREF col)
{
	strFontTag.Format("%c#%02x%02x%02x%c>", '"', GetRValue(col),
		              GetGValue(col),
				      GetBValue(col), '"');
			  
}



void CLogAnalyzeDlg::WriteLineWithColor(char *szLine, COLORREF col, CString &cstrLabel)
{
  CString cstrHeader = "<font color="; 
  CString cstrFontColor = "";
  CString cstrFooter = "</font><BR>";

  CString cstrLine = szLine;  

  FormatFontColorIntoHTML(cstrFontColor, col);

  CString line2;
  line2 = cstrHeader + cstrFontColor + cstrLabel + cstrLine + cstrFooter;

  m_cstrHTML.Add(line2);
}


void CLogAnalyzeDlg::AddGenericLineToHTML(char *szLine)
{
  char cTypeProcess  = 0; //c, s, or a
  char cThreadContext = 0; //: or !

  const char *pszProcessTypeToken = "MSI (";
  const char *pszThreadContextToken = ") (";

  //parse line...
  char *pos = strstr(szLine, pszProcessTypeToken);
  if (pos)
  {
	  int lenbuff = strlen(szLine);
	  int lenToken = strlen(pszProcessTypeToken);

	  if (lenbuff > lenToken)
	  {
  	    cTypeProcess = *(pos + lenToken);

		pos = strstr(szLine, pszThreadContextToken);
		if (pos)
		{
           lenToken = strlen(pszProcessTypeToken);
	   	   if (lenbuff > lenToken)
              cThreadContext = *(pos + lenToken); //: or !
        }
	  }
  }

  CString cstrLabel;
  if (cTypeProcess && cThreadContext)
  {
	 switch (cTypeProcess)
	 {
	    case 'c':
	    case 'C': cstrLabel = "(CLIENT)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
			      WriteLineWithColor(szLine, m_colClientContext, cstrLabel);
			      break;

	    case 's':
	    case 'S': cstrLabel = "(SERVER)&nbsp;&nbsp&nbsp;&nbsp;&nbsp";
			      WriteLineWithColor(szLine, m_colServerContext, cstrLabel);
			      break;

	    case 'a':
	    case 'A': cstrLabel = "(CUSTOM)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
			      WriteLineWithColor(szLine, m_colCustomActionContext, cstrLabel);
			      break;

		default:  cstrLabel = "(UNKNOWN)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
                  WriteLineWithColor(szLine, m_colUnknownContext, cstrLabel);
	 }
  }
  else
  {
	  cstrLabel = "(UNKNOWN)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
      WriteLineWithColor(szLine, m_colUnknownContext, cstrLabel);
  }
}


void CLogAnalyzeDlg::AddErrorLineSuccessToHTML()
{
  CString cstrErrorBookmark = "<p> <a name=""ERRORAREA_1""></a></p>"; 	
  m_cstrHTML.Add(cstrErrorBookmark); //this is added at bottom if we hit no error
}


void CLogAnalyzeDlg::AddErrorLineWorker(char *szLine, BOOL bIgnored)
{
  if (!bIgnored)
  {
     CString cstrLabel = "(ERROR)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
     WriteLineWithColor(szLine, m_colErrorArea, cstrLabel);
  }
  else
  {
     CString cstrLabel = "(IGNORED)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
     WriteLineWithColor(szLine, m_colIgnoredError, cstrLabel);
  }
}



#define HTML_ERROR_LINES LINES_ERROR

void CLogAnalyzeDlg::AddErrorLineToHTML(char *szLine, BOOL bIgnored)
{
	if (!bIgnored) //non-ignorable error???
	{
       CString cstrErrorBookmark;
       cstrErrorBookmark.Format("<p> <a name=%cERRORAREA_%d%c></a></p>", '"',  m_iTotalNonIgnoredErrors, '"');

	   if (m_LineCount > HTML_ERROR_LINES)
	   {

/* 5-16-2001 fix up for errors, in HTML, only show the error found, not the context...
/*
	      int nCount = m_cstrHTML.GetSize();
	      int RemovePos;
          for (int i=0; i < HTML_ERROR_LINES; i++)
		  {
              RemovePos = nCount - i - 1;
	          if (RemovePos > 0)
			  {
                 m_cstrHTML.RemoveAt(RemovePos);
			  }
		  }
*/

		  m_cstrHTML.Add(cstrErrorBookmark);     //add bookmark
		  m_cstrHTML.Add("NOTE: Look at few lines above for clues on error<BR>"); //add error area stuff after error block

		  AddErrorLineWorker(szLine, bIgnored);

/* 5-16-2001 fix
          for (i=0; i < HTML_ERROR_LINES; i++)
		  {
		      AddErrorLineWorker(&m_szErrorLines[i][0], bIgnored);
		  }
*/
	   }
   	   else
	   {
		  m_cstrHTML.Add(cstrErrorBookmark);     //add bookmark
		  m_cstrHTML.Add("<BR>"); //add error area stuff after error block

	      AddErrorLineWorker(szLine, bIgnored);
	   }
	}
	else //ignorable errors, just ignore this one line....
	{
       AddErrorLineWorker(szLine, bIgnored);
	}
}


void CLogAnalyzeDlg::AddPropLineToHTML(char *szLine)
{
   CString cstrLabel = "(PROPERTY)&nbsp";
   WriteLineWithColor(szLine, m_colProperty, cstrLabel);
}

void CLogAnalyzeDlg::AddStateLineToHTML(char *szLine)
{
   CString cstrLabel = "(STATE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
   WriteLineWithColor(szLine, m_colState, cstrLabel);
}

void CLogAnalyzeDlg::AddPolicyLineToHTML(char *szLine)
{
   CString cstrLabel = "(POLICY)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp";
   WriteLineWithColor(szLine, m_colPolicy, cstrLabel);
}

// 2-12-2001 changed function name to more appropriate name...
BOOL WriteHTMLResourceToFile(int ResourceName, CString &szFileName)
{
   BOOL bRet = TRUE;

   HMODULE hmod = GetModuleHandle(NULL);
   HRSRC hrsrc = FindResource(hmod, MAKEINTRESOURCE(ResourceName), RT_HTML);
   if (hrsrc)
   {
	  HGLOBAL res = LoadResource(hmod, hrsrc);
	  if (res)
	  {
		  DWORD dwSize = SizeofResource(hmod, hrsrc);
		  LPVOID pVoid = LockResource(res);
		  if (pVoid)
		  {
			 DWORD dwWritten = 0;
  		     FILE  *fptr = fopen(szFileName, "wb");
             if (fptr)
			 {
                dwWritten = fwrite(pVoid, dwSize, 1, fptr);
				ASSERT(1 == dwWritten);
				fclose(fptr);
			 }
		  }
	  }
  }

  return bRet;
}

void AddJumpTags(FILE *fptr, CString &cstrDetailsName, int MaxErrors)
{
	if (fptr)
	{
      HMODULE hmod = GetModuleHandle(NULL);
      HRSRC hrsrc = FindResource(hmod, MAKEINTRESOURCE(IDR_JUMPTAGS), RT_HTML);
      if (hrsrc)
	  {
	     HGLOBAL res = LoadResource(hmod, hrsrc);
	     if (res)
		 {
		    DWORD dwSize = SizeofResource(hmod, hrsrc);
		    LPVOID pVoid = LockResource(res);
		    if (pVoid)
			{
			   DWORD dwWritten = 0;
               dwWritten = fwrite(pVoid, dwSize, 1, fptr);
			   ASSERT(1 == dwWritten);

			   CString strTags;

			   strTags.Format("\n<script language=%cjavascript%c>\n", '"', '"');
			   fputs(strTags, fptr);

			   strTags.Format("var MaxErrors = %d;\n", MaxErrors);
			   fputs(strTags, fptr);

			   //"details_123.htm"
			   cstrDetailsName.Replace('\\', '/');
			   strTags.Format("var DetailsName = %cfile:///%s%c;\n", '"', cstrDetailsName, '"');
			   fputs(strTags, fptr);

   			   strTags.Format("</script>\n");
			   fputs(strTags, fptr);
			}
		 }
	  }
	}
}



//new function to write legend on fly...
BOOL WriteHTMLLogLegend(CString &cstrFilename, CString &cstrDetailsName, int iTotalErrors)
{
  BOOL bRet = TRUE;

  FILE *fptr;
  fptr = fopen(cstrFilename, "wb");
  if (fptr)
  {
	CString strTags;

	strTags = "<HTML>";
	fputs(strTags, fptr);

	strTags = "<BODY>";
	fputs(strTags, fptr);

	fputs("LEGEND", fptr);

    strTags.Format("<TABLE BORDER=1 WIDTH=%c100%c>", '"', '"');
	fputs(strTags, fptr);

    strTags = "<TR>";
	fputs(strTags, fptr);

	HTMLColorSettings settings1;

	InitHTMLColorSettings(settings1);
	CArray<COLORREF, COLORREF> arColors;

	CWILogUtilApp *pApp = (CWILogUtilApp *) AfxGetApp();
	if (pApp)
    {
	   pApp->GetUserColorSettings(arColors);
	   if (arColors.GetSize() == MAX_HTML_LOG_COLORS)
	   {
  	      CString strRowTagStart = "<TD><font color=";
  	      CString strRowTagEnd = "</font></TD>";
		  CString strFontTag;

		  CString strTableRow;
		  COLORREF col;
	      for (int i=0; i < MAX_HTML_LOG_COLORS; i++)
		  {
              col = arColors.GetAt(i);
			  strFontTag.Format("%c#%02x%02x%02x%c>""%s", '"', GetRValue(col), GetGValue(col),
				                GetBValue(col), '"', settings1.settings[i].name);
			  
			  strTableRow = strRowTagStart + strFontTag + strRowTagEnd;
              fputs(strTableRow, fptr);
		  }
	   }
	}

    strTags = "</TR>";
	fputs(strTags, fptr);

    strTags = "</TABLE>";
	fputs(strTags, fptr);

	AddJumpTags(fptr, cstrDetailsName, iTotalErrors);

	strTags = "</BODY>";
	fputs(strTags, fptr);

	strTags = "</HTML>";
	fputs(strTags, fptr);

	fclose(fptr);
  }
  else
  {
     bRet = FALSE;

     //file write failed for legend HTML file
     if (!g_bRunningInQuietMode)
	 {
        CString cstrErr;
        cstrErr.Format("Unexpected error when writing legend file");

	    AfxMessageBox(cstrErr);
	 }
  }

  return bRet;
}




BOOL CLogAnalyzeDlg::WriteHTMLFrame(CString &cstrHTMLFrame, CString &cstrOutputHTMLFile, CString &cstrLegendHTMLFile)
{
  BOOL bRet = FALSE;

  FILE *fptr;
  fptr = fopen(cstrHTMLFrame, "w");

  if (fptr)
  {
     bRet = TRUE; //set flag to true...

	 CString strTags;

	 strTags = "<HTML><HEAD>";
	 fputs(strTags, fptr);

	 strTags = "<title>Log File Details</title></head>";
	 fputs(strTags, fptr);

	 strTags.Format("<frameset rows=%c150,*%c noresize>\n", '"', '"');
	 fputs(strTags, fptr);

	 strTags.Format("<frame SCROLLING=%cno%c name=%cheader%c target=%cmain%c src=%c%s%c>\n", '"', '"', '"', '"', '"', '"', '"', cstrLegendHTMLFile, '"');
	 fputs(strTags, fptr);

	 strTags.Format("<frame name= %cmain%c src=%c", '"', '"', '"');
	 CString strTags2;
	 strTags2.Format("%s%c>\n", cstrOutputHTMLFile, '"');

	 CString strTags3 = strTags + strTags2;
	 fputs(strTags3, fptr);

   	 strTags = "<noframes><body>\n";
	 fputs(strTags, fptr);

   	 strTags = "<p>This page uses frames, but your browser doesn't support them.</p>Go to log.htm to read this log...";
	 fputs(strTags, fptr);

   	 strTags = "</body></noframes>\n";
	 fputs(strTags, fptr);

     strTags = "</frameset></HTML>";
     fputs(strTags, fptr);

     fclose(fptr);
  }
  else
  {
    //file write failed for HTML frame file
    if (!g_bRunningInQuietMode)
	{
       CString cstrErr;
       cstrErr.Format("Unexpected error open details file");

	   AfxMessageBox(cstrErr);
	}
  }

  return bRet;
}


BOOL CLogAnalyzeDlg::DumpHTMLToFile(CString &cstrOutputHTMLFile)
{
//5-16-2001
   BOOL bRet = IsValidDirectory(m_cstrOutputDir);  //create dir first...
   if (bRet)
   {
      CString cstrOutputTempDir;
      cstrOutputTempDir = m_cstrOutputDir + "TMP\\";

      bRet = IsValidDirectory(cstrOutputTempDir);
      if (bRet)
	  {
  	     //5-17-2001
  	     CString cstrCurrentLogName;
	     cstrCurrentLogName = this->m_cstrLogFileName;

	     cstrCurrentLogName.Replace(':', '_'); //covert colons to _
	     cstrCurrentLogName.Replace('\\', '_'); //convert backslashes to _
	     cstrCurrentLogName.Replace(' ', '_'); //convert spaces to _

         m_cstrDetailsName =  m_cstrOutputDir + "TMP\\" + cstrCurrentLogName + ".HTM";
         //end 5-17-2001

         FILE *fptr;
         fptr = fopen( m_cstrDetailsName, "w");

	     bRet = FALSE; //set flag to false...
         if (fptr)
		 {
	        bRet = TRUE; //set flag to true...

	        CString strTags;
  	        strTags.Format("<HTML><BODY> <p><a name=%cTOP_DETAILS%c></a></p>", '"', '"');
	        fputs(strTags, fptr);
 
            int iCount = m_cstrHTML.GetSize();
            for (int i=0; i < iCount; i++)
			{
	            fputs(m_cstrHTML.GetAt(i), fptr);
			}

 	        strTags.Format("<p> <a name=%cBOTTOM_DETAILS%c></a></p></BODY></HTML>", '"', '"');
   	        fputs(strTags, fptr);

            fclose(fptr);
		    fptr = NULL;

            //5-14-2001
            CString cstrFrameName;
		    cstrFrameName =  m_cstrOutputDir + "Details_" + cstrCurrentLogName + ".HTM";

            m_cstrLegendName = cstrOutputTempDir + "legend_" + cstrCurrentLogName + ".HTM";
            bRet = WriteHTMLFrame(cstrFrameName, m_cstrDetailsName, m_cstrLegendName);
            if (bRet)
			{
  	           cstrOutputHTMLFile = cstrFrameName;
               WriteHTMLLogLegend(m_cstrLegendName, m_cstrDetailsName, m_iTotalNonIgnoredErrors);
			}
		 }
         else
		 {
	        bRet = FALSE;

	        //file write failed for details file, (annotated log)
 	        if (!g_bRunningInQuietMode)
			{
		       CString cstrErr;
		       cstrErr.Format("Unexpected error when writing details file");
               AfxMessageBox(cstrErr);
			}
		 }
	  }
	  else
	  {
         bRet = FALSE; //bad temp dir...
         if (!g_bRunningInQuietMode)
		 {
            CString cstrOutDirMsg;
	        cstrOutDirMsg.Format("Could not create directory %s", cstrOutputTempDir);
	        AfxMessageBox(cstrOutDirMsg);
		 }
	  }
   }
   else //bad out dir...
   {
      bRet = FALSE; //
      if (!g_bRunningInQuietMode)
	  {
         CString cstrOutDirMsg;
	     cstrOutDirMsg.Format("Current directory set for output directory: %s is invalid, please select a new one in Options.", this->m_cstrOutputDir);
	     AfxMessageBox(cstrOutDirMsg);
	  }
   }

   return bRet; //return if worked to caller...
}

//5-16-2001, shows HTML file in default system browser, can be Netscape...
void ShowHTMLFile(CString &cstrDirectory, CString &cstrPath)
{
   if (!g_bRunningInQuietMode)
   {
      char lpszBrowser[MAX_PATH];
      HINSTANCE hInst = FindExecutable(cstrPath, cstrDirectory, lpszBrowser);
      if (hInst > (HINSTANCE)32)
	  {
         ShellExecute(NULL, "open", lpszBrowser, cstrPath, cstrDirectory, SW_SHOWMAXIMIZED);
	  }
      else
	  {
 	     if (!g_bRunningInQuietMode)
            AfxMessageBox("No default browser found for .htm files");	 
	  }
   }
}


//show HTML file...
void CLogAnalyzeDlg::OnExplainlog() 
{
  if (!m_bLogVersionAllowed)
  {
	 ShowLogRejectedMessage();
	 return;
  }

  CString cstrOutputFile;
  BOOL bRet = DumpHTMLToFile(cstrOutputFile); //output HTMLized log file...
  if (bRet)
     ShowHTMLFile(m_cstrOutputDir, cstrOutputFile);
  else
  {
      if (!g_bRunningInQuietMode)
	     AfxMessageBox("Error generating HTML File for current log");
  }
}

#include "PolicyD.h"

void CLogAnalyzeDlg::OnPolicies() 
{
  if (!m_bLogVersionAllowed)
  {
	 ShowLogRejectedMessage();
	 return;
  }

  CPoliciesDlg dlg;

  dlg.SetPolicyInformation(m_MachinePolicySettings, m_UserPolicySettings);

  //5-3-2001, don't show in quiet mode...
  if (!g_bRunningInQuietMode)
     dlg.DoModal();
}

void CLogAnalyzeDlg::OnNexterror() 
{
  if (!m_bShowIgnoredDebugErrors) //showing critical errors only...
  {
	 int iSize = m_arNonIgnorableErrorArray.GetSize();
     if ((m_iCurrentNonIgnoredError < m_iTotalNonIgnoredErrors) && iSize)
	 {
        m_iCurrentNonIgnoredError++;

  	    WIErrorInfo *pErrorInfo;
        pErrorInfo = m_arNonIgnorableErrorArray.GetAt(m_iCurrentNonIgnoredError);
	    if (pErrorInfo)
		{
		  m_cstrSolution = pErrorInfo->cstrSolution;
		  m_cstrError = pErrorInfo->cstrError;

		  if (!g_bRunningInQuietMode)
		     UpdateData(FALSE);
		}
	 }

 	 if (m_iCurrentNonIgnoredError == m_iTotalNonIgnoredErrors)
	 {
	    CWnd *pWnd;
	    pWnd = GetDlgItem(IDC_NEXTERROR);
	    if (pWnd)
		{
	       pWnd->EnableWindow(FALSE);	 
		}
	}

    CWnd *pWnd;
    pWnd = GetDlgItem(IDC_PREVIOUSERROR);
    if (pWnd && (m_iTotalNonIgnoredErrors > 1))
	{
	   if (!pWnd->IsWindowEnabled())
          pWnd->EnableWindow(TRUE);
	}
	else
	{
	   pWnd->EnableWindow(FALSE);
	}


	CString str;
	str.Format("%d", m_iCurrentNonIgnoredError);
	pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
	if (pWnd)
	{
       pWnd->SetWindowText(str);
	}
  } 
  else //showing ignorable errors instead...
  {
	 int iSize = m_arIgnorableErrorArray.GetSize();
     if ((m_iCurrentIgnoredError < m_iTotalIgnoredErrors) && iSize)
	 {
        m_iCurrentIgnoredError++;

  	    WIErrorInfo *pErrorInfo;
        pErrorInfo = m_arIgnorableErrorArray.GetAt(m_iCurrentIgnoredError);
	    if (pErrorInfo)
		{
		  m_cstrSolution = pErrorInfo->cstrSolution;
		  m_cstrError = pErrorInfo->cstrError;

          if (!g_bRunningInQuietMode)
		     UpdateData(FALSE);
		}
	 }
 	    
	 if (m_iCurrentIgnoredError == m_iTotalIgnoredErrors)
	 {
	    CWnd *pWnd;
	    pWnd = GetDlgItem(IDC_NEXTERROR);
	    if (pWnd)
		{
	       pWnd->EnableWindow(FALSE);	 
		}
	 }

     CWnd *pWnd;
	 pWnd = GetDlgItem(IDC_PREVIOUSERROR);
	 if (pWnd && (m_iTotalIgnoredErrors > 1))
	 {
	    if (!pWnd->IsWindowEnabled())
           pWnd->EnableWindow(TRUE);
	 }
	 else
	 {
        pWnd->EnableWindow(FALSE);
	 }

	 CString str;
	 str.Format("%d", m_iCurrentIgnoredError);
	 pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
	 if (pWnd)
	 {
		pWnd->SetWindowText(str);
	 }
  }
}


//handle interating through the previous error found from the current error
void CLogAnalyzeDlg::OnPreviouserror() 
{
  if (!m_bShowIgnoredDebugErrors) //showing critical errors only...
  {
     UINT iSize = m_arNonIgnorableErrorArray.GetSize();
     if ((m_iCurrentNonIgnoredError > 1) && (iSize >= m_iCurrentNonIgnoredError))
	 {
        m_iCurrentNonIgnoredError--;

	    WIErrorInfo *pErrorInfo;
        pErrorInfo = m_arNonIgnorableErrorArray.GetAt(m_iCurrentNonIgnoredError);
	    if (pErrorInfo)
		{
		   m_cstrSolution = pErrorInfo->cstrSolution;
		   m_cstrError = pErrorInfo->cstrError;

		   if (!g_bRunningInQuietMode)
   	          UpdateData(FALSE);
		}
	 }

 	 if (m_iCurrentNonIgnoredError <= 1)
	 {
	    CWnd *pWnd;
	    pWnd = GetDlgItem(IDC_PREVIOUSERROR);
	    if (pWnd)
		{
	       pWnd->EnableWindow(FALSE);	 
		}
	 }

     CWnd *pWnd;
	 pWnd = GetDlgItem(IDC_NEXTERROR);
	 if (pWnd && (m_iTotalNonIgnoredErrors > 1))
	 {
	    if (!pWnd->IsWindowEnabled())
           pWnd->EnableWindow(TRUE);
	 }
	 else
	 {
	    pWnd->EnableWindow(FALSE);
	 }

     CString str;
	 str.Format("%d", m_iCurrentNonIgnoredError);
	 pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
	 if (pWnd)
	 {
		pWnd->SetWindowText(str);
	 }
  }
  else
  {
     UINT iSize = m_arIgnorableErrorArray.GetSize();
     if ((m_iCurrentIgnoredError > 1) && (iSize >= m_iCurrentIgnoredError))
	 {
        m_iCurrentIgnoredError--;

	    WIErrorInfo *pErrorInfo;
        pErrorInfo = m_arIgnorableErrorArray.GetAt(m_iCurrentIgnoredError);
	    if (pErrorInfo)
		{
		   m_cstrSolution = pErrorInfo->cstrSolution;
		   m_cstrError = pErrorInfo->cstrError;

		   if (!g_bRunningInQuietMode)
   	          UpdateData(FALSE);
		}
	 }

 	 if (m_iCurrentIgnoredError <= 1)
	 {
	    CWnd *pWnd;
	    pWnd = GetDlgItem(IDC_PREVIOUSERROR);
	    if (pWnd)
		{
	       pWnd->EnableWindow(FALSE);	 
		}
	 }

     CWnd *pWnd;
	 pWnd = GetDlgItem(IDC_NEXTERROR);
	 if (pWnd && (m_iTotalIgnoredErrors > 1))
	 {
	    if (!pWnd->IsWindowEnabled())
           pWnd->EnableWindow(TRUE);
	 }
	 else
	 {
	    pWnd->EnableWindow(FALSE);
	 }

	 CString str;
	 str.Format("%d", m_iCurrentIgnoredError);
	 pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
	 if (pWnd)
	 {
		pWnd->SetWindowText(str);
	 }
  }
}

#include "optionsd.h"

void CLogAnalyzeDlg::OnOperationsOptions() 
{
	COptionsDlg dlg;

	BOOL bRet;
	CWILogUtilApp *pApp = (CWILogUtilApp *) AfxGetApp();
	if (pApp)
	{
		CArray<COLORREF, COLORREF> arColors;
		bRet = pApp->GetUserColorSettings(arColors);
		if (bRet)
		{
           m_cstrIgnoredErrors = pApp->GetIgnoredErrors();
		   dlg.SetIgnoredErrors(m_cstrIgnoredErrors);

           m_cstrOutputDir = pApp->GetOutputDirectory();
		   dlg.SetOutputDirectory(m_cstrOutputDir);

  	       bRet = dlg.SetColors(arColors);
		   if (bRet)
		   {
              //5-3-2001, don't show in quiet mode...
             if (!g_bRunningInQuietMode)
			 {
	            int iRet = dlg.DoModal();
		        if (IDOK == iRet)
				{
			       bRet = dlg.GetColors(arColors);
			       if (bRet)
				   {
			          bRet = pApp->SetUserColorSettings(arColors);
				   }

				   m_cstrOutputDir = dlg.GetOutputDirectory();
                   pApp->SetOutputDirectory(m_cstrOutputDir);

				   m_cstrIgnoredErrors = dlg.GetIgnoredErrors();
                   pApp->SetIgnoredErrors(m_cstrIgnoredErrors);
				}
			 }
		   }
		}
	}
}

void CLogAnalyzeDlg::OnOperationsGeneratehtmloutput() 
{
  OnExplainlog();
}

void CLogAnalyzeDlg::OnOperationsShowpolicies() 
{
  	OnPolicies();
}

void CLogAnalyzeDlg::OnOperationsShowproperties() 
{
	OnShowprop();
}

void CLogAnalyzeDlg::OnOperationsShowstates() 
{
	OnShowstates();
}

//tricky GUI code below...
void CLogAnalyzeDlg::OnShowIgnoredErrors() 
{
  CButton *pButton = (CButton *) GetDlgItem(IDC_SHOW_IGNORED_ERRORS);
  if (pButton)
  {
     int iCheck = pButton->GetCheck();
	 if (iCheck) //currently checked, showing only the errors that were ignored...
	 {
        m_bShowIgnoredDebugErrors = TRUE;
        if (m_iTotalIgnoredErrors > 0)
           m_iCurrentIgnoredError = 1;

        CString str;
		str.Format("%d", m_iCurrentIgnoredError);
		CWnd *pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
		if (pWnd)
		{
			pWnd->SetWindowText(str);
		}                

		str.Format("%d", m_iTotalIgnoredErrors);
		pWnd = GetDlgItem(IDC_TOTAL_ERRORS);
		if (pWnd)
		{
			pWnd->SetWindowText(str);
		}

        pWnd = GetDlgItem(IDC_PREVIOUSERROR);
 	    if (m_iCurrentIgnoredError <= 1)
		{
	       if (pWnd)
	          pWnd->EnableWindow(FALSE);	 
		}
		else
		{
	       if (pWnd)
	          pWnd->EnableWindow(TRUE);	 
		}

        pWnd;
	    pWnd = GetDlgItem(IDC_NEXTERROR);
	    if (pWnd && (m_iTotalIgnoredErrors > 1))
		{
		   if (!pWnd->IsWindowEnabled())
              pWnd->EnableWindow(TRUE);
		}
		else
		{
           if (pWnd)
			  pWnd->EnableWindow(FALSE);
		}

        if (m_iCurrentIgnoredError)
		{
	       WIErrorInfo *pErrorInfo;
           pErrorInfo = m_arIgnorableErrorArray.GetAt(m_iCurrentIgnoredError);
	       if (pErrorInfo)
		   {
		      m_cstrSolution = pErrorInfo->cstrSolution;
		      m_cstrError = pErrorInfo->cstrError;

			  if (!g_bRunningInQuietMode)
   	             UpdateData(FALSE);
		   }
		}
		else //hackhack
		{
 	       m_cstrSolution.LoadString(IDS_NOSOLUTION_NEEDED);
	       m_cstrError.LoadString(IDS_NOERRORFOUND);

		   if (!g_bRunningInQuietMode)
		      UpdateData(FALSE);
		}
	 }
	 else  //not checked...  Showing only non-ignorable errors currently
	 {
        m_bShowIgnoredDebugErrors = FALSE;
        if (m_iTotalNonIgnoredErrors > 0) //reset it back to first pos...
           m_iCurrentNonIgnoredError = 1;

        CString str;
		str.Format("%d", m_iCurrentNonIgnoredError);
		CWnd *pWnd = GetDlgItem(IDC_CURRENT_ERROR_NUMBER);
		if (pWnd)
		{
			pWnd->SetWindowText(str);
		}                

		str.Format("%d", m_iTotalNonIgnoredErrors);
		pWnd = GetDlgItem(IDC_TOTAL_ERRORS);
		if (pWnd)
		{
			pWnd->SetWindowText(str);
		}

 	    if (m_iCurrentNonIgnoredError <= 1)
		{
	       CWnd *pWnd;
	       pWnd = GetDlgItem(IDC_PREVIOUSERROR);
	       if (pWnd)
		   {
	          pWnd->EnableWindow(FALSE);	 
		   }
		}
		else
		{
           if (pWnd)
  		      pWnd->EnableWindow(TRUE);	 
		}

        pWnd;
	    pWnd = GetDlgItem(IDC_NEXTERROR);
	    if (pWnd && (m_iTotalNonIgnoredErrors > 1))
		{
		   if (!pWnd->IsWindowEnabled())
              pWnd->EnableWindow(TRUE);
		}
		else
		{ 
           pWnd->EnableWindow(FALSE);
		}

        if (m_iCurrentNonIgnoredError)
		{
	       WIErrorInfo *pErrorInfo;
           pErrorInfo = m_arNonIgnorableErrorArray.GetAt(m_iCurrentNonIgnoredError);
	       if (pErrorInfo)
		   {
		      m_cstrSolution = pErrorInfo->cstrSolution;
		      m_cstrError = pErrorInfo->cstrError;

			  if (!g_bRunningInQuietMode)
   	             UpdateData(FALSE);
		   }
		}
		else //hackhack
		{
 	       m_cstrSolution.LoadString(IDS_NOSOLUTION_NEEDED);
	       m_cstrError.LoadString(IDS_NOERRORFOUND);

		   if (!g_bRunningInQuietMode)
		      UpdateData(FALSE);
		}
	 }
  }
}


#include "propsht.h"
#include "clientpp.h"
#include "serverpp.h"
#include "nestedpp.h"

void CLogAnalyzeDlg::OnProptest() 
{
  if (!m_bLogVersionAllowed)
  {
	 ShowLogRejectedMessage();
	 return;
  }

  CMyPropertySheet ps("Properties", NULL, 0);
  ps.m_psh.dwFlags |= PSH_NOAPPLYNOW;

  if (ps.m_psh.dwFlags & PSH_HASHELP)
  {
     ps.m_psh.dwFlags -= PSH_HASHELP;
  }
  
  CClientPropertyPage ClientPage;
  CServerPropertyPage ServerPage;
  CNestedPropertyPage NestedPage;
 
  if (ClientPage.m_psp.dwFlags & PSP_HASHELP)
  {
	  ClientPage.m_psp.dwFlags -= PSP_HASHELP;
  }

  if (ServerPage.m_psp.dwFlags & PSP_HASHELP)
  {
	  ServerPage.m_psp.dwFlags -= PSP_HASHELP;
  }

  if (NestedPage.m_psp.dwFlags & PSP_HASHELP)
  {
	  NestedPage.m_psp.dwFlags -= PSP_HASHELP;
  }

  ClientPage.SetClientPropNames(&this->m_cstrClientPropNameArray);
  ClientPage.SetClientPropValues(&this->m_cstrClientPropValueArray);

  ServerPage.SetServerPropNames(&this->m_cstrServerPropNameArray);
  ServerPage.SetServerPropValues(&this->m_cstrServerPropValueArray);

  NestedPage.SetNestedPropNames(&this->m_cstrNestedPropNameArray);
  NestedPage.SetNestedPropValues(&this->m_cstrNestedPropValueArray);

  ps.AddPage(&ClientPage);
  ps.AddPage(&ServerPage);
  ps.AddPage(&NestedPage);

  //5-3-2001, don't show in quiet mode...
  if (!g_bRunningInQuietMode)
     ps.DoModal();
}

void CLogAnalyzeDlg::OnSaveresults() 
{
     if (!m_bLogVersionAllowed)
	 {
	    ShowLogRejectedMessage();
	    return;
	 }

     DoQuietModeResults();

	 CString strMsg;
	 strMsg.Format("Saved results to %s", m_cstrOutputDir);

     if (!g_bRunningInQuietMode)
	    AfxMessageBox(strMsg);
}



//TODO...
//5-16-2001
void CLogAnalyzeDlg::OnDeleteoutputdircontents() 
{
   if (!g_bRunningInQuietMode) //don't do anything in quite mode...
   {
      int iRet;   

      CString strConfirmStr;
      strConfirmStr.Format("Are you sure you want to delete ALL contents from directory %s", m_cstrOutputDir);
      iRet = MessageBox(strConfirmStr, "Deletion Confirmation", MB_YESNO);
      if (iRet == IDYES)
	  {
         //TODO
	     //do the delete
	     int j = 0;

		 //do nothing....
         BOOL bRet;
	     bRet = IsValidDirectory(m_cstrOutputDir);
	     if (bRet) //ok, good so far
		 {

		 }
	     else
		 {
             if (!g_bRunningInQuietMode)
			 {
		        //do nothing
		        CString cstrOutDirMsg;
		        cstrOutDirMsg.Format("Current directory set for output directory: %s is invalid, please select a new one in Options.", m_cstrOutputDir);
		        AfxMessageBox(cstrOutDirMsg);
			 }
		  }
	  }
      else
	  {
		  //do nothing!
	  }
   }
}


//5-16-2001
void WriteAndShowHTMLFile(int iHTMLResource, CString &cstrDirectory, CString &cstrPath)
{
	BOOL bRet = IsValidDirectory(cstrDirectory);
	if (bRet)
	{
  	   bRet = WriteHTMLResourceToFile(iHTMLResource, cstrPath);
	   if (bRet)
	   {
          ShowHTMLFile(cstrDirectory, cstrPath);
	   }
	   else
	   {
          if (!g_bRunningInQuietMode)
		  {
		     CString cstrErrorMsg;
		     cstrErrorMsg.Format("Error extracting internal errors file to directory %s", cstrDirectory); 

  	         AfxMessageBox(cstrErrorMsg);
		  }
	   }
	}
	else
	{
       if (!g_bRunningInQuietMode)
	   {
          CString cstrOutDirMsg;
	      cstrOutDirMsg.Format("Current directory set for output directory: %s is invalid, please select a new one in Options.", cstrDirectory);
	      AfxMessageBox(cstrOutDirMsg);
	   }
	}
}
//5-16-2001


void CLogAnalyzeDlg::OnShowinternalerrorshelp() 
{
    CString cstrOutHelpDir;
	cstrOutHelpDir = m_cstrOutputDir + "HELP\\";

    BOOL bRet = IsValidDirectory(cstrOutHelpDir);

    CString cstrOutPath;
    cstrOutPath = cstrOutHelpDir + "InternalWIErrors.html";

	WriteAndShowHTMLFile(IDR_ALLERRORS,  cstrOutHelpDir, cstrOutPath);
}


//5-16-2001, TODO....
void CLogAnalyzeDlg::OnShowhelp() 
{
    CString cstrOutHelpDir;
	cstrOutHelpDir = m_cstrOutputDir + "HELP\\";

    BOOL bRet = IsValidDirectory(cstrOutHelpDir);

    CString cstrOutPath;
    cstrOutPath = cstrOutHelpDir + "WILogUtilHelp.html";

	WriteAndShowHTMLFile(IDR_WILOGHELP, cstrOutHelpDir, cstrOutPath);
}

//TODO
void CLogAnalyzeDlg::OnShowhowtoreadlog() 
{
    CString cstrOutHelpDir;
	cstrOutHelpDir = m_cstrOutputDir + "HELP\\";

	BOOL bRet = IsValidDirectory(cstrOutHelpDir);

	CString cstrOutPath;
	cstrOutPath = cstrOutHelpDir + "HowToReadWILogs.html";

    WriteAndShowHTMLFile(IDR_HOWTOREADLOGS,  cstrOutHelpDir, cstrOutPath);
}
//end 5-16-2001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\common.h ===
#ifndef COMMON_TYPES_H
#define COMMON_TYPES_H


//how big is our buffer reads in file
#define LOG_BUF_READ_SIZE 8192

//number of lines we identify errors
#define LINES_ERROR 6

//property types...
#define SERVER_PROP 0
#define CLIENT_PROP 1
#define NESTED_PROP 2


//HTML common settings...
#define MAX_HTML_LOG_COLORS 9

struct HTMLColorSetting
{
  char name[64];
  COLORREF value;
};


#define SOLUTIONS_BUFFER 8192

struct HTMLColorSettings
{
	HTMLColorSetting settings[MAX_HTML_LOG_COLORS]; 
};

void InitHTMLColorSettings(HTMLColorSettings &settings1);


//POLICY common settings
#define MAX_MACHINE_POLICIES_MSI11 14
#define MAX_USER_POLICIES_MSI11     5
#define MAX_POLICY_NAME 64

//5-9-2001, make policies 2.0 aware...
#define MAX_MACHINE_POLICIES_MSI20 16
#define MAX_USER_POLICIES_MSI20     5

#define MAX_MACHINE_POLICIES MAX_MACHINE_POLICIES_MSI20
#define MAX_USER_POLICIES    MAX_USER_POLICIES_MSI20
//end 5-9-2001

struct MSIPolicy
{
	BOOL bSet;
    char PolicyName[MAX_POLICY_NAME];
};


struct MachinePolicySettings
{
	int iNumberMachinePolicies;
//5-9-2001, go to 2.0 now, 2.0 has same 1.1/1.2 policies plus 2 new ones, so this is "ok" 
	struct MSIPolicy MachinePolicy[MAX_MACHINE_POLICIES_MSI20];
//end 5-9-2001
};

struct UserPolicySettings
{
	int iNumberUserPolicies;

//5-9-2001, go to 2.0 now
	struct MSIPolicy UserPolicy[MAX_USER_POLICIES_MSI20];
//end 5-9-2001
};

void InitMachinePolicySettings(MachinePolicySettings &policies);
void InitUserPolicySettings(UserPolicySettings &policies);

struct WIErrorInfo
{
	CString cstrError;
	CString cstrSolution;
    BOOL    bIgnorableError;
};

struct WIIgnoredError
{
	CString cstrError;
};

extern "C"   BOOL  g_bNT;
extern "C"   BOOL  g_bRunningInQuietMode;

extern const TCHAR *g_szDefaultOutputLogDir;
extern       TCHAR g_szLogFileToParse[MAX_PATH];
extern const TCHAR *g_szDefaultIgnoredErrors;

extern "C"   BOOL  g_bShowEverything;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\loganald.h ===
#if !defined(AFX_LOGANALYZEDLG_H__7790BEC2_EF8B_4536_ADC0_4ECBB36CEB43__INCLUDED_)
#define AFX_LOGANALYZEDLG_H__7790BEC2_EF8B_4536_ADC0_4ECBB36CEB43__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// LogAnalD.h : header file
//

#include "LogParse.h"


/////////////////////////////////////////////////////////////////////////////
// CLogAnalyzeDlg dialog
class CLogAnalyzeDlg : public CDialog
{
// Construction
public:
	CLogAnalyzeDlg(CWnd* pParent = NULL);   // standard constructor

	void ShowLogRejectedMessage();

	virtual ~CLogAnalyzeDlg() //clean up dynamic memory
	{
		int iCount, i;
		
		iCount = m_arNonIgnorableErrorArray.GetSize();
		for (i=0; i < iCount; i++)
		{
			WIErrorInfo* pErrorInfo = m_arNonIgnorableErrorArray.GetAt(i);
			if (pErrorInfo)
			{
			  delete pErrorInfo;
			  pErrorInfo = NULL;
			}
		}

		iCount = m_arIgnorableErrorArray.GetSize();
		for (i=0; i < iCount; i++)
		{
			WIErrorInfo* pErrorInfo = m_arIgnorableErrorArray.GetAt(i);
			if (pErrorInfo)
			{
			  delete pErrorInfo;
			  pErrorInfo = NULL;
			}
		}
	}

// Dialog Data
	//{{AFX_DATA(CLogAnalyzeDlg)
	enum { IDD = IDD_ADVVIEW_DIALOG1 };
	CString	m_cstrSolution;
	CString	m_cstrError;
	CString	m_cstrDateTime;
	CString	m_cstrUser;
	CString	m_cstrProduct;
	CString	m_cstrClientCMD;
	BOOL	m_bAdminRights;
	CString	m_cstrVersion;
	CString	m_cstrClientPrivDetail;
	CString	m_cstrServerPrivDetail;
	BOOL	m_bShowIgnoredDebugErrors;
	//}}AFX_DATA

	void SetLogfileLocation(CString & cstr) { m_cstrLogFileName = cstr; }

//5-3-2001, moved these up to allow for silent mode operation
	BOOL AnalyzeLog();
//end 5-3-2001

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLogAnalyzeDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
//5-9-2001, added tooltips...    
    BOOL OnToolTipNotify(UINT id, NMHDR *pNMH, LRESULT *pResult);

//general members used...
    long m_LineCount;
	BOOL m_bIsUnicodeLog;

//5-3-2001
	void DoInitialization();
	void DoResults();
	void DoQuietModeResults();
//end 5-3-2001

//5-4-2001
	void DoSummaryResults(CString &cstrFileName);
    void DoPolicyResults(CString &cstrFileName);
    void DoErrorResults(CString &cstrFileName);
//end 5-4-2001

//added 2-13-2001 to hold last line that was done...
	CString m_cstrLastLine;

//following section is for rejecting too high of WI log...
//REJECT LOG FILE SECTION
	BOOL m_bLogVersionAllowed;

	void SetRejectVersions(DWORD dwMajor, DWORD dwMinor)
	{
       m_dwVersionMajorReject = dwMajor;
	   m_dwVersionMinorReject = dwMinor;
	}

//will have version of WI that log was created against...
	DWORD m_dwVersionMajorLogCreated;
	DWORD m_dwVersionMinorLogCreated;
	DWORD m_dwVersionBuildLogCreated;

//has versions that this tool should reject parsing in case of changes...
	DWORD m_dwVersionMajorReject;
	DWORD m_dwVersionMinorReject;
//END SECTION

    CString m_cstrLogFileName;

	CStringArray m_cstrClientPropNameArray;
	CStringArray m_cstrClientPropValueArray;

	CStringArray m_cstrServerPropNameArray;
	CStringArray m_cstrServerPropValueArray;

	CStringArray m_cstrNestedPropNameArray;
	CStringArray m_cstrNestedPropValueArray;

	CStringArray m_cstrComponentNameArray;
	CStringArray m_cstrComponentInstalledArray;
	CStringArray m_cstrComponentRequestArray;
	CStringArray m_cstrComponentActionArray;

	CStringArray m_cstrFeatureNameArray;
	CStringArray m_cstrFeatureInstalledArray;
	CStringArray m_cstrFeatureRequestArray;
	CStringArray m_cstrFeatureActionArray;

//policies that were set when install ran...
	struct MachinePolicySettings m_MachinePolicySettings;
	struct UserPolicySettings m_UserPolicySettings;

//2-13-2001
	CArray<WIErrorInfo*, WIErrorInfo*> m_arNonIgnorableErrorArray;
	CArray<WIErrorInfo*, WIErrorInfo*> m_arIgnorableErrorArray;

	char m_szErrorLines[LINES_ERROR][LOG_BUF_READ_SIZE];
	BOOL m_bErrorFound;

	UINT m_iTotalNonIgnoredErrors;
	UINT m_iCurrentNonIgnoredError;

	UINT m_iTotalIgnoredErrors;
	UINT m_iCurrentIgnoredError;

	CString m_cstrIgnoredErrors;

//SECTION, PARSING HELPER FUNCTIONS	
//the parser...
	CLogParser m_LogParser; //handles reading of log file and interpreting lines in it...
//end the parser

	BOOL DoParse(char *buffer);
	BOOL DoDetectError(char *szLine, BOOL *pbIgnorableError);

	BOOL DoDetectProperty(char *szLine);
	BOOL DoDetectStates(char *szLine);
	BOOL DoDetectPolicy(char *szLine); 	//for getting policies that are set in log file
	BOOL DoDetectElevatedInstall(char *szLine); //checking permissions install run under
//END PARSING FUNCTIONS


//HTML generating functions
	CStringArray m_cstrHTML;

    BOOL WriteHTMLFrame(CString &cstrHTMLFrame, CString &cstrOutputHTMLFile, CString &cstrLegendHTMLFile);
    BOOL DumpHTMLToFile(CString &cstrOutputHTMLFile);

	void AddPolicyLineToHTML(char *ansibuffer);
	void AddGenericLineToHTML(char *ansibuffer);

	void AddErrorLineWorker(char *szLine, BOOL bIgnored);
	void AddErrorLineToHTML(char *ansibuffer, BOOL bIgnorableError);
	void AddErrorLineSuccessToHTML();

	void AddPropLineToHTML(char *ansibuffer);
	void AddStateLineToHTML(char *ansibuffer);

	void WriteLineWithColor(char *szLine, COLORREF col, CString &cstrLabel);
//END HTML functions

//members used by HTML functions
    CString m_cstrOutputDir;
    CString m_cstrDetailsName;
    CString m_cstrLegendName;
 
	COLORREF m_colClientContext;
	COLORREF m_colServerContext;
	COLORREF m_colCustomActionContext;
	COLORREF m_colUnknownContext;
	COLORREF m_colErrorArea;
	COLORREF m_colProperty;
	COLORREF m_colState;
	COLORREF m_colPolicy;
	COLORREF m_colIgnoredError;

	void InitColorMembers()
	{
         CWILogUtilApp *pApp = (CWILogUtilApp *) AfxGetApp();
		 if (pApp)
		 {
		   CArray<COLORREF, COLORREF> UserSelectedHTMLColors;

		   BOOL bRet = pApp->GetUserColorSettings(UserSelectedHTMLColors);
		   int iSize = UserSelectedHTMLColors.GetSize();

	       if (bRet && (iSize == MAX_HTML_LOG_COLORS))
		   {
              m_colClientContext = UserSelectedHTMLColors.GetAt(0);
			  m_colServerContext = UserSelectedHTMLColors.GetAt(1);
			  m_colCustomActionContext = UserSelectedHTMLColors.GetAt(2);
			  m_colUnknownContext = UserSelectedHTMLColors.GetAt(3);
			  m_colErrorArea = UserSelectedHTMLColors.GetAt(4);
			  m_colProperty = UserSelectedHTMLColors.GetAt(5);
              m_colState = UserSelectedHTMLColors.GetAt(6);
			  m_colPolicy = UserSelectedHTMLColors.GetAt(7);
			  m_colIgnoredError = UserSelectedHTMLColors.GetAt(8);
		   }
		 }
	}
//end HTML Members


	// Generated message map functions
	//{{AFX_MSG(CLogAnalyzeDlg)
	afx_msg void OnShowstates();
	afx_msg void OnShowprop();
	virtual BOOL OnInitDialog();
	afx_msg void OnExplainlog();
	afx_msg void OnPolicies();
	afx_msg void OnNexterror();
	afx_msg void OnPreviouserror();
	afx_msg void OnOperationsOptions();
	afx_msg void OnOperationsGeneratehtmloutput();
	afx_msg void OnOperationsShowpolicies();
	afx_msg void OnOperationsShowproperties();
	afx_msg void OnOperationsShowstates();
	afx_msg void OnShowIgnoredErrors();
	afx_msg void OnProptest();
	afx_msg void OnSaveresults();
	afx_msg void OnShowinternalerrorshelp();
	afx_msg void OnDeleteoutputdircontents();
	afx_msg void OnShowhelp();
	afx_msg void OnShowhowtoreadlog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOGANALYZEDLG_H__7790BEC2_EF8B_4536_ADC0_4ECBB36CEB43__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\logparse.cpp ===
// LogParse.cpp: implementation of the CLogParser class.
//
//
// Code in this file is the most specific and likely to break in future
// versions of WI.  What could be done and should be done is
// determine which build of WI this was built with.  This tool
// currently can read 1.0, 1.1 and 1.2 logs.  1.5 may break this
// tool and we could have the tool refuse to run with 1.5 until more
// testing is done.  This could be control via an .INI file with this
// app to turn on >= 1.5 log file parsing
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wilogutl.h"
#include "LogParse.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLogParser::CLogParser()
{
}

CLogParser::~CLogParser()
{

}


void CopyVersions(char *szVersion, DWORD *dwMajor, DWORD *dwMinor, DWORD *dwBuild)
{
  char szMajor[2];
  szMajor[0] = szVersion[0];
  szMajor[1] = '\0';

  char szMinor[3];
  szMinor[0] = szVersion[2];
  szMinor[1] = szVersion[3];
  szMinor[2] = '\0';

  char szBuild[5];
  szBuild[0] = szVersion[5];
  szBuild[1] = szVersion[6];
  szBuild[2] = szVersion[7];
  szBuild[3] = szVersion[8];
  szBuild[4] = '\0';

  *dwMajor = atoi(szMajor);
  *dwMinor = atoi(szMinor);
  *dwBuild = atoi(szBuild);
}


BOOL CLogParser::DetectWindowInstallerVersion(char *szLine, DWORD *dwMajor, DWORD *dwMinor, DWORD *dwBuild)
{
	BOOL bRet = FALSE;

	//below based on this...
	//=== Verbose logging started: 7/18/2000  12:46:39  Build type:
    //DEBUG UNICODE 1.11.1820.00  Calling process: D:\WINNT\system32\msiexec.exe ===

	const char *szToken = "Build type:";
	const char *szAnsiToken = "ANSI";
	const char *szUnicodeToken = "UNICODE";
	const char *szCallingProcessToken = "Calling process";

    char *pszTokenFound = strstr(szLine, szToken);
	if (pszTokenFound)
	{
       char *pszAnsiTokenFound = strstr(szLine, szAnsiToken);
	   if (pszAnsiTokenFound)
	   {
          char *pszCallingProcessTokenFound = strstr(szLine, szCallingProcessToken);
		  if (pszCallingProcessTokenFound)
		  {
			  //get version now...
			  char *szVersion = pszAnsiTokenFound + strlen(szAnsiToken) + 1;
			  if (szVersion < pszCallingProcessTokenFound)
			  {
				 CopyVersions(szVersion, dwMajor, dwMinor, dwBuild);
    			 bRet = TRUE;
			  }	  

			  bRet = TRUE;
		  }
	   }
	   else
	   {
		   char *pszUnicodeTokenFound = strstr(szLine, szUnicodeToken);
		   if (pszUnicodeTokenFound)
		   {
              char *pszCallingProcessTokenFound = strstr(szLine, szCallingProcessToken);
			  if (pszCallingProcessTokenFound)
			  {
				  //get version now...
				  char *szVersion = pszUnicodeTokenFound + strlen(szUnicodeToken) + 1;
				  if (szVersion < pszCallingProcessTokenFound)
				  {
				     CopyVersions(szVersion, dwMajor, dwMinor, dwBuild);
					 bRet = TRUE;
				  }
			  }
		   }
	   }
	}

	return bRet;
}


BOOL CLogParser::DoDateTimeParse(char *szLine, char *szDateTime)
{
   BOOL bRet = FALSE;

   //below based on this...
	//=== Verbose logging started: 7/18/2000  12:46:39  Build type:
    //DEBUG UNICODE 1.11.1820.00  Calling process: D:\WINNT\system32\msiexec.exe ===

	const char *szToken = "logging started: ";
	const char *szBuildToken = "Build ";
    char *pszTokenFound = strstr(szLine, szToken);
	if (pszTokenFound)
	{
       char *pszBuildTokenFound = strstr(szLine, szBuildToken);
	   if (pszBuildTokenFound && (pszTokenFound < pszBuildTokenFound))
	   {
          char *szDate = pszTokenFound + strlen(szToken);
		  if (szDate)
		  {
             int iNumCopy = pszBuildTokenFound - szDate;  
			 strncpy(szDateTime, szDate, iNumCopy);

             szDateTime[iNumCopy] = '\0';
			 bRet = TRUE;
		  }
	   }
	}
 
    return bRet;
}


BOOL CLogParser::DoProductParse(char *szLine, char *szProduct)
{
   BOOL bRet = FALSE;

//MSI (c) (F0:B0): Executing op: ProductInfo(ProductKey={DC9359A6-692A-C9E6-FB13-4EE89C504C02},ProductName=Custom Action test,PackageName=34c1d6.msi,Language=1033,Version=16777216,Assignment=1,ObsoleteArg=0,)   

   const char *szToken = "Executing op: ProductInfo(";
   char *pszTokenFound = strstr(szLine, szToken);
   if (pszTokenFound)
   {
      char *szProductFound = pszTokenFound + strlen(szToken);
	  if (szProductFound)
	  {
	     strcpy(szProduct, szProductFound);

		 StripLineFeeds(szProduct); //take off \r\n
		 bRet = TRUE;
	  }
   }

   return bRet;
}



BOOL CLogParser::DoCommandLineParse(char *szLine, char *szCommandLine)
{
   BOOL bRet = FALSE;

//           ******* CommandLine:  
	const char *szToken = "** CommandLine: ";
    char *pszTokenFound = strstr(szLine, szToken);
	if (pszTokenFound)
	{
       char *szCmdLine = pszTokenFound + strlen(szToken);
	   if (szCmdLine)
	   {
	      strcpy(szCommandLine, szCmdLine);

		  int iLen = strlen(szCommandLine);
		  if (iLen <= 2)
		  {
             strcpy(szCommandLine, "(none)");
		  }
		  else
             StripLineFeeds(szCommandLine);

		  bRet = TRUE;
	   }
	}

   return bRet;
}


BOOL CLogParser::DoUserParse(char *szLine, char *szUser)
{
   BOOL bRet = FALSE;

//MSI (c) (F0:18): MainEngineThread: Process token is for: NORTHAMERICA\nmanis
//MSI (c) (F0:18): At the beginning of CreateAndRunEngine: NORTHAMERICA\nmanis [process]
//MSI (c) (F0:18): Resetting cached policy values
//MSI (c) (F0:18): After Impersonating in CreateAndRunEngine: NORTHAMERICA\nmanis [process]

	const char *szToken = "MainEngineThread: Process token is for: ";
    char *pszTokenFound = strstr(szLine, szToken);
	if (pszTokenFound)
	{
       char *szUserFound = pszTokenFound + strlen(szToken);
	   if (szUserFound)
	   {
	      strcpy(szUser, szUserFound);

		  StripLineFeeds(szUser);
		  bRet = TRUE;
	   }
	}
 
    return bRet;
}



//protected methods...
BOOL CLogParser::DetectProperty(char *szLine, char *szPropName, char *szPropValue, int *piPropType)
{
    BOOL bRet = FALSE;

	const char *szProperty = "Property(";
    int len = strlen(szProperty);
    int result = strncmp(szLine, szProperty, len);
    if (!result)
	{
	   const char *pszPropNameToken = ": "; 
	   const char *pszPropValueToken = " = "; 

	   char *pFoundPropNameToken  = strstr(szLine, pszPropNameToken);
	   char *pFoundPropValueToken = strstr(pFoundPropNameToken, pszPropValueToken);
	   if (pFoundPropNameToken && pFoundPropValueToken)
	   {
		  if ((szLine[len] == 'c') || (szLine[len] == 'C'))
			 *piPropType = CLIENT_PROP;

  		  if ((szLine[len] == 's') || (szLine[len] == 'S'))
			 *piPropType = SERVER_PROP;

  		  if ((szLine[len] == 'n') || (szLine[len] == 'N'))
			 *piPropType = NESTED_PROP;

          int lenCopy = 0;
		  lenCopy = (pFoundPropValueToken + strlen(pszPropNameToken)) - (pFoundPropNameToken + strlen(pszPropValueToken));

		  strncpy(szPropName, pFoundPropNameToken + strlen(pszPropNameToken), lenCopy);
          szPropName[lenCopy] = '\0';

		  lenCopy = strlen(pFoundPropValueToken) -  strlen(pszPropValueToken) - 1;

	      strncpy(szPropValue, pFoundPropValueToken + strlen(pszPropValueToken), lenCopy);
		  szPropValue[lenCopy] = '\0';

//5-4-2001
		  StripLineFeeds(szPropValue);
//end 5-4-2001

		  //property dump...
		  bRet = TRUE;
		}
	}

    return bRet;
}


BOOL CLogParser::DetectStatesCommon(const char *szToken, char *szLine, char *szName, char *szInstalled, char *szRequest, char *szAction)
{
	BOOL bRet = FALSE;

	const char *szInstalledToken = "Installed: ";
    const char *szRequestToken = "Request: ";
	const char *szActionToken  = "Action: ";
	const char *szEndStringToken = "\0";

	char *pTokenPos = NULL;
	char *pInstalledPos = NULL;
	char *pRequestPos = NULL;
	char *pActionPos = NULL;
	char *pEndStringPos = NULL;

	pTokenPos = strstr(szLine, szToken);
    pInstalledPos = strstr(szLine, szInstalledToken);
    pRequestPos = strstr(szLine, szRequestToken);
	pActionPos = strstr(szLine, szActionToken);
	pEndStringPos = strstr(szLine, szEndStringToken);

	if (pTokenPos && pInstalledPos && pRequestPos && pActionPos && pEndStringPos)
	{
	   //do the component name...
       int lenCopy = pInstalledPos - pTokenPos;
	   int lenToken = strlen(szToken);
	   if (lenCopy > lenToken)
	   {
		   lenCopy -= lenToken;
  	       strncpy(szName, pTokenPos + lenToken, lenCopy);
           szName[lenCopy] = '\0';
	   }

	   //do the installed value
       lenCopy =  pRequestPos - pInstalledPos;
	   lenToken = strlen(szInstalledToken);
	   if (lenCopy > lenToken)
	   {
		   lenCopy -= lenToken;
	   	   strncpy(szInstalled, pInstalledPos + lenToken, lenCopy);
           szInstalled[lenCopy] = '\0';
	   }

	   //do the request value
	   lenCopy =  pActionPos - pRequestPos;
	   lenToken = strlen(szRequestToken);
	   if (lenCopy > lenToken)
	   {
		   lenCopy -= lenToken;
	   	   strncpy(szRequest, pRequestPos + lenToken, lenCopy);
           szRequest[lenCopy] = '\0';
	   }

       //do the action value
       lenToken = strlen(szActionToken);
   	   strcpy(szAction, pActionPos + lenToken);

//5-4-2001
	   StripLineFeeds(szAction);
//end 5-4-2001

       bRet = TRUE;
	}

	return bRet;
}


BOOL CLogParser::DetectComponentStates(char *szLine, char *szName, char *szInstalled, char *szRequest, char *szAction, BOOL *pbInternalComponent)
{
	const char *szComponentToken = "Component: ";

//5-16-2001
	BOOL bRet;
	bRet = DetectStatesCommon(szComponentToken, szLine, szName, szInstalled, szRequest, szAction);

	if (szName[0] == '_' && szName[1] == '_') //internal property...
	{
       *pbInternalComponent = TRUE;
	}
	else
       *pbInternalComponent = FALSE;

	return bRet;
}


BOOL CLogParser::DetectFeatureStates(char *szLine, char *szName, char *szInstalled, char *szRequest, char *szAction)
{
	const char *szFeatureToken = "Feature: ";

	return DetectStatesCommon(szFeatureToken, szLine, szName, szInstalled, szRequest, szAction);
}





BOOL CLogParser::DetectWindowsError(char *szLine, char *szSolutions, BOOL *pbIgnorableError)
{
    BOOL bRet = FALSE;

	return bRet;
}


//ship ranges...
const int cimsgBase = 1000;   // offset for error messages, must be >=1000 for VBA
const int cidbgBase = 2000;   // offset for debug-only messages

/*
const   imsgHostStart = 1000;  // produced by install host or automation
const   imsgHostEnd   = 1000;  // produced by install host or automation

const   imsgServicesStart = 1100;  // produced by general services, services.h
const   imsgServicesEnd   = 1100;  // produced by general services, services.h

const   imsgDatabaseStart = 1200; // produced by database access, databae.h
const   imsgDatabaseEnd   = 1200; // produced by database access, databae.h

const 	imsgFileStart = 1300; // produced by file/volume services, path.h
const 	imsgFileEnd   = 1300; // produced by file/volume services, path.h

const 	imsgRegistryStart = 1400; // produced by registry services, regkey.h
const 	imsgRegistryEnd   = 1400; // produced by registry services, regkey.h

const 	imsgConfigStart   = 1500; // produced by configuration manager, iconfig.h
const 	imsgConfigEnd   = 1500; // produced by configuration manager, iconfig.h

const 	imsgActionStart  = 1600; // produced by standard actions, actions.h
const 	imsgActionEnd   = 1600; // produced by standard actions, actions.h

const 	imsgEngineStart   = 1700; // produced by engine, engine.h
const 	imsgEngineEnd   = 1700; // produced by engine, engine.h

const 	imsgHandlerStart  = 1800; // associated with UI control, handler.h
const 	imsgHandlerEnd  = 1800; // associated with UI control, handler.h

const 	imsgExecuteStart  = 1900; // produced by execute methods, engine.h
const 	imsgExecuteEnd  = 1900; // produced by execute methods, engine.h


const   idbgHostStart = 2000;  // produced by install host or automation
const   idbgHostEnd   = 2000;  // produced by install host or automation

const   idbgServicesStart = 2100;  // produced by general services, services.h
const   idbgServicesEnd   = 2100;  // produced by general services, services.h

const   idbgDatabaseStart = 2200; // produced by database access, databae.h
const   idbgDatabaseEnd   = 2200; // produced by database access, databae.h

const 	idbgFileStart = 2300; // produced by file/volume services, path.h
const 	idbgFileEnd   = 2300; // produced by file/volume services, path.h

const 	idbgRegistryStart = 2400; // produced by registry services, regkey.h
const 	idbgRegistryEnd   = 2400; // produced by registry services, regkey.h

const 	idbgConfigStart   = 2500; // produced by configuration manager, iconfig.h
const 	idbgConfigEnd   = 2500; // produced by configuration manager, iconfig.h

const 	idbgActionStart  = 2600; // produced by standard actions, actions.h
const 	idbgActionEnd   = 2600; // produced by standard actions, actions.h

const 	idbgEngineStart   = 2700; // produced by engine, engine.h
const 	idbgEngineEnd   = 2700; // produced by engine, engine.h

const 	idbgHandlerStart  = 2800; // associated with UI control, handler.h
const 	idbgHandlerEnd  = 2800; // associated with UI control, handler.h

const 	idbgExecuteStart  = 2900; // produced by execute methods, engine.h
const 	idbgExecuteEnd  = 2900; // produced by execute methods, engine.h
*/

struct ErrorRange
{
	long Begin;
	long End;
};

ErrorRange ShipErrorRangeAr[10] = 
{ 
	{1000, 1099},
	{1100, 1199},
	{1200, 1299},
	{1300, 1399},
	{1400, 1499},
	{1500, 1599},
	{1600, 1699},
	{1700, 1799},
	{1800, 1899},
	{1900, 1999},
};

ErrorRange DebugErrorRangeAr[10] = 
{
	{2000, 2099},
	{2100, 2199},
	{2200, 2299},
	{2300, 2399},
	{2400, 2499},
	{2500, 2599},
	{2600, 2699},
	{2700, 2799},
	{2800, 2899},
	{2900, 2999},
};

//TODO, possibly make this customizable so user can add/delete which errors they want to ignore
//only two so far...  
#define NUM_IGNORE_DEBUG_ERRORS 3

int g_arIgnoreDebugErrors[NUM_IGNORE_DEBUG_ERRORS] = { 2898, 2826, 2827 };
//END TODO

BOOL RealWIError(long iErrorNumber, BOOL *pbIgnorable)
{
  BOOL bRet = FALSE;
  ErrorRange range;
  int iIndex;

  //ship error message???
  if ((iErrorNumber>= cimsgBase) && (iErrorNumber < cidbgBase))
  {
    iIndex = iErrorNumber - cimsgBase;
    range = ShipErrorRangeAr[(iIndex / 100)];
  
    if ((iErrorNumber >= range.Begin) && (iErrorNumber <= range.End))
	{
	  //flag this as an error...
	  bRet = TRUE;
	}
  }
  else if ((iErrorNumber >= cidbgBase) && (iErrorNumber < cidbgBase+1000))
  {
    //debug error message???
    iIndex = iErrorNumber - cidbgBase;
    range = DebugErrorRangeAr[(iIndex / 100)];
  
    if ((iErrorNumber >= range.Begin) && (iErrorNumber <= range.End))
	{
	   BOOL bIgnoreError = FALSE;
       for (int i=0; i < NUM_IGNORE_DEBUG_ERRORS; i++)
	   {
           if (iErrorNumber == g_arIgnoreDebugErrors[i])
		   {
			  bIgnoreError = TRUE;
		   }
	   }

	   if (bIgnoreError) 	    //flag this as an ignored error...
          *pbIgnorable = bIgnoreError;

	   bRet = TRUE;
	}
  }

  return bRet;
}


struct ErrorLookup
{
	long Number;
	char szSolution[1024];
};


#define KNOWN_IGNORED_ERRORS 3
ErrorLookup g_ErrorLookupArray[KNOWN_IGNORED_ERRORS] = 
{
	2898, "Font was created.",
	2826, "Indicates that an item extends beyond the bounds of the given dialog.\r\nNot a big deal, but might be useful to catch if you don't see something you expect to see.",
	2827, "Indicates that a radio button extends beyond the bounds of the given group box.\r\nNot a big deal, but might be useful to catch if you don't see something you expect to see."
};



#define KNOWN_MAJOR_ERRORS    3
#define ERROR_SOL_SIZE     8192


//for hack below to workaround overlap in error codes!!!
#define ERR_DUPLICATE_BASE 1601
#define ERR_DUPLICATE_END 1609


char szDuplicatedErrors[ERR_DUPLICATE_END - ERR_DUPLICATE_BASE][256] =
{
	"The Windows Installer service could not be accessed. Contact your support personnel to verify that the Windows Installer service is properly registered", //1601
    "User cancel installation", //1602
    "Fatal error during installation", //1603
	"Installation suspended, incomplete", //1604
	"This action is only valid for products that are currently installed", //1605
	"Feature ID not registered", //1606
	"Component ID not registered", //1607
	"Unknown property" //1608
};


BOOL DetermineSolution(long iErrorNumber, char *szSolutions)
{
    BOOL bRet = FALSE;
	DWORD dwRet = 0;

	LPVOID lpMsgBuf;
    dwRet = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | 
		                  FORMAT_MESSAGE_IGNORE_INSERTS | 
		                  FORMAT_MESSAGE_ALLOCATE_BUFFER, 
						  0, iErrorNumber, 0, (LPTSTR) &lpMsgBuf, ERROR_SOL_SIZE / 2, 0);

    if ((dwRet != ERROR_RESOURCE_LANG_NOT_FOUND) && dwRet)
	{
       if (strlen((LPTSTR)lpMsgBuf) < ERROR_SOL_SIZE)
	   {
	      bRet = TRUE;
	      strcpy(szSolutions, (LPTSTR)lpMsgBuf);
	   }
	}
	else
	{
		//is this one of the ignored ones???
		for (int i=0; (i <  NUM_IGNORE_DEBUG_ERRORS) && !bRet; i++)
		{
			if (g_ErrorLookupArray[i].Number == iErrorNumber)
			{
				bRet = TRUE;
				strcpy(szSolutions, g_ErrorLookupArray[i].szSolution);
			}
		}

		if (!bRet)
		{
		   //hack, hack...
           if ((iErrorNumber >= ERR_DUPLICATE_BASE) && (iErrorNumber < 1609))
		   {
              strcpy(szSolutions, szDuplicatedErrors[iErrorNumber - ERR_DUPLICATE_BASE]);
			  bRet = TRUE;
		   }
		   else //try to load it from our string table...
		   {
              int iRet = LoadString(NULL, IDS_INTERNAL_ERROR_BASE + iErrorNumber, szSolutions, SOLUTIONS_BUFFER);
  	          if (iRet)
			  {
		         bRet = TRUE;
			  }
			  else
			  {

			  }
		   }
		}
	}

	return bRet;
}



BOOL DetermineInternalErrorSolution(long iErrorNumber, char *szSolutions)
{
    BOOL bRet = FALSE;

	//is this one of the ignored ones???
	for (int i=0; (i <  NUM_IGNORE_DEBUG_ERRORS) && !bRet; i++)
	{
		if (g_ErrorLookupArray[i].Number == iErrorNumber)
		{
			bRet = TRUE;
			strcpy(szSolutions, g_ErrorLookupArray[i].szSolution);
		}
	}

	if (!bRet)
	{
       //do something here to make it better...
	   int iRet = LoadString(NULL, IDS_INTERNAL_ERROR_BASE + iErrorNumber, szSolutions, SOLUTIONS_BUFFER);
	   if (iRet)
	   {
		  bRet = TRUE;
	   }
	}

	return bRet;
}



BOOL CLogParser::DetectInstallerInternalError(char *szLine, char *szSolutions, BOOL *pbIgnorable, int *piErrorNumber)
{
    BOOL bRet = FALSE;

	//Internal Error 2755.3, k:\xml-ma\1105\fre\cd_image\mms xml and file toolkit.msi
	//2755.3

	const char *szInternalErrorToken = "Internal Error ";

	char *lpszInternalErrorFound = strstr(szLine, szInternalErrorToken);
	if (lpszInternalErrorFound)
	{
       //parse the error number now and do a look up on error number in error table...
       char *lpszErrorNumber = lpszInternalErrorFound + strlen(szInternalErrorToken);	   
	   if (lpszErrorNumber)
	   {
           long iErrorNumber;
              
           char szError[16];
 		   int iAmountCopy = 4; //REVIEW, maybe better to do a strstr and look for . instead...

           strncpy(szError, lpszErrorNumber, iAmountCopy);

		   szError[iAmountCopy] = '\0';

  	  	   iErrorNumber = atoi(szError);

		   BOOL bIgnorableError = FALSE;
           bRet = RealWIError(iErrorNumber, &bIgnorableError);
		   if (bRet)
		   {
             *piErrorNumber = iErrorNumber;

             *pbIgnorable = bIgnorableError;
             BOOL bSolutionFound = DetermineInternalErrorSolution(iErrorNumber, szSolutions);
  	  	  	 if (!bSolutionFound)
			 {
			 	//make note of it...
				strcpy(szSolutions, "Solution Unknown");
			 }
		   }
	   }
	}

    return bRet;
}


BOOL CLogParser::DetectOtherError(char *szLine, char *szSolutions, BOOL *pbIgnorableError, int *piErrorNumber)
{
    BOOL bRet = FALSE;

    //MSI (c) (E4:50): MainEngineThread is returning 1602
	const char *szClient = "MSI (c)";
	const char *szErrorToken = "MainEngineThread is returning ";

	char *lpszFound = strstr(szLine, szClient);
	if (lpszFound)
	{
       lpszFound = strstr(szLine, szErrorToken);
	   if (lpszFound)
	   {
          //parse the error number now and do a look up on error number in error table...
          char *lpszErrorNumber = lpszFound + strlen(szErrorToken);	   
	      if (lpszErrorNumber)
		  {
             long iErrorNumber;
             char szError[16];
		     int iAmountCopy = 4;

             strncpy(szError, lpszErrorNumber, iAmountCopy);
		     szError[iAmountCopy] = '\0';

  	  	     iErrorNumber = atoi(szError);

		     BOOL bIgnorableError = FALSE;
             bRet = RealWIError(iErrorNumber, &bIgnorableError);
		     if (bRet)
			 {
                *pbIgnorableError = bIgnorableError;
				*piErrorNumber = iErrorNumber;

                BOOL bSolutionFound = DetermineSolution(iErrorNumber, szSolutions);
				if (!bSolutionFound)
				{
					//make note of it...
					strcpy(szSolutions, "(Solution Unknown)");
				}
			 }
		  }
	   }
	}

	return bRet;
}



BOOL CLogParser::DetectCustomActionError(char *szLine, char *szSolutions, BOOL *pbIgnorableError)
{
  BOOL bRet = FALSE;

  const char *szEndAction = "Action ended";
  const char *szReturnValue = "Return value ";

  int len = strlen(szEndAction);
  int result = _strnicmp(szLine, szEndAction, len);
  if (!result)
  {
	 char *lpszReturnValueFound = strstr(szLine, szReturnValue);
	 if (lpszReturnValueFound)
	 {
        char *lpszValue = lpszReturnValueFound+strlen(szReturnValue);

		if (lpszValue)
		{
           int iValue = atoi(lpszValue);
		   if (iValue == 3)
		   {
              strcpy(szSolutions, "A standard action or custom action caused the failure.");
              bRet = TRUE;
			  *pbIgnorableError = FALSE;
		   }
           else if (iValue == 2)
		   {
              strcpy(szSolutions, "User canceled action.");
              bRet = TRUE;
			  *pbIgnorableError = FALSE;
		   }
		}
	 }
  }

  return bRet;
}
//END Error analysis functions





int GetPolicyValue(char *szPolicyString)
{
	const char *constPolicyVal = "' is";
	char *lpszValue;
	int iValue = -1;

    lpszValue = strstr(szPolicyString, constPolicyVal);
	if (lpszValue)
	{
	   iValue = atoi(lpszValue + strlen(constPolicyVal));
	   ASSERT(iValue >= 0);
	}

	return iValue;
}

BOOL GetPolicyName(char *szPolicyString, char *lpszPolicyName)
{
	BOOL bRet = FALSE;
	char *lpszPolicyNameFound;
    const char *lpconstName = "'";

	lpszPolicyNameFound = strstr(szPolicyString, lpconstName);
    if (lpszPolicyNameFound)
	{
	   int iAmountCopy = lpszPolicyNameFound - szPolicyString;

       strncpy(lpszPolicyName, szPolicyString, iAmountCopy);
       lpszPolicyName[iAmountCopy] = '\0';
	   bRet = TRUE;
    }
	
	return bRet;
}


//will come in like: policyname' is value
BOOL CLogParser::ParseUserPolicy(char *szPolicyString, 	UserPolicySettings &UserPolicies)
{
    BOOL bRet = FALSE;

	char lpszPolicyName[MAX_POLICY_NAME];
	bRet = GetPolicyName(szPolicyString, lpszPolicyName);
	if (bRet)
	{
       int iValue;
       iValue = GetPolicyValue(szPolicyString);

	   BOOL bFound = FALSE;
	   int  iRet;
	   for (int i=0; (i < UserPolicies.iNumberUserPolicies) && !bFound; i++)
	   {
           iRet = _stricmp(lpszPolicyName, UserPolicies.UserPolicy[i].PolicyName);
		   bFound = iRet == 0;
       }

	   if (bFound) //set member...
		  UserPolicies.UserPolicy[i-1].bSet = iValue;

	   bRet = bFound;
	}

	return bRet;
}

//will come in like: policyname' is value
BOOL CLogParser::ParseMachinePolicy(char *szPolicyString, 	MachinePolicySettings &MachinePolicies)
{
    BOOL bRet = FALSE;

	char lpszPolicyName[MAX_POLICY_NAME];
	bRet = GetPolicyName(szPolicyString, lpszPolicyName);
	if (bRet)
	{
	   int iValue;
       iValue = GetPolicyValue(szPolicyString);

	   BOOL bFound = FALSE;
	   int  iRet;
	   for (int i=0; (i < MachinePolicies.iNumberMachinePolicies) && !bFound; i++)
	   {
           iRet = _stricmp(lpszPolicyName, MachinePolicies.MachinePolicy[i].PolicyName);
           bFound = iRet == 0;
       }

	   if (bFound) //set member...
		  MachinePolicies.MachinePolicy[i-1].bSet = iValue;

	   bRet = bFound;
	}

	return bRet;
}



//2-9-2001
BOOL CLogParser::DetectPolicyValue(char *szLine, 
								   MachinePolicySettings &MachinePolicySettings,
                                   UserPolicySettings &UserPolicySettings
)
{
  BOOL bRet = FALSE;

  const char *szUserPolicyValue = "User policy value '";
  const char *szMachinePolicyValue = "Machine policy value '";

  char *lpszFound;
  char *lpszPolicyName;

  lpszFound = strstr(szLine, szUserPolicyValue);
  if (lpszFound) //user policy?
  {
	 lpszPolicyName = lpszFound + strlen(szUserPolicyValue);
	 if (lpszPolicyName)
	 {
        bRet = ParseUserPolicy(lpszPolicyName, UserPolicySettings);
	 }
  }
  else
  {
     lpszFound = strstr(szLine, szMachinePolicyValue); //machine policy?
     if (lpszFound)
	 {
	    lpszPolicyName = lpszFound + strlen(szMachinePolicyValue);
        if (lpszPolicyName)
		{
           bRet = ParseMachinePolicy(lpszPolicyName, MachinePolicySettings);
		}
	 }
  }

  return bRet;
}

//2-13-2001
BOOL CLogParser::DetectElevatedInstall(char *szLine, BOOL *pbElevatedInstall, BOOL *pbClient)
{
     if (!pbElevatedInstall || !pbClient) //bad pointer...
		return FALSE;

	 BOOL bRet = FALSE;
	 BOOL bElevated = -1; //set to neither TRUE or FALSE
	 BOOL bClient = FALSE;

	 //do parse here..
	 const char *szServer = "MSI (s)";
	 const char *szClient = "MSI (c)";

     const char *szAssignment = "Running product";
     const char *szUserPriv = "with user privileges:";
	 const char *szElevatedPriv = "with elevated privileges:";

     char *lpszFound;
     char *lpszSkipProductCode;

     lpszFound = strstr(szLine, szAssignment);
     if (lpszFound) //user policy?
	 {
	   lpszSkipProductCode = lpszFound + strlen(szAssignment);
	   if (lpszSkipProductCode)
	   {
          lpszFound = strstr(lpszSkipProductCode, szUserPriv);
		  if (lpszFound) //user?
		  {
 	         lpszFound = strstr(szLine, szServer);
			 if (lpszFound) //server side user?
			 {
				bClient = FALSE;
  		 	    bElevated = FALSE;
			    bRet = TRUE;

			 }
			 else
			 {
 	           lpszFound = strstr(szLine, szClient); //client side user?
			   if (lpszFound)
			   {
				  bClient = TRUE;
  		 	      bElevated = FALSE;
			      bRet = TRUE;
			   }
			 }
		  }
		  else //elevated???
		  {
			  lpszFound = strstr(lpszSkipProductCode, szElevatedPriv);
			  if (lpszFound)
			  {
   	             lpszFound = strstr(szLine, szServer);
			     if (lpszFound) //server side elevated?
				 {
				    bClient = FALSE;
  		 	        bElevated = TRUE;
			        bRet = TRUE;

				 }
			     else
				 {
 	                lpszFound = strstr(szLine, szClient); //client side elevated?
			        if (lpszFound)
					{
				       bClient = TRUE;
  		 	           bElevated = TRUE;
			           bRet = TRUE;
					}
				 }
			 }
		  }
	   }
	 }
     
	 if (bRet)
	 {
	    *pbElevatedInstall = bElevated;
		*pbClient = bClient;
	 }
    
	 return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\common.cpp ===
#include "stdafx.h"
#include "Common.h"


//in BGR form.  COLORREF needs to use RGB macro to work as COLORREF is bbggrr
struct HTMLColorSettings InitialUserSettings = 
{
	     "(CLIENT) Client Context", 0xFF00FF,  
		 "(SERVER) Server Context", 0xFF0000, 
		 "(CUSTOM) CustomAction Context", 0x00AA00, 
		 "(UNKNOWN) Unknown Context", 0x000000,
		 "(ERROR) Error Area", 0x0000FF, 
		 "(PROPERTY) Property", 0xFFAA00, 
		 "(STATE) State", 0x555555,
		 "(POLICY) Policy", 0x008000,
		 "(IGNORED) Ignored Error", 0x0000AA
};


void InitHTMLColorSettings(HTMLColorSettings &settings1)
{
	int iCount = MAX_HTML_LOG_COLORS;
//	settings1.iNumberColorSettings = iCount;

    for (int i=0; i < iCount; i++)
	{
	  strcpy(settings1.settings[i].name, InitialUserSettings.settings[i].name);
      settings1.settings[i].value = InitialUserSettings.settings[i].value;
	}
}


//5-9-2001, has all 2.0 policies now
char MachinePolicyTable[MAX_MACHINE_POLICIES][MAX_POLICY_NAME] =
{ 
//machine
	"AllowLockDownBrowse",
	"AllowLockdownMedia",
	"AllowLockdownPatch",
	"AlwaysInstallElevated",
	"Debug",
	"DisableBrowse",
	"DisableMSI",
	"DisablePatch",
	"DisableRollback",
    "DisableUserInstalls",
	"EnableAdminTSRemote",
	"EnableUserControl",
	"LimitSystemRestoreCheckpointing",
	"Logging",
	"SafeForScripting",
	"TransformsSecure"
};


char UserPolicyTable[MAX_USER_POLICIES][MAX_POLICY_NAME] =
{
//user
	"AlwaysInstallElevated",
	"DisableMedia",
	"DisableRollback",
	"SearchOrder",
	"TransformsAtSource"
};


//5-9-2001, made policies not dependent on version and what is set in MAX_MACHINE_POLICIES
void InitMachinePolicySettings(MachinePolicySettings &policies)
{
  policies.iNumberMachinePolicies = MAX_MACHINE_POLICIES;

  int iCount = MAX_MACHINE_POLICIES;
  for (int i=0; i < iCount; i++)
  {
	  policies.MachinePolicy[i].bSet = -1;
	  strcpy(policies.MachinePolicy[i].PolicyName, MachinePolicyTable[i]);
  }
}


void InitUserPolicySettings(UserPolicySettings &policies)
{
  policies.iNumberUserPolicies = MAX_USER_POLICIES;

  int iCount = MAX_USER_POLICIES;
  for (int i=0; i < iCount; i++)
  {
	  policies.UserPolicy[i].bSet = -1;
	  strcpy(policies.UserPolicy[i].PolicyName, UserPolicyTable[i]);
  }
}
//end 5-9-2001

BOOL         g_bNT = FALSE;
BOOL         g_bRunningInQuietMode = FALSE;

const TCHAR *g_szDefaultOutputLogDir = _T("c:\\WILogResults\\");
TCHAR        g_szLogFileToParse[MAX_PATH] = "";
const TCHAR  *g_szDefaultIgnoredErrors = _T("2898,2826,2827");
BOOL         g_bShowEverything = FALSE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\clientpp.h ===
#if !defined(AFX_CLIENTPROPERTYPAGE_H__153ECD67_C022_4A4F_A246_146A0EFF509B__INCLUDED_)
#define AFX_CLIENTPROPERTYPAGE_H__153ECD67_C022_4A4F_A246_146A0EFF509B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ClientPP.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CClientPropertyPage dialog

class CClientPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CClientPropertyPage)

// Construction
public:
	CClientPropertyPage();
	~CClientPropertyPage();

	static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

	BOOL SetClientPropNames(CStringArray *cstrClientPropNameArray)
	{
        m_pcstrClientPropNameArray = cstrClientPropNameArray;
		return TRUE;
	}

	BOOL SetClientPropValues(CStringArray *cstrClientPropValueArray)
	{
        m_pcstrClientPropValueArray = cstrClientPropValueArray;
		return TRUE;
	}
	
    BOOL m_bClientPropSortUp;


// Dialog Data
	//{{AFX_DATA(CClientPropertyPage)
	enum { IDD = IDD_PROPPAGE_CLIENT };
	CListCtrl	m_lstClientProp;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CClientPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CStringArray *m_pcstrClientPropNameArray;
	CStringArray *m_pcstrClientPropValueArray;

	CListCtrl *m_pCurrentListSorting;
	int       m_iCurrentColumnSorting;
	BOOL      m_bCurrentSortUp;

	int  m_iClientLastColumnClick;
	int  m_iClientLastColumnClickCache;



	// Generated message map functions
	//{{AFX_MSG(CClientPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnColumnClickClientProp(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CLIENTPROPERTYPAGE_H__153ECD67_C022_4A4F_A246_146A0EFF509B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\logviewd.cpp ===
// LogViewD.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "LogViewD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDetailedLogViewDlg dialog


CDetailedLogViewDlg::CDetailedLogViewDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDetailedLogViewDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDetailedLogViewDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDetailedLogViewDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDetailedLogViewDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDetailedLogViewDlg, CDialog)
	//{{AFX_MSG_MAP(CDetailedLogViewDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDetailedLogViewDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\logparse.h ===
// LogParse.h: interface for the CLogParser class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGPARSER_H__E759EBFC_8B37_40C0_819F_26B111063F44__INCLUDED_)
#define AFX_LOGPARSER_H__E759EBFC_8B37_40C0_819F_26B111063F44__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CLogParser  
{
public:
	CLogParser();
	virtual ~CLogParser();

	BOOL DetectWindowInstallerVersion(char *szLine, DWORD *dwMajor, DWORD *dwMinor, DWORD *dwBuild);

	//standard info about log
	BOOL DoDateTimeParse(char *szLine, char *szDateTime); 
	BOOL DoProductParse(char *szLine, char *szProduct);
	BOOL DoCommandLineParse(char *szLine, char *szCommandline);
	BOOL DoUserParse(char *szLine, char *szUser);

	//policy detection...
    BOOL DetectPolicyValue(char *szLine, 
		                   struct MachinePolicySettings &MachinePolicySettings,
	                       struct UserPolicySettings &UserPolicySettings);

    BOOL ParseMachinePolicy(char *szPolicyString, MachinePolicySettings &MachinePolicy);
    BOOL ParseUserPolicy(char *szPolicyString,  UserPolicySettings &UserPolicy);

	//error detection functions...
	BOOL DetectOtherError(char *szLine, char *szSolutions, BOOL *pbIgnorable, int *piErrorNumber);
    BOOL DetectInstallerInternalError(char *szLine, char *szSolutions, BOOL *pbIgnorable, int *piErrorNumber);

    BOOL DetectWindowsError(char *szLine, char *szSolutions, BOOL *pbIgnorable);
	BOOL DetectCustomActionError(char *szLine, char *szSolutions, BOOL *pbIgnorable);

	//property functions...
	BOOL DetectProperty(char *szLine, char *szPropName, char *szPropValue, int *piPropType);

    BOOL DetectComponentStates(char *szLine, char *szName, char *szInstalled, char *szRequest, char *szAction, BOOL *pbInternalComponent);
	BOOL DetectFeatureStates(char *szLine, char *szName, char *szInstalled, char *szRequest, char *szAction);

	//permission detection functions
    BOOL DetectElevatedInstall(char *szLine, BOOL *pbElevatedInstall, BOOL *pbClient);

	void SetLogType(BOOL bUnicodeLog)	{ m_bIsUnicodeLog = bUnicodeLog; }

protected:
    BOOL m_bIsUnicodeLog;

	//state functions
    BOOL DetectStatesCommon(const char *szTokenSearch, char *szLine, char *szName, char *szInstalled, char *szRequest, char *szAction);
};

#endif // !defined(AFX_LOGPARSER_H__E759EBFC_8B37_40C0_819F_26B111063F44__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\logviewd.h ===
#if !defined(AFX_DETAILEDLOGVIEWDLG_H__9C60973C_2E04_4EBE_95DB_C6CE5AE63EF8__INCLUDED_)
#define AFX_DETAILEDLOGVIEWDLG_H__9C60973C_2E04_4EBE_95DB_C6CE5AE63EF8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// LogViewD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDetailedLogViewDlg dialog

class CDetailedLogViewDlg : public CDialog
{
// Construction
public:
	CDetailedLogViewDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDetailedLogViewDlg)
	enum { IDD = IDD_ADVVIEW_DIALOG1 };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDetailedLogViewDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDetailedLogViewDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DETAILEDLOGVIEWDLG_H__9C60973C_2E04_4EBE_95DB_C6CE5AE63EF8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\optionsd.cpp ===
// OptionsD.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "Optionsd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COptionsDlg dialog


COptionsDlg::COptionsDlg(CWnd* pParent /*=NULL*/)
	: CDialog(COptionsDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(COptionsDlg)
	m_cstrOutputDirectory = g_szDefaultOutputLogDir;
	//}}AFX_DATA_INIT
}

void COptionsDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COptionsDlg)
	DDX_Control(pDX, IDC_LIST1, m_lstIgnoredErrors);
	DDX_Text(pDX, IDC_OUTPUTDIRECTORY, m_cstrOutputDirectory);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COptionsDlg, CDialog)
	//{{AFX_MSG_MAP(COptionsDlg)
	ON_WM_CTLCOLOR()
	ON_BN_CLICKED(IDOK, OnOk)
	//}}AFX_MSG_MAP
    ON_COMMAND_RANGE(IDC_CHOOSECOLOR_CLIENT, IDC_CHOOSECOLOR_IGNOREDERRORS, OnChooseColor)
END_MESSAGE_MAP()


HBRUSH COptionsDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{
	HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);

	int id = pWnd->GetDlgCtrlID();
	if ((id >= IDC_CLIENTCONTEXT) && (id <= IDC_IGNOREDERROR))
	{
	   int iPos = id - IDC_CLIENTCONTEXT;
       if (m_brArray[iPos].m_hObject)
	   {
		   m_brArray[iPos].DeleteObject();

	   }

   	   COLORREF col;
	   col = m_arColors.GetAt(iPos);

       m_brArray[iPos].CreateSolidBrush(col);

	   hbr = m_brArray[iPos];
	}
	
	return hbr;
}


BOOL COptionsDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	UINT iSize = m_arColors.GetSize();
	if (iSize == MAX_HTML_LOG_COLORS)
	{
	  BOOL bRet;
	  COLORREF col;
	  for (UINT i = 0; i < iSize; i++)
	  {
		  col = m_arColors.GetAt(i);

		  bRet = m_brArray[i].CreateSolidBrush(col);
		  ASSERT(bRet);
	  }
	}

	
	CString cstrErr;
	if (!m_cstrIgnoredErrors.IsEmpty())
	{
/*
//FUTURE TODO, need to parse m_cstrIgnoredErrors
	   BOOL bDone = FALSE;
	   char *lpszFound;
	   do
	   {
		  lpszFound = strstr(m_cstrIgnoredErrors, ",");
		  if (lpszFound)
		  {
			 char *lpszFoundNext;
             lpszFoundNext = strstr(lpszFound+1, ",");
			 if (lpszFoundNext)
			 {
			    int chars = lpszFoundNext - lpszFound;

			    char szError[16];
			    if ((chars > 0) && (chars < 16))
				{
				   strncpy(szError, lpszFound+1, chars-1);
				   szError[chars-1] = '\0';
				   m_lstIgnoredErrors.InsertItem(-1, szError);

				   *lpszFound = ';';
				}
			    else
                   bDone = TRUE;
			 }
			 else //must be last one...
			 {

			 }
			 
       	  }
		  else
			 bDone = TRUE;
	   }

	   while (!bDone);
	//END TODO
*/
	}


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void COptionsDlg::OnChooseColor(UINT iCommandID)
{
  CColorDialog dlg;

  //5-3-2001, don't show in quiet mode...
  if (!g_bRunningInQuietMode)
  {
     int iRet = dlg.DoModal();
     if (IDOK == iRet)
	 {
	    int iPos = iCommandID - IDC_CHOOSECOLOR_CLIENT;

	    COLORREF col;
	    col = dlg.GetColor();
        if (iPos < m_arColors.GetSize())
		{
  	       m_arColors.SetAt(iPos, col);
           if (m_brArray[iPos].m_hObject)
  	          m_brArray[iPos].DeleteObject();

   	       COLORREF col;
	       col = m_arColors.GetAt(iPos);

           m_brArray[iPos].CreateSolidBrush(col);
	       Invalidate();
		}
	 }
  }
}


void COptionsDlg::OnOk() 
{
  UpdateData(TRUE);

  int iLength = m_cstrOutputDirectory.GetLength();
  int iRet = m_cstrOutputDirectory.ReverseFind('\\');
  if (iRet < iLength-1) 
  {
     m_cstrOutputDirectory += "\\"; //add back slash to out dir...
  }

  BOOL bRet = IsValidDirectory(m_cstrOutputDirectory);
  if (bRet)
  {
	 UpdateData(TRUE);

	 if (iRet < iLength-1) 
        m_cstrOutputDirectory += "\\"; //add back slash to out dir...

	 EndDialog(IDOK);
  }
  else
  {
     if (!g_bRunningInQuietMode)
	 {
	    AfxMessageBox("Invalid directory name, please re-enter a valid directory");
	 }
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\policyd.cpp ===
// Policyd.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "Policyd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPoliciesDlg dialog


CPoliciesDlg::CPoliciesDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPoliciesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPoliciesDlg)
	//}}AFX_DATA_INIT
}


void CPoliciesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPoliciesDlg)
}


BEGIN_MESSAGE_MAP(CPoliciesDlg, CDialog)
	//{{AFX_MSG_MAP(CPoliciesDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CFont g_font;

/////////////////////////////////////////////////////////////////////////////
// CPoliciesDlg message handlers
BOOL CPoliciesDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	DWORD dwEditStyle   = 0;
	DWORD dwEditStyleEx = 0;

	DWORD dwStaticStyle   = 0;
	DWORD dwStaticStyleEx = 0;

	RECT EditRect = { 0 };
	RECT StaticRect = { 0 };

	UINT iStatic = (UINT) IDC_STATIC;

	//set first column for machine policies
	CWnd *pWnd;
	pWnd = GetDlgItem(IDC_MACHINEEDITCOL1);
	if (pWnd)
	{
	  CString str;

	  dwEditStyle = pWnd->GetStyle();
	  dwEditStyleEx = pWnd->GetExStyle();

      pWnd->GetWindowRect(&EditRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&EditRect, 2);
//	  ScreenToClient(&EditRect);

	  if (m_pMachinePolicySettings->MachinePolicy[0].bSet == -1)
		  str = "?";
	  else
		 str.Format("%d", m_pMachinePolicySettings->MachinePolicy[0].bSet);

	  pWnd->SetWindowText(str);
	}

	pWnd = GetDlgItem(IDC_MACHINECOL1);
	if (pWnd)
	{
       dwStaticStyle = pWnd->GetStyle();
	   dwStaticStyleEx = pWnd->GetExStyle();

       pWnd->GetWindowRect(&StaticRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&StaticRect, 2);
  //     ScreenToClient(&StaticRect);

	   pWnd->SetWindowText(m_pMachinePolicySettings->MachinePolicy[0].PolicyName);
	}	   

	int nextEditID = 0;

	CEdit   *pEdit;
	CStatic *pStatic;
    BOOL    bRet;

	RECT EditRectOld = { 0 };
	RECT StaticRectOld = { 0 };

	//create and populate state of each machine policy in first row
	for (int i = 1; i < (m_pMachinePolicySettings->iNumberMachinePolicies / 2); i++)
	{
		nextEditID = IDC_MACHINEEDITCOL1 + i*2;

		EditRectOld = EditRect;
		StaticRectOld = StaticRect;

		pEdit = new CEdit;
		EditRect.top    = EditRectOld.bottom + 7;
		EditRect.bottom = EditRectOld.bottom + (EditRectOld.bottom - EditRectOld.top) + 7;
		bRet = pEdit->CreateEx(dwEditStyleEx, "EDIT", NULL, dwEditStyle, EditRect, this, nextEditID);
		if (bRet)
		{
		  CString str;

		  if (m_pMachinePolicySettings->MachinePolicy[i].bSet == -1)
		     str = "?";
	      else
		     str.Format("%d", m_pMachinePolicySettings->MachinePolicy[i].bSet);

		  pEdit->SetWindowText(str);
          this->m_arEditArray.Add(pEdit);
		}
		else
		   delete pEdit;

		pStatic = new CStatic;
		StaticRect.top    = StaticRectOld.bottom + 7;
		StaticRect.bottom = StaticRectOld.bottom + (StaticRectOld.bottom - StaticRectOld.top) + 7;
		bRet = pStatic->CreateEx(dwStaticStyleEx, "STATIC", m_pMachinePolicySettings->MachinePolicy[i].PolicyName, dwStaticStyle, StaticRect, this, iStatic);
		if (bRet)
           this->m_arStaticArray.Add(pStatic);
		else
		   delete pStatic;
	}

	//set second column for machine policies
	pWnd = GetDlgItem(IDC_MACHINEEDITCOL2);
	if (pWnd)
	{
	  CString str;

	  if (m_pMachinePolicySettings->MachinePolicy[i].bSet == -1)
		  str = "?";
	  else
		 str.Format("%d", m_pMachinePolicySettings->MachinePolicy[i].bSet);
	  pWnd->SetWindowText(str);

      pWnd->GetWindowRect(&EditRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&EditRect, 2);
//	  ScreenToClient(&EditRect);
	}

	pWnd = GetDlgItem(IDC_MACHINEPROPCOL2);
	if (pWnd)
	{
       pWnd->SetWindowText(m_pMachinePolicySettings->MachinePolicy[i].PolicyName);

       pWnd->GetWindowRect(&StaticRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&StaticRect, 2);
//       ScreenToClient(&StaticRect);
	}

//create and populate state of each machine policy in second row
	for (int j = i+1; j < m_pMachinePolicySettings->iNumberMachinePolicies; j++)
	{
		nextEditID = IDC_MACHINEEDITCOL2 + j*2;

		EditRectOld = EditRect;
		StaticRectOld = StaticRect;

		pEdit = new CEdit;
		EditRect.top    = EditRectOld.bottom + 7;
		EditRect.bottom = EditRectOld.bottom + (EditRectOld.bottom - EditRectOld.top) + 7;
		bRet = pEdit->CreateEx(dwEditStyleEx, "EDIT", NULL, dwEditStyle, EditRect, this, nextEditID);
		if (bRet)
		{
		  CString str;

		  if (m_pMachinePolicySettings->MachinePolicy[j].bSet == -1)
		     str = "?";
	      else
		     str.Format("%d", m_pMachinePolicySettings->MachinePolicy[j].bSet);

		  pEdit->SetWindowText(str);
          this->m_arEditArray.Add(pEdit);
		}
		else
		   delete pEdit;

		pStatic = new CStatic;
		StaticRect.top    = StaticRectOld.bottom + 7;
		StaticRect.bottom = StaticRectOld.bottom + (StaticRectOld.bottom - StaticRectOld.top) + 7;
		bRet = pStatic->CreateEx(dwStaticStyleEx, "STATIC", m_pMachinePolicySettings->MachinePolicy[j].PolicyName, dwStaticStyle, StaticRect, this, iStatic);
		if (bRet)
           this->m_arStaticArray.Add(pStatic);
		else
		   delete pStatic;
	}

	//set first column for User policies
	pWnd = GetDlgItem(IDC_USEREDITCOL1);
	if (pWnd)
	{
	  CString str;

      pWnd->GetWindowRect(&EditRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&EditRect, 2);
//      ScreenToClient(&EditRect);
	  if (m_pUserPolicySettings->UserPolicy[0].bSet == -1)
		  str = "?";
	  else
		 str.Format("%d", m_pUserPolicySettings->UserPolicy[0].bSet);

	  pWnd->SetWindowText(str);
	}

	pWnd = GetDlgItem(IDC_USERCOL1);
	if (pWnd)
	{
       pWnd->GetWindowRect(&StaticRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&StaticRect, 2);
 //      ScreenToClient(&StaticRect);

	   pWnd->SetWindowText(m_pUserPolicySettings->UserPolicy[0].PolicyName);
	}	   


{ //so we can reuse i, C++ compiler bug...
//create and populate state of each user policy in first row
	for (int i = 1; i < (m_pUserPolicySettings->iNumberUserPolicies / 2); i++)
	{
		nextEditID = IDC_USEREDITCOL1 + i*2;

		EditRectOld = EditRect;
		StaticRectOld = StaticRect;

		pEdit = new CEdit;
		EditRect.top    = EditRectOld.bottom + 7;
		EditRect.bottom = EditRectOld.bottom + (EditRectOld.bottom - EditRectOld.top) + 7;
		bRet = pEdit->CreateEx(dwEditStyleEx, "EDIT", NULL, dwEditStyle, EditRect, this, nextEditID);
		if (bRet)
		{
		  CString str;

		  if (m_pUserPolicySettings->UserPolicy[i].bSet == -1)
		     str = "?";
	      else
		     str.Format("%d", m_pUserPolicySettings->UserPolicy[i].bSet);

		  pEdit->SetWindowText(str);
          this->m_arEditArray.Add(pEdit);
		}
		else
		   delete pEdit;

		pStatic = new CStatic;
		StaticRect.top    = StaticRectOld.bottom + 7;
		StaticRect.bottom = StaticRectOld.bottom + (StaticRectOld.bottom - StaticRectOld.top) + 7;

		bRet = pStatic->CreateEx(dwStaticStyleEx, "STATIC", m_pUserPolicySettings->UserPolicy[i].PolicyName,
			dwStaticStyle, 	StaticRect,	this, iStatic);

		if (bRet)
           this->m_arStaticArray.Add(pStatic);
		else
		   delete pStatic;
	}

//set second column for machine policies
	pWnd = GetDlgItem(IDC_USEREDITCOL2);
	if (pWnd)
	{
	  CString str;

	  if (m_pUserPolicySettings->UserPolicy[i].bSet == -1)
		  str = "?";
	  else
		 str.Format("%d", m_pUserPolicySettings->UserPolicy[i].bSet);
	  pWnd->SetWindowText(str);

      pWnd->GetWindowRect(&EditRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&EditRect, 2);
 //     ScreenToClient(&EditRect);
	}

	pWnd = GetDlgItem(IDC_USERCOL2);
	if (pWnd)
	{
       pWnd->SetWindowText(m_pUserPolicySettings->UserPolicy[i].PolicyName);

       pWnd->GetWindowRect(&StaticRect);
	  ::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&StaticRect, 2);
 //      ScreenToClient(&StaticRect);
	}

//create and populate state of each user policy in second row
	for (int j = i+1; j < m_pUserPolicySettings->iNumberUserPolicies; j++)
	{
		nextEditID = IDC_USEREDITCOL2 + j*2;

		EditRectOld = EditRect;
		StaticRectOld = StaticRect;

		pEdit = new CEdit;
		EditRect.top    = EditRectOld.bottom + 7;
		EditRect.bottom = EditRectOld.bottom + (EditRectOld.bottom - EditRectOld.top) + 7;
		bRet = pEdit->CreateEx(dwEditStyleEx, "EDIT", NULL, dwEditStyle, EditRect, this, nextEditID);
		if (bRet)
		{
		  CString str;

		  if (m_pUserPolicySettings->UserPolicy[j].bSet == -1)
		     str = "?";
	      else
		     str.Format("%d", m_pUserPolicySettings->UserPolicy[j].bSet);

		  pEdit->SetWindowText(str);
          this->m_arEditArray.Add(pEdit);
		}
		else
		   delete pEdit;

		pStatic = new CStatic;
		StaticRect.top    = StaticRectOld.bottom + 7;
		StaticRect.bottom = StaticRectOld.bottom + (StaticRectOld.bottom - StaticRectOld.top) + 7;
		bRet = pStatic->CreateEx(dwStaticStyleEx, "STATIC", m_pUserPolicySettings->UserPolicy[j].PolicyName, dwStaticStyle, StaticRect, this, iStatic);
		if (bRet)
           this->m_arStaticArray.Add(pStatic);
		else
		   delete pStatic;
	}
}

//make sure all controls use same font, stupid MFC problem...
	SendMessageToDescendants(WM_SETFONT, (WPARAM)this->GetFont()->m_hObject, //handle to font
		   MAKELONG ((WORD) FALSE, 0), //See above 
		   FALSE);    // send to all decedents(TRUE) 
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\policyd.h ===
#if !defined(AFX_POLICIESDLG_H__83F91A8A_5800_4521_ABF0_36AE0F3224BD__INCLUDED_)
#define AFX_POLICIESDLG_H__83F91A8A_5800_4521_ABF0_36AE0F3224BD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Policyd.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CPoliciesDlg dialog
class CPoliciesDlg : public CDialog
{
// Construction
public:
	CPoliciesDlg(CWnd* pParent = NULL);   // standard constructor

	void SetPolicyInformation(struct MachinePolicySettings &MachinePolicy,
	                          struct UserPolicySettings &UserPolicy)
	{
   	   m_pMachinePolicySettings = &MachinePolicy;
       m_pUserPolicySettings = &UserPolicy;
	}

	CArray<CEdit*, CEdit*> m_arEditArray;
	CArray<CStatic*, CStatic*> m_arStaticArray;

	~CPoliciesDlg()
	{
		int iCount, i;
		
		iCount = m_arEditArray.GetSize();
		for (i=0; i < iCount; i++)
		{
			CEdit *pEdit = m_arEditArray.GetAt(i);
			delete pEdit;
		}

		iCount = m_arStaticArray.GetSize();
		for (i=0; i < iCount; i++)
		{
			CStatic *pStatic = m_arStaticArray.GetAt(i);
			delete pStatic;
		}
	}
	
// Dialog Data
	//{{AFX_DATA(CPoliciesDlg)
	enum { IDD = IDD_POLICIESDLG };
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPoliciesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	struct MachinePolicySettings *m_pMachinePolicySettings;
	struct UserPolicySettings    *m_pUserPolicySettings;

	// Generated message map functions
	//{{AFX_MSG(CPoliciesDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_POLICIESDLG_H__83F91A8A_5800_4521_ABF0_36AE0F3224BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\nestedpp.h ===
#if !defined(AFX_NESTEDPROPERTYPAGE_H__FC5EAA3F_D8D9_4F19_8587_E7CE86416943__INCLUDED_)
#define AFX_NESTEDPROPERTYPAGE_H__FC5EAA3F_D8D9_4F19_8587_E7CE86416943__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// NestedPP.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNestedPropertyPage dialog

class CNestedPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CNestedPropertyPage)

// Construction
public:
	CNestedPropertyPage();
	~CNestedPropertyPage();
	
	static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

    BOOL m_bNestedPropSortUp;

	BOOL SetNestedPropNames(CStringArray *cstrNestedPropNameArray)
	{
        m_pcstrNestedPropNameArray = cstrNestedPropNameArray;
		return TRUE;
	}

	BOOL SetNestedPropValues(CStringArray *cstrNestedPropValueArray)
	{
        m_pcstrNestedPropValueArray = cstrNestedPropValueArray;
		return TRUE;
	}


// Dialog Data
	//{{AFX_DATA(CNestedPropertyPage)
	enum { IDD = IDD_PROPPAGE_NESTED };
	CListCtrl	m_lstNestedProp;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNestedPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CStringArray *m_pcstrNestedPropNameArray;
	CStringArray *m_pcstrNestedPropValueArray;

	CListCtrl *m_pCurrentListSorting;
	int       m_iCurrentColumnSorting;
	BOOL      m_bCurrentSortUp;

	int  m_iNestedLastColumnClick;
	int  m_iNestedLastColumnClickCache;


	// Generated message map functions
	//{{AFX_MSG(CNestedPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnColumnClickNestedProp(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_NESTEDPROPERTYPAGE_H__FC5EAA3F_D8D9_4F19_8587_E7CE86416943__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\nestedpp.cpp ===
// NestedPP.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "NestedPP.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNestedPropertyPage property page

IMPLEMENT_DYNCREATE(CNestedPropertyPage, CPropertyPage)

CNestedPropertyPage::CNestedPropertyPage() : CPropertyPage(CNestedPropertyPage::IDD)
{
	//{{AFX_DATA_INIT(CNestedPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_bNestedPropSortUp = TRUE;
	m_iNestedLastColumnClick = 0;
	m_iNestedLastColumnClickCache = 0;

	m_bCurrentSortUp = FALSE;
	m_pCurrentListSorting = NULL;

	m_pcstrNestedPropNameArray = NULL;
}

CNestedPropertyPage::~CNestedPropertyPage()
{
}

void CNestedPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNestedPropertyPage)
	DDX_Control(pDX, IDC_NESTEDPROP, m_lstNestedProp);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNestedPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CNestedPropertyPage)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_NESTEDPROP, OnColumnClickNestedProp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNestedPropertyPage message handlers

BOOL CNestedPropertyPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	RECT r;
	m_lstNestedProp.GetClientRect(&r);

	int widthCol1;
	int widthCol2;

	//col 1 & 2 takes up around half of area...
	widthCol1 = widthCol2 = ((r.right - r.left) / 2);
	
	m_lstNestedProp.InsertColumn(0, "Property", LVCFMT_LEFT, widthCol1);
	m_lstNestedProp.InsertColumn(1, "Value", LVCFMT_LEFT, widthCol2);

    //autosize last column for best look and to get rid of scroll bar
	m_lstNestedProp.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);

    m_lstNestedProp.SetExtendedStyle(m_lstNestedProp.GetExtendedStyle() | LVS_EX_FULLROWSELECT);

    int i, count;
	if (m_pcstrNestedPropNameArray)
	{
	    count = this->m_pcstrNestedPropNameArray->GetSize();
	    for (i = 0; i < count; i++)
		{
            m_lstNestedProp.InsertItem(i, m_pcstrNestedPropNameArray->GetAt(i), 0);
		    m_lstNestedProp.SetItemData(i, i);
            m_lstNestedProp.SetItemText(i, 1, m_pcstrNestedPropValueArray->GetAt(i));
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//nmanis, for sorting of columns...
int CALLBACK CNestedPropertyPage::CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CNestedPropertyPage *pDlg; //we pass "this" in to this callback...
    pDlg = (CNestedPropertyPage *) lParamSort; 

    LV_FINDINFO FindItem1;
    LV_FINDINFO FindItem2;

    ZeroMemory(&FindItem1, sizeof(LV_FINDINFO));
    ZeroMemory(&FindItem2, sizeof(LV_FINDINFO));

    FindItem1.flags  = LVFI_PARAM;
    FindItem1.lParam = lParam1;

    FindItem2.flags = LVFI_PARAM;
    FindItem2.lParam = lParam2;

    int iIndexItem1 = pDlg->m_pCurrentListSorting->FindItem(&FindItem1);
    int iIndexItem2 = pDlg->m_pCurrentListSorting->FindItem(&FindItem2);

	if (pDlg->m_pCurrentListSorting)
	{
      CString str1 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem1, pDlg->m_iCurrentColumnSorting);
      CString str2 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem2, pDlg->m_iCurrentColumnSorting);
      switch (pDlg->m_iCurrentColumnSorting)
	  {
        case 0: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     
              break;

        case 1: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

              break;  //no needed, just in case we forget...
	  }
	}

    return 0;
}
//end nmanis, sorting function

void CNestedPropertyPage::OnColumnClickNestedProp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iNestedLastColumnClick = pNMListView->iSubItem;
    if (m_iNestedLastColumnClickCache == m_iNestedLastColumnClick) //if click on different column, don't toggle
       m_bNestedPropSortUp = !m_bNestedPropSortUp;  //toggle it...

    m_iNestedLastColumnClickCache = m_iNestedLastColumnClick;  //save last header clicked

	m_pCurrentListSorting = &m_lstNestedProp;
	m_iCurrentColumnSorting = m_iNestedLastColumnClick;
	m_bCurrentSortUp = m_bNestedPropSortUp;

	m_lstNestedProp.SortItems(CompareFunc, (LPARAM) this);
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\propd.cpp ===
// PropD.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "PropD.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropDlg dialog


CPropDlg::CPropDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CPropDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPropDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

    m_bNestedPropSortUp = TRUE;
	m_bClientPropSortUp = TRUE;
	m_bServerPropSortUp = TRUE;

	m_iNestedLastColumnClick = 0;
	m_iClientLastColumnClick = 0;
	m_iServerLastColumnClick = 0;

	m_iNestedLastColumnClickCache = 0;
	m_iClientLastColumnClickCache = 0;
	m_iServerLastColumnClickCache = 0;

	m_bCurrentSortUp = FALSE;
	m_pCurrentListSorting = NULL;

	m_pcstrNestedPropNameArray = NULL;
	m_pcstrClientPropNameArray = NULL;
	m_pcstrServerPropNameArray = NULL;
}


void CPropDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropDlg)
	DDX_Control(pDX, IDC_NESTEDPROP, m_lstNestedProp);
	DDX_Control(pDX, IDC_SERVERPROP, m_lstServerProp);
	DDX_Control(pDX, IDC_CLIENTPROP, m_lstClientProp);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropDlg, CDialog)
	//{{AFX_MSG_MAP(CPropDlg)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_CLIENTPROP, OnColumnClickClientProp)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_NESTEDPROP, OnColumnClickNestedProp)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_SERVERPROP, OnColumnClickServerProp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropDlg message handlers

BOOL CPropDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	RECT r;
	m_lstServerProp.GetClientRect(&r);

	int widthCol1;
	int widthCol2;

	//col 1 & 2 takes up around half of area...
	widthCol1 = widthCol2 = ((r.right - r.left) / 2);
	
	m_lstServerProp.InsertColumn(0, "Property", LVCFMT_LEFT, widthCol1);
	m_lstServerProp.InsertColumn(1, "Value", LVCFMT_LEFT, widthCol2);

	m_lstClientProp.InsertColumn(0, "Property", LVCFMT_LEFT, widthCol1);
	m_lstClientProp.InsertColumn(1, "Value", LVCFMT_LEFT, widthCol2);

	m_lstNestedProp.InsertColumn(0, "Property", LVCFMT_LEFT, widthCol1);
	m_lstNestedProp.InsertColumn(1, "Value", LVCFMT_LEFT, widthCol2);

    //autosize last column for best look and to get rid of scroll bar
	m_lstServerProp.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);
	m_lstClientProp.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);
    m_lstNestedProp.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);


	//full row select...
	m_lstServerProp.SetExtendedStyle(m_lstServerProp.GetExtendedStyle() | LVS_EX_FULLROWSELECT);
	m_lstClientProp.SetExtendedStyle(m_lstClientProp.GetExtendedStyle() | LVS_EX_FULLROWSELECT);
	m_lstNestedProp.SetExtendedStyle(m_lstNestedProp.GetExtendedStyle() | LVS_EX_FULLROWSELECT);

    int count;
	int i;

	if (m_pcstrClientPropNameArray)
	{
  	   count = m_pcstrClientPropNameArray->GetSize();
	   for (i = 0; i < count; i++)
	   {
          m_lstClientProp.InsertItem(i, m_pcstrClientPropNameArray->GetAt(i), 0);
		  m_lstClientProp.SetItemData(i, i);
          m_lstClientProp.SetItemText(i, 1, m_pcstrClientPropValueArray->GetAt(i));
		}
	}

	if (m_pcstrServerPropNameArray)
	{
	    count = m_pcstrServerPropNameArray->GetSize();
	    for (i = 0; i < count; i++)
		{
            m_lstServerProp.InsertItem(i, m_pcstrServerPropNameArray->GetAt(i), 0);
		    m_lstServerProp.SetItemData(i, i);
            m_lstServerProp.SetItemText(i, 1, m_pcstrServerPropValueArray->GetAt(i));
		}
	}

	if (m_pcstrNestedPropNameArray)
	{
	    count = this->m_pcstrNestedPropNameArray->GetSize();
	    for (i = 0; i < count; i++)
		{
            m_lstNestedProp.InsertItem(i, m_pcstrNestedPropNameArray->GetAt(i), 0);
		    m_lstNestedProp.SetItemData(i, i);
            m_lstNestedProp.SetItemText(i, 1, m_pcstrNestedPropValueArray->GetAt(i));
		}
	}

	return TRUE;
}


//nmanis, for sorting of columns...
int CALLBACK CPropDlg::CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CPropDlg *pDlg; //we pass "this" in to this callback...
    pDlg = (CPropDlg *) lParamSort; 

    LV_FINDINFO FindItem1;
    LV_FINDINFO FindItem2;

    ZeroMemory(&FindItem1, sizeof(LV_FINDINFO));
    ZeroMemory(&FindItem2, sizeof(LV_FINDINFO));

    FindItem1.flags  = LVFI_PARAM;
    FindItem1.lParam = lParam1;

    FindItem2.flags = LVFI_PARAM;
    FindItem2.lParam = lParam2;

    int iIndexItem1 = pDlg->m_pCurrentListSorting->FindItem(&FindItem1);
    int iIndexItem2 = pDlg->m_pCurrentListSorting->FindItem(&FindItem2);

	if (pDlg->m_pCurrentListSorting)
	{
      CString str1 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem1, pDlg->m_iCurrentColumnSorting);
      CString str2 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem2, pDlg->m_iCurrentColumnSorting);
      switch (pDlg->m_iCurrentColumnSorting)
	  {
        case 0: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     
              break;

        case 1: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

              break;  //no needed, just in case we forget...
	  }
	}

    return 0;
}
//end nmanis, sorting function


void CPropDlg::OnColumnClickClientProp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iClientLastColumnClick = pNMListView->iSubItem;
    if (m_iClientLastColumnClickCache == m_iClientLastColumnClick) //if click on different column, don't toggle
	{
       m_bClientPropSortUp = !m_bClientPropSortUp;  //toggle it...
	}


    m_iClientLastColumnClickCache = m_iClientLastColumnClick;  //save last header clicked

    m_pCurrentListSorting = &m_lstClientProp;
	m_iCurrentColumnSorting = m_iClientLastColumnClick;
	m_bCurrentSortUp = m_bClientPropSortUp;

    //we are going to do a custom sort...
    m_lstClientProp.SortItems(CompareFunc, (LPARAM) this);
	*pResult = 0;
}


void CPropDlg::OnColumnClickNestedProp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iNestedLastColumnClick = pNMListView->iSubItem;
    if (m_iNestedLastColumnClickCache == m_iNestedLastColumnClick) //if click on different column, don't toggle
       m_bNestedPropSortUp = !m_bNestedPropSortUp;  //toggle it...

    m_iNestedLastColumnClickCache = m_iNestedLastColumnClick;  //save last header clicked

	m_pCurrentListSorting = &m_lstNestedProp;
	m_iCurrentColumnSorting = m_iNestedLastColumnClick;
	m_bCurrentSortUp = m_bNestedPropSortUp;

	m_lstNestedProp.SortItems(CompareFunc, (LPARAM) this);
	*pResult = 0;
}


void CPropDlg::OnColumnClickServerProp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iServerLastColumnClick = pNMListView->iSubItem;
    if (m_iServerLastColumnClickCache == m_iServerLastColumnClick) //if click on different column, don't toggle
       m_bServerPropSortUp = !m_bServerPropSortUp;  //toggle it...

    m_iServerLastColumnClickCache = m_iServerLastColumnClick;  //save last header clicked

	m_pCurrentListSorting = &m_lstServerProp;
	m_iCurrentColumnSorting = m_iServerLastColumnClick;
	m_bCurrentSortUp = m_bServerPropSortUp;

	m_lstServerProp.SortItems(CompareFunc, (LPARAM) this);
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\optionsd.h ===
#if !defined(AFX_OPTIONSDLG_H__E1BA321D_78BC_4A7B_8E7C_5B85B79ADD8B__INCLUDED_)
#define AFX_OPTIONSDLG_H__E1BA321D_78BC_4A7B_8E7C_5B85B79ADD8B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OptionsD.h : header file
//

#include "common.h"

/////////////////////////////////////////////////////////////////////////////
// COptionsDlg dialog

class COptionsDlg : public CDialog
{
// Construction
public:
	COptionsDlg(CWnd* pParent = NULL);   // standard constructor
	~COptionsDlg() 
	{ 
	}

	CString GetIgnoredErrors()
	{
	   return m_cstrIgnoredErrors;
	}

	void SetIgnoredErrors(CString &cstrErrors)
	{
	   m_cstrIgnoredErrors = cstrErrors;
	}

	CString GetOutputDirectory()
	{
		return m_cstrOutputDirectory;
	}

	void SetOutputDirectory(CString &cstrDir)
	{
		m_cstrOutputDirectory = cstrDir;
	}


// Dialog Data
	//{{AFX_DATA(COptionsDlg)
	enum { IDD = IDD_OPTIONS };
	CListCtrl	m_lstIgnoredErrors;
	CString	m_cstrOutputDirectory;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COptionsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
    BOOL SetColors(CArray<COLORREF, COLORREF> &refColors) 
	{
	  BOOL bRet = FALSE;
	  int iSize = refColors.GetSize();
	  COLORREF col;

	  if ((iSize > 0) && (iSize <= MAX_HTML_LOG_COLORS))
	  {
         bRet = TRUE;

	     m_arColors.RemoveAll();
	     for (int i=0; i < iSize; i++)
		 {
		   col = refColors.GetAt(i);
           m_arColors.Add(col);
		 }  
	  }

      return bRet;
	}


	BOOL GetColors(CArray<COLORREF, COLORREF> &refColors)
	{
	  BOOL bRet = FALSE;
	  int iSize = m_arColors.GetSize();
	  COLORREF col;
	  
	  if ((iSize > 0) && (iSize <= MAX_HTML_LOG_COLORS))
	  {
		  bRet = TRUE;

          refColors.RemoveAll();
	   	  for (int i=0; i < iSize; i++)
		  {
            col = m_arColors.GetAt(i);
            refColors.Add(col);
		  }
	  }

      return bRet;
	}

// Implementation
protected:
	CArray<COLORREF, COLORREF> m_arColors; //values...
	CBrush m_brArray[MAX_HTML_LOG_COLORS]; //assume nothing, will get size in OnInitDialog...

	CString m_cstrIgnoredErrors;

	// Generated message map functions
	//{{AFX_MSG(COptionsDlg)
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	virtual BOOL OnInitDialog();
	afx_msg void OnOk();
	afx_msg void OnChoosecolorPolicy();
	//}}AFX_MSG

	afx_msg void OnChooseColor(UINT iCommandID);

	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OPTIONSDLG_H__E1BA321D_78BC_4A7B_8E7C_5B85B79ADD8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\propsht.cpp ===
// propsht.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "propsht.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMyPropertySheet

IMPLEMENT_DYNAMIC(CMyPropertySheet, CPropertySheet)

CMyPropertySheet::CMyPropertySheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CMyPropertySheet::CMyPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

CMyPropertySheet::~CMyPropertySheet()
{
}


BEGIN_MESSAGE_MAP(CMyPropertySheet, CPropertySheet)
	//{{AFX_MSG_MAP(CMyPropertySheet)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMyPropertySheet message handlers

BOOL CMyPropertySheet::OnInitDialog() 
{
	BOOL bResult = CPropertySheet::OnInitDialog();

	//put tabs at bottom...
    CTabCtrl *pTab = GetTabControl();
    if (pTab)
	{
	   long val;
       val = ::GetWindowLong(pTab->m_hWnd, GWL_STYLE);
	   if (!(val & TCS_BOTTOM)) 
	   { 
	     val |= TCS_BOTTOM;
		 ::SetWindowLong(pTab->m_hWnd, GWL_STYLE, val);
	   } 

	   SetActivePage(0);
	}
	
    CWnd* pApplyButton = GetDlgItem (ID_APPLY_NOW);
    ASSERT (pApplyButton);
	if (pApplyButton)
	   pApplyButton->ShowWindow (SW_HIDE);


    CWnd* pCancelButton = GetDlgItem (IDCANCEL);
    ASSERT (pCancelButton);
	if (pCancelButton)
	   pCancelButton->SetWindowText("OK");

	CWnd* pOKButton = GetDlgItem (IDOK);
    ASSERT (pOKButton);
	if (pOKButton)
	   pOKButton->ShowWindow (SW_HIDE);

	return bResult;
}

int CMyPropertySheet::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CPropertySheet::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\propsht.h ===
#if !defined(AFX_MYPROPERTYSHEET_H__DF81F4AF_6637_4CBB_9FAF_0B5CB388345E__INCLUDED_)
#define AFX_MYPROPERTYSHEET_H__DF81F4AF_6637_4CBB_9FAF_0B5CB388345E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MyPropertySheet.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMyPropertySheet

class CMyPropertySheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CMyPropertySheet)

// Construction
public:
	CMyPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CMyPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMyPropertySheet)
	public:
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMyPropertySheet();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMyPropertySheet)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MYPROPERTYSHEET_H__DF81F4AF_6637_4CBB_9FAF_0B5CB388345E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\propd.h ===
#if !defined(AFX_PROPDLG_H__7D0406B8_7960_4B25_A848_EA6A5C3325E2__INCLUDED_)
#define AFX_PROPDLG_H__7D0406B8_7960_4B25_A848_EA6A5C3325E2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PropD.h : header file
//

#include <afxcmn.h>

/////////////////////////////////////////////////////////////////////////////
// CPropDlg dialog
class CPropDlg : public CDialog
{
// Construction
public:
	CPropDlg(CWnd* pParent = NULL);   // standard constructor

    BOOL m_bNestedPropSortUp;
	BOOL m_bClientPropSortUp;
	BOOL m_bServerPropSortUp;

	static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

// Dialog Data
	//{{AFX_DATA(CPropDlg)
	enum { IDD = IDD_PROPDLG1 };
	CListCtrl	m_lstNestedProp;
	CListCtrl	m_lstServerProp;
	CListCtrl	m_lstClientProp;
	//}}AFX_DATA

	BOOL SetClientPropNames(CStringArray *cstrClientPropNameArray)
	{
        m_pcstrClientPropNameArray = cstrClientPropNameArray;
		return TRUE;
	}

	BOOL SetClientPropValues(CStringArray *cstrClientPropValueArray)
	{
        m_pcstrClientPropValueArray = cstrClientPropValueArray;
		return TRUE;
	}
	
	BOOL SetServerPropNames(CStringArray *cstrServerPropNameArray)
	{
        m_pcstrServerPropNameArray = cstrServerPropNameArray;
		return TRUE;
	}

	BOOL SetServerPropValues(CStringArray *cstrServerPropValueArray)
	{
        m_pcstrServerPropValueArray = cstrServerPropValueArray;
		return TRUE;
	}


	BOOL SetNestedPropNames(CStringArray *cstrNestedPropNameArray)
	{
        m_pcstrNestedPropNameArray = cstrNestedPropNameArray;
		return TRUE;
	}

	BOOL SetNestedPropValues(CStringArray *cstrNestedPropValueArray)
	{
        m_pcstrNestedPropValueArray = cstrNestedPropValueArray;
		return TRUE;
	}


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CStringArray *m_pcstrClientPropNameArray;
	CStringArray *m_pcstrClientPropValueArray;

	CStringArray *m_pcstrServerPropNameArray;
	CStringArray *m_pcstrServerPropValueArray;

	CStringArray *m_pcstrNestedPropNameArray;
	CStringArray *m_pcstrNestedPropValueArray;

	CListCtrl *m_pCurrentListSorting;
	int       m_iCurrentColumnSorting;
	BOOL      m_bCurrentSortUp;

	int  m_iNestedLastColumnClick;
	int  m_iClientLastColumnClick;
	int  m_iServerLastColumnClick;

	int  m_iNestedLastColumnClickCache;
	int  m_iClientLastColumnClickCache;
	int  m_iServerLastColumnClickCache;

	// Generated message map functions
	//{{AFX_MSG(CPropDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnColumnClickClientProp(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClickNestedProp(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClickServerProp(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPDLG_H__7D0406B8_7960_4B25_A848_EA6A5C3325E2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\serverpp.h ===
#if !defined(AFX_SERVERPROPERTYPAGE_H__11970E3E_6F55_4FEE_887B_991F70728066__INCLUDED_)
#define AFX_SERVERPROPERTYPAGE_H__11970E3E_6F55_4FEE_887B_991F70728066__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ServerPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CServerPropertyPage dialog

class CServerPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CServerPropertyPage)

// Construction
public:
	CServerPropertyPage();
	~CServerPropertyPage();

	static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

	BOOL SetServerPropNames(CStringArray *cstrServerPropNameArray)
	{
        m_pcstrServerPropNameArray = cstrServerPropNameArray;
		return TRUE;
	}

	BOOL SetServerPropValues(CStringArray *cstrServerPropValueArray)
	{
        m_pcstrServerPropValueArray = cstrServerPropValueArray;
		return TRUE;
	}

// Dialog Data
	//{{AFX_DATA(CServerPropertyPage)
	enum { IDD = IDD_PROPPAGE_SERVER };
	CListCtrl	m_lstServerProp;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServerPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	BOOL m_bServerPropSortUp;

// Implementation
protected:
	CStringArray *m_pcstrServerPropNameArray;
	CStringArray *m_pcstrServerPropValueArray;

	CListCtrl *m_pCurrentListSorting;
	int       m_iCurrentColumnSorting;
	BOOL      m_bCurrentSortUp;

	int  m_iServerLastColumnClick;
	int  m_iServerLastColumnClickCache;

	// Generated message map functions
	//{{AFX_MSG(CServerPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnColumnClickServerProp(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SERVERPROPERTYPAGE_H__11970E3E_6F55_4FEE_887B_991F70728066__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\showlogd.h ===
// ShowInstallLogsDlg.h : header file
//

#if !defined(AFX_SHOWINSTALLLOGSDLG_H__CB0487B0_84C3_4D1D_83AE_968A03F9393A__INCLUDED_)
#define AFX_SHOWINSTALLLOGSDLG_H__CB0487B0_84C3_4D1D_83AE_968A03F9393A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <afxtempl.h>
  
struct LogInformation
{
	CString m_strLogName;
	CString m_strPreview;
	BOOL    m_bUnicodeLog;

    LogInformation() : m_strLogName(' ', 256), m_strPreview(' ', 256), m_bUnicodeLog(FALSE)
	{
	}
};

/////////////////////////////////////////////////////////////////////////////
// COpenDlg dialog
class COpenDlg : public CDialog
{
// Construction
public:
	COpenDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(COpenDlg)
	enum { IDD = IDD_SHOWINSTALLLOGS_DIALOG };
	CComboBox	m_cboLogFiles;
	CString	m_strPreview;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COpenDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
//5-9-2001
    BOOL OnToolTipNotify(UINT id, NMHDR *pNMH, LRESULT *pResult);
//end 5-9-2001

	HICON m_hIcon;

	CArray<LogInformation, LogInformation> m_arLogInfo;

	BOOL ParseLog(struct LogInformation *pLogInfoRec);
	BOOL CommonSearch(CString &strDir);


	// Generated message map functions
	//{{AFX_MSG(COpenDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnOpen();
	afx_msg void OnGetlogs();
	afx_msg void OnSelchangeLogfiles();
	afx_msg void OnDetailedDisplay();
	afx_msg void OnFindlog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHOWINSTALLLOGSDLG_H__CB0487B0_84C3_4D1D_83AE_968A03F9393A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\sources.inc ===
TARGETNAME=wilogutl
!INCLUDE ..\..\..\MsiMake.inc
                  
TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

C_DEFINES=-D"_WIN32_MSM=200" $(C_DEFINES)

UMTYPE=windows

TARGETPATH=$(MSI_BUILD_TARGET)

# 
# Fusionized
# 

SXS_ASSEMBLY_NAME=Microsoft.Windows.MSI.WiLogUtl
SXS_ASSEMBLY_VERSION=2.0 
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=wilogutl.exe.manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1

USE_NATIVE_EH=1


#MSC_OPTIMIZATION=/Odi

USE_MFC=1
USE_STATIC_MFC=1
USE_LIBCMT=1

TARGETLIBS=\
	$(SDK_LIB_PATH)\shell32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\comctl32.lib \
	$(SDK_LIB_PATH)\comdlg32.lib \
	$(SDK_LIB_PATH)\winspool.lib

MFC_LIBS=$(MSI_BIN_PATH)\mfc\*\nafxcw.lib

INCLUDES=$(INC_DIR);$(SDK_INC_PATH);$(O);$(MFC_INCLUDES);$(RES_OBJDIR)

SOURCES=..\clientpp.cpp \
	..\common.cpp \
	..\loganald.cpp \
	..\logparse.cpp \
	..\logviewd.cpp \
	..\nestedpp.cpp \
	..\optionsd.cpp \
	..\policyd.cpp \
	..\propd.cpp \
	..\propsht.cpp \
	..\serverpp.cpp \
	..\showlogd.cpp \
	..\statesd.cpp \
	..\stdafx.cpp \
	..\util.cpp \
	..\wilogutl.cpp \
	..\wilogutl.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\serverpp.cpp ===
// serverpp.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "serverpp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CServerPropertyPage property page

IMPLEMENT_DYNCREATE(CServerPropertyPage, CPropertyPage)

CServerPropertyPage::CServerPropertyPage() : CPropertyPage(CServerPropertyPage::IDD)
{
	//{{AFX_DATA_INIT(CServerPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_bServerPropSortUp = TRUE;
	m_iServerLastColumnClick = 0;
	m_iServerLastColumnClickCache = 0;

	m_bCurrentSortUp = FALSE;
	m_pCurrentListSorting = NULL;
	m_pcstrServerPropNameArray = NULL;
}

CServerPropertyPage::~CServerPropertyPage()
{
}

void CServerPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServerPropertyPage)
	DDX_Control(pDX, IDC_SERVERPROP, m_lstServerProp);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServerPropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CServerPropertyPage)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_SERVERPROP, OnColumnClickServerProp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServerPropertyPage message handlers

BOOL CServerPropertyPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	RECT r;
	m_lstServerProp.GetClientRect(&r);

	int widthCol1;
	int widthCol2;

	//col 1 & 2 takes up around half of area...
	widthCol1 = widthCol2 = ((r.right - r.left) / 2);
	
	m_lstServerProp.InsertColumn(0, "Property", LVCFMT_LEFT, widthCol1);
	m_lstServerProp.InsertColumn(1, "Value", LVCFMT_LEFT, widthCol2);

    //autosize last column for best look and to get rid of scroll bar
	m_lstServerProp.SetColumnWidth(1, LVSCW_AUTOSIZE_USEHEADER);
	m_lstServerProp.SetExtendedStyle(m_lstServerProp.GetExtendedStyle() | LVS_EX_FULLROWSELECT);

	int i, count;
	if (m_pcstrServerPropNameArray)
	{
	    count = m_pcstrServerPropNameArray->GetSize();
	    for (i = 0; i < count; i++)
		{
            m_lstServerProp.InsertItem(i, m_pcstrServerPropNameArray->GetAt(i), 0);
		    m_lstServerProp.SetItemData(i, i);
            m_lstServerProp.SetItemText(i, 1, m_pcstrServerPropValueArray->GetAt(i));
		}
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


//nmanis, for sorting of columns...
int CALLBACK CServerPropertyPage::CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CServerPropertyPage *pDlg; //we pass "this" in to this callback...
    pDlg = (CServerPropertyPage *) lParamSort; 

    LV_FINDINFO FindItem1;
    LV_FINDINFO FindItem2;

    ZeroMemory(&FindItem1, sizeof(LV_FINDINFO));
    ZeroMemory(&FindItem2, sizeof(LV_FINDINFO));

    FindItem1.flags  = LVFI_PARAM;
    FindItem1.lParam = lParam1;

    FindItem2.flags = LVFI_PARAM;
    FindItem2.lParam = lParam2;

    int iIndexItem1 = pDlg->m_pCurrentListSorting->FindItem(&FindItem1);
    int iIndexItem2 = pDlg->m_pCurrentListSorting->FindItem(&FindItem2);

	if (pDlg->m_pCurrentListSorting)
	{
      CString str1 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem1, pDlg->m_iCurrentColumnSorting);
      CString str2 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem2, pDlg->m_iCurrentColumnSorting);
      switch (pDlg->m_iCurrentColumnSorting)
	  {
        case 0: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     
              break;

        case 1: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

              break;  //no needed, just in case we forget...
	  }
	}

    return 0;
}
//end nmanis, sorting function

void CServerPropertyPage::OnColumnClickServerProp(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iServerLastColumnClick = pNMListView->iSubItem;
    if (m_iServerLastColumnClickCache == m_iServerLastColumnClick) //if click on different column, don't toggle
       m_bServerPropSortUp = !m_bServerPropSortUp;  //toggle it...

    m_iServerLastColumnClickCache = m_iServerLastColumnClick;  //save last header clicked

	m_pCurrentListSorting = &m_lstServerProp;
	m_iCurrentColumnSorting = m_iServerLastColumnClick;
	m_bCurrentSortUp = m_bServerPropSortUp;

	m_lstServerProp.SortItems(CompareFunc, (LPARAM) this);
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ShowInstallLogs.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\showlogd.cpp ===
// showlogd.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "showlogd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COpenDlg dialog
COpenDlg::COpenDlg(CWnd* pParent /*=NULL*/)
	: CDialog(COpenDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(COpenDlg)
	m_strPreview = _T("");
	//}}AFX_DATA_INIT

	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void COpenDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COpenDlg)
	DDX_Control(pDX, IDC_LOGFILES, m_cboLogFiles);
	DDX_Text(pDX, IDC_PREVIEW, m_strPreview);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(COpenDlg, CDialog)
	//{{AFX_MSG_MAP(COpenDlg)
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_OPEN, OnOpen)
	ON_BN_CLICKED(IDC_GETLOGS, OnGetlogs)
	ON_CBN_SELCHANGE(IDC_LOGFILES, OnSelchangeLogfiles)
	ON_BN_CLICKED(IDC_ANALYZE, OnDetailedDisplay)
	ON_BN_CLICKED(IDC_FINDLOG, OnFindlog)
	//}}AFX_MSG_MAP

//5-9-2001, add tooltips!!!
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT,0,0xFFFF,OnToolTipNotify)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COpenDlg message handlers
BOOL COpenDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon

	EnableToolTips(TRUE);
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}


//5-9-2001
BOOL COpenDlg::OnToolTipNotify(UINT id, NMHDR *pNMH, LRESULT *pResult)
{
       TOOLTIPTEXT *pText = (TOOLTIPTEXT *)pNMH;
       int control_id =  ::GetDlgCtrlID((HWND)pNMH->idFrom);
       if(control_id)
       {
           pText->lpszText = MAKEINTRESOURCE(control_id);
           pText->hinst = AfxGetInstanceHandle();
           return TRUE;
       }
       return FALSE;
}
//end 5-9-2001

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.
void COpenDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR COpenDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}


//nmanis, handle when user wants to open log
void COpenDlg::OnOpen() 
{
	int nIndex = m_cboLogFiles.GetCurSel();
	int nCount = m_cboLogFiles.GetCount();

	if ((nIndex != LB_ERR) && (nCount >= 1))
	{
       CString str;
       m_cboLogFiles.GetLBText(nIndex, str);
 	   if (!str.IsEmpty())
	   {
		  CString strNotepad;
		  strNotepad = "notepad.exe ";
		  strNotepad += str;
		  WinExec(strNotepad, SW_SHOW);
	   }
	}
    else if (nCount <= 0)
	{
       if (!g_bRunningInQuietMode)
	      AfxMessageBox("No log files currently in list.");
	}
    else
	{
       if (!g_bRunningInQuietMode)
          AfxMessageBox("Please select a log file first.");
	}
}



//nmanis, buffer size to read in each time
#define LOG_BUF_READ_SIZE 8192

//max lines to preview in pLogInfoRec->m_strPreview
#define MAX_PREVIEW       100

//this is called when just showing the current file selected to view
BOOL COpenDlg::ParseLog(struct LogInformation *pLogInfoRec)
{
	ASSERT(pLogInfoRec != NULL);

	BOOL bRet = DetermineLogType(pLogInfoRec->m_strLogName, &pLogInfoRec->m_bUnicodeLog);
	if (bRet)
	{
		CString buffer = "";
		int  iCount = 0;
		int  iMax = MAX_PREVIEW;
        BOOL bDone = FALSE;

		FILE *fptr;
	    if (pLogInfoRec->m_bUnicodeLog) //logs are different on NT vs.Win9x.  On NT, they are written in UNICODE, open them differently...
	       fptr = fopen(pLogInfoRec->m_strLogName, "rb");
	    else
	       fptr = fopen(pLogInfoRec->m_strLogName, "r");

	    if (fptr)
		{
	       char ansibuffer[LOG_BUF_READ_SIZE+1];

	       BOOL bEndFile = FALSE;
		   BOOL bError = FALSE;
		   char  *pos = NULL;
		   WCHAR *wpos = NULL;

		   do
		   {
		     if (pLogInfoRec->m_bUnicodeLog) //logs are different on NT vs. Win9x.  On NT, they are written in UNICODE...
			 {
			    const int HalfBufSize = LOG_BUF_READ_SIZE/2;
		        WCHAR widebuffer[HalfBufSize];

			    wpos = fgetws(widebuffer, HalfBufSize, fptr);
			    bError = wpos ? 1 : 0;

				//convert string to ANSI string, all parsing is done with ANSI strings...
		        WideCharToMultiByte(CP_ACP, 0, widebuffer, HalfBufSize, ansibuffer, LOG_BUF_READ_SIZE, NULL, NULL);
			 }
		     else
			 {
		        //do line by line read with fgets()
		        pos = fgets(ansibuffer, LOG_BUF_READ_SIZE, fptr);
				int len1 = strlen(ansibuffer);
				if (len1 > 1 && ansibuffer[len1-2] != '\r')
				{
				  ansibuffer[len1 - 2] = '\r';
				  ansibuffer[len1 - 1] = '\n';
				  ansibuffer[len1] = '\0';
				}

			    bError = pos ? 1 : 0;
			 }

			 iCount++;
			 if (iCount > iMax)
  			    bDone = TRUE;

			 buffer += ansibuffer;
		     bEndFile = feof(fptr);
		   }
		   while (!bEndFile && bError && !bDone);

		   if (!bEndFile && !bError) //error occured...
		   {
#ifdef _DEBUG
              if (!g_bRunningInQuietMode)
			  {
		  	     int iError = ferror(fptr);
            
			     CString cstrErr;
		         cstrErr.Format("Unexpected Error reading file, error = %d", iError);

                 AfxMessageBox(cstrErr);
			  }
#endif

		   }

           pLogInfoRec->m_strPreview = buffer;
		   fclose(fptr);
		}
	    else
		{
		  //error opening file, unexpected...
		}
	}
	else
	{
       if (!g_bRunningInQuietMode)
	   {
	      AfxMessageBox("Could not determine if log is UNICODE or ANSI");
	   }
	}

	return bRet;
}



//nmanis, used to look for log files (msi*.log) files in directory passed
BOOL COpenDlg::CommonSearch(CString &strDir)
{
    BOOL bRet = FALSE;
	WIN32_FIND_DATA finddata = { 0 };
	HANDLE hFind = 0;

	CString strSearch;

	strSearch = strDir;
    strSearch += "msi*.log";
	hFind = FindFirstFile(strSearch, &finddata);
    if (hFind == INVALID_HANDLE_VALUE) 
	{
		//no temp files currently in temp dir...
		return bRet;
	}
	else
	{
       m_arLogInfo.RemoveAll(); 
	   m_cboLogFiles.ResetContent();

	   int iCount = 0;
	   struct LogInformation LogInfoRec;

	   LogInfoRec.m_strLogName = strDir;
	   LogInfoRec.m_strLogName += finddata.cFileName;

	   bRet = ParseLog(&LogInfoRec);
	   if (bRet)
	   {
	      m_arLogInfo.Add(LogInfoRec);
          m_cboLogFiles.InsertString(iCount, LogInfoRec.m_strLogName);

          iCount++;
	   }

	   BOOL bMoreFiles = FindNextFile(hFind, &finddata);
	   while (bMoreFiles)
	   {
		  struct LogInformation LogInfoRec2;

	      LogInfoRec2.m_strLogName = strDir;
		  LogInfoRec2.m_strLogName += finddata.cFileName;

	      bRet = ParseLog(&LogInfoRec2);
	      if (bRet)
		  {
             m_arLogInfo.Add(LogInfoRec2);

	         m_cboLogFiles.InsertString(iCount, LogInfoRec2.m_strLogName);

             iCount++;
		  }

          bMoreFiles = FindNextFile(hFind, &finddata);
	   }

       FindClose(hFind);
  	}

    return bRet;
}

//nmanis, used to get logs from temp directory...
void COpenDlg::OnGetlogs() 
{
	char szTempPath[_MAX_PATH];
	char szFullPath[_MAX_PATH];

	DWORD dwLen = 0;
    dwLen = GetTempPath(_MAX_PATH, szTempPath);
    if (!dwLen)
	{
		OutputDebugString("GetTempPath failed in MSI translate process");
		return;
	}

	strcpy(szFullPath, szTempPath);

	CString cstr;
	cstr = szFullPath;
	CommonSearch(cstr);
}


//nmanis, when user picks different file from combo box, change the preview
void COpenDlg::OnSelchangeLogfiles() 
{
	int nIndex = m_cboLogFiles.GetCurSel();;
	int nCount = m_cboLogFiles.GetCount();

//more than one log in combo box?
	if ((nIndex != LB_ERR) && (nCount > 1))
	{
	  
      CString str;
      m_cboLogFiles.GetLBText(nIndex, str);
	  if (!str.IsEmpty())
	  {
		 LogInformation loginfo;

         loginfo = m_arLogInfo.GetAt(nIndex); //get entry in array
		 m_strPreview = loginfo.m_strPreview; //set preview edit control to data from array entry

		 UpdateData(FALSE); //do the update
	  }
	}
}



//look for a log on disk using file dialog
void COpenDlg::OnFindlog() 
{
   static char szFilter[] = "Log files (*.log;*.txt)|*.log; *.txt|All files (*.*)|*.*||";
   CFileDialog dlg(TRUE, "log", "*.log; *.txt", 0, szFilter );

   //5-3-2001, don't show in quiet mode...
   if (!g_bRunningInQuietMode)
   {
      int iRet = dlg.DoModal();
      if (iRet == IDOK)
	  {
	     struct LogInformation LogInfoRec;
	     LogInfoRec.m_strLogName = dlg.GetPathName();
         BOOL bRet = ParseLog(&LogInfoRec); //get one?  If so, parse it
         if (bRet) //parse ok, if so, add to our array
		 {
	        m_arLogInfo.Add(LogInfoRec);

		    int iCount = m_cboLogFiles.GetCount();

            m_cboLogFiles.InsertString(iCount, LogInfoRec.m_strLogName);
            m_cboLogFiles.SetCurSel(iCount);

		    iCount++;
            //m_bIsUnicodeLogFile = LogInfoRec.m_bUnicodeLog;
		    m_strPreview = LogInfoRec.m_strPreview;

		    UpdateData(FALSE);
		 }
	  }
   }
}


#include "loganald.h"

void COpenDlg::OnDetailedDisplay() 
{
  CLogAnalyzeDlg dlg;

  int nIndex = m_cboLogFiles.GetCurSel();;
  int nCount = m_cboLogFiles.GetCount();

  if ((nIndex != LB_ERR) && (nCount >= 1))
  {
      CString str;
      m_cboLogFiles.GetLBText(nIndex, str);
	  if (!str.IsEmpty())
	  {
	  }

	  dlg.SetLogfileLocation(str);
	  
	  //5-3-2001, don't show in quiet mode...
     if (!g_bRunningInQuietMode)
	    dlg.DoModal();
  }
  else if (nCount <= 0)
  {
	  //5-3-2001, don't show in quiet mode...
      if (!g_bRunningInQuietMode)
	     AfxMessageBox("No log files currently in list.");
  }
  else
  {
	  //5-3-2001, don't show in quiet mode...
      if (!g_bRunningInQuietMode)
	     AfxMessageBox("Please select a log file first.");
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\statesd.cpp ===
// StatesD.cpp : implementation file
//

#include "stdafx.h"
#include "wilogutl.h"
#include "statesd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CStatesDlg dialog


CStatesDlg::CStatesDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CStatesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CStatesDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

	m_pcstrComponentNameArray = NULL;
	m_pcstrFeatureNameArray = NULL;

//for sorting columns...
	m_iFeatureLastColumnClick = 0;
	m_iComponentLastColumnClick = 0;

	m_iFeatureLastColumnClickCache = 0;
	m_iComponentLastColumnClickCache = 0;

	m_bCurrentSortUp = FALSE;
	m_pCurrentListSorting = NULL;
    m_iCurrentColumnSorting = 0;

	m_bFeatureSortUp = FALSE;
	m_bComponentSortUp = FALSE;
}


void CStatesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStatesDlg)
	DDX_Control(pDX, IDC_FEATURESTATES, m_lstFeatureStates);
	DDX_Control(pDX, IDC_COMPONENTSTATES, m_lstComponentStates);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStatesDlg, CDialog)
	//{{AFX_MSG_MAP(CStatesDlg)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_COMPONENTSTATES, OnColumnClickComponentStates)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_FEATURESTATES, OnColumnClickFeatureStates)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStatesDlg message handlers

BOOL CStatesDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();

	RECT r;
	m_lstFeatureStates.GetClientRect(&r);

	int widthCol1;
	int widthCol2;

    //col 1 for states takes up around half of area...
	widthCol1 = ((r.right - r.left) / 2);

	//divide rest evenly between three other columns...
    widthCol2 = (((r.right - r.left) / 2) / 3) + 1; //+1 for int rounding errors

	m_lstFeatureStates.InsertColumn(0, "Feature name", LVCFMT_LEFT, widthCol1);
	m_lstFeatureStates.InsertColumn(1, "Installed", LVCFMT_LEFT, widthCol2);
	m_lstFeatureStates.InsertColumn(2, "Request", LVCFMT_LEFT, widthCol2);
	m_lstFeatureStates.InsertColumn(3, "Action", LVCFMT_LEFT, widthCol2);

	m_lstComponentStates.InsertColumn(0, "Component name", LVCFMT_LEFT, widthCol1);
	m_lstComponentStates.InsertColumn(1, "Installed", LVCFMT_LEFT, widthCol2);
	m_lstComponentStates.InsertColumn(2, "Request", LVCFMT_LEFT, widthCol2);
	m_lstComponentStates.InsertColumn(3, "Action", LVCFMT_LEFT, widthCol2);

	//full row select...
	m_lstComponentStates.SetExtendedStyle(m_lstComponentStates.GetExtendedStyle() | LVS_EX_FULLROWSELECT);
	m_lstFeatureStates.SetExtendedStyle(m_lstFeatureStates.GetExtendedStyle() | LVS_EX_FULLROWSELECT);


	int i;
	int nCount;
	
	if (m_pcstrComponentNameArray)
	{
		nCount = m_pcstrComponentNameArray->GetSize();  
	    for (i=0; i < nCount; i++)
		{
		    m_lstComponentStates.InsertItem(i, m_pcstrComponentNameArray->GetAt(i), 0);
	        m_lstComponentStates.SetItemText(i, 1, m_pcstrComponentInstalledArray->GetAt(i));
	        m_lstComponentStates.SetItemText(i, 2, m_pcstrComponentRequestArray->GetAt(i));
	        m_lstComponentStates.SetItemText(i, 3, m_pcstrComponentActionArray->GetAt(i));

		    //for sorting later on...
		    m_lstComponentStates.SetItemData(i, i);
		}
	}

	if (m_pcstrFeatureNameArray)
	{
	   nCount = m_pcstrFeatureNameArray->GetSize();  
	   for (i=0; i < nCount; i++)
	   {
          m_lstFeatureStates.InsertItem(i, m_pcstrFeatureNameArray->GetAt(i), 0);
	      m_lstFeatureStates.SetItemText(i, 1, m_pcstrFeatureInstalledArray->GetAt(i));
	      m_lstFeatureStates.SetItemText(i, 2, m_pcstrFeatureRequestArray->GetAt(i));
	      m_lstFeatureStates.SetItemText(i, 3, m_pcstrFeatureActionArray->GetAt(i));

          //for sorting later on...
		  m_lstFeatureStates.SetItemData(i, i);
	   }
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CStatesDlg::OnColumnClickComponentStates(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iComponentLastColumnClick = pNMListView->iSubItem;
    if (m_iComponentLastColumnClickCache == m_iComponentLastColumnClick) //if click on different column, don't toggle
	{
       m_bComponentSortUp = !m_bComponentSortUp;  //toggle it...
	}

    m_iComponentLastColumnClickCache = m_iComponentLastColumnClick;  //save last header clicked

    m_pCurrentListSorting = &m_lstComponentStates;
	m_iCurrentColumnSorting = m_iComponentLastColumnClick;
	m_bCurrentSortUp = m_bComponentSortUp;

    //we are going to do a custom sort...
    m_lstComponentStates.SortItems(CompareFunc, (LPARAM) this);

	*pResult = 0;
}


void CStatesDlg::OnColumnClickFeatureStates(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

	m_iFeatureLastColumnClick = pNMListView->iSubItem;
    if (m_iFeatureLastColumnClickCache == m_iFeatureLastColumnClick) //if click on different column, don't toggle
	{
       m_bFeatureSortUp = !m_bFeatureSortUp;  //toggle it...
	}

    m_iFeatureLastColumnClickCache = m_iFeatureLastColumnClick;  //save last header clicked

    m_pCurrentListSorting = &m_lstFeatureStates;
	m_iCurrentColumnSorting = m_iFeatureLastColumnClick;
	m_bCurrentSortUp = m_bFeatureSortUp;

    //we are going to do a custom sort...
    m_lstFeatureStates.SortItems(CompareFunc, (LPARAM) this);
	
	*pResult = 0;
}

//nmanis, for sorting of columns...
int CALLBACK CStatesDlg::CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CStatesDlg *pDlg; //we pass "this" in to this callback...
    pDlg = (CStatesDlg *) lParamSort; 

    LV_FINDINFO FindItem1;
    LV_FINDINFO FindItem2;

    ZeroMemory(&FindItem1, sizeof(LV_FINDINFO));
    ZeroMemory(&FindItem2, sizeof(LV_FINDINFO));

    FindItem1.flags  = LVFI_PARAM;
    FindItem1.lParam = lParam1;

    FindItem2.flags = LVFI_PARAM;
    FindItem2.lParam = lParam2;

    int iIndexItem1 = pDlg->m_pCurrentListSorting->FindItem(&FindItem1);
    int iIndexItem2 = pDlg->m_pCurrentListSorting->FindItem(&FindItem2);

	if (pDlg->m_pCurrentListSorting)
	{
      CString str1 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem1, pDlg->m_iCurrentColumnSorting);
      CString str2 = pDlg->m_pCurrentListSorting->GetItemText(iIndexItem2, pDlg->m_iCurrentColumnSorting);
      switch (pDlg->m_iCurrentColumnSorting)
	  {
        case 0: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     
              break;

        case 1: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

        case 2: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

        case 3: //do string compare...
              if (pDlg->m_bCurrentSortUp)
                 return str1 < str2;              
              else
                 return str1 > str2;     

              break;  //no needed, just in case we forget...
	  }
	}

    return 0;
}
//end nmanis, sorting function
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__17BDF522_0D39_4C28_9679_C4802E7DF9DA__INCLUDED_)
#define AFX_STDAFX_H__17BDF522_0D39_4C28_9679_C4802E7DF9DA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

//ignore warning C4100: unreferenced formal parameter
#pragma warning (disable:4100)

#include <afxwin.h>         // MFC core and standard components
//#include <afxext.h>         // MFC extensions
//#include <afxdisp.h>        // MFC Automation classes
//#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


#include <afxdlgs.h>  //for CFileDialog
#include <afxtempl.h> //for CArray

//our standard includes that don't change much now
#include "util.h"
#include "common.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__17BDF522_0D39_4C28_9679_C4802E7DF9DA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\statesd.h ===
#if !defined(AFX_STATESDLG_H__6E91AEDB_6AB7_4574_B567_5DC4928578DC__INCLUDED_)
#define AFX_STATESDLG_H__6E91AEDB_6AB7_4574_B567_5DC4928578DC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// StatesDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CStatesDlg dialog
class CStatesDlg : public CDialog
{
// Construction
public:
	CStatesDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CStatesDlg)
	enum { IDD = IDD_STATESDLG1 };
	CListCtrl	m_lstFeatureStates;
	CListCtrl	m_lstComponentStates;
	//}}AFX_DATA

	//sorting function for columns...
	static int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

//sorting vars used in callback CompareFunc
	CListCtrl *m_pCurrentListSorting;
	BOOL m_bCurrentSortUp;
	int  m_iCurrentColumnSorting;
//end sorting vars...
	
	BOOL SetComponentNames(CStringArray *cstrComponentNameArray)
	{
        m_pcstrComponentNameArray = cstrComponentNameArray;
		return TRUE;
	}

	BOOL SetComponentInstalled(CStringArray *cstrComponentInstalledArray)
	{
        m_pcstrComponentInstalledArray = cstrComponentInstalledArray;
		return TRUE;
	}

	BOOL SetComponentRequest(CStringArray *cstrComponentRequestArray)
	{
        m_pcstrComponentRequestArray = cstrComponentRequestArray;
		return TRUE;
	}

	BOOL SetComponentAction(CStringArray *cstrComponentActionArray)
	{
        m_pcstrComponentActionArray = cstrComponentActionArray;
		return TRUE;
	}


	BOOL SetFeatureNames(CStringArray *cstrFeatureNameArray)
	{
        m_pcstrFeatureNameArray = cstrFeatureNameArray;
		return TRUE;
	}

	BOOL SetFeatureInstalled(CStringArray *cstrFeatureInstalledArray)
	{
        m_pcstrFeatureInstalledArray = cstrFeatureInstalledArray;
		return TRUE;
	}

	BOOL SetFeatureRequest(CStringArray *cstrFeatureRequestArray)
	{
        m_pcstrFeatureRequestArray = cstrFeatureRequestArray;
		return TRUE;
	}

	BOOL SetFeatureAction(CStringArray *cstrFeatureActionArray)
	{
        m_pcstrFeatureActionArray = cstrFeatureActionArray;
		return TRUE;
	}

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStatesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CStringArray *m_pcstrComponentNameArray;
	CStringArray *m_pcstrComponentInstalledArray;
	CStringArray *m_pcstrComponentRequestArray;
	CStringArray *m_pcstrComponentActionArray;

	CStringArray *m_pcstrFeatureNameArray;
	CStringArray *m_pcstrFeatureInstalledArray;
	CStringArray *m_pcstrFeatureRequestArray;
	CStringArray *m_pcstrFeatureActionArray;

//used for sorting columns...
	int m_iFeatureLastColumnClick;
	int m_iComponentLastColumnClick;

	int m_iFeatureLastColumnClickCache;
	int m_iComponentLastColumnClickCache;

	BOOL m_bFeatureSortUp;
	BOOL m_bComponentSortUp;
//end sorting vars

	// Generated message map functions
	//{{AFX_MSG(CStatesDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnColumnClickComponentStates(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnClickFeatureStates(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STATESDLG_H__6E91AEDB_6AB7_4574_B567_5DC4928578DC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\util.h ===
#ifndef UTIL_H
#define UTIL_H

BOOL DetermineLogType(CString &cstrLogFileName, BOOL *bIsUnicodeLog);
BOOL StripLineFeeds(char *lpszString);
BOOL IsValidDirectory(CString cstrDir);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\wilogres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ShowInstallLogs.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_SHOWINSTALLLOGS_DIALOG      102
#define IDS_NOERRORFOUND                102
#define IDS_NOSOLUTION_NEEDED           103
#define IDD_PROPPAGE_CLIENT             106
#define IDR_MAINFRAME                   128
#define IDR_MAINFRAME1                  129
#define IDD_PROPDLG1                    130
#define IDD_ADVVIEW_DIALOG1             132
#define IDD_STATESDLG1                  133
#define IDR_LEGEND                      135
#define IDR_DETAILS                     136
#define IDD_POLICIESDLG                 137
#define IDR_MENU1                       138
#define IDD_OPTIONS                     139
#define IDR_ALLERRORS                   142
#define IDD_PROPPAGE_SERVER             143
#define IDR_JUMPTAGS                    143
#define IDD_PROPPAGE_NESTED             144
#define IDR_HOWTOREADLOGS               144
#define IDR_WILOGHELP                   145
#define IDC_PRODUCT                     1000
#define IDC_USER                        1001
#define IDC_DATETIME                    1002
#define IDC_VERSION                     1003
#define IDC_CLIENTPRIVILEDGEDETAIL      1004
#define IDC_SERVERPRIVILEDGEDETAIL      1005
#define IDC_GETLOGS                     1006
#define IDC_PREVIEW                     1007
#define IDC_MACHINE                     1009
#define IDC_SHARE                       1010
#define IDC_BUTTON1                     1011
#define IDC_BUTTON2                     1012
#define IDC_COMPONENTSTATES             1013
#define IDC_SOLUTION                    1018
#define IDC_CLIENTPROP                  1019
#define IDC_SHOWSTATES                  1019
#define IDC_SERVERCMDLINE               1020
#define IDC_NESTEDPROP                  1020
#define IDC_ERROR                       1021
#define IDC_CLIENTCMDLINE               1022
#define IDC_FEATURESTATES               1023
#define IDC_SHOWPROP                    1023
#define IDC_SERVERPROP                  1024
#define IDC_ADMINRIGHTS                 1024
#define IDC_EXPLAINLOG                  1025
#define IDC_ISUNICODELOG                1026
#define IDC_POLICIES                    1026
#define IDC_FINDLOG2                    1026
#define IDC_DELETEOUTPUTDIRCONTENTS     1027
#define IDC_PREVIOUSERROR               1069
#define IDC_NEXTERROR                   1070
#define IDC_OUTPUTDIRECTORY             1071
#define IDC_OUTPUTFILENAME              1072
#define IDC_CURRENT_ERROR_NUMBER        1076
#define IDC_TOTAL_ERRORS                1077
#define IDC_SHOW_IGNORED_ERRORS         1078
#define IDC_LIST1                       1079
#define IDC_PROPTEST                    1080
#define IDC_SAVERESULTS                 1081
#define IDC_ELEVATEDINSTALL_TEXT        1082
#define IDC_SHOWINTERNALERRORSHELP      1083
#define IDC_ERROR2                      1084
#define IDC_SHOWHELP                    1084
#define IDC_SHOWHOWTOREADLOG            1085
#define IDC_MACHINEEDITCOL1             2000
#define IDC_MACHINECOL1                 2001
#define IDC_OPEN                        2007
#define IDC_ANALYZE                     2008
#define IDC_FINDLOG                     2009
#define IDC_MACHINEEDITCOL2             3000
#define IDC_MACHINEPROPCOL2             3001
#define IDC_LOGFILES                    3010
#define IDC_USEREDITCOL1                4000
#define IDC_USERCOL1                    4001
#define IDC_USEREDITCOL2                5000
#define IDC_USERCOL2                    5001
#define IDC_CLIENTCONTEXT               6000
#define IDC_SERVERCONTEXT               6001
#define IDC_CUSTOMACTIONCONTEXT         6002
#define IDC_UNKNOWNCONTEXT              6003
#define IDC_ERRORAREA                   6004
#define IDC_PROPERTY                    6005
#define IDC_STATE                       6006
#define IDC_POLICY                      6007
#define IDC_IGNOREDERROR                6008
#define IDC_CHOOSECOLOR_CLIENT          7000
#define IDC_CHOOSECOLOR_SERVER          7001
#define IDC_CHOOSECOLOR__CUSTOMACTION   7002
#define IDC_CHOOSECOLOR_UNKNOWN         7003
#define IDC_CHOOSECOLOR_ERRORAREA       7004
#define IDC_CHOOSECOLOR_PROPERTY        7005
#define IDC_CHOOSECOLOR_STATE           7006
#define IDC_CHOOSECOLOR_POLICY          7007
#define IDC_CHOOSECOLOR_IGNOREDERRORS   7008
#define IDS_INTERNAL_ERROR_BASE         10000
#define IDS_WI_ERROR_1000               11000
#define IDS_WI_ERROR_1001               11001
#define IDS_WI_ERROR_1002               11002
#define IDS_WI_ERROR_1003               11003
#define IDS_WI_ERROR_1004               11004
#define IDS_WI_ERROR_1005               11005
#define IDS_WI_ERROR_1006               11006
#define IDS_WI_ERROR_1007               11007
#define IDS_WI_ERROR_1008               11008
#define IDS_WI_ERROR_1009               11009
#define IDS_WI_ERROR_1010               11010
#define IDS_WI_ERROR_1011               11011
#define IDS_WI_ERROR_1012               11012
#define IDS_WI_ERROR_1013               11013
#define IDS_WI_ERROR_1014               11014
#define IDS_WI_ERROR_1015               11015
#define IDS_WI_ERROR_1016               11016
#define IDS_WI_ERROR_1017               11017
#define IDS_WI_ERROR_1018               11018
#define IDS_WI_ERROR_1019               11019
#define IDS_WI_ERROR_1020               11020
#define IDS_WI_ERROR_1021               11021
#define IDS_WI_ERROR_1022               11022
#define IDS_WI_ERROR_1023               11023
#define IDS_WI_ERROR_1024               11024
#define IDS_WI_ERROR_1025               11025
#define IDS_WI_ERROR_1026               11026
#define IDS_WI_ERROR_1027               11027
#define IDS_WI_ERROR_1028               11028
#define IDS_WI_ERROR_1029               11029
#define IDS_WI_ERROR_1030               11030
#define IDS_WI_ERROR_1031               11031
#define IDS_WI_ERROR_1032               11032
#define IDS_WI_ERROR_1033               11033
#define IDS_WI_ERROR_1034               11034
#define IDS_WI_ERROR_1035               11035
#define IDS_WI_ERROR_1036               11036
#define IDS_WI_ERROR_1037               11037
#define IDS_WI_ERROR_1038               11038
#define IDS_WI_ERROR_1039               11039
#define IDS_WI_ERROR_1040               11040
#define IDS_WI_ERROR_1041               11041
#define IDS_WI_ERROR_1042               11042
#define IDS_WI_ERROR_1043               11043
#define IDS_WI_ERROR_1044               11044
#define IDS_WI_ERROR_1045               11045
#define IDS_WI_ERROR_1046               11046
#define IDS_WI_ERROR_1047               11047
#define IDS_WI_ERROR_1048               11048
#define IDS_WI_ERROR_1049               11049
#define IDS_WI_ERROR_1050               11050
#define IDS_WI_ERROR_1051               11051
#define IDS_WI_ERROR_1052               11052
#define IDS_WI_ERROR_1053               11053
#define IDS_WI_ERROR_1054               11054
#define IDS_WI_ERROR_1055               11055
#define IDS_WI_ERROR_1056               11056
#define IDS_WI_ERROR_1057               11057
#define IDS_WI_ERROR_1058               11058
#define IDS_WI_ERROR_1059               11059
#define IDS_WI_ERROR_1060               11060
#define IDS_WI_ERROR_1061               11061
#define IDS_WI_ERROR_1062               11062
#define IDS_WI_ERROR_1063               11063
#define IDS_WI_ERROR_1064               11064
#define IDS_WI_ERROR_1065               11065
#define IDS_WI_ERROR_1066               11066
#define IDS_WI_ERROR_1067               11067
#define IDS_WI_ERROR_1068               11068
#define IDS_WI_ERROR_1069               11069
#define IDS_WI_ERROR_1070               11070
#define IDS_WI_ERROR_1071               11071
#define IDS_WI_ERROR_1072               11072
#define IDS_WI_ERROR_1073               11073
#define IDS_WI_ERROR_1074               11074
#define IDS_WI_ERROR_1075               11075
#define IDS_WI_ERROR_1076               11076
#define IDS_WI_ERROR_1077               11077
#define IDS_WI_ERROR_1078               11078
#define IDS_WI_ERROR_1079               11079
#define IDS_WI_ERROR_1080               11080
#define IDS_WI_ERROR_1081               11081
#define IDS_WI_ERROR_1082               11082
#define IDS_WI_ERROR_1083               11083
#define IDS_WI_ERROR_1084               11084
#define IDS_WI_ERROR_1085               11085
#define IDS_WI_ERROR_1086               11086
#define IDS_WI_ERROR_1087               11087
#define IDS_WI_ERROR_1088               11088
#define IDS_WI_ERROR_1089               11089
#define IDS_WI_ERROR_1090               11090
#define IDS_WI_ERROR_1091               11091
#define IDS_WI_ERROR_1092               11092
#define IDS_WI_ERROR_1093               11093
#define IDS_WI_ERROR_1094               11094
#define IDS_WI_ERROR_1095               11095
#define IDS_WI_ERROR_1096               11096
#define IDS_WI_ERROR_1097               11097
#define IDS_WI_ERROR_1098               11098
#define IDS_WI_ERROR_1099               11099
#define IDS_WI_ERROR_1100               11100
#define IDS_WI_ERROR_1101               11101
#define IDS_WI_ERROR_1102               11102
#define IDS_WI_ERROR_1103               11103
#define IDS_WI_ERROR_1104               11104
#define IDS_WI_ERROR_1105               11105
#define IDS_WI_ERROR_1106               11106
#define IDS_WI_ERROR_1107               11107
#define IDS_WI_ERROR_1108               11108
#define IDS_WI_ERROR_1109               11109
#define IDS_WI_ERROR_1110               11110
#define IDS_WI_ERROR_1111               11111
#define IDS_WI_ERROR_1112               11112
#define IDS_WI_ERROR_1113               11113
#define IDS_WI_ERROR_1114               11114
#define IDS_WI_ERROR_1115               11115
#define IDS_WI_ERROR_1116               11116
#define IDS_WI_ERROR_1117               11117
#define IDS_WI_ERROR_1118               11118
#define IDS_WI_ERROR_1119               11119
#define IDS_WI_ERROR_1120               11120
#define IDS_WI_ERROR_1121               11121
#define IDS_WI_ERROR_1122               11122
#define IDS_WI_ERROR_1123               11123
#define IDS_WI_ERROR_1124               11124
#define IDS_WI_ERROR_1125               11125
#define IDS_WI_ERROR_1126               11126
#define IDS_WI_ERROR_1127               11127
#define IDS_WI_ERROR_1128               11128
#define IDS_WI_ERROR_1129               11129
#define IDS_WI_ERROR_1130               11130
#define IDS_WI_ERROR_1131               11131
#define IDS_WI_ERROR_1132               11132
#define IDS_WI_ERROR_1133               11133
#define IDS_WI_ERROR_1134               11134
#define IDS_WI_ERROR_1135               11135
#define IDS_WI_ERROR_1136               11136
#define IDS_WI_ERROR_1137               11137
#define IDS_WI_ERROR_1138               11138
#define IDS_WI_ERROR_1139               11139
#define IDS_WI_ERROR_1140               11140
#define IDS_WI_ERROR_1141               11141
#define IDS_WI_ERROR_1142               11142
#define IDS_WI_ERROR_1143               11143
#define IDS_WI_ERROR_1144               11144
#define IDS_WI_ERROR_1145               11145
#define IDS_WI_ERROR_1146               11146
#define IDS_WI_ERROR_1147               11147
#define IDS_WI_ERROR_1148               11148
#define IDS_WI_ERROR_1149               11149
#define IDS_WI_ERROR_1150               11150
#define IDS_WI_ERROR_1151               11151
#define IDS_WI_ERROR_1152               11152
#define IDS_WI_ERROR_1153               11153
#define IDS_WI_ERROR_1154               11154
#define IDS_WI_ERROR_1155               11155
#define IDS_WI_ERROR_1156               11156
#define IDS_WI_ERROR_1157               11157
#define IDS_WI_ERROR_1158               11158
#define IDS_WI_ERROR_1159               11159
#define IDS_WI_ERROR_1160               11160
#define IDS_WI_ERROR_1161               11161
#define IDS_WI_ERROR_1162               11162
#define IDS_WI_ERROR_1163               11163
#define IDS_WI_ERROR_1164               11164
#define IDS_WI_ERROR_1165               11165
#define IDS_WI_ERROR_1166               11166
#define IDS_WI_ERROR_1167               11167
#define IDS_WI_ERROR_1168               11168
#define IDS_WI_ERROR_1169               11169
#define IDS_WI_ERROR_1170               11170
#define IDS_WI_ERROR_1171               11171
#define IDS_WI_ERROR_1172               11172
#define IDS_WI_ERROR_1173               11173
#define IDS_WI_ERROR_1174               11174
#define IDS_WI_ERROR_1175               11175
#define IDS_WI_ERROR_1176               11176
#define IDS_WI_ERROR_1177               11177
#define IDS_WI_ERROR_1178               11178
#define IDS_WI_ERROR_1179               11179
#define IDS_WI_ERROR_1180               11180
#define IDS_WI_ERROR_1181               11181
#define IDS_WI_ERROR_1182               11182
#define IDS_WI_ERROR_1183               11183
#define IDS_WI_ERROR_1184               11184
#define IDS_WI_ERROR_1185               11185
#define IDS_WI_ERROR_1186               11186
#define IDS_WI_ERROR_1187               11187
#define IDS_WI_ERROR_1188               11188
#define IDS_WI_ERROR_1189               11189
#define IDS_WI_ERROR_1190               11190
#define IDS_WI_ERROR_1191               11191
#define IDS_WI_ERROR_1192               11192
#define IDS_WI_ERROR_1193               11193
#define IDS_WI_ERROR_1194               11194
#define IDS_WI_ERROR_1195               11195
#define IDS_WI_ERROR_1196               11196
#define IDS_WI_ERROR_1197               11197
#define IDS_WI_ERROR_1198               11198
#define IDS_WI_ERROR_1199               11199
#define IDS_WI_ERROR_1200               11200
#define IDS_WI_ERROR_1201               11201
#define IDS_WI_ERROR_1202               11202
#define IDS_WI_ERROR_1203               11203
#define IDS_WI_ERROR_1204               11204
#define IDS_WI_ERROR_1205               11205
#define IDS_WI_ERROR_1206               11206
#define IDS_WI_ERROR_1207               11207
#define IDS_WI_ERROR_1208               11208
#define IDS_WI_ERROR_1209               11209
#define IDS_WI_ERROR_1210               11210
#define IDS_WI_ERROR_1211               11211
#define IDS_WI_ERROR_1212               11212
#define IDS_WI_ERROR_1213               11213
#define IDS_WI_ERROR_1214               11214
#define IDS_WI_ERROR_1215               11215
#define IDS_WI_ERROR_1216               11216
#define IDS_WI_ERROR_1217               11217
#define IDS_WI_ERROR_1218               11218
#define IDS_WI_ERROR_1219               11219
#define IDS_WI_ERROR_1220               11220
#define IDS_WI_ERROR_1221               11221
#define IDS_WI_ERROR_1222               11222
#define IDS_WI_ERROR_1223               11223
#define IDS_WI_ERROR_1224               11224
#define IDS_WI_ERROR_1225               11225
#define IDS_WI_ERROR_1226               11226
#define IDS_WI_ERROR_1227               11227
#define IDS_WI_ERROR_1228               11228
#define IDS_WI_ERROR_1229               11229
#define IDS_WI_ERROR_1230               11230
#define IDS_WI_ERROR_1231               11231
#define IDS_WI_ERROR_1232               11232
#define IDS_WI_ERROR_1233               11233
#define IDS_WI_ERROR_1234               11234
#define IDS_WI_ERROR_1235               11235
#define IDS_WI_ERROR_1236               11236
#define IDS_WI_ERROR_1237               11237
#define IDS_WI_ERROR_1238               11238
#define IDS_WI_ERROR_1239               11239
#define IDS_WI_ERROR_1240               11240
#define IDS_WI_ERROR_1241               11241
#define IDS_WI_ERROR_1242               11242
#define IDS_WI_ERROR_1243               11243
#define IDS_WI_ERROR_1244               11244
#define IDS_WI_ERROR_1245               11245
#define IDS_WI_ERROR_1246               11246
#define IDS_WI_ERROR_1247               11247
#define IDS_WI_ERROR_1248               11248
#define IDS_WI_ERROR_1249               11249
#define IDS_WI_ERROR_1250               11250
#define IDS_WI_ERROR_1251               11251
#define IDS_WI_ERROR_1252               11252
#define IDS_WI_ERROR_1253               11253
#define IDS_WI_ERROR_1254               11254
#define IDS_WI_ERROR_1255               11255
#define IDS_WI_ERROR_1256               11256
#define IDS_WI_ERROR_1257               11257
#define IDS_WI_ERROR_1258               11258
#define IDS_WI_ERROR_1259               11259
#define IDS_WI_ERROR_1260               11260
#define IDS_WI_ERROR_1261               11261
#define IDS_WI_ERROR_1262               11262
#define IDS_WI_ERROR_1263               11263
#define IDS_WI_ERROR_1264               11264
#define IDS_WI_ERROR_1265               11265
#define IDS_WI_ERROR_1266               11266
#define IDS_WI_ERROR_1267               11267
#define IDS_WI_ERROR_1268               11268
#define IDS_WI_ERROR_1269               11269
#define IDS_WI_ERROR_1270               11270
#define IDS_WI_ERROR_1271               11271
#define IDS_WI_ERROR_1272               11272
#define IDS_WI_ERROR_1273               11273
#define IDS_WI_ERROR_1274               11274
#define IDS_WI_ERROR_1275               11275
#define IDS_WI_ERROR_1276               11276
#define IDS_WI_ERROR_1277               11277
#define IDS_WI_ERROR_1278               11278
#define IDS_WI_ERROR_1279               11279
#define IDS_WI_ERROR_1280               11280
#define IDS_WI_ERROR_1281               11281
#define IDS_WI_ERROR_1282               11282
#define IDS_WI_ERROR_1283               11283
#define IDS_WI_ERROR_1284               11284
#define IDS_WI_ERROR_1285               11285
#define IDS_WI_ERROR_1286               11286
#define IDS_WI_ERROR_1287               11287
#define IDS_WI_ERROR_1288               11288
#define IDS_WI_ERROR_1289               11289
#define IDS_WI_ERROR_1290               11290
#define IDS_WI_ERROR_1291               11291
#define IDS_WI_ERROR_1292               11292
#define IDS_WI_ERROR_1293               11293
#define IDS_WI_ERROR_1294               11294
#define IDS_WI_ERROR_1295               11295
#define IDS_WI_ERROR_1296               11296
#define IDS_WI_ERROR_1297               11297
#define IDS_WI_ERROR_1298               11298
#define IDS_WI_ERROR_1299               11299
#define IDS_WI_ERROR_1300               11300
#define IDS_WI_ERROR_1301               11301
#define IDS_WI_ERROR_1302               11302
#define IDS_WI_ERROR_1303               11303
#define IDS_WI_ERROR_1304               11304
#define IDS_WI_ERROR_1305               11305
#define IDS_WI_ERROR_1306               11306
#define IDS_WI_ERROR_1307               11307
#define IDS_WI_ERROR_1308               11308
#define IDS_WI_ERROR_1309               11309
#define IDS_WI_ERROR_1310               11310
#define IDS_WI_ERROR_1311               11311
#define IDS_WI_ERROR_1312               11312
#define IDS_WI_ERROR_1313               11313
#define IDS_WI_ERROR_1314               11314
#define IDS_WI_ERROR_1315               11315
#define IDS_WI_ERROR_1316               11316
#define IDS_WI_ERROR_1317               11317
#define IDS_WI_ERROR_1318               11318
#define IDS_WI_ERROR_1319               11319
#define IDS_WI_ERROR_1320               11320
#define IDS_WI_ERROR_1321               11321
#define IDS_WI_ERROR_1322               11322
#define IDS_WI_ERROR_1323               11323
#define IDS_WI_ERROR_1324               11324
#define IDS_WI_ERROR_1325               11325
#define IDS_WI_ERROR_1326               11326
#define IDS_WI_ERROR_1327               11327
#define IDS_WI_ERROR_1328               11328
#define IDS_WI_ERROR_1329               11329
#define IDS_WI_ERROR_1330               11330
#define IDS_WI_ERROR_1331               11331
#define IDS_WI_ERROR_1332               11332
#define IDS_WI_ERROR_1333               11333
#define IDS_WI_ERROR_1334               11334
#define IDS_WI_ERROR_1335               11335
#define IDS_WI_ERROR_1336               11336
#define IDS_WI_ERROR_1337               11337
#define IDS_WI_ERROR_1338               11338
#define IDS_WI_ERROR_1339               11339
#define IDS_WI_ERROR_1340               11340
#define IDS_WI_ERROR_1341               11341
#define IDS_WI_ERROR_1342               11342
#define IDS_WI_ERROR_1343               11343
#define IDS_WI_ERROR_1344               11344
#define IDS_WI_ERROR_1345               11345
#define IDS_WI_ERROR_1346               11346
#define IDS_WI_ERROR_1347               11347
#define IDS_WI_ERROR_1348               11348
#define IDS_WI_ERROR_1349               11349
#define IDS_WI_ERROR_1350               11350
#define IDS_WI_ERROR_1351               11351
#define IDS_WI_ERROR_1352               11352
#define IDS_WI_ERROR_1353               11353
#define IDS_WI_ERROR_1354               11354
#define IDS_WI_ERROR_1355               11355
#define IDS_WI_ERROR_1356               11356
#define IDS_WI_ERROR_1357               11357
#define IDS_WI_ERROR_1358               11358
#define IDS_WI_ERROR_1359               11359
#define IDS_WI_ERROR_1360               11360
#define IDS_WI_ERROR_1361               11361
#define IDS_WI_ERROR_1362               11362
#define IDS_WI_ERROR_1363               11363
#define IDS_WI_ERROR_1364               11364
#define IDS_WI_ERROR_1365               11365
#define IDS_WI_ERROR_1366               11366
#define IDS_WI_ERROR_1367               11367
#define IDS_WI_ERROR_1368               11368
#define IDS_WI_ERROR_1369               11369
#define IDS_WI_ERROR_1370               11370
#define IDS_WI_ERROR_1371               11371
#define IDS_WI_ERROR_1372               11372
#define IDS_WI_ERROR_1373               11373
#define IDS_WI_ERROR_1374               11374
#define IDS_WI_ERROR_1375               11375
#define IDS_WI_ERROR_1376               11376
#define IDS_WI_ERROR_1377               11377
#define IDS_WI_ERROR_1378               11378
#define IDS_WI_ERROR_1379               11379
#define IDS_WI_ERROR_1380               11380
#define IDS_WI_ERROR_1381               11381
#define IDS_WI_ERROR_1382               11382
#define IDS_WI_ERROR_1383               11383
#define IDS_WI_ERROR_1384               11384
#define IDS_WI_ERROR_1385               11385
#define IDS_WI_ERROR_1386               11386
#define IDS_WI_ERROR_1387               11387
#define IDS_WI_ERROR_1388               11388
#define IDS_WI_ERROR_1389               11389
#define IDS_WI_ERROR_1390               11390
#define IDS_WI_ERROR_1391               11391
#define IDS_WI_ERROR_1392               11392
#define IDS_WI_ERROR_1393               11393
#define IDS_WI_ERROR_1394               11394
#define IDS_WI_ERROR_1395               11395
#define IDS_WI_ERROR_1396               11396
#define IDS_WI_ERROR_1397               11397
#define IDS_WI_ERROR_1398               11398
#define IDS_WI_ERROR_1399               11399
#define IDS_WI_ERROR_1400               11400
#define IDS_WI_ERROR_1401               11401
#define IDS_WI_ERROR_1402               11402
#define IDS_WI_ERROR_1403               11403
#define IDS_WI_ERROR_1404               11404
#define IDS_WI_ERROR_1405               11405
#define IDS_WI_ERROR_1406               11406
#define IDS_WI_ERROR_1407               11407
#define IDS_WI_ERROR_1408               11408
#define IDS_WI_ERROR_1409               11409
#define IDS_WI_ERROR_1410               11410
#define IDS_WI_ERROR_1411               11411
#define IDS_WI_ERROR_1412               11412
#define IDS_WI_ERROR_1413               11413
#define IDS_WI_ERROR_1414               11414
#define IDS_WI_ERROR_1415               11415
#define IDS_WI_ERROR_1416               11416
#define IDS_WI_ERROR_1417               11417
#define IDS_WI_ERROR_1418               11418
#define IDS_WI_ERROR_1419               11419
#define IDS_WI_ERROR_1420               11420
#define IDS_WI_ERROR_1421               11421
#define IDS_WI_ERROR_1422               11422
#define IDS_WI_ERROR_1423               11423
#define IDS_WI_ERROR_1424               11424
#define IDS_WI_ERROR_1425               11425
#define IDS_WI_ERROR_1426               11426
#define IDS_WI_ERROR_1427               11427
#define IDS_WI_ERROR_1428               11428
#define IDS_WI_ERROR_1429               11429
#define IDS_WI_ERROR_1430               11430
#define IDS_WI_ERROR_1431               11431
#define IDS_WI_ERROR_1432               11432
#define IDS_WI_ERROR_1433               11433
#define IDS_WI_ERROR_1434               11434
#define IDS_WI_ERROR_1435               11435
#define IDS_WI_ERROR_1436               11436
#define IDS_WI_ERROR_1437               11437
#define IDS_WI_ERROR_1438               11438
#define IDS_WI_ERROR_1439               11439
#define IDS_WI_ERROR_1440               11440
#define IDS_WI_ERROR_1441               11441
#define IDS_WI_ERROR_1442               11442
#define IDS_WI_ERROR_1443               11443
#define IDS_WI_ERROR_1444               11444
#define IDS_WI_ERROR_1445               11445
#define IDS_WI_ERROR_1446               11446
#define IDS_WI_ERROR_1447               11447
#define IDS_WI_ERROR_1448               11448
#define IDS_WI_ERROR_1449               11449
#define IDS_WI_ERROR_1450               11450
#define IDS_WI_ERROR_1451               11451
#define IDS_WI_ERROR_1452               11452
#define IDS_WI_ERROR_1453               11453
#define IDS_WI_ERROR_1454               11454
#define IDS_WI_ERROR_1455               11455
#define IDS_WI_ERROR_1456               11456
#define IDS_WI_ERROR_1457               11457
#define IDS_WI_ERROR_1458               11458
#define IDS_WI_ERROR_1459               11459
#define IDS_WI_ERROR_1460               11460
#define IDS_WI_ERROR_1461               11461
#define IDS_WI_ERROR_1462               11462
#define IDS_WI_ERROR_1463               11463
#define IDS_WI_ERROR_1464               11464
#define IDS_WI_ERROR_1465               11465
#define IDS_WI_ERROR_1466               11466
#define IDS_WI_ERROR_1467               11467
#define IDS_WI_ERROR_1468               11468
#define IDS_WI_ERROR_1469               11469
#define IDS_WI_ERROR_1470               11470
#define IDS_WI_ERROR_1471               11471
#define IDS_WI_ERROR_1472               11472
#define IDS_WI_ERROR_1473               11473
#define IDS_WI_ERROR_1474               11474
#define IDS_WI_ERROR_1475               11475
#define IDS_WI_ERROR_1476               11476
#define IDS_WI_ERROR_1477               11477
#define IDS_WI_ERROR_1478               11478
#define IDS_WI_ERROR_1479               11479
#define IDS_WI_ERROR_1480               11480
#define IDS_WI_ERROR_1481               11481
#define IDS_WI_ERROR_1482               11482
#define IDS_WI_ERROR_1483               11483
#define IDS_WI_ERROR_1484               11484
#define IDS_WI_ERROR_1485               11485
#define IDS_WI_ERROR_1486               11486
#define IDS_WI_ERROR_1487               11487
#define IDS_WI_ERROR_1488               11488
#define IDS_WI_ERROR_1489               11489
#define IDS_WI_ERROR_1490               11490
#define IDS_WI_ERROR_1491               11491
#define IDS_WI_ERROR_1492               11492
#define IDS_WI_ERROR_1493               11493
#define IDS_WI_ERROR_1494               11494
#define IDS_WI_ERROR_1495               11495
#define IDS_WI_ERROR_1496               11496
#define IDS_WI_ERROR_1497               11497
#define IDS_WI_ERROR_1498               11498
#define IDS_WI_ERROR_1499               11499
#define IDS_WI_ERROR_1500               11500
#define IDS_WI_ERROR_1501               11501
#define IDS_WI_ERROR_1502               11502
#define IDS_WI_ERROR_1503               11503
#define IDS_WI_ERROR_1504               11504
#define IDS_WI_ERROR_1505               11505
#define IDS_WI_ERROR_1506               11506
#define IDS_WI_ERROR_1507               11507
#define IDS_WI_ERROR_1508               11508
#define IDS_WI_ERROR_1509               11509
#define IDS_WI_ERROR_1510               11510
#define IDS_WI_ERROR_1511               11511
#define IDS_WI_ERROR_1512               11512
#define IDS_WI_ERROR_1513               11513
#define IDS_WI_ERROR_1514               11514
#define IDS_WI_ERROR_1515               11515
#define IDS_WI_ERROR_1516               11516
#define IDS_WI_ERROR_1517               11517
#define IDS_WI_ERROR_1518               11518
#define IDS_WI_ERROR_1519               11519
#define IDS_WI_ERROR_1520               11520
#define IDS_WI_ERROR_1521               11521
#define IDS_WI_ERROR_1522               11522
#define IDS_WI_ERROR_1523               11523
#define IDS_WI_ERROR_1524               11524
#define IDS_WI_ERROR_1525               11525
#define IDS_WI_ERROR_1526               11526
#define IDS_WI_ERROR_1527               11527
#define IDS_WI_ERROR_1528               11528
#define IDS_WI_ERROR_1529               11529
#define IDS_WI_ERROR_1530               11530
#define IDS_WI_ERROR_1531               11531
#define IDS_WI_ERROR_1532               11532
#define IDS_WI_ERROR_1533               11533
#define IDS_WI_ERROR_1534               11534
#define IDS_WI_ERROR_1535               11535
#define IDS_WI_ERROR_1536               11536
#define IDS_WI_ERROR_1537               11537
#define IDS_WI_ERROR_1538               11538
#define IDS_WI_ERROR_1539               11539
#define IDS_WI_ERROR_1540               11540
#define IDS_WI_ERROR_1541               11541
#define IDS_WI_ERROR_1542               11542
#define IDS_WI_ERROR_1543               11543
#define IDS_WI_ERROR_1544               11544
#define IDS_WI_ERROR_1545               11545
#define IDS_WI_ERROR_1546               11546
#define IDS_WI_ERROR_1547               11547
#define IDS_WI_ERROR_1548               11548
#define IDS_WI_ERROR_1549               11549
#define IDS_WI_ERROR_1550               11550
#define IDS_WI_ERROR_1551               11551
#define IDS_WI_ERROR_1552               11552
#define IDS_WI_ERROR_1553               11553
#define IDS_WI_ERROR_1554               11554
#define IDS_WI_ERROR_1555               11555
#define IDS_WI_ERROR_1556               11556
#define IDS_WI_ERROR_1557               11557
#define IDS_WI_ERROR_1558               11558
#define IDS_WI_ERROR_1559               11559
#define IDS_WI_ERROR_1560               11560
#define IDS_WI_ERROR_1561               11561
#define IDS_WI_ERROR_1562               11562
#define IDS_WI_ERROR_1563               11563
#define IDS_WI_ERROR_1564               11564
#define IDS_WI_ERROR_1565               11565
#define IDS_WI_ERROR_1566               11566
#define IDS_WI_ERROR_1567               11567
#define IDS_WI_ERROR_1568               11568
#define IDS_WI_ERROR_1569               11569
#define IDS_WI_ERROR_1570               11570
#define IDS_WI_ERROR_1571               11571
#define IDS_WI_ERROR_1572               11572
#define IDS_WI_ERROR_1573               11573
#define IDS_WI_ERROR_1574               11574
#define IDS_WI_ERROR_1575               11575
#define IDS_WI_ERROR_1576               11576
#define IDS_WI_ERROR_1577               11577
#define IDS_WI_ERROR_1578               11578
#define IDS_WI_ERROR_1579               11579
#define IDS_WI_ERROR_1580               11580
#define IDS_WI_ERROR_1581               11581
#define IDS_WI_ERROR_1582               11582
#define IDS_WI_ERROR_1583               11583
#define IDS_WI_ERROR_1584               11584
#define IDS_WI_ERROR_1585               11585
#define IDS_WI_ERROR_1586               11586
#define IDS_WI_ERROR_1587               11587
#define IDS_WI_ERROR_1588               11588
#define IDS_WI_ERROR_1589               11589
#define IDS_WI_ERROR_1590               11590
#define IDS_WI_ERROR_1591               11591
#define IDS_WI_ERROR_1592               11592
#define IDS_WI_ERROR_1593               11593
#define IDS_WI_ERROR_1594               11594
#define IDS_WI_ERROR_1595               11595
#define IDS_WI_ERROR_1596               11596
#define IDS_WI_ERROR_1597               11597
#define IDS_WI_ERROR_1598               11598
#define IDS_WI_ERROR_1599               11599
#define IDS_WI_ERROR_1600               11600
#define IDS_WI_ERROR_1601               11601
#define IDS_WI_ERROR_1602               11602
#define IDS_WI_ERROR_1603               11603
#define IDS_WI_ERROR_1604               11604
#define IDS_WI_ERROR_1605               11605
#define IDS_WI_ERROR_1606               11606
#define IDS_WI_ERROR_1607               11607
#define IDS_WI_ERROR_1608               11608
#define IDS_WI_ERROR_1609               11609
#define IDS_WI_ERROR_1610               11610
#define IDS_WI_ERROR_1611               11611
#define IDS_WI_ERROR_1612               11612
#define IDS_WI_ERROR_1613               11613
#define IDS_WI_ERROR_1614               11614
#define IDS_WI_ERROR_1615               11615
#define IDS_WI_ERROR_1616               11616
#define IDS_WI_ERROR_1617               11617
#define IDS_WI_ERROR_1618               11618
#define IDS_WI_ERROR_1619               11619
#define IDS_WI_ERROR_1620               11620
#define IDS_WI_ERROR_1621               11621
#define IDS_WI_ERROR_1622               11622
#define IDS_WI_ERROR_1623               11623
#define IDS_WI_ERROR_1624               11624
#define IDS_WI_ERROR_1625               11625
#define IDS_WI_ERROR_1626               11626
#define IDS_WI_ERROR_1627               11627
#define IDS_WI_ERROR_1628               11628
#define IDS_WI_ERROR_1629               11629
#define IDS_WI_ERROR_1630               11630
#define IDS_WI_ERROR_1631               11631
#define IDS_WI_ERROR_1632               11632
#define IDS_WI_ERROR_1633               11633
#define IDS_WI_ERROR_1634               11634
#define IDS_WI_ERROR_1635               11635
#define IDS_WI_ERROR_1636               11636
#define IDS_WI_ERROR_1637               11637
#define IDS_WI_ERROR_1638               11638
#define IDS_WI_ERROR_1639               11639
#define IDS_WI_ERROR_1640               11640
#define IDS_WI_ERROR_1641               11641
#define IDS_WI_ERROR_1642               11642
#define IDS_WI_ERROR_1643               11643
#define IDS_WI_ERROR_1644               11644
#define IDS_WI_ERROR_1645               11645
#define IDS_WI_ERROR_1646               11646
#define IDS_WI_ERROR_1647               11647
#define IDS_WI_ERROR_1648               11648
#define IDS_WI_ERROR_1649               11649
#define IDS_WI_ERROR_1650               11650
#define IDS_WI_ERROR_1651               11651
#define IDS_WI_ERROR_1652               11652
#define IDS_WI_ERROR_1653               11653
#define IDS_WI_ERROR_1654               11654
#define IDS_WI_ERROR_1655               11655
#define IDS_WI_ERROR_1656               11656
#define IDS_WI_ERROR_1657               11657
#define IDS_WI_ERROR_1658               11658
#define IDS_WI_ERROR_1659               11659
#define IDS_WI_ERROR_1660               11660
#define IDS_WI_ERROR_1661               11661
#define IDS_WI_ERROR_1662               11662
#define IDS_WI_ERROR_1663               11663
#define IDS_WI_ERROR_1664               11664
#define IDS_WI_ERROR_1665               11665
#define IDS_WI_ERROR_1666               11666
#define IDS_WI_ERROR_1667               11667
#define IDS_WI_ERROR_1668               11668
#define IDS_WI_ERROR_1669               11669
#define IDS_WI_ERROR_1670               11670
#define IDS_WI_ERROR_1671               11671
#define IDS_WI_ERROR_1672               11672
#define IDS_WI_ERROR_1673               11673
#define IDS_WI_ERROR_1674               11674
#define IDS_WI_ERROR_1675               11675
#define IDS_WI_ERROR_1676               11676
#define IDS_WI_ERROR_1677               11677
#define IDS_WI_ERROR_1678               11678
#define IDS_WI_ERROR_1679               11679
#define IDS_WI_ERROR_1680               11680
#define IDS_WI_ERROR_1681               11681
#define IDS_WI_ERROR_1682               11682
#define IDS_WI_ERROR_1683               11683
#define IDS_WI_ERROR_1684               11684
#define IDS_WI_ERROR_1685               11685
#define IDS_WI_ERROR_1686               11686
#define IDS_WI_ERROR_1687               11687
#define IDS_WI_ERROR_1688               11688
#define IDS_WI_ERROR_1689               11689
#define IDS_WI_ERROR_1690               11690
#define IDS_WI_ERROR_1691               11691
#define IDS_WI_ERROR_1692               11692
#define IDS_WI_ERROR_1693               11693
#define IDS_WI_ERROR_1694               11694
#define IDS_WI_ERROR_1695               11695
#define IDS_WI_ERROR_1696               11696
#define IDS_WI_ERROR_1697               11697
#define IDS_WI_ERROR_1698               11698
#define IDS_WI_ERROR_1699               11699
#define IDS_WI_ERROR_1700               11700
#define IDS_WI_ERROR_1701               11701
#define IDS_WI_ERROR_1702               11702
#define IDS_WI_ERROR_1703               11703
#define IDS_WI_ERROR_1704               11704
#define IDS_WI_ERROR_1705               11705
#define IDS_WI_ERROR_1706               11706
#define IDS_WI_ERROR_1707               11707
#define IDS_WI_ERROR_1708               11708
#define IDS_WI_ERROR_1709               11709
#define IDS_WI_ERROR_1710               11710
#define IDS_WI_ERROR_1711               11711
#define IDS_WI_ERROR_1712               11712
#define IDS_WI_ERROR_1713               11713
#define IDS_WI_ERROR_1714               11714
#define IDS_WI_ERROR_1715               11715
#define IDS_WI_ERROR_1716               11716
#define IDS_WI_ERROR_1717               11717
#define IDS_WI_ERROR_1718               11718
#define IDS_WI_ERROR_1719               11719
#define IDS_WI_ERROR_1720               11720
#define IDS_WI_ERROR_1721               11721
#define IDS_WI_ERROR_1722               11722
#define IDS_WI_ERROR_1723               11723
#define IDS_WI_ERROR_1724               11724
#define IDS_WI_ERROR_1725               11725
#define IDS_WI_ERROR_1726               11726
#define IDS_WI_ERROR_1727               11727
#define IDS_WI_ERROR_1728               11728
#define IDS_WI_ERROR_1729               11729
#define IDS_WI_ERROR_1730               11730
#define IDS_WI_ERROR_1731               11731
#define IDS_WI_ERROR_1732               11732
#define IDS_WI_ERROR_1733               11733
#define IDS_WI_ERROR_1734               11734
#define IDS_WI_ERROR_1735               11735
#define IDS_WI_ERROR_1736               11736
#define IDS_WI_ERROR_1737               11737
#define IDS_WI_ERROR_1738               11738
#define IDS_WI_ERROR_1739               11739
#define IDS_WI_ERROR_1740               11740
#define IDS_WI_ERROR_1741               11741
#define IDS_WI_ERROR_1742               11742
#define IDS_WI_ERROR_1743               11743
#define IDS_WI_ERROR_1744               11744
#define IDS_WI_ERROR_1745               11745
#define IDS_WI_ERROR_1746               11746
#define IDS_WI_ERROR_1747               11747
#define IDS_WI_ERROR_1748               11748
#define IDS_WI_ERROR_1749               11749
#define IDS_WI_ERROR_1750               11750
#define IDS_WI_ERROR_1751               11751
#define IDS_WI_ERROR_1752               11752
#define IDS_WI_ERROR_1753               11753
#define IDS_WI_ERROR_1754               11754
#define IDS_WI_ERROR_1755               11755
#define IDS_WI_ERROR_1756               11756
#define IDS_WI_ERROR_1757               11757
#define IDS_WI_ERROR_1758               11758
#define IDS_WI_ERROR_1759               11759
#define IDS_WI_ERROR_1760               11760
#define IDS_WI_ERROR_1761               11761
#define IDS_WI_ERROR_1762               11762
#define IDS_WI_ERROR_1763               11763
#define IDS_WI_ERROR_1764               11764
#define IDS_WI_ERROR_1765               11765
#define IDS_WI_ERROR_1766               11766
#define IDS_WI_ERROR_1767               11767
#define IDS_WI_ERROR_1768               11768
#define IDS_WI_ERROR_1769               11769
#define IDS_WI_ERROR_1770               11770
#define IDS_WI_ERROR_1771               11771
#define IDS_WI_ERROR_1772               11772
#define IDS_WI_ERROR_1773               11773
#define IDS_WI_ERROR_1774               11774
#define IDS_WI_ERROR_1775               11775
#define IDS_WI_ERROR_1776               11776
#define IDS_WI_ERROR_1777               11777
#define IDS_WI_ERROR_1778               11778
#define IDS_WI_ERROR_1779               11779
#define IDS_WI_ERROR_1780               11780
#define IDS_WI_ERROR_1781               11781
#define IDS_WI_ERROR_1782               11782
#define IDS_WI_ERROR_1783               11783
#define IDS_WI_ERROR_1784               11784
#define IDS_WI_ERROR_1785               11785
#define IDS_WI_ERROR_1786               11786
#define IDS_WI_ERROR_1787               11787
#define IDS_WI_ERROR_1788               11788
#define IDS_WI_ERROR_1789               11789
#define IDS_WI_ERROR_1790               11790
#define IDS_WI_ERROR_1791               11791
#define IDS_WI_ERROR_1792               11792
#define IDS_WI_ERROR_1793               11793
#define IDS_WI_ERROR_1794               11794
#define IDS_WI_ERROR_1795               11795
#define IDS_WI_ERROR_1796               11796
#define IDS_WI_ERROR_1797               11797
#define IDS_WI_ERROR_1798               11798
#define IDS_WI_ERROR_1799               11799
#define IDS_WI_ERROR_1800               11800
#define IDS_WI_ERROR_1801               11801
#define IDS_WI_ERROR_1802               11802
#define IDS_WI_ERROR_1803               11803
#define IDS_WI_ERROR_1804               11804
#define IDS_WI_ERROR_1805               11805
#define IDS_WI_ERROR_1806               11806
#define IDS_WI_ERROR_1807               11807
#define IDS_WI_ERROR_1808               11808
#define IDS_WI_ERROR_1809               11809
#define IDS_WI_ERROR_1810               11810
#define IDS_WI_ERROR_1811               11811
#define IDS_WI_ERROR_1812               11812
#define IDS_WI_ERROR_1813               11813
#define IDS_WI_ERROR_1814               11814
#define IDS_WI_ERROR_1815               11815
#define IDS_WI_ERROR_1816               11816
#define IDS_WI_ERROR_1817               11817
#define IDS_WI_ERROR_1818               11818
#define IDS_WI_ERROR_1819               11819
#define IDS_WI_ERROR_1820               11820
#define IDS_WI_ERROR_1821               11821
#define IDS_WI_ERROR_1822               11822
#define IDS_WI_ERROR_1823               11823
#define IDS_WI_ERROR_1824               11824
#define IDS_WI_ERROR_1825               11825
#define IDS_WI_ERROR_1826               11826
#define IDS_WI_ERROR_1827               11827
#define IDS_WI_ERROR_1828               11828
#define IDS_WI_ERROR_1829               11829
#define IDS_WI_ERROR_1830               11830
#define IDS_WI_ERROR_1831               11831
#define IDS_WI_ERROR_1832               11832
#define IDS_WI_ERROR_1833               11833
#define IDS_WI_ERROR_1834               11834
#define IDS_WI_ERROR_1835               11835
#define IDS_WI_ERROR_1836               11836
#define IDS_WI_ERROR_1837               11837
#define IDS_WI_ERROR_1838               11838
#define IDS_WI_ERROR_1839               11839
#define IDS_WI_ERROR_1840               11840
#define IDS_WI_ERROR_1841               11841
#define IDS_WI_ERROR_1842               11842
#define IDS_WI_ERROR_1843               11843
#define IDS_WI_ERROR_1844               11844
#define IDS_WI_ERROR_1845               11845
#define IDS_WI_ERROR_1846               11846
#define IDS_WI_ERROR_1847               11847
#define IDS_WI_ERROR_1848               11848
#define IDS_WI_ERROR_1849               11849
#define IDS_WI_ERROR_1850               11850
#define IDS_WI_ERROR_1851               11851
#define IDS_WI_ERROR_1852               11852
#define IDS_WI_ERROR_1853               11853
#define IDS_WI_ERROR_1854               11854
#define IDS_WI_ERROR_1855               11855
#define IDS_WI_ERROR_1856               11856
#define IDS_WI_ERROR_1857               11857
#define IDS_WI_ERROR_1858               11858
#define IDS_WI_ERROR_1859               11859
#define IDS_WI_ERROR_1860               11860
#define IDS_WI_ERROR_1861               11861
#define IDS_WI_ERROR_1862               11862
#define IDS_WI_ERROR_1863               11863
#define IDS_WI_ERROR_1864               11864
#define IDS_WI_ERROR_1865               11865
#define IDS_WI_ERROR_1866               11866
#define IDS_WI_ERROR_1867               11867
#define IDS_WI_ERROR_1868               11868
#define IDS_WI_ERROR_1869               11869
#define IDS_WI_ERROR_1870               11870
#define IDS_WI_ERROR_1871               11871
#define IDS_WI_ERROR_1872               11872
#define IDS_WI_ERROR_1873               11873
#define IDS_WI_ERROR_1874               11874
#define IDS_WI_ERROR_1875               11875
#define IDS_WI_ERROR_1876               11876
#define IDS_WI_ERROR_1877               11877
#define IDS_WI_ERROR_1878               11878
#define IDS_WI_ERROR_1879               11879
#define IDS_WI_ERROR_1880               11880
#define IDS_WI_ERROR_1881               11881
#define IDS_WI_ERROR_1882               11882
#define IDS_WI_ERROR_1883               11883
#define IDS_WI_ERROR_1884               11884
#define IDS_WI_ERROR_1885               11885
#define IDS_WI_ERROR_1886               11886
#define IDS_WI_ERROR_1887               11887
#define IDS_WI_ERROR_1888               11888
#define IDS_WI_ERROR_1889               11889
#define IDS_WI_ERROR_1890               11890
#define IDS_WI_ERROR_1891               11891
#define IDS_WI_ERROR_1892               11892
#define IDS_WI_ERROR_1893               11893
#define IDS_WI_ERROR_1894               11894
#define IDS_WI_ERROR_1895               11895
#define IDS_WI_ERROR_1896               11896
#define IDS_WI_ERROR_1897               11897
#define IDS_WI_ERROR_1898               11898
#define IDS_WI_ERROR_1899               11899
#define IDS_WI_ERROR_1900               11900
#define IDS_WI_ERROR_1901               11901
#define IDS_WI_ERROR_1902               11902
#define IDS_WI_ERROR_1903               11903
#define IDS_WI_ERROR_1904               11904
#define IDS_WI_ERROR_1905               11905
#define IDS_WI_ERROR_1906               11906
#define IDS_WI_ERROR_1907               11907
#define IDS_WI_ERROR_1908               11908
#define IDS_WI_ERROR_1909               11909
#define IDS_WI_ERROR_1910               11910
#define IDS_WI_ERROR_1911               11911
#define IDS_WI_ERROR_1912               11912
#define IDS_WI_ERROR_1913               11913
#define IDS_WI_ERROR_1914               11914
#define IDS_WI_ERROR_1915               11915
#define IDS_WI_ERROR_1916               11916
#define IDS_WI_ERROR_1917               11917
#define IDS_WI_ERROR_1918               11918
#define IDS_WI_ERROR_1919               11919
#define IDS_WI_ERROR_1920               11920
#define IDS_WI_ERROR_1921               11921
#define IDS_WI_ERROR_1922               11922
#define IDS_WI_ERROR_1923               11923
#define IDS_WI_ERROR_1924               11924
#define IDS_WI_ERROR_1925               11925
#define IDS_WI_ERROR_1926               11926
#define IDS_WI_ERROR_1927               11927
#define IDS_WI_ERROR_1928               11928
#define IDS_WI_ERROR_1929               11929
#define IDS_WI_ERROR_1930               11930
#define IDS_WI_ERROR_1931               11931
#define IDS_WI_ERROR_1932               11932
#define IDS_WI_ERROR_1933               11933
#define IDS_WI_ERROR_1934               11934
#define IDS_WI_ERROR_1935               11935
#define IDS_WI_ERROR_1936               11936
#define IDS_WI_ERROR_1937               11937
#define IDS_WI_ERROR_1938               11938
#define IDS_WI_ERROR_1939               11939
#define IDS_WI_ERROR_1940               11940
#define IDS_WI_ERROR_1941               11941
#define IDS_WI_ERROR_1942               11942
#define IDS_WI_ERROR_1943               11943
#define IDS_WI_ERROR_1944               11944
#define IDS_WI_ERROR_1945               11945
#define IDS_WI_ERROR_1946               11946
#define IDS_WI_ERROR_1947               11947
#define IDS_WI_ERROR_1948               11948
#define IDS_WI_ERROR_1949               11949
#define IDS_WI_ERROR_1950               11950
#define IDS_WI_ERROR_1951               11951
#define IDS_WI_ERROR_1952               11952
#define IDS_WI_ERROR_1953               11953
#define IDS_WI_ERROR_1954               11954
#define IDS_WI_ERROR_1955               11955
#define IDS_WI_ERROR_1956               11956
#define IDS_WI_ERROR_1957               11957
#define IDS_WI_ERROR_1958               11958
#define IDS_WI_ERROR_1959               11959
#define IDS_WI_ERROR_1960               11960
#define IDS_WI_ERROR_1961               11961
#define IDS_WI_ERROR_1962               11962
#define IDS_WI_ERROR_1963               11963
#define IDS_WI_ERROR_1964               11964
#define IDS_WI_ERROR_1965               11965
#define IDS_WI_ERROR_1966               11966
#define IDS_WI_ERROR_1967               11967
#define IDS_WI_ERROR_1968               11968
#define IDS_WI_ERROR_1969               11969
#define IDS_WI_ERROR_1970               11970
#define IDS_WI_ERROR_1971               11971
#define IDS_WI_ERROR_1972               11972
#define IDS_WI_ERROR_1973               11973
#define IDS_WI_ERROR_1974               11974
#define IDS_WI_ERROR_1975               11975
#define IDS_WI_ERROR_1976               11976
#define IDS_WI_ERROR_1977               11977
#define IDS_WI_ERROR_1978               11978
#define IDS_WI_ERROR_1979               11979
#define IDS_WI_ERROR_1980               11980
#define IDS_WI_ERROR_1981               11981
#define IDS_WI_ERROR_1982               11982
#define IDS_WI_ERROR_1983               11983
#define IDS_WI_ERROR_1984               11984
#define IDS_WI_ERROR_1985               11985
#define IDS_WI_ERROR_1986               11986
#define IDS_WI_ERROR_1987               11987
#define IDS_WI_ERROR_1988               11988
#define IDS_WI_ERROR_1989               11989
#define IDS_WI_ERROR_1990               11990
#define IDS_WI_ERROR_1991               11991
#define IDS_WI_ERROR_1992               11992
#define IDS_WI_ERROR_1993               11993
#define IDS_WI_ERROR_1994               11994
#define IDS_WI_ERROR_1995               11995
#define IDS_WI_ERROR_1996               11996
#define IDS_WI_ERROR_1997               11997
#define IDS_WI_ERROR_1998               11998
#define IDS_WI_ERROR_1999               11999
#define IDS_WI_ERROR_2000               12000
#define IDS_WI_ERROR_2001               12001
#define IDS_WI_ERROR_2002               12002
#define IDS_WI_ERROR_2003               12003
#define IDS_WI_ERROR_2004               12004
#define IDS_WI_ERROR_2005               12005
#define IDS_WI_ERROR_2006               12006
#define IDS_WI_ERROR_2007               12007
#define IDS_WI_ERROR_2008               12008
#define IDS_WI_ERROR_2009               12009
#define IDS_WI_ERROR_2010               12010
#define IDS_WI_ERROR_2011               12011
#define IDS_WI_ERROR_2012               12012
#define IDS_WI_ERROR_2013               12013
#define IDS_WI_ERROR_2014               12014
#define IDS_WI_ERROR_2015               12015
#define IDS_WI_ERROR_2016               12016
#define IDS_WI_ERROR_2017               12017
#define IDS_WI_ERROR_2018               12018
#define IDS_WI_ERROR_2019               12019
#define IDS_WI_ERROR_2020               12020
#define IDS_WI_ERROR_2021               12021
#define IDS_WI_ERROR_2022               12022
#define IDS_WI_ERROR_2023               12023
#define IDS_WI_ERROR_2024               12024
#define IDS_WI_ERROR_2025               12025
#define IDS_WI_ERROR_2026               12026
#define IDS_WI_ERROR_2027               12027
#define IDS_WI_ERROR_2028               12028
#define IDS_WI_ERROR_2029               12029
#define IDS_WI_ERROR_2030               12030
#define IDS_WI_ERROR_2031               12031
#define IDS_WI_ERROR_2032               12032
#define IDS_WI_ERROR_2033               12033
#define IDS_WI_ERROR_2034               12034
#define IDS_WI_ERROR_2035               12035
#define IDS_WI_ERROR_2036               12036
#define IDS_WI_ERROR_2037               12037
#define IDS_WI_ERROR_2038               12038
#define IDS_WI_ERROR_2039               12039
#define IDS_WI_ERROR_2040               12040
#define IDS_WI_ERROR_2041               12041
#define IDS_WI_ERROR_2042               12042
#define IDS_WI_ERROR_2043               12043
#define IDS_WI_ERROR_2044               12044
#define IDS_WI_ERROR_2045               12045
#define IDS_WI_ERROR_2046               12046
#define IDS_WI_ERROR_2047               12047
#define IDS_WI_ERROR_2048               12048
#define IDS_WI_ERROR_2049               12049
#define IDS_WI_ERROR_2050               12050
#define IDS_WI_ERROR_2051               12051
#define IDS_WI_ERROR_2052               12052
#define IDS_WI_ERROR_2053               12053
#define IDS_WI_ERROR_2054               12054
#define IDS_WI_ERROR_2055               12055
#define IDS_WI_ERROR_2056               12056
#define IDS_WI_ERROR_2057               12057
#define IDS_WI_ERROR_2058               12058
#define IDS_WI_ERROR_2059               12059
#define IDS_WI_ERROR_2060               12060
#define IDS_WI_ERROR_2061               12061
#define IDS_WI_ERROR_2062               12062
#define IDS_WI_ERROR_2063               12063
#define IDS_WI_ERROR_2064               12064
#define IDS_WI_ERROR_2065               12065
#define IDS_WI_ERROR_2066               12066
#define IDS_WI_ERROR_2067               12067
#define IDS_WI_ERROR_2068               12068
#define IDS_WI_ERROR_2069               12069
#define IDS_WI_ERROR_2070               12070
#define IDS_WI_ERROR_2071               12071
#define IDS_WI_ERROR_2072               12072
#define IDS_WI_ERROR_2073               12073
#define IDS_WI_ERROR_2074               12074
#define IDS_WI_ERROR_2075               12075
#define IDS_WI_ERROR_2076               12076
#define IDS_WI_ERROR_2077               12077
#define IDS_WI_ERROR_2078               12078
#define IDS_WI_ERROR_2079               12079
#define IDS_WI_ERROR_2080               12080
#define IDS_WI_ERROR_2081               12081
#define IDS_WI_ERROR_2082               12082
#define IDS_WI_ERROR_2083               12083
#define IDS_WI_ERROR_2084               12084
#define IDS_WI_ERROR_2085               12085
#define IDS_WI_ERROR_2086               12086
#define IDS_WI_ERROR_2087               12087
#define IDS_WI_ERROR_2088               12088
#define IDS_WI_ERROR_2089               12089
#define IDS_WI_ERROR_2090               12090
#define IDS_WI_ERROR_2091               12091
#define IDS_WI_ERROR_2092               12092
#define IDS_WI_ERROR_2093               12093
#define IDS_WI_ERROR_2094               12094
#define IDS_WI_ERROR_2095               12095
#define IDS_WI_ERROR_2096               12096
#define IDS_WI_ERROR_2097               12097
#define IDS_WI_ERROR_2098               12098
#define IDS_WI_ERROR_2099               12099
#define IDS_WI_ERROR_2100               12100
#define IDS_WI_ERROR_2101               12101
#define IDS_WI_ERROR_2102               12102
#define IDS_WI_ERROR_2103               12103
#define IDS_WI_ERROR_2104               12104
#define IDS_WI_ERROR_2105               12105
#define IDS_WI_ERROR_2106               12106
#define IDS_WI_ERROR_2107               12107
#define IDS_WI_ERROR_2108               12108
#define IDS_WI_ERROR_2109               12109
#define IDS_WI_ERROR_2110               12110
#define IDS_WI_ERROR_2111               12111
#define IDS_WI_ERROR_2112               12112
#define IDS_WI_ERROR_2113               12113
#define IDS_WI_ERROR_2114               12114
#define IDS_WI_ERROR_2115               12115
#define IDS_WI_ERROR_2116               12116
#define IDS_WI_ERROR_2117               12117
#define IDS_WI_ERROR_2118               12118
#define IDS_WI_ERROR_2119               12119
#define IDS_WI_ERROR_2120               12120
#define IDS_WI_ERROR_2121               12121
#define IDS_WI_ERROR_2122               12122
#define IDS_WI_ERROR_2123               12123
#define IDS_WI_ERROR_2124               12124
#define IDS_WI_ERROR_2125               12125
#define IDS_WI_ERROR_2126               12126
#define IDS_WI_ERROR_2127               12127
#define IDS_WI_ERROR_2128               12128
#define IDS_WI_ERROR_2129               12129
#define IDS_WI_ERROR_2130               12130
#define IDS_WI_ERROR_2131               12131
#define IDS_WI_ERROR_2132               12132
#define IDS_WI_ERROR_2133               12133
#define IDS_WI_ERROR_2134               12134
#define IDS_WI_ERROR_2135               12135
#define IDS_WI_ERROR_2136               12136
#define IDS_WI_ERROR_2137               12137
#define IDS_WI_ERROR_2138               12138
#define IDS_WI_ERROR_2139               12139
#define IDS_WI_ERROR_2140               12140
#define IDS_WI_ERROR_2141               12141
#define IDS_WI_ERROR_2142               12142
#define IDS_WI_ERROR_2143               12143
#define IDS_WI_ERROR_2144               12144
#define IDS_WI_ERROR_2145               12145
#define IDS_WI_ERROR_2146               12146
#define IDS_WI_ERROR_2147               12147
#define IDS_WI_ERROR_2148               12148
#define IDS_WI_ERROR_2149               12149
#define IDS_WI_ERROR_2150               12150
#define IDS_WI_ERROR_2151               12151
#define IDS_WI_ERROR_2152               12152
#define IDS_WI_ERROR_2153               12153
#define IDS_WI_ERROR_2154               12154
#define IDS_WI_ERROR_2155               12155
#define IDS_WI_ERROR_2156               12156
#define IDS_WI_ERROR_2157               12157
#define IDS_WI_ERROR_2158               12158
#define IDS_WI_ERROR_2159               12159
#define IDS_WI_ERROR_2160               12160
#define IDS_WI_ERROR_2161               12161
#define IDS_WI_ERROR_2162               12162
#define IDS_WI_ERROR_2163               12163
#define IDS_WI_ERROR_2164               12164
#define IDS_WI_ERROR_2165               12165
#define IDS_WI_ERROR_2166               12166
#define IDS_WI_ERROR_2167               12167
#define IDS_WI_ERROR_2168               12168
#define IDS_WI_ERROR_2169               12169
#define IDS_WI_ERROR_2170               12170
#define IDS_WI_ERROR_2171               12171
#define IDS_WI_ERROR_2172               12172
#define IDS_WI_ERROR_2173               12173
#define IDS_WI_ERROR_2174               12174
#define IDS_WI_ERROR_2175               12175
#define IDS_WI_ERROR_2176               12176
#define IDS_WI_ERROR_2177               12177
#define IDS_WI_ERROR_2178               12178
#define IDS_WI_ERROR_2179               12179
#define IDS_WI_ERROR_2180               12180
#define IDS_WI_ERROR_2181               12181
#define IDS_WI_ERROR_2182               12182
#define IDS_WI_ERROR_2183               12183
#define IDS_WI_ERROR_2184               12184
#define IDS_WI_ERROR_2185               12185
#define IDS_WI_ERROR_2186               12186
#define IDS_WI_ERROR_2187               12187
#define IDS_WI_ERROR_2188               12188
#define IDS_WI_ERROR_2189               12189
#define IDS_WI_ERROR_2190               12190
#define IDS_WI_ERROR_2191               12191
#define IDS_WI_ERROR_2192               12192
#define IDS_WI_ERROR_2193               12193
#define IDS_WI_ERROR_2194               12194
#define IDS_WI_ERROR_2195               12195
#define IDS_WI_ERROR_2196               12196
#define IDS_WI_ERROR_2197               12197
#define IDS_WI_ERROR_2198               12198
#define IDS_WI_ERROR_2199               12199
#define IDS_WI_ERROR_2200               12200
#define IDS_WI_ERROR_2201               12201
#define IDS_WI_ERROR_2202               12202
#define IDS_WI_ERROR_2203               12203
#define IDS_WI_ERROR_2204               12204
#define IDS_WI_ERROR_2205               12205
#define IDS_WI_ERROR_2206               12206
#define IDS_WI_ERROR_2207               12207
#define IDS_WI_ERROR_2208               12208
#define IDS_WI_ERROR_2209               12209
#define IDS_WI_ERROR_2210               12210
#define IDS_WI_ERROR_2211               12211
#define IDS_WI_ERROR_2212               12212
#define IDS_WI_ERROR_2213               12213
#define IDS_WI_ERROR_2214               12214
#define IDS_WI_ERROR_2215               12215
#define IDS_WI_ERROR_2216               12216
#define IDS_WI_ERROR_2217               12217
#define IDS_WI_ERROR_2218               12218
#define IDS_WI_ERROR_2219               12219
#define IDS_WI_ERROR_2220               12220
#define IDS_WI_ERROR_2221               12221
#define IDS_WI_ERROR_2222               12222
#define IDS_WI_ERROR_2223               12223
#define IDS_WI_ERROR_2224               12224
#define IDS_WI_ERROR_2225               12225
#define IDS_WI_ERROR_2226               12226
#define IDS_WI_ERROR_2227               12227
#define IDS_WI_ERROR_2228               12228
#define IDS_WI_ERROR_2229               12229
#define IDS_WI_ERROR_2230               12230
#define IDS_WI_ERROR_2231               12231
#define IDS_WI_ERROR_2232               12232
#define IDS_WI_ERROR_2233               12233
#define IDS_WI_ERROR_2234               12234
#define IDS_WI_ERROR_2235               12235
#define IDS_WI_ERROR_2236               12236
#define IDS_WI_ERROR_2237               12237
#define IDS_WI_ERROR_2238               12238
#define IDS_WI_ERROR_2239               12239
#define IDS_WI_ERROR_2240               12240
#define IDS_WI_ERROR_2241               12241
#define IDS_WI_ERROR_2242               12242
#define IDS_WI_ERROR_2243               12243
#define IDS_WI_ERROR_2244               12244
#define IDS_WI_ERROR_2245               12245
#define IDS_WI_ERROR_2246               12246
#define IDS_WI_ERROR_2247               12247
#define IDS_WI_ERROR_2248               12248
#define IDS_WI_ERROR_2249               12249
#define IDS_WI_ERROR_2250               12250
#define IDS_WI_ERROR_2251               12251
#define IDS_WI_ERROR_2252               12252
#define IDS_WI_ERROR_2253               12253
#define IDS_WI_ERROR_2254               12254
#define IDS_WI_ERROR_2255               12255
#define IDS_WI_ERROR_2256               12256
#define IDS_WI_ERROR_2257               12257
#define IDS_WI_ERROR_2258               12258
#define IDS_WI_ERROR_2259               12259
#define IDS_WI_ERROR_2260               12260
#define IDS_WI_ERROR_2261               12261
#define IDS_WI_ERROR_2262               12262
#define IDS_WI_ERROR_2263               12263
#define IDS_WI_ERROR_2264               12264
#define IDS_WI_ERROR_2265               12265
#define IDS_WI_ERROR_2266               12266
#define IDS_WI_ERROR_2267               12267
#define IDS_WI_ERROR_2268               12268
#define IDS_WI_ERROR_2269               12269
#define IDS_WI_ERROR_2270               12270
#define IDS_WI_ERROR_2271               12271
#define IDS_WI_ERROR_2272               12272
#define IDS_WI_ERROR_2273               12273
#define IDS_WI_ERROR_2274               12274
#define IDS_WI_ERROR_2275               12275
#define IDS_WI_ERROR_2276               12276
#define IDS_WI_ERROR_2277               12277
#define IDS_WI_ERROR_2278               12278
#define IDS_WI_ERROR_2279               12279
#define IDS_WI_ERROR_2280               12280
#define IDS_WI_ERROR_2281               12281
#define IDS_WI_ERROR_2282               12282
#define IDS_WI_ERROR_2283               12283
#define IDS_WI_ERROR_2284               12284
#define IDS_WI_ERROR_2285               12285
#define IDS_WI_ERROR_2286               12286
#define IDS_WI_ERROR_2287               12287
#define IDS_WI_ERROR_2288               12288
#define IDS_WI_ERROR_2289               12289
#define IDS_WI_ERROR_2290               12290
#define IDS_WI_ERROR_2291               12291
#define IDS_WI_ERROR_2292               12292
#define IDS_WI_ERROR_2293               12293
#define IDS_WI_ERROR_2294               12294
#define IDS_WI_ERROR_2295               12295
#define IDS_WI_ERROR_2296               12296
#define IDS_WI_ERROR_2297               12297
#define IDS_WI_ERROR_2298               12298
#define IDS_WI_ERROR_2299               12299
#define IDS_WI_ERROR_2300               12300
#define IDS_WI_ERROR_2301               12301
#define IDS_WI_ERROR_2302               12302
#define IDS_WI_ERROR_2303               12303
#define IDS_WI_ERROR_2304               12304
#define IDS_WI_ERROR_2305               12305
#define IDS_WI_ERROR_2306               12306
#define IDS_WI_ERROR_2307               12307
#define IDS_WI_ERROR_2308               12308
#define IDS_WI_ERROR_2309               12309
#define IDS_WI_ERROR_2310               12310
#define IDS_WI_ERROR_2311               12311
#define IDS_WI_ERROR_2312               12312
#define IDS_WI_ERROR_2313               12313
#define IDS_WI_ERROR_2314               12314
#define IDS_WI_ERROR_2315               12315
#define IDS_WI_ERROR_2316               12316
#define IDS_WI_ERROR_2317               12317
#define IDS_WI_ERROR_2318               12318
#define IDS_WI_ERROR_2319               12319
#define IDS_WI_ERROR_2320               12320
#define IDS_WI_ERROR_2321               12321
#define IDS_WI_ERROR_2322               12322
#define IDS_WI_ERROR_2323               12323
#define IDS_WI_ERROR_2324               12324
#define IDS_WI_ERROR_2325               12325
#define IDS_WI_ERROR_2326               12326
#define IDS_WI_ERROR_2327               12327
#define IDS_WI_ERROR_2328               12328
#define IDS_WI_ERROR_2329               12329
#define IDS_WI_ERROR_2330               12330
#define IDS_WI_ERROR_2331               12331
#define IDS_WI_ERROR_2332               12332
#define IDS_WI_ERROR_2333               12333
#define IDS_WI_ERROR_2334               12334
#define IDS_WI_ERROR_2335               12335
#define IDS_WI_ERROR_2336               12336
#define IDS_WI_ERROR_2337               12337
#define IDS_WI_ERROR_2338               12338
#define IDS_WI_ERROR_2339               12339
#define IDS_WI_ERROR_2340               12340
#define IDS_WI_ERROR_2341               12341
#define IDS_WI_ERROR_2342               12342
#define IDS_WI_ERROR_2343               12343
#define IDS_WI_ERROR_2344               12344
#define IDS_WI_ERROR_2345               12345
#define IDS_WI_ERROR_2346               12346
#define IDS_WI_ERROR_2347               12347
#define IDS_WI_ERROR_2348               12348
#define IDS_WI_ERROR_2349               12349
#define IDS_WI_ERROR_2350               12350
#define IDS_WI_ERROR_2351               12351
#define IDS_WI_ERROR_2352               12352
#define IDS_WI_ERROR_2353               12353
#define IDS_WI_ERROR_2354               12354
#define IDS_WI_ERROR_2355               12355
#define IDS_WI_ERROR_2356               12356
#define IDS_WI_ERROR_2357               12357
#define IDS_WI_ERROR_2358               12358
#define IDS_WI_ERROR_2359               12359
#define IDS_WI_ERROR_2360               12360
#define IDS_WI_ERROR_2361               12361
#define IDS_WI_ERROR_2362               12362
#define IDS_WI_ERROR_2363               12363
#define IDS_WI_ERROR_2364               12364
#define IDS_WI_ERROR_2365               12365
#define IDS_WI_ERROR_2366               12366
#define IDS_WI_ERROR_2367               12367
#define IDS_WI_ERROR_2368               12368
#define IDS_WI_ERROR_2369               12369
#define IDS_WI_ERROR_2370               12370
#define IDS_WI_ERROR_2371               12371
#define IDS_WI_ERROR_2372               12372
#define IDS_WI_ERROR_2373               12373
#define IDS_WI_ERROR_2374               12374
#define IDS_WI_ERROR_2375               12375
#define IDS_WI_ERROR_2376               12376
#define IDS_WI_ERROR_2377               12377
#define IDS_WI_ERROR_2378               12378
#define IDS_WI_ERROR_2379               12379
#define IDS_WI_ERROR_2380               12380
#define IDS_WI_ERROR_2381               12381
#define IDS_WI_ERROR_2382               12382
#define IDS_WI_ERROR_2383               12383
#define IDS_WI_ERROR_2384               12384
#define IDS_WI_ERROR_2385               12385
#define IDS_WI_ERROR_2386               12386
#define IDS_WI_ERROR_2387               12387
#define IDS_WI_ERROR_2388               12388
#define IDS_WI_ERROR_2389               12389
#define IDS_WI_ERROR_2390               12390
#define IDS_WI_ERROR_2391               12391
#define IDS_WI_ERROR_2392               12392
#define IDS_WI_ERROR_2393               12393
#define IDS_WI_ERROR_2394               12394
#define IDS_WI_ERROR_2395               12395
#define IDS_WI_ERROR_2396               12396
#define IDS_WI_ERROR_2397               12397
#define IDS_WI_ERROR_2398               12398
#define IDS_WI_ERROR_2399               12399
#define IDS_WI_ERROR_2400               12400
#define IDS_WI_ERROR_2401               12401
#define IDS_WI_ERROR_2402               12402
#define IDS_WI_ERROR_2403               12403
#define IDS_WI_ERROR_2404               12404
#define IDS_WI_ERROR_2405               12405
#define IDS_WI_ERROR_2406               12406
#define IDS_WI_ERROR_2407               12407
#define IDS_WI_ERROR_2408               12408
#define IDS_WI_ERROR_2409               12409
#define IDS_WI_ERROR_2410               12410
#define IDS_WI_ERROR_2411               12411
#define IDS_WI_ERROR_2412               12412
#define IDS_WI_ERROR_2413               12413
#define IDS_WI_ERROR_2414               12414
#define IDS_WI_ERROR_2415               12415
#define IDS_WI_ERROR_2416               12416
#define IDS_WI_ERROR_2417               12417
#define IDS_WI_ERROR_2418               12418
#define IDS_WI_ERROR_2419               12419
#define IDS_WI_ERROR_2420               12420
#define IDS_WI_ERROR_2421               12421
#define IDS_WI_ERROR_2422               12422
#define IDS_WI_ERROR_2423               12423
#define IDS_WI_ERROR_2424               12424
#define IDS_WI_ERROR_2425               12425
#define IDS_WI_ERROR_2426               12426
#define IDS_WI_ERROR_2427               12427
#define IDS_WI_ERROR_2428               12428
#define IDS_WI_ERROR_2429               12429
#define IDS_WI_ERROR_2430               12430
#define IDS_WI_ERROR_2431               12431
#define IDS_WI_ERROR_2432               12432
#define IDS_WI_ERROR_2433               12433
#define IDS_WI_ERROR_2434               12434
#define IDS_WI_ERROR_2435               12435
#define IDS_WI_ERROR_2436               12436
#define IDS_WI_ERROR_2437               12437
#define IDS_WI_ERROR_2438               12438
#define IDS_WI_ERROR_2439               12439
#define IDS_WI_ERROR_2440               12440
#define IDS_WI_ERROR_2441               12441
#define IDS_WI_ERROR_2442               12442
#define IDS_WI_ERROR_2443               12443
#define IDS_WI_ERROR_2444               12444
#define IDS_WI_ERROR_2445               12445
#define IDS_WI_ERROR_2446               12446
#define IDS_WI_ERROR_2447               12447
#define IDS_WI_ERROR_2448               12448
#define IDS_WI_ERROR_2449               12449
#define IDS_WI_ERROR_2450               12450
#define IDS_WI_ERROR_2451               12451
#define IDS_WI_ERROR_2452               12452
#define IDS_WI_ERROR_2453               12453
#define IDS_WI_ERROR_2454               12454
#define IDS_WI_ERROR_2455               12455
#define IDS_WI_ERROR_2456               12456
#define IDS_WI_ERROR_2457               12457
#define IDS_WI_ERROR_2458               12458
#define IDS_WI_ERROR_2459               12459
#define IDS_WI_ERROR_2460               12460
#define IDS_WI_ERROR_2461               12461
#define IDS_WI_ERROR_2462               12462
#define IDS_WI_ERROR_2463               12463
#define IDS_WI_ERROR_2464               12464
#define IDS_WI_ERROR_2465               12465
#define IDS_WI_ERROR_2466               12466
#define IDS_WI_ERROR_2467               12467
#define IDS_WI_ERROR_2468               12468
#define IDS_WI_ERROR_2469               12469
#define IDS_WI_ERROR_2470               12470
#define IDS_WI_ERROR_2471               12471
#define IDS_WI_ERROR_2472               12472
#define IDS_WI_ERROR_2473               12473
#define IDS_WI_ERROR_2474               12474
#define IDS_WI_ERROR_2475               12475
#define IDS_WI_ERROR_2476               12476
#define IDS_WI_ERROR_2477               12477
#define IDS_WI_ERROR_2478               12478
#define IDS_WI_ERROR_2479               12479
#define IDS_WI_ERROR_2480               12480
#define IDS_WI_ERROR_2481               12481
#define IDS_WI_ERROR_2482               12482
#define IDS_WI_ERROR_2483               12483
#define IDS_WI_ERROR_2484               12484
#define IDS_WI_ERROR_2485               12485
#define IDS_WI_ERROR_2486               12486
#define IDS_WI_ERROR_2487               12487
#define IDS_WI_ERROR_2488               12488
#define IDS_WI_ERROR_2489               12489
#define IDS_WI_ERROR_2490               12490
#define IDS_WI_ERROR_2491               12491
#define IDS_WI_ERROR_2492               12492
#define IDS_WI_ERROR_2493               12493
#define IDS_WI_ERROR_2494               12494
#define IDS_WI_ERROR_2495               12495
#define IDS_WI_ERROR_2496               12496
#define IDS_WI_ERROR_2497               12497
#define IDS_WI_ERROR_2498               12498
#define IDS_WI_ERROR_2499               12499
#define IDS_WI_ERROR_2500               12500
#define IDS_WI_ERROR_2501               12501
#define IDS_WI_ERROR_2502               12502
#define IDS_WI_ERROR_2503               12503
#define IDS_WI_ERROR_2504               12504
#define IDS_WI_ERROR_2505               12505
#define IDS_WI_ERROR_2506               12506
#define IDS_WI_ERROR_2507               12507
#define IDS_WI_ERROR_2508               12508
#define IDS_WI_ERROR_2509               12509
#define IDS_WI_ERROR_2510               12510
#define IDS_WI_ERROR_2511               12511
#define IDS_WI_ERROR_2512               12512
#define IDS_WI_ERROR_2513               12513
#define IDS_WI_ERROR_2514               12514
#define IDS_WI_ERROR_2515               12515
#define IDS_WI_ERROR_2516               12516
#define IDS_WI_ERROR_2517               12517
#define IDS_WI_ERROR_2518               12518
#define IDS_WI_ERROR_2519               12519
#define IDS_WI_ERROR_2520               12520
#define IDS_WI_ERROR_2521               12521
#define IDS_WI_ERROR_2522               12522
#define IDS_WI_ERROR_2523               12523
#define IDS_WI_ERROR_2524               12524
#define IDS_WI_ERROR_2525               12525
#define IDS_WI_ERROR_2526               12526
#define IDS_WI_ERROR_2527               12527
#define IDS_WI_ERROR_2528               12528
#define IDS_WI_ERROR_2529               12529
#define IDS_WI_ERROR_2530               12530
#define IDS_WI_ERROR_2531               12531
#define IDS_WI_ERROR_2532               12532
#define IDS_WI_ERROR_2533               12533
#define IDS_WI_ERROR_2534               12534
#define IDS_WI_ERROR_2535               12535
#define IDS_WI_ERROR_2536               12536
#define IDS_WI_ERROR_2537               12537
#define IDS_WI_ERROR_2538               12538
#define IDS_WI_ERROR_2539               12539
#define IDS_WI_ERROR_2540               12540
#define IDS_WI_ERROR_2541               12541
#define IDS_WI_ERROR_2542               12542
#define IDS_WI_ERROR_2543               12543
#define IDS_WI_ERROR_2544               12544
#define IDS_WI_ERROR_2545               12545
#define IDS_WI_ERROR_2546               12546
#define IDS_WI_ERROR_2547               12547
#define IDS_WI_ERROR_2548               12548
#define IDS_WI_ERROR_2549               12549
#define IDS_WI_ERROR_2550               12550
#define IDS_WI_ERROR_2551               12551
#define IDS_WI_ERROR_2552               12552
#define IDS_WI_ERROR_2553               12553
#define IDS_WI_ERROR_2554               12554
#define IDS_WI_ERROR_2555               12555
#define IDS_WI_ERROR_2556               12556
#define IDS_WI_ERROR_2557               12557
#define IDS_WI_ERROR_2558               12558
#define IDS_WI_ERROR_2559               12559
#define IDS_WI_ERROR_2560               12560
#define IDS_WI_ERROR_2561               12561
#define IDS_WI_ERROR_2562               12562
#define IDS_WI_ERROR_2563               12563
#define IDS_WI_ERROR_2564               12564
#define IDS_WI_ERROR_2565               12565
#define IDS_WI_ERROR_2566               12566
#define IDS_WI_ERROR_2567               12567
#define IDS_WI_ERROR_2568               12568
#define IDS_WI_ERROR_2569               12569
#define IDS_WI_ERROR_2570               12570
#define IDS_WI_ERROR_2571               12571
#define IDS_WI_ERROR_2572               12572
#define IDS_WI_ERROR_2573               12573
#define IDS_WI_ERROR_2574               12574
#define IDS_WI_ERROR_2575               12575
#define IDS_WI_ERROR_2576               12576
#define IDS_WI_ERROR_2577               12577
#define IDS_WI_ERROR_2578               12578
#define IDS_WI_ERROR_2579               12579
#define IDS_WI_ERROR_2580               12580
#define IDS_WI_ERROR_2581               12581
#define IDS_WI_ERROR_2582               12582
#define IDS_WI_ERROR_2583               12583
#define IDS_WI_ERROR_2584               12584
#define IDS_WI_ERROR_2585               12585
#define IDS_WI_ERROR_2586               12586
#define IDS_WI_ERROR_2587               12587
#define IDS_WI_ERROR_2588               12588
#define IDS_WI_ERROR_2589               12589
#define IDS_WI_ERROR_2590               12590
#define IDS_WI_ERROR_2591               12591
#define IDS_WI_ERROR_2592               12592
#define IDS_WI_ERROR_2593               12593
#define IDS_WI_ERROR_2594               12594
#define IDS_WI_ERROR_2595               12595
#define IDS_WI_ERROR_2596               12596
#define IDS_WI_ERROR_2597               12597
#define IDS_WI_ERROR_2598               12598
#define IDS_WI_ERROR_2599               12599
#define IDS_WI_ERROR_2600               12600
#define IDS_WI_ERROR_2601               12601
#define IDS_WI_ERROR_2602               12602
#define IDS_WI_ERROR_2603               12603
#define IDS_WI_ERROR_2604               12604
#define IDS_WI_ERROR_2605               12605
#define IDS_WI_ERROR_2606               12606
#define IDS_WI_ERROR_2607               12607
#define IDS_WI_ERROR_2608               12608
#define IDS_WI_ERROR_2609               12609
#define IDS_WI_ERROR_2610               12610
#define IDS_WI_ERROR_2611               12611
#define IDS_WI_ERROR_2612               12612
#define IDS_WI_ERROR_2613               12613
#define IDS_WI_ERROR_2614               12614
#define IDS_WI_ERROR_2615               12615
#define IDS_WI_ERROR_2616               12616
#define IDS_WI_ERROR_2617               12617
#define IDS_WI_ERROR_2618               12618
#define IDS_WI_ERROR_2619               12619
#define IDS_WI_ERROR_2620               12620
#define IDS_WI_ERROR_2621               12621
#define IDS_WI_ERROR_2622               12622
#define IDS_WI_ERROR_2623               12623
#define IDS_WI_ERROR_2624               12624
#define IDS_WI_ERROR_2625               12625
#define IDS_WI_ERROR_2626               12626
#define IDS_WI_ERROR_2627               12627
#define IDS_WI_ERROR_2628               12628
#define IDS_WI_ERROR_2629               12629
#define IDS_WI_ERROR_2630               12630
#define IDS_WI_ERROR_2631               12631
#define IDS_WI_ERROR_2632               12632
#define IDS_WI_ERROR_2633               12633
#define IDS_WI_ERROR_2634               12634
#define IDS_WI_ERROR_2635               12635
#define IDS_WI_ERROR_2636               12636
#define IDS_WI_ERROR_2637               12637
#define IDS_WI_ERROR_2638               12638
#define IDS_WI_ERROR_2639               12639
#define IDS_WI_ERROR_2640               12640
#define IDS_WI_ERROR_2641               12641
#define IDS_WI_ERROR_2642               12642
#define IDS_WI_ERROR_2643               12643
#define IDS_WI_ERROR_2644               12644
#define IDS_WI_ERROR_2645               12645
#define IDS_WI_ERROR_2646               12646
#define IDS_WI_ERROR_2647               12647
#define IDS_WI_ERROR_2648               12648
#define IDS_WI_ERROR_2649               12649
#define IDS_WI_ERROR_2650               12650
#define IDS_WI_ERROR_2651               12651
#define IDS_WI_ERROR_2652               12652
#define IDS_WI_ERROR_2653               12653
#define IDS_WI_ERROR_2654               12654
#define IDS_WI_ERROR_2655               12655
#define IDS_WI_ERROR_2656               12656
#define IDS_WI_ERROR_2657               12657
#define IDS_WI_ERROR_2658               12658
#define IDS_WI_ERROR_2659               12659
#define IDS_WI_ERROR_2660               12660
#define IDS_WI_ERROR_2661               12661
#define IDS_WI_ERROR_2662               12662
#define IDS_WI_ERROR_2663               12663
#define IDS_WI_ERROR_2664               12664
#define IDS_WI_ERROR_2665               12665
#define IDS_WI_ERROR_2666               12666
#define IDS_WI_ERROR_2667               12667
#define IDS_WI_ERROR_2668               12668
#define IDS_WI_ERROR_2669               12669
#define IDS_WI_ERROR_2670               12670
#define IDS_WI_ERROR_2671               12671
#define IDS_WI_ERROR_2672               12672
#define IDS_WI_ERROR_2673               12673
#define IDS_WI_ERROR_2674               12674
#define IDS_WI_ERROR_2675               12675
#define IDS_WI_ERROR_2676               12676
#define IDS_WI_ERROR_2677               12677
#define IDS_WI_ERROR_2678               12678
#define IDS_WI_ERROR_2679               12679
#define IDS_WI_ERROR_2680               12680
#define IDS_WI_ERROR_2681               12681
#define IDS_WI_ERROR_2682               12682
#define IDS_WI_ERROR_2683               12683
#define IDS_WI_ERROR_2684               12684
#define IDS_WI_ERROR_2685               12685
#define IDS_WI_ERROR_2686               12686
#define IDS_WI_ERROR_2687               12687
#define IDS_WI_ERROR_2688               12688
#define IDS_WI_ERROR_2689               12689
#define IDS_WI_ERROR_2690               12690
#define IDS_WI_ERROR_2691               12691
#define IDS_WI_ERROR_2692               12692
#define IDS_WI_ERROR_2693               12693
#define IDS_WI_ERROR_2694               12694
#define IDS_WI_ERROR_2695               12695
#define IDS_WI_ERROR_2696               12696
#define IDS_WI_ERROR_2697               12697
#define IDS_WI_ERROR_2698               12698
#define IDS_WI_ERROR_2699               12699
#define IDS_WI_ERROR_2700               12700
#define IDS_WI_ERROR_2701               12701
#define IDS_WI_ERROR_2702               12702
#define IDS_WI_ERROR_2703               12703
#define IDS_WI_ERROR_2704               12704
#define IDS_WI_ERROR_2705               12705
#define IDS_WI_ERROR_2706               12706
#define IDS_WI_ERROR_2707               12707
#define IDS_WI_ERROR_2708               12708
#define IDS_WI_ERROR_2709               12709
#define IDS_WI_ERROR_2710               12710
#define IDS_WI_ERROR_2711               12711
#define IDS_WI_ERROR_2712               12712
#define IDS_WI_ERROR_2713               12713
#define IDS_WI_ERROR_2714               12714
#define IDS_WI_ERROR_2715               12715
#define IDS_WI_ERROR_2716               12716
#define IDS_WI_ERROR_2717               12717
#define IDS_WI_ERROR_2718               12718
#define IDS_WI_ERROR_2719               12719
#define IDS_WI_ERROR_2720               12720
#define IDS_WI_ERROR_2721               12721
#define IDS_WI_ERROR_2722               12722
#define IDS_WI_ERROR_2723               12723
#define IDS_WI_ERROR_2724               12724
#define IDS_WI_ERROR_2725               12725
#define IDS_WI_ERROR_2726               12726
#define IDS_WI_ERROR_2727               12727
#define IDS_WI_ERROR_2728               12728
#define IDS_WI_ERROR_2729               12729
#define IDS_WI_ERROR_2730               12730
#define IDS_WI_ERROR_2731               12731
#define IDS_WI_ERROR_2732               12732
#define IDS_WI_ERROR_2733               12733
#define IDS_WI_ERROR_2734               12734
#define IDS_WI_ERROR_2735               12735
#define IDS_WI_ERROR_2736               12736
#define IDS_WI_ERROR_2737               12737
#define IDS_WI_ERROR_2738               12738
#define IDS_WI_ERROR_2739               12739
#define IDS_WI_ERROR_2740               12740
#define IDS_WI_ERROR_2741               12741
#define IDS_WI_ERROR_2742               12742
#define IDS_WI_ERROR_2743               12743
#define IDS_WI_ERROR_2744               12744
#define IDS_WI_ERROR_2745               12745
#define IDS_WI_ERROR_2746               12746
#define IDS_WI_ERROR_2747               12747
#define IDS_WI_ERROR_2748               12748
#define IDS_WI_ERROR_2749               12749
#define IDS_WI_ERROR_2750               12750
#define IDS_WI_ERROR_2751               12751
#define IDS_WI_ERROR_2752               12752
#define IDS_WI_ERROR_2753               12753
#define IDS_WI_ERROR_2754               12754
#define IDS_WI_ERROR_2755               12755
#define IDS_WI_ERROR_2756               12756
#define IDS_WI_ERROR_2757               12757
#define IDS_WI_ERROR_2758               12758
#define IDS_WI_ERROR_2759               12759
#define IDS_WI_ERROR_2760               12760
#define IDS_WI_ERROR_2761               12761
#define IDS_WI_ERROR_2762               12762
#define IDS_WI_ERROR_2763               12763
#define IDS_WI_ERROR_2764               12764
#define IDS_WI_ERROR_2765               12765
#define IDS_WI_ERROR_2766               12766
#define IDS_WI_ERROR_2767               12767
#define IDS_WI_ERROR_2768               12768
#define IDS_WI_ERROR_2769               12769
#define IDS_WI_ERROR_2770               12770
#define IDS_WI_ERROR_2771               12771
#define IDS_WI_ERROR_2772               12772
#define IDS_WI_ERROR_2773               12773
#define IDS_WI_ERROR_2774               12774
#define IDS_WI_ERROR_2775               12775
#define IDS_WI_ERROR_2776               12776
#define IDS_WI_ERROR_2777               12777
#define IDS_WI_ERROR_2778               12778
#define IDS_WI_ERROR_2779               12779
#define IDS_WI_ERROR_2780               12780
#define IDS_WI_ERROR_2781               12781
#define IDS_WI_ERROR_2782               12782
#define IDS_WI_ERROR_2783               12783
#define IDS_WI_ERROR_2784               12784
#define IDS_WI_ERROR_2785               12785
#define IDS_WI_ERROR_2786               12786
#define IDS_WI_ERROR_2787               12787
#define IDS_WI_ERROR_2788               12788
#define IDS_WI_ERROR_2789               12789
#define IDS_WI_ERROR_2790               12790
#define IDS_WI_ERROR_2791               12791
#define IDS_WI_ERROR_2792               12792
#define IDS_WI_ERROR_2793               12793
#define IDS_WI_ERROR_2794               12794
#define IDS_WI_ERROR_2795               12795
#define IDS_WI_ERROR_2796               12796
#define IDS_WI_ERROR_2797               12797
#define IDS_WI_ERROR_2798               12798
#define IDS_WI_ERROR_2799               12799
#define IDS_WI_ERROR_2800               12800
#define IDS_WI_ERROR_2801               12801
#define IDS_WI_ERROR_2802               12802
#define IDS_WI_ERROR_2803               12803
#define IDS_WI_ERROR_2804               12804
#define IDS_WI_ERROR_2805               12805
#define IDS_WI_ERROR_2806               12806
#define IDS_WI_ERROR_2807               12807
#define IDS_WI_ERROR_2808               12808
#define IDS_WI_ERROR_2809               12809
#define IDS_WI_ERROR_2810               12810
#define IDS_WI_ERROR_2811               12811
#define IDS_WI_ERROR_2812               12812
#define IDS_WI_ERROR_2813               12813
#define IDS_WI_ERROR_2814               12814
#define IDS_WI_ERROR_2815               12815
#define IDS_WI_ERROR_2816               12816
#define IDS_WI_ERROR_2817               12817
#define IDS_WI_ERROR_2818               12818
#define IDS_WI_ERROR_2819               12819
#define IDS_WI_ERROR_2820               12820
#define IDS_WI_ERROR_2821               12821
#define IDS_WI_ERROR_2822               12822
#define IDS_WI_ERROR_2823               12823
#define IDS_WI_ERROR_2824               12824
#define IDS_WI_ERROR_2825               12825
#define IDS_WI_ERROR_2826               12826
#define IDS_WI_ERROR_2827               12827
#define IDS_WI_ERROR_2828               12828
#define IDS_WI_ERROR_2829               12829
#define IDS_WI_ERROR_2830               12830
#define IDS_WI_ERROR_2831               12831
#define IDS_WI_ERROR_2832               12832
#define IDS_WI_ERROR_2833               12833
#define IDS_WI_ERROR_2834               12834
#define IDS_WI_ERROR_2835               12835
#define IDS_WI_ERROR_2836               12836
#define IDS_WI_ERROR_2837               12837
#define IDS_WI_ERROR_2838               12838
#define IDS_WI_ERROR_2839               12839
#define IDS_WI_ERROR_2840               12840
#define IDS_WI_ERROR_2841               12841
#define IDS_WI_ERROR_2842               12842
#define IDS_WI_ERROR_2843               12843
#define IDS_WI_ERROR_2844               12844
#define IDS_WI_ERROR_2845               12845
#define IDS_WI_ERROR_2846               12846
#define IDS_WI_ERROR_2847               12847
#define IDS_WI_ERROR_2848               12848
#define IDS_WI_ERROR_2849               12849
#define IDS_WI_ERROR_2850               12850
#define IDS_WI_ERROR_2851               12851
#define IDS_WI_ERROR_2852               12852
#define IDS_WI_ERROR_2853               12853
#define IDS_WI_ERROR_2854               12854
#define IDS_WI_ERROR_2855               12855
#define IDS_WI_ERROR_2856               12856
#define IDS_WI_ERROR_2857               12857
#define IDS_WI_ERROR_2858               12858
#define IDS_WI_ERROR_2859               12859
#define IDS_WI_ERROR_2860               12860
#define IDS_WI_ERROR_2861               12861
#define IDS_WI_ERROR_2862               12862
#define IDS_WI_ERROR_2863               12863
#define IDS_WI_ERROR_2864               12864
#define IDS_WI_ERROR_2865               12865
#define IDS_WI_ERROR_2866               12866
#define IDS_WI_ERROR_2867               12867
#define IDS_WI_ERROR_2868               12868
#define IDS_WI_ERROR_2869               12869
#define IDS_WI_ERROR_2870               12870
#define IDS_WI_ERROR_2871               12871
#define IDS_WI_ERROR_2872               12872
#define IDS_WI_ERROR_2873               12873
#define IDS_WI_ERROR_2874               12874
#define IDS_WI_ERROR_2875               12875
#define IDS_WI_ERROR_2876               12876
#define IDS_WI_ERROR_2877               12877
#define IDS_WI_ERROR_2878               12878
#define IDS_WI_ERROR_2879               12879
#define IDS_WI_ERROR_2880               12880
#define IDS_WI_ERROR_2881               12881
#define IDS_WI_ERROR_2882               12882
#define IDS_WI_ERROR_2883               12883
#define IDS_WI_ERROR_2884               12884
#define IDS_WI_ERROR_2885               12885
#define IDS_WI_ERROR_2886               12886
#define IDS_WI_ERROR_2887               12887
#define IDS_WI_ERROR_2888               12888
#define IDS_WI_ERROR_2889               12889
#define IDS_WI_ERROR_2890               12890
#define IDS_WI_ERROR_2891               12891
#define IDS_WI_ERROR_2892               12892
#define IDS_WI_ERROR_2893               12893
#define IDS_WI_ERROR_2894               12894
#define IDS_WI_ERROR_2895               12895
#define IDS_WI_ERROR_2896               12896
#define IDS_WI_ERROR_2897               12897
#define IDS_WI_ERROR_2898               12898
#define IDS_WI_ERROR_2899               12899
#define IDS_WI_ERROR_2900               12900
#define IDS_WI_ERROR_2901               12901
#define IDS_WI_ERROR_2902               12902
#define IDS_WI_ERROR_2903               12903
#define IDS_WI_ERROR_2904               12904
#define IDS_WI_ERROR_2905               12905
#define IDS_WI_ERROR_2906               12906
#define IDS_WI_ERROR_2907               12907
#define IDS_WI_ERROR_2908               12908
#define IDS_WI_ERROR_2909               12909
#define IDS_WI_ERROR_2910               12910
#define IDS_WI_ERROR_2911               12911
#define IDS_WI_ERROR_2912               12912
#define IDS_WI_ERROR_2913               12913
#define IDS_WI_ERROR_2914               12914
#define IDS_WI_ERROR_2915               12915
#define IDS_WI_ERROR_2916               12916
#define IDS_WI_ERROR_2917               12917
#define IDS_WI_ERROR_2918               12918
#define IDS_WI_ERROR_2919               12919
#define IDS_WI_ERROR_2920               12920
#define IDS_WI_ERROR_2921               12921
#define IDS_WI_ERROR_2922               12922
#define IDS_WI_ERROR_2923               12923
#define IDS_WI_ERROR_2924               12924
#define IDS_WI_ERROR_2925               12925
#define IDS_WI_ERROR_2926               12926
#define IDS_WI_ERROR_2927               12927
#define IDS_WI_ERROR_2928               12928
#define IDS_WI_ERROR_2929               12929
#define IDS_WI_ERROR_2930               12930
#define IDS_WI_ERROR_2931               12931
#define IDS_WI_ERROR_2932               12932
#define IDS_WI_ERROR_2933               12933
#define IDS_WI_ERROR_2934               12934
#define IDS_WI_ERROR_2935               12935
#define IDS_WI_ERROR_2936               12936
#define IDS_WI_ERROR_2937               12937
#define IDS_WI_ERROR_2938               12938
#define IDS_WI_ERROR_2939               12939
#define IDS_WI_ERROR_2940               12940
#define IDS_WI_ERROR_2941               12941
#define IDS_WI_ERROR_2942               12942
#define IDS_WI_ERROR_2943               12943
#define IDS_WI_ERROR_2944               12944
#define IDS_WI_ERROR_2945               12945
#define IDS_WI_ERROR_2946               12946
#define IDS_WI_ERROR_2947               12947
#define IDS_WI_ERROR_2948               12948
#define IDS_WI_ERROR_2949               12949
#define IDS_WI_ERROR_2950               12950
#define IDS_WI_ERROR_2951               12951
#define IDS_WI_ERROR_2952               12952
#define IDS_WI_ERROR_2953               12953
#define IDS_WI_ERROR_2954               12954
#define IDS_WI_ERROR_2955               12955
#define IDS_WI_ERROR_2956               12956
#define IDS_WI_ERROR_2957               12957
#define IDS_WI_ERROR_2958               12958
#define IDS_WI_ERROR_2959               12959
#define IDS_WI_ERROR_2960               12960
#define IDS_WI_ERROR_2961               12961
#define IDS_WI_ERROR_2962               12962
#define IDS_WI_ERROR_2963               12963
#define IDS_WI_ERROR_2964               12964
#define IDS_WI_ERROR_2965               12965
#define IDS_WI_ERROR_2966               12966
#define IDS_WI_ERROR_2967               12967
#define IDS_WI_ERROR_2968               12968
#define IDS_WI_ERROR_2969               12969
#define IDS_WI_ERROR_2970               12970
#define IDS_WI_ERROR_2971               12971
#define IDS_WI_ERROR_2972               12972
#define IDS_WI_ERROR_2973               12973
#define IDS_WI_ERROR_2974               12974
#define IDS_WI_ERROR_2975               12975
#define IDS_WI_ERROR_2976               12976
#define IDS_WI_ERROR_2977               12977
#define IDS_WI_ERROR_2978               12978
#define IDS_WI_ERROR_2979               12979
#define IDS_WI_ERROR_2980               12980
#define IDS_WI_ERROR_2981               12981
#define IDS_WI_ERROR_2982               12982
#define IDS_WI_ERROR_2983               12983
#define IDS_WI_ERROR_2984               12984
#define IDS_WI_ERROR_2985               12985
#define IDS_WI_ERROR_2986               12986
#define IDS_WI_ERROR_2987               12987
#define IDS_WI_ERROR_2988               12988
#define IDS_WI_ERROR_2989               12989
#define IDS_WI_ERROR_2990               12990
#define IDS_WI_ERROR_2991               12991
#define IDS_WI_ERROR_2992               12992
#define IDS_WI_ERROR_2993               12993
#define IDS_WI_ERROR_2994               12994
#define IDS_WI_ERROR_2995               12995
#define IDS_WI_ERROR_2996               12996
#define IDS_WI_ERROR_2997               12997
#define IDS_WI_ERROR_2998               12998
#define IDS_WI_ERROR_2999               12999
#define ID_OPERATIONS_SHOWPROPERTIES    32771
#define ID_OPERATIONS_SHOWSTATES        32772
#define ID_OPERATIONS_SHOWPOLICIES      32773
#define ID_OPERATIONS_GENERATEHTMLOUTPUT 32774
#define ID_OPERATIONS_OPTIONS           32776

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        146
#define _APS_NEXT_COMMAND_VALUE         32777
#define _APS_NEXT_CONTROL_VALUE         1086
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\util.cpp ===
#include "stdafx.h"
#include "util.h"

#define LOG_BUF_READ_SIZE 8192

BOOL ANSICheck(char *firstline, BOOL *bIsUnicodeLog)
{
	BOOL bRet = FALSE;

	char *UnicodePos = NULL;
	char *ANSIPos = NULL;

	UnicodePos = strstr(firstline, "UNICODE");
	ANSIPos = strstr(firstline, "ANSI");
	if (UnicodePos)
	{
	   *bIsUnicodeLog = TRUE;
		bRet = TRUE;
	}
	else if (ANSIPos)
	{
        *bIsUnicodeLog = FALSE;
		bRet = TRUE;
	}

	return bRet;
}


BOOL UnicodeCheck(WCHAR *firstline, BOOL *bIsUnicodeLog)
{
  BOOL bRet = FALSE;

  char ansibuffer[LOG_BUF_READ_SIZE+1];
  const int HalfBufSize = LOG_BUF_READ_SIZE/2;

  int iRet = WideCharToMultiByte(CP_ACP, 0, firstline, HalfBufSize, ansibuffer, LOG_BUF_READ_SIZE, NULL, NULL);
  if (iRet)
  {
	  bRet = ANSICheck(ansibuffer, bIsUnicodeLog);
  }

  return bRet;
}

#define BYTE_ORDER_MARK 0xFEFF

//make decision if passed text is unicode...
BOOL BOMCheck(WCHAR *firstline, BOOL *bIsUnicodeLog)
{
  if (firstline && (*firstline == BYTE_ORDER_MARK))
     *bIsUnicodeLog = TRUE;
  else
     *bIsUnicodeLog = FALSE;

  return TRUE;
}


BOOL DetermineLogType(CString &cstrLogFileName, BOOL *bIsUnicodeLog)
{
	BOOL bRet = FALSE;

	FILE *fptr;
	fptr = fopen(cstrLogFileName, "r");
	if (fptr)
	{
		char firstline[LOG_BUF_READ_SIZE];
		char *pos;

		pos = fgets(firstline, LOG_BUF_READ_SIZE, fptr);
		if (pos)
		{
//we could do this instead of calling the ANSICheck and UnicodeCheck functions below...
//			bRet = BOMCheck((WCHAR*)firstline, bIsUnicodeLog);

			bRet = ANSICheck(firstline, bIsUnicodeLog);
			if (!bRet) //ANSI checking failed, try to check by reading in UNICODE...
			{
				fclose(fptr);
				fptr = fopen(cstrLogFileName, "rb");
				if (fptr)
				{
					WCHAR widebuffer[LOG_BUF_READ_SIZE/2];
					WCHAR *wpos;
                    wpos = fgetws(widebuffer, LOG_BUF_READ_SIZE/2, fptr);
					if (wpos)
					{
						bRet = UnicodeCheck(widebuffer, bIsUnicodeLog);
						if (!bRet) //could not find UNICODE or ANSI in log, try something else...
                           bRet = BOMCheck(widebuffer, bIsUnicodeLog);  
					}
					//else, read failed...

					fclose(fptr);
					fptr = NULL;
				}
				//else open failed...
			}
		}
		//else, read failed!
		if (fptr)
           fclose(fptr);
	}
	else
	{
	    CString cstr;
		cstr.Format("Unexpected error reading file %s.  GetLastError = %x", cstrLogFileName, GetLastError());

	    if (!g_bRunningInQuietMode)
		{
		   AfxMessageBox(cstr);
		}
	}

	return bRet;
}

//move to util.cpp
BOOL StripLineFeeds(char *szString)
{
	BOOL bRet = FALSE;
	int iLen = strlen(szString);

	char *lpszFound = strstr(szString, "\r");
	if (lpszFound)
	{
	   int iPos;
	   iPos = lpszFound - szString;
	   if (iPos >= iLen-2) //at the end???
	   {
		  //strip it off dude...
		  *lpszFound = '\0';
		  bRet = TRUE;
	   }
	}

	lpszFound = strstr(szString, "\n");
	if (lpszFound)
	{
	   int iPos;
	   iPos = lpszFound - szString;
	   if (iPos >= iLen-2) //at the end???
	   {
		  //strip it off dude...
		  *lpszFound = '\0';
		  bRet = TRUE;
	   }
	}

	return bRet;
}

//#include "Dbghelp.h"

//5-4-2001
BOOL IsValidDirectory(CString cstrDir)
{
  BOOL bRet;

  //do the create dir and test...
  bRet = CreateDirectory(cstrDir, NULL);
  if (!bRet)
  {
     DWORD dwErr, dwPrevErr;
     dwPrevErr = dwErr = GetLastError();

	 if (ERROR_DISK_FULL == dwErr)
	 {
		 //TODO...
		 //handle this messed up case...
//		 bRet = MakeSureDirectoryPathExists(cstrDir);
	 }

//5-9-2001, fix for Win9x!
     if (!bRet && (ERROR_ALREADY_EXISTS == dwPrevErr)) //no error really...
     {	 
	    if (g_bNT) //do some extra checks...
		{
		   SetLastError(NO_ERROR);
//5-9-2001

           DWORD dwAccess = GENERIC_READ | GENERIC_WRITE;
		   DWORD dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
		   DWORD dwCreate = OPEN_EXISTING;
	       DWORD dwFlags = FILE_FLAG_BACKUP_SEMANTICS;
  
		   HANDLE hFile = CreateFile(cstrDir, dwAccess, dwShare, 0, dwCreate, dwFlags, NULL);
		   if (hFile == INVALID_HANDLE_VALUE)
		   {
	          dwErr = GetLastError();
              if (ERROR_ALREADY_EXISTS == dwErr) //no error really...
			  {
		         bRet = TRUE;
			  }
		   }
		   else
		   {
		      bRet = TRUE;
		      CloseHandle(hFile);
		   }
		}
		else
		{
		   bRet = TRUE; //5-9-2001, Win9x, assume it is ok 
		}
	 }
  }

  return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\wilogutl.h ===
// wilogutl.h : main header file for the SHOWINSTALLLOGS application
//

#if !defined(AFX_SHOWINSTALLLOGS_H__EEC979FD_C301_48B5_BE22_D4C5CEE50166__INCLUDED_)
#define AFX_SHOWINSTALLLOGS_H__EEC979FD_C301_48B5_BE22_D4C5CEE50166__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "wilogres.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CWILogUtilApp:
// See wilogutl.cpp for the implementation of this class
//

class CWILogUtilApp : public CWinApp
{
public:
	CWILogUtilApp();

	CString GetOutputDirectory()
	{
       return m_cstrOutputDirectory;
	}

	CString GetIgnoredErrors()
	{
	   return m_cstrIgnoredErrors;
	}

	void SetIgnoredErrors(CString &cstrErrors)
	{
	   m_cstrIgnoredErrors = cstrErrors;
	}
	

	void SetOutputDirectory(CString &cstrOut)
	{
       m_cstrOutputDirectory = cstrOut;
	}

    BOOL GetUserColorSettings(CArray<COLORREF, COLORREF> &outColors)
	{
		BOOL bRet = FALSE;
		int iArraySize = m_arColors.GetSize();

        if (iArraySize)
		{
			bRet = TRUE;

			COLORREF col;
			outColors.RemoveAll();
 			for (int i=0; i < iArraySize; i++)
			{
				col = m_arColors.GetAt(i);
				outColors.Add(col);
			}
		}

		return bRet;
	}

	BOOL SetUserColorSettings(CArray<COLORREF, COLORREF> &inColors)
	{
		BOOL bRet = FALSE;
		int iArraySize = inColors.GetSize();

        if (iArraySize)
		{
			bRet = TRUE;

			COLORREF col;
			m_arColors.RemoveAll();
 			for (int i=0; i < iArraySize; i++)
			{
				col = inColors.GetAt(i);
				m_arColors.Add(col);
			}
		}

		return bRet;
	}

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWILogUtilApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CWILogUtilApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
   BOOL DoCommandLine();

   BOOL    m_bBadExceptionHit; 

   CString m_cstrOutputDirectory;
   CString m_cstrIgnoredErrors;

   CArray <COLORREF, COLORREF> m_arColors;
   struct HTMLColorSettings UserSettings;
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHOWINSTALLLOGS_H__EEC979FD_C301_48B5_BE22_D4C5CEE50166__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\wilogutl\wilogutl.cpp ===
// wilogutl.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "wilogutl.h"
#include "showlogd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWILogUtilApp

BEGIN_MESSAGE_MAP(CWILogUtilApp, CWinApp)
	//{{AFX_MSG_MAP(CWILogUtilApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWILogUtilApp construction

CWILogUtilApp::CWILogUtilApp()
{
	m_cstrOutputDirectory = g_szDefaultOutputLogDir;
	m_bBadExceptionHit = FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWILogUtilApp object

CWILogUtilApp theApp;

BOOL DoesFileExist(CString &cstrLogFileName)
{
	BOOL bRet = FALSE;

	if (!cstrLogFileName.IsEmpty())
	{
       FILE *fptr;
	   fptr = fopen(cstrLogFileName, "r");
	   if (fptr)
	   {
		  bRet = TRUE;

		  fclose(fptr);
	   }
	}

	return bRet;
}



BOOL DoLogFile(char *szLine,
			   char *szLogFileName)
{
	BOOL bRet = FALSE;

    szLine++; //skip /
    szLine++; //skip l
 
    if (szLine[0] == ' ')
    {
       szLine++; //skip space
	}

	char *lpszMSILogFileNameFound;
	lpszMSILogFileNameFound = strstr(szLine, "/");
	if (lpszMSILogFileNameFound)
	{
	    int nBytesCopy = lpszMSILogFileNameFound - szLine - 1; //-1 is for "/" string
		if ((nBytesCopy > 0) && (nBytesCopy < MAX_PATH))
		{
           strncpy(szLogFileName, szLine, nBytesCopy);
           szLogFileName[nBytesCopy] = '\0';

		   bRet = TRUE;
		}
		else
		   bRet = FALSE; //buffer too small...
	}
	else //must be last one passed or commandline was invalid....
	{
		strcpy(szLogFileName, szLine);
		bRet = TRUE;
	}

	return bRet;
}

//nmanis, 5-4-2001
BOOL DoOutputDir(char *szLine,
			     char *szOutDirName)
{
	BOOL bRet = FALSE;

    szLine++; //skip /
    szLine++; //skip l
 
    if (szLine[0] == ' ')
    {
       szLine++; //skip space
	}

	char *lpszOutDirFound;
	lpszOutDirFound= strstr(szLine, "/");
	if (lpszOutDirFound)
	{
	    int nBytesCopy = lpszOutDirFound - szLine - 1; //-1 is for "/" string
		if ((nBytesCopy > 0) && (nBytesCopy < MAX_PATH))
		{
           strncpy(szOutDirName, szLine, nBytesCopy);
           szOutDirName[nBytesCopy] = '\0';

		   bRet = TRUE;
		}
		else
		   bRet = FALSE; //buffer too small...
	}
	else //must be last one passed or commandline was invalid....
	{
		strcpy(szOutDirName, szLine);
		bRet = TRUE;
	}

	return bRet;
}
//end nmanis, 5-4-2001
				 
//5-9-2001
#define CMD_OK                  0
#define BAD_OUTPUT_DIR          1
#define BAD_LOGFILE_NAME        2
#define MISSING_LOG_SWITCH      3
#define MISSING_QUIET_SWITCH    4

int g_iBadCmdRet = CMD_OK;
char g_szCmdError[5][256] = { "No Error", "Bad output directory specified", 
"Bad log file name specified", "Missing required switch /l for the log file name",
"Missing required switch /q for quiet mode" }; 

//returns CMD_OK if no error
//returns BAD_OUTPUT_DIR   if bad dir, non-existant
//returns BAD_LOGFILE_NAME if bad log file, non-existant
//returns MISSING_REQUIRED_SWITCH if invalid switches, missing required switch /q, /Q or /l, /L
int CWILogUtilApp::DoCommandLine()
{
	int  iRet = CMD_OK;
	BOOL bRet = TRUE;
	BOOL bLogFound = FALSE;

	char szLogFileName[MAX_PATH];
	char szOutDir[MAX_PATH];

	char *lpszCmdLine = GetCommandLine();
    if (lpszCmdLine)
    {
//5-16-2001
	   char *lpszPSSModeOn;
       lpszPSSModeOn = strstr(lpszCmdLine, "/v");
	   if (lpszPSSModeOn)
	   {
          g_bShowEverything = TRUE;
	   }

       lpszPSSModeOn = strstr(lpszCmdLine, "/V");
	   if (lpszPSSModeOn)
	   {
          g_bShowEverything = TRUE;
	   }
//end 5-16-2001

	   char *lpszQuiteMode;
       lpszQuiteMode = strstr(lpszCmdLine, "/q");
	   if (lpszQuiteMode)
	   {
          g_bRunningInQuietMode = TRUE;
	   }

	   lpszQuiteMode = strstr(lpszCmdLine, "/Q");
	   if (lpszQuiteMode)
          g_bRunningInQuietMode = TRUE;

       char *lpszMSILogFilePassed;
	   lpszMSILogFilePassed = strstr(lpszCmdLine, "/l");
	   if (lpszMSILogFilePassed)
	      bLogFound = DoLogFile(lpszMSILogFilePassed, szLogFileName);

	   if (!bLogFound)
	   {
	      lpszMSILogFilePassed = strstr(lpszCmdLine, "/L");
          if (lpszMSILogFilePassed)
             bLogFound = DoLogFile(lpszMSILogFilePassed, szLogFileName);
	   }

	   if (bLogFound)
	   {
		  CString cstrFile;
		  cstrFile = szLogFileName;
		  cstrFile.TrimRight(); //clean up any trailing spaces...
		  cstrFile.TrimLeft();  //clean up any leading spaces...

		  char szQuote[2];
		  szQuote[0] = '"';
		  szQuote[1] = '\0';

		  cstrFile.TrimRight(szQuote); //clean up any trailing quotes...
		  cstrFile.TrimLeft(szQuote); //clean up any leading quotes...

		  char szShortPath[MAX_PATH];
		  DWORD dwRet = GetShortPathName(cstrFile, szShortPath, MAX_PATH);
		  if (dwRet)
		  {
			 //converted...
             cstrFile = szShortPath; //use the short path for the file...
		  }
			 
		  bRet = DoesFileExist(cstrFile);
		  if (bRet)
		  {
			 strcpy(g_szLogFileToParse, cstrFile.GetBuffer(MAX_PATH));
			 cstrFile.ReleaseBuffer();
		  }
		  else
		  {
			 //invalid log file passed, fail out...
			 iRet = BAD_LOGFILE_NAME; //5-9-2001
		  }
	   }
	   else //5-9-2001
	   {
		  if (g_bRunningInQuietMode) //only required if running in quiet mode...
             iRet = MISSING_LOG_SWITCH;
	   }

//nmanis, 5-4-2001, fixed Win9x bug on 5-9-2001
	   if (bRet && bLogFound && g_bRunningInQuietMode) //5-9-2001, well, before doing any optional work, make sure required worked first!
	   {
          char *lpszOutDirPassed;
	      BOOL bOutDirFound = FALSE;
	      lpszOutDirPassed = strstr(lpszCmdLine, "/o");
	      if (lpszOutDirPassed)
	         bOutDirFound = DoOutputDir(lpszOutDirPassed, szOutDir);

	      if (!bOutDirFound)
		  {
	         lpszOutDirPassed = strstr(lpszCmdLine, "/O");
             if (lpszOutDirPassed)
                bOutDirFound = DoOutputDir(lpszOutDirPassed, szOutDir);
		  }

	      if (bOutDirFound)
		  {
             int iLength = strlen(szOutDir);
			 if (iLength)
			 {
               if (szOutDir[iLength-1] != '\\') 
			   {
			 	  strcat(szOutDir, "\\");
			   }

		       bRet = IsValidDirectory(szOutDir);
		       if (bRet)
			   {
                  m_cstrOutputDirectory = szOutDir;
			   }
			   //else, //else, ignore log dir passed
			 }
			 //else, ignore log dir passed
		  }
	   }
//end nmanis, 5-4-2001, 5-9-2001
    }

	//5-9-2001
	//if a log was passed, but not quiet mode, well, it is incorrect
	if (!g_bRunningInQuietMode && bLogFound)
       iRet = MISSING_QUIET_SWITCH;	    

	return iRet;
}


#include "loganald.h"

/////////////////////////////////////////////////////////////////////////////
// CWILogUtilApp initialization
BOOL CWILogUtilApp::InitInstance()
{
    //handle all exceptions up to this point...
	try
	{
//nmanis, do the OS check early...
  	   OSVERSIONINFO ver = { 0 };

	   ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	   GetVersionEx(&ver);
	   if (VER_PLATFORM_WIN32_NT == ver.dwPlatformId)
          g_bNT = TRUE;

  	   int nResponse;

//nmanis, no Ax controls means leaner .EXE...
// 	   AfxEnableControlContainer();

	   SetRegistryKey(_T("PSS"));
	   InitHTMLColorSettings(UserSettings); //initial settings for program...

	   CString strValue;
	   CString strRet;
	   UINT    nValue;

       //read in the colors dude, reading/writing with strings as friggin' MFC GetProfileInt can not handle larger values (> 32767)
	   for (int i=0; i < MAX_HTML_LOG_COLORS; i++)
	   {
	 	   strValue.Format("%d", UserSettings.settings[i].value);

		   strRet = GetProfileString("Settings", UserSettings.settings[i].name, strValue);

           nValue = atoi(strRet);//convert to a int
		   this->m_arColors.Add(nValue);
	   }

	   m_cstrOutputDirectory = GetProfileString("Settings", "OutputDir", g_szDefaultOutputLogDir);
	   m_cstrIgnoredErrors = GetProfileString("Settings", "IgnoredErrors", g_szDefaultIgnoredErrors);

//5-9-2001
	   g_iBadCmdRet = DoCommandLine();
	   if (g_iBadCmdRet != CMD_OK)
	   { 
		  CString str;
		  str.Format("WILogUtil.EXE: Invalid command line passed to executable. Return error %d.  %s\n",  g_iBadCmdRet, g_szCmdError[ g_iBadCmdRet]);

          //invalid command line passed to executable, could be bad parameters...
		  OutputDebugString(str);
		  return FALSE;
	   }
//end 5-9-2001

	   if (!g_bRunningInQuietMode)
	   {
  	      COpenDlg dlg;
	      m_pMainWnd = &dlg;

          nResponse = dlg.DoModal();
	      if (nResponse == IDOK)
		  {
		  }
	      else if (nResponse == IDCANCEL)
		  {
		  }
	   }
	   else
	   {
		     //5-17-2001, don't show error messages in quiet mode via gui...
             SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);

			 CString strFile;
			 strFile = g_szLogFileToParse;

		     CLogAnalyzeDlg dlg;

             dlg.SetLogfileLocation(strFile);
			 dlg.AnalyzeLog();
	   }
	}
	catch(...)
	{
       if (!g_bRunningInQuietMode)
	   {
          AfxMessageBox("Unhandled exception in program.  Program will now close.");
	   }

	   //got exception somehow, catch it!
	   m_bBadExceptionHit = TRUE;
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}


int CWILogUtilApp::ExitInstance() 
{
	int iSize = m_arColors.GetSize();

	if (!m_bBadExceptionHit && (iSize == MAX_HTML_LOG_COLORS) && 
		!g_bRunningInQuietMode)  //don't let quiet command line override the GUI settings...
	{
       CString strValue;
	   UINT    nValue;
	   BOOL    bRet;

       //read in the colors dude...
       for (int i=0; i < MAX_HTML_LOG_COLORS; i++)
	   {
		 nValue = m_arColors.GetAt(i);
	 	 strValue.Format("%d", nValue); //format as a string...

		 bRet = WriteProfileString("Settings", UserSettings.settings[i].name, strValue);
	   }

       bRet = WriteProfileString("Settings", "OutputDir", m_cstrOutputDirectory);

//5-4-2001
	   //write out ignored errors to registry as well...
	   bRet = WriteProfileString("Settings", "IgnoredErrors", m_cstrIgnoredErrors);
//5-4-2001
	}

//5-9-2001
	int iRet;
	iRet = CWinApp::ExitInstance();

	if (g_iBadCmdRet)
       iRet = g_iBadCmdRet;

	return iRet;
//end 5-9-2001
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\commandopt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       CommandOpt.h
//
//    This file contains the implementation of CommandOpt class 
//--------------------------------------------------------------------------

#include "CommandOpt.h"

void
CommandOpt::PrintUsage()
{
	/* Issue: format */
    _ftprintf(stderr, 
		TEXT("Usage: wmi <options> -i WIML_File SKU_Filter \n"));
    _ftprintf(stderr, 
		TEXT("Converts a setup package written in WIML to MSI packages\n"));
    _ftprintf(stderr, 
		TEXT("Options are:\n"));
    _ftprintf(stderr, 
		TEXT("\t-c           Validation only\n"));
    _ftprintf(stderr, 
		TEXT("\t-v           Verbose mode\n"));
    _ftprintf(stderr, 
		TEXT("\t-l Log_File  Output written into specified file\n"));
    _ftprintf(stderr, 
		TEXT("\n"));
}

UINT
CommandOpt::ParseCommandOptions(int argc, TCHAR *argv[])
{
	int i;

	if (1 == argc)
	{
		PrintUsage();
		return ERROR_BAD_ARGUMENTS;
	}

    for (i = 1; i < argc; i++)
    {
        LPTSTR arg = argv[i];
        if (arg[0] == TEXT('-'))
        {
            switch (arg[1])
            {
            case 'c': 
			case 'C'://Issue: 
                m_bValidation = true;
#ifdef DEBUG
				_tprintf(TEXT("Validation Only\n"));
#endif
                break;
            case 'v':
			case 'V':
                m_bVerbose = true;
#ifdef DEBUG
				_tprintf(TEXT("Verbose mode\n"));
#endif
                break;
            case 'l':
			case 'L':
                if ( (m_pLogFile = _tfopen(argv[++i], TEXT("a"))) == NULL)
				{
					_tprintf(
						TEXT("Error: Unable to open specified log file: %s"), 
									argv[i]);
					return ERROR_FILE_NOT_FOUND;
				}
#ifdef DEBUG
				_tprintf(TEXT("Log file name: %s\n"), argv[i]);
#endif
                break;
            case 'i':
			case 'I':
                 m_szURL= argv[++i];
#ifdef DEBUG
				_tprintf(TEXT("WIML file name: %s\n"), argv[i]);
#endif
                break;
			default:
				_tprintf(TEXT("Error: unrecognized option -%c\n"), arg[1]);
				PrintUsage();
				return ERROR_BAD_ARGUMENTS;
            }
        }
		// This is a command-line SKU filter.
        else 
        {
			if (m_szInputSkuFilter != NULL)
			{
				_tprintf(TEXT("Error: only one Sku Filter is allowed\n"));
				return ERROR_BAD_ARGUMENTS;
			}
			m_szInputSkuFilter = arg;

#ifdef DEBUG
			_tprintf(TEXT("SKU filter from command line: %s\n"), 
								m_szInputSkuFilter);
#endif			
        }
    }

	if (NULL == m_szURL) 
	{
		_tprintf(
			TEXT("Error: Please specify the URL of the input package\n"));
		return ERROR_BAD_ARGUMENTS;
	}

	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\commandopt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       CommandOpt.h
//
//    This file contains the definition of CommandOpt class 
//--------------------------------------------------------------------------

#ifndef XMSI_COMMANDOPT_H
#define XMSI_COMMANDOPT_H

#include <Windows.h>
#include <tchar.h>
#include <stdio.h>

class CommandOpt {
public:
	CommandOpt():m_bValidation(false),m_bVerbose(false),m_pLogFile(NULL),
				 m_szURL(NULL), m_szInputSkuFilter(NULL) {}

	~CommandOpt() 
	{
		if (m_pLogFile) fclose(m_pLogFile);
	}

	// Real work is done here
	UINT ParseCommandOptions(int argc, TCHAR *argv[]);
	
	// Print Usage
	void PrintUsage();

	// member access functions
	bool GetValidationMode() {return m_bValidation;}
	bool GetVerboseMode() {return m_bVerbose;}
	FILE *GetLogFile() {return m_pLogFile;}
	LPTSTR GetURL() {return m_szURL;}
	LPTSTR GetInputSkuFilter() {return m_szInputSkuFilter;}

private:
	bool m_bValidation;
	bool m_bVerbose;
	FILE *m_pLogFile;
	LPTSTR m_szURL;
	LPTSTR m_szInputSkuFilter;
};

#endif //XMSI_COMMANDOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\component.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       Component.cpp
//
//    This file contains the implementation of Component class 
//--------------------------------------------------------------------------

#include "wmc.h"

////////////////////////////////////////////////////////////////////////////
// Constructor: allocate memory for member variables
////////////////////////////////////////////////////////////////////////////
Component::Component()
{
	m_pSkuSet = new SkuSet(g_cSkus);
	assert(m_pSkuSet);

	m_pSkuSetValuesFeatureUse = new SkuSetValues();
	assert(m_pSkuSetValuesFeatureUse);
	m_pSkuSetValuesFeatureUse->SetValType(STRING_LIST);

	for (int i=0; i<5; i++)
	{
		m_rgpSkuSetValuesOwnership[i] = new SkuSetValues();
		assert(m_rgpSkuSetValuesOwnership);
		m_rgpSkuSetValuesOwnership[i]->SetValType(FM_PAIR);
	}
	
	m_pSkuSetValuesKeyPath = new SkuSetValues();
	assert(m_pSkuSetValuesKeyPath);
	m_pSkuSetValuesKeyPath->SetValType(STRING);

}

////////////////////////////////////////////////////////////////////////////
// Destructor: release memory
////////////////////////////////////////////////////////////////////////////
Component::~Component()
{
	if (m_pSkuSet)
		delete m_pSkuSet;

	if (m_pSkuSetValuesFeatureUse)
		delete m_pSkuSetValuesFeatureUse;

	for (int i=0; i<5; i++)
	{
		if (m_rgpSkuSetValuesOwnership[i])
			delete m_rgpSkuSetValuesOwnership[i];
	}

	if (m_pSkuSetValuesKeyPath)
		delete m_pSkuSetValuesKeyPath;
}

////////////////////////////////////////////////////////////////////////////
// SetSkuSet: update the set of SKUs that will install this component
////////////////////////////////////////////////////////////////////////////
void 
Component::SetSkuSet(SkuSet *pSkuSet)
{
	assert(pSkuSet);

	assert(m_pSkuSet);
	*m_pSkuSet |= *pSkuSet;
}

////////////////////////////////////////////////////////////////////////////
// GetSkuSet: returns the set of SKUs that will install this component
//			  caller should free the value returned
////////////////////////////////////////////////////////////////////////////
SkuSet *
Component::GetSkuSet()
{
	SkuSet *pSkuSetRetVal = new SkuSet(g_cSkus);
	assert(pSkuSetRetVal);

	assert(m_pSkuSet);
	*pSkuSetRetVal = *m_pSkuSet;
	return pSkuSetRetVal;
}

// The function tells how to update the feature set
// the type of values stored in *pIsValOut and isValOld are both
// STRING_LIST; the type of value stored in isValNew is LPTSTR.
// In the function, the output value is essentailly a set of strings
// that include all the strings stored in the old value plus the string
// stored in the new value.
// the function doesn't destroy isValOld or isValNew
HRESULT UpdateFeatureSet(IntStringValue *pIsValOut, IntStringValue isValOld, 
						 IntStringValue isValNew)
{
	set<LPTSTR, Cstring_less>::iterator it;

	set<LPTSTR, Cstring_less> *pSetStringOut = 
		new set<LPTSTR, Cstring_less>;
	assert(pSetStringOut);

	set<LPTSTR, Cstring_less> *pSetStringOld = isValOld.pSetString;

	// copy the strings stored in isValOld to *pSetStringOut
	for(it = pSetStringOld->begin(); it != pSetStringOld->end(); ++it)
	{
		if (*it)
		{
			LPTSTR sz = _tcsdup(*it);
			assert(sz);
			pSetStringOut->insert(sz);
		}		
	}

	// make a copy of the string stored in the new value
	LPTSTR szNew = _tcsdup(isValNew.szVal);
	assert(szNew);
	// insert the new value
	pSetStringOut->insert(szNew);

	// return the built StringSet
	pIsValOut->pSetString = pSetStringOut;

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// SetUsedByFeature: Add the passed-in feature to the set of features that use
//                   this component for the specified SkuSet. 
//					 Caller should free the arguments
////////////////////////////////////////////////////////////////////////////
void 
Component::SetUsedByFeature(LPTSTR szFeature, SkuSet *pSkuSet)
{
	assert(pSkuSet);
	if (pSkuSet->testClear())
		return;

	// make a copy of arguments
	SkuSet *pSkuSetNew = new SkuSet(g_cSkus);
	assert(pSkuSetNew);
	*pSkuSetNew = *pSkuSet;

	LPTSTR sz = _tcsdup(szFeature);
	assert(sz);

	IntStringValue isValNew;
	isValNew.szVal = sz;

	// update the list that is holding the Features
	m_pSkuSetValuesFeatureUse->SplitInsert(pSkuSetNew, isValNew, UpdateFeatureSet);
}

////////////////////////////////////////////////////////////////////////////
// GetFeatureUse: return the list of Features that use this component via
//				  a SkuSetValues object
//				  Caller should NOT destroy the value returned since it 
//				  is just a pointer to the value stored inside this component
////////////////////////////////////////////////////////////////////////////
SkuSetValues *
Component::GetFeatureUse()
{
	return m_pSkuSetValuesFeatureUse;
}

// The function tells how to update the Ownership Info stored in a
// SkuSetValues object. The type of all the IsVals used are FM_PAIR -
// a pair of Feature and Module IDs. In the function, the module of the
// old value (module 1) is compared with the module of the new value
// (module 2).  whoever lies lower in the module tree wins, meaning that
// the feature associated with that module stays in the data structure,
// i.e., that feature has the corresponding ownership.
// the function doesn't destroy isValOld or isValNew
HRESULT UpdateOwnership(IntStringValue *pIsValOut, IntStringValue isValOld, 
						 IntStringValue isValNew)
{
	extern HRESULT CompareModuleRel(LPTSTR szModule1, LPTSTR szModule2, 
										int *iResult);

	HRESULT hr = S_OK;

	LPTSTR szModuleOld = (isValOld.pFOM)->szModule;
	LPTSTR szModuleNew = (isValNew.pFOM)->szModule;

	int iCmpResult = 0;
	// compare the relationship of the 2 modules in the module tree
	hr = CompareModuleRel(szModuleOld, szModuleNew, &iCmpResult);

	// checking for conflict of ownership claiming
	if (SUCCEEDED(hr) && (0 == iCmpResult))
	{
		_tprintf(TEXT("Compile Error: Ambiguous ownership claiming:\n\t"));
		_tprintf(TEXT("Feature %s claim ownership of Module %s\n\t"),
					(isValOld.pFOM)->szFeature, szModuleOld);
		_tprintf(TEXT("Feature %s claim ownership of Module %s\n\t"),
					(isValNew.pFOM)->szFeature, szModuleNew);
		hr = E_FAIL;
	}

	if (FAILED(hr)) return hr;

	FOM *pFOMOut = new FOM;

	// ModuleNew wins
	if (-1 == iCmpResult)
	{
		pFOMOut->szModule = _tcsdup(szModuleNew);
		assert(pFOMOut->szModule);
		pFOMOut->szFeature = _tcsdup((isValNew.pFOM)->szFeature);
		assert(pFOMOut->szFeature);
	}
	else if (1 == iCmpResult)
	{
		pFOMOut->szModule = _tcsdup(szModuleOld);
		assert(pFOMOut->szModule);
		pFOMOut->szFeature = _tcsdup((isValOld.pFOM)->szFeature);
		assert(pFOMOut->szFeature);
	}
	else
		// shouldn't happen
		assert(1);

	// return the built FOM
	pIsValOut->pFOM = pFOMOut;

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// SetOwnership: pSkuSetValuesOwnership contains the information of 5 types
//				 of ownerships in bitfields. This function checks the 
//				 bitfield and stores each type of ownership info in a 
//				 seperate SkuSetValus object
////////////////////////////////////////////////////////////////////////////
HRESULT 
Component::SetOwnership(FOM *pFOM, SkuSetValues *pSkuSetValuesOwnership)
{
	assert(pFOM && pSkuSetValuesOwnership);

	HRESULT hr = S_OK;
	SkuSetVal *pSkuSetValTemp = NULL;

	// loop through the passed in ownership info list
	for (pSkuSetValTemp =  pSkuSetValuesOwnership->Start();
		 pSkuSetValTemp != pSkuSetValuesOwnership->End();
		 pSkuSetValTemp =  pSkuSetValuesOwnership->Next())
	{
		assert(pSkuSetValTemp);
		int iOwnershipInfo = pSkuSetValTemp->isVal.intVal;

		for (int i=0; i<cAttrBits_TakeOwnership; i++)
		{
			// check for each type of ownership info
			if ( (iOwnershipInfo & rgAttrBits_TakeOwnership[i].uiBit)
					== rgAttrBits_TakeOwnership[i].uiBit)
			{
				// make a copy of the passed-in value and insert
				// into the SkuSetValues object for this particular
				// type of ownership info
				LPTSTR szFeatureNew = _tcsdup(pFOM->szFeature);
				assert(szFeatureNew);
				LPTSTR szModuleNew = _tcsdup(pFOM->szModule);
				assert(szModuleNew);
				FOM *pFOMNew = new FOM;
				assert(pFOMNew);
				pFOMNew->szFeature = szFeatureNew;
				pFOMNew->szModule = szModuleNew;

				SkuSet *pSkuSetNew = new SkuSet(g_cSkus);
				assert(pSkuSetNew);
				*pSkuSetNew = *(pSkuSetValTemp->pSkuSet);

				IntStringValue isValNew;
				isValNew.pFOM = pFOMNew;
				hr = m_rgpSkuSetValuesOwnership[i]->SplitInsert(pSkuSetNew,
																isValNew, 
															UpdateOwnership);
				if (FAILED(hr)) break;
			}
		}

		if (FAILED(hr)) break;
	}

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in Function: Component::SetOwnership\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// GetOwnership: given a NodeIndex specifying the type of ownership
//				 the function returns the ownership info of the specified
//				 SKUs via ppSkuSetValues
////////////////////////////////////////////////////////////////////////////
HRESULT
Component::GetOwnership(NodeIndex ni, SkuSet *pSkuSet,
						SkuSetValues **ppSkuSetValuesRetVal)
{
	assert(pSkuSet);
	if (pSkuSet->testClear())
		return S_FALSE;

	HRESULT hr = S_OK;

	// the index starts from OWNSHORTCUTS
	int iIndex = (int)ni - (int)OWNSHORTCUTS;

	hr = m_rgpSkuSetValuesOwnership[iIndex]->GetValueSkuSet(pSkuSet, 
													ppSkuSetValuesRetVal);

	// error: some SKUs don't have this ownership specified 
	if (FAILED(hr))
	{
		_tprintf(TEXT("don't have the ownership information for %s specified\n"),
				 rgXMSINodes[ni].szNodeName);
	}

	return hr;
}

// KeyPath cannot/shouldn't be updated. If this function is called, 
// there are more than one entities that are claiming to be KeyPath of 
// a Component in a SKU. Return E_FAIL to signal the error. 
HRESULT UpdateKeyPath(IntStringValue *pIsValOut, IntStringValue isValOld, 
						 IntStringValue isValNew)
{
	_tprintf(TEXT("Compile Error: multiple KeyPath specified \n"));
	return E_FAIL;
}


////////////////////////////////////////////////////////////////////////////
// SetKeyPath: set the KeyPath information for this component for the specified
//			   SKUs. 
////////////////////////////////////////////////////////////////////////////
HRESULT
Component::SetKeyPath(LPTSTR szKeyPath, SkuSet *pSkuSet)
{
	assert(pSkuSet);
	HRESULT hr = S_OK;
	if (pSkuSet->testClear())
		return S_FALSE;

	// make a copy of arguments
	SkuSet *pSkuSetNew = new SkuSet(g_cSkus);
	assert(pSkuSetNew);
	*pSkuSetNew = *pSkuSet;

	LPTSTR sz = _tcsdup(szKeyPath);
	assert(sz);

	IntStringValue isValNew;
	isValNew.szVal = sz;

	// update the list that is holding the KeyPath
	hr = m_pSkuSetValuesKeyPath->SplitInsert(pSkuSetNew, isValNew, 
											 UpdateKeyPath);

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// GetKeyPath: Retrieve the KeyPath information for this component for
//			   the specified SKUs.
////////////////////////////////////////////////////////////////////////////
HRESULT 
Component::GetKeyPath(SkuSet *pSkuSet, SkuSetValues **ppSkuSetValuesRetVal)
{ 
	assert(pSkuSet);
	if (pSkuSet->testClear())
		return S_FALSE;

	HRESULT hr = S_OK;

	hr = m_pSkuSetValuesKeyPath->GetValueSkuSet(pSkuSet, ppSkuSetValuesRetVal);

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Print: for debug purpose, print out the content (Features that use this
//		  Component; KeyPath; Ownership info) of this Component
////////////////////////////////////////////////////////////////////////////
void
Component::Print()
{
	_tprintf(TEXT("SkuSets:\n"));
	if (m_pSkuSet)
		m_pSkuSet->print();

	_tprintf(TEXT("Used by Feature:\n"));
	if (m_pSkuSetValuesFeatureUse)
		m_pSkuSetValuesFeatureUse->Print();

	_tprintf(TEXT("KeyPath: \n"));
	if (m_pSkuSetValuesKeyPath)
		m_pSkuSetValuesKeyPath->Print();

	for (int i=0; i<5; i++)
	{
		NodeIndex ni = (NodeIndex)(i+OWNSHORTCUTS);
		_tprintf(TEXT("%s\n"), rgXMSINodes[ni].szNodeName);
		if(m_rgpSkuSetValuesOwnership[i])
			m_rgpSkuSetValuesOwnership[i]->Print();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\component.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:     Component.h
// 
//    This file contains the definition of Class Component
//--------------------------------------------------------------------------


#ifndef XMSI_COMPONENT_H
#define XMSI_COMPONENT_H

#include <Windows.h>
#include <tchar.h>
#include <stdio.h>
#include "wmc.h"

using namespace std;

struct Cstring_less {
	 bool operator()(LPCTSTR p, LPCTSTR q) const { return _tcscmp(p, q)<0; }
};

class Component {
public:
	Component():m_setFeaturesUse(), m_szKeyPath(NULL){}

	~Component();
	
	bool UsedByFeature(LPTSTR szFeatureID);

	void SetUsedByFeature(LPTSTR szFeatureID);

	// member access functions
	LPTSTR GetKeyPath() {return m_szKeyPath;}
	void SetKeyPath(LPTSTR szKeyPath);

private:
	// store the ID of all the <Feature>s that use this component
	set<LPTSTR, Cstring_less> m_setFeaturesUse; 
	LPTSTR m_szKeyPath;
};

#endif //XMSI_COMMANDOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\componentfuncs.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       componentFuncs.cpp
//              This file contains the functions that process <Component>
//              and its subentities in the input package
//--------------------------------------------------------------------------

#include "componentFuncs.h"

////////////////////////////////////////////////////////////////////////////
// ProcessComponents:
//   This function is the root of the sub function tree corresponding to 
//	 process <Component> part. When this function is called from 
//   ProcessProductFamily, a list of component objects has been established,
//	 Starting from here, those components are processed one by one.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessComponents()
{
	HRESULT hr = S_OK;
	
	map<LPTSTR, Component *, Cstring_less>::iterator iter;

	// process the Component objects stored one by one
	for (iter = g_mapComponents.begin(); iter != g_mapComponents.end(); iter++)
	{
		LPTSTR szComponent = (*iter).first;

		// Process the set of Features that use this Component and insert
		// into FeatureComponents table
		SkuSetValues *pSkuSetValuesFeatures = NULL;
		Component *pComponent = (*iter).second;
		pSkuSetValuesFeatures = pComponent->GetFeatureUse();
		if (!pSkuSetValuesFeatures->Empty())
		{
			SkuSetVal *pSkuSetVal = NULL;
			for (pSkuSetVal = pSkuSetValuesFeatures->Start();
				 pSkuSetVal != pSkuSetValuesFeatures->End();
				 pSkuSetVal = pSkuSetValuesFeatures->Next())
			{
				SkuSet *pSkuSet = pSkuSetVal->pSkuSet;
				// create FeatureComponents table
				hr = CreateTable_SKU(TEXT("FeatureComponents"), pSkuSet);
				if (FAILED(hr)) break;
				// insert all the Features stored into DB
				set<LPTSTR, Cstring_less> *pSet = 
								(pSkuSetVal->isVal.pSetString);
				set<LPTSTR, Cstring_less>::iterator it;
				for (it = pSet->begin(); it != pSet->end(); it++)
				{
					LPTSTR szFeature = (*it);
					hr = InsertFeatureComponents(szFeature, szComponent,
												 pSkuSet, -1);
					if (FAILED(hr)) break;
				}
				if (FAILED(hr)) break;
			}
			if (FAILED(hr)) break;
		}

		// Call ProcessComponent to process all the subentities of 
		// this Component
		SkuSet *pSkuSet = pComponent->GetSkuSet();
		PIXMLDOMNode pNodeComponent = pComponent->m_pNodeComponent;
		hr = ProcessComponent(pNodeComponent, szComponent, pSkuSet);
		delete pSkuSet;
		if (FAILED(hr)) break;
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessComponents\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessComponent
//   This function process <Component> entity
//         1) insert into <FeatureComponents> table
//         2) Process all the subentities include <Files>
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessComponent(PIXMLDOMNode &pNodeComponent, LPTSTR szComponent, 
						 SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeComponent != NULL);

	SkuSetValues *pSkuSetValuesKeyPath = NULL;
	SkuSet skuSetCommon(g_cSkus); // the SkuSet that shars the common column 
								  // values

	// Values to be inserted into the DB 
	LPTSTR szComponentId = NULL;
	LPTSTR szDirectory_ = NULL;
	int iAttributes = MSI_NULL_INTEGER;
	LPTSTR szCondition = NULL;
	LPTSTR szKeyPath = NULL;

	// Construct an ElementEntry object. 
	ElementEntry *pEEComponent = new ElementEntry(5, pSkuSet);
	assert(pEEComponent);

	// send the Component ID down to children nodes
	IntStringValue isValInfo;
	isValInfo.szVal = szComponent;
	pEEComponent->m_isValInfo = isValInfo;

	hr = CreateTable_SKU(TEXT("Component"), pSkuSet);

	if (SUCCEEDED(hr))
	{
		// Call ProcessChildrenArray to get back column values of all SKUs 
		// via the ElementEntry object
		hr = ProcessChildrenArray_H_XIES(pNodeComponent, rgNodeFuncs_Component,
										 cNodeFuncs_Component, pEEComponent, 
										 pSkuSet);
	}

	// Process <CreateFolder>s
	// Issue: need to check for duplicate primary key <Dir, Com>
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, CREATEFOLDER, false,
									 isValInfo, ProcessCreateFolder, pSkuSet);

	// Process <File>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, XMSI_FILE,
									 false, isValInfo,
									 ProcessFile,
									 pSkuSet);

	// Process <MoveFile>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, MOVEFILE,
									 false, isValInfo,
									 ProcessMoveFile,
									 pSkuSet);

	// Process <RemoveFile>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, REMOVEFILE,
									 false, isValInfo,
									 ProcessRemoveFile,
									 pSkuSet);

	// Process <IniFile>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, INIFILE,
									 false, isValInfo,
									 ProcessIniFile,
									 pSkuSet);

	// Process <RemoveIniFile>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, REMOVEINIFILE,
									 false, isValInfo,
									 ProcessRemoveIniFile,
									 pSkuSet);

	// Process <Registry>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeComponent, XMSI_REGISTRY,
									 false, isValInfo,
									 ProcessRegistry,
									 pSkuSet);

	// Get KeyPath information
	if (SUCCEEDED(hr))
	{
		hr = g_mapComponents[szComponent]->GetKeyPath(pSkuSet, 
													  &pSkuSetValuesKeyPath);
		if (SUCCEEDED(hr))
		{
			hr = pEEComponent->SetValueSkuSetValues(pSkuSetValuesKeyPath, 5);
			if (pSkuSetValuesKeyPath)
				delete pSkuSetValuesKeyPath;
		}
		else
			_tprintf(TEXT(" don't have a KeyPath specified for Component %s\n"),
					 szComponent);
	}


	// Finalize the values stored in *pEE
	if (SUCCEEDED(hr))
		hr = pEEComponent->Finalize();

	// insert the values into the DB
	if (SUCCEEDED(hr))
	{
		// Process Common values first
		skuSetCommon = pEEComponent->GetCommonSkuSet();

		printf("Common Set:");
		skuSetCommon.print();

		if (!skuSetCommon.testClear())
		{
			szComponentId = pEEComponent->GetCommonValue(1).szVal;
			szDirectory_  = pEEComponent->GetCommonValue(2).szVal;
			iAttributes   = pEEComponent->GetCommonValue(3).intVal;
			szCondition   = pEEComponent->GetCommonValue(4).szVal;
			szKeyPath     = pEEComponent->GetCommonValue(5).szVal;

			// insert into DB
			hr = InsertComponent(szComponent, szComponentId, szDirectory_,
								 iAttributes, szCondition, szKeyPath,
								 &skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szComponentId = pEEComponent->GetValue(1,i).szVal;
					szDirectory_ = pEEComponent->GetValue(2,i).szVal;
					iAttributes = pEEComponent->GetValue(3,i).intVal;
					szCondition = pEEComponent->GetValue(4,i).szVal;
					szKeyPath = pEEComponent->GetValue(5,i).szVal;
			
					// insert into DB
					hr = InsertComponent(szComponent, szComponentId, 
										 szDirectory_, iAttributes, 
										 szCondition, szKeyPath, NULL, i);
				}
			}
		}
	}

	delete pEEComponent;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessComponent\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessGUID
//   This function:
//         1) Process <GUID> entity and put the value inside *pEE
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessGUID(PIXMLDOMNode &pNodeGUID, int iColumn, 
					ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeGUID != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeGUID)));
#endif

	// Get the value of the element.
	IntStringValue isValGUID;

	if (SUCCEEDED(hr = ProcessAttribute(pNodeGUID, 
										rgXMSINodes[XMSI_GUID].szAttributeName,
										STRING, &isValGUID, pSkuSet)))
	{
		if (NULL == isValGUID.szVal)
		{
			_tprintf(TEXT("Compile Error: Missing required attribute")
					 TEXT("\'%s\' of <%s>\n"), 
					 rgXMSINodes[XMSI_GUID].szAttributeName,
					 rgXMSINodes[XMSI_GUID].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			// Convert to all uppercase and add { }
			hr = FormatGUID(isValGUID.szVal);

			// insert the value into the ElementEntry.
			if (SUCCEEDED(hr))
				hr = pEE->SetValue(isValGUID, iColumn, pSkuSet);
		}
	}

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessGUID\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessComponentDir
//   This function:
//         1) Process <ComponentDir> entity and return its value via szVal
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessComponentDir(PIXMLDOMNode &pNodeComponentDir, int iColumn,  
							ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	int i = 0;

	assert(pNodeComponentDir != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeComponentDir)));
#endif

	LPTSTR szComponent = pEE->m_isValInfo.szVal;

	// Process Ref attribute
	hr = ProcessRefElement(pNodeComponentDir, iColumn, pEE, pSkuSet);

	// Process KeyPath attribute
	if (SUCCEEDED(hr))
		hr = ProcessKeyPath(pNodeComponentDir, szComponent, TEXT(""), 
							pSkuSet);

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessComponentDir\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: Process
// This function processes <ComponentAttributes> entity under <Component> 
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessComponentAttributes(PIXMLDOMNode &pNodeComponentAttributes, 
								   int iColumn, ElementEntry *pEE, 
								   SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeComponentAttributes != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeComponentAttributes)));
#endif

	// Process <RunFrom> child
	hr = ProcessEnumAttributes(pNodeComponentAttributes, FAVOR, 
							   rgEnumBits_RunFrom_Component,
							   cEnumBits_RunFrom_Component, pEE, iColumn, 
							   pSkuSet);

	// Process all on/off children elements
	if (SUCCEEDED(hr))
		hr = ProcessOnOffAttributes_SKU(pNodeComponentAttributes, 
										rgAttrBits_Component,
										cAttrBits_Component, pEE, iColumn,
										pSkuSet);
#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessComponentAttributes\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessCreateFolder
//   This function:
//         1) Process <CreateFolder> entity and insert the info into 
//			  the CreateFolder table
//		   2) Process children <LockPermission>s
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessCreateFolder(PIXMLDOMNode &pNodeCreateFolder,
							IntStringValue isVal, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeCreateFolder!=NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeCreateFolder)));
#endif
	
	LPTSTR szComponent = isVal.szVal;

	// create the CreateFolder table if necessary
	hr = CreateTable_SKU(TEXT("CreateFolder"), pSkuSet);

	if (FAILED(hr)) return hr;
	
	// get the Ref attribute 
	IntStringValue isValCreateFolder;
	isValCreateFolder.szVal = NULL;
	if (SUCCEEDED(hr = ProcessAttribute(pNodeCreateFolder,
							  		    rgXMSINodes[CREATEFOLDER].szAttributeName,
										STRING, &isValCreateFolder, pSkuSet)))
	{
		if (NULL == isValCreateFolder.szVal)
		{
			_tprintf(TEXT("Compile Error: Missing required attribute")
					 TEXT("\'%s\' of <%s>\n"), 
					 rgXMSINodes[CREATEFOLDER].szAttributeName,
					 rgXMSINodes[CREATEFOLDER].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			SkuSetValues *pSkuSetValuesRetVal = NULL;
			LPTSTR szRef = isValCreateFolder.szVal;

			// The dir referred should be in the data structure already
			assert(0 != g_mapDirectoryRefs_SKU.count(szRef));

			// return a list of <SkuSet, Directory> pairs
			hr = g_mapDirectoryRefs_SKU[szRef]->
								GetValueSkuSet(pSkuSet, &pSkuSetValuesRetVal);

			if (SUCCEEDED(hr))
			{
				// go over the list returned, get Directory value for each sub
				// SkuSets and insert into DB
				SkuSetVal *pSkuSetVal = NULL;
				for (pSkuSetVal = pSkuSetValuesRetVal->Start(); 
					 pSkuSetVal != pSkuSetValuesRetVal->End(); 
					 pSkuSetVal = pSkuSetValuesRetVal->Next())
				
				{
					LPTSTR szDir = pSkuSetVal->isVal.szVal;
					SkuSet *pSkuSetTemp = pSkuSetVal->pSkuSet;

					if (FAILED(hr = InsertCreateFolder(szDir, szComponent, 
													   pSkuSetTemp, -1)))
						break;
									
					// Process children <LockPermission>s
					// Issue: need to ensure there is no duplicate primary key
					//		  LockOjbect + Table + Domain + User
					IntStringValue isValLockPermission;
					TableLockObj *pTableLockObjTemp = new TableLockObj;
					pTableLockObjTemp->szLockObject = szDir;
					pTableLockObjTemp->szTable = TEXT("CreateFolder");
					isValLockPermission.pTableLockObj = pTableLockObjTemp;
					if (FAILED(hr = ProcessChildrenList_SKU(pNodeCreateFolder, 
															LOCKPERMISSION, 
															false,
															isValLockPermission, 
															ProcessLockPermission, 
															pSkuSetTemp)))
						break;

					delete pTableLockObjTemp;
				}

				if (pSkuSetValuesRetVal)
					delete pSkuSetValuesRetVal;

			}

			delete[] isValCreateFolder.szVal;
		}	
	}	



#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessCreateFolder\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessLockPermission
//   This function:
//         1) Process <LockPermission> node and insert into LockPermissions
//			  table;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessLockPermission(PIXMLDOMNode &pNodeLockPermission,
							IntStringValue isValLockPermission, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeLockPermission!=NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeLockPermission)));
#endif
	
	LPTSTR szLockObject = isValLockPermission.pTableLockObj->szLockObject;
	LPTSTR szTable = isValLockPermission.pTableLockObj->szTable;
	LPTSTR szUser = NULL;
	LPTSTR szDomain = NULL;
	int iPermission = MSI_NULL_INTEGER;

	// create the CreateFolder table if necessary
	if (FAILED(hr = CreateTable_SKU(TEXT("LockPermissions"), pSkuSet)))
		return hr;
	
	IntStringValue isValUser;
	isValUser.szVal = NULL;

	// get the User attribute (Required)
	if (SUCCEEDED(hr = ProcessAttribute(pNodeLockPermission,
							  		    TEXT("User"),
										STRING, &isValUser, pSkuSet)))
	{
		if (NULL == isValUser.szVal)
		{
			_tprintf(TEXT("Compile Error: Missing required attribute")
					 TEXT("\'%s\' of <%s>\n"), 
					 TEXT("User"),
					 rgXMSINodes[CREATEFOLDER].szNodeName);
			hr = E_FAIL;
		}
		else
			szUser = isValUser.szVal;
	}

	// get the Domain Attribute (Not Required)
	if (SUCCEEDED(hr))
	{
		IntStringValue isValDomain;
		isValDomain.szVal = NULL;
		hr = ProcessAttribute(pNodeLockPermission,TEXT("Domain"), STRING, 
						  &isValDomain, pSkuSet);
		szDomain = isValDomain.szVal;
	}

	// get the Permission attribute (Required)
	if (SUCCEEDED(hr))
	{
		IntStringValue isValPermission;
		isValPermission.szVal = NULL;
		if (SUCCEEDED(hr = ProcessAttribute(pNodeLockPermission, 
											TEXT("Permission"),
											INTEGER,
											&isValPermission, pSkuSet)))
		{
			if (MSI_NULL_INTEGER == isValPermission.intVal)
			{
				_tprintf(TEXT("Compile Error: Missing required attribute")
						 TEXT("\'%s\' of <%s>\n"), 
						 TEXT("Permission"),
						 rgXMSINodes[CREATEFOLDER].szNodeName);
				hr = E_FAIL;
			}
			else
				iPermission = isValPermission.intVal;
		}
	}

	// insert into the DB LockPermissions table
	if (SUCCEEDED(hr))
		hr = InsertLockPermissions(szLockObject, szTable, szDomain, szUser, 
								   iPermission, pSkuSet, -1);
#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessCreateFolder\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFile
//   This function:
//         1) Process all subentities of <File> include <FileName>, <FileSize>
//            <FileVersion>, <FileLanguage>, <FileAttributes>, <Font>,
//			  <BindImage>, <SelfReg>;
//         2) Insert into the File table;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFile(PIXMLDOMNode &pNodeFile, IntStringValue isValComponent,
					SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeFile != NULL);

	SkuSet skuSetCommon(g_cSkus); // the SkuSet that shars the common column 
								  // values

	// Values to be inserted into the DB 
	LPTSTR szFile		= NULL;
	LPTSTR szComponent  = isValComponent.szVal;
	LPTSTR szFileName   = NULL;
	UINT   uiFileSize   = NULL;
	LPTSTR szVersion    = NULL;
	LPTSTR szLanguage   = NULL;
	UINT   uiAttributes = MSI_NULL_INTEGER;

	// create the File DB table
	hr = CreateTable_SKU(TEXT("File"), pSkuSet);

	if (FAILED(hr))	return hr;

	// Construct an ElementEntry object. 
	ElementEntry *pEEFile = new ElementEntry(8, pSkuSet);
	assert(pEEFile);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeFile, TEXT("ID"), STRING, &isValID, pSkuSet);

	// if there is no ID specified, compiler generates one
	if (SUCCEEDED(hr))
	{
		if (!isValID.szVal)
		{
			isValID.szVal = GetName(TEXT("File"));
#ifdef DEBUG
			_tprintf(TEXT("Processing <File> with compiler generated ")
					 TEXT("primary key = %s\n"), isValID.szVal);
#endif
		}
		else
		{
#ifdef DEBUG
			_tprintf(TEXT("Processing <File ID=\"%s\">\n"), isValID.szVal);
#else
		;
#endif
		}
	}

	// at this point, a primary key should exist for this file
	szFile = isValID.szVal;
	assert(szFile);
	IntStringValue isValInfo;
	isValInfo.szVal = szFile;
	pEEFile->m_isValInfo = isValInfo;

	// insert the FileID - SkuSet relationship into the global data structure
	// so that the compiler can check whether a FileID reference is allowed
	// for any given SKU
	if (!g_mapFiles.count(szFile))
	{
		LPTSTR szFile_Map = _tcsdup(szFile);
		assert(szFile_Map);
		SkuSet *pSkuSet_Map = new SkuSet(g_cSkus);
		assert(pSkuSet_Map);
		*pSkuSet_Map = *pSkuSet;
		g_mapFiles.insert(LS_ValType(szFile_Map, pSkuSet_Map));
	}

	// Process KeyPath attribute
	if (SUCCEEDED(hr))
		hr = ProcessKeyPath(pNodeFile, szComponent, szFile, pSkuSet);


	// Call ProcessChildrenArray to get back column values of all SKUs 
	// via the ElementEntry object
	if (SUCCEEDED(hr))
		hr = ProcessChildrenArray_H_XIES(pNodeFile, rgNodeFuncs_File,
										 cNodeFuncs_File, pEEFile, 
										 pSkuSet);

	// Process children <LockPermission>s
	// Issue: need to ensure there is no duplicate primary key
	//		  LockOjbect + Table + Domain + User
	if (SUCCEEDED(hr))
	{
		IntStringValue isValLockPermission;
		TableLockObj *pTableLockObjTemp = new TableLockObj;
		pTableLockObjTemp->szLockObject = szFile;
		pTableLockObjTemp->szTable = TEXT("CreateFolder");
		isValLockPermission.pTableLockObj = pTableLockObjTemp;
		hr = ProcessChildrenList_SKU(pNodeFile, LOCKPERMISSION,
									false, isValLockPermission, 
									ProcessLockPermission, pSkuSet);
		delete pTableLockObjTemp;
	}
	
	// Finalize the values stored in *pEE
	if (SUCCEEDED(hr))
		hr = pEEFile->Finalize();

	if (SUCCEEDED(hr))
	{
		// Process Common values first
		skuSetCommon = pEEFile->GetCommonSkuSet();

		if (!skuSetCommon.testClear())
		{
			szFileName	 = pEEFile->GetCommonValue(1).szVal;
			uiFileSize	 = pEEFile->GetCommonValue(2).intVal;
			szVersion	 = pEEFile->GetCommonValue(3).szVal;
			szLanguage	 = pEEFile->GetCommonValue(4).szVal;
			uiAttributes = pEEFile->GetCommonValue(5).intVal;

			// insert into DB
			hr = InsertFile(szFile, szComponent, szFileName, uiFileSize,
							szVersion, szLanguage, uiAttributes,
							/*ISSUE: Sequence */ 1,
							&skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szFileName	 = pEEFile->GetValue(1, i).szVal;
					uiFileSize	 = pEEFile->GetValue(2, i).intVal;
					szVersion	 = pEEFile->GetValue(3, i).szVal;
					szLanguage	 = pEEFile->GetValue(4, i).szVal;
					uiAttributes = pEEFile->GetValue(5, i).intVal;
			
					// insert into DB
					hr = InsertFile(szFile, szComponent, szFileName, 
									uiFileSize, szVersion, szLanguage, 
									uiAttributes, 
									/*ISSUE: Sequence */ 1,
									NULL, i);
				}
			}
		}
	}

	delete pEEFile;

	if (szFile)
		delete[] szFile;


#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessFile\n"));
#endif

	return hr;
}

///////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFileName
//   This function:
//         1) Process <FileName> entity and return its value via szVal
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFileName(PIXMLDOMNode &pNodeFileName, int iColumn,  
						ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeFileName);
	assert(pEE);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeFileName)));
#endif

	// Get the value of FileName. It is either short or short|Long 
	IntStringValue isValFileName;
	hr = ProcessShortLong_SKU(pNodeFileName, &isValFileName, pSkuSet);

	// insert the value into the ElementEntry. 
	if (SUCCEEDED(hr))
		hr = pEE->SetValue(isValFileName, iColumn, pSkuSet);

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessFileName\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFileVersion
//   This function:
//         1) Process <FileVersion> entity and return its value via szVal
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFileVersion(PIXMLDOMNode &pNodeFileVersion, int iColumn, 
						   ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeFileVersion != NULL);
	assert(pEE);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeFileVersion)));
#endif

	IntStringValue isValValue;
	isValValue.szVal = NULL;
	IntStringValue isValSameAs;
	isValSameAs.szVal = NULL;
	HRESULT hrValue = S_OK;
	HRESULT hrSameAs = S_OK;

	hrValue = 
		ProcessAttribute(pNodeFileVersion, TEXT("Value"), STRING, &isValValue, 
						 pSkuSet);
	hrSameAs = 
		ProcessAttribute(pNodeFileVersion, TEXT("SameAs"), STRING, &isValSameAs, 
						 pSkuSet);

	if (SUCCEEDED(hrValue) && SUCCEEDED(hrSameAs))
	{
		// Both Value and SameAs attribute exist - Error
		if ( (S_FALSE != hrValue) && (S_FALSE != hrSameAs) )
		{
			_tprintf(TEXT("Compile Error: Value and SameAs attributes")
					 TEXT("cannot both exist for <FileVersion>\n"));
			hr = E_FAIL;
		}
		else 
		{
			// SameAs is speicified
			if (S_FALSE == hrValue)
			{
				LPTSTR szSameAs = isValSameAs.szVal;
				// check for the FileID reference is valid for this SkuSet
				assert(g_mapFiles.count(szSameAs));
				SkuSet *pSkuSetTemp = g_mapFiles[szSameAs];
				// *pSkuSet should be included in *pSkuSetTemp
				SkuSet skuSetTemp = SkuSetMinus(*pSkuSet, *pSkuSetTemp);
				if (!skuSetTemp.testClear())
				{
					_tprintf(TEXT("Compile Error: File Reference: %s ")
							 TEXT("is not valid in SKU "), szSameAs);
					PrintSkuIDs(&skuSetTemp);
					hr = E_FAIL;
				}
				else
					hr = pEE->SetValue(isValSameAs, iColumn, pSkuSet);
			}
			// Value is speicified
			if (S_FALSE == hrSameAs)
				hr = pEE->SetValue(isValValue, iColumn, pSkuSet);
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessFileVersion\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFileAttributes
//   This function:
//         1) Process <FileAttributes> entity and return its value via iVal
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFileAttributes(PIXMLDOMNode &pNodeFileAttributes, int iColumn,
						   ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	assert(pNodeFileAttributes != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeFileAttributes)));
#endif

	// Process all on/off children elements
	if (SUCCEEDED(hr))
		hr = ProcessOnOffAttributes_SKU(pNodeFileAttributes, 
										rgAttrBits_File,
										cAttrBits_File, pEE, iColumn,
										pSkuSet);
	// Process <Compressed> child
	hr = ProcessEnumAttributes(pNodeFileAttributes, COMPRESSED, 
							   rgEnumBits_Compressed_File,
							   cEnumBits_Compressed_File, pEE, iColumn, 
							   pSkuSet);

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessFileAttributes\n"));
#endif
	return hr;
}
////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFBS
//   This function processes <Font>, <BindImage>, <SelfReg> entity 
//	and insert into Font, BindImage, SelfReg DB tables respectively. It
//  also inserts the value into the ElementEntry object to do the uniqueness
//	validation
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFBS(PIXMLDOMNode &pNodeFBS, int iColumn, ElementEntry *pEE,
				   SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeFBS != NULL);
	assert(pEE);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeFBS)));
#endif

	NodeIndex ni = pEE->GetNodeIndex(iColumn);
	LPTSTR szAttributeName = rgXMSINodes[ni].szAttributeName;
	ValType vt = pEE->GetValType(iColumn);

	IntStringValue isVal;
	LPTSTR szFile = pEE->m_isValInfo.szVal;

	// get the attribute 
	if (SUCCEEDED(hr = ProcessAttribute(pNodeFBS, szAttributeName, 
										vt, &isVal, pSkuSet)))
	{
		// checking for missing required attribute
		if (S_FALSE == hr)
		{
			_tprintf(TEXT("Compile Error: Missing required attribute")
					 TEXT("\'%s\' of <%s>\n"), 
					 rgXMSINodes[ni].szAttributeName,
					 rgXMSINodes[ni].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			if (SUCCEEDED(hr = pEE->SetValue(isVal, iColumn, pSkuSet)))
			{
				// create table and insert into DB
				switch (ni) 
				{
				case FONT:
					hr = CreateTable_SKU(TEXT("Font"), pSkuSet);
					if (SUCCEEDED(hr))
						hr = InsertFont(szFile, isVal.szVal, pSkuSet, -1);
					break;
				case BINDIMAGE:
					hr = CreateTable_SKU(TEXT("BindImage"), pSkuSet);
					if (SUCCEEDED(hr))
						hr = InsertFont(szFile, isVal.szVal, pSkuSet, -1);
					break;
				case SELFREG:
					hr = CreateTable_SKU(TEXT("SelfReg"), pSkuSet);
					if (SUCCEEDED(hr))
						hr = InsertSelfReg(szFile, isVal.intVal, pSkuSet, -1);
					break;
				}
			}
		}
	}

#ifdef DEBUG
	if (FAILED(hr))	_tprintf(TEXT("Error in function: ProcessFBS\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessMoveFile
//   This function:
//         1) Process all subentities of <MoveFile> include <SourceName>, 
//			  <DestName>, <SourceFolder>, <DestFolder>, <CopyFile>;
//         2) Insert into the MoveFile table;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessMoveFile(PIXMLDOMNode &pNodeMoveFile, 
						IntStringValue isValComponent, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeMoveFile != NULL);

	SkuSet skuSetCommon(g_cSkus); // the SkuSet that shars the common column 
								  // values

	// Values to be inserted into the DB 
	LPTSTR szFileKey	  = NULL;
	LPTSTR szComponent_   = isValComponent.szVal;
	LPTSTR szSourceName   = NULL;
	LPTSTR szDestName     = NULL;
	LPTSTR szSourceFolder = NULL;
	LPTSTR szDestFolder	  = NULL;
	UINT   uiOptions      = MSI_NULL_INTEGER;

	// create the File DB table
	hr = CreateTable_SKU(TEXT("MoveFile"), pSkuSet);

	if (FAILED(hr))	return hr;

	// Construct an ElementEntry object. 
	ElementEntry *pEEMoveFile = new ElementEntry(5, pSkuSet);
	assert(pEEMoveFile);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeMoveFile, TEXT("ID"), STRING, &isValID, pSkuSet);

	// if there is no ID specified, compiler generates one
	if (SUCCEEDED(hr))
	{
		if (!isValID.szVal)
		{
			isValID.szVal = GetName(TEXT("MoveFile"));
#ifdef DEBUG
			_tprintf(TEXT("Processing <MoveFile> with compiler generated ")
					 TEXT("primary key = %s\n"), isValID.szVal);
#endif
		}
		else
		{
#ifdef DEBUG
			_tprintf(TEXT("Processing <MoveFile ID=\"%s\">\n"), isValID.szVal);
#else
		;
#endif
		}
		// at this point, a primary key should exist for this MoveFile
		szFileKey = isValID.szVal;
		assert(szFileKey);

	}

	// Call ProcessChildrenArray to get back column values of all SKUs 
	// via the ElementEntry object
	if (SUCCEEDED(hr))
	{
		// because <CopyFile> actually DEset a bit, So the column value
		// for Options has to be set to default first
		IntStringValue isValOptions;
		isValOptions.intVal = msidbMoveFileOptionsMove;
		pEEMoveFile->SetNodeIndex(COPYFILE, 5);
		pEEMoveFile->SetValType(INTEGER, 5);
		hr = pEEMoveFile->SetValueSplit(isValOptions, 5, pSkuSet, NULL);

		if (SUCCEEDED(hr))
			hr = ProcessChildrenArray_H_XIES(pNodeMoveFile, rgNodeFuncs_MoveFile,
											 cNodeFuncs_MoveFile, pEEMoveFile, 
											 pSkuSet);
	}
	
	// Finalize the values stored in *pEE
	if (SUCCEEDED(hr))
		hr = pEEMoveFile->Finalize();

	if (SUCCEEDED(hr))
	{
		// Process Common values first
		skuSetCommon = pEEMoveFile->GetCommonSkuSet();

		if (!skuSetCommon.testClear())
		{
			szSourceName   = pEEMoveFile->GetCommonValue(1).szVal;
			szDestName	   = pEEMoveFile->GetCommonValue(2).szVal;
			szSourceFolder = pEEMoveFile->GetCommonValue(3).szVal;
			szDestFolder   = pEEMoveFile->GetCommonValue(4).szVal;
			uiOptions	   = pEEMoveFile->GetCommonValue(5).intVal;

			// insert into DB
			hr = InsertMoveFile(szFileKey, szComponent_, szSourceName, 
								szDestName, szSourceFolder, szDestFolder, 
								uiOptions, &skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szSourceName   = pEEMoveFile->GetValue(1,i).szVal;
					szDestName	   = pEEMoveFile->GetValue(2,i).szVal;
					szSourceFolder = pEEMoveFile->GetValue(3,i).szVal;
					szDestFolder   = pEEMoveFile->GetValue(4,i).szVal;
					uiOptions	   = pEEMoveFile->GetValue(5,i).intVal;

					// insert into DB
					hr = InsertMoveFile(szFileKey, szComponent_, szSourceName, 
										szDestName, szSourceFolder, 
										szDestFolder, uiOptions, NULL, i);
				}
			}
		}
	}

	delete pEEMoveFile;

	if (szFileKey)
		delete[] szFileKey;


#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessMoveFile\n"));
#endif

	return hr;
}


// Helper function: tells how to update an IntStringValue storing the value
// of the Options column of MoveFile table. It sets the stored value to 
// be 0
HRESULT UpdateMoveFileOptions(IntStringValue *pisValOut, IntStringValue isValOld, 
							  IntStringValue isValNew)
{
	pisValOut->intVal = isValNew.intVal;

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessCopyFile
//   This function:
//         1) Process <CopyFile> entity and set the Options Column in the
//	  MoveFile Table.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessCopyFile(PIXMLDOMNode &pNodeCopyFile, int iColumn,  
						ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeCopyFile != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeCopyFile)));
#endif
	
	IntStringValue isVal;
	isVal.intVal = 0;
	hr = pEE->SetValueSplit(isVal, iColumn, pSkuSet, UpdateMoveFileOptions);

#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessCopyFile\n"));
#endif

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessRemoveFile
//   This function:
//         1) Process all subentities of <RemoveFile> include <FName>, 
//			  <DirProperty>, <InstallMode>;
//         2) Insert into the RemoveFile table;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessRemoveFile(PIXMLDOMNode &pNodeRemoveFile, 
						  IntStringValue isValComponent, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeRemoveFile != NULL);

	SkuSet skuSetCommon(g_cSkus); // the SkuSet that shares the common column 
								  // values

	// Values to be inserted into the DB 
	LPTSTR szFileKey	  = NULL;
	LPTSTR szComponent_   = isValComponent.szVal;
	LPTSTR szFileName     = NULL;
	LPTSTR szDirProperty  = NULL;
	UINT   uiInstallMode  = MSI_NULL_INTEGER;

	// create the File DB table
	hr = CreateTable_SKU(TEXT("RemoveFile"), pSkuSet);

	if (FAILED(hr))	return hr;

	// Construct an ElementEntry object. 
	ElementEntry *pEERemoveFile = new ElementEntry(3, pSkuSet);
	assert(pEERemoveFile);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeRemoveFile, TEXT("ID"), STRING, &isValID, pSkuSet);

	// if there is no ID specified, compiler generates one
	if (SUCCEEDED(hr))
	{
		if (!isValID.szVal)
		{
			isValID.szVal = GetName(TEXT("RemoveFile"));
#ifdef DEBUG
			_tprintf(TEXT("Processing <RemoveFile> with compiler generated ")
					 TEXT("primary key = %s\n"), isValID.szVal);
#endif
		}
		else
		{
#ifdef DEBUG
			_tprintf(TEXT("Processing <RemoveFile ID=\"%s\">\n"), isValID.szVal);
#else
		;
#endif
		}
		// at this point, a primary key should exist for this RemoveFile
		szFileKey = isValID.szVal;
		assert(szFileKey);
	}

	// Call ProcessChildrenArray to get back column values of all SKUs 
	// via the ElementEntry object
	if (SUCCEEDED(hr))
		hr = ProcessChildrenArray_H_XIES(pNodeRemoveFile, rgNodeFuncs_RemoveFile,
										 cNodeFuncs_RemoveFile, pEERemoveFile, 
										 pSkuSet);
	
	// Finalize the values stored in *pEE
	if (SUCCEEDED(hr))
		hr = pEERemoveFile->Finalize();

	if (SUCCEEDED(hr))
	{
		// Process Common values first
		skuSetCommon = pEERemoveFile->GetCommonSkuSet();

		if (!skuSetCommon.testClear())
		{
			szFileName     = pEERemoveFile->GetCommonValue(1).szVal;
			szDirProperty  = pEERemoveFile->GetCommonValue(2).szVal;
			uiInstallMode  = pEERemoveFile->GetCommonValue(3).intVal;

			// insert into DB
			hr = InsertRemoveFile(szFileKey, szComponent_, szFileName, 
								  szDirProperty, uiInstallMode,
								  &skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szFileName	  = pEERemoveFile->GetValue(1,i).szVal;
					szDirProperty = pEERemoveFile->GetValue(2,i).szVal;
					uiInstallMode = pEERemoveFile->GetValue(3,i).intVal;

					// insert into DB
					hr = InsertRemoveFile(szFileKey, szComponent_, szFileName, 
										  szDirProperty, uiInstallMode,
										  NULL, i);
				}
			}
		}
	}

	delete pEERemoveFile;

	if (szFileKey)
		delete[] szFileKey;


#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessRemoveFile\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessInstallMode
//   This function:
//         1) Process <InstallMode> entity and set the InstallMode Column in the
//	  RemoveFile Table.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessInstallMode(PIXMLDOMNode &pNodeInstallMode, int iColumn,
						   ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeInstallMode != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeInstallMode)));
#endif

	LPTSTR szValue = NULL;

	// get Value attribute 
	IntStringValue isValValue;
	isValValue.szVal = NULL;
	if (SUCCEEDED(hr = ProcessAttribute(pNodeInstallMode, 
										rgXMSINodes[XMSI_INSTALLMODE].szAttributeName,
							  		    STRING,
										&isValValue,
										pSkuSet)))
	{
		if (NULL == isValValue.szVal)
		{
			_tprintf(TEXT("Compile Error: Missing required attribute")
					 TEXT("\'%s\' of <%s>\n"), 
					 rgXMSINodes[XMSI_INSTALLMODE].szNodeName,
					 rgXMSINodes[XMSI_INSTALLMODE].szNodeName);
			hr = E_FAIL;
		}
		else
			szValue = isValValue.szVal;
	}

	// get the numeric value of InstallMode column in DB
	if (SUCCEEDED(hr))
	{
		IntStringValue isVal;
		isVal.intVal = 0;

		if (0 == _tcscmp(szValue, TEXT("OnInstall")))
		{
			isVal.intVal = msidbRemoveFileInstallModeOnInstall;
		}
		else if (0 == _tcscmp(szValue, TEXT("OnRemove")))
		{
			isVal.intVal = msidbRemoveFileInstallModeOnRemove;
		}
		else if (0 == _tcscmp(szValue, TEXT("OnBoth")))
		{
			isVal.intVal = msidbRemoveFileInstallModeOnBoth;
		}
		else
		{
			// error
			_tprintf(TEXT("Compile Error: <%s> has an unrecognized value %s ")
					 TEXT("in SKU "),
					 rgXMSINodes[XMSI_INSTALLMODE].szNodeName, 
					 szValue);
			PrintSkuIDs(pSkuSet);
			hr = E_FAIL;
		}

		delete[] szValue;

		if (SUCCEEDED(hr))
			hr = pEE->SetValue(isVal, iColumn, pSkuSet);
	}

#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessInstallMode\n"));
#endif

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessIniFile
//   This function:
//         1) Process all subentities of <IniFile> include <FName>, 
//			  <DirProperty>, <Section>, <Key>, <Value>, <Action>
//         2) Insert into the IniFile table;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessIniFile(PIXMLDOMNode &pNodeIniFile, 
						IntStringValue isValComponent, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeIniFile != NULL);

	SkuSet skuSetCommon(g_cSkus); // the SkuSet that shares the common column 
								  // values

	// Values to be inserted into the DB 
	LPTSTR szIniFile	  = NULL;
	LPTSTR szFileName	  = NULL;
	LPTSTR szDirProperty  = NULL;
	LPTSTR szSection	  = NULL;
	LPTSTR szKey		  = NULL;
	LPTSTR szValue		  = NULL;
	UINT   uiAction       = MSI_NULL_INTEGER;
	LPTSTR szComponent_   = isValComponent.szVal;

	// create the File DB table
	hr = CreateTable_SKU(TEXT("IniFile"), pSkuSet);

	if (FAILED(hr))	return hr;

	// Construct an ElementEntry object. 
	ElementEntry *pEEIniFile = new ElementEntry(6, pSkuSet);
	assert(pEEIniFile);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeIniFile, TEXT("ID"), STRING, &isValID, pSkuSet);

	// if there is no ID specified, compiler generates one
	if (SUCCEEDED(hr))
	{
		if (!isValID.szVal)
		{
			isValID.szVal = GetName(TEXT("IniFile"));
#ifdef DEBUG
			_tprintf(TEXT("Processing <IniFile> with compiler generated ")
					 TEXT("primary key = %s\n"), isValID.szVal);
#endif
		}
		else
		{
#ifdef DEBUG
			_tprintf(TEXT("Processing <IniFile ID=\"%s\">\n"), isValID.szVal);
#else
		;
#endif
		}
		// at this point, a primary key should exist for this IniFile
		szIniFile = isValID.szVal;
		assert(szIniFile);

	}

	// Call ProcessChildrenArray to get back column values of all SKUs 
	// via the ElementEntry object
	if (SUCCEEDED(hr))
		hr = ProcessChildrenArray_H_XIES(pNodeIniFile, rgNodeFuncs_IniFile,
										 cNodeFuncs_IniFile, pEEIniFile, 
										 pSkuSet);
	
	// Finalize the values stored in *pEEIniFile
	if (SUCCEEDED(hr))
		hr = pEEIniFile->Finalize();

	if (SUCCEEDED(hr))
	{
		// Process Common values first
		skuSetCommon = pEEIniFile->GetCommonSkuSet();

		if (!skuSetCommon.testClear())
		{
			szFileName	   = pEEIniFile->GetCommonValue(1).szVal;
			szDirProperty  = pEEIniFile->GetCommonValue(2).szVal;
			szSection	   = pEEIniFile->GetCommonValue(3).szVal;
			szKey		   = pEEIniFile->GetCommonValue(4).szVal;
			szValue		   = pEEIniFile->GetCommonValue(5).szVal;
			uiAction	   = pEEIniFile->GetCommonValue(6).intVal;

			// insert into DB
			hr = InsertIniFile(szIniFile, szFileName, szDirProperty, 
							   szSection, szKey, szValue, uiAction, 
							   szComponent_, &skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szFileName	   = pEEIniFile->GetValue(1,i).szVal;
					szDirProperty  = pEEIniFile->GetValue(2,i).szVal;
					szSection	   = pEEIniFile->GetValue(3,i).szVal;
					szKey		   = pEEIniFile->GetValue(4,i).szVal;
					szValue		   = pEEIniFile->GetValue(5,i).szVal;
					uiAction	   = pEEIniFile->GetValue(6,i).intVal;

					// insert into DB
					hr = InsertIniFile(szIniFile, szFileName, szDirProperty, 
									   szSection, szKey, szValue, uiAction, 
									   szComponent_, NULL, i);
				}
			}
		}
	}

	delete pEEIniFile;

	if (szIniFile)
		delete[] szIniFile;


#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessIniFile\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessAction
//   This function:
//         1) Process <Action> entity and set the Action Column in the
//	  IniFile Table.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessAction(PIXMLDOMNode &pNodeAction, int iColumn,
						   ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeAction != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeAction)));
#endif

	LPTSTR szValue = NULL;

	// get Value attribute 
	IntStringValue isValValue;
	isValValue.szVal = NULL;
	if (SUCCEEDED(hr = ProcessAttribute(pNodeAction, 
										rgXMSINodes[ACTION].szAttributeName,
							  		    STRING,
										&isValValue,
										pSkuSet)))
	{
		if (NULL == isValValue.szVal)
		{
			_tprintf(TEXT("Compile Error: Missing required attribute")
					 TEXT("\'%s\' of <%s>\n"), 
					 rgXMSINodes[ACTION].szNodeName,
					 rgXMSINodes[ACTION].szNodeName);
			hr = E_FAIL;
		}
		else
			szValue = isValValue.szVal;
	}

	// get the numeric value of Action column in DB
	if (SUCCEEDED(hr))
	{
		IntStringValue isVal;
		isVal.intVal = 0;

		if (0 == _tcscmp(szValue, TEXT("AddLine")))
		{
			isVal.intVal = msidbIniFileActionAddLine;
		}
		else if (0 == _tcscmp(szValue, TEXT("CreateLine")))
		{
			isVal.intVal = msidbIniFileActionCreateLine;
		}
		else if (0 == _tcscmp(szValue, TEXT("AddTag")))
		{
			isVal.intVal = msidbIniFileActionAddTag;
		}
		else
		{
			// error
			_tprintf(TEXT("Compile Error: <%s> has an unrecognized value %s ")
					 TEXT("in SKU "),
					 rgXMSINodes[ACTION].szNodeName, 
					 szValue);
			PrintSkuIDs(pSkuSet);
			hr = E_FAIL;
		}

		delete[] szValue;

		if (SUCCEEDED(hr))
			hr = pEE->SetValue(isVal, iColumn, pSkuSet);
	}

#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessAction\n"));
#endif

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessRemoveIniFile
//   This function:
//         1) Process all subentities of <RemoveIniFile> include <SourceName>, 
//			  <DestName>, <SourceFolder>, <DestFolder>, <CopyFile>;
//         2) Insert into the RemoveIniFile table;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessRemoveIniFile(PIXMLDOMNode &pNodeRemoveIniFile, 
						IntStringValue isValComponent, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeRemoveIniFile != NULL);

	SkuSet skuSetCommon(g_cSkus); // the SkuSet that shars the common column 
								  // values

	// Values to be inserted into the DB 
	LPTSTR szRemoveIniFile  = NULL;
	LPTSTR szFileName		= NULL;
	LPTSTR szDirProperty	= NULL;
	LPTSTR szSection		= NULL;
	LPTSTR szKey			= NULL;
	LPTSTR szValue			= NULL;
	UINT   uiAction			= MSI_NULL_INTEGER;
	LPTSTR szComponent_		= isValComponent.szVal;

	// create the File DB table
	hr = CreateTable_SKU(TEXT("RemoveIniFile"), pSkuSet);

	if (FAILED(hr))	return hr;

	// Construct an ElementEntry object. 
	ElementEntry *pEERemoveIniFile = new ElementEntry(6, pSkuSet);
	assert(pEERemoveIniFile);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeRemoveIniFile, TEXT("ID"), STRING, &isValID, pSkuSet);

	// if there is no ID specified, compiler generates one
	if (SUCCEEDED(hr))
	{
		if (!isValID.szVal)
		{
			isValID.szVal = GetName(TEXT("RemoveIniFile"));
#ifdef DEBUG
			_tprintf(TEXT("Processing <RemoveIniFile> with compiler generated ")
					 TEXT("primary key = %s\n"), isValID.szVal);
#endif
		}
		else
		{
#ifdef DEBUG
			_tprintf(TEXT("Processing <RemoveIniFile ID=\"%s\">\n"), isValID.szVal);
#else
		;
#endif
		}
		// at this point, a primary key should exist for this RemoveIniFile
		szRemoveIniFile = isValID.szVal;
		assert(szRemoveIniFile);

	}

	// Call ProcessChildrenArray to get back column values of all SKUs 
	// via the ElementEntry object
	if (SUCCEEDED(hr))
	{
		//because <Action> has a default value of msidbIniFileActionRemoveLine
		//set it for all SKUs in *pSkuSet 
		IntStringValue isValAction;
		isValAction.intVal = msidbIniFileActionRemoveLine;
		pEERemoveIniFile->SetNodeIndex(ACTION_REMOVEINIFILE, 5);
		pEERemoveIniFile->SetValType(INTEGER, 5);
		hr = pEERemoveIniFile->SetValueSplit(isValAction, 5, pSkuSet, NULL);

		if (SUCCEEDED(hr))
			hr = ProcessChildrenArray_H_XIES(pNodeRemoveIniFile, rgNodeFuncs_RemoveIniFile,
											 cNodeFuncs_RemoveIniFile, pEERemoveIniFile, 
											 pSkuSet);
	}
	
	// Finalize the values stored in *pEE
	if (SUCCEEDED(hr))
		hr = pEERemoveIniFile->Finalize();

	if (SUCCEEDED(hr))
	{
		// Process Common values first
		skuSetCommon = pEERemoveIniFile->GetCommonSkuSet();

		if (!skuSetCommon.testClear())
		{
			szFileName	   = pEERemoveIniFile->GetCommonValue(1).szVal;
			szDirProperty  = pEERemoveIniFile->GetCommonValue(2).szVal;
			szSection	   = pEERemoveIniFile->GetCommonValue(3).szVal;
			szKey		   = pEERemoveIniFile->GetCommonValue(4).szVal;
			szValue		   = pEERemoveIniFile->GetCommonValue(6).szVal;
			uiAction	   = pEERemoveIniFile->GetCommonValue(5).intVal;

			// insert into DB
			hr = InsertRemoveIniFile(szRemoveIniFile, szFileName, szDirProperty, 
							         szSection, szKey, szValue, uiAction, 
							         szComponent_, &skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szFileName	   = pEERemoveIniFile->GetValue(1,i).szVal;
					szDirProperty  = pEERemoveIniFile->GetValue(2,i).szVal;
					szSection	   = pEERemoveIniFile->GetValue(3,i).szVal;
					szKey		   = pEERemoveIniFile->GetValue(4,i).szVal;
					szValue		   = pEERemoveIniFile->GetValue(6,i).szVal;
					uiAction	   = pEERemoveIniFile->GetValue(5,i).intVal;

					// insert into DB
					hr = InsertRemoveIniFile(szRemoveIniFile, szFileName, szDirProperty, 
										     szSection, szKey, szValue, uiAction, 
									         szComponent_, NULL, i);
				}
			}
		}
	}

	delete pEERemoveIniFile;

	if (szRemoveIniFile)
		delete[] szRemoveIniFile;


#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessRemoveIniFile\n"));
#endif

	return hr;
}


// Helper function: tells how to update an IntStringValue storing the value
// of the Action column of RemoveIniFile table. It sets the stored value to 
// be msidbIniFileActionRemoveTag
HRESULT UpdateRemoveIniFileAction(IntStringValue *pisValOut, IntStringValue isValOld, 
								  IntStringValue isValNew)
{
	pisValOut->intVal = isValNew.intVal;

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessValue
//   This function:
//         1) Process <Value> entity and set both the Value column and 
//	  the Action Column in the RemoveIniFile Table.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessValue(PIXMLDOMNode &pNodeValue, int iColumn,  
						ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeValue != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeValue)));
#endif
	
	// update Value column
	hr = ProcessSimpleElement(pNodeValue, iColumn, pEE, pSkuSet);

	// update Action column
	if (SUCCEEDED(hr))
	{
		IntStringValue isVal;
		isVal.intVal = msidbIniFileActionRemoveTag;
		hr = pEE->SetValueSplit(isVal, 5, pSkuSet, UpdateRemoveIniFileAction);
	}

#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessValue\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessRegistry
//   This function process <Registry> entity:
//		(1) get Root, Key and pass to ProcessDelete, ProcessCreate
//		(2) for those SKUs that don't have <Delete> or <Create> specified,
//			insert into Registry table with Key and Root set to NULL
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessRegistry(PIXMLDOMNode &pNodeRegistry, 
						IntStringValue isValComponent, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeRegistry != NULL);
	int iRoot = MSI_NULL_INTEGER;
	LPTSTR szKey = NULL;
	LPTSTR szComponent_ = isValComponent.szVal;

	// get Root Attribute
	IntStringValue isValRoot;
	isValRoot.szVal = NULL;
	if (SUCCEEDED(hr = ProcessAttribute(pNodeRegistry, TEXT("Root"), STRING, 
										&isValRoot, pSkuSet)))
	{
		if (NULL == isValRoot.szVal)
			iRoot = -1; // default
		else if (0 == _tcscmp(isValRoot.szVal, TEXT("Default")))
			iRoot = -1;
		else if (0 == _tcscmp(isValRoot.szVal, TEXT("HKCR")))
			iRoot = msidbRegistryRootClassesRoot;
		else if (0 == _tcscmp(isValRoot.szVal, TEXT("HKCU")))
			iRoot = msidbRegistryRootCurrentUser;
		else if (0 == _tcscmp(isValRoot.szVal, TEXT("HKLM")))
			iRoot = msidbRegistryRootLocalMachine;
		else if (0 == _tcscmp(isValRoot.szVal, TEXT("HKU")))
			iRoot = msidbRegistryRootUsers;
		else 
		{
			_tprintf(TEXT("Compile Error: Unrecognized Root value %s ")
					 TEXT("attribute of <Registry> in SKU "),
					 isValRoot.szVal);
			PrintSkuIDs(pSkuSet);
			hr = E_FAIL;
		}
		
		if (isValRoot.szVal)
			delete[] isValRoot.szVal;
	}

	// get Key Attribute
	if (SUCCEEDED(hr))
	{
		IntStringValue isValKey;
		isValKey.szVal = NULL;
		if (SUCCEEDED(hr = ProcessAttribute(pNodeRegistry, TEXT("Key"),
											STRING, &isValKey, pSkuSet)))
		{
			if (NULL == isValKey.szVal)
			{
				_tprintf(TEXT("Compile Error: Missing required attribute")
						 TEXT("\'Key\' of <%s> in SKU \n"), 
						 rgXMSINodes[XMSI_REGISTRY].szNodeName);
				PrintSkuIDs(pSkuSet);
				hr = E_FAIL;
			}
			else
				szKey = isValKey.szVal;
		}
	}

	if (SUCCEEDED(hr))
	{
		// form the data structure to pass 3 values down to ProcessDelete
		// and ProcessCreate
		CompRootKey *pCompRootKey = new CompRootKey;
		assert(pCompRootKey);
		pCompRootKey->iRoot = iRoot;
		pCompRootKey->szComponent = szComponent_;
		pCompRootKey->szKey = szKey;

		IntStringValue isValCRK;
		isValCRK.pCompRootKey = pCompRootKey;

		// Process <Delete> column
		SkuSet skuSetCheckDelete(g_cSkus);
		hr = ProcessChildrenList_SKU(pNodeRegistry, XMSI_DELETE, false, isValCRK, 
									 ProcessDelete, pSkuSet,
									 &skuSetCheckDelete);
		// Process <Create> column
		SkuSet skuSetCheckCreate(g_cSkus);
		if (SUCCEEDED(hr))
			hr = ProcessChildrenList_SKU(pNodeRegistry, XMSI_CREATE, false, isValCRK,
										 ProcessCreate, pSkuSet, 
										 &skuSetCheckCreate);

		// if in some SKUs this <Registry> node has no children
		// insert into Create DB table with Name and Value column
		// set to NULL
		if (SUCCEEDED(hr))
		{
			skuSetCheckCreate &= skuSetCheckDelete;
			if (!skuSetCheckCreate.testClear())
			{
				hr = CreateTable_SKU(TEXT("Registry"), &skuSetCheckCreate);
				if (SUCCEEDED(hr))
				{
					LPTSTR szName = NULL;
					LPTSTR szValue = NULL;
					LPTSTR szRegistry = GetName(TEXT("Registry"));
					assert(szRegistry);
					
					hr = InsertRegistry(szRegistry, iRoot, szKey, szName, szValue, 
										szComponent_, &skuSetCheckCreate, -1);
				}
			}
		}
	}

	if (szKey)
		delete[] szKey;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessRegistry\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessDelete
//   This function process <Delete> entity:
//		(1) get Name column value and insert one row into RemoveRegistry table
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessDelete(PIXMLDOMNode &pNodeDelete, 
						IntStringValue isValCRK, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeDelete != NULL);

	// variables holding the values to be inserted into the DB
	LPTSTR szRemoveRegistry = NULL;
	int iRoot				= isValCRK.pCompRootKey->iRoot;
	LPTSTR szKey			= isValCRK.pCompRootKey->szKey;
	LPTSTR szName			= NULL;
	LPTSTR szComponent_		= isValCRK.pCompRootKey->szComponent;

	LPTSTR szType = NULL;

	// get ID Attribute if there is no ID specified, compiler generates one
	IntStringValue isValID;
	isValID.szVal = NULL;
	if (SUCCEEDED(hr = ProcessAttribute(pNodeDelete, TEXT("ID"), STRING, 
										&isValID, pSkuSet)))
	{
		if (!isValID.szVal)
			isValID.szVal = GetName(TEXT("RemoveRegistry"));

		// at this point, a primary key should exist for this RemoveRegistry
		szRemoveRegistry = isValID.szVal;
		assert(szRemoveRegistry);
	}
	
	// get Type and set Name accordingly
	if (SUCCEEDED(hr))
	{
		IntStringValue isValType;
		isValType.szVal = NULL;
		if (SUCCEEDED(hr = ProcessAttribute(pNodeDelete, TEXT("Type"),
											STRING, &isValType, pSkuSet)))
		{
			if (isValType.szVal && (0 == _tcscmp(isValType.szVal, TEXT("Key"))))
			{
				szName = _tcsdup(TEXT("-"));
				assert(szName);
			}
			else
			{
				// get Name attribute
				IntStringValue isValName;
				isValName.szVal = NULL;
				if (SUCCEEDED(hr = ProcessAttribute(pNodeDelete, TEXT("Name"),
													STRING, &isValName, pSkuSet)))
					szName = isValName.szVal;
			}
			if (isValType.szVal)
				delete[] isValType.szVal;
		}
	}

	if (SUCCEEDED(hr))
	{
		hr = CreateTable_SKU(TEXT("RemoveRegistry"), pSkuSet);
		if (SUCCEEDED(hr))
			hr = InsertRemoveRegistry(szRemoveRegistry, iRoot, szKey, szName,  
									  szComponent_, pSkuSet, -1);
	}

	if (szRemoveRegistry)
		delete[] szRemoveRegistry;

	if (szName)
		delete[] szName;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessDelete\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessCreate
//   This function process <Create> entity:
//		(1) get Name, Value column value and insert one row into Registry 
//			table;
//		(2) process KeyPath information;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessCreate(PIXMLDOMNode &pNodeCreate, 
						IntStringValue isValCRK, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeCreate != NULL);

	// variables holding the values to be inserted into the DB
	LPTSTR szRegistry	= NULL;
	int iRoot			= isValCRK.pCompRootKey->iRoot;
	LPTSTR szKey		= isValCRK.pCompRootKey->szKey;
	LPTSTR szName		= NULL;
	LPTSTR szValue		= NULL;
	LPTSTR szComponent_ = isValCRK.pCompRootKey->szComponent;

	LPTSTR szType = NULL;
	LPTSTR szKeyType = NULL;

	// get ID Attribute if there is no ID specified, compiler generates one
	IntStringValue isValID;
	isValID.szVal = NULL;
	if (SUCCEEDED(hr = ProcessAttribute(pNodeCreate, TEXT("ID"), STRING, 
										&isValID, pSkuSet)))
	{
		if (!isValID.szVal)
			isValID.szVal = GetName(TEXT("Registry"));

		// at this point, a primary key should exist for this Registry
		szRegistry = isValID.szVal;
		assert(szRegistry);
	}
	
	// get Type and set Name accordingly
	if (SUCCEEDED(hr))
	{
		IntStringValue isValType;
		isValType.szVal = NULL;
		if (SUCCEEDED(hr = ProcessAttribute(pNodeCreate, TEXT("Type"),
											STRING, &isValType, pSkuSet)))
		{
			if (isValType.szVal && (0 == _tcscmp(isValType.szVal, TEXT("Key"))))
			{
				// get KeyType and set Name accordingly
				IntStringValue isValKeyType;
				isValKeyType.szVal = NULL;
				if (SUCCEEDED(hr = ProcessAttribute(pNodeCreate, TEXT("KeyType"),
													STRING, &isValKeyType, pSkuSet)))
				{
					if (!isValKeyType.szVal)
					{
						szName = _tcsdup(TEXT("*"));
						assert(szName);
					}
					else
					{
						if (0 == _tcscmp(isValKeyType.szVal, TEXT("InstallUnInstall")))
						{
							szName = _tcsdup(TEXT("*"));
							assert(szName);
						}
						else if(0 == _tcscmp(isValKeyType.szVal, TEXT("InstallOnly")))
						{
							szName = _tcsdup(TEXT("+"));
							assert(szName);
						}
						else if(0 == _tcscmp(isValKeyType.szVal, TEXT("UnInstallOnly")))
						{
							szName = _tcsdup(TEXT("-"));
							assert(szName);
						}

						delete[] isValKeyType.szVal;
					}
				}
			}
			else
			{
				// get Name attribute
				IntStringValue isValName;
				isValName.szVal = NULL;
				if (SUCCEEDED(hr = ProcessAttribute(pNodeCreate, TEXT("Name"),
													STRING, &isValName, pSkuSet)))
					szName = isValName.szVal;

				// get Value attribute
				if (SUCCEEDED(hr))
				{
					IntStringValue isValValue;
					isValValue.szVal = NULL;
					if (SUCCEEDED(hr = ProcessAttribute(pNodeCreate, TEXT("Value"),
														STRING, &isValValue, pSkuSet)))
						szValue = isValValue.szVal;
				}

			}
			if (isValType.szVal)
				delete[] isValType.szVal;
		}
	}

	if (SUCCEEDED(hr))
	{
		hr = CreateTable_SKU(TEXT("Registry"), pSkuSet);
		if (SUCCEEDED(hr))
			hr = InsertRegistry(szRegistry, iRoot, szKey, szName, szValue,
								szComponent_, pSkuSet, -1);
	}

	// Process KeyPath attribute
	if (SUCCEEDED(hr))
		hr = ProcessKeyPath(pNodeCreate, szComponent_, szRegistry, pSkuSet);

	
	// Process children <LockPermission>s
	// Issue: need to ensure there is no duplicate primary key
	//		  LockOjbect + Table + Domain + User
	if (SUCCEEDED(hr))
	{
		IntStringValue isValLockPermission;
		TableLockObj *pTableLockObjTemp = new TableLockObj;
		pTableLockObjTemp->szLockObject = szRegistry;
		pTableLockObjTemp->szTable = TEXT("Registry");
		isValLockPermission.pTableLockObj = pTableLockObjTemp;
		hr = ProcessChildrenList_SKU(pNodeCreate, LOCKPERMISSION,
									false, isValLockPermission, 
									ProcessLockPermission, pSkuSet);
		delete pTableLockObjTemp;
	}

	if (szRegistry)
		delete[] szRegistry;

	if (szName)
		delete[] szName;

	if (szValue)
		delete[] szValue;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessCreate\n"));
#endif

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\elemententry.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       ElementEntry.cpp
//
//    This file contains the implementation of ElementEntry class
//--------------------------------------------------------------------------

#include "wmc.h"

////////////////////////////////////////////////////////////////////////////
// Constructor: take the number of columns in the DB
////////////////////////////////////////////////////////////////////////////
ElementEntry::ElementEntry(int cColumns, SkuSet *pSkuSetAppliesTo)
{
	m_cColumns = cColumns;

	m_pSkuSetAppliesTo = new SkuSet(g_cSkus);
	assert(m_pSkuSetAppliesTo != NULL);
	*m_pSkuSetAppliesTo = *pSkuSetAppliesTo;

	m_pSkuSetCommon = new SkuSet(g_cSkus);
	assert(m_pSkuSetCommon != NULL);
	*m_pSkuSetCommon = *pSkuSetAppliesTo;

	m_rgCommonValues = new SkuSetVal*[cColumns];
	for(int j=0; j<cColumns; j++)
		m_rgCommonValues[j] = NULL;

	assert(m_rgCommonValues != NULL);

	m_rgValTypes = new ValType[cColumns];
	assert(m_rgValTypes != NULL);

	m_rgpSkuSetValuesXVals = new SkuSetValues*[cColumns];
	assert(m_rgpSkuSetValuesXVals != NULL);
	for(int i=0; i<cColumns; i++)
		m_rgpSkuSetValuesXVals[i] = NULL;

	m_rgNodeIndices = new NodeIndex[cColumns];
	assert(m_rgNodeIndices != NULL);

	m_rgpSkuSetValidate = new SkuSet*[cColumns];
	assert(m_rgpSkuSetValidate);
	for(int k=0; k<cColumns; k++)
		m_rgpSkuSetValidate[k] = NULL;

	m_rgpSkuSetUnique = new SkuSet*[cColumns];
	assert(m_rgpSkuSetUnique);
	for(int m=0; m<cColumns; m++)
		m_rgpSkuSetUnique[m] = NULL;
}

////////////////////////////////////////////////////////////////////////////
// Destructor: 
////////////////////////////////////////////////////////////////////////////
ElementEntry::~ElementEntry()
{
	if (m_pSkuSetAppliesTo) delete m_pSkuSetAppliesTo;
	if (m_pSkuSetCommon) delete m_pSkuSetCommon;
	if (m_rgCommonValues)
	{
		for (int i=0; i<m_cColumns; i++)
		{
			if (m_rgCommonValues[i])
			{
				delete m_rgCommonValues[i]->pSkuSet;
				if (STRING == m_rgValTypes[i])
					delete[] m_rgCommonValues[i]->isVal.szVal;
				delete m_rgCommonValues[i];
			}
		}
		delete[] m_rgCommonValues;
	}

	if (m_rgValTypes) delete[] m_rgValTypes;
	if (m_rgpSkuSetValuesXVals) 
	{
		for (int i=0; i<m_cColumns; i++)
		{
			if (m_rgpSkuSetValuesXVals[i])
				delete m_rgpSkuSetValuesXVals[i];
		}
		delete[] m_rgpSkuSetValuesXVals;
	}

	if (m_rgpSkuSetValidate)
	{
		for(int i=0; i<m_cColumns; i++)
		{
			if (m_rgpSkuSetValidate[i])
				delete m_rgpSkuSetValidate[i];
		}
		delete[] m_rgpSkuSetValidate;
	}

	if (m_rgpSkuSetUnique)
	{
		for(int i=0; i<m_cColumns; i++)
		{
			if (m_rgpSkuSetUnique[i])
				delete m_rgpSkuSetUnique[i];
		}
		delete[] m_rgpSkuSetUnique;
	}
}

////////////////////////////////////////////////////////////////////////////
// GetValType: return the ValueType (INTEGER or STRING) of a column
//				(column count from 1)
////////////////////////////////////////////////////////////////////////////
ValType 
ElementEntry::GetValType(int iColumn)
{
	assert(iColumn <=m_cColumns && iColumn>0);
	assert(m_rgValTypes);
	return m_rgValTypes[iColumn-1];
}

////////////////////////////////////////////////////////////////////////////
// SetValType: set the ValueType (INTEGER or STRING) of a column
////////////////////////////////////////////////////////////////////////////
void 
ElementEntry::SetValType(ValType vt, int iColumn)
{
	assert(iColumn <=m_cColumns && iColumn>0);
	assert(m_rgValTypes);
	m_rgValTypes[iColumn-1] = vt;
}

////////////////////////////////////////////////////////////////////////////
// GetNodeIndex: return the NodeIndex of a column (column count from 1)
////////////////////////////////////////////////////////////////////////////
NodeIndex
ElementEntry::GetNodeIndex(int iColumn)
{
	assert(iColumn <=m_cColumns && iColumn>0);
	assert(m_rgNodeIndices);
	return m_rgNodeIndices[iColumn-1];
}

////////////////////////////////////////////////////////////////////////////
// SetNodeIndex: set the NodeIndex of a column (column count from 1)
////////////////////////////////////////////////////////////////////////////
void 
ElementEntry::SetNodeIndex(NodeIndex ni, int iColumn)
{
	assert(iColumn <=m_cColumns && iColumn>0);
	assert(m_rgNodeIndices);

	int iIndex = iColumn-1;
	m_rgNodeIndices[iIndex] = ni;
	if (m_rgpSkuSetUnique[iIndex])
		m_rgpSkuSetUnique[iIndex]->clear();
}


////////////////////////////////////////////////////////////////////////////
// SetValue: set the exceptional value of a column (column count from 1)
//			 The caller should free *pSkuSetAppliesTo
////////////////////////////////////////////////////////////////////////////
HRESULT
ElementEntry::SetValue(IntStringValue isVal, int iColumn, SkuSet *pSkuSetAppliesTo)
{
	assert(iColumn <=m_cColumns && iColumn>0);
	assert(m_rgCommonValues);
	assert(m_rgpSkuSetValuesXVals);

	HRESULT hr = S_OK;
	int iIndex = iColumn-1;

	SkuSet *pSkuSetTemp = new SkuSet(g_cSkus);
	assert(pSkuSetTemp);

	// get rid of the SKUs specified in children but not in parent
	*pSkuSetTemp = (*m_pSkuSetAppliesTo) & (*pSkuSetAppliesTo);

	// this value is no good for any SKU under consideration
	if (pSkuSetTemp->testClear())
		return S_FALSE;

	// if there is no common value specified for this column
	// this value becomes the common value
	if (!m_rgCommonValues[iIndex])
	{
		m_rgCommonValues[iIndex] = new SkuSetVal;
		assert(m_rgCommonValues[iIndex]);

		m_rgCommonValues[iIndex]->pSkuSet = pSkuSetTemp;
		m_rgCommonValues[iIndex]->isVal = isVal;

		// allocate memory to store the SkuSet for checking
		// the uniqueness of column values per SKU
		assert(!m_rgpSkuSetValidate[iIndex]);
		m_rgpSkuSetValidate[iIndex] = new SkuSet(g_cSkus);
		assert(m_rgpSkuSetValidate[iIndex]);

		*m_rgpSkuSetValidate[iIndex] = *pSkuSetTemp;

		return hr;
	}

	// Check the uniqueness of the column value in each SKU
	assert(m_rgpSkuSetValidate[iIndex]);
	SkuSet skuSetTemp = (*pSkuSetTemp) & *(m_rgpSkuSetValidate[iIndex]);

	if (!skuSetTemp.testClear())
	{
		_tprintf(TEXT("Error: <%s> appears more than ")
			TEXT("once in SKU: "), 
			rgXMSINodes[m_rgNodeIndices[iIndex]].szNodeName);
		for (int j=0; j<g_cSkus; j++)
		{
			if (skuSetTemp.test(j))
				_tprintf(TEXT("%s "), g_rgpSkus[j]->GetID());
		}
		_tprintf(TEXT("\n"));

		//For now, completely break when such error happens
		hr = E_FAIL;
		if (STRING == m_rgValTypes[iIndex])
			delete[] isVal.szVal;
		return hr;
	}

	// update the set of Skus that have this column value set
	*(m_rgpSkuSetValidate[iIndex]) |= *pSkuSetTemp;

	// allocate memory for the exceptional value
	if (!m_rgpSkuSetValuesXVals[iIndex])
	{
		m_rgpSkuSetValuesXVals[iIndex] = new SkuSetValues;
		assert(m_rgpSkuSetValuesXVals);
		m_rgpSkuSetValuesXVals[iIndex]->SetValType(m_rgValTypes[iIndex]);
	}

	// allocate memory and construct a SkuSetVal object
	SkuSetVal *pSkuSetVal = new SkuSetVal;
	assert(pSkuSetVal);

	// there is an exceptional column value. Prepare the values
	// for the newly constructed SkuSetVal object to be stored.
	// swap common and special values if necessary
	if (m_rgCommonValues[iIndex]->pSkuSet->countSetBits() 
					>= pSkuSetTemp->countSetBits())
	{
		pSkuSetVal->pSkuSet = pSkuSetTemp;
		pSkuSetVal->isVal = isVal;
	}
	else // swap common and special values
	{
		*pSkuSetVal = *(m_rgCommonValues[iIndex]);

		m_rgCommonValues[iIndex]->pSkuSet = pSkuSetTemp;
		m_rgCommonValues[iIndex]->isVal = isVal;
	}

	// insert into vector
	m_rgpSkuSetValuesXVals[iIndex]->DirectInsert(pSkuSetVal);

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// SetValueSkuSetValues: Store a list of values (a SkuSetValues object)
//						 for a column
//						 Caller should allocate and free *pSkuSetValues
////////////////////////////////////////////////////////////////////////////
HRESULT
ElementEntry::SetValueSkuSetValues(SkuSetValues *pSkuSetValues, int iColumn)
{
	HRESULT hr = S_OK;

	assert(pSkuSetValues);
	int iIndex = iColumn - 1;
	ValType vt = m_rgValTypes[iIndex];

	assert(pSkuSetValues->GetValType() == vt);

	SkuSetVal *pSkuSetVal = NULL;
	for (pSkuSetVal = pSkuSetValues->Start(); 
		 pSkuSetVal != pSkuSetValues->End(); 
		 pSkuSetVal = pSkuSetValues->Next())
	{
		if (pSkuSetVal)
		{
			IntStringValue isVal;
			if(STRING == vt)
			{
				if (pSkuSetVal->isVal.szVal)
					isVal.szVal = _tcsdup(pSkuSetVal->isVal.szVal);
				else
					isVal.szVal = NULL;
				assert(isVal.szVal);
			}
			else
				isVal.intVal = pSkuSetVal->isVal.intVal;

			hr = SetValue(isVal, iColumn, pSkuSetVal->pSkuSet);

			if (FAILED(hr))
				break;
		}
	}

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// SetValueSplit: set the exceptional value of a column (column count from 1)
//				  The caller should free *pSkuSetAppliesTo.
//				  This function is used for the following situation:
//					1) When the column value is decided by more than one type 
//					   of node in the WIML file. The passed-in function pointer 
//					   tells how to update the column value;
////////////////////////////////////////////////////////////////////////////
HRESULT
ElementEntry::SetValueSplit(IntStringValue isVal, int iColumn, SkuSet *pSkuSetAppliesTo,
							HRESULT (*UpdateFunc)
								(IntStringValue *pIsValOut, IntStringValue isVal1, IntStringValue isVal2))
{
	assert(iColumn <=m_cColumns && iColumn>0);
	assert(m_rgpSkuSetValuesXVals);

	HRESULT hr = S_OK;
	int iIndex = iColumn-1;

	SkuSet *pSkuSetTemp = new SkuSet(g_cSkus);
	assert(pSkuSetTemp);

	// get rid of the SKUs specified in children but not in parent
	*pSkuSetTemp = (*m_pSkuSetAppliesTo) & (*pSkuSetAppliesTo);

	// this value is no good for any SKU under consideration
	if (pSkuSetTemp->testClear())
		return S_FALSE;

	// allocate memory to store the SkuSet for checking
	// the uniqueness of column values per SKU
	if (!m_rgpSkuSetUnique[iIndex])
		m_rgpSkuSetUnique[iIndex] = new SkuSet(g_cSkus);

	assert(m_rgpSkuSetUnique[iIndex]);


	// allocate memory to store the SkuSet for checking
	// not missing of required column values per SKU
	if (!m_rgpSkuSetValidate[iIndex])
		m_rgpSkuSetValidate[iIndex] = new SkuSet(g_cSkus);

	assert(m_rgpSkuSetValidate[iIndex]);

	// Check the uniqueness of the column value in each SKU
	if (1 == rgXMSINodes[m_rgNodeIndices[iIndex]].uiOccurence)
	{
		SkuSet skuSetTemp = (*pSkuSetTemp) & *(m_rgpSkuSetUnique[iIndex]);
		if (!skuSetTemp.testClear())
		{
			_tprintf(TEXT("Error: <%s> appears more than ")
				TEXT("once in SKU: "), 
				rgXMSINodes[m_rgNodeIndices[iIndex]].szNodeName);
			for (int j=0; j<g_cSkus; j++)
			{
				if (skuSetTemp.test(j))
					_tprintf(TEXT("%s "), g_rgpSkus[j]->GetID());
			}
			_tprintf(TEXT("\n"));

			//For now, completely break when such error happens
			hr = E_FAIL;
			if (STRING == m_rgValTypes[iIndex])
				delete[] isVal.szVal;
			return hr;
		}
	}

	// update the SkuSets used for error checking
	*(m_rgpSkuSetValidate[iIndex]) |= *pSkuSetTemp;
	*(m_rgpSkuSetUnique[iIndex]) |= *pSkuSetTemp;

	// allocate memory for the exceptional value
	if (!m_rgpSkuSetValuesXVals[iIndex])
	{
		m_rgpSkuSetValuesXVals[iIndex] = new SkuSetValues;
		assert(m_rgpSkuSetValuesXVals);
		m_rgpSkuSetValuesXVals[iIndex]->SetValType(m_rgValTypes[iIndex]);
	}

	// insert into vector
	hr = m_rgpSkuSetValuesXVals[iIndex]->SplitInsert(pSkuSetTemp, isVal, UpdateFunc);


	return hr;
}

////////////////////////////////////////////////////////////////////////////
// GetValue: Get the exceptional value of a column (column count from 1)
////////////////////////////////////////////////////////////////////////////
IntStringValue
ElementEntry::GetValue(int iColumn, int iPos)
{
	assert(iColumn <=m_cColumns && iColumn>0);
	// it is not efficient to get a common value this way!
	assert(!m_pSkuSetCommon->test(iPos));

	int iIndex = iColumn - 1;

	// check the common value of this column
	if (m_rgCommonValues[iIndex])
	{
		if (m_rgCommonValues[iIndex]->pSkuSet->test(iPos))
			return m_rgCommonValues[iIndex]->isVal;
	}

	// check the exceptional values
	if (m_rgpSkuSetValuesXVals[iIndex])
	{
		return m_rgpSkuSetValuesXVals[iIndex]->GetValue(iPos);
	}

	IntStringValue isVal;
	if (INTEGER == m_rgValTypes[iIndex])
		isVal.intVal = MSI_NULL_INTEGER;
	else
		isVal.szVal = NULL;

	return isVal;
}

////////////////////////////////////////////////////////////////////////////
// finalize the common values and the common set 
// also check for missing required entities
////////////////////////////////////////////////////////////////////////////
HRESULT 
ElementEntry::Finalize()
{
	HRESULT hr = S_OK;

	for(int iIndex=0; iIndex<m_cColumns; iIndex++)
	{
		NodeIndex nodeIndex = m_rgNodeIndices[iIndex];

		// check for missing required entities error
		if(rgXMSINodes[nodeIndex].bIsRequired)
		{
			SkuSet skuSetTemp(g_cSkus);
			if(!m_rgpSkuSetValidate[iIndex])
				skuSetTemp.setAllBits();
			else 
				skuSetTemp = SkuSetMinus(*m_pSkuSetAppliesTo, 
										*m_rgpSkuSetValidate[iIndex]);

			if (!skuSetTemp.testClear())
			{
				_tprintf(TEXT("Compile Error: Missing required Node <%s> ")
								TEXT("in SKU: "), 
								rgXMSINodes[nodeIndex].szNodeName);
							
				for (int j=0; j<g_cSkus; j++)
				{
					if (skuSetTemp.test(j))
						_tprintf(TEXT("%s "), g_rgpSkus[j]->GetID());
				}
				_tprintf(TEXT("\n"));

				//For now, completely break when such error happens
				hr = E_FAIL;
				break;
			}
		}

		// if the common value is not set, but the exceptional value is
		// set. This column is formed by SetValueSplit. Need to find
		// the most common value stored and put it in m_rgCommonValues
		if (!m_rgCommonValues[iIndex] && m_rgpSkuSetValuesXVals[iIndex])
		{
			// find the most common one
			SkuSetVal *pSkuSetVal =
				m_rgpSkuSetValuesXVals[iIndex]->GetMostCommon();

			// insert into the common array
			m_rgCommonValues[iIndex] = pSkuSetVal;

			// delete from the side chain
			m_rgpSkuSetValuesXVals[iIndex]->Erase(pSkuSetVal);

			// update the common set of all column values
			*m_pSkuSetCommon &= *(m_rgCommonValues[iIndex]->pSkuSet);
		}

		if (m_rgCommonValues[iIndex])
		{
			// finalize the common value for each column: it might be NULL
			// How many Skus have this column value set?
			int cSkusHasValue = m_rgpSkuSetValidate[iIndex]->countSetBits();
			// How many Skus are there?
			int cSkus = m_pSkuSetAppliesTo->countSetBits();

			if (cSkusHasValue < cSkus-cSkusHasValue)
			{
				// allocate memory for a vector for the exceptional value
				if (m_rgpSkuSetValuesXVals[iIndex] == NULL)
				{
					m_rgpSkuSetValuesXVals[iIndex] = new SkuSetValues;
					assert(m_rgpSkuSetValuesXVals);
					m_rgpSkuSetValuesXVals[iIndex]->SetValType(m_rgValTypes[iIndex]);
				}
				m_rgpSkuSetValuesXVals[iIndex]->DirectInsert(m_rgCommonValues[iIndex]);	

				// allocate memory and construct a SkuSetVal object
				SkuSetVal *pSkuSetVal = new SkuSetVal;
				assert(pSkuSetVal);
				pSkuSetVal->pSkuSet = new SkuSet();

				*(pSkuSetVal->pSkuSet) = (*m_pSkuSetAppliesTo) & 
									(~(*(m_rgCommonValues[iIndex]->pSkuSet)));

				if (INTEGER == m_rgValTypes[iIndex])
				{
					(pSkuSetVal->isVal).intVal = 0;
				}
				else
				{
					(pSkuSetVal->isVal).szVal = NULL;
				}

				m_rgCommonValues[iIndex] = pSkuSetVal;
			}
		
			// the common set of all column values is the intersection
			// of the common sets of all the columns
			*m_pSkuSetCommon &= *(m_rgCommonValues[iIndex]->pSkuSet);
		}
	}	
	
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// GetCommonValue: return the common value of a column (column count from 1)
////////////////////////////////////////////////////////////////////////////
IntStringValue
ElementEntry::GetCommonValue(int iColumn)
{
	assert(iColumn <=m_cColumns && iColumn>0);

	IntStringValue isVal;
	int iIndex = iColumn - 1;

	// no value has been specified for this column
	if (!m_rgCommonValues[iIndex])
	{
		if (INTEGER == m_rgValTypes[iIndex])
		{
			isVal.intVal = MSI_NULL_INTEGER;
		}
		else
		{
			isVal.szVal = NULL;
		}
		return isVal;
	}

	return m_rgCommonValues[iIndex]->isVal;
}

////////////////////////////////////////////////////////////////////////////
// return the SkuSet that the common values apply to
////////////////////////////////////////////////////////////////////////////
SkuSet 
ElementEntry::GetCommonSkuSet()
{
	return *m_pSkuSetCommon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\componentfuncs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       componentFuncs.h
//              
//				The part of the program that deals with <Component> and
//              its subentities in the input XML file
//--------------------------------------------------------------------------

#ifndef XMSI_COMPONENTFUNCS_H
#define XMSI_COMPONENTFUNCS_H

#include "wmc.h"
#include "utilities.h"

HRESULT ProcessComponents();
	HRESULT ProcessComponent(PIXMLDOMNode &pNodeComponent, LPTSTR szComponent,
							 SkuSet *pSkuSet);
		HRESULT ProcessGUID(PIXMLDOMNode &pNode, int iColumn,  
							ElementEntry *pEE, SkuSet *pSkuSet);
		HRESULT ProcessComponentDir(PIXMLDOMNode &pNodeComponentDir, 
									int iColumn, ElementEntry *pEE, 
									SkuSet *pSkuSet);
		HRESULT ProcessComponentAttributes(PIXMLDOMNode &pNodeComponentAttributes,
										   int iColumn,  ElementEntry *pEE,
										   SkuSet *pSkuSet);
		HRESULT ProcessCreateFolder(PIXMLDOMNode &pNodeCreateFolder,
							IntStringValue isVal, SkuSet *pSkuSet);
			HRESULT ProcessLockPermission(PIXMLDOMNode &pNodeLockPermission,
										  IntStringValue isValLockPermission, 
										  SkuSet *pSkuSet);
		HRESULT ProcessFile(PIXMLDOMNode &pNodeFile, IntStringValue isValComponent,
							SkuSet *pSkuSet);
			HRESULT ProcessFileName(PIXMLDOMNode &pNode, int iColumn,  
									ElementEntry *pEE, SkuSet *pSkuSet);
			HRESULT ProcessFileVersion(PIXMLDOMNode &pNode, int iColumn,  
									   ElementEntry *pEE, SkuSet *pSkuSet);
			HRESULT ProcessFileAttributes(PIXMLDOMNode &pNode, int iColumn,  
										  ElementEntry *pEE, SkuSet *pSkuSet);
			/* ProcessFBS processes <Font> <BindImage> <SelfReg> */
			HRESULT ProcessFBS(PIXMLDOMNode &pNode, int iColumn,  
								ElementEntry *pEE, SkuSet *pSkuSet);
		HRESULT ProcessMoveFile(PIXMLDOMNode &pNodeFile, 
								IntStringValue isValComponent, SkuSet *pSkuSet);
			HRESULT ProcessCopyFile(PIXMLDOMNode &pNode, int iColumn,  
									ElementEntry *pEE, SkuSet *pSkuSet);
		HRESULT ProcessRemoveFile(PIXMLDOMNode &pNodeRemoveFile, 
								IntStringValue isValComponent, SkuSet *pSkuSet);
			HRESULT ProcessInstallMode(PIXMLDOMNode &pNode, int iColumn,
									ElementEntry *pEE, SkuSet *pSkuSet);	
		HRESULT ProcessIniFile(PIXMLDOMNode &pNodeIniFile, 
			  				   IntStringValue isValComponent, SkuSet *pSkuSet);
			HRESULT ProcessAction(PIXMLDOMNode &pNodeAction, int iColumn,
							      ElementEntry *pEE, SkuSet *pSkuSet);
		HRESULT ProcessRemoveIniFile(PIXMLDOMNode &pNodeRemoveIniFile, 
									 IntStringValue isValComponent, 
									 SkuSet *pSkuSet);
			HRESULT ProcessValue(PIXMLDOMNode &pNodeValue, int iColumn,  
								 ElementEntry *pEE, SkuSet *pSkuSet);
		HRESULT ProcessRegistry(PIXMLDOMNode &pNodeRegistry, 
								IntStringValue isValComponent, SkuSet *pSkuSet);
			HRESULT ProcessDelete(PIXMLDOMNode &pNodeDelete, 
								  IntStringValue isValCRK, SkuSet *pSkuSet);
			HRESULT ProcessCreate(PIXMLDOMNode &pNodeCreate, 
								  IntStringValue isValCRK, SkuSet *pSkuSet);

///////////////////////////////////////////////////////////////////////////
// <Component>
Node_Func_H_XIES rgNodeFuncs_Component[] = {
//	 NodeIndex			ProcessFunc				  ValueType	  column #	
{	XMSI_GUID,			ProcessGUID,				STRING,		1		},
{	COMPONENTDIR,		ProcessComponentDir,		STRING,		2		},
{	COMPONENTATTRIBUTES,ProcessComponentAttributes,	INTEGER,	3		},
{	CONDITION,			ProcessSimpleElement,		STRING,		4		},
{	PLACEHOLDER,		NULL/* */,					STRING,		5		}
};

const int cNodeFuncs_Component = 
			sizeof(rgNodeFuncs_Component)/sizeof(Node_Func_H_XIES);

EnumBit rgEnumBits_RunFrom_Component[] = {
{	TEXT("Local"),				0										 },
{	TEXT("Source"),			msidbComponentAttributesSourceOnly			 },
{	TEXT("Both"),			msidbComponentAttributesOptional			 },
};

const int cEnumBits_RunFrom_Component = 
			sizeof(rgEnumBits_RunFrom_Component)/sizeof(EnumBit);


AttrBit_SKU rgAttrBits_Component[] = {
{SHAREDDLLREFCOUNT,			msidbComponentAttributesSharedDllRefCount	},
{PERMANENT,					msidbComponentAttributesPermanent			},
{TRANSITIVE,				msidbComponentAttributesTransitive			},
{NEVEROVERWRITE,			msidbComponentAttributesNeverOverwrite		}
};

const int cAttrBits_Component = 
			sizeof(rgAttrBits_Component)/sizeof(AttrBit_SKU);
///////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// <File>
Node_Func_H_XIES rgNodeFuncs_File[] = {
//	 NodeIndex			ProcessFunc				ValueType	column #	
{	FILENAME,		ProcessFileName,			STRING,			1	},
{	FILESIZE,		ProcessSimpleElement,		INTEGER,		2	},
{	FILEVERSION,	ProcessFileVersion,			STRING,			3	},
{	FILELANGUAGE,	ProcessSimpleElement,		STRING,			4	},
{	FILEATTRIBUTES,	ProcessFileAttributes,		INTEGER,		5	},
{	FONT,			ProcessFBS,					STRING,			6	},
{	BINDIMAGE,		ProcessFBS,					STRING,			7	},
{	SELFREG,		ProcessFBS,					INTEGER,		8	}
};

const int cNodeFuncs_File =
			 sizeof(rgNodeFuncs_File)/sizeof(Node_Func_H_XIES);

EnumBit rgEnumBits_Compressed_File[] = {
{	TEXT("Default"),		0											 },
{	TEXT("No"),				msidbFileAttributesNoncompressed			 },
{	TEXT("Yes"),			msidbFileAttributesCompressed				 },
};

const int cEnumBits_Compressed_File = 
			sizeof(rgEnumBits_Compressed_File)/sizeof(EnumBit);

AttrBit_SKU rgAttrBits_File[] = {
	{READONLY,			msidbFileAttributesReadOnly			},
	{HIDDEN,			msidbFileAttributesHidden			},
	{SYSTEM,			msidbFileAttributesSystem			},
	{VITAL,				msidbFileAttributesVital			},
	{CHECKSUM,			msidbFileAttributesChecksum			}
};
const int cAttrBits_File = sizeof(rgAttrBits_File)/sizeof(AttrBit_SKU);
//////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// <MoveFile>
Node_Func_H_XIES rgNodeFuncs_MoveFile[] = {
//	 NodeIndex			ProcessFunc				ValueType	column #	
{	SOURCENAME,		ProcessSimpleElement,		STRING,			1	},
{	DESTNAME,		ProcessSimpleElement,		STRING,			2	},
{	SOURCEFOLDER,	ProcessSimpleElement,		STRING,			3	},
{	DESTFOLDER,		ProcessSimpleElement,		STRING,			4	},
{	COPYFILE,		ProcessCopyFile,			INTEGER,		5	}
};

const int cNodeFuncs_MoveFile =
			 sizeof(rgNodeFuncs_MoveFile)/sizeof(Node_Func_H_XIES);
//////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// <RemoveFile>
Node_Func_H_XIES rgNodeFuncs_RemoveFile[] = {
//	 NodeIndex				ProcessFunc				ValueType	column #	
{	FNAME_REMOVEFILE,		ProcessSimpleElement,		STRING,			1	},
{	DIRPROPERTY_INIFILE,	ProcessSimpleElement,		STRING,			2	},
{	XMSI_INSTALLMODE,		ProcessInstallMode,			INTEGER,		3	}
};

const int cNodeFuncs_RemoveFile =
			 sizeof(rgNodeFuncs_RemoveFile)/sizeof(Node_Func_H_XIES);
//////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// <IniFile>
Node_Func_H_XIES rgNodeFuncs_IniFile[] = {
//	NodeIndex				ProcessFunc				ValueType	column #	
{	FNAME_INIFILE,			ProcessSimpleElement,	STRING,			1	},
{	DIRPROPERTY_INIFILE,	ProcessSimpleElement,	STRING,			2	},
{	SECTION,				ProcessSimpleElement,	STRING,			3	},
{	KEY,					ProcessSimpleElement,	STRING,			4	},
{	VALUE_INIFILE,			ProcessSimpleElement,	STRING,			5	},
{	ACTION,					ProcessAction,			INTEGER,		6	}
};

const int cNodeFuncs_IniFile =
			 sizeof(rgNodeFuncs_IniFile)/sizeof(Node_Func_H_XIES);
//////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////
// <RemoveIniFile>
Node_Func_H_XIES rgNodeFuncs_RemoveIniFile[] = {
//	NodeIndex					ProcessFunc				ValueType	column #	
{	FNAME_REMOVEINIFILE,		ProcessSimpleElement,	STRING,			1	},
{	DIRPROPERTY_REMOVEINIFILE,	ProcessSimpleElement,	STRING,			2	},
{	SECTION,					ProcessSimpleElement,	STRING,			3	},
{	KEY,						ProcessSimpleElement,	STRING,			4	},
/* Note: because it is inside ProcessValue that the value of Action column 
   is Set. So the following process order has to be enforced */
{	ACTION_REMOVEINIFILE,		NULL,					INTEGER,		5	},
{	VALUE_REMOVEINIFILE,		ProcessValue,			STRING,			6	},
};

const int cNodeFuncs_RemoveIniFile =
			 sizeof(rgNodeFuncs_RemoveIniFile)/sizeof(Node_Func_H_XIES);
//////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////
// Globals

// Key: File ID		Value: the set of SKUs that can reference this File ID
map<LPTSTR, SkuSet *, Cstring_less> g_mapFiles;
//////////////////////////////////////////////////////////////////////////

#endif //XMSI_COMPONENTFUNCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\mainfuncs.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       mainFuncs.cpp
//              This file contains the functions the main function and 
//				functions that process <Information> <Directories>
//				<InstallLevels> <Features> and their subentities in the 
//				input package
//--------------------------------------------------------------------------

#include "mainFuncs.h"

//////////////////////////////////////////////////////////////////////////
// Function: Main program entry point.
//       Return Value			Meaning
// ------------------------------------------------------------------------
//      ERROR_SUCCESS			Normal
//      ERROR_BAD_ARGUMENTS		Error during command line arg parsing                
//		ERROR_FILE_NOT_FOUND	Cannot find specified log file
//          -1					Other errors
//////////////////////////////////////////////////////////////////////////
int _cdecl 
_tmain(int argc, TCHAR *argv[])
{
	int errorCode = ERROR_SUCCESS;    
	HRESULT hr = S_OK;
	BSTR pBURL = NULL;       // the URL of the input WIML package 


	CommandOpt com_opt;

	// parse the command line options
	if (ERROR_SUCCESS != 
					(errorCode = com_opt.ParseCommandOptions(argc, argv)) )
		return errorCode;

	// Intialize global variables
	g_bValidationOnly = com_opt.GetValidationMode();
	g_bVerbose = com_opt.GetVerboseMode();
	g_pLogFile = com_opt.GetLogFile();
	g_szInputSkuFilter = com_opt.GetInputSkuFilter();

	if (NULL != (pBURL = LPTSTRToBSTR(com_opt.GetURL())) )
		hr = CoInitialize(NULL);
	else
	{
		_tprintf(TEXT("Internal Error. Failed to convert string")
				 TEXT("from LPSTSR to BSTR\n"));
		hr = E_FAIL;
	}

	if (SUCCEEDED(hr))
	{
	// Start processing the input package
		if (SUCCEEDED(hr = ProcessStart(pBURL)))
		{
			errorCode = CommitChanges();

#ifdef DEBUG 
	// print out the content of global data structures for debug purpose
	//PrintMap_DirRef(g_mapDirectoryRefs_SKU);
	//PrintMap_DirRef(g_mapInstallLevelRefs_SKU);
	//PrintMap_LC(g_mapComponents); 
#endif
		}

		// release the memory taken by the global data structures
		CleanUp();
		CoUninitialize();
	}

	if (pBURL)
		SysFreeString(pBURL);

	if (FAILED(hr))
		errorCode = -1;

	return errorCode;
}

////////////////////////////////////////////////////////////////////////////
// GeneratePackageCode: generate a GUID and insert into the database
////////////////////////////////////////////////////////////////////////////
HRESULT GeneratePackageCode(MSIHANDLE hSummaryInfo)
{
	HRESULT hr = S_OK;
	int errorCode = ERROR_SUCCESS;
	GUID GUID_PackageCode = GUID_NULL;

	if (SUCCEEDED(hr = CoCreateGuid(&GUID_PackageCode)))
	{
		LPTSTR szGUID = NULL;
		if (SUCCEEDED(hr = GUIDToLPTSTR(&GUID_PackageCode, szGUID)))
		{
			if (SUCCEEDED(hr = FormatGUID(szGUID)))
				if(ERROR_SUCCESS != (errorCode = 
					MsiSummaryInfoSetProperty(hSummaryInfo, PID_REVNUMBER,
												VT_LPSTR, 0, NULL, szGUID)))
				{
					PrintError(errorCode);
					hr = E_FAIL;
				}
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: GeneratePackageCode\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// CommitChanges: commit the changes made to the output MSI database
////////////////////////////////////////////////////////////////////////////
UINT CommitChanges()
{
	UINT errorCode = ERROR_SUCCESS;

	for (int i=0; i<g_cSkus; i++)
	{
		if (g_pskuSet->test(i))
		{
			// Commit summary infomation changes
			if (ERROR_SUCCESS == 
				(errorCode = 
						MsiSummaryInfoPersist(g_rgpSkus[i]->m_hSummaryInfo)))
			{
				// Commit database changes
				if (ERROR_SUCCESS != 
					(errorCode = MsiDatabaseCommit(g_rgpSkus[i]->m_hDatabase)))
					_tprintf(
						TEXT("Error: Failed to commit the database changes")
						TEXT(" for SKU %s\n"), g_rgpSkus[i]->GetID());
			}
			else
			{
				PrintError(errorCode);
				_tprintf(
					TEXT("Error: Failed to persist the summary info changes")
					TEXT(" for SKU %s\n"), g_rgpSkus[i]->GetID());
			}
		}
	}
	return errorCode;
}	

////////////////////////////////////////////////////////////////////////////
// ProcessStart: The compiling process starts here.
//				 This function:
//					1) call the MSXML parser to load the input WIML document;
//					2) obtaining the root node;
//					3) pass the root node to function ProcessProductFamily                  
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessStart(BSTR pBURL)
{
	HRESULT hr = S_OK;

	PIXMLDOMDocument2 pDoc = NULL;       // the document tree 
	PIXMLDOMElement pDocElement = NULL;  // the root element <ProductFamily> 
	PIXMLDOMNode pNodeProductFamily = NULL; // the root node <ProductFamily> 

	// create an empty XML document
	if (SUCCEEDED
		(hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, 
							   IID_IXMLDOMDocument, (void**)&pDoc)))
	{
		// load the XML document from specified file
		if (SUCCEEDED(hr = LoadDocumentSync(pDoc, pBURL)))
		{
			// get the root element <ProductFamily>
			if(SUCCEEDED(hr = pDoc->get_documentElement(&pDocElement)))
			{
				if (pDocElement == NULL)
				{
					_tprintf(TEXT("Compiler error: no root exists")
							 TEXT("in the input document\n"));
					hr = E_FAIL;
				}
				else  // get the root node <ProductFamily> 
					hr = pDocElement->QueryInterface(IID_IXMLDOMNode, 
											(void **)&pNodeProductFamily);
			}
		}
	}
	else	
		_tprintf(TEXT("Internal Error: Failed to create the interface")
				 TEXT("instance\n"));

	// call ProcessProductFamily to start the function tree processing
	if (SUCCEEDED(hr) && (pNodeProductFamily != NULL))
	{
		g_pNodeProductFamily = pNodeProductFamily;

		hr = ProcessProductFamily(pNodeProductFamily);
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessStart\n"));
#endif

  return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessProductFamily
//   This function is the root of the function tree. It gets the children
//   of <ProductFamily> and process them by calling their corresponding
//   tree process functions
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessProductFamily(PIXMLDOMNode &pNodeProductFamily)
{
	HRESULT hr = S_OK;

	PIXMLDOMNode pNode = NULL; 
	PIXMLDOMNode pNodeSkuManagement = NULL;
	PIXMLDOMNode pNodeModules = NULL;

	SkuSet *pskuSetInputSkuFilter = NULL;

	assert(pNodeProductFamily != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeProductFamily)));
#endif

	// Process <SkuManagement> 
	if(SUCCEEDED(hr = GetChildNode(pNodeProductFamily, 
								   rgXMSINodes[SKUMANAGEMENT].szNodeName, 
								   pNodeSkuManagement)))
	{
		if (pNodeSkuManagement == NULL) 
		{
			_tprintf(TEXT("Compile Error: Missing required entity <%s>.\n"),
								rgXMSINodes[SKUMANAGEMENT].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			hr = ProcessSkuManagement(pNodeSkuManagement);
		}
	}

	// Process the Sku Filter specified from command line
	hr = ProcessSkuFilter(g_szInputSkuFilter, &pskuSetInputSkuFilter);

#ifdef DEBUG
	if (SUCCEEDED(hr))
	{
		_tprintf(TEXT("The Command Line Sku Filter:\n"));
		pskuSetInputSkuFilter->print();
		_tprintf(TEXT("\n"));
	}
#endif
	
	// Process <Information> <Directories> <InstallLevels> <Features>
	if (SUCCEEDED(hr))
	{
		assert(pskuSetInputSkuFilter != NULL);
		g_pskuSet = new SkuSet(*pskuSetInputSkuFilter);
		assert(g_pskuSet != NULL);

		hr = ProcessChildrenArray_H_XIS(pNodeProductFamily, 
									rgNodeFuncs_ProductFamily_SKU,
									cNodeFuncs_ProductFamily_SKU,
									NULL, pskuSetInputSkuFilter);
	}

	if (pskuSetInputSkuFilter)
		delete pskuSetInputSkuFilter;

	// at this point, a component list has been established
	// process them
	if (SUCCEEDED(hr))
		hr = ProcessComponents();

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessProductFamily\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessSkuManagement
//   This function processes <SkuManagement> node and its children:
//		<SKUs> and <SkuGroups>
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSkuManagement(PIXMLDOMNode &pNodeSkuManagement)
{
	HRESULT hr = S_OK;
	PIXMLDOMNode pNodeSkus = NULL;
	PIXMLDOMNode pNodeSkuGroups = NULL;
	int cSkus = 0;  // # Skus defined in the input package. This will be the
					// length of each SkuSet

	assert(pNodeSkuManagement != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeSkuManagement)));
#endif

	// (1) Process <SKUs> tag
	if(SUCCEEDED(hr = GetChildNode(pNodeSkuManagement, 
						rgXMSINodes[SKUS].szNodeName, pNodeSkus)))
	{
		if (pNodeSkus == NULL) 
		{
			_tprintf(TEXT("Compile Error: Missing required entity <%s>.\n"),
								rgXMSINodes[SKUS].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			hr = ProcessSkus(pNodeSkus, &cSkus);
		}
	}

	// (2) Process <SkuGroups> tag
	if(SUCCEEDED(hr = GetChildNode(pNodeSkuManagement, 
						rgXMSINodes[SKUGROUPS].szNodeName, pNodeSkuGroups)))
	{
		if (pNodeSkuGroups != NULL) 
			hr = ProcessSkuGroups(pNodeSkuGroups, cSkus);
	}


#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessSkuManagement\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessSkus
//   This function processes <SKUs> tag:
//		1) Process each defined <SKU> tag and create a Sku object for
///			each one of them.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSkus(PIXMLDOMNode &pNodeSkus, int *pcSkus)
{
	HRESULT hr = S_OK;
	PIXMLDOMNodeList pNodeListSkus = NULL;

	assert(pNodeSkus != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeSkus)));
#endif

	// get the list of <SKU>s
	if (SUCCEEDED(hr = GetChildrenNodes(pNodeSkus,
								rgXMSINodes[SKU].szNodeName,
								pNodeListSkus)))
	{
		if (SUCCEEDED(hr = pNodeListSkus->get_length((long *)pcSkus)))
		{
			if (0 == *pcSkus)
			{
			   _tprintf(TEXT("Compile Error: Missing required entity <%s>.\n"),
								rgXMSINodes[SKU].szNodeName);

				hr = E_FAIL;
			}
			else // Allocate memory for the global Skus array 
			{
				g_cSkus = *pcSkus;
				g_rgpSkus = new Sku*[*pcSkus];
				for (int i=0; i<g_cSkus; i++)
					g_rgpSkus[i] = NULL;
			}

		}
	}

	// Process all Children <SKU>s
	if (SUCCEEDED(hr))
	{
		for (long i=0; i<*pcSkus; i++)
		{
			PIXMLDOMNode pNodeSku = NULL;
			// get the node
			if (SUCCEEDED(hr = pNodeListSkus->get_item(i, &pNodeSku)))
			{
				if (pNodeSku != NULL)
					hr = ProcessSku(pNodeSku, i, *pcSkus);
				if (FAILED(hr))
					break;
			}
			else
			{
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_item\n"));
				break;
			}
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessSkus\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessSku
//   This function processes <SKU> tag:
//		1) construct a SkuSet object and insert into global map
//			(a SKU is a SkuGroup of just one element)
//		2) Update the global SKU array;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSku(PIXMLDOMNode &pNodeSku, int iIndex, int cSkus)
{			
	HRESULT hr = S_OK;
	LPTSTR szID = NULL; // ID of a SKU

	assert(pNodeSku != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeSku)));
#endif

	// get ID attribute and assign to szID
	if(SUCCEEDED(hr = GetID(pNodeSku, szID))) 
	{
		if (NULL == szID)
		{
			_tprintf(
			TEXT("Compile Error: Missing required attribute \'ID\' on <%s>\n"),
				rgXMSINodes[SKU].szNodeName);
			hr = E_FAIL;
		}
	}

	// construct a SkuSet object and insert into global map
	if (SUCCEEDED(hr))
	{
		SkuSet *pSkuSet = new SkuSet(cSkus);
		if (pSkuSet == NULL)
		{
			_tprintf(TEXT("Internal Error: Failed to create a new")
					 TEXT("SkuSet object\n"));
			hr = E_FAIL;
		}
		else 
		{
			pSkuSet->set(iIndex);// ith bit in the bit field represent this SKU
			assert(0 == g_mapSkuSets.count(szID)); // IDs shouldn't duplicate
			g_mapSkuSets.insert(LS_ValType(szID, pSkuSet));
		}
	}

	// reserve the spot in the global SKU array
	if (SUCCEEDED(hr))
	{
		g_rgpSkus[iIndex] = new Sku(szID);
	}


#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessSku\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessSkuGroups
//   This function processes <SkuGroups> tag:
//		1) Process each defined <SkuGroup> tag and create a SkuSet object for
//			each one of them.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSkuGroups(PIXMLDOMNode &pNodeSkuGroups, int cSkus)
{
	HRESULT hr = S_OK;
	long iListLength = 0;
	PIXMLDOMNodeList pNodeListSkuGroups = NULL;

	assert(pNodeSkuGroups != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeSkuGroups)));
#endif

	// get the list of <SkuGroup>s
	if (SUCCEEDED(hr = GetChildrenNodes(pNodeSkuGroups,
								rgXMSINodes[SKUGROUP].szNodeName,
								pNodeListSkuGroups)))
	{
		if (SUCCEEDED(hr = pNodeListSkuGroups->get_length(&iListLength)))
		{
			// Process all Children <SkuGroup>s
			for (long i=0; i<iListLength; i++)
			{
				PIXMLDOMNode pNodeSkuGroup = NULL;
				// get the node
				if (SUCCEEDED
					(hr = pNodeListSkuGroups->get_item(i, &pNodeSkuGroup)))
				{
					if (pNodeSkuGroup != NULL)
					{
						// get ID attribute
						LPTSTR szID = NULL; 
						if(FAILED(hr = GetID(pNodeSkuGroup, szID)))
							break;							
						if (NULL == szID)
						{
							_tprintf(
							TEXT("Compile Error: Missing required ")
							TEXT("attribute \'ID\' on <%s>\n"),
								rgXMSINodes[SKUGROUP].szNodeName);
							hr = E_FAIL;
							break;
						}

						// It is possible that this SkuGroup is referenced
						// from inside other SkuGroups and thus has already
						// been processed. So only process it if it hasn't
						// been processed.
						if (0 == g_mapSkuSets.count(szID))
						{
							// set is used to detect circular references
							set<LPTSTR, Cstring_less> *pSet 
								= new set<LPTSTR, Cstring_less>;

							hr = ProcessSkuGroup(pNodeSkuGroup, szID, 
															pSet, cSkus);

							delete pSet;
						}
					}
					if (FAILED(hr))
						break;
				}
				else
				{
					_tprintf(TEXT("Internal Error: Failed to make ")
							 TEXT("DOM API call: get_item\n"));
					break;
				}
			}
		}
		else
		{
			_tprintf(TEXT("Internal Error: Failed to make ")
					 TEXT("DOM API call: get_length\n"));
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessSkuGroups\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessSkuGroup
//   This recursive function processes <SkuGroup> tag:
//		1) construct a SkuSet object and insert into global map
//			(a SKU is a SkuGroup of just one element)
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSkuGroup(PIXMLDOMNode &pNodeSkuGroup, LPTSTR szID,
						set<LPTSTR, Cstring_less> *pSet, int cSkus)
{			
	HRESULT hr = S_OK;
	long iListLength = 0;
	PIXMLDOMNodeList pNodeListSkuGroups = NULL;

	assert(pNodeSkuGroup != NULL);

#ifdef DEBUG
	_tprintf(TEXT("Processing <SkuGroup> ID = %s\n"), szID);
#endif

	pSet->insert(szID); // mark that this SkuGroup is being processed

	SkuSet *pSkuSet = new SkuSet(cSkus);

	// construct a SkuSet object for this SkuGroup
	if (SUCCEEDED(hr))
	{
		if (pSkuSet == NULL)
		{
			_tprintf(TEXT("Internal Error: Failed to create")
					 TEXT("a new SkuSet object\n"));
			hr = E_FAIL;
		}
	}

	// Get the list of children <SkuGroup>s
	if (SUCCEEDED(hr))
	{
		if (SUCCEEDED(hr = GetChildrenNodes(pNodeSkuGroup,
									rgXMSINodes[SKUGROUP].szNodeName,
									pNodeListSkuGroups)))
		{
			if(FAILED(hr = pNodeListSkuGroups->get_length(&iListLength)))      
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_length\n"));
		}
	}

	// recursively process all the children <SkuGroup>
	if (SUCCEEDED(hr))
	{
		// Process all Children <SkuGroup>s
		for (long i=0; i<iListLength; i++)
		{
			PIXMLDOMNode pNodeChild = NULL;
			// get the node
			if (SUCCEEDED
				(hr = pNodeListSkuGroups->get_item(i, &pNodeChild)))
			{
				if (pNodeChild != NULL)
				{
					// get ID attribute
					LPTSTR szChildID = NULL; 
					if(FAILED(hr = GetID(pNodeChild, szChildID)))
						break;							
					if (NULL == szChildID)
					{
						_tprintf(
							TEXT("Compile Error: Missing required ")
							TEXT("attribute \'ID\' on <%s>\n"),
								rgXMSINodes[SKUGROUP].szNodeName);
						hr = E_FAIL;
						break;
					}
					
					// Process this child <SkuGroup> if it hasn't been
					//	processed
					if (0 == g_mapSkuSets.count(szChildID))
					{
						if (FAILED(hr = ProcessSkuGroup(pNodeChild, 
												szChildID, pSet, cSkus)))
							break;
						assert(0 != g_mapSkuSets.count(szChildID));
						*pSkuSet |= *(g_mapSkuSets[szChildID]);
					}
					else
					{
						*pSkuSet |= *(g_mapSkuSets[szChildID]);
						delete[] szChildID;
					}
				}
			}
			else
			{
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_item\n"));
				break;
			}
		}
	}

	// Process the "SKUs" attribute of this <SkuGroup>
	if (SUCCEEDED(hr))
	{
		LPTSTR szSKUs = NULL;
		IntStringValue isValSKUs;
		int i=0;
		if (SUCCEEDED(hr = ProcessAttribute(pNodeSkuGroup, TEXT("SKUs"), STRING, 
											&isValSKUs, NULL)))
		{
			// "SKUs" attribute exists
			if (S_FALSE != hr)
			{
				szSKUs = isValSKUs.szVal;
				TCHAR *ptch1 = szSKUs;
				TCHAR *ptch2 = NULL;

				// Process all the SKUGroup members
				while (true)
				{
					// (1) parse the string containing all members
					// skip white spaces at the head
					while(_istspace(*ptch1)) ptch1++;					
					if (TEXT('\0') == *ptch1) break;
					ptch2 = ptch1;
					// search for the end of this SkuGroup member
					while(!_istspace(*ptch2) && *ptch2 != TEXT('\0')) 
						ptch2++;
					int iLength = ptch2-ptch1+1;
					LPTSTR szSkuGroupMember = new TCHAR[iLength];
					for (int j=0; j<iLength-1; j++)
						szSkuGroupMember[j] = *ptch1++;
					szSkuGroupMember[iLength-1] = TEXT('\0');

					// (2) check for circular reference
					if (0 != pSet->count(szSkuGroupMember))
					{
					  _tprintf(TEXT("Compile Error: Circular Reference: %s\n")
					TEXT(" in the declaration of <SkuGroup ID=\"%s\">\n"),
						  szSkuGroupMember, szID);
					  hr = E_FAIL;
					  break;
					}

					// (3) Process this member if it hasn't been
					//	    processed
					if (0 == g_mapSkuSets.count(szSkuGroupMember))
					{
						// Form the XPath query:  
						//		/SkuGroup[ @ID = "szSkuGroupMember"]
						int iLength = _tcslen(szSkuGroupMember);
						LPTSTR szXPath = new TCHAR[iLength+61];
						if (!szXPath)
						{
							_tprintf(TEXT("Error: Out of memory\n"));
							hr = E_FAIL;
							break;
						}

						_stprintf(szXPath, 
		TEXT("/ProductFamily/SkuManagement/SkuGroups//SkuGroup[ @ID = \"%s\"]"),
										szSkuGroupMember);
						
						BSTR bstrXPath = NULL;

						if (NULL == (bstrXPath = LPTSTRToBSTR(szXPath)))
						{
						   _tprintf(TEXT("Error: String conversion failed\n"));
							hr = E_FAIL;
							break;
						}
						// get the <SkuGroup> node with ID=szSkuGroupMember 
						// and pass it to ProcessSkuGroup
						PIXMLDOMNode pNodeChild = NULL;
						if(SUCCEEDED(hr = 
							pNodeSkuGroup->selectSingleNode
											(bstrXPath, &pNodeChild)))
						{
							assert(pNodeChild != NULL);
							if(FAILED
								(hr = ProcessSkuGroup(pNodeChild, 
											szSkuGroupMember, pSet, cSkus)))
								break;
						}
						else
						{
							_tprintf(TEXT("Internal Error: Failed to make ")
									 TEXT("DOM API call: get_item\n"));
							SysFreeString(bstrXPath);
							break;
						}
						SysFreeString(bstrXPath);
						// Now this member is processed and is in the 
						// global map
						assert(0 != g_mapSkuSets.count(szSkuGroupMember));
						*pSkuSet |= *(g_mapSkuSets[szSkuGroupMember]);
					}
					else
					{
						*pSkuSet |= *(g_mapSkuSets[szSkuGroupMember]);
						delete[] szSkuGroupMember;
					}

					if (TEXT('\0') == *ptch2) break;
				}

				delete[] szSKUs;
			}
		}
	}

	// insert this SkuGroup into the global map
	if (SUCCEEDED(hr))
		g_mapSkuSets.insert(LS_ValType(szID, pSkuSet));


	if (FAILED(hr)) 
	{
		if (pSkuSet)
			delete pSkuSet;
		if (szID)
			delete szID;
#ifdef DEBUG
		_tprintf(TEXT("Error in function: ProcessSku\n"));
#endif
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessInformation
//   This function processes <Information> node:
//         1) create the output database;
///		   2) create the Property Table and write several properties into it;
//         3) write several properties into the summary information stream;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessInformation_SKU(PIXMLDOMNode &pNodeInformation, 
						   const IntStringValue *isVal_In, SkuSet *pskuSet)
{
	HRESULT hr = S_OK;
	UINT iWordCount = 0;
	PIXMLDOMNode pNode = NULL; 

	assert(pNodeInformation != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeInformation)));
#endif

	// Process <InstallerVersionRequired> and <PackageFileName>
	hr = ProcessChildrenArray_H_XIS(pNodeInformation, 
								   rgNodeFuncs_Information_SKU,
								   cNodeFuncs_Information_SKU, 
								   NULL, pskuSet);


	// process nodes in rgChildren_Information: <ProductName> <ProductCode>
	//	<UpgradeCode> <ProductVersion> <Manufacturer> <Keywords> <Template>
	if (SUCCEEDED(hr))
	{
		hr = ProcessChildrenArray_H_XIS(pNodeInformation, 
									   rgNodeFuncs_Information2_SKU,
									   cNodeFuncs_Information2_SKU, 
								       NULL, pskuSet);
	}

	if (SUCCEEDED(hr))
	{
		ElementEntry *pEEWordCount = new ElementEntry(1, pskuSet);
		pEEWordCount->SetValType(INTEGER, 1);
		if (SUCCEEDED(hr = 
						ProcessOnOffAttributes_SKU(pNodeInformation, 
												   rgAttrBits_WordCount,
												   cAttrBits_WordCount, 
												   pEEWordCount, 1, pskuSet)))
		{
			pEEWordCount->Finalize();

			SkuSet skuSetCommon = pEEWordCount->GetCommonSkuSet();
			SkuSet skuSetUncommon = SkuSetMinus(*pskuSet, skuSetCommon);
			int iCommon = pEEWordCount->GetCommonValue(1).intVal;

			// process Common values
			if (!skuSetCommon.testClear())
			{
				for (int i=0; i<g_cSkus; i++)
				{
					if (skuSetCommon.test(i))
					{
					//	printf("%s: %d\n", g_rgpSkus[i]->GetID(), iCommon);
						if (FAILED(hr = 
									MsiSummaryInfoSetProperty(
												g_rgpSkus[i]->m_hSummaryInfo,
												PID_WORDCOUNT, VT_I4, iCommon,
												NULL, NULL)))
						{
							_tprintf(TEXT("Error: Failed to insert WordCount")
									 TEXT(" Property into the Summary ")
									 TEXT("information stream for SKU\n;"),
									g_rgpSkus[i]->GetID());
							break;
						}
					}
				}
			}

			// process uncommon values
			if (!skuSetUncommon.testClear())
			{
				for (int i=0; i<g_cSkus; i++)
				{
					if (skuSetUncommon.test(i))
					{
						int iWordCount = pEEWordCount->GetValue(1, i).intVal;

					//	printf("%s: %d\n", g_rgpSkus[i]->GetID(), iWordCount);
						if (FAILED(hr = 
									MsiSummaryInfoSetProperty(
												g_rgpSkus[i]->m_hSummaryInfo,
												PID_WORDCOUNT, VT_I4,
												iWordCount, NULL, NULL)))
						{
							_tprintf(TEXT("Error: Failed to insert WordCount")
									 TEXT("Property into the Summary")
									 TEXT("information stream for SKU\n;"),
									 g_rgpSkus[i]->GetID());
							break;
						}
					}
				}
			}
				
		}

		delete pEEWordCount;
	}
		
#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessInformation_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessInstallerVersionRequired
//   This function processes <InstallerVersionRequired> node:
//         1) Choose a proper template MSI file to read in database schema
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessInstallerVersionRequired_SKU
		(PIXMLDOMNode &pNodeInstallerVersionRequired, 
						   const IntStringValue *isVal_In, SkuSet *pskuSet)
{
	HRESULT hr = S_OK;
	IntStringValue isValInstallerVersion;
	isValInstallerVersion.intVal = 120; // the default value

	assert(pNodeInstallerVersionRequired != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeInstallerVersionRequired)));
#endif

	// Get the Value of the required Windows Installer Version
	if (SUCCEEDED(hr = ProcessAttribute(pNodeInstallerVersionRequired, 
						rgXMSINodes[INSTALLERVERSIONREQUIRED].szAttributeName,
							INTEGER, &isValInstallerVersion, pskuSet)))
	{
		if (isValInstallerVersion.intVal <= 120)
		{
		// open the template database which is used to read in the database 
		//	schema for each SKU
			for (int i=0; i<g_cSkus; i++)
			{
				if (pskuSet->test(i))
				{
					if (ERROR_SUCCESS != MsiOpenDatabase
			   (TEXT("Schema.msi"),
								MSIDBOPEN_READONLY, 
								&g_rgpSkus[i]->m_hTemplate))
					{
						_tprintf(
							TEXT("Error: Failed to open the template ")
							TEXT("database for SKU: %s\n"), 
								g_rgpSkus[i]->GetID());
						hr = E_FAIL;
						break;
					}
				}
			}
		}	
		else 
		{
			// Issue: need to add more templates corresponding to different
			//	MSI version
			_tprintf(TEXT("Error: Invalid value of")
					 TEXT("<InstallerVersionRequired>: %d\n"),
					 isValInstallerVersion.intVal);
			hr = E_FAIL;
		}
	}

#ifdef DEBUG
	if (FAILED(hr))	
	   _tprintf(TEXT("Error in function: ")
				TEXT("ProcessInstallerVersionRequired_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessPackageFileName
//   This function processes <PackageFileName> node:
//         1) Use the specified pathname to open the output MSI database
//            and obtain the handle;
//		   2) Use the database handle to obtain the handle to the summary info
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessPackageFilename_SKU(PIXMLDOMNode &pNodePackageFilename, 
								   const IntStringValue *isVal_In, 
								   SkuSet *pskuSet)
{
	HRESULT hr = S_OK;
	IntStringValue isValPackageName;

	UINT errorCode = ERROR_SUCCESS;

	assert(pNodePackageFilename != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodePackageFilename)));
#endif

	pskuSet->print();

	// get the specified output package name
	if (SUCCEEDED(hr = ProcessAttribute(pNodePackageFilename, 
								rgXMSINodes[PACKAGEFILENAME].szAttributeName,
								STRING, &isValPackageName, pskuSet)))
	{
		// open the output DB for each SKU
		for (int i=0; i<g_cSkus; i++)
		{
			if (pskuSet->test(i))
			{
				printf("%s\n", isValPackageName.szVal);
				// get the database handle
				if (ERROR_SUCCESS != 
						(errorCode = MsiOpenDatabase(isValPackageName.szVal, 
						  							 MSIDBOPEN_CREATE,
												&g_rgpSkus[i]->m_hDatabase)))
				{
					PrintError(errorCode);
					_tprintf(TEXT("Error: Failed to create a new database ")
							 TEXT("for SKU %s\n"), g_rgpSkus[i]->GetID());
					hr = E_FAIL;
					break;
				}

				// get the Summary Infomation handle
				if (ERROR_SUCCESS != MsiGetSummaryInformation
											(g_rgpSkus[i]->m_hDatabase, 0, 50,
											&g_rgpSkus[i]->m_hSummaryInfo))
				{
					_tprintf(TEXT("Error: Failed to get the summary ")
							TEXT("information handle for SKU %s\n"),
							g_rgpSkus[i]->GetID());
					hr = E_FAIL;
					break;
				}
				
				// Auto-generate a package code for this SKU
				if (FAILED(hr = 
					GeneratePackageCode(g_rgpSkus[i]->m_hSummaryInfo)))
				{
					_tprintf(TEXT("Error: Failed to generate PackageCode")
						 TEXT(" for SKU %s\n"), g_rgpSkus[i]->GetID());
					break;
				}				
			}
		}

		delete[] isValPackageName.szVal;
	}

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessPackageFilename_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessInformationChildren
//   This function processes the following children of <Information>:
//	  <Codepage> <ProductName> <ProductCode> <UpgradeCode> <ProductVersion> 
//	  <Keywords> <Template>.
//
// After the desired value is retrieved, the compiler will insert the value
// into Property table, SummaryInfo, or both     
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessInformationChildren_SKU(PIXMLDOMNode &pNodeInfoChild, 
									   const IntStringValue *pisVal_In, 
									   SkuSet *pskuSet)
{
	HRESULT hr = S_OK;
	int i = pisVal_In->intVal;

	// get the information needed from global array
    LPTSTR szAttributeName = 
		rgXMSINodes[rgChildren_Information[i].enumNodeIndex].szAttributeName;
    LPTSTR szPropertyName = rgChildren_Information[i].szPropertyName;
    INFODESTINATION enumDestination = 
		rgChildren_Information[i].enumDestination;
    UINT uiPropertyID = rgChildren_Information[i].uiPropertyID;
	VARTYPE vt = rgChildren_Information[i].vt;
	bool bIsGUID = rgChildren_Information[i].bIsGUID;

	IntStringValue isVal;

	assert(pNodeInfoChild != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeInfoChild)));
#endif


	// create Property table for those SKUs that haven't had one
	hr = CreateTable_SKU(TEXT("Property"), pskuSet);

	if (SUCCEEDED(hr))
	{
		if (SUCCEEDED(hr = ProcessAttribute(pNodeInfoChild, 
							szAttributeName, STRING, &isVal, pskuSet)))
		{	
			// if this is a GUID, needs format it: convert to upper case 
			// and surround it with { }
			if (bIsGUID)						
				hr = FormatGUID(isVal.szVal);
				
			if (SUCCEEDED(hr))
			{
				// insert into Property table
				if ((PROPERTY_TABLE == enumDestination) || 
									(BOTH == enumDestination))
				{
					hr = InsertProperty(szPropertyName, isVal.szVal, pskuSet, 
										/*iSkuIndex*/-1);
				}
	
				//insert into Summary Info
				if (SUCCEEDED(hr))
				{
					if ((SUMMARY_INFO == enumDestination) || 
										(BOTH == enumDestination))
					{
						int iVal = _ttoi(isVal.szVal);
						for (int i=0; i<g_cSkus; i++)
						{
							if (pskuSet->test(i))
							{
								switch (vt) {
									case VT_I2:
									case VT_I4:
									{
										if (ERROR_SUCCESS != 
												MsiSummaryInfoSetProperty(
												  g_rgpSkus[i]->m_hSummaryInfo,
												  uiPropertyID, vt, iVal, 
												  NULL, NULL))
										{
											_tprintf(
												TEXT("Error: Failed to insert")
												TEXT("%s into Summary Info ")
												TEXT("for SKU %s\n"), 
												szPropertyName,
												g_rgpSkus[i]->GetID());
											hr = E_FAIL;							
										}
										break;
									}
									case VT_FILETIME:
										//do nothing yet
										break;
									case VT_LPSTR:
									{
										if (ERROR_SUCCESS != 
												MsiSummaryInfoSetProperty(
												  g_rgpSkus[i]->m_hSummaryInfo,
												  uiPropertyID, vt, 0, NULL, 
												  isVal.szVal))
										{
											_tprintf(
												TEXT("Error: Failed to insert")
												TEXT("%s into Summary Info")
												TEXT(" for SKU %s\n"), 
												szPropertyName,
												g_rgpSkus[i]->GetID());
											hr = E_FAIL;																						
										}
										break;
									}
									default:
										assert(true);
								}
							}

							if (FAILED(hr))
								break;
						}
					}
				}
			}
			delete[] isVal.szVal;
		}
	}
	
#ifdef DEBUG
	if (FAILED(hr))	
		_tprintf(TEXT("Error in function: ProcessInformationChildren_SKU\n"));
#endif

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessDirectories
//   This function processes <Directories> node:
//         1) Create Directory Table;
///		   2) Insert "TARGETDIR", NULL, "SourceDir" into the first row of the 
//			  Directory table
//         3) Process its children <Diretory> nodes and insert into the table
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessDirectories_SKU(PIXMLDOMNode &pNodeDirectories, 
							   const IntStringValue *pIsVal, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeDirectories != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeDirectories)));
#endif

	// create Directory table for those SKUs that haven't had one
	hr = CreateTable_SKU(TEXT("Directory"), pSkuSet);

	if (SUCCEEDED(hr))
	{
		if (SUCCEEDED(hr = InsertDirectory(TEXT("TARGETDIR"), NULL, 
										TEXT("SourceDir"), pSkuSet, 
										/*iSkuIndex*/-1)))
		{
			IntStringValue isValParentDir;
			isValParentDir.szVal = TEXT("TARGETDIR");
			hr = ProcessChildrenList_SKU(pNodeDirectories, DIRECTORY,
										 /*bIsRequired*/false, isValParentDir,
										 ProcessDirectory_SKU,
										 pSkuSet); 
		}
	}

	PrintMap_DirRef(g_mapDirectoryRefs_SKU);

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessDirectories\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// a set of small help functions so that ProcessDirectory won't grow too big!

// return E_FAIL if <TargetProperty> and <TargetDir> coexists
HRESULT CheckTargetDir_TargetProperty(LPCTSTR szTargetProperty, 
									  LPCTSTR szDefaultDir,
									  SkuSet *pSkuSet,
									  int iSkuIndex)
{
	assert(szDefaultDir);

	HRESULT hr = S_OK;

	if (_tcschr(szDefaultDir, TEXT(':'))/* <TargetDir> exists */ &&
		szTargetProperty/*<TargetProptery> exists*/)
	{
		_tprintf(TEXT("Compile error: <%s> and <%s> coexists for SKU: \n"),
				 rgXMSINodes[TARGETDIR].szNodeName, 
				 rgXMSINodes[TARGETPROPERTY].szNodeName);
		if (pSkuSet)
			PrintSkuIDs(pSkuSet);
		else
		{
			assert(iSkuIndex>=0 && iSkuIndex<g_cSkus);
			_tprintf(TEXT("%s\n"), g_rgpSkus[iSkuIndex]->GetID());
		}

		hr = E_FAIL;
	}

	return hr;
}

// Return the value of primary key (Directory column)
void GetPrimaryKey(LPTSTR *pszDirectory, LPCTSTR szID)
{
	if (*pszDirectory)
	{
		// make a copy so that the value won't be destroyed after
		// deleting the ElementEntry object
		*pszDirectory = _tcsdup(*pszDirectory);
		return;
	}

	if (szID)
	{
		*pszDirectory = _tcsdup(szID);
		assert(*pszDirectory);
	}
	else
	{
		*pszDirectory = GetName(TEXT("Directory"));
		assert(*pszDirectory);
	}
}

// insert the directory reference into global data structure
void InsertDirRef(LPTSTR szID, LPTSTR szDirectory, SkuSet *pSkuSet, 
				  int iSkuIndex)
{
	if (!szID) return;

	IntStringValue isValDirectory;
	isValDirectory.szVal = szDirectory;

	// construct a SkuSetValues object if there isn't one
	// in the slot corresponding to szID
	if (!g_mapDirectoryRefs_SKU.count(szID))
	{
		SkuSetValues *pSkuSetValues = new SkuSetValues;
		assert(pSkuSetValues);
		pSkuSetValues->SetValType(STRING);
		g_mapDirectoryRefs_SKU.insert
			(map<LPTSTR, SkuSetValues *, Cstring_less>::value_type
				(szID, pSkuSetValues));							
	}

	// insert the directory reference together with its
	// associated SkuSet into the global data structure
	SkuSet *pSkuSetTemp = new SkuSet(g_cSkus);
	assert(pSkuSetTemp);
	if (pSkuSet)
		*pSkuSetTemp = *pSkuSet;
	else
	{
		assert(iSkuIndex>=0 && iSkuIndex<g_cSkus);
		pSkuSetTemp->set(iSkuIndex);
	}
	g_mapDirectoryRefs_SKU[szID]->CollapseInsert(pSkuSetTemp, 
												 isValDirectory, false);
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessDirectory
//   This is a recursive function.
//         1) Process the current <Diretory> node and insert info into the 
//			  Directory table;
//         2) Call itself to process its children <Directory> nodes;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessDirectory_SKU(PIXMLDOMNode &pNodeDirectory, 
							 IntStringValue isValParentDir, 
							 SkuSet *pSkuSet)
{
	assert(pNodeDirectory != NULL);

	HRESULT hr = S_OK;

	SkuSet skuSetCommon(g_cSkus);
	LPTSTR szDirectoryCommon = NULL;

	// Construct an ElementEntry object. 
	ElementEntry *pEEDirectory = new ElementEntry(2, pSkuSet);
	assert(pEEDirectory);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeDirectory,
						rgXMSINodes[DIRECTORY].szAttributeName, STRING, 
						&isValID, pSkuSet);

#ifdef DEBUG
	if (isValID.szVal)
		_tprintf(TEXT("Processing <Directory ID=\"%s\">\n"), isValID.szVal);
	else
		_tprintf(TEXT("Processing <Directory> without ID specified\n"));
#endif

	if (SUCCEEDED(hr))
	{
		// Call ProcessChildrenArray to get back column values of all SKUs 
		// via the ElementEntry object
		hr = ProcessChildrenArray_H_XIES(pNodeDirectory, rgNodeFuncs_Directory,
										 cNodeFuncs_Directory, pEEDirectory, 
										 pSkuSet);
	}

	// Process Common values first
	if (SUCCEEDED(hr))
	{
		pEEDirectory->Finalize();

		skuSetCommon = pEEDirectory->GetCommonSkuSet();

		printf("Common Set:");
		skuSetCommon.print();

		if (!skuSetCommon.testClear())
		{
			szDirectoryCommon = pEEDirectory->GetCommonValue(1).szVal;
			LPTSTR szDefaultDirCommon = pEEDirectory->GetCommonValue(2).szVal;

			// check that <TargetDir> and <TargetProperty> don't coexist
			hr = CheckTargetDir_TargetProperty(szDirectoryCommon, 
											   szDefaultDirCommon,
											   &skuSetCommon, -1);
			if (SUCCEEDED(hr))
			{
				GetPrimaryKey(&szDirectoryCommon, isValID.szVal);

				// insert into DB
				hr = InsertDirectory(szDirectoryCommon, isValParentDir.szVal,
									 szDefaultDirCommon, &skuSetCommon, -1);
			}
		}
		else
			szDirectoryCommon = isValID.szVal;
	}


	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					LPTSTR szDirectory = pEEDirectory->GetValue(1, i).szVal;
					LPTSTR szDefaultDir = pEEDirectory->GetValue(2, i).szVal;

					// check that <TargetDir> and <TargetProperty> don't 
					// coexist
					hr = CheckTargetDir_TargetProperty(szDirectory, 
													   szDefaultDir,
													   NULL, i);
					if (FAILED(hr)) break;
					// generate Primary Key: Directory column
					GetPrimaryKey(&szDirectory, isValID.szVal);

					// insert into DB
					hr = InsertDirectory(szDirectory, isValParentDir.szVal,
										 szDefaultDir, NULL, i);

					if (FAILED(hr)) 
					{
						delete[] szDirectory;
						break;
					}

					// if the primary key is the same as the common case,
					// put this Sku on the common SkuSet because only
					// the primary key matters for the next 2 steps:
					// store the reference and recursively process children
					if (0 == _tcscmp(szDirectory, szDirectoryCommon))
					{
						delete[] szDirectory;
						skuSetCommon.set(i);
					}
					else // otherwise perform the next 2 steps
					{
						// insert the ref into global data structure
						if (isValID.szVal)
							InsertDirRef(isValID.szVal, szDirectory, NULL, i);

						// recursively process all the children <Directory>s
						IntStringValue isValDirectory;
						isValDirectory.szVal = szDirectory;
						SkuSet skuSetTemp(g_cSkus);
						skuSetTemp.set(i);
						hr = ProcessChildrenList_SKU(pNodeDirectory, DIRECTORY,
													 /*bIsRequired*/false, 
													 isValDirectory,
													 ProcessDirectory_SKU,
													 &skuSetTemp);
						if (!isValID.szVal)
							delete[] szDirectory;
						
						if (FAILED(hr)) break;
					}
				}
			}
		}
	}

	// finally perform the last 2 steps for the common set
	// Insert the Directory ref into global data structure
	if (SUCCEEDED(hr))
	{
		if (isValID.szVal)
			InsertDirRef(isValID.szVal, szDirectoryCommon, &skuSetCommon, -1);

		// recursively process all the children <Directory>s
		IntStringValue isValDirectory;
		isValDirectory.szVal = szDirectoryCommon;
		hr = ProcessChildrenList_SKU(pNodeDirectory, DIRECTORY,
									 /*bIsRequired*/false, isValDirectory,
									 ProcessDirectory_SKU,
									 &skuSetCommon);
	}
		
	delete pEEDirectory;

	if (!isValID.szVal)
		delete[] szDirectoryCommon;

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessDirectory_SKU\n"));
#endif

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// FormDefaultDir: form TargetDir:Name for DefaultDir column 
////////////////////////////////////////////////////////////////////////////
HRESULT FormDefaultDir(IntStringValue *pIsValOut, IntStringValue isValName, 
							  IntStringValue isValTargetDir)
{
	int iLength = _tcslen(isValName.szVal) + _tcslen(isValTargetDir.szVal);
	pIsValOut->szVal = new TCHAR[iLength+2]; 
	assert(pIsValOut->szVal);

	_stprintf(pIsValOut->szVal, TEXT("%s:%s"), 
						isValTargetDir, isValName);

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessName
// This function process <Name> node under <Directory>. It writes the value
// obtained into the ElementEntry object *pEE
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessName(PIXMLDOMNode &pNodeName, int iColumn, ElementEntry *pEE,
					SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeName);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeName)));
#endif

	// Get the value of <Name>. It is either short or short|Long 
	IntStringValue isValName;
	hr = ProcessShortLong_SKU(pNodeName, &isValName, pSkuSet);

	// insert the value into the ElementEntry. Because both
	// <Name> and <TargetDir> could update the value of 
	// "DefaultDir" column, use SetValueSplit.
	if (SUCCEEDED(hr))
		hr = pEE->SetValueSplit(isValName, iColumn, pSkuSet, NULL);

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessName\n"));
#endif
	
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessTargetDir
// This function process <TargetDir> node under <Directory>. It writes the 
// value obtained into the ElementEntry object *pEE
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessTargetDir(PIXMLDOMNode &pNodeTargetDir, int iColumn, 
						 ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeTargetDir);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeTargetDir)));
#endif

	// Get the value of <TargetDir>. It is either short or short|Long 
	IntStringValue isValTargetDir;
	hr = ProcessShortLong_SKU(pNodeTargetDir, &isValTargetDir, pSkuSet);

	// insert the value into the ElementEntry. Because both
	// <Name> and <TargetDir> could update the value of 
	// "DefaultDir" column, use SetValueSplit.
	if (SUCCEEDED(hr))
		hr = pEE->SetValueSplit(isValTargetDir, iColumn, pSkuSet, 
								FormDefaultDir);

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessTargetDir\n"));
#endif

	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessTargetProperty
// This function process <TargetProperty> node under <Directory>. It writes 
// the value obtained into the ElementEntry object *pEE
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessTargetProperty(PIXMLDOMNode &pNodeTargetProperty, int iColumn, 
							  ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeTargetProperty);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeTargetProperty)));
#endif

	// Get the value of <TargetProperty>. It is either short or short|Long 
	IntStringValue isValTargetProperty;
	hr = ProcessAttribute(pNodeTargetProperty, 
						  rgXMSINodes[TARGETPROPERTY].szAttributeName,
						  STRING, &isValTargetProperty, pSkuSet);

	if (SUCCEEDED(hr))
		hr = pEE->SetValue(isValTargetProperty, iColumn, pSkuSet);	
	
#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessTargetProperty\n"));
#endif

	return hr;
}
 
////////////////////////////////////////////////////////////////////////////
// Helper function used by ProcessInstallLevels to update the data structure
// storing the least possible numeric intalllevel value for each SKU.
////////////////////////////////////////////////////////////////////////////
HRESULT UpdateLevel(IntStringValue *pisValOut, IntStringValue isValOld,
					IntStringValue isValNew)
{
	HRESULT hr = S_OK;

	if (-1 == isValNew.intVal)
	{
		// This is a <InstallLevel> w/o specified value
		if (-1 == isValOld.intVal)
			// This is the second <InstallLevel> tag for this Sku
			pisValOut->intVal = 1;
		else
			pisValOut->intVal = isValOld.intVal + 1;
	}
	else // isValNew contains the Value specified by the input package
	{
		if (-1 == isValOld.intVal)
			isValOld.intVal = 0;
		// checking for if the specified value is possible or not
		if (isValNew.intVal < ++(isValOld.intVal))
		{
			hr = E_FAIL;
			_tprintf(
				TEXT("Compile Error: the value specified %d is too small ")
				TEXT("(the minimal possible value is: %d) "),
				isValNew.intVal, isValOld.intVal);
			pisValOut->intVal = -2;
		}
		else
		{
			pisValOut->intVal = isValNew.intVal;
		}
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessInstallLevels
//   This function processes <InstallLevels> node:
//         1) process its children <InstallerLevel>s, either get the
//			 specified value or assign each <InstalerLevel> a numeric value i
//			 and insert each <ID, i> into g_mapInstallLevelRefs for future
//			 look-up;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessInstallLevels_SKU(PIXMLDOMNode &pNodeInstallLevels, 
								 const IntStringValue *pisVal, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	
	PIXMLDOMNodeList pNodeListInstallLevels = NULL;
	long iListLength = 0;

	assert(pNodeInstallLevels != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeInstallLevels)));
#endif

	// Retrieve the list of <InstallLevel>s
	if (SUCCEEDED(hr = GetChildrenNodes(pNodeInstallLevels,
								rgXMSINodes[XMSI_INSTALLLEVEL].szNodeName,
								pNodeListInstallLevels)))
	{
		if (FAILED(hr = pNodeListInstallLevels->get_length(&iListLength)))
			_tprintf(
			  TEXT("Error: Internal error. DOM API call get_length failed\n"));
	}

	// process all the <InstallLevel>s
	if (SUCCEEDED(hr))
	{
	
		// The data structure is used to store the
		// least possible values that each Sku can take
		// as InstallLevel
		SkuSetValues *pSkuSetValues = new SkuSetValues;
		assert(pSkuSetValues);
		pSkuSetValues->SetValType(INSTALL_LEVEL);

		for (long i=0; i<iListLength; i++)
		{
			PIXMLDOMNode pNodeInstallLevel = NULL;
			IntStringValue isValID;
			SkuSet *pSkuSetChild = NULL;

			// Get the node and its SkuSet, ID.
			if (SUCCEEDED(hr = 
				pNodeListInstallLevels->get_item(i, &pNodeInstallLevel)))
			{
				assert(pNodeInstallLevel != NULL);
				// Get the SkuSet specified for this child
				if (SUCCEEDED(hr = 
								GetSkuSet(pNodeInstallLevel, &pSkuSetChild)))
				{
					assert (pSkuSetChild != NULL);

					// if the child node doesn't have a SKU filter specified,
					//  it inherits the SKU filter from its parent
					*pSkuSetChild &= *pSkuSet;

					// No need to process this node if it doesn't apply to
					// any SKU
					if (pSkuSetChild->testClear())
					{
						delete pSkuSetChild;
						continue;
					}
				}
				else
					break;

				// get ID
				if (SUCCEEDED(hr = 
					ProcessAttribute(pNodeInstallLevel, TEXT("ID"),
									 STRING, &isValID, pSkuSetChild)))
				{
					if (S_FALSE == hr)
					{
						_tprintf(TEXT("Compile Error: Missing required")
								 TEXT("\'ID\' attribute for <%s>"),
							rgXMSINodes[XMSI_INSTALLLEVEL].szNodeName);
						hr = E_FAIL;
						delete pSkuSetChild;
						break;
					}
				}
				else
				{
					delete pSkuSetChild;
					break;
				}
			}
			else 
			{
				_tprintf(
				 TEXT("Internal Error: DOM API call \'get_item\' failed"));
		
				break;
			}
			
			// Process the node

			// get Value if there is one specified
			IntStringValue isValInstallLevel_User;
			hr = ProcessAttribute(pNodeInstallLevel, TEXT("Value"), 
								  INTEGER, &isValInstallLevel_User,
								  pSkuSetChild);

			if (SUCCEEDED(hr))
			{
				// if there is no value specified, initialize to -1
				// it cannot be 0 since 0 is an acceptable value.
				// UpdateLevel needs to be able to tell that there
				// is no value specified just by looking at the value
				// passed in.
				if (S_FALSE == hr)
					isValInstallLevel_User.intVal = -1;

				// update the data structure to reflect the newest 
				// value. make a copy of pSkuSetTemp since it will
				// be destroyed inside SplitInsert
				SkuSet *pSkuSetTemp = new SkuSet(g_cSkus);
				*pSkuSetTemp = *pSkuSetChild;
				hr = pSkuSetValues->SplitInsert(pSkuSetTemp, 
												isValInstallLevel_User,
												UpdateLevel);
				if (SUCCEEDED(hr))
				{
					// query the data structure to get back a SkuSetValues 
					// object that will be stored globally
					SkuSetValues *pSkuSetValuesRetVal = NULL;
					hr = pSkuSetValues->GetValueSkuSet(pSkuSetChild, 
													   &pSkuSetValuesRetVal);

					// insert into the global data structure
					if (SUCCEEDED(hr))
					{
						// each <InstallLevel> should have a unique ID
					   assert(!g_mapInstallLevelRefs_SKU.count(isValID.szVal));
					   g_mapInstallLevelRefs_SKU.insert
						(map<LPTSTR, SkuSetValues *, Cstring_less>::value_type
										(isValID.szVal, pSkuSetValuesRetVal));	
					}
					else
						delete isValID.szVal;
				}
				else
				{
					_tprintf(TEXT("for <%s ID=\"%s\">\n"), 
						rgXMSINodes[XMSI_INSTALLLEVEL].szNodeName,
						isValID.szVal);
					delete isValID.szVal;
				}
				delete pSkuSetChild;

				if(FAILED(hr)) break;
			}
			else
			{
				delete isValID.szVal;
				delete pSkuSetChild;
				break;
			}
		}
		delete(pSkuSetValues);
	}	

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessInstallLevels_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFeatures
//   This function processes <Features> node:
//         1) Call ProcessChildrenList to Process its children <Feature> nodes
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFeatures_SKU(PIXMLDOMNode &pNodeFeatures, 
						const IntStringValue *pisVal, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeFeatures != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeFeatures)));
#endif

	// create Feature table for those SKUs that haven't had one
	hr = CreateTable_SKU(TEXT("Feature"), pSkuSet);

	IntStringValue isValParentFeature;
	isValParentFeature.szVal = NULL;
	hr = ProcessChildrenList_SKU(pNodeFeatures, FEATURE,
								 /*bIsRequired*/true, isValParentFeature,
								 ProcessFeature_SKU,
								 pSkuSet); 

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessFeatures_SKU\n"));
#endif
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessFeature
//   This is a recursive function:
//         1) Process <Title> <Description> <DisplayState> <Dir> <State> 
//			  <ILevel> (w/o Condition field) entities that belong to the 
//			  current <Feature> entity and insert into Feature table;
//		   2) Process <ILevel> (w/ condition field) and insert into Condition
//			  table
//         3) Process <UseModule> entity and therefore trigger the processing
//			   of all the components used by this feature
//         4) Call itself to process its children <Feature> nodes;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessFeature_SKU(PIXMLDOMNode &pNodeFeature, 
					   IntStringValue isValParentFeature, 
					   SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	assert(pNodeFeature != NULL);

	// Values to be inserted into the DB 
	LPTSTR szFeature = NULL;
	LPTSTR szFeatureParent = isValParentFeature.szVal;
	LPTSTR szTitle = NULL;
	LPTSTR szDescription = NULL;
	int iDisplay = MSI_NULL_INTEGER;
	int iInstallLevel = MSI_NULL_INTEGER;
	LPTSTR szDirectory = NULL;
	UINT iAttribute = MSI_NULL_INTEGER;

	SkuSet skuSetCommon(g_cSkus);

	// Construct an ElementEntry object. 
	ElementEntry *pEEFeature = new ElementEntry(6, pSkuSet);
	assert(pEEFeature);

	// Get ID attribute if there is one
	IntStringValue isValID;
	isValID.szVal = NULL;
	hr = ProcessAttribute(pNodeFeature,
						rgXMSINodes[FEATURE].szAttributeName, 
						STRING, &isValID, pSkuSet);

	if (SUCCEEDED(hr))
	{
		if (S_FALSE == hr)
		{
			_tprintf(TEXT("Compile Error: Missing required")
					 TEXT("\'%s\' attribute for <%s>"),
					rgXMSINodes[FEATURE].szAttributeName,
					rgXMSINodes[FEATURE].szNodeName);
			hr = E_FAIL;
		}
		else
			szFeature = isValID.szVal;
	}

#ifdef DEBUG
	if (SUCCEEDED(hr))
		_tprintf(TEXT("Processing <Feature ID=\"%s\">\n"), isValID.szVal);
#endif

	if (SUCCEEDED(hr))
	{
		// Call ProcessChildrenArray to get back column values of all SKUs 
		// via the ElementEntry object
		hr = ProcessChildrenArray_H_XIES(pNodeFeature, rgNodeFuncs_Feature_SKU,
										 cNodeFuncs_Feature_SKU, pEEFeature, 
										 pSkuSet);
	}

	// Process Common values first
	if (SUCCEEDED(hr))
	{
		pEEFeature->Finalize();

		skuSetCommon = pEEFeature->GetCommonSkuSet();

		if (!skuSetCommon.testClear())
		{
			szTitle = pEEFeature->GetCommonValue(1).szVal;
			szDescription = pEEFeature->GetCommonValue(2).szVal;
			iDisplay = pEEFeature->GetCommonValue(3).intVal;
			iInstallLevel = pEEFeature->GetCommonValue(4).intVal;
			szDirectory = pEEFeature->GetCommonValue(5).szVal;
			iAttribute = pEEFeature->GetCommonValue(6).intVal;

			// insert into DB
			hr = InsertFeature(szFeature, szFeatureParent, szTitle, 
							   szDescription, iDisplay, iInstallLevel, 
							   szDirectory, iAttribute, &skuSetCommon, -1);
		}
	}

	// process exceptional values
	if(SUCCEEDED(hr))
	{
		SkuSet skuSetUncommon = SkuSetMinus(*pSkuSet, skuSetCommon);
		if (!skuSetUncommon.testClear())
		{
			for (int i=0; i<g_cSkus; i++)
			{
				if (skuSetUncommon.test(i))
				{
					szTitle = pEEFeature->GetValue(1,i).szVal;
					szDescription = pEEFeature->GetValue(2,i).szVal;
					iDisplay = pEEFeature->GetValue(3,i).intVal;
					iInstallLevel = pEEFeature->GetValue(4,i).intVal;
					szDirectory = pEEFeature->GetValue(5,i).szVal;
					iAttribute = pEEFeature->GetValue(6,i).intVal;
			
					// insert into DB
					hr = InsertFeature(szFeature, szFeatureParent, szTitle, 
									   szDescription, iDisplay, iInstallLevel,
									   szDirectory, iAttribute, NULL, i);
				}
			}
		}
	}

	delete pEEFeature;

	// Process conditionalized <ILevel> nodes
	if (SUCCEEDED(hr))
	{
		hr = ProcessILevelCondition(pNodeFeature, szFeature, pSkuSet);
	}

	// Process <UseModule>s
	if (SUCCEEDED(hr))
		hr = ProcessChildrenList_SKU(pNodeFeature, USEMODULE, 
									 /*bIsRequired*/false, isValID,
									 ProcessUseModule_SKU, pSkuSet);

	/* Issue: if the feature ID will be referenced later, the compiler
			  should store the reference for checking the SKU ownership
			  of a feature. (one SkU shouldn't refer to a feature that
			  doesn't belong to it) */

	// recursively process children <Feature>s
	if (SUCCEEDED(hr))
		// recursively process all the children <Feature>s
		hr = ProcessChildrenList_SKU(pNodeFeature, FEATURE,
									 /*bIsRequired*/false, isValID,
									 ProcessFeature_SKU,
									 pSkuSet);

	if (isValID.szVal)
		delete[] isValID.szVal;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessFeature_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessDisplayState
//   This function:
//         1) Process <DisplayState> entity and store the value inside
//			  the ElementEntry object;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessDisplayState_SKU(PIXMLDOMNode &pNodeDisplayState, int iColumn,  
							 ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeDisplayState != NULL);
	assert(pEE);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeDisplayState)));
#endif

	int iDisplay = 0;
	IntStringValue isVal;
	NodeIndex ni = pEE->GetNodeIndex(iColumn);

	// Get the Value of Value Attribute of <DisplayState>
	if (SUCCEEDED(hr = ProcessAttribute(pNodeDisplayState, 
										rgXMSINodes[ni].szAttributeName,
										STRING, &isVal, pSkuSet)))
	{
		if (NULL == isVal.szVal)
		{
			_tprintf(
			TEXT("Compile Error: Missing required attribute \'%s\' of <%s>\n"), 
				rgXMSINodes[ni].szAttributeName, rgXMSINodes[ni].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			if (0 != _tcscmp(isVal.szVal, TEXT("Hidden")))
			{
				iDisplay = GetUniqueNumber();

				if (0 == _tcscmp(isVal.szVal, TEXT("Collapsed")))
				{
					iDisplay *= 2;
				}
				else if (0 == _tcscmp(isVal.szVal, TEXT("Expanded")))
				{
					iDisplay = iDisplay*2 + 1;
				}
				else
				{
					_tprintf(TEXT("Compiler Error:  \'%s\' attribute ")
							 TEXT("of <%s> has an unrecognized value\n"),
							 rgXMSINodes[ni].szAttributeName,
							 rgXMSINodes[ni].szNodeName);
				}
			}

			delete[] isVal.szVal;

			isVal.intVal = iDisplay;
				// insert the value into the ElementEntry.
			hr = pEE->SetValue(isVal, iColumn, pSkuSet);
		}
	}
	
#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessDisplayState_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessState
// This function processes <State> entity under <Feature> 
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessState_SKU(PIXMLDOMNode &pNodeState, int iColumn, 
							 ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeState != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeState)));
#endif

	// Process <Favor> child
	hr = ProcessEnumAttributes(pNodeState, FAVOR, rgEnumBits_Favor_Feature,
							   cEnumBits_Favor_Feature, pEE, iColumn, pSkuSet);

	// Process <Advertise> child
	if (SUCCEEDED(hr))
		hr = ProcessEnumAttributes(pNodeState, ADVERTISE, 
								  rgEnumBits_Advertise_Feature,
								  cEnumBits_Advertise_Feature, pEE, 
								  iColumn, pSkuSet);

	// Process all on/off children elements
	if (SUCCEEDED(hr))
		hr = ProcessOnOffAttributes_SKU(pNodeState, rgAttrBits_Feature,
						cAttrBits_Feature, pEE, iColumn, pSkuSet);
#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessState_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Function: ProcessILevelCondition
//		This function processes <ILevel> node that has a Condition attribute
//		specified and insert into Condition table.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessILevelCondition(PIXMLDOMNode &pNodeFeature, LPTSTR szFeature,
							   SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	PIXMLDOMNodeList pNodeListILevelConditions = NULL;
	long iListLength = 0;
	// used to validate the one SKU doesn't refer to the same Ref 
	// more than once. (Ref is part of the primary key in the Condition
	// table.
	map<LPTSTR/*Ref*/, SkuSet *, Cstring_less> mapValidateUniqueRef; 

#ifdef DEBUG
	_tprintf(TEXT("Inside Function: ProcessILevelCondition\n"));
#endif

	assert(pNodeFeature != NULL);

	// get the list of <ILevel Condition="..."> nodes
	if(SUCCEEDED(hr = GetChildrenNodes(pNodeFeature, 
									   rgXMSINodes[ILEVELCONDITION].szNodeName,
									   pNodeListILevelConditions)))
	{
		if(FAILED(hr = pNodeListILevelConditions->get_length(&iListLength)))
		{
			_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
				 TEXT("get_length\n"));
			iListLength = 0;
		}
	}

	// process each ILevelCondition node in the list
	for (long l=0; l<iListLength; l++)
	{
		PIXMLDOMNode pNodeILevelCondition = NULL;
		if (SUCCEEDED(hr = 
			pNodeListILevelConditions->get_item(l, &pNodeILevelCondition)))
		{	
			assert(pNodeILevelCondition != NULL);
			// Get the SkuSet specified for this ILevelCondition node
			SkuSet *pSkuSetILevelCondition = NULL;
			if (SUCCEEDED(hr = GetSkuSet(pNodeILevelCondition, 
										 &pSkuSetILevelCondition)))
			{
				assert (pSkuSetILevelCondition != NULL);

				// if this node doesn't have a SKU filter specified,
				//  it inherits the SKU filter from its parent
				// Also get rid of those Skus specified in this node
				// but not in its parent
				*pSkuSetILevelCondition &= *pSkuSet;

				// only keep processing if the SkuSet is not empty
				if (!pSkuSetILevelCondition->testClear())
				{
					// create Condition table
					hr = CreateTable_SKU(TEXT("Condition"), 
										 pSkuSetILevelCondition);
					IntStringValue isValCondition;
					isValCondition.szVal = NULL;
					// get the value of Condition attribute
					if (SUCCEEDED(hr))
					{
						hr = ProcessAttribute(pNodeILevelCondition, 
											  TEXT("Condition"), STRING,
											  &isValCondition, 
											  pSkuSetILevelCondition);
					}

					if (SUCCEEDED(hr))
					{
						// get the Value of the Ref attribute
						IntStringValue isValRef;
						if (SUCCEEDED
							(hr = ProcessAttribute(pNodeILevelCondition,
												   TEXT("Ref"),
												   STRING, &isValRef, 
												   pSkuSetILevelCondition)))
						{
							if (NULL == isValRef.szVal)
							{
								_tprintf(
									TEXT("Compile Error: Missing required ")
									TEXT("attribute \'Ref\' of")
									TEXT(" <ILevel Condition=\"%s\">\n"),
									isValCondition.szVal);

								hr = E_FAIL;
							}
						}

						if (SUCCEEDED(hr))
						{
							// check for Uniqueness of Ref
							if (mapValidateUniqueRef.count(isValRef.szVal))
							{
								SkuSet skuSetTemp 
									= *mapValidateUniqueRef[isValRef.szVal] &
									  *pSkuSetILevelCondition;

								if (!skuSetTemp.testClear())
								{
									// Error happened. Duplicate <Feature, Ref>
									// for the same SKU
									_tprintf(TEXT("Compile Error:")
											 TEXT("<ILevel Ref=\"%s\" ")
											 TEXT("Condition=\"%s\"> ")
											 TEXT("Duplicate ILevel for SKU "),
											 isValRef.szVal, 
											 isValCondition.szVal);
									PrintSkuIDs(&skuSetTemp);
									hr = E_FAIL;
								}
								else
								{
									// update the SkuSet that contains this Ref
									*mapValidateUniqueRef[isValRef.szVal] |=
										*pSkuSetILevelCondition;
								}
							}
							else
							{
								// make a copy of pSkuSetILevelCondition
								// and insert into the map
								SkuSet *pSkuSetTemp = new SkuSet(g_cSkus);
								*pSkuSetTemp = *pSkuSetILevelCondition;
								mapValidateUniqueRef.insert(
									LS_ValType(isValRef.szVal, 
											   pSkuSetTemp));
							}
						}

						// get the real values of the Ref. It is a list
						// of values since <InstallLevel> is Skuable.
						if (SUCCEEDED(hr))
						{
							SkuSetValues *pSkuSetValuesRetVal = NULL;
							// The ILevel referred should be in the 
							// data structure already
							assert(0 != g_mapInstallLevelRefs_SKU.count
															(isValRef.szVal));

							// return a list of <SkuSet, InstallLevel> pairs
							hr = g_mapInstallLevelRefs_SKU[isValRef.szVal]->
										GetValueSkuSet(pSkuSetILevelCondition, 
													   &pSkuSetValuesRetVal);

							if (FAILED(hr))
							{
								_tprintf(
									TEXT("are trying to reference %s which is ")
									TEXT("undefined inside them\n"),
									 isValRef.szVal);
							}
							else
							{
								// Finally we can insert into the DB
								SkuSetVal *pSkuSetValTemp = NULL;
								for (pSkuSetValTemp = 
											pSkuSetValuesRetVal->Start();
									 pSkuSetValTemp != 
											pSkuSetValuesRetVal->End();
									 pSkuSetValTemp = 
											pSkuSetValuesRetVal->Next())
								{
									hr = InsertCondition(szFeature, 
												pSkuSetValTemp->isVal.intVal,
												isValCondition.szVal, 
												pSkuSetValTemp->pSkuSet,
												-1);
									if(FAILED(hr))	break;
								}
								delete pSkuSetValuesRetVal;
							}
						}

						if (0 == mapValidateUniqueRef.count(isValRef.szVal))
							delete[] isValRef.szVal;
					}
					delete[] isValCondition.szVal;
				}
				delete pSkuSetILevelCondition;
			}
		}
		else
		{
			_tprintf(TEXT("Internal Error: Failed to make ")
					 TEXT("DOM API call: get_item\n"));
			break;
		}
		if (FAILED(hr))	break;
	}

	// Free memory referenced from map
	map<LPTSTR, SkuSet *, Cstring_less>::iterator it;
	for (it = mapValidateUniqueRef.begin(); 
		 it != mapValidateUniqueRef.end(); 
		 ++it)
	{
		delete[] (*it).first;
		delete (*it).second;
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessILevelCondition\n"));
#endif

	return hr;
}  

////////////////////////////////////////////////////////////////////////////
// The following set of functions: ProcessUseModule, ProcessModule, and
// ProcessComponentRel are used to form 3 kinds of information:
//		1) a Component list that stores all the components to be processed
//		   together with their associated SkuSet;
//		2) for each component: a list of feature ids for the FeatureComponent
//		   table and the ownership information for Shortcuts, Classes, 
//		   Typelibs, Extensions, and QualifiedComponents;
//		3) for each SKU, a list of Module IDs that will be installed in 
//		   that SKU. This is used for checking the DependOn relationship
////////////////////////////////////////////////////////////////////////////

// check if all the Skus in the SkuSet own the Module. Need to check
// the SkuSet information of the given Module and its ancestors up to
// <Modules> entity.
//
// Issue: Not implemented for now. 
HRESULT CheckModuleSku(PIXMLDOMNode &pNodeModule, SkuSet *ppSkuSet)
{
	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessUseModule
//   This function:
//         1) Process <UseModule> entity to get the Module reference
//		   2) Process the <TakeOwnership> entity
//         3) Call ProcessModule and pass along the ownership information
//			  thus trigger the process described above
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessUseModule_SKU(PIXMLDOMNode &pNodeUseModule, 
							 IntStringValue isValFeature,  
							 SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	IntStringValue isValRef;
	isValRef.szVal = NULL;
	PIXMLDOMNode pNodeModule = NULL;
	ElementEntry *pEEOwnership = NULL;

	assert(pNodeUseModule != NULL);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeUseModule)));
#endif

	pEEOwnership = new ElementEntry(1, pSkuSet);
	assert(pEEOwnership);
	// Process <TakeOwnerShip>
	hr = ProcessChildrenArray_H_XIES(pNodeUseModule, rgNodeFuncs_UseModule,
									 cNodeFuncs_UseModule, pEEOwnership, 
									 pSkuSet);

	if (SUCCEEDED(hr))
	{
		// Get Ref attribute of <UseModule>
		if (SUCCEEDED(hr = ProcessAttribute(pNodeUseModule,  
										rgXMSINodes[USEMODULE].szAttributeName,
										STRING, &isValRef, pSkuSet)))
		{
			if (NULL == isValRef.szVal)
			{
				_tprintf(TEXT("Compile Error: Missing required attribute")
						 TEXT("\'%s\' of <%s>\n"), 
						 rgXMSINodes[USEMODULE].szAttributeName,
						 rgXMSINodes[USEMODULE].szNodeName);
				hr = E_FAIL;
			}
		}

		if (SUCCEEDED(hr))
		{
			// Form the XPath query:  
			//			ProductFamily/Modules//Module[ @ID = "sz"]
			int iLength = _tcslen(isValRef.szVal);
			LPTSTR szXPath = new TCHAR[iLength+61];
			assert(szXPath);
			_stprintf(szXPath, 
				TEXT("/ProductFamily/Modules//Module[ @ID = \"%s\"]"), 
				isValRef.szVal);
			
			BSTR bstrXPath = NULL;

			if (NULL != (bstrXPath = LPTSTRToBSTR(szXPath)))
			{
				// get the referred <Module> node and pass it to 
				//	ProcessModule
				if(SUCCEEDED(hr = 
					pNodeUseModule->selectSingleNode(bstrXPath,
														&pNodeModule)))
				{
					// check if every SKU in *pSkuSet owns the
					// Module referred to. 
					hr = CheckModuleSku(pNodeModule, pSkuSet);

					if (SUCCEEDED(hr))
					{
						SkuSetValues *pSkuSetValuesOwnership = 
							pEEOwnership->GetColumnValue(1);

						FOM *pFOM = new FOM;
						pFOM->szFeature = isValFeature.szVal;
						pFOM->szModule = isValRef.szVal;

						hr = ProcessModule_SKU(pNodeModule, pFOM,
										   pSkuSetValuesOwnership, pSkuSet);
						delete pFOM;
					}
				}
				SysFreeString(bstrXPath);
			}
			else 
			{
				hr = E_FAIL;
				_tprintf(TEXT("Internal Error: string conversion ")
						 TEXT("failed.\n"));
			}

			delete[] szXPath;
			delete[] isValRef.szVal;
		}
	}

	delete pEEOwnership;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessUseModule\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessTakeOwnership
//		This function processes <TakeOwnership> entity under <UseModule>.
//		It forms a bit field represent the ownership information of 5 different
//		entities: ShortCut, Class, TypeLib, Extenstion, QualifiedComponent
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessTakeOwnership(PIXMLDOMNode &pNodeTakeOwnership, int iColumn, 
							 ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeTakeOwnership != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeTakeOwnership)));
#endif

	// Process all on/off children elements <OwnShortcuts>
	// <OwnClasses> <OwnTypeLibs> <OwnExtensions> <OwnQualifiedComponents>
	hr = ProcessOnOffAttributes_SKU(pNodeTakeOwnership, 
									rgAttrBits_TakeOwnership,
									cAttrBits_TakeOwnership, 
									pEE, iColumn, pSkuSet);

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessTakeOwnership\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessModule
//   This is a recursive function:
//         1) Process <Module> entity;
//         2) Call ProcessComponentRel on all the components belonged to this 
//				<Module>;
//         3) Recursively process all children <Module>s;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessModule_SKU(PIXMLDOMNode &pNodeModule, FOM *pFOM, 
						  SkuSetValues *pSkuSetValuesOwnership, 
						  SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;
	assert(pFOM);

	IntStringValue isValID;
	// get ID attribute
	if(SUCCEEDED(hr = ProcessAttribute(pNodeModule, TEXT("ID"), STRING, 
									   &isValID, pSkuSet))) 
	{
		if (NULL == isValID.szVal)
		{
			_tprintf(
			TEXT("Compile Error: Missing required attribute \'ID\' on <%s>\n"),
				rgXMSINodes[MODULE].szNodeName);
			hr = E_FAIL;
		}
		else
			_tprintf(TEXT("Processing Module ID = %s\n"), isValID.szVal);
	}

	if (SUCCEEDED(hr))
	{
		// add this module ID to the module list of each SKU object
		// in *pSkuSet
		for (int i=0; i<g_cSkus; i++)
		{
			if (pSkuSet->test(i))
				g_rgpSkus[i]->SetOwnedModule(pFOM->szModule);
		}
		
		// skuSetCheckModule will contain those SKUs in which there is no
		// <Module> child of this <Module>
		SkuSet skuSetCheckModule(g_cSkus);
		// Retrieve the list of children <Component>s and process all of them
		hr = ProcessChildrenList_SKU(pNodeModule, COMPONENT, false, pFOM, 
									 pSkuSetValuesOwnership, 
									 ProcessComponentRel,
									 pSkuSet, &skuSetCheckModule);

		// Recursively Process all the children <Module>s of this <Module>
		if (SUCCEEDED(hr))
		{
			// skuSetCheckModule will contain those SKUs in which there is no
			// <Module> child of this <Module>
			SkuSet skuSetCheckComponent(g_cSkus);
			hr = ProcessChildrenList_SKU(pNodeModule, MODULE, false, pFOM, 
										 pSkuSetValuesOwnership, 
										 ProcessModule_SKU,
										 pSkuSet, &skuSetCheckComponent);
			if (SUCCEEDED(hr))
			{
				// check for empty Module declaration
				SkuSet skuSetTemp = skuSetCheckComponent & skuSetCheckModule;
				if (!skuSetTemp.testClear())
				{
					//the SKUs in skuSetTemp have an empty module
					_tprintf(TEXT("Compile Error: Empty Module ID = %s ")
							 TEXT("for SKU "), isValID.szVal);
					PrintSkuIDs(&skuSetTemp);
					hr = E_FAIL;
				}
			}
		}
		delete[] isValID.szVal;
	}
	
#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessModule_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessComponentRel
//   This functions established all component-related relationships w/o
//	 processing the sub-entities of the component:
//         1) If this component hasn't been processed yet, create a new
//			  Component object and insert into the global map;
//         2) Update the set of SKUs that will install this Component;
//		   3) Update the set of features that use this Component;
//		   4) Update the owner ship information of this Component;
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessComponentRel(PIXMLDOMNode &pNodeComponent, FOM *pFOM,
						  SkuSetValues *pSkuSetValuesOwnership, 
						  SkuSet *pSkuSet)
{
	assert(pFOM);

	HRESULT hr = S_OK;
	Component *pComponent = NULL;

	// Get Component ID
	IntStringValue isValID;
	isValID.szVal = NULL;
	if(SUCCEEDED(hr = ProcessAttribute(pNodeComponent, TEXT("ID"), STRING,
									   &isValID, pSkuSet)))
	{
		if (NULL == isValID.szVal)
		{
			_tprintf(
			TEXT("Compile Error: Missing required attribute \'ID\' on <%s>\n"),
				rgXMSINodes[COMPONENT].szNodeName);
			hr = E_FAIL;
		}
	}
	
#ifdef DEBUG
	if (isValID.szVal)
		_tprintf(TEXT("Processing Component ID = %s\n"), isValID.szVal);
#endif

	if (SUCCEEDED(hr))
	{
		// if this component hasn't been touched before, create a new
		// Component object and insert into the global map
		if (0 == g_mapComponents.count(isValID.szVal))
		{
			pComponent = new Component();
			assert(pComponent);

			g_mapComponents.insert(LC_ValType(isValID.szVal, pComponent));
		}
		else
			pComponent = g_mapComponents[isValID.szVal];

		pComponent->m_pNodeComponent = pNodeComponent;
		// update the set of SKUs that will install this Component
		pComponent->SetSkuSet(pSkuSet);
		// update the set of Features that use this Component
		pComponent->SetUsedByFeature(pFOM->szFeature, pSkuSet);
		// update the ownership information
		if (pSkuSetValuesOwnership)
		{
			hr = pComponent->SetOwnership(pFOM, pSkuSetValuesOwnership);
			if (FAILED(hr))
				_tprintf(TEXT("when processing Component ID= %s\n"),
						 isValID.szVal);
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessComponentRel\n"));
#endif

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\query.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       query.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// query.h
//		A simple MSI View wrapper
// 

#ifndef _MSI_SQL_QUERY_H_
#define _MSI_SQL_QUERY_H_

#include <stdio.h>
#include <stdarg.h>
#include <tchar.h>
#include "msiquery.h"

/////////////////////////////////////////////////////////////////////////////
// CQuery

class CQuery
{
public:
	CQuery();
	~CQuery();

	// basic operations
	UINT Open(MSIHANDLE hDatabase, LPCTSTR szSQLFormat, ...);
	UINT Close();
	UINT Execute(MSIHANDLE hParams = NULL);
	UINT Fetch(MSIHANDLE* phRecord);
	UINT Modify(MSIMODIFY eInfo, MSIHANDLE hRec);
	UINT GetError();
	inline MSIDBERROR GetError(LPTSTR szBuf, unsigned long &cchBuf)
	{ return ::MsiViewGetError(m_hView, szBuf, &cchBuf); }
	inline bool IsOpen() { return (m_hView != 0); }
	
	UINT GetColumnInfo(MSICOLINFO eInfo, MSIHANDLE* phRec);

	// "advanced" operations
	UINT OpenExecute(MSIHANDLE hDatabase, MSIHANDLE hParam, 
		LPCTSTR szSQLFormat, ...);
	UINT FetchOnce(MSIHANDLE hDatabase, MSIHANDLE hParam, 
		MSIHANDLE* phRecord, LPCTSTR szSQLFormat, ...);

private:
	MSIHANDLE m_hView;
};	// end of CQuery

/////////////////////////////////////////////////////////////////////////////
// CManageTable -- Simple class to manage a table held in memory.  Ensures
//                 that a table is "freed" from memory for each hold count
//                 that the class knows about.  
//
//  use fAlreadyLocked=true to specify that the table that is being managed
//   has already had a hold applied
class CManageTable
{
public:
	 CManageTable(MSIHANDLE hDatabase, LPCTSTR szTable, bool fAlreadyLocked);
	~CManageTable();

	// basic operations
	UINT LockTable();       // add a hold count to the table
	UINT UnLockTable();     // release a hold count from the table
	void AddLockCount();    // some other query added a hold count, 
							//	so increase the lock count
	void RemoveLockCount(); // some other query removed a hold count, 
							// so decrease the lock count

private: // private data
	int       m_iLockCount;  // hold count on table, release called in 
							 // destructor for each hold count until 0
	TCHAR	  m_szTable[64]; // name of table held in memory
	MSIHANDLE m_hDatabase;   // handle to database
};

#endif	// _MSI_SQL_QUERY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\mainfuncs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       mainFuncs.h
//              This file contains the main function and functions that 
//				process <Information> <Directories> <InstallLEvels <Features> 
//              and their subentities
//--------------------------------------------------------------------------

#ifndef XMSI_MAINFUNCS_H
#define XMSI_MAINFUNCS_H

#include "wmc.h"
#include "Utilities.h"

HRESULT ProcessStart(BSTR);
HRESULT ProcessProductFamily(PIXMLDOMNode &);
	HRESULT ProcessSkuManagement(PIXMLDOMNode &);
		HRESULT ProcessSkus(PIXMLDOMNode &pNodeSkus, int *pcSkus);
			HRESULT ProcessSku(PIXMLDOMNode &pNodeSku, int iIndex, int cSkus);
		HRESULT ProcessSkuGroups(PIXMLDOMNode &pNodeSkuGroups, int cSkus);
			HRESULT ProcessSkuGroup(PIXMLDOMNode &pNodeSkuGroup, LPTSTR szID,
								   set<LPTSTR, Cstring_less> *pSet, int cSkus);
	HRESULT ProcessInformation_SKU(PIXMLDOMNode &pNodeInformation, 
						   const IntStringValue *isVal_In, SkuSet *pskuSet);
		HRESULT ProcessInstallerVersionRequired_SKU
				(PIXMLDOMNode &pNodeInstallerVersionRequired, 
						   const IntStringValue *isVal_In, SkuSet *pskuSet);
		HRESULT ProcessPackageFilename_SKU(PIXMLDOMNode &pNodePackageFilename, 
										const IntStringValue *isVal_In, 
										SkuSet *pskuSet);
		HRESULT ProcessInformationChildren_SKU(PIXMLDOMNode &pNodeInfoChild, 
									   const IntStringValue *pisVal_In, 
									   SkuSet *pskuSet);
	HRESULT ProcessDirectories_SKU(PIXMLDOMNode &pNodeDirectories, 
								   const IntStringValue *pIsVal, 
								   SkuSet *pSkuSet);
		HRESULT ProcessDirectory_SKU(PIXMLDOMNode &pNodeDirectory, 
		 							 IntStringValue isValParentDir, 
									 SkuSet *pSkuSet);
			HRESULT ProcessName(PIXMLDOMNode &pNodeName, int iColumn, 
								ElementEntry *pEE, SkuSet *pSkuSet);
			HRESULT ProcessTargetDir(PIXMLDOMNode &pNodeTargetDir, int iColumn, 
									 ElementEntry *pEE, SkuSet *pSkuSet);
			HRESULT ProcessTargetProperty(PIXMLDOMNode &pNodeTargetProperty, 
										 int iColumn, ElementEntry *pEE,
										 SkuSet *pSkuSet);
	HRESULT ProcessInstallLevels_SKU(PIXMLDOMNode &pNodeInstallLevels, 
									const IntStringValue *pisVal, 
									SkuSet *pSkuSet);
	HRESULT ProcessFeatures_SKU(PIXMLDOMNode &pNodeFeatures, 
						const IntStringValue *pisVal, SkuSet *pSkuSet);
		HRESULT ProcessFeature_SKU(PIXMLDOMNode &pNodeFeature, 
								   IntStringValue isValParentFeature, 
								   SkuSet *pSkuSet);
			HRESULT ProcessDisplayState_SKU(PIXMLDOMNode &pNodeDisplayState, 
											int iColumn, ElementEntry *pEE, 
											SkuSet *pSkuSet);
			HRESULT ProcessState_SKU(PIXMLDOMNode &pNodeState, int iColumn, 
							 ElementEntry *pEE, SkuSet *pSkuSet);
			HRESULT ProcessILevelCondition(PIXMLDOMNode &pNodeFeature, 
										   LPTSTR szFeature, SkuSet *pSkuSet);
			HRESULT ProcessUseModule_SKU(PIXMLDOMNode &pNodeUseModule, 
										 IntStringValue isValFeature,  
										 SkuSet *pSkuSet);
				HRESULT ProcessTakeOwnership(PIXMLDOMNode &pNodeTakeOwnership, 
					int iColumn, ElementEntry *pEE, SkuSet *pSkuSet);
				HRESULT ProcessModule_SKU(PIXMLDOMNode &pNodeModule, FOM *pFOM, 
										  SkuSetValues *pSkuSetValuesOwnership,
										  SkuSet *pSkuSet);
				HRESULT ProcessComponentRel(PIXMLDOMNode &pNodeModule, 
										FOM *pFOM,
										SkuSetValues *pSkuSetValuesOwnership,
										SkuSet *pSkuSet);
HRESULT ProcessComponents();
///////////////////////////////////////////////////////////////////////////////
// Data structures dealing with creating DB tables
typedef struct
{
	UINT uiInstallerVersion;
	LPTSTR szTemplateDB;
} TemplateDB;

TemplateDB rgTemplateDBs[] = {
	{120,	TEXT("d:\\nt\\admin\\darwin\\src\\msitools\\xmsi\\Schema.msi")	}
};

class TemplateDBSchema
{
public:
	MSIHANDLE m_hTemplate;
	TemplateDBSchema():m_hTemplate(NULL)
	{
		m_pmapszSQLCreates = new map<LPTSTR, LPTSTR, Cstring_less>();
		assert(m_pmapszSQLCreates != NULL);
	}

private:
	map<LPTSTR, LPTSTR, Cstring_less> *m_pmapszSQLCreates;
};
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// <ProductFamily>
Node_Func_H_XIS rgNodeFuncs_ProductFamily_SKU[] = {
	{		INFORMATION,				ProcessInformation_SKU			},
	{		DIRECTORIES,				ProcessDirectories_SKU			},
	{		INSTALLLEVELS,				ProcessInstallLevels_SKU		},
	{		FEATURES,					ProcessFeatures_SKU				}
};
const int cNodeFuncs_ProductFamily_SKU =
			 sizeof(rgNodeFuncs_ProductFamily_SKU)/sizeof(Node_Func_H_XIS);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// <Information>

Node_Func_H_XIS rgNodeFuncs_Information_SKU[]= {
	{		INSTALLERVERSIONREQUIRED,	ProcessInstallerVersionRequired_SKU	},
	{		PACKAGEFILENAME,			ProcessPackageFilename_SKU			}
};

const int cNodeFuncs_Information_SKU = 
			sizeof(rgNodeFuncs_Information_SKU)/sizeof(Node_Func_H_XIS);

Node_Func_H_XIS rgNodeFuncs_Information2_SKU[]= {
	{	CODEPAGE,		ProcessInformationChildren_SKU	},
	{	PRODUCTNAME,	ProcessInformationChildren_SKU	},
	{	PRODUCTCODE,	ProcessInformationChildren_SKU	},
	{	UPGRADECODE,	ProcessInformationChildren_SKU	},
	{	PRODUCTVERSION,	ProcessInformationChildren_SKU	},
	{	MANUFACTURER,	ProcessInformationChildren_SKU	},
	{	KEYWORDS,		ProcessInformationChildren_SKU	},
	{	TEMPLATE,		ProcessInformationChildren_SKU	}
};

const int cNodeFuncs_Information2_SKU = 
			sizeof(rgNodeFuncs_Information2_SKU)/sizeof(Node_Func_H_XIS);

// All of the following children of <Information> will be processed by 
//	a generic function
INFO_CHILD rgChildren_Information[] = {
/* NodeIndex		szPropertyName		uiDesintation	uiPropertyID  vt		bIsGUID	*/
{CODEPAGE,		TEXT("Codepage"),		SUMMARY_INFO,	PID_CODEPAGE, VT_I2,	false	},
{PRODUCTNAME,	TEXT("ProductName"),	BOTH,			PID_SUBJECT,  VT_LPSTR,	false	},
{PRODUCTCODE,	TEXT("ProductCode"),	PROPERTY_TABLE,	0,			  VT_LPSTR,	true	},
{UPGRADECODE,	TEXT("UpgradeCode"),	PROPERTY_TABLE,	0,			  VT_LPSTR,	true	},
{PRODUCTVERSION,TEXT("ProductVersion"),	PROPERTY_TABLE,	0,			  VT_LPSTR,	false	},
{MANUFACTURER,	TEXT("Manufacturer"),	BOTH,			PID_AUTHOR,	  VT_LPSTR,	false	},
{KEYWORDS,		TEXT("Keywords"),		SUMMARY_INFO,	PID_KEYWORDS, VT_LPSTR,	false	},
{TEMPLATE,		TEXT("Template"),		SUMMARY_INFO,	PID_TEMPLATE, VT_LPSTR,	false	}
};


const int cChildren_Information = 
				sizeof(rgChildren_Information)/sizeof(INFO_CHILD);

AttrBit_SKU rgAttrBits_WordCount[] = {
{	LONGFILENAMES,		1	},
{	SOURCECOMPRESSED,	2	}
};

const int cAttrBits_WordCount = 
			sizeof(rgAttrBits_WordCount)/sizeof(AttrBit_SKU);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// <Directory>
//	 
Node_Func_H_XIES rgNodeFuncs_Directory[] = {
/*	NodeIndex		ProcessFunc				ValueType		   column #		*/
{	NAME,			ProcessName,			 STRING,		2/*DefaultDir*/	},
{	TARGETDIR,		ProcessTargetDir,		 STRING,		2/*DefaultDir*/	},
{	TARGETPROPERTY,	ProcessTargetProperty,	 STRING,		1/*Directory*/	}
};


const int cNodeFuncs_Directory = 
	sizeof(rgNodeFuncs_Directory)/sizeof(Node_Func_H_XIES);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// <Feature>
//	 
Node_Func_H_XIES rgNodeFuncs_Feature_SKU[] = {
/*	 NodeIndex			ProcessFunc			ValueType		   column #	*/
{	TITLE,			ProcessSimpleElement,	 STRING,		1/*Title*/		 },
{	DESCRIPTION,	ProcessSimpleElement,	 STRING,		2/*Description*/ },
{	DISPLAYSTATE,	ProcessDisplayState_SKU, INTEGER,		3/*Display*/	 },
{	ILEVEL,			ProcessRefElement,		 INSTALL_LEVEL,	4/*Level*/		 },
{	DIR,			ProcessRefElement,		 STRING,		5/*Description*/ },
{	STATE,			ProcessState_SKU,		 INTEGER,		6/*DisplayState*/}
};


const int cNodeFuncs_Feature_SKU = 
	sizeof(rgNodeFuncs_Feature_SKU)/sizeof(Node_Func_H_XIES);

EnumBit rgEnumBits_Favor_Feature[] = {
{	TEXT("Local"),		0									},
{	TEXT("Source"),		msidbFeatureAttributesFavorSource	},
{	TEXT("Parent"),		msidbFeatureAttributesFollowParent	}
};

const int cEnumBits_Favor_Feature = 
			sizeof(rgEnumBits_Favor_Feature)/sizeof(EnumBit);

EnumBit rgEnumBits_Advertise_Feature[] = {
{	TEXT("None"),				0											 },
{	TEXT("Favor"),				msidbFeatureAttributesFavorAdvertise		 },
{	TEXT("Disallow"),			msidbFeatureAttributesDisallowAdvertise		 },
{	TEXT("NoUnsupported"),		msidbFeatureAttributesNoUnsupportedAdvertise },
{	TEXT("FavorNoUnSupported"),	msidbFeatureAttributesFavorAdvertise |
								msidbFeatureAttributesNoUnsupportedAdvertise },
};

const int cEnumBits_Advertise_Feature = 
			sizeof(rgEnumBits_Advertise_Feature)/sizeof(EnumBit);

AttrBit_SKU rgAttrBits_Feature[] = {
{	DISALLOWABSENT,		msidbFeatureAttributesUIDisallowAbsent	},
};

const int cAttrBits_Feature = 
			sizeof(rgAttrBits_Feature)/sizeof(AttrBit_SKU);
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
// <UseModule>
//	 
Node_Func_H_XIES rgNodeFuncs_UseModule[] = {
/*	 NodeIndex			ProcessFunc			ValueType		  column #	*/
{  TAKEOWNERSHIP,	ProcessTakeOwnership,	 INTEGER,			1	},
};

const int cNodeFuncs_UseModule = 
	sizeof(rgNodeFuncs_UseModule)/sizeof(Node_Func_H_XIES);

AttrBit_SKU rgAttrBits_TakeOwnership[] = {
{	OWNSHORTCUTS,				1	},
{	OWNCLASSES,					2	},
{	OWNTYPELIBS,				4	},
{	OWNEXTENSIONS,				8	},
{	OWNQUALIFIEDCOMPONENTS,		16	},
};

const int cAttrBits_TakeOwnership = 
			sizeof(rgAttrBits_TakeOwnership)/sizeof(AttrBit_SKU);
//////////////////////////////////////////////////////////////////////////////

LPTSTR g_szInputSkuFilter = NULL;
SkuSet *g_pskuSet = NULL;
int g_cSkus = 0;
Sku **g_rgpSkus = NULL;
IXMLDOMNode *g_pNodeProductFamily = NULL;

// assume the user doesn't want to see the extra information
bool g_bVerbose = false;			
// assume the user doesn't only want to validate the input WIML package
bool g_bValidationOnly = false;	
FILE *g_pLogFile = NULL;	// assume the user doesn't specify a log file

map<LPTSTR, SkuSet *, Cstring_less> g_mapSkuSets;
map<LPTSTR, SkuSetValues *, Cstring_less> g_mapDirectoryRefs_SKU;
map<LPTSTR, SkuSetValues *, Cstring_less> g_mapInstallLevelRefs_SKU;
map<LPTSTR, Component *, Cstring_less> g_mapComponents;

// for each table type, there is a counter that keeps 
// incrementing when each time the function is called
// with that particular table name
map<LPTSTR, int, Cstring_less> g_mapTableCounter;


NODE rgXMSINodes[] = 
{
/* a handy place holder */
	{ NULL, NULL, false, -1},

{TEXT("ProductFamily"),		NULL,	true,	1},		
	{TEXT("SkuManagement"),		NULL,	true,	1},	
		{TEXT("SKUs"),		NULL,	true,	1},
			{TEXT("SKU"),	TEXT("ID"),		true,	0},
		{TEXT("SkuGroups"),		NULL,	false,	1},
			{TEXT("SkuGroup"),	TEXT("ID"),	false,	0},
	{TEXT("Information"),		NULL,	true,	1},
		{TEXT("ProductName"),				TEXT("Value"),	true,	1},
		{TEXT("ProductCode"),				TEXT("Value"),	true,	1},
		{TEXT("UpgradeCode"),				TEXT("Value"),	true,	1},
		{TEXT("ProductVersion"),			TEXT("Value"),	true,	1},
		{TEXT("Manufacturer"),				TEXT("Value"),	true,	1},
		{TEXT("Keywords"),					TEXT("Value"),	true,	1},
		{TEXT("Template"),					TEXT("Value"),	true,	1},
		{TEXT("InstallerVersionRequired"),	TEXT("Value"),	true,	1},
		{TEXT("LongFilenames"),				NULL,			false,	1},
		{TEXT("SourceCompressed"),			NULL,			false,	1},
		{TEXT("Codepage"),					TEXT("Value"),	true,	1},
		{TEXT("SummaryCodepage"),			TEXT("Value"),	false,	1},
		{TEXT("PackageFilename"),			TEXT("Value"),	false,	1},
	{TEXT("Directories"),		NULL,	true,	1},
		{TEXT("Directory"),		TEXT("ID"),		false,	0},
			{TEXT("Name"),				NULL,		true,	1},
			{TEXT("TargetDir"),			NULL,		false,	1},
			{TEXT("TargetProperty"),	TEXT("Value"),	false, 1},
	{TEXT("InstallLevels"),		NULL,	true,	1},
		{TEXT("InstallLevel"),	TEXT("ID"),		true,	0},
	{TEXT("Features"),			NULL,	true,	1},
		{TEXT("Feature"),	TEXT("ID"),		true,	0},		
			{TEXT("Title"),				TEXT("Value"),		false,	1},
			{TEXT("Description"),		TEXT("Value"),		false,	1},
			{TEXT("DisplayState"),		TEXT("Value"),		false,	1},
/* there are 2 nodes corresponde to <ILevel> entity. The first one is given 
	the NodeIndex ILEVEL which correspondes Level column in Feature table. 
	The second one is given the NodeIndex ILEVELCONDITION which corresponds to
	the Level column in Condition table */
			{TEXT("ILevel[not(@Condition)]"),	TEXT("Ref"),	true,	1},
			{TEXT("ILevel[@Condition]"),		TEXT("Ref"),	false,	0},
			{TEXT("Dir"),				TEXT("Ref"),		false,	1},
			{TEXT("State"),				NULL,				false,	1},
				{TEXT("Favor"),				TEXT("Value"),		false,	1},
				{TEXT("Advertise"),			TEXT("Value"),		false,	1},
				{TEXT("DisallowAbsent"),	NULL,				false,	1},
			{TEXT("UseModule"),				TEXT("Ref"),	false,	0},
				{TEXT("TakeOwnership"),		NULL,			false,	1},
					{TEXT("OwnShortcuts"),		NULL,				false,	1},
					{TEXT("OwnClasses"),		NULL,				false,	1},
					{TEXT("OwnTypeLibs"),		NULL,				false,	1},
					{TEXT("OwnExtensions"),		NULL,				false,	1},
					{TEXT("OwnQualifiedComponents"),	NULL,		false,	1},
	{TEXT("Modules"),			NULL,	true,	1},
		{TEXT("Module"),		TEXT("ID"),		true,	0},		
			{TEXT("Component"),		TEXT("ID"),		true,	0},	
				{TEXT("GUID"),					TEXT("Value"),		true,	1},
				{TEXT("ComponentDir"),			TEXT("Ref"),		true,	1},
				{TEXT("CreateFolder"),			TEXT("Ref"),		false,	0},
					{TEXT("LockPermission"),	NULL,				false,	0},
				{TEXT("ComponentAttributes"),	NULL,				false,	1},
					{TEXT("RunFrom"),			TEXT("Value"),		false,	1},
					{TEXT("SharedDllRefCount"),	NULL,				false,	1},
					{TEXT("Permanent"),			NULL,				false,	1},
					{TEXT("Transitive"),		NULL,				false,	1},
					{TEXT("NeverOverwrite"),	NULL,				false,	1},
				{TEXT("Condition"),				TEXT("Value"),		false,	1},
				{TEXT("File"),				TEXT("ID"),		false,	0},
					{TEXT("FileName"),			NULL,			true,	1},
					{TEXT("FileSize"),			TEXT("Value"),	false,	1},
					{TEXT("FileVersion"),		NULL,			false,	1},
					{TEXT("FileLanguage"),		TEXT("Value"),	false,	1},
					{TEXT("FileAttributes"),	NULL,			false,	1},
						{TEXT("ReadOnly"),		NULL,			false,	1},
						{TEXT("Hidden"),		NULL,			false,	1},
						{TEXT("System"),		NULL,			false,	1},
						{TEXT("Vital"),			NULL,			false,	1},
						{TEXT("Checksum"),		NULL,			false,	1},
						{TEXT("Compressed"),	TEXT("Value"),	false,	1},
					{TEXT("Font"),				TEXT("Title"),	false,	1},
					{TEXT("BindImage"),			TEXT("Path"),	false,	1},
					{TEXT("SelfReg"),			TEXT("Cost"),	false,	1},
				{TEXT("MoveFile"),				TEXT("ID"),		false,	0},
					{TEXT("SourceName"),		TEXT("Value"),	false,	1},
					{TEXT("DestName"),			TEXT("Value"),	false,	1},
					{TEXT("SourceFolder"),		TEXT("Value"),	false,	1},
					{TEXT("DestFolder"),		TEXT("Value"),	true,	1},
					{TEXT("CopyFile"),			NULL,			false,	1},
				{TEXT("RemoveFile"),			TEXT("ID"),		false,	0},
					{TEXT("FName"),				TEXT("Value"),	false,	1},
					{TEXT("DirProperty"),		TEXT("Value"),	true,	1},
					{TEXT("InstallMode"),		TEXT("Value"),	true,	1},
				{TEXT("IniFile"),				TEXT("ID"),		false,	0},
					{TEXT("FName"),				TEXT("Value"),	true,	1},
					{TEXT("DirProperty"),		TEXT("Value"),	false,	1},
					{TEXT("Section"),			TEXT("Value"),	true,	1},
					{TEXT("Key"),				TEXT("Value"),	true,	1},
					{TEXT("Value"),				TEXT("Value"),	true,	1},
					{TEXT("Action"),			TEXT("Type"),	true,	1},
				{TEXT("RemoveIniFile"),			TEXT("ID"),		false,	0},
					{TEXT("FName"),				TEXT("Value"),	true,	1},
					{TEXT("DirProperty"),		TEXT("Value"),	false,	1},
					{TEXT("Value"),				TEXT("Value"),	false,	1},
					{TEXT("Action"),			TEXT("Type"),	true,	1},
				{TEXT("Registry"),				NULL,			false,	0},
					{TEXT("Delete"),			NULL,			false,	0},
					{TEXT("Create"),			NULL,			false,	0},
};

#endif //XMSI_MAINFUNCS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\query.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998
//
//  File:       query.cpp
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
// query.cpp
//		Implements a simple class wrapper around a MSI view. 
// 

// this ensures that UNICODE and _UNICODE are always defined together for this
// object file
#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE
#endif
#else
#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE
#endif
#endif
#endif

#include <windows.h>
#include <assert.h>
#include "query.h"

///////////////////////////////////////////////////////////
// constructor
CQuery::CQuery()
{
	// invalidate the handles
	m_hView = NULL;
}	// end of constructor

///////////////////////////////////////////////////////////
// destructor
CQuery::~CQuery()
{
	// if the view wasn't closed
	if (m_hView)
		::MsiCloseHandle(m_hView);
}	// end of destructor

///////////////////////////////////////////////////////////
// Open
// Pre:	database handle is valid
// Pos:	m_hView is open on databse
UINT CQuery::Open(MSIHANDLE hDatabase, LPCTSTR szSQLFormat, ...)
{
	size_t dwBuf = 512;
	TCHAR *szSQL = new TCHAR[dwBuf];
	if (!szSQL)
		return ERROR_FUNCTION_FAILED;
	
	// store the result SQL string
	va_list listSQL; 
	va_start(listSQL, szSQLFormat); 
	while (-1 == _vsntprintf(szSQL, dwBuf, szSQLFormat, listSQL))
	{
		dwBuf *= 2;
		delete[] szSQL;
		szSQL = new TCHAR[dwBuf];
		if (!szSQL)
		{
			va_end(listSQL);
			return ERROR_FUNCTION_FAILED;
		}
	}
	va_end(listSQL);

	if (m_hView)
		::MsiCloseHandle(m_hView);

	// open the view
	UINT iResult = ::MsiDatabaseOpenView(hDatabase, szSQL, &m_hView);

	delete[] szSQL;

	return iResult;
}	// end of Open

///////////////////////////////////////////////////////////
// Close
// Pre:	none
// Pos:	view handle is closed
//			SQL string is blanked
UINT CQuery::Close()
{
	UINT iResult = ERROR_SUCCESS;		// assume everything will be okay

	// close the handle and null the handle
	iResult = ::MsiViewClose(m_hView);
	
	return iResult;
}	// end of Close

///////////////////////////////////////////////////////////
// Execute
// Pre:	view handle is open
// Pos:	view is executed
//			result is returned
UINT CQuery::Execute(MSIHANDLE hParams /*= NULL*/)
{
	// execute the view and return the result
	return ::MsiViewExecute(m_hView, hParams);
}	// end of Execute

///////////////////////////////////////////////////////////
// OpenExecute
// Pre:	database handle is valid
// Pos:	m_hView is open and executed on databse
UINT CQuery::OpenExecute(MSIHANDLE hDatabase, MSIHANDLE hParam, 
						 LPCTSTR szSQLFormat, ...)
{
	size_t dwBuf = 512;
	TCHAR *szSQL = new TCHAR[dwBuf];
	if (!szSQL)
		return ERROR_FUNCTION_FAILED;
	
	// store the result SQL string
	va_list listSQL; 
	va_start(listSQL, szSQLFormat); 
	while (-1 == _vsntprintf(szSQL, dwBuf, szSQLFormat, listSQL))
	{
		dwBuf *= 2;
		delete[] szSQL;
		szSQL = new TCHAR[dwBuf];
		if (!szSQL)
		{
			va_end(listSQL);
			return ERROR_FUNCTION_FAILED;
		}
	}
	va_end(listSQL);

	if (m_hView)
		::MsiCloseHandle(m_hView);

	// open the view
	UINT iResult = ::MsiDatabaseOpenView(hDatabase, szSQL, &m_hView);

	delete[] szSQL;

	if (ERROR_SUCCESS != iResult)
		return iResult;

	return Execute(hParam);
}	// end of OpenExecute

///////////////////////////////////////////////////////////
// Fetch
// Pre:	view handle is open
//			view is executed
// Pos:	record is returned
//			result is returned
UINT CQuery::Fetch(MSIHANDLE* phRecord)
{
	// fetch from the view and return the result
	return ::MsiViewFetch(m_hView, phRecord);
}	// end of Fetch

///////////////////////////////////////////////////////////
// FetchOnce
// Pre:	database handle is valid
// Pos:	m_hView is open, executed, and one record is fetched
UINT CQuery::FetchOnce(MSIHANDLE hDatabase, MSIHANDLE hParam, 
					   MSIHANDLE* phRecord, LPCTSTR szSQLFormat, ...)
{
	size_t dwBuf = 512;
	TCHAR *szSQL = new TCHAR[dwBuf];
	if (!szSQL)
		return ERROR_FUNCTION_FAILED;
	
	// store the result SQL string
	va_list listSQL; 
	va_start(listSQL, szSQLFormat); 
	while (-1 == _vsntprintf(szSQL, dwBuf, szSQLFormat, listSQL))
	{
		dwBuf *= 2;
		delete[] szSQL;
		szSQL = new TCHAR[dwBuf];
		if (!szSQL)
		{
			va_end(listSQL);
			return ERROR_FUNCTION_FAILED;
		}
	}
	va_end(listSQL);

	if (m_hView)
		::MsiCloseHandle(m_hView);

	// open the view
	UINT iResult = ::MsiDatabaseOpenView(hDatabase, szSQL, &m_hView);
	delete[] szSQL;
	if (ERROR_SUCCESS != iResult)
		return iResult;
	
	if (ERROR_SUCCESS != (iResult = Execute(hParam)))
		return iResult;

	return Fetch(phRecord);
}	// end of FetchOnce

///////////////////////////////////////////////////////////
// Modify
// Pre:	view handle is open
//			view is executed
// Pos:	modification is done
//			result is returned
UINT CQuery::Modify(MSIMODIFY eInfo, MSIHANDLE hRec)
{
	// execute the view and return the result
	return ::MsiViewModify(m_hView, eInfo, hRec);
}	// end of GetColumnInfo

///////////////////////////////////////////////////////////
// GetError
// Pre:	view handle is open
//			view is executed

UINT CQuery::GetError()
{
	TCHAR szDummyBuf[1024];
	unsigned long cchDummyBuf = sizeof(szDummyBuf)/sizeof(TCHAR);
	// execute the view and return the result
	return ::MsiViewGetError(m_hView, szDummyBuf, &cchDummyBuf);
}	// end of GetColumnInfo

///////////////////////////////////////////////////////////
// GetColumnInfo
// Pre:	view handle is open
//			view is executed
// Pos:	record is returned
//			result is returned
UINT CQuery::GetColumnInfo(MSICOLINFO eInfo, MSIHANDLE* phRec)
{
	// execute the view and return the result
	return ::MsiViewGetColumnInfo(m_hView, eInfo, phRec);
}	// end of GetColumnInfo


/////////////////////////////////////////////////////////////////////////////
// query.cpp -- CManageTable implementation
//		Implements a simple class wrapper around a MSI table for managing
//      hold counts and will clean up all hold counts it has managed upon
//      release.  Upon creation, can specify that a table has already
//      been held in memory prior to the Class managing it.  It will add
//      a hold count for this case and then release upon class destruction 
// 
CManageTable::CManageTable(MSIHANDLE hDatabase, LPCTSTR szTable,
						   bool fAlreadyLocked) : m_hDatabase(hDatabase),
						   m_iLockCount(0)
{
	assert(m_hDatabase != 0);

	if (fAlreadyLocked)
		m_iLockCount++; // add a hold count for the table, we're managing after a HOLD
	if (lstrlen(szTable) +1 > sizeof(m_szTable)/sizeof(TCHAR))
		m_szTable[0] = '\0'; // set failure state, buffer not big enough for string
	else
		lstrcpy(m_szTable, szTable);
}

CManageTable::~CManageTable()
{
	// check failure state
	if (m_szTable[0] == '\0')
	{
		m_iLockCount = 0;
		return;
	}

	// clean up all hold counts that this class is managing upon release
	CQuery qUnLock;
	for (int i = 1; i <= m_iLockCount; i++)
	{
		qUnLock.OpenExecute(m_hDatabase, 0, 
								TEXT("ALTER TABLE `%s` FREE"), m_szTable);
	}
	m_iLockCount = 0; // reset
}

UINT CManageTable::LockTable()
{
	// check failure state
	if (m_szTable[0] == '\0')
		return ERROR_FUNCTION_FAILED;

	assert(m_iLockCount >= 0);
	CQuery qLock;
	UINT iStat = qLock.OpenExecute(m_hDatabase, 0,
								TEXT("ALTER TABLE `%s` HOLD"), m_szTable);
	if (ERROR_SUCCESS == iStat)
		m_iLockCount++; // only add to lock count if successful
	return iStat;
}

UINT CManageTable::UnLockTable()
{
	// check failure state
	if (m_szTable[0] == '\0')
		return ERROR_FUNCTION_FAILED;

	assert(m_iLockCount > 0);
	CQuery qUnLock;
	UINT iStat = qUnLock.OpenExecute(m_hDatabase, 0,
								TEXT("ALTER TABLE `%s` FREE"), m_szTable);
	if (ERROR_SUCCESS == iStat)
		m_iLockCount--; // only release lock count if successful
	return iStat;
}

void CManageTable::AddLockCount()
{
	m_iLockCount++; // HOLD added to this table by an external query
}

void CManageTable::RemoveLockCount()
{
	m_iLockCount--; // FREED by an external query
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\skufilterexprnode.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       SKUFilterExprNode.cpp
//
//    This file contains the implementation of SKUFilterExprNode class 
//
// This class implements the SKU Filter language parser and the
// SKU filter logic.
//
// USAGE:
//    - create a root node like this:
//      SKUFilterExprNode *root = new SKUFilterExprNode(&input, SKUFilterExprNode::Filter);
//      with input being a char* pointing to the beginning of the NULL terminated
//      filter expression C string, e.g.
//      char *input = argv[1];
//      When the constructor returns the expression was already parsed and an
//      Astract Syntax Tree created.
//    - if (root->errpos == 0) the expression could be parsed correctly. In this case
//      you can use the Filter with "SKUFilterPass".
//      if (root->errpos != 0) the expression could not be parsed correctly. The AST is invalid
//      in this case. root->errpos then points to the char that caused the parser to fail.
//      root->errstr then contains a C string error message.
//    - In any case, don't forget to free the tree with "delete root".
//
// MECHANICS:
//      The class implements a node of the AST for the following LL(1) grammar.
//
//      Letter 		::= ['a'-'z']|['A'-'Z']
//      Identifier 	::= ('_'|Letter) ('_'|Letter|['0'-'9'])*
//      Primitive	::= Identifier | '(' Expression ')'
//      Factor		::= '!' Primitive | Primitive
//      Term 		::= Factor TermTail
//      TermTail	::= '+' Factor TermTail | Lambda
//      Expression	::= Term ExprTail
//      ExprTail 	::= ',' Term ExprTail | Lambda
//      Filter		::= Expression
//
//      The parser is a simple recursive descent parser building a binary AST, descending
//      to the right, e.g. A+B+C results in
//                                                  +
//                                                 / \
//                                                A   +
//                                                   / \
//                                                  B   C 
//--------------------------------------------------------------------------

#include "SKUFilterExprNode.h"
#include "wmc.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

// initialization of the static constants
// letterCharB contains all characters that are allowed to appear at the beginning of a
// SKU/SKUGroup identifier. letterChar all valid chars.
LPCTSTR SKUFilterExprNode::letterCharB = TEXT("_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ");
LPCTSTR SKUFilterExprNode::letterChar  = TEXT("_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");


SKUFilterExprNode::SKUFilterExprNode(SKUFilterExprNode* parent)
// a private, special kind of copy constructor. Called whenever a node discovers
// that it has to "push down" the AST created so far because a higher level operator
// was discovered. Nodes always "push down" to the left and continue parsing in the
// right subtree.
// This "copy" constructor almost does the job of a normal copy constructor, except
// it MOVES the name to the child instead of COPYING it.
{
    assert(parent);
    left   = parent->left;      // copy all attributes
    right  = parent->right;
    name   = parent->name;
//----------------------------------------------------------------------------
	m_pSkuSet = new SkuSet(*(parent->m_pSkuSet));
//----------------------------------------------------------------------------
    ntype  = parent->ntype;
    errpos = NULL;                 // we don't need to copy, errpos is known to be zero

    parent->name = NULL;           // kill old name pointer, we don't want the parent to keep the name
}

SKUFilterExprNode::SKUFilterExprNode(LPTSTR *input, ExprType antype)
// the main constructor and the main routine of the parser
// after initializing the routine continues parsing of the input
// with the Grammar part that it is instructed through the "antype" parameter.
//
// INPUT MUSTN'T BE NULL AND MUSTN'T POINT TO A NULL POINTER!!!
// (it is allowed to point to a pointer to a empty string though!)
{
    assert(input && *input); // make sure input is ok
    left = right = NULL;
    name = errpos = NULL;
//-----------------------------------------------------------------------------
	m_pSkuSet = new SkuSet(g_cSkus);
	assert(m_pSkuSet != NULL);
//-----------------------------------------------------------------------------

    ntype = Leaf;

    switch (antype) {
    case Filter:
        // the outer wrapper case, only called on the root from the outside
        while (_istspace(**input)) (*input)++;              // skip whitespace
        if (ParseExpression(input) && **input) {        // parse the expression and make
            _stprintf(errstr, TEXT("Syntax Error!"));   // sure that afterwards there are no
            errpos = *input;                            // input characters left, i.e. **input==0
        }
        break;
    case Expression:
        ParseExpression(input); // we are a subnode having to accept an Expression
        break;
    case Term:
        ParseTerm(input);       // we are a subnode having to accept an Term
        break;
    case Factor:
        ParseFactor(input);     // we are a subnode having to accept an Factor
        break;
    case Primitive:
        ParsePrimitive(input);  // we are a subnode having to accept an Primitive
        break;
    }
    // after parsing our subtree we might have encoutered an error in one of out
    // subtrees ... therefore we have to propagate to error up to our level
    if (left && left->errpos) {
        errpos  = left->errpos;
        _tcscpy(errstr, left->errstr);
    } else if (right && right->errpos) {
        errpos  = right->errpos;
        _tcscpy(errstr, right->errstr);;
    }
}

SKUFilterExprNode::~SKUFilterExprNode()
// simple destructor, recursively freeing our subtrees and then our name string
{
    if (left)
	{
		delete left;
		left = NULL;
	}
    if (right) 
	{
		delete right;
		right = NULL;
	}
    if (name) 
	{
		delete[] name;
		name = NULL;
	}

	if (m_pSkuSet)
	{
		delete m_pSkuSet;
		m_pSkuSet = NULL;
	}
}

bool SKUFilterExprNode::ConsumeChar(LPTSTR *input, TCHAR c, bool forceError)
// small helper routine
// If c is the current character it is consumed with any following whitespace and
// TRUE returned. If c is not the current character the input is left as is and
// FALSE returned. If forceError is set to TRUE an additional error message is created
// in this case.
{
    if (**input == c) {
        (*input)++;                         // consume c
        while (_istspace(**input)) (*input)++;  // consume any following whitespace
        return true;
    } else 
        if (forceError) {
            _stprintf(errstr, TEXT("\'%c\' expected!"), c);
            errpos = *input;
        }
    return false;
}

bool SKUFilterExprNode::ParseExpression(LPTSTR *input)
// parses an expression and returns TRUE on success, FALSE on failure.
{
    bool ok = true;
    if (ParseTerm(input)) {                     // parse a Term
        if (**input && **input != TEXT(')')) {            // if there is input left and it's not a ')'
            if (ConsumeChar(input,TEXT(','),true)) {          // it has to be a ','
                left  = new SKUFilterExprNode(this);        // if it is push down to the left
                right = new SKUFilterExprNode(input, Expression);// and continue to the right
                ntype = Union;                      // at this level we are a Union
//-----------------------------------------------------------------------------
				*m_pSkuSet = *(left->m_pSkuSet) | *(right->m_pSkuSet);
//-----------------------------------------------------------------------------
                ok = right && (right->errpos == 0); // propagate a potential error
            } else ok = false;
        }
    } else ok = false; // the Term is invalid and so are we
    return ok;
}

bool SKUFilterExprNode::ParseTerm(LPTSTR *input)
// parses a term and returns TRUE on success, FALSE on failure.
{
    bool ok = true;
    if (ParseFactor(input)) {                           // parse a Factor
        if (**input && ConsumeChar(input, TEXT('+'), false)) {  // if there is input left and it's a '+'
            left  = new SKUFilterExprNode(this);        // push down to the left
            right = new SKUFilterExprNode(input, Term); // and continue to the right
            ntype = Intersection;                       // at this level we are an Intersection
//-----------------------------------------------------------------------------
				*m_pSkuSet = *(left->m_pSkuSet) & *(right->m_pSkuSet);
//-----------------------------------------------------------------------------
            ok = right && (right->errpos == 0);         // propagate a potential error
        }
    } else ok = false; // the Factor is invalid and so are we
    return ok;
}

bool SKUFilterExprNode::ParseFactor(LPTSTR *input)
// parses a factor and returns TRUE on success, FALSE on failure.
{
    bool ok = false;
    if (ConsumeChar(input,TEXT('!'),false)) {                 // if we start with a '!'
        ntype = Inversion;                              // we an Inversion
        left = new SKUFilterExprNode(input, Primitive); // create new node and parse the Primitive
        ok = left && (left->errpos == 0);       // propagate a potential error
//-----------------------------------------------------------------------------
		*m_pSkuSet = ~(*(left->m_pSkuSet));
//-----------------------------------------------------------------------------
    } else ok = ParsePrimitive(input); // we are not an Inversion so we simply go ahead with the Primitive
    return ok;
}

bool SKUFilterExprNode::ParsePrimitive(LPTSTR *input)
// parses a primitive and returns TRUE on success, FALSE on failure.
{
    LPTSTR p;
    int l;

    if (!ConsumeChar(input, TEXT('('), false)) {    // if we are not starting with a '(' we simply parse the identifier
        p = *input;                         // save the beginning of the identifier
        if (*p && _tcschr(letterCharB,*p)) { // check whether the first char is valid

            // advance input to one char after the last character of the identifier
            while ((**input) && (_tcschr(letterChar,**input))) (*input)++; 

            l = *input - p;                     // calculate length of identifier
            name = new TCHAR[l+1];        // allocate name + null byte
            assert(name);                      // make sure we have the memory
            _tcsncpy(name, p, l);                // copy name
            *(name + l) = NULL;                    // manually set null byte
            while (_istspace(**input)) (*input)++;  // skip trailing whitespace
            ntype = Leaf;                       // we are a Leaf (yeah!)
            if (!IsValidSKUGroupID(name)) {     // check whether the name is a known SKU group or SKU
                _stprintf(errstr, TEXT("Unknown SKU Group!"));
                errpos = p;
                return false;
            } else
			{
//-----------------------------------------------------------------------------
				// needs to make a copy so that the destructor of SKUFilterNode
				// won't destroy the SkuSet stored globally
				*m_pSkuSet = *g_mapSkuSets[name];
//-----------------------------------------------------------------------------
				return true;                 // it is a valid SKU group, so we are fine
			}
        }
    } else {
        // we had a '(' so we expect a valid expression and then a closing ')'
        return ParseExpression(input) && ConsumeChar(input, TEXT(')'), true);
    }
    // if we didn't return yet at this point, we haven't found a proper identifier
    _stprintf(errstr, TEXT("Identifier expected!"));
    errpos = *input;
    return false;
}

void SKUFilterExprNode::Print()
// simply prints the AST in a "(OR,A,(OR,B,C))" kind of fashion
{
    switch (ntype) {
        case Leaf:
            _tprintf(TEXT("%s"),name);
            return;
        case Union:
            _tprintf(TEXT("(OR,"),name);
            break;
        case Intersection:
            _tprintf(TEXT("(AND,"),name);
            break;
        case Inversion:
            _tprintf(TEXT("(NOT,"),name);
            break;
        default:
            return;
    }
    if (left) left->Print();
    if (right) {
        _tprintf(TEXT(","));
        right->Print();
    }
    _tprintf(TEXT(")"));
}

bool SKUFilterExprNode::IsValidSKUGroupID(LPTSTR id)
// checks whether ID is a valid SKU group or SKU identifier
{
    // insert the appropriate code here
    return (0 != g_mapSkuSets.count(id));
}

bool SKUFilterExprNode::SKUFilterPass(LPTSTR id)
// performs the actual Filter logic after the AST has been built
// returns false if the the parameter does not pass the filter or the
// AST is invalid, otherwise TRUE.
{
    bool ok = false;
    if (!errpos) {
        switch (ntype) {
            case Leaf:
                // insert the appropriate code here:
                // set ok to true if id is member of the SKU group [name]
                // or if id is the actual SKU [name]
                break;
            case Union:
                assert(left && right);
                ok = left->SKUFilterPass(id) || right->SKUFilterPass(id);
                break;
            case Intersection:
                assert(left && right);
                ok = left->SKUFilterPass(id) && right->SKUFilterPass(id);
                break;
            case Inversion:
                assert(left);
                ok = !left->SKUFilterPass(id);
                break;
        }
    }
    return ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\sku.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       Sku.cpp
//
//    This file contains the implementation of Sku class
//--------------------------------------------------------------------------

#include "wmc.h"

////////////////////////////////////////////////////////////////////////////
// Destructor: release all the key values stored in the set
//             release KeyPath string stored
////////////////////////////////////////////////////////////////////////////
Sku::~Sku()
{
	if (m_szID)
		delete[] m_szID;

	set<LPTSTR, Cstring_less>::iterator it = m_setModules.begin();
	for(; it != m_setModules.end(); ++it)
	{
		if (*it)
			delete[] (*it);
	}

	FreeCQueries();
	CloseDBHandles();
}

////////////////////////////////////////////////////////////////////////////
// FreeCQueries: close all the stored CQueries and release all the 
//               stored table names
////////////////////////////////////////////////////////////////////////////
void
Sku::FreeCQueries()
{
	map<LPTSTR, CQuery *, Cstring_less>::iterator it;
	for (it = m_mapCQueries.begin(); it != m_mapCQueries.end(); ++it)
	{
		delete[] (*it).first;
		(*it).second->Close();
		delete (*it).second;
	}
}

////////////////////////////////////////////////////////////////////////////
// CloseDBHandles: close DB Handles
////////////////////////////////////////////////////////////////////////////
void
Sku::CloseDBHandles()
{
	if (m_hSummaryInfo) MsiCloseHandle(m_hSummaryInfo);
	if (m_hDatabase) MsiCloseHandle(m_hDatabase);
	if (m_hTemplate) MsiCloseHandle(m_hTemplate);
}

////////////////////////////////////////////////////////////////////////////
// TableExists: returns true if the table has been created for this SKU
////////////////////////////////////////////////////////////////////////////
bool
Sku::TableExists(LPTSTR szTable)
{
	return (0 != m_mapCQueries.count(szTable));
}

////////////////////////////////////////////////////////////////////////////
// CreateCQuery: create a CQuery and store it together with the table name.
//				 This also marks that a table has been created.
////////////////////////////////////////////////////////////////////////////
HRESULT
Sku::CreateCQuery(LPTSTR szTable)
{
	HRESULT hr = S_OK;

	if (!TableExists(szTable))
	{
		CQuery *pCQuery = new CQuery();
		if (pCQuery != NULL)
		{
			if (ERROR_SUCCESS != 
				pCQuery->OpenExecute(m_hDatabase, NULL, TEXT("SELECT * FROM %s"), 
											szTable))
			{
				_tprintf(TEXT("Internal Error: Failed to call OpenExecute to create a ")
						 TEXT("CQuery for %s table"), szTable);
				hr = E_FAIL;
			}
			else
			{
				LPTSTR sz = _tcsdup(szTable);
				assert(szTable);
				if (sz != NULL)
					m_mapCQueries.insert(LQ_ValType(sz, pCQuery));
				else
				{
					_tprintf(TEXT("Error: Out of memory\n"));
					hr = E_FAIL;
				}
			}
		}
		else 
		{
			_tprintf(TEXT("Internal Error: Failed to create a new CQuery\n"));
			hr = E_FAIL;
		}
	}
	else
	{
#ifdef DEBUG
		_tprintf(TEXT("Table already exisits in this SKU!\n"));
#endif
		hr = S_FALSE;
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// SetOwnedModule: Add the passed-in module to the set of modules owned by
//                   this SKU
////////////////////////////////////////////////////////////////////////////
void 
Sku::SetOwnedModule(LPTSTR szModule)
{
	LPTSTR szTemp = _tcsdup(szModule);
	assert(szTemp);
	m_setModules.insert(szTemp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\skufilterexprnode.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:     SKUFilterExprNode.h
// 
//    This file contains the definition of Class SKUFilterExprNode --
//	    a temporary solution for parsing Sku filter expressions	
//--------------------------------------------------------------------------


#ifndef XMSI_SKUFILTEREXPRNODE_H
#define XMSI_SKUFILTEREXPRNODE_H

#include <Windows.h>
#include <tchar.h>
#include <stdio.h>
#include <assert.h>
#include "SkuSet.h"

class SKUFilterExprNode  
{
private:

    static LPCTSTR letterCharB; // list of valid chars for the beginning of an identifier
    static LPCTSTR letterChar;  // list of valid chars for an identifier

    SKUFilterExprNode(SKUFilterExprNode* parent);
    bool SKUFilterExprNode::ConsumeChar(LPTSTR *input, TCHAR c, bool force);
    bool SKUFilterExprNode::ParseExpression(LPTSTR *input);
    bool SKUFilterExprNode::ParseTerm(LPTSTR *input);
    bool SKUFilterExprNode::ParseFactor(LPTSTR *input);
    bool SKUFilterExprNode::ParsePrimitive(LPTSTR *input);

public:

	SkuSet *m_pSkuSet;
    LPTSTR name,                 // the identifier at the node if the node is Leaf
          errpos;               // NULL is subtree was successfully parsed, otherwise points to error char in input
    TCHAR errstr[21];            // contains an error message is errpos!=0
    enum {  Leaf,
            Union,
            Intersection,
            Inversion } ntype;  // the type of the node
    enum ExprType { 
            Filter,
            Expression,         // type for commanding the parser what grammar part to parse next
            Term, 
            Factor, 
            Primitive };
    SKUFilterExprNode *left, *right;    // the two subtrees

	SKUFilterExprNode(LPTSTR *input, ExprType etype);
	virtual ~SKUFilterExprNode();
    bool SKUFilterExprNode::SKUFilterPass(LPTSTR id);
	void Print();

    static bool IsValidSKUGroupID(LPTSTR id);
};

#endif // XMSI_SKUFILTEREXPRNODE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\skuset.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       SkuSet.cpp
//
//    This file contains the implementation of SkuSet class 
//--------------------------------------------------------------------------

#include "SkuSet.h"
#include "math.h"

////////////////////////////////////////////////////////////////////////////
// Constructor: take the length of the bit field 
////////////////////////////////////////////////////////////////////////////
SkuSet::SkuSet(int iLength)
{
	m_iLength = iLength;
	int i = SKUSET_UNIT_SIZE;

	m_iSize = (int)ceil((double)m_iLength/SKUSET_UNIT_SIZE);

	m_rgulBitField = new ULONG[m_iSize];
	assert(m_rgulBitField);

	clear();
}

////////////////////////////////////////////////////////////////////////////
// Copy Constructor
////////////////////////////////////////////////////////////////////////////
SkuSet::SkuSet(const SkuSet &rhs)
{
	m_iLength = rhs.m_iLength;
	m_iSize = rhs.m_iSize;
	m_rgulBitField = new ULONG[m_iSize];
	assert(m_rgulBitField != NULL);
	for (int i=0; i<m_iSize; i++)
		m_rgulBitField[i] = rhs.m_rgulBitField[i];
}

////////////////////////////////////////////////////////////////////////////
// Destructor: release the integer array used for the bit field
////////////////////////////////////////////////////////////////////////////
SkuSet::~SkuSet()
{
	if (m_rgulBitField)
	{
		delete[] m_rgulBitField;
	}
}

////////////////////////////////////////////////////////////////////////////
// copy assignment operator
////////////////////////////////////////////////////////////////////////////
SkuSet & 
SkuSet::operator=(const SkuSet &rhs)
{
	assert(rhs.m_rgulBitField != NULL);

	if (this != &rhs)
	{
		if (m_rgulBitField) 
		{
			delete[] m_rgulBitField;
			m_rgulBitField = NULL;
		}
	
		m_iLength = rhs.m_iLength;
		m_iSize = rhs.m_iSize;
		m_rgulBitField = new ULONG[m_iSize];
		assert(m_rgulBitField != NULL);
		for (int i=0; i<m_iSize; i++)
			m_rgulBitField[i] = rhs.m_rgulBitField[i];
	}
	return *this;
}

////////////////////////////////////////////////////////////////////////////
// Overloaded bitwise operators: &=, |=, ^=, ~=
////////////////////////////////////////////////////////////////////////////
const SkuSet & 
SkuSet::operator&=(const SkuSet &rhs)
{
	assert(rhs.m_rgulBitField != NULL);
	assert (this != &rhs);
	assert(m_iLength == rhs.m_iLength);

	for (int i=0; i<m_iSize; i++)
		m_rgulBitField[i] &= (rhs.m_rgulBitField[i]);

	return *this;
}

const SkuSet & 
SkuSet::operator|=(const SkuSet &rhs)
{
	assert(rhs.m_rgulBitField != NULL);
	assert (this != &rhs);
	assert(m_iLength == rhs.m_iLength);

	for (int i=0; i<m_iSize; i++)
		m_rgulBitField[i] |= (rhs.m_rgulBitField[i]);

	return *this;
}

const SkuSet & 
SkuSet::operator^=(const SkuSet &rhs)
{
	assert(rhs.m_rgulBitField != NULL);
	assert (this != &rhs);
	assert(m_iLength == rhs.m_iLength);

	for (int i=0; i<m_iSize; i++)
		m_rgulBitField[i] ^= (rhs.m_rgulBitField[i]);

	return *this;
}

////////////////////////////////////////////////////////////////////////////
// Overloaded bitwise assignment operators: &=, |=, ^=
////////////////////////////////////////////////////////////////////////////
bool 
SkuSet::operator==(const SkuSet &rhs)
{
	assert(rhs.m_rgulBitField != NULL);

	if (this == &rhs)
		return true;

	assert(m_iLength == rhs.m_iLength);

	for (int i=0; i<m_iSize; i++)
	{
		if (m_rgulBitField[i] != rhs.m_rgulBitField[i])
			return false;
	}

	return true;
}
	
bool 
SkuSet::operator!=(const SkuSet &rhs)
{
	return !((*this)==rhs);
}

////////////////////////////////////////////////////////////////////////////
// turn on the iPos bit
////////////////////////////////////////////////////////////////////////////
void
SkuSet::set(int iPos)
{
	assert(iPos < m_iLength);
	
	int iIndex = iPos/SKUSET_UNIT_SIZE;
	int iPosition = iPos % SKUSET_UNIT_SIZE;
	UINT iMask = 1 << iPosition;

#ifdef DEBUG
	if ((m_rgulBitField[iIndex] & iMask) == 1)
		_tprintf(TEXT("Warning: this bit is set already\n"));
#endif

	m_rgulBitField[iIndex] |= iMask;
}

////////////////////////////////////////////////////////////////////////////
// return true if iPos bit is set, false otherwise
////////////////////////////////////////////////////////////////////////////
bool
SkuSet::test(int iPos)
{
	assert(iPos < m_iLength);
	
	int iIndex = iPos/SKUSET_UNIT_SIZE;
	int iPosition = iPos % SKUSET_UNIT_SIZE;
	UINT iMask = 1 << iPosition;

	return ((m_rgulBitField[iIndex] & iMask) == iMask);
}

////////////////////////////////////////////////////////////////////////////
// return # set bits
////////////////////////////////////////////////////////////////////////////
int
SkuSet::countSetBits()
{
	assert (m_rgulBitField != NULL);

	int iRetVal=0;
	ULONG iMask = 1 << (SKUSET_UNIT_SIZE - 1);

	for(int i=m_iSize-1; i>=0; i--)
	{
		ULONG ul = m_rgulBitField[i];

		for (int j=1; j<=SKUSET_UNIT_SIZE; j++)
		{
			if ((ul & iMask) == iMask)
				iRetVal++;
			ul <<= 1;
		}
	}
	return iRetVal;
}

////////////////////////////////////////////////////////////////////////////
// test if all the bits in the SkuSet is cleared
////////////////////////////////////////////////////////////////////////////
bool
SkuSet::testClear()
{
	for(int i=0; i<m_iSize; i++) 
	{
		if (0 != m_rgulBitField[i])
			return false;
	}

	return true;
}

////////////////////////////////////////////////////////////////////////////
// For debug purpose, print out the bit field
////////////////////////////////////////////////////////////////////////////
void
SkuSet::print()
{
	assert (m_rgulBitField != NULL);

	ULONG iMask = 1 << (SKUSET_UNIT_SIZE - 1);

	for(int i=m_iSize-1; i>=0; i--)
	{
		ULONG ul = m_rgulBitField[i];

		for (int j=1; j<=SKUSET_UNIT_SIZE; j++)
		{
			if ((ul & iMask) == 0)
				_tprintf(TEXT("0"));
			else
				_tprintf(TEXT("1"));
			ul <<= 1;
			if (j % CHAR_BIT == 0)
				_tprintf(TEXT(" "));
		}

	}

	_tprintf(TEXT("\n"));
}


//----------------------------------------------------------------------------
// bitwise operators for SkuSet
SkuSet operator & (const SkuSet &a, const SkuSet &b)
{
	assert(a.m_rgulBitField != NULL);
	SkuSet retVal = a;
	retVal &= b;

	return retVal;
}

SkuSet operator | (const SkuSet &a, const SkuSet &b)
{
	assert(a.m_rgulBitField != NULL);
	SkuSet retVal = a;
	retVal |= b;

	return retVal;
}

SkuSet operator ^ (const SkuSet &a, const SkuSet &b)
{
	assert(a.m_rgulBitField != NULL);
	SkuSet retVal = a;
	retVal ^= b;

	return retVal;
}


// minus(a,b) is the same as: a &(a^b). The result bit field
// consists of those bits that are set in a but not set 
// in b
SkuSet SkuSetMinus(const SkuSet &a, const SkuSet &b)
{
	assert(a.m_rgulBitField != NULL);
	assert(b.m_rgulBitField != NULL);

	SkuSet retVal = a;
	for (int i=0; i<retVal.m_iSize; i++)
		retVal.m_rgulBitField[i] = 
			retVal.m_rgulBitField[i] & 
					(retVal.m_rgulBitField[i] ^ b.m_rgulBitField[i]);

	return retVal;
}

SkuSet operator ~ (const SkuSet &a)
{
	assert(a.m_rgulBitField != NULL);

	SkuSet retVal = a;
	for (int i=0; i<retVal.m_iSize; i++)
		retVal.m_rgulBitField[i] = ~(retVal.m_rgulBitField[i]);

	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\skuset.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:     SkuSet.h
// 
//    This file contains the definition of Class SkuSet. It is basically
//	  a bit field with arbitrary length.
//--------------------------------------------------------------------------


#ifndef XMSI_SKUSET_H
#define XMSI_SKUSET_H

#include <Windows.h>
#include <tchar.h>
#include <stdio.h>
#include <limits.h>
#include <assert.h>

// # bits of ULONG
const int SKUSET_UNIT_SIZE=sizeof(ULONG)*CHAR_BIT;

class SkuSet {

	friend SkuSet operator & (const SkuSet &a, const SkuSet &b);
	friend SkuSet operator | (const SkuSet &a, const SkuSet &b);
	friend SkuSet operator ^ (const SkuSet &a, const SkuSet &b);
	friend SkuSet operator ~ (const SkuSet &a);
	friend bool testClear(const SkuSet &a);
	// minus(a, b) is the same as: a &(a^b). The result bit field
	// consists of those bits that are set in a but not set 
	// in b
	friend SkuSet SkuSetMinus(const SkuSet &a, const SkuSet &b);

public:
	SkuSet():m_iLength(0), m_iSize(0), m_rgulBitField(NULL){}

	SkuSet(int iLength);
	SkuSet(const SkuSet &);
	~SkuSet();

	// copy assignment operator
	SkuSet & operator=(const SkuSet &);

	// overload bitwise assignment operators
	const SkuSet & operator&=(const SkuSet &);
	const SkuSet & operator|=(const SkuSet &);
	const SkuSet & operator^=(const SkuSet &);

	// overload ==, !=
	bool operator==(const SkuSet &);
	bool operator!=(const SkuSet &);

	// set a certain bit in the bitfield
	void set(int iPos);

	// set all bits in the bitfield
	void setAllBits() {for(int i=0; i<m_iLength; i++) set(i); }
	
	// test a certain bit in the bitfield
	bool test(int iPos);

	// return the # set bits
	int countSetBits();

	// test if this bitfield is all cleared (no bit set)
	bool testClear();

	// clear the bitfield to all 0s
	void clear() {for(int i=0; i<m_iSize; i++) m_rgulBitField[i] = 0; }

	void print();

	// member access function
	int getLength(){return m_iLength;}
	int getSize(){return m_iSize;}
private:
	int m_iLength; // the length of the bit field
	int m_iSize;   // # integers that is used to represent the bit field
	ULONG *m_rgulBitField;
};

#endif //XMSI_SKUSET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\sources.inc ===
TARGETNAME=wmc
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

UMTYPE=console
UMENTRY=$(MSI_ENTRY)
USE_NATIVE_EH=1

TARGETPATH=$(MSI_BUILD_TARGET)
TARGETLIBS=\
        $(BUILD_DIR)\msi.lib \
	$(SDK_LIB_PATH)\kernel32.lib \
	$(SDK_LIB_PATH)\user32.lib \
	$(SDK_LIB_PATH)\gdi32.lib \
	$(SDK_LIB_PATH)\winspool.lib \
	$(SDK_LIB_PATH)\comdlg32.lib \
	$(SDK_LIB_PATH)\advapi32.lib \
	$(SDK_LIB_PATH)\shell32.lib \
	$(SDK_LIB_PATH)\ole32.lib \
	$(SDK_LIB_PATH)\oleaut32.lib \
	$(SDK_LIB_PATH)\uuid.lib \
	$(SDK_LIB_PATH)\odbc32.lib \
	$(SDK_LIB_PATH)\odbccp32.lib \
	$(SDK_LIB_PATH)\urlmon.lib \
	$(SDK_LIB_PATH)\msvcprt.lib
	 

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(BUILD_COMMONDIR);$(INC_DIR);$(RES_OBJDIR)

SOURCES=..\query.cpp \
	..\SkuSet.cpp\
	..\SKUFilterExprNode.cpp \
	..\CommandOpt.cpp\
	..\Sku.cpp\
	..\SkuSetVals.cpp \
	..\ElementEntry.cpp\
	..\Component.cpp\
	..\utilities.cpp \
	..\componentFuncs.cpp \
	..\mainFuncs.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\res\ansi\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\skusetvals.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  Project: wmc (WIML to MSI Compiler)
//
//  File:       SkuSetValues.cpp
//
//    This file contains the implementation of SkuSetValues class
//--------------------------------------------------------------------------

#include "wmc.h"

////////////////////////////////////////////////////////////////////////////
// Constructor: 
////////////////////////////////////////////////////////////////////////////
SkuSetValues::SkuSetValues()
{
	m_pVecSkuSetVals = new vector<SkuSetVal *>;
	assert(m_pVecSkuSetVals);

	m_iter = m_pVecSkuSetVals->begin();
}

////////////////////////////////////////////////////////////////////////////
// Destructor: 
////////////////////////////////////////////////////////////////////////////
SkuSetValues::~SkuSetValues()
{
	if (m_pVecSkuSetVals) 
	{
		for (m_iter = m_pVecSkuSetVals->begin(); 
			 m_iter != m_pVecSkuSetVals->end(); 
			 m_iter++)	 
		{
			if (*m_iter)
			{
				delete (*m_iter)->pSkuSet;
				switch (m_vt) 
				{
					case STRING:
						delete[] (*m_iter)->isVal.szVal;
						break;
					case STRING_LIST:
					{
						// free all the strings stored on the list
						set<LPTSTR, Cstring_less>::iterator it;
						set<LPTSTR, Cstring_less> *pSetString;
						pSetString = (*m_iter)->isVal.pSetString;
						if (pSetString)
						{
							for(it = pSetString->begin(); 
								it != pSetString->end(); ++it)
							{
								if (*it)
									delete[] (*it);
							}
							delete pSetString;
						}
						break;
					}
					case FM_PAIR:
					{
						FOM *pFOM = (*m_iter)->isVal.pFOM;
						if (pFOM)
						{
							//delete stored feature name
							if (pFOM->szFeature)
								delete[] pFOM->szFeature;
							//delete stored module name
							if (pFOM->szModule)
								delete[] pFOM->szModule;
							delete pFOM;
						}
						break;
					}
				}
				delete *m_iter;
			}
		}

		delete m_pVecSkuSetVals;
	}
}

////////////////////////////////////////////////////////////////////////////
// DirectInsert: store the pointer (caller should allocate memory)
////////////////////////////////////////////////////////////////////////////
void
SkuSetValues::DirectInsert(SkuSetVal *pSkuSetVal)
{
	assert(pSkuSetVal);


	if (pSkuSetVal->pSkuSet->testClear())
	{
#ifdef DEBUG
		_tprintf(TEXT("\nAttempting to store a SkuSetVal associated with an")
				TEXT(" EMPTY SkuSet\n\n"));
#endif
		return;
	}

	m_pVecSkuSetVals->push_back(pSkuSetVal);
}

////////////////////////////////////////////////////////////////////////////
// DirectInsert: construct a new SkuSetVal object using the passed-in values
//				(caller should allocate memory for *pSkuSet)
////////////////////////////////////////////////////////////////////////////
void
SkuSetValues::DirectInsert(SkuSet *pSkuSet, IntStringValue isVal)
{
	assert(pSkuSet);

	SkuSetVal *pSkuSetVal = new SkuSetVal;
	assert(pSkuSetVal);

	pSkuSetVal->isVal = isVal;
	pSkuSetVal->pSkuSet = pSkuSet;

	DirectInsert(pSkuSetVal);
}

////////////////////////////////////////////////////////////////////////////
// CollapseInsert: Sometimes when inserting into the list of <SkuSet, Value>
//				   data structure, we want to collapse the SkuSets with the
//				   same value into one slot. One example is when inserting
//				   into a data structure storing references (to Directories,
//				   to InstallLevels, etc.)
//				   when NoRepeat is set to true, the compiler will check 
//				   that for any given SKU, the value to be inserted is not 
//				   on the list already. This solves the problem of checking
//				   the uniqueness of an attribute - sometimes an attribute
//				   corresponds to a DB column(primary key) instead of the 
//				   element that the attribute belongs to
////////////////////////////////////////////////////////////////////////////
HRESULT
SkuSetValues::CollapseInsert(SkuSet *pSkuSet, IntStringValue isVal, bool NoDuplicate)
{
	HRESULT hr = S_OK;
	vector<SkuSetVal *>::iterator iter;

	assert(pSkuSet);

	if (pSkuSet->testClear())
	{
#ifdef DEBUG
		_tprintf(TEXT("\nAttempting to store a SkuSetVal associated with an")
				TEXT(" EMPTY SkuSet\n\n"));
#endif
		return S_FALSE;
	}

	SkuSet *b = pSkuSet;
	SkuSet *a = NULL;

	if (m_pVecSkuSetVals->empty())
	{
		SkuSetVal *pSV = new SkuSetVal;
		assert(pSV);
		pSV->pSkuSet = pSkuSet;
		pSV->isVal = isVal;
		m_pVecSkuSetVals->push_back(pSV);
	}
	else
	{
		for (iter = m_pVecSkuSetVals->begin();
			 iter != m_pVecSkuSetVals->end();
			 iter++)
		{
			assert(*iter);
			a = (*iter)->pSkuSet;

			// same value
			if ( ((STRING == m_vt) && (0 == _tcscmp((*iter)->isVal.szVal, isVal.szVal))) ||
				 ((INTEGER == m_vt) && (isVal.intVal == (*iter)->isVal.intVal)) )
			{
				// check for no duplicate value
				if (NoDuplicate)
				{
					SkuSet skuSetTemp = (*a) & (*b);
					if (!skuSetTemp.testClear())
					{
						if (STRING == m_vt)
							_tprintf(TEXT("Compile Error: Value %s exists already\n"), 
											isVal.szVal);
						else
							_tprintf(TEXT("Compile Error: Value %d exists already\n"), 
											isVal.intVal);
						hr = E_FAIL;
						break;
					}
				}

				// update the SkuSet stored to include the newly added SKUs
				*((*iter)->pSkuSet) |= *b;
				b->clear();
				break;
			}
		}

		if (SUCCEEDED(hr) && !b->testClear())
		{
			// there is no chance to collapse, insert the new value
			SkuSetVal *pSV = new SkuSetVal;
			pSV->pSkuSet = b;
			pSV->isVal = isVal;
			// Store the new value
			m_pVecSkuSetVals->push_back(pSV);
		}
		else
		{
			if (STRING == m_vt)
				delete[] isVal.szVal;
			delete b;
			pSkuSet = NULL;
		}
	}

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// SplitInsert: go through the value stored on the vector so far
//				a : SkuSet stored; b : SkuSet to be added
//			    Get 3 new SkuSets: 
//					1) a-b: should remain the old attr value;
//					2) a&b: should update to old|new
//					3)b-a: used as new b to process the next element
//				Insert the newly generated SkuSets a-b, a&b into the vector
//				if they are not empty.
//				Finally if b is not empty, insert b into the vector
//				*pSkuSet is destroyed after the function call.
////////////////////////////////////////////////////////////////////////////
HRESULT
SkuSetValues::SplitInsert(SkuSet *pSkuSet, IntStringValue isVal, 
						  HRESULT (*UpdateFunc)
							(IntStringValue *pisValOut, IntStringValue isValOld, 
												IntStringValue isValNew))
{
	assert(pSkuSet);
	extern void PrintSkuIDs(SkuSet *);

	if (pSkuSet->testClear())
	{
#ifdef DEBUG
		_tprintf(TEXT("\nAttempting to store a SkuSetVal associated with an")
				TEXT(" EMPTY SkuSet\n\n"));
#endif
		return S_FALSE;
	}

	HRESULT hr = S_OK;
	SkuSet *a = NULL;
	SkuSet *b = pSkuSet;
	vector<SkuSetVal *> vecTemp; // temporary storage to move SkuSetVals around
	vector<SkuSetVal *>::iterator iter;

	// first time insertion or this is the first entity that
	// corresponds to a column value, just insert directly
	if (m_pVecSkuSetVals->empty() || (!UpdateFunc))
	{
		SkuSetVal *pSV = new SkuSetVal;
		assert(pSV);
		pSV->pSkuSet = pSkuSet;
		if (STRING_LIST == m_vt)
		{
			// construct a new set and put the first Feature in the set
			set<LPTSTR, Cstring_less> *pSetStringFirst = 
										new set<LPTSTR, Cstring_less>;
			assert(pSetStringFirst);
			pSetStringFirst->insert(isVal.szVal);
			isVal.pSetString = pSetStringFirst;
		}
		pSV->isVal = isVal;
		m_pVecSkuSetVals->push_back(pSV);
	}
	else
	{
		for (iter = m_pVecSkuSetVals->begin();
			 iter != m_pVecSkuSetVals->end();
			 iter++)
		{
			assert(*iter);
			a = (*iter)->pSkuSet;

			(*iter)->isVal;

			// test for special case: a, b completely overlap
			if ( *a == *b)
			{ 
				// Get the updated value
				IntStringValue isValTemp;
				hr = UpdateFunc(&isValTemp, (*iter)->isVal, isVal);
				if (FAILED(hr))
				{
					_tprintf(TEXT("in SKU: "));
					PrintSkuIDs(a);
					delete b;
					switch (m_vt)
					{
						case STRING:
						case STRING_LIST:
							if (isVal.szVal)
								delete[] isVal.szVal;
							break;
						case FM_PAIR:
							delete[] (isVal.pFOM)->szFeature;
							delete[] (isVal.pFOM)->szModule;
							delete isVal.pFOM;
							break;
					}					
					break;
				}

				// old value is no longer good, destroy it
				switch (m_vt)
				{
					case STRING:
						if ((*iter)->isVal.szVal)
							delete[] (*iter)->isVal.szVal;
						break;
					case FM_PAIR:
						delete[] ((*iter)->isVal.pFOM)->szFeature;
						delete[] ((*iter)->isVal.pFOM)->szModule;
						delete (*iter)->isVal.pFOM;
						break;
					case STRING_LIST:
					{
						// free all the strings stored on the list
						set<LPTSTR, Cstring_less>::iterator it;
						set<LPTSTR, Cstring_less> *pSetString;
						pSetString = (*iter)->isVal.pSetString;
						if (pSetString)
						{
							for(it = pSetString->begin(); 
								it != pSetString->end(); ++it)
							{
								if (*it)
									delete[] (*it);
							}
							delete pSetString;
						}						
						break;
					}
				}

				(*iter)->isVal = isValTemp;

				// the rest of the elements on the list should
				// all be kept
				for (; iter != m_pVecSkuSetVals->end(); iter++)
					vecTemp.push_back(*iter);
				b->clear();
				break;
			}

			// a & b
			SkuSet *pSkuSet_a_and_b = new SkuSet(g_cSkus);
			assert(pSkuSet_a_and_b);
			*pSkuSet_a_and_b = (*a) & (*b);
			if(!pSkuSet_a_and_b->testClear())
			{
				SkuSetVal *pSV = new SkuSetVal;
				assert(pSV);
				pSV->pSkuSet = pSkuSet_a_and_b;
				// update the collided value
				if (UpdateFunc)
					hr = UpdateFunc(&(pSV->isVal), (*iter)->isVal, isVal);
				if (FAILED(hr))
				{
					_tprintf(TEXT("in SKU: "));
					PrintSkuIDs(pSkuSet_a_and_b);
					delete pSkuSet_a_and_b;
					delete pSV;
					delete b;
					switch (m_vt)
					{
						case STRING:
						case STRING_LIST: 
							if (isVal.szVal)
								delete[] isVal.szVal;
							break;
						case FM_PAIR:
							delete[] (isVal.pFOM)->szFeature;
							delete[] (isVal.pFOM)->szModule;
							delete isVal.pFOM;
							break;
					}					
					break;
				}
				// store the splitted part
				vecTemp.push_back(pSV);
			}
			else
			{
				delete pSkuSet_a_and_b;
				//a is to stay
				vecTemp.push_back(*iter);
				//a, b don't overlap at all, no need to process a-b
				continue;
			}

			// a - b
			SkuSet *pSkuSet_a_minus_b = new SkuSet(g_cSkus);
			assert(pSkuSet_a_minus_b);
			*pSkuSet_a_minus_b = SkuSetMinus(*a, *b);

			if(!pSkuSet_a_minus_b->testClear())
			{
				SkuSetVal *pSV = new SkuSetVal;
				assert(pSV);
				pSV->pSkuSet = pSkuSet_a_minus_b;
				// keep the original value
				pSV->isVal = (*iter)->isVal;
				// store the splitted part
				vecTemp.push_back(pSV);
			}
			else
			{
				delete pSkuSet_a_minus_b;
				// the old element is completely replaced
				// by the new one
				// release the memory used by the unwanted element
				// old value is no longer good, destroy it
				// Issue: wrap the following switch clause in a function
				switch (m_vt)
				{
					case STRING:
						if ((*iter)->isVal.szVal)
							delete[] (*iter)->isVal.szVal;
						break;
					case FM_PAIR:
						delete[] ((*iter)->isVal.pFOM)->szFeature;
						delete[] ((*iter)->isVal.pFOM)->szModule;
						delete (*iter)->isVal.pFOM;
						break;
					case STRING_LIST:
					{
						// free all the strings stored on the list
						set<LPTSTR, Cstring_less>::iterator it;
						set<LPTSTR, Cstring_less> *pSetString;
						pSetString = (*iter)->isVal.pSetString;
						if (pSetString)
						{
							for(it = pSetString->begin(); 
								it != pSetString->end(); ++it)
							{
								if (*it)
									delete[] (*it);
							}
							delete pSetString;
						}						
						break;
					}
				}
			}

			// b - a
			*b = SkuSetMinus(*b, *a);
			delete (*iter)->pSkuSet;
			delete (*iter);
		}

		if (SUCCEEDED(hr))
		{
			if (!b->testClear())
			{
				// this is the first time for the SKUs in b to get a value
				// form a SkuSetVal element and insert it into the list
				SkuSetVal *pSV = new SkuSetVal;
				pSV->pSkuSet = b;
				// if the value to be stored should be a STRING_LIST, 
				// need to change the input new value from a LPTSTR
				// to a StringSet
				if (STRING_LIST == m_vt)
				{
					set<LPTSTR, Cstring_less> *pSetStringNew
						= new set<LPTSTR, Cstring_less>;
					assert(pSetStringNew);
					pSetStringNew->insert(isVal.szVal);
					isVal.pSetString = pSetStringNew;
				}
				pSV->isVal = isVal;
				// Store the new value
				vecTemp.push_back(pSV);
			}
			else
			{
				// input value is useless now since there is no SKU that
				// should take that value. destroy it.
				switch (m_vt)
				{
					case STRING:
					case STRING_LIST: // even the value to be stored is STRING_LIST
									 // the input value is just a LPTSTR
						if (isVal.szVal)
							delete[] isVal.szVal;
						break;
					case FM_PAIR:
						delete[] (isVal.pFOM)->szFeature;
						delete[] (isVal.pFOM)->szModule;
						delete isVal.pFOM;
						break;
				}
				delete b;
				pSkuSet = NULL;
			}
			// erase the processed elements
			m_pVecSkuSetVals->erase(m_pVecSkuSetVals->begin(), m_pVecSkuSetVals->end());

			//insert the newly generated elements
			m_pVecSkuSetVals->insert(m_pVecSkuSetVals->begin(), vecTemp.begin(), 
										vecTemp.end());
		}
	}

	return hr;
}
	
////////////////////////////////////////////////////////////////////////////
// SplitInsert: (caller should allocate memory for *pSkuSetVal)
//				simply calls the other overloaded function
////////////////////////////////////////////////////////////////////////////
HRESULT
SkuSetValues::SplitInsert(SkuSetVal *pSkuSetVal, 
						  HRESULT (*UpdateFunc)
								(IntStringValue *pIsValOut, IntStringValue isValOld, 
								 IntStringValue isValNew))
{
	assert(pSkuSetVal);
	IntStringValue isVal = pSkuSetVal->isVal;
	SkuSet *pSkuSet = pSkuSetVal->pSkuSet;

	return SplitInsert(pSkuSet, isVal, UpdateFunc);
}

////////////////////////////////////////////////////////////////////////////
// return the value(s) of a set of Skus in the form of
// a SkuSetValues object. Return E_FAIL and set passed-in object to NULL
// if some of the SKUs don't exist in the data structure since this function
// will be mainly used to query stored references. *pSkuSet is untouched.
////////////////////////////////////////////////////////////////////////////
HRESULT 
SkuSetValues::GetValueSkuSet(SkuSet *pSkuSet, 
							SkuSetValues **ppSkuSetValuesRetVal)
{
	extern void PrintSkuIDs(SkuSet *pSkuSet);
	assert(pSkuSet);
	HRESULT hr = S_OK;
	vector<SkuSetVal *>::iterator iter;

	if (pSkuSet->testClear())
	{
#ifdef DEBUG
		_tprintf(TEXT("Warning: attempt to call GetValueSkuSet with")
				 TEXT(" an empty SkuSet\n"));
#endif
		return S_FALSE;
	}

	if (!*ppSkuSetValuesRetVal)
		*ppSkuSetValuesRetVal = new SkuSetValues;
	
	assert(*ppSkuSetValuesRetVal);

	// when the type is FM_PAIR, only the Feature information is needed
	// so the type will be set to STRING
	if (FM_PAIR == m_vt)
		(*ppSkuSetValuesRetVal)->SetValType(STRING);
	else
		(*ppSkuSetValuesRetVal)->SetValType(m_vt);

	SkuSet *b = new SkuSet(g_cSkus);
	*b = *pSkuSet;
	SkuSet *a = NULL;

	for (iter = m_pVecSkuSetVals->begin();
		 iter != m_pVecSkuSetVals->end();
		 iter++)
	{
		assert(*iter);
		a = (*iter)->pSkuSet;
		// test for special case: a, b completely overlap
		if ( *a == *b)
		{ 
			// make a completely copy of *iter
			// Issue: it might be easier to make SkuSetVal a class 
			//		  rather than a struct and give it a copy constructor
			SkuSet *pSkuSetNew = new SkuSet(g_cSkus);
			*pSkuSetNew = *b;
			IntStringValue isValNew;
			switch (m_vt)
			{
				case STRING:
					isValNew.szVal = _tcsdup((*iter)->isVal.szVal);
					assert(isValNew.szVal);
					break;
				case INSTALL_LEVEL:
					// for the sake of InstallLevelRefs
					if(-1 == (*iter)->isVal.intVal)
						(*iter)->isVal.intVal = 0;
					else
						isValNew = (*iter)->isVal;
					break;
				case FM_PAIR:
				{// only Feature is needed 
					isValNew.szVal = 
								_tcsdup(((*iter)->isVal.pFOM)->szFeature);
					assert(isValNew.szVal);
					break;
				}
				case INTEGER:
					isValNew = (*iter)->isVal;
			}

			// insert the copy into the return data structure
			// Issue: it might speed up the future processing if 
			//		  call CollapseInsert to do the insertion 
			(*ppSkuSetValuesRetVal)->DirectInsert(pSkuSetNew, isValNew);

			b->clear();
			break;
		}

		// a & b
		SkuSet *pSkuSet_a_and_b = new SkuSet(g_cSkus);
		assert(pSkuSet_a_and_b);
		*pSkuSet_a_and_b = (*a) & (*b);
		if(!pSkuSet_a_and_b->testClear())
		{
			IntStringValue isValNew;
			switch (m_vt)
			{
				case STRING:
					isValNew.szVal = _tcsdup((*iter)->isVal.szVal);
					assert(isValNew.szVal);
					break;
				case INSTALL_LEVEL:
					// for the sake of InstallLevelRefs
					if(-1 == (*iter)->isVal.intVal)
						(*iter)->isVal.intVal = 0;
					else
						isValNew = (*iter)->isVal;
					break;
				case FM_PAIR:
				{
					FOM *pFOMNew = new FOM;
					pFOMNew->szFeature = 
								_tcsdup(((*iter)->isVal.pFOM)->szFeature);
					assert(pFOMNew->szFeature);
					pFOMNew->szModule = 
								_tcsdup(((*iter)->isVal.pFOM)->szModule);
					assert(pFOMNew->szModule);
					isValNew.pFOM = pFOMNew;
					break;
				}
				case INTEGER:
					isValNew = (*iter)->isVal;
			}
			// insert this part into the return data structure
			(*ppSkuSetValuesRetVal)->DirectInsert(pSkuSet_a_and_b, isValNew);			
		}
		else
		{
			delete pSkuSet_a_and_b;
		}

		// b - a
		*b = SkuSetMinus(*b, *a);
	}

	if (!b->testClear())
	{
		// this is an error: some of the Skus under interest don't
		// have a value specified. If it is references that are stored,
		// this means that those SKUs are refering to sth that don't 
		// belong to them. If this is a KeyPath, it means that some SKUs
		// don't have a KeyPath specified for this Component. If it is
		// Ownership information, it means that some SKUs don't have 
		// Ownership information specified for this component. All of these 
		// are errors to be caught.
		_tprintf(TEXT("Compile Error: Following SKUs: "));
		PrintSkuIDs(b);
		// let the caller finish the error message
		hr = E_FAIL;
	}
	delete b;

	if (FAILED(hr))
	{
		delete *ppSkuSetValuesRetVal;
		*ppSkuSetValuesRetVal = NULL;
	}
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// GetValue: return the value stored for any given SKU
////////////////////////////////////////////////////////////////////////////
IntStringValue 
SkuSetValues::GetValue(int iPos)
{
	assert(m_pVecSkuSetVals);

	vector<SkuSetVal *>::iterator iter;

	for (iter = m_pVecSkuSetVals->begin(); 
		 iter != m_pVecSkuSetVals->end(); 
		 iter++)	 
	{
		if (*iter)
		{
			if ((*iter)->pSkuSet->test(iPos))
				return (*iter)->isVal;
		}
	}

	IntStringValue isVal;

	if (INTEGER == m_vt)
		isVal.intVal = MSI_NULL_INTEGER;
	else
		isVal.szVal = NULL;

	return isVal;
}

////////////////////////////////////////////////////////////////////////////
// GetMostCommon: return the pointer to the SkuSetVal that stores the most 
//				  common value (its SkuSet has the most bits set)
////////////////////////////////////////////////////////////////////////////
SkuSetVal *
SkuSetValues::GetMostCommon()
{
	assert(m_pVecSkuSetVals);

	vector<SkuSetVal *>::iterator iter;
	SkuSetVal *skuSetValRetVal = NULL;
	int cSetBitsMax = 0;

	for (iter = m_pVecSkuSetVals->begin(); 
		 iter != m_pVecSkuSetVals->end(); 
		 iter++)	 
	{
		if (*iter)
		{
			int i = (*iter)->pSkuSet->countSetBits();
			if (i>cSetBitsMax)
			{
				cSetBitsMax = i;
				skuSetValRetVal = *iter;
			}				
		}
	}

	return skuSetValRetVal;
}

////////////////////////////////////////////////////////////////////////////
// Start: return the first value stored
////////////////////////////////////////////////////////////////////////////
SkuSetVal *
SkuSetValues::Start()
{
	m_iter = m_pVecSkuSetVals->begin();
	return *m_iter;
}

////////////////////////////////////////////////////////////////////////////
// Next: return the next value
////////////////////////////////////////////////////////////////////////////
SkuSetVal *
SkuSetValues::Next()
{
	m_iter++;
	return *m_iter;
}

////////////////////////////////////////////////////////////////////////////
// End: return the last value stored
////////////////////////////////////////////////////////////////////////////
SkuSetVal *
SkuSetValues::End()
{
	return *m_pVecSkuSetVals->end();
}

////////////////////////////////////////////////////////////////////////////
// Empty: return true if the vector is empty; false otherwise
////////////////////////////////////////////////////////////////////////////
bool
SkuSetValues::Empty()
{
	return m_pVecSkuSetVals->empty();
}

////////////////////////////////////////////////////////////////////////////
// Erase: erase the element from the storage W/O freeing memory
////////////////////////////////////////////////////////////////////////////
void
SkuSetValues::Erase(SkuSetVal *pSkuSetVal)
{
	vector<SkuSetVal *>::iterator iter =
		find(m_pVecSkuSetVals->begin(), m_pVecSkuSetVals->end(), pSkuSetVal);

	if (iter != m_pVecSkuSetVals->end())
		m_pVecSkuSetVals->erase(iter);
}

////////////////////////////////////////////////////////////////////////////
// Print: for debug purpose
////////////////////////////////////////////////////////////////////////////
void
SkuSetValues::Print()
{
	vector<SkuSetVal *>::iterator iter;

	_tprintf(TEXT("\n"));

	for (iter = m_pVecSkuSetVals->begin(); 
		 iter != m_pVecSkuSetVals->end(); 
		 iter++)	 
	{
		if (*iter)
		{
			(*iter)->pSkuSet->print();
			switch (m_vt)
			{
				case STRING:
					_tprintf(TEXT("%s\n"), (*iter)->isVal.szVal);
					break;
				case INTEGER:
				case INSTALL_LEVEL:
					_tprintf(TEXT("%d\n"), (*iter)->isVal.intVal);
					break;
				case FM_PAIR:
					_tprintf(TEXT("Feature: %s\tModule: %s\n"), 
						((*iter)->isVal.pFOM)->szFeature,
						((*iter)->isVal.pFOM)->szModule);
					break;
				case STRING_LIST:
				{
					set<LPTSTR, Cstring_less>::iterator it;
					set<LPTSTR, Cstring_less> *pSetString;
					pSetString = (*iter)->isVal.pSetString;
					if (pSetString)
					{
						for(it = pSetString->begin(); 
							it != pSetString->end(); ++it)
						{
							if (*it)
								_tprintf(TEXT("%s "), *it);
						}
						_tprintf(TEXT("\n"));
					}
					break;
				}
			}
		}
	}

	_tprintf(TEXT("\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\res\unicode\makefile.inc ===
!INCLUDE ..\make.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\utilities.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:      helper.cpp
// 
//    This file contains the utility functions used by the wmc
//    project.
//--------------------------------------------------------------------------

#include "Utilities.h"
#include "SKUFilterExprNode.h"

////////////////////////////////////////////////////////////////////////////
// CleanUp: free the memory from the global data structure
////////////////////////////////////////////////////////////////////////////
void CleanUp()
{
	// free Directory reference
	map<LPTSTR, SkuSetValues *, Cstring_less>::iterator it_LS;

	for (it_LS = g_mapDirectoryRefs_SKU.begin(); 
		 it_LS != g_mapDirectoryRefs_SKU.end(); 
		 ++it_LS)
	{
		if ((*it_LS).first)
			delete[] (*it_LS).first;
		if ((*it_LS).second)
			delete (*it_LS).second;
	}

	// free InstallLevel reference
	for (it_LS = g_mapInstallLevelRefs_SKU.begin(); 
		 it_LS != g_mapInstallLevelRefs_SKU.end(); 
		 ++it_LS)
	{
		if ((*it_LS).first)
			delete[] (*it_LS).first;
		if ((*it_LS).second)
			delete (*it_LS).second;
	}

	// free Component Objects
	map<LPTSTR, Component *, Cstring_less>::iterator it_LC;

	for (it_LC = g_mapComponents.begin(); 
		 it_LC != g_mapComponents.end(); 
		 ++it_LC)
	{
		if ((*it_LC).first)
			delete[] (*it_LC).first;
		if ((*it_LC).second)
			delete (*it_LC).second;
	}

	map<LPTSTR, SkuSet *, Cstring_less>::iterator it_LSS;

	// free SkuSet Objects
	for (it_LSS = g_mapSkuSets.begin(); 
		 it_LSS != g_mapSkuSets.end(); 
		 ++it_LSS)
	{
		if ((*it_LSS).first)
			delete[] (*it_LSS).first;
		if ((*it_LSS).second)
			delete (*it_LSS).second;
	}

	// free the map storing FileID - SkuSet relationships
	for (it_LSS = g_mapFiles.begin(); 
		 it_LSS != g_mapFiles.end(); 
		 ++it_LSS)
	{
		if ((*it_LSS).first)
			delete[] (*it_LSS).first;
		if ((*it_LSS).second)
			delete (*it_LSS).second;
	}

	map<LPTSTR, int, Cstring_less>::iterator it_LI;
	// free string stored inside g_mapTableCounter
	for (it_LI = g_mapTableCounter.begin(); 
		 it_LI != g_mapTableCounter.end(); 
		 ++it_LI)
	{
		if ((*it_LI).first)
			delete[] (*it_LI).first;
	}

	// free Sku objects
	if (g_rgpSkus)
	{
		for (int i=0; i<g_cSkus; i++)
		{
			if (g_rgpSkus[i])
				delete g_rgpSkus[i];
		}
	}
}
////////////////////////////////////////////////////////////////////////////
// compares the relationship of the 2 modules in the module tree. Return 
// the comparison result through iResult. if szModule1 is an ancestor
// of szModule2, *iResult is set to -1. if szModule1 is a descendant of 
// szModule2, *iResult is set to 1. if szModule1 is the same as szModule2 
// or the 2 modules doesn't belong to the same Module subtree, iResult is
// set to 0. This is an error to catch for the caller.
////////////////////////////////////////////////////////////////////////////
HRESULT CompareModuleRel(LPTSTR szModule1, LPTSTR szModule2, int *iResult)
{
	HRESULT hr = S_OK;
	PIXMLDOMNode pNodeModule1 = NULL;
	PIXMLDOMNode pNodeModule2 = NULL;

	// comparing the same modules
	if (0 == _tcscmp(szModule1, szModule2))
	{
		*iResult = 0;
		return S_FALSE;
	}

	int iLength = _tcslen(
					TEXT("/ProductFamily/Modules//Module[ @ID = \"\"]"));
	int iLength1 = _tcslen(szModule1);
	int iLength2 = _tcslen(szModule2);

	// form the XPath for searching for szModule1 inside the whole doc
	LPTSTR szXPath_Root_1 = new TCHAR[iLength1+iLength+1];
	assert(szXPath_Root_1);
	_stprintf(szXPath_Root_1, 
		TEXT("/ProductFamily/Modules//Module[ @ID = \"%s\"]"), szModule1);

	// check for szModule1 < szModule2 first (1 is an ancestor of 2)
	if (SUCCEEDED(hr = GetChildNode(g_pNodeProductFamily, szXPath_Root_1, 
									pNodeModule1)))
	{
		delete[] szXPath_Root_1;
		assert(S_FALSE != hr);

		//form the XPath for searching for szModule2 inside the current context
		LPTSTR szXPath_1_2 = new TCHAR[iLength2+25];
		assert(szXPath_1_2);
		_stprintf(szXPath_1_2, TEXT(".//Module[ @ID = \"%s\"]"), szModule2);

		if (SUCCEEDED(hr = 
			GetChildNode(pNodeModule1, szXPath_1_2, pNodeModule2)))
		{
			delete[] szXPath_1_2;
			if (S_FALSE != hr)
			{
				// found szModule2 inside the subtree rooted at szModule1
				*iResult = -1;
				return hr;
			}
		}
		else
			delete[] szXPath_1_2;
	}
	else
	{
		delete[] szXPath_Root_1;
	}

	// check for szModule1 > szModule2 (1 is a descendant of 2)
	if (SUCCEEDED(hr))
	{
		//form the XPath for searching for szModule2 inside the whole doc
		LPTSTR szXPath_Root_2 = new TCHAR[iLength2+iLength+1];
		assert(szXPath_Root_2);
		_stprintf(szXPath_Root_2, 
			TEXT("/ProductFamily/Modules//Module[ @ID = \"%s\"]"), szModule2);

		if (SUCCEEDED(hr = GetChildNode(g_pNodeProductFamily, szXPath_Root_2, 
										pNodeModule2)))
		{
			delete[] szXPath_Root_2;
			assert(S_FALSE != hr);

			// form the XPath for searching for szModule1 inside the current 
			//	context
			LPTSTR szXPath_2_1 = new TCHAR[iLength1+25];
			assert(szXPath_2_1);
			_stprintf(szXPath_2_1, TEXT(".//Module[ @ID = \"%s\"]"),szModule1);

			if (SUCCEEDED(hr = 
				GetChildNode(pNodeModule2, szXPath_2_1, pNodeModule1)))
			{
				delete[] szXPath_2_1;
				if (S_FALSE != hr)
				{
					// found szModule1 inside the subtree rooted at szModule2
					*iResult = 1;
					return hr;
				}
			}
			else
				delete[] szXPath_2_1;
		}
		else
			delete[] szXPath_Root_1;
	}

	// szModule1 and szModule2 don't exist in the same subtree
	*iResult = 0;

	return hr;

}

////////////////////////////////////////////////////////////////////////////
// PrintSkuNames: Given a SkuSet, print out the IDs of all SKUs in the set
////////////////////////////////////////////////////////////////////////////
void PrintSkuIDs(SkuSet *pSkuSet)
{
	for (int i=0; i<g_cSkus; i++)
	{
		if (pSkuSet->test(i))
			_tprintf(TEXT("%s "), g_rgpSkus[i]->GetID());
	}
	_tprintf(TEXT("\n"));
}

////////////////////////////////////////////////////////////////////////////
// ProcessSkuFilter
//    Given a Sku filter string, return the SkuSet that represents the result
//		Sku Group.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSkuFilter(LPTSTR szSkuFilter, SkuSet **ppskuSet)
{
	HRESULT hr = S_OK;
	LPTSTR sz = szSkuFilter;

#ifdef DEBUG
	_tprintf(TEXT("Inside Function ProcessSkuFilter\n"));
#endif

	printf("Sku filter: %s\n", szSkuFilter);
	*ppskuSet = new SkuSet(g_cSkus);
	assert(*ppskuSet != NULL);

	if (szSkuFilter == NULL)
	{
		// no filter = a sku group contains all SKUs
		(*ppskuSet)->setAllBits();
	}
	else
	{
		SKUFilterExprNode *pSKUFilterNode 
			= new SKUFilterExprNode(&sz, SKUFilterExprNode::Filter);
		assert(pSKUFilterNode != NULL);
        if (!pSKUFilterNode->errpos) 
		{
			**ppskuSet = *(pSKUFilterNode->m_pSkuSet);
        } 
		else
		{
			_tprintf(TEXT("Sku Filter : %s\n"), szSkuFilter);
			TCHAR sz[32];
            _stprintf(sz, TEXT("Error      : %%%dc %%s\n"), 
								pSKUFilterNode->errpos-szSkuFilter+1);
            _tprintf(sz,TEXT('^'),pSKUFilterNode->errstr);

			hr = E_FAIL;
        }
        delete pSKUFilterNode;
	}

#ifdef DEBUG
	if (FAILED(hr)) 
	{
		_tprintf(TEXT("Error in function: ProcessSkuFilter\n"));
		delete *ppskuSet;
		*ppskuSet = NULL;
	}

#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// GetSkuSet
//    Given a node:
//		1) Get the Sku Filter specified with the node;
//		2) Process the filter and get the result SkuSet;
//		3) Return the SkuSet via ppskuSet;
////////////////////////////////////////////////////////////////////////////
HRESULT GetSkuSet(PIXMLDOMNode &pNode, SkuSet **ppskuSet)
{
	HRESULT hr = S_OK;
	IntStringValue isVal;

	if (SUCCEEDED(hr = ProcessAttribute(pNode, TEXT("SKU"), STRING, 
										&isVal, NULL)))
	{
		hr = ProcessSkuFilter(isVal.szVal, ppskuSet);

		if (isVal.szVal)
			delete[] isVal.szVal;
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: GetSkuSet\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// ProcessAttribute
//    Given a parent node, an attribute name and an attribute type (int or
//	  string),  this function returns the string value of the attribute 
//	  via isVal. If the attribute doesn't exist, value returned will be
//	  NULL if vt = STRING, or 0 if vt = INTEGER. If the attribute doesn't
//	  exist, return S_FALSE.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessAttribute(PIXMLDOMNode &pNodeParent, LPCTSTR szAttributeName,
						 ValType vt, IntStringValue *pisVal, 
						 const SkuSet *pskuSet)
{
	HRESULT hr = S_OK;
	VARIANT vAttrValue;
	LPTSTR sz = NULL;

	assert(pNodeParent != NULL);
#ifdef DEBUG
	_tprintf(TEXT("Inside ProcessAttribute: "));
	assert(SUCCEEDED(PrintNodeName(pNodeParent)));
#endif

	VariantInit(&vAttrValue);
	// Get the specified attribute of the specified node
	if (SUCCEEDED(hr = GetAttribute(pNodeParent, szAttributeName, vAttrValue)))
	{
		// the specified attribute exists
		if (S_FALSE != hr)
		{
			if (NULL != (sz = BSTRToLPTSTR(vAttrValue.bstrVal)))
			{
				switch (vt) {
				case INTEGER:
					pisVal->intVal = _ttoi(sz);
					delete[] sz;
					break;
				case STRING:
					pisVal->szVal = sz;
					break;
				}
			}
			else
			{
				_tprintf(TEXT("Internal Error: String conversion failed\n"));
				hr = E_FAIL;
			}
		}
	}

	VariantClear(&vAttrValue);

	// make sure the value returned reflects the fact of failure
	if (FAILED(hr) || (S_FALSE == hr))
	{
		switch (vt) {
		case INTEGER:
			pisVal->intVal = 0;
			break;
		case STRING:
			pisVal->szVal = NULL;
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessStringAttribute\n"));
#endif

	return hr;
}	


////////////////////////////////////////////////////////////////////////////
// Function: ProcessShortLong
//   This function processes nodes with Short attribute and long attribute
//         1) form a C-style string: Short|Long
// Issue: Check the format of short file name (8+3)
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessShortLong_SKU(PIXMLDOMNode &pNode, IntStringValue *pIsValOut,
							 SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNode != NULL);
#ifdef DEBUG
	_tprintf(TEXT("Inside ProcessShortLong_SKU: \n"));
	assert(SUCCEEDED(PrintNodeName(pNode)));
#endif

	// Short file name has to present
	if (SUCCEEDED(hr = ProcessAttribute(pNode, TEXT("Short"), STRING, 
										pIsValOut, pSkuSet)))
	{
		if (S_FALSE == hr)
		{
			// Issue: put node name in the error message
			_tprintf(
				TEXT("Compile Error: missing required attribute Short ")
				TEXT("for SKU: "));
			PrintSkuIDs(pSkuSet);
			hr = E_FAIL;
		}
	}

	// concatenate short name and long name if a long name is present
	if (SUCCEEDED(hr))
	{
		IntStringValue isValLong;
		isValLong.szVal = NULL;
		// Long file name is provided, Return value is Short|Long
		if (SUCCEEDED(hr = ProcessAttribute(pNode, TEXT("Long"),
							STRING, &isValLong, pSkuSet)) && (S_FALSE != hr))
		{
			LPTSTR szLong = isValLong.szVal;
			LPTSTR szShort = pIsValOut->szVal;
			pIsValOut->szVal = 
					new TCHAR[_tcslen(szShort) + _tcslen(szLong) + 2];
			if (!pIsValOut->szVal)
			{
				_tprintf(TEXT("Error: Out of memory\n"));
				hr = E_FAIL;
			}
			else
				_stprintf(pIsValOut->szVal, TEXT("%s|%s"), szShort, szLong);
			delete[] szShort;
			delete[] szLong;
		}
	}		

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessShortLong_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Process KeyPath attribute of an element
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessKeyPath(PIXMLDOMNode &pNode, LPTSTR szComponent, 
					   LPTSTR szKeyPath, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNode != NULL);

	printf("szComponent = %s\n", szComponent);

	// Get KeyPath attribute
	IntStringValue isValKeyPath;
	hr = ProcessAttribute(pNode, TEXT("KeyPath"), STRING, &isValKeyPath, 
						  pSkuSet);

	if (SUCCEEDED(hr) && (S_FALSE != hr))
	{
		LPTSTR sz = isValKeyPath.szVal;
		if (0 == _tcscmp(sz, TEXT("Yes")))
		{
			// store the KeyPath information in the global component object
			printf("szComponent = %s\n", szComponent);
			 
			assert(g_mapComponents.count(szComponent));
			hr = g_mapComponents[szComponent]->SetKeyPath(szKeyPath, pSkuSet);
		}
		else if (0 != _tcscmp(sz, TEXT("No")))
		{
			_tprintf(TEXT("Compile Error: the value of a KeyPath atribute")
					 TEXT("should be either \"Yes\" or \"No\""));
			hr = E_FAIL;
		}
		delete[] sz;
	}

#ifdef DEBUG
	if (FAILED(hr)) 
		_tprintf(TEXT("Error in function: ProcessKeyPath\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessSimpleElement
// This function processes the type of nodes that correspond to one DB column
// and need no more complicated logic than simply retrieving an attribute 
// value. The logic for checking for missing required entities and uniquness
// is included inside the ElementEntry object.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSimpleElement(PIXMLDOMNode &pNode, int iColumn, 
							 ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNode != NULL);
	assert(pEE);

#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNode)));
#endif

	// Get the value of the element.
	IntStringValue isVal;
	ValType vt = pEE->GetValType(iColumn);
	NodeIndex ni = pEE->GetNodeIndex(iColumn);

	hr = ProcessAttribute(pNode, rgXMSINodes[ni].szAttributeName, vt, 
						  &isVal, pSkuSet);

	// insert the value into the ElementEntry.
	if (SUCCEEDED(hr))
		hr = pEE->SetValue(isVal, iColumn, pSkuSet);

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: ProcessSimpleElement\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Document tree process function: ProcessRefElement
//   This function processes the type of node whose value is a reference.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessRefElement(PIXMLDOMNode &pNodeRef,  int iColumn, 
							 ElementEntry *pEE, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeRef != NULL);
	assert(pEE);
#ifdef DEBUG
	assert(SUCCEEDED(PrintNodeName(pNodeRef)));
#endif

	IntStringValue isValRef;
	NodeIndex ni = pEE->GetNodeIndex(iColumn);

	// Get the Value of the Ref attribute
	if (SUCCEEDED(hr = ProcessAttribute(pNodeRef, 
										rgXMSINodes[ni].szAttributeName,
										STRING, &isValRef, pSkuSet)))
	{
		if (NULL == isValRef.szVal)
		{
			_tprintf(
			TEXT("Compile Error: Missing required attribute \'%s\' of <%s>\n"), 
				rgXMSINodes[ni].szAttributeName, rgXMSINodes[ni].szNodeName);
			hr = E_FAIL;
		}
		else
		{
			SkuSetValues *pSkuSetValuesRetVal = NULL;
			if (ni == ILEVEL)
			{
				// The dir referred should be in the data structure already
				assert(0 != g_mapInstallLevelRefs_SKU.count(isValRef.szVal));

				// return a list of <SkuSet, InstallLevel> pairs
				hr = g_mapInstallLevelRefs_SKU[isValRef.szVal]->
								GetValueSkuSet(pSkuSet, &pSkuSetValuesRetVal);
			}
			else if (ni == DIR || ni == COMPONENTDIR)
			{
				// The dir referred should be in the data structure already
				assert(0 != g_mapDirectoryRefs_SKU.count(isValRef.szVal));

				// return a list of <SkuSet, InstallLevel> pairs
				hr = g_mapDirectoryRefs_SKU[isValRef.szVal]->
								GetValueSkuSet(pSkuSet, &pSkuSetValuesRetVal);
			}

			if (FAILED(hr))
			{
				_tprintf(TEXT("are trying to reference %s which is ")
						 TEXT("undefined inside them\n"),
						 isValRef.szVal);
			}
			else
			{
				// store the returned list into *pEE
				hr = pEE->SetValueSkuSetValues(pSkuSetValuesRetVal, iColumn);
				if (pSkuSetValuesRetVal)
					delete pSkuSetValuesRetVal;
			}

			delete[] isValRef.szVal;
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessILevel_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Function: ProcessChildrenList
//   Given a parent node and a child node name, this function finds all the
//   children node of that name and sequentially process them using the 
//   function passed in.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenList_SKU(PIXMLDOMNode &pNodeParent, 
								NodeIndex niChild, bool bIsRequired,
								IntStringValue isVal, 
								HRESULT (*ProcessFunc)
									(PIXMLDOMNode &, IntStringValue isVal, 
										SkuSet *pSkuSet), 
								SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	PIXMLDOMNodeList pNodeListChildren = NULL;
	long iListLength = 0;
	// used to validate: a required node really appears in each SKU
	SkuSet *pSkuSetValidate = NULL;

	assert(pNodeParent != NULL);

	// get the list of children nodes
	if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[niChild].szNodeName, 
									pNodeListChildren)))
	{
		if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
		{
			_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
				 TEXT("get_length\n"));
			iListLength = 0;
		}
	}

	if (SUCCEEDED(hr) && bIsRequired)
	{
		pSkuSetValidate = new SkuSet(g_cSkus);
		assert(pSkuSetValidate);
	}  

	// process each child node in the list
	for (long l=0; l<iListLength; l++)
	{
		PIXMLDOMNode pNodeChild = NULL;
		if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
		{	
			assert(pNodeChild != NULL);
			// Get the SkuSet specified for this child
			SkuSet *pSkuSetChild = NULL;
			if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pSkuSetChild)))
			{
				assert (pSkuSetChild != NULL);

				// if the child node doesn't have a SKU filter specified,
				//  it inherits the SKU filter from its parent
				// Also get rid of those Skus specified in the child
				// but not in its parent
				*pSkuSetChild &= *pSkuSet;

				// only keep processing if the SkuSet is not empty
				if (!pSkuSetChild->testClear())
				{
					if (bIsRequired)
						// mark down the Skus that have this child node
						*pSkuSetValidate |= *pSkuSetChild;

					// process the child node;
					hr = ProcessFunc(pNodeChild, isVal, pSkuSetChild);
				}

				delete pSkuSetChild;
				pSkuSetChild = NULL;
			}

			if (FAILED(hr))
				break;
		}
		else
		{
			_tprintf(TEXT("Internal Error: Failed to make ")
					 TEXT("DOM API call: get_item\n"));
			break;
		}
	}

	// check if the requied node exists in every SKU
	if (SUCCEEDED(hr) && bIsRequired) 
	{
		SkuSet skuSetTemp = SkuSetMinus(*pSkuSet, *pSkuSetValidate);

		if (!skuSetTemp.testClear())
		{
			_tprintf(TEXT("Compile Error: Missing required Node <%s> ")
							TEXT("in SKU: "), 
							rgXMSINodes[niChild].szNodeName);
			PrintSkuIDs(&skuSetTemp);
			_tprintf(TEXT("\n"));

			//For now, completely break when such error happens
			hr = E_FAIL;
		}
	}

	if (SUCCEEDED(hr) && bIsRequired)
		delete pSkuSetValidate;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessChildrenList_SKU\n"));
#endif

	return hr;
}  

////////////////////////////////////////////////////////////////////////////
// Function: ProcessChildrenList
//		Overloaded function. This function is essentially the same as the
//		previous one except that it returns the SkuSet that contains the
//		SKUs that doesn't have this child node. 
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenList_SKU(PIXMLDOMNode &pNodeParent, 
								NodeIndex niChild, bool bIsRequired,
								IntStringValue isVal, 
								HRESULT (*ProcessFunc)
									(PIXMLDOMNode &, IntStringValue isVal, 
										SkuSet *pSkuSet), 
								SkuSet *pSkuSet, SkuSet *pSkuSetCheck)
{
	HRESULT hr = S_OK;

	PIXMLDOMNodeList pNodeListChildren = NULL;
	long iListLength = 0;
	// used to validate: a required node really appears in each SKU
	SkuSet *pSkuSetValidate = NULL;

	assert(pNodeParent != NULL);

	// get the list of children nodes
	if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[niChild].szNodeName, 
									pNodeListChildren)))
	{
		if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
		{
			_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
				 TEXT("get_length\n"));
			iListLength = 0;
		}
	}

	if (SUCCEEDED(hr))
	{
		pSkuSetValidate = new SkuSet(g_cSkus);
		assert(pSkuSetValidate);
	}  

	// process each child node in the list
	for (long l=0; l<iListLength; l++)
	{
		PIXMLDOMNode pNodeChild = NULL;
		if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
		{	
			assert(pNodeChild != NULL);
			// Get the SkuSet specified for this child
			SkuSet *pSkuSetChild = NULL;
			if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pSkuSetChild)))
			{
				assert (pSkuSetChild != NULL);

				// if the child node doesn't have a SKU filter specified,
				//  it inherits the SKU filter from its parent
				// Also get rid of those Skus specified in the child
				// but not in its parent
				*pSkuSetChild &= *pSkuSet;

				// only keep processing if the SkuSet is not empty
				if (!pSkuSetChild->testClear())
				{
					// mark down the Skus that have this child node
					*pSkuSetValidate |= *pSkuSetChild;

					// process the child node;
					hr = ProcessFunc(pNodeChild, isVal, pSkuSetChild);
				}

				delete pSkuSetChild;
				pSkuSetChild = NULL;
			}

			if (FAILED(hr))
				break;
		}
		else
		{
			_tprintf(TEXT("Internal Error: Failed to make ")
					 TEXT("DOM API call: get_item\n"));
			break;
		}
	}

	// check if the requied node exists in every SKU
	if (SUCCEEDED(hr))
	{
		*pSkuSetCheck = SkuSetMinus(*pSkuSet, *pSkuSetValidate);

		if (!pSkuSetCheck->testClear() && bIsRequired)
		{
			_tprintf(TEXT("Compile Error: Missing required Node <%s> ")
							TEXT("in SKU: "), 
							rgXMSINodes[niChild].szNodeName);
			PrintSkuIDs(pSkuSetCheck);
			_tprintf(TEXT("\n"));

			//For now, completely break when such error happens
			hr = E_FAIL;
		}
	}

	if (SUCCEEDED(hr))
		delete pSkuSetValidate;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessChildrenList_SKU\n"));
#endif

	return hr;
}  

////////////////////////////////////////////////////////////////////////////
// Function: ProcessChildrenList
//	An overloaded function. Essentially this function is the same as 
//	the one above. The only difference is the information passed through
//	this function to the function that process the children. 
//  This function is used for process <Module>s and <Component>s 
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenList_SKU(PIXMLDOMNode &pNodeParent, 
								NodeIndex niChild, bool bIsRequired,
								FOM *pFOM, SkuSetValues *pSkuSetValues, 
								HRESULT (*ProcessFunc)
									(PIXMLDOMNode &, FOM *pFOM, 
									 SkuSetValues *pSkuSetValues, 
									 SkuSet *pSkuSet), 
								SkuSet *pSkuSet, SkuSet *pSkuSetCheck)
{
	HRESULT hr = S_OK;

	PIXMLDOMNodeList pNodeListChildren = NULL;
	long iListLength = 0;
	// used to validate: a required node really appears in each SKU
	SkuSet *pSkuSetValidate = NULL;

	assert(pNodeParent != NULL);

	// get the list of children nodes
	if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[niChild].szNodeName, 
									pNodeListChildren)))
	{
		if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
		{
			_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
				 TEXT("get_length\n"));
			iListLength = 0;
		}
	}

	if (SUCCEEDED(hr))
	{
		pSkuSetValidate = new SkuSet(g_cSkus);
		assert(pSkuSetValidate);
	}  

	// process each child node in the list
	for (long l=0; l<iListLength; l++)
	{
		PIXMLDOMNode pNodeChild = NULL;
		if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
		{	
			assert(pNodeChild != NULL);
			// Get the SkuSet specified for this child
			SkuSet *pSkuSetChild = NULL;
			if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pSkuSetChild)))
			{
				assert (pSkuSetChild != NULL);

				// if the child node doesn't have a SKU filter specified,
				//  it inherits the SKU filter from its parent
				// Also get rid of those Skus specified in the child
				// but not in its parent
				*pSkuSetChild &= *pSkuSet;

				// only keep processing if the SkuSet is not empty
				if (!pSkuSetChild->testClear())
				{
					// mark down the Skus that have this child node
					*pSkuSetValidate |= *pSkuSetChild;

					// process the child node;
					hr = ProcessFunc(pNodeChild, pFOM, pSkuSetValues, 
									 pSkuSetChild);
				}

				delete pSkuSetChild;
				pSkuSetChild = NULL;
			}

			if (FAILED(hr))
				break;
		}
		else
		{
			_tprintf(TEXT("Internal Error: Failed to make ")
					 TEXT("DOM API call: get_item\n"));
			break;
		}
	}

	// check if the requied node exists in every SKU
	if (SUCCEEDED(hr)) 
	{
		*pSkuSetCheck = SkuSetMinus(*pSkuSet, *pSkuSetValidate);

		if (!pSkuSetCheck->testClear() && bIsRequired)
		{
			_tprintf(TEXT("Compile Error: Missing required Node <%s> ")
							TEXT("in SKU: "), 
							rgXMSINodes[niChild].szNodeName);
			
			PrintSkuIDs(pSkuSetCheck);
			_tprintf(TEXT("\n"));

			//For now, completely break when such error happens
			hr = E_FAIL;
		}
	}

	if (SUCCEEDED(hr))
		delete pSkuSetValidate;

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ProcessChildrenList_SKU\n"));
#endif

	return hr;
}  

////////////////////////////////////////////////////////////////////////////
// Function: ProcessChildrenArray_H_XIS
//   Given a parent node(<ProductFamily> or <Information>) and an array of 
//	 nodeFuncs, this function loops through the array and sequentially process 
//   them using the functions given in the array
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenArray_H_XIS(PIXMLDOMNode &pNodeParent, 
								  Node_Func_H_XIS *rgNodeFuncs,
								  UINT cNodeFuncs, 
								  const IntStringValue *pisVal_In, 
								  SkuSet *pskuSet)
{
	HRESULT hr = S_OK;
	IntStringValue isVal;

	assert(pNodeParent != NULL);

	for (int i=0; i<cNodeFuncs; i++)
	{
		isVal.intVal = i;

		PIXMLDOMNodeList pNodeListChildren = NULL;
		long iListLength = 0;
		NodeIndex nodeIndex = rgNodeFuncs[i].enumNodeIndex;
		// Get the list of nodes with the same name
		if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[nodeIndex].szNodeName, 
										pNodeListChildren)))
		{
			if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
			{
				_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
					 TEXT("get_length\n"));
				break;
			}
		}
		else
			break;

		// used to validate:
		//    (1) a required node really appears in each SKU;
		//    (2) a node that is supposed to appear ONCE really
		//			appears once for each SKU; 
		SkuSet *pskuSetValidate = new SkuSet(g_cSkus);
		assert(pskuSetValidate);

		// process each child node in the list
		for (long l=0; l<iListLength; l++)
		{
			PIXMLDOMNode pNodeChild = NULL;
			if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
			{	
				assert(pNodeChild != NULL);
				// Get the SkuSet specified for this child
				SkuSet *pskuSetChild = NULL;
				if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pskuSetChild)))
				{
					assert (pskuSetChild != NULL);

					// if the child node doesn't have a SKU filter specified,
					//  it inherits the SKU filter from its parent
					*pskuSetChild &= *pskuSet;

					// only keep processing if the SkuSet is not empty
					if (!pskuSetChild->testClear())
					{
						// check for the uniqueness of this child in each SKU
						if (1 == rgXMSINodes[nodeIndex].uiOccurence)
						{
							SkuSet skuSetTemp = 
								(*pskuSetValidate) & (*pskuSetChild);

							if (!skuSetTemp.testClear())
							{
								_tprintf(TEXT("Error: <%s> appears more than ")
									TEXT("once in SKU: "), 
									rgXMSINodes[nodeIndex].szNodeName);
								for (int j=0; j<g_cSkus; j++)
								{
									if (skuSetTemp.test(j))
										_tprintf(TEXT("%s "), 
												g_rgpSkus[j]->GetID());
								}
								_tprintf(TEXT("\n"));

								// For now, completely break when such error 
								// happens
								hr = E_FAIL;
							}
						}
						*pskuSetValidate |= *pskuSetChild;

						// process the node;
						hr = (rgNodeFuncs[i].pNodeProcessFunc)
									(pNodeChild, &isVal, pskuSetChild);
					}

					delete pskuSetChild;
					pskuSetChild = NULL;
				}

				if (FAILED(hr))
					break;
			}
			else
			{
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_item\n"));
				break;
			}
		}
		
		if (FAILED(hr))
			break;

		// check if the requied node exists in every SKU
		if (SUCCEEDED(hr) && rgXMSINodes[nodeIndex].bIsRequired) 
		{
		    SkuSet skuSetTemp = SkuSetMinus(*pskuSet, *pskuSetValidate);

			if (!skuSetTemp.testClear())
			{
				_tprintf(TEXT("Compile Error: Missing required Node <%s> ")
								TEXT("in SKU: "), 
								rgXMSINodes[nodeIndex].szNodeName);
				for (int j=0; j<g_cSkus; j++)
				{
					if (skuSetTemp.test(j))
						_tprintf(TEXT("%s "), g_rgpSkus[j]->GetID());
				}
				_tprintf(TEXT("\n"));

				//For now, completely break when such error happens
				hr = E_FAIL;
				break;
			}
		}

		delete pskuSetValidate;
	}


#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessChildrenArray_H_XS\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Function: ProcessChildrenArray_H_XIES
//   Given a parent node(<Feature> <Component> <File>) and an array of 
//	 nodeFuncs, this function loops through the array and sequentially process 
//   them using the functions given in the array
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenArray_H_XIES(PIXMLDOMNode &pNodeParent, 
									Node_Func_H_XIES *rgNodeFuncs,
									UINT cNodeFuncs, 
									ElementEntry *pEE,
									SkuSet *pskuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeParent != NULL);

	for (int i=0; i<cNodeFuncs; i++)
	{
		PIXMLDOMNodeList pNodeListChildren = NULL;
		long iListLength = 0;
		NodeIndex nodeIndex = rgNodeFuncs[i].enumNodeIndex;
		int iColumn = rgNodeFuncs[i].iColumn;
		pEE->SetNodeIndex(nodeIndex, iColumn);
		pEE->SetValType(rgNodeFuncs[i].vt, iColumn);
		
		// skip those elements that don't have one particular function
		// processing them (e.g., KeyPath for Component)
		if (rgNodeFuncs[i].pNodeProcessFunc == NULL)
			continue;

		// Get the list of nodes with the same name
		if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[nodeIndex].szNodeName, 
										pNodeListChildren)))
		{
			if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
			{
				_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
					 TEXT("get_length\n"));
				break;
			}
		}
		else
			break;

		// process each child node in the list
		for (long l=0; l<iListLength; l++)
		{
			PIXMLDOMNode pNodeChild = NULL;
			if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
			{	
				assert(pNodeChild != NULL);
				// Get the SkuSet specified for this child
				SkuSet *pskuSetChild = NULL;
				if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pskuSetChild)))
				{
					assert (pskuSetChild != NULL);

					// if the child node doesn't have a SKU filter specified,
					//  it inherits the SKU filter from its parent
					*pskuSetChild &= *pskuSet;

					if (!pskuSetChild->testClear())
					{
						if (rgNodeFuncs[i].pNodeProcessFunc != NULL)
							// process the node;
							hr = (rgNodeFuncs[i].pNodeProcessFunc)
									(pNodeChild, iColumn, pEE, pskuSetChild);
					}
					delete pskuSetChild;
					pskuSetChild = NULL;
				}

				if (FAILED(hr))
					break;
			}
			else
			{
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_item\n"));
				break;
			}
		}

		if (FAILED(hr))
			break;
	}


#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessChildrenArray_H_XIES\n"));
#endif

	return hr;
}


// Helper function: tells how to update an IntStringValue storing bitfields
HRESULT IsValBitWiseOR(IntStringValue *pisValOut, IntStringValue isValOld, 
					   IntStringValue isValNew)
{
	pisValOut->intVal = isValOld.intVal | isValNew.intVal;

	return S_OK;
}

////////////////////////////////////////////////////////////////////////////
// Function: ProcessOnOffAttributes_SKU
//		This function processes an array of On/Off elements, each of which
//		corresponds to a certain bit in a bit field (Attributes of Component,
//		File, etc.)
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessOnOffAttributes_SKU(PIXMLDOMNode &pNodeParent, 
								   AttrBit_SKU *rgAttrBits,
								   UINT cAttrBits, 
								   ElementEntry *pEE, int iColumn,
								   SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeParent != NULL);
#ifdef DEBUG
	_tprintf(TEXT("Inside Function: ProcessOnOffAttributes_SKU\n"));
#endif

	for (int i=0; i<cAttrBits; i++)
	{
		PIXMLDOMNodeList pNodeListChildren = NULL;
		long iListLength = 0;
		NodeIndex nodeIndex = rgAttrBits[i].enumNodeIndex;
		pEE->SetNodeIndex(nodeIndex, iColumn);
		// Get the list of nodes with the same name
		if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[nodeIndex].szNodeName, 
										pNodeListChildren)))
		{
			if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
			{
				_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
					 TEXT("get_length\n"));
				break;
			}
		}
		else
			break;

		// process each child node in the list
		for (long l=0; l<iListLength; l++)
		{
			PIXMLDOMNode pNodeChild = NULL;
			if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
			{	
				assert(pNodeChild != NULL);
				// Get the SkuSet specified for this child
				SkuSet *pSkuSetChild = NULL;
				if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pSkuSetChild)))
				{
					assert (pSkuSetChild != NULL);
					*pSkuSetChild &= *pSkuSet;
					if (!pSkuSetChild->testClear())
					{
						IntStringValue isVal;
						isVal.intVal = rgAttrBits[i].uiBit;
						hr = pEE->SetValueSplit(isVal, iColumn, pSkuSetChild, 
												IsValBitWiseOR);
					}
				}
				delete pSkuSetChild;

				if (FAILED(hr))
					break;
			}
			else
			{
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_item\n"));
				break;
			}
		}
	}


#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessOnOffAttributes_SKU\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Function: ProcessEnumAttributes
//		This function processes a single element which can take a value of 
//		among an enumeration that corresponds to certain bits in a bit field.
//		(Attributes of Component, File, etc.)
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessEnumAttributes(PIXMLDOMNode &pNodeParent, 
								  NodeIndex ni, EnumBit *rgEnumBits,
								  UINT cEnumBits, ElementEntry *pEE, 
								  int iColumn, SkuSet *pSkuSet)
{
	HRESULT hr = S_OK;

	assert(pNodeParent != NULL);
	assert(pEE);
#ifdef DEBUG
	_tprintf(TEXT("Inside Function: ProcessEnumAttributes\n"));
#endif

	PIXMLDOMNodeList pNodeListChildren = NULL;
	long iListLength = 0;

	pEE->SetNodeIndex(ni, iColumn);

	// Get the list of nodes that represent the same entity in
	// different SKUs
	if(SUCCEEDED(hr = GetChildrenNodes(pNodeParent, 
									rgXMSINodes[ni].szNodeName, 
									pNodeListChildren)))
	{
		if(FAILED(hr = pNodeListChildren->get_length(&iListLength)))
		{
			_tprintf(TEXT("Internal Error: Failed to make DOM API call:")
					 TEXT("get_length\n"));
		}
	}

	// process each node
	if (SUCCEEDED(hr))
	{
		// process each child node in the list
		for (long l=0; l<iListLength; l++)
		{
			PIXMLDOMNode pNodeChild = NULL;
			if (SUCCEEDED(hr = pNodeListChildren->get_item(l, &pNodeChild)))
			{	
				assert(pNodeChild != NULL);
				// Get the SkuSet specified for this child
				SkuSet *pSkuSetChild = NULL;
				if (SUCCEEDED(hr = GetSkuSet(pNodeChild, &pSkuSetChild)))
				{
					assert (pSkuSetChild != NULL);

					*pSkuSetChild &= *pSkuSet;

					// no need to process an element that is good for
					// no SKUs
					if (pSkuSetChild->testClear())
					{
						delete pSkuSetChild;
						break;
					}
					
					// get Value attribute of this node
					IntStringValue isValAttr;
					hr = ProcessAttribute(pNodeChild, 
										  rgXMSINodes[ni].szAttributeName, 
										  STRING, &isValAttr, pSkuSetChild);

					if (SUCCEEDED(hr))
					{
						if (NULL == isValAttr.szVal)
						{
							_tprintf(
						TEXT("Compile Error: Missing required attribute")
						TEXT("\'%s\' of <%s>\n"), 
								rgXMSINodes[ni].szAttributeName, 
								rgXMSINodes[ni].szNodeName);
							hr = E_FAIL;
						}
						else
						{
							IntStringValue isVal;
							for (int i=0; i<cEnumBits; i++)
							{
								if (0==_tcscmp(isValAttr.szVal, 
												rgEnumBits[i].EnumValue))
								{
									isVal.intVal = rgEnumBits[i].uiBit;
									hr = pEE->SetValueSplit(isVal, iColumn, 
												pSkuSetChild, IsValBitWiseOR);
								}
							}
							delete[] isValAttr.szVal;
						}
					}

					delete pSkuSetChild;
					if (FAILED(hr)) break;
				}
				else
					break;

			}
			else
			{
				_tprintf(TEXT("Internal Error: Failed to make ")
						 TEXT("DOM API call: get_item\n"));
				break;
			}
		}
	}


#ifdef DEBUG	
	if (FAILED(hr)) _tprintf(TEXT("Error in function: ")
							 TEXT("ProcessEnumAttributes\n"));
#endif

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: Return a unique number
////////////////////////////////////////////////////////////////////////////
ULONG GetUniqueNumber()
{
	static ULONG ulNum = 1;
	return ulNum++;
}
	
////////////////////////////////////////////////////////////////////////////
// Helper Function: Return a unique name by postfixing szName with a 
//					unique number
////////////////////////////////////////////////////////////////////////////
LPTSTR GetName(LPTSTR szTable)
{
	int ci = 0;
	LPTSTR szUniqueName = NULL;

	if (0 == g_mapTableCounter.count(szTable))
	{
		// first time see this Table
		LPTSTR szTableTemp = _tcsdup(szTable);
		assert(szTableTemp);

		g_mapTableCounter.insert(LI_ValType(szTableTemp, 1));
		ci = 1;
	}
	else
		ci = ++g_mapTableCounter[szTable];

	// convert the counter into a string
	TCHAR szCI[64];
	_itot(ci, szCI, 10);

	int iLengthCI = _tcslen(szCI);
	assert(iLengthCI<=5);

	TCHAR szPostFix[6];
	for (int i=0; i<5-iLengthCI; i++)
	{
		szPostFix[i] = TEXT('0');
	}

	szPostFix[i] = TEXT('\0');
	_tcscat(szPostFix, szCI);

	int iLength = _tcslen(szTable) + 5;
	szUniqueName = new TCHAR[iLength+4]; // for __ and .
	if (!szUniqueName)
	{
		_tprintf(TEXT("Error: Out of memory\n"));
		return NULL;
	}

	_stprintf(szUniqueName, TEXT("__%s.%s"), szTable, szPostFix);

	return szUniqueName;
}

		


/*
LPTSTR GetName(LPCTSTR szName)
{
	ULONG ul = GetUniqueNumber();
	int iLength = 0;
	LPTSTR szUniqueName = NULL;

	TCHAR szUL[64];
	_itot(ul, szUL, 10);

	iLength = _tcslen(szName);
	iLength += _tcslen(szUL);

	szUniqueName = new TCHAR[iLength+1];
	if (!szUniqueName)
	{
		_tprintf(TEXT("Error: Out of memory\n"));
		return NULL;
	}

	_stprintf(szUniqueName, TEXT("%s%s"), szName, szUL);

	return szUniqueName;
}
*/
////////////////////////////////////////////////////////////////////////////
// Helper Function: print the content of a map 
////////////////////////////////////////////////////////////////////////////
void PrintMap_LI(map<LPTSTR, int, Cstring_less> &LI_map)
{
	map<LPTSTR, int, Cstring_less>::iterator it;

	_tprintf(TEXT("\n**********************************************\n"));
	
	for (it = LI_map.begin(); it != LI_map.end(); ++it)
		_tprintf(TEXT("Key: %s\t Value: %d\n"), (*it).first, (*it).second);

	_tprintf(TEXT("\n**********************************************\n"));
}

void PrintMap_LL(map<LPTSTR, LPTSTR, Cstring_less> &LL_map)
{
	map<LPTSTR, LPTSTR, Cstring_less>::iterator it;

	_tprintf(TEXT("\n**********************************************\n"));
	
	for (it = LL_map.begin(); it != LL_map.end(); ++it)
		_tprintf(TEXT("Key: %s\t Value: %s\n"), (*it).first, (*it).second);

	_tprintf(TEXT("\n**********************************************\n"));
}

void PrintMap_LC(map<LPTSTR, Component *, Cstring_less> &LC_map)
{
	map<LPTSTR, Component *, Cstring_less>::iterator it;

	_tprintf(TEXT("\n**********************************************\n"));
	
	for (it = LC_map.begin(); it != LC_map.end(); ++it)
	{
		_tprintf(TEXT("Key: %s\n Value: \n"), (*it).first);
		((*it).second)->Print();
	}

	_tprintf(TEXT("\n**********************************************\n"));
}

void PrintMap_DirRef(map<LPTSTR, SkuSetValues *, Cstring_less> &map_DirRef)
{
	map<LPTSTR, SkuSetValues *, Cstring_less>::iterator it;

	_tprintf(TEXT("\n**********************************************\n"));
	
	for (it = map_DirRef.begin(); it != map_DirRef.end(); ++it)
	{
		_tprintf(TEXT("Key: %s\n Value:\n"), (*it).first);
		((*it).second)->Print();
	}

	_tprintf(TEXT("\n**********************************************\n"));
}


void PrintMap_LS(map<LPTSTR, SkuSet *, Cstring_less> &LS_map)
{
	map<LPTSTR, SkuSet *, Cstring_less>::iterator it;

	_tprintf(TEXT("\n**********************************************\n"));
	
	for (it = LS_map.begin(); it != LS_map.end(); ++it)
	{
		_tprintf(TEXT("Key: %s\t Value:\n"), (*it).first);
		((*it).second)->print();
	}

	_tprintf(TEXT("\n**********************************************\n"));
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: 
////////////////////////////////////////////////////////////////////////////
UINT WmcRecordGetString(MSIHANDLE hRecord, unsigned int iField, 
								LPTSTR &szValueBuf, DWORD *pcchValueBuf)
{
	UINT errorCode = ERROR_SUCCESS;

	if ( (errorCode = MsiRecordGetString(hRecord, iField, szValueBuf, 
										pcchValueBuf)) == ERROR_MORE_DATA)
		{
			delete[] szValueBuf;
			szValueBuf = new TCHAR[(*pcchValueBuf)+1];
			if (!szValueBuf)
			{
				_tprintf(TEXT("Error: Out of Memory\n"));
				return ERROR_FUNCTION_FAILED;
			}
			(*pcchValueBuf)++;
			errorCode = MsiRecordGetString(hRecord, iField, szValueBuf,
											pcchValueBuf);
		}

	return errorCode;
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: Convert LPTSTR to BSTR
////////////////////////////////////////////////////////////////////////////
BSTR LPTSTRToBSTR(LPCTSTR szName)
{

#ifdef UNICODE
	return SysAllocString(szName);
#else
	
    WCHAR wszURL[MAX_PATH];
    if (0 == MultiByteToWideChar(CP_ACP, 0, szName, -1, wszURL, MAX_PATH))
	{
		_tprintf(TEXT("Internal Error: API call \'MultiByteToWideChar\'") 
				 TEXT("failed.\n"));
 		return NULL; // API call failed
	}
	else 
		return SysAllocString(wszURL);
#endif //UNICODE
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: Convert BSTR to LPTSTR
////////////////////////////////////////////////////////////////////////////
LPTSTR BSTRToLPTSTR(BSTR bString)
{

#ifdef UNICODE
	LPTSTR sz = new TCHAR[_tcslen(bString) + 1];
	_tcscpy(sz, bString);
	return sz;
#else
	int i = SysStringLen(bString);
    LPSTR szString = new CHAR[i + 1];
	if (!szString)
	{
		_tprintf("Error: Out of Memory\n");
		return NULL;
	}
	
    if (0 == WideCharToMultiByte(CP_ACP, 0, bString, -1, szString, i+1, 
									NULL, false))
	{
		// API call failed
		delete[] szString;
		return NULL;
	}
	else
		return szString;
#endif //UNICODE
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: convert GUID to LPTSTR
////////////////////////////////////////////////////////////////////////////
HRESULT GUIDToLPTSTR(LPGUID pGUID, LPTSTR &szGUID)
{
	HRESULT hr = S_OK;
	if (!pGUID)
		return E_INVALIDARG;
	//Build GUID string
	LPTSTR szDSGUID = new TCHAR [128];
	if (!szDSGUID)
	{
		_tprintf(TEXT("Internal Error: Out of memory.\n"));
		return E_FAIL;
	}
	DWORD dwLen =  sizeof(*pGUID);
	LPBYTE lpByte = (LPBYTE) pGUID;
	//Copy a blank string to make it a zero length string.
	_tcscpy( szDSGUID, TEXT(""));
	//Loop through to add each byte to the string.
	for( DWORD dwItem = 0L; dwItem < dwLen ; dwItem++ )
	{
		if(4 == dwItem || 6 == dwItem || 8 == dwItem || 10 == dwItem)
			_stprintf(szDSGUID+_tcslen(szDSGUID), TEXT("-"));
	
		//Append to szDSGUID, double-byte, byte at dwItem index.
		_stprintf(szDSGUID + _tcslen(szDSGUID), TEXT("%02x"), lpByte[dwItem]);
		if( _tcslen( szDSGUID ) > 128 )
			break;
	}

	//Allocate memory for string
	szGUID = new TCHAR[_tcslen(szDSGUID)+1];
	if (!szDSGUID)
	{
		_tprintf(TEXT("Internal Error: Out of memory.\n"));
		return E_FAIL;
	}
	if (szGUID)
		_tcscpy(szGUID, szDSGUID);
	else
	  hr=E_FAIL;
	//Caller must free pszGUID
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: convert a UUID string to all uppercases and add '{' '}'
//                  to the beginning and end of the string
////////////////////////////////////////////////////////////////////////////
HRESULT FormatGUID(LPTSTR &szUuid)
{
	HRESULT hr = S_OK;
	LPTSTR szValue = NULL;
	LPTSTR szValueCurlyBraces = NULL;

	szValue = _tcsupr(szUuid);
	szValueCurlyBraces = new TCHAR[_tcslen(szValue) + 3]; 
	if (!szValueCurlyBraces)
	{
		_tprintf(TEXT("Error: Out of Memory\n"));
		return E_FAIL;
	}
	_stprintf(szValueCurlyBraces, TEXT("{%s}"), szValue);
	delete[] szUuid;
	szUuid = szValueCurlyBraces;

#ifdef DEBUG
	if (FAILED(hr))	_tprintf(TEXT("Error in function: FormatGUID\n"));
#endif
    
	return hr;

}

////////////////////////////////////////////////////////////////////////////
// Helper function: return the child node of pParent with the specified name 
//                  via pChild. S_FALSE is returned if no node found.
////////////////////////////////////////////////////////////////////////////
HRESULT GetChildNode(PIXMLDOMNode &pParent, LPCTSTR szChildName, 
					 PIXMLDOMNode &pChild)
{
    HRESULT hr=S_OK;
	BSTR pBQuery=NULL;

	assert(pParent!=NULL);

	if (NULL == (pBQuery = LPTSTRToBSTR(szChildName)))
	{
		_tprintf(TEXT("Internal Error: String conversion failed\n"));
		hr = E_FAIL;
	}
	else
	{
		if (FAILED(hr = pParent->selectSingleNode(pBQuery, &pChild)))
		{
			_tprintf(TEXT("Internal Error: DOM API call \'selectSingleNode\'")
					 TEXT("failed\n"));
		}
		
		// NOTE: do NOT alter hr value after this line. 

		SysFreeString(pBQuery);
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: GetChildNode\n"));
#endif
    
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Overloaded function:
//			return the child node of pParent with the specified name 
//          via pChild. S_FALSE is returned if no node found.
////////////////////////////////////////////////////////////////////////////
HRESULT GetChildNode(IXMLDOMNode *pParent, LPCTSTR szChildName, 
					 PIXMLDOMNode &pChild)
{
    HRESULT hr=S_OK;
	BSTR pBQuery=NULL;

	assert(pParent!=NULL);

	if (NULL == (pBQuery = LPTSTRToBSTR(szChildName)))
	{
		_tprintf(TEXT("Internal Error: String conversion failed\n"));
		hr = E_FAIL;
	}
	else
	{
		if (FAILED(hr = pParent->selectSingleNode(pBQuery, &pChild)))
		{
			_tprintf(TEXT("Internal Error: DOM API call \'selectSingleNode\'")
					 TEXT("failed\n"));
		}
		
		// NOTE: do NOT alter hr value after this line. 

		SysFreeString(pBQuery);
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: GetChildNode\n"));
#endif
    
	return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: return a list of all the children node of pParent with 
//					the specified name via pChild
////////////////////////////////////////////////////////////////////////////
HRESULT GetChildrenNodes(PIXMLDOMNode &pParent, LPCTSTR szChildrenName, 
						 PIXMLDOMNodeList &pChildren)
{
    HRESULT hr=S_OK;
	BSTR pBQuery=NULL;

	assert(pParent != NULL);

	if (NULL == (pBQuery = LPTSTRToBSTR(szChildrenName)))
	{
		_tprintf(TEXT("Internal Error: String conversion failed\n"));
		hr = E_FAIL;
	}
	else
	{
		if (FAILED(hr = pParent->selectNodes(pBQuery, &pChildren)))
		{
			_tprintf(TEXT("Internal Error: DOM API call \'selectNodes\'")
					 TEXT("failed\n"));
		}
		
		SysFreeString(pBQuery);
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: GetChildrenNodes\n"));
#endif
    
	return hr;
}


////////////////////////////////////////////////////////////////////////////
// Helper function: for debug purpose, print out the name of pNode
////////////////////////////////////////////////////////////////////////////
HRESULT PrintNodeName(PIXMLDOMNode &pNode)
{
    HRESULT hr=S_OK;
	BSTR pBNodeName = NULL;

	if (FAILED(hr = pNode->get_nodeName(&pBNodeName)))
	{
		_tprintf(TEXT
				("Internal Error: DOM API call \'get_nodeName\' failed\n"));
	}
	else
	{
		_tprintf(TEXT("Processing tag: %ls\n"), pBNodeName);
	}

	if (pBNodeName)
		SysFreeString(pBNodeName);
	
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: PrintNodeName\n"));

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: return the value of pNode's attribute with name 
//                  szAttrName via vAttrValue
////////////////////////////////////////////////////////////////////////////
HRESULT GetAttribute(PIXMLDOMNode &pNode, LPCTSTR szAttrName, 
						VARIANT &vAttrValue)
{
    HRESULT hr=S_OK;
	PIXMLDOMElement pElement=NULL;
	BSTR pBAttrName=NULL;

	assert(pNode != NULL);

	if (FAILED(hr = pNode->QueryInterface(IID_IXMLDOMElement, 
												(void **)&pElement)))
	{
		_tprintf(TEXT
				("Internal Error: DOM API call \'QueryInterface\' failed\n"));
	}
	else if (NULL == (pBAttrName = LPTSTRToBSTR(szAttrName)))
	{
		_tprintf(TEXT("Internal Error: string conversion failed\n"));
		hr = E_FAIL;
	}
	else
	{
		if (FAILED(hr = pElement->getAttribute(pBAttrName, &vAttrValue)))
		{
			_tprintf(
				TEXT("Internal Error: DOM API call \'getAttribute\' failed\n"));
		}

		//NOTE: do NOT alter hr value after this line!
		
		SysFreeString(pBAttrName);
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: GetAttribute\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: return the value of pNode's ID attribute via szID.
//                  if pNode doesn't have a ID attribute, szID = NULL 
////////////////////////////////////////////////////////////////////////////
HRESULT GetID(PIXMLDOMNode &pNode, LPCTSTR &szID)
{
    HRESULT hr=S_OK;
	VARIANT vVal;

	assert (pNode != NULL);

	VariantInit(&vVal);
	if(SUCCEEDED(hr = GetAttribute(pNode, TEXT("ID"), vVal))) 
	{
		if(S_FALSE != hr)
		{
			if (NULL == (szID = BSTRToLPTSTR(vVal.bstrVal)))
			{
				_tprintf(TEXT("Internal Error: string conversion failed\n"));
				hr = E_FAIL;
				szID = NULL;
			}
		}
		else // ID attribute doesn't exist
		{
			szID = NULL;
		}
	}

	VariantClear(&vVal);	

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: GetID\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Function: Load an XML Document from the specified file or URL synchronously.
////////////////////////////////////////////////////////////////////////////
HRESULT LoadDocumentSync(PIXMLDOMDocument2 &pDoc, BSTR pBURL)
{
    HRESULT         hr = S_OK;
    PIXMLDOMParseError  pXMLError = NULL;
    VARIANT         vURL;
    VARIANT_BOOL    vb = VARIANT_FALSE;

    if (FAILED(hr = pDoc->put_async(VARIANT_FALSE)))
	{
		_tprintf(TEXT("Internal Error: DOM API call put_async failed \n"));
	}
	else if(FAILED(hr = pDoc->put_validateOnParse(VARIANT_TRUE)))
	{
		_tprintf(TEXT
			("Internal Error: DOM API call put_validateOnParse failed\n"));
	}
	else
	{
		// Load xml document from the given URL or file path
		VariantInit(&vURL);
		vURL.vt = VT_BSTR;
		vURL.bstrVal = pBURL;
		if (FAILED(hr = pDoc->load(vURL, &vb)))
		{
			_tprintf(TEXT("Internal Error: DOM API call load failed \n"));
		}
		else if (vb == VARIANT_FALSE)
		{
			hr = CheckLoad(pDoc);
		}
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: LoadDocumentSync\n"));
#endif
    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Report parsing error information
////////////////////////////////////////////////////////////////////////////
HRESULT ReportError(PIXMLDOMParseError &pXMLError)
{
    long line, linePos;
    LONG errorCode;
    BSTR pBURL=NULL, pBReason=NULL;
    HRESULT hr = E_FAIL;

    if ( SUCCEEDED(pXMLError->get_line(&line)) && 
		SUCCEEDED(pXMLError->get_linepos(&linePos)) &&
		SUCCEEDED(pXMLError->get_errorCode(&errorCode)) &&
		SUCCEEDED(pXMLError->get_url(&pBURL)) &&
		SUCCEEDED(pXMLError->get_reason(&pBReason)) )
	{
	    _ftprintf(stderr, TEXT("%S"), pBReason);
	    if (line > 0)
	    {
	        _tprintf(TEXT("Error found by MSXML parser:")
					 TEXT("on line %d, position %d in \"%S\".\n"), 
						line, linePos, pBURL);
		}
	}
	else 
	{
		_tprintf(
			TEXT("Internal Error: DOM API call on IMLDOMParseError failed\n"));
	}

    if (pBURL)
		SysFreeString(pBURL);
	if (pBReason)
		SysFreeString(pBReason);

    return hr;
}


////////////////////////////////////////////////////////////////////////////
// Helper function: Check load results
////////////////////////////////////////////////////////////////////////////
HRESULT CheckLoad(PIXMLDOMDocument2 &pDoc)
{
    PIXMLDOMParseError  pXMLError = NULL;
    LONG errorCode = E_FAIL;
    HRESULT hr = S_OK;

    if (FAILED(hr = pDoc->get_parseError(&pXMLError)))
	{
		_tprintf(TEXT("Internal Error: DOM API call get_parseError failed\n"));
	}
	else if (FAILED(hr = pXMLError->get_errorCode(&errorCode)))
	{
		_tprintf(TEXT("Internal Error: DOM API call get_errorCode failed\n"));
	}
	else 
	{
	    if (errorCode != 0)
		{
	        hr = ReportError(pXMLError);
		}
		else
		{
			_ftprintf(stderr, TEXT("XML document loaded successfully\n"));
	    }
	}

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: CheckLoad\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper Function: Print error returned by MSI API function 
////////////////////////////////////////////////////////////////////////////
void PrintError(UINT errorCode)
{
	switch (errorCode) {

	case ERROR_ACCESS_DENIED:
		_tprintf(TEXT("***ERROR_ACCESS_DENIED***\n"));
		break;
	case ERROR_BAD_PATHNAME:
		_tprintf(TEXT("***ERROR_BAD_PATHNAME***\n"));
		break;
	case ERROR_BAD_QUERY_SYNTAX:
		_tprintf(TEXT("***ERROR_BAD_QUERY_SYNTAX***\n"));
		break;
	case ERROR_CREATE_FAILED:
		_tprintf(TEXT("***ERROR_CREATE_FAILED***\n"));
		break;
	case ERROR_FUNCTION_FAILED:
		_tprintf(TEXT("***ERROR_FUNCTION_FAILED***\n"));
		break;
	case ERROR_INVALID_DATA:
		_tprintf(TEXT("***ERROR_INVALID_DATA***\n"));
		break;		
	case ERROR_INVALID_FIELD:
		_tprintf(TEXT("***ERROR_INVALID_FIELD***\n"));
		break;
	case ERROR_INVALID_HANDLE:
		_tprintf(TEXT("***ERROR_INVALID_HANDLE***\n"));
		break;
	case ERROR_INVALID_HANDLE_STATE:
		_tprintf(TEXT("***ERROR_INVALID_HANDLE_STATE***\n"));
		break;
	case ERROR_INVALID_PARAMETER:
		_tprintf(TEXT("***ERROR_INVALID_PARAMETER***\n"));
		break;
	case ERROR_MORE_DATA:
		_tprintf(TEXT("***ERROR_MORE_DATA***\n"));
		break;
	case ERROR_NO_MORE_ITEMS:
		_tprintf(TEXT("***ERROR_NO_MORE_ITEMS***\n"));
		break;
	case ERROR_OPEN_FAILED:
		_tprintf(TEXT("***ERROR_OPEN_FAILED***\n"));
		break;
	case ERROR_SUCCESS:
		_tprintf(TEXT("***ERROR_SUCCESS***\n"));
		break;
	default:
		_tprintf(TEXT("Unrecognized Error\n"));
		break;
	}
}

////////////////////////////////////////////////////////////////////////////
// GetSQLCreateQuery: 
//		Given a template DB and a table name, return the SQL query string
//		for creating that table via pszSQLCreate
////////////////////////////////////////////////////////////////////////////
HRESULT GetSQLCreateQuery(LPTSTR szTable, MSIHANDLE hDBTemplate, 
						  LPTSTR *pszSQLCreate)
{
	// Issue: in the future, should cache SQLQuery per Template DB
	//		  use a map indexed by installerversion
    HRESULT hr = S_OK;
	UINT errorCode = ERROR_SUCCESS;
	LPTSTR szTemp = NULL;

	int cColumn = -1, i =1; // Record field count
	LPTSTR szSQLCreate = NULL;

	PMSIHANDLE hView = NULL;
	PMSIHANDLE hRecColName = NULL;
	PMSIHANDLE hRecColType = NULL;
	PMSIHANDLE hRecPrimaryKeys = NULL;

	CQuery qDBSchema;

	szSQLCreate = new TCHAR[_tcslen(szTable) + 20];
	assert(szSQLCreate!=NULL);

	_stprintf(szSQLCreate, TEXT("CREATE TABLE `%s` ("), szTable);

	if ((errorCode = qDBSchema.Open(hDBTemplate, TEXT("SELECT * From %s"), 
										szTable))
			!= ERROR_SUCCESS)
	{
		_tprintf(TEXT("Error: failed to open CQuery qDBSchema\n"));
		goto CleanUp;
	}
		
	if ((errorCode = qDBSchema.GetColumnInfo(MSICOLINFO_NAMES, &hRecColName))
			!= ERROR_SUCCESS)
	{
		_tprintf(TEXT("Error: failed to get column info - names\n"));
		goto CleanUp;
	}

	if ((errorCode = qDBSchema.GetColumnInfo(MSICOLINFO_TYPES, &hRecColType)) 
		!= ERROR_SUCCESS)
	{
		_tprintf(TEXT("Error: failed to get column info - types\n"));
		goto CleanUp;
	}

	cColumn = MsiRecordGetFieldCount(hRecColName);
	if (-1 == cColumn)
	{
		_tprintf(TEXT("ERROR: Failed to get field count. \n"));
		hr = E_FAIL;
		goto CleanUp;
	}
	
	for (i=1; i<=cColumn; i++)
	{
		// get the name of the ith column
		LPTSTR szColumnName = new TCHAR[256];
		DWORD cchColumnName = 256;

		if ( (errorCode = WmcRecordGetString(hRecColName, i, szColumnName,
											&cchColumnName))
				!= ERROR_SUCCESS)
		{
			_tprintf(TEXT("Error: failed when calling WmcRecordGetString\n"));
			delete[] szColumnName;
			goto CleanUp;
		}
	
		szTemp = szSQLCreate;
		szSQLCreate = new TCHAR[_tcslen(szTemp) + _tcslen(szColumnName) + 3];
		assert(szSQLCreate!=NULL);
		_stprintf(szSQLCreate, TEXT("%s`%s`"), szTemp, szColumnName);
		
		delete[] szColumnName;
		delete[] szTemp;
		szTemp=NULL;

		// get the description of the ith column
		LPTSTR szColumnType = new TCHAR[256];
		DWORD cchColumnType = 256;

		if ( (errorCode = WmcRecordGetString(hRecColType, i, szColumnType, 
												&cchColumnType))
					!= ERROR_SUCCESS)
		{
			_tprintf(TEXT("Error: failed when calling WmcRecordGetString\n"));
			delete[] szColumnType;
			goto CleanUp;
		}

		switch (*szColumnType) {
			case 's' :
			case 'S' :
			case 'l' :
			case 'L' :
				if ( (2 == _tcslen(szColumnType)) && ('0' == *(szColumnType+1)) )
				{
					szTemp = szSQLCreate;
					szSQLCreate = new TCHAR[_tcslen(szTemp) + 10];
					assert(szSQLCreate!=NULL);
					_stprintf(szSQLCreate, TEXT("%s LONGCHAR"), szTemp);
					delete[] szTemp;
					szTemp = NULL;
				}
				else
				{
					szTemp = szSQLCreate;
					szSQLCreate = 
						new TCHAR[_tcslen(szTemp)+_tcslen(szColumnType)-1 + 9];
					assert(szSQLCreate!=NULL);
					_stprintf(szSQLCreate, TEXT("%s CHAR (%s)"), szTemp, 
									szColumnType+1);
					delete[] szTemp;
					szTemp = NULL;
				}
				break;
			case 'i' :
			case 'I' :
				if ( '2' == *(szColumnType+1) )		
				{
					szTemp = szSQLCreate;
					szSQLCreate = new TCHAR[_tcslen(szTemp) + 7];
					assert(szSQLCreate!=NULL);
					_stprintf(szSQLCreate, TEXT("%s SHORT"), szTemp);
					delete[] szTemp;
					szTemp = NULL;
				}

				else if ( '4' == *(szColumnType+1) )
				{
					szTemp = szSQLCreate;
					szSQLCreate = new TCHAR[_tcslen(szTemp) + 6];
					assert(szSQLCreate!=NULL);
					_stprintf(szSQLCreate, TEXT("%s LONG"), szTemp);
					delete[] szTemp;
					szTemp = NULL;
				}
				else // should not happen
				{
					_tprintf(TEXT("Error: invalid character returned from")
							 TEXT("MsiGetColumnInfo\n"));
					errorCode = ERROR_INVALID_DATA;
					goto CleanUp;
				}
				break;
			case 'v' :
				{
					szTemp = szSQLCreate;
					szSQLCreate = new TCHAR[_tcslen(szTemp) + 8];
					assert(szSQLCreate!=NULL);
					_stprintf(szSQLCreate, TEXT("%s OBJECT"), szTemp);
					delete[] szTemp;
					szTemp = NULL;
				}
				break;
			case 'g' :
			case 'j' :
				//Issue: is temporary column possible?
			default: // should not happen
				_tprintf(TEXT("Error: invalid character returned from")
						 TEXT("MsiGetColumnInfo\n"));
				errorCode = ERROR_INVALID_DATA;
				goto CleanUp;
		}

		if (_istlower(*szColumnType))
		{
			szTemp = szSQLCreate;
			szSQLCreate = new TCHAR[_tcslen(szTemp) + 10];
			assert(szSQLCreate!=NULL);
			_stprintf(szSQLCreate, TEXT("%s NOT NULL"), szTemp);
			delete[] szTemp;
			szTemp = NULL;
		}

		if ( ('l' == *szColumnType) || ('L' == *szColumnType) )
		{
			szTemp = szSQLCreate;
			szSQLCreate = new TCHAR[_tcslen(szTemp) + 13];
			assert(szSQLCreate!=NULL);
			_stprintf(szSQLCreate, TEXT("%s LOCALIZABLE"), szTemp);
			delete[] szTemp;
			szTemp = NULL;
		}

		if (i < cColumn)
		{
			szTemp = szSQLCreate;
			szSQLCreate = new TCHAR[_tcslen(szTemp) + 3];
			assert(szSQLCreate!=NULL);
			_stprintf(szSQLCreate, TEXT("%s, "), szTemp);
			delete[] szTemp;
			szTemp = NULL;
		}

		delete[] szColumnType;
	}
	
	szTemp = szSQLCreate;
	szSQLCreate = new TCHAR[_tcslen(szTemp) + 14];
	assert(szSQLCreate!=NULL);
	_stprintf(szSQLCreate, TEXT("%s PRIMARY KEY "), szTemp);
	delete[] szTemp;
	szTemp = NULL;

	if ( (errorCode = MsiDatabaseGetPrimaryKeys(hDBTemplate, szTable, 
													&hRecPrimaryKeys))
			!= ERROR_SUCCESS)
	{
		_tprintf(TEXT("Error: failed to get primary keys\n"));
		goto CleanUp;
	}

	cColumn = MsiRecordGetFieldCount(hRecPrimaryKeys);

	if (-1 == cColumn)
	{
		_tprintf(TEXT("ERROR: Failed to get field count. \n"));
		hr = E_FAIL;
		goto CleanUp;
	}
	
	for (i=1; i<=cColumn; i++)
	{
		LPTSTR szPrimaryKey = new TCHAR[256];
		DWORD cchPrimaryKey = 256;

		if ( (errorCode = WmcRecordGetString(hRecPrimaryKeys, i, szPrimaryKey,
												&cchPrimaryKey))
					!= ERROR_SUCCESS)
		{
			_tprintf(TEXT("Error: failed when calling WmcRecordGetString\n"));
			delete[] szPrimaryKey;
			goto CleanUp;
		}
	
		szTemp = szSQLCreate;
		szSQLCreate = new TCHAR[_tcslen(szTemp) + _tcslen(szPrimaryKey) + 3];
		assert(szSQLCreate!=NULL);
		_stprintf(szSQLCreate, TEXT("%s`%s`"), szTemp, szPrimaryKey);
		delete[] szTemp;
		szTemp = NULL;

		if (i < cColumn)
		{
			szTemp = szSQLCreate;
			szSQLCreate = new TCHAR[_tcslen(szTemp) + 3];
			assert(szSQLCreate!=NULL);
			_stprintf(szSQLCreate, TEXT("%s, "), szTemp);
			delete[] szTemp;
			szTemp = NULL;
		}
		delete[] szPrimaryKey;
	}

	szTemp = szSQLCreate;
	szSQLCreate = new TCHAR[_tcslen(szTemp) + 2];
	assert(szSQLCreate!=NULL);
	_stprintf(szSQLCreate, TEXT("%s)"), szTemp);
	delete[] szTemp;
	szTemp = NULL;


CleanUp:

	if (FAILED(hr) || (errorCode != ERROR_SUCCESS)) {
		_tprintf(TEXT("Error in function: GetSQLCreateQuery when creating query for table: %s\n")
			, szTable);
		if (szSQLCreate)
			delete[] szSQLCreate;
		*pszSQLCreate = NULL;
		hr = E_FAIL;
	}
	else
	{
		*pszSQLCreate = szSQLCreate;
	}

	if (szTemp)
		delete[] szTemp;

	qDBSchema.Close();

	return hr;
}

////////////////////////////////////////////////////////////////////////////
// CreateTable: 
////////////////////////////////////////////////////////////////////////////
HRESULT CreateTable_SKU(LPTSTR szTable, SkuSet *pskuSet)
{
    HRESULT hr = S_OK;
	UINT errorCode = ERROR_SUCCESS;

	// Find all the SKUs that need to create the Property table 
	for (int i=0; i<g_cSkus; i++)
	{
		if (pskuSet->test(i))
		{
			// only create table if the table doesn't already exist
			if (!g_rgpSkus[i]->TableExists(szTable))
			{
				LPTSTR szSQLCreate = NULL;
				CQuery qCreateTable;
				
				// use the template DB to form the SQL query for table creation
				hr = GetSQLCreateQuery(szTable, g_rgpSkus[i]->m_hTemplate, 
										&szSQLCreate);

				if (SUCCEEDED(hr))
				{
					// now use the formed SQL string to create the table in the 
					// output database
					if (ERROR_SUCCESS !=
						(errorCode = qCreateTable.OpenExecute
										(g_rgpSkus[i]->m_hDatabase, 
												NULL, szSQLCreate)))
					{
						_tprintf(TEXT("Error: Failed to use the formed SQL")
								 TEXT("string to create the table %s\n"), 
								 szTable);
						PrintError(errorCode);
						hr = E_FAIL;
						break;
					}
					else 
					{
						// create a CQuery to be used for future insertion 
						// into this table and cache it in the Sku object
						hr = g_rgpSkus[i]->CreateCQuery(szTable);
						qCreateTable.Close();
					}

					delete[] szSQLCreate;
					if (FAILED(hr)) break;
				}
			}
		}
	}

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert a record into the specified table in the database
//				    This function will either perform insertion for a set
//					of Skus or just for a single Sku, depending on whether
//					pskuSet == NULL or not.
////////////////////////////////////////////////////////////////////////////
HRESULT InsertDBTable_SKU(LPTSTR szTable, PMSIHANDLE &hRec, SkuSet *pskuSet,
						  int iSkuIndex)
{
	HRESULT hr = S_OK;
	UINT errorCode = ERROR_SUCCESS;

	// if pskuSet is NULL, it means that only insertion into ONE SKU
	// (indexed by iSkuIndex) is needed
	if (!pskuSet)
	{
		assert((iSkuIndex >=0) && (iSkuIndex<g_cSkus));
		// never attempt to insert into a table that hasn't been created yet
		assert(g_rgpSkus[iSkuIndex]->TableExists(szTable));

		// Obtain the CQuery stored in the map
		CQuery *pCQuery = g_rgpSkus[iSkuIndex]->GetInsertQuery(szTable);
		
		if (ERROR_SUCCESS != 
				(errorCode = pCQuery->Modify(MSIMODIFY_INSERT, hRec)))
		{
			PrintError(errorCode);
			_tprintf(TEXT("Error: Failed to insert into %s table for SKU %s\n"), 
				szTable, g_rgpSkus[iSkuIndex]->GetID());
			hr = E_FAIL;
		}

		return hr;
	}

	for (int i=0; i<g_cSkus; i++)
	{
		if (pskuSet->test(i))
		{
			// never attempt to insert into a table that hasn't been created
			// yet
			assert(g_rgpSkus[i]->TableExists(szTable));

			// Obtain the CQuery stored in the map
			CQuery *pCQuery = g_rgpSkus[i]->GetInsertQuery(szTable);
			
			if (ERROR_SUCCESS != 
				(errorCode = pCQuery->Modify(MSIMODIFY_INSERT, hRec)))
			{
				PrintError(errorCode);
				_tprintf(TEXT("Error: Failed to insert into %s table for ")
						 TEXT("SKU %s\n"), 
					szTable, g_rgpSkus[i]->GetID());
				hr = E_FAIL;
				break;
			}
		}
	}

	return hr;
}
////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the Property table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertProperty(LPCTSTR szProperty, LPCTSTR szValue, SkuSet *pskuSet,
					   int iSkuIndex)
{
    HRESULT hr=S_OK;
	
	PMSIHANDLE hRec = MsiCreateRecord(2);

	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szProperty) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szValue))
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string ")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Property"), hRec, pskuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertPropertyTable\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the Directory table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertDirectory(LPCTSTR szDirectory, LPCTSTR szDirectory_Parent, 
						LPCTSTR szDefaultDir, SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(3);

	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szDirectory) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szDirectory_Parent) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szDefaultDir) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string ")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Directory"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertDirectory\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the Feature table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertFeature(LPCTSTR szFeature, LPCTSTR szFeatureParent, 
					  LPCTSTR szTitle, LPCTSTR szDescription, int iDisplay, 
					  int iInstallLevel, LPCTSTR szDirectory, UINT iAttribute,
					  SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	if (MSI_NULL_INTEGER == iAttribute)
		iAttribute = 0;

	PMSIHANDLE hRec = MsiCreateRecord(8);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFeature) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szFeatureParent) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szTitle) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szDescription) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 5, iDisplay) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 6, iInstallLevel) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 7, szDirectory) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 8, iAttribute) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Feature"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertFeature\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the Condition table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertCondition(LPCTSTR szFeature_, int iLevel, LPCTSTR szCondition, 
					  SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(3);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFeature_) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 2, iLevel) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szCondition) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord")
					 TEXT(" parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Condition"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertCondition\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the FeatureComponents table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertFeatureComponents(LPCTSTR szFeature, LPCTSTR szComponent, 
								SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;
	assert(szFeature && szComponent);

	PMSIHANDLE hRec = MsiCreateRecord(2);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFeature) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szComponent) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("FeatureComponents"), hRec, pSkuSet,
								iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr))
		_tprintf(TEXT("Error in function: InsertFeatureComponents\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the Component table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertComponent(LPCTSTR szComponent, LPCTSTR szComponentId, 
						LPCTSTR szDirectory_, UINT iAttributes, 
						LPCTSTR szCondition, LPCTSTR szKeyPath, 
						SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	if (MSI_NULL_INTEGER == iAttributes)
		iAttributes = 0;
	PMSIHANDLE hRec = MsiCreateRecord(6);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szComponent) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szComponentId) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szDirectory_) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 4, iAttributes) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szCondition) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 6, szKeyPath) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Component"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertComponent\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the CreateFolder table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertCreateFolder(LPCTSTR szDirectory, LPCTSTR szComponent, 
						   SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(2);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szDirectory) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szComponent) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("CreateFolder"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertCreateFolder\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the LockPermissions table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertLockPermissions(LPCTSTR szLockObject, LPCTSTR szTable, 
							  LPCTSTR szDomain, LPCTSTR szUser,
			  				  int iPermission, SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(5);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szLockObject) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szTable)	   ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szDomain)	   ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szUser)	   ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec,5, iPermission))
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("LockPermissions"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertLockPermissions\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the File table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertFile(LPCTSTR szFile, LPCTSTR szComponentId,
				   LPCTSTR szFileName, UINT uiFileSize, LPCTSTR szVersion, 
				   LPCTSTR szLanguage, UINT iAttributes, INT iSequence,
				   SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(8);

	if (MSI_NULL_INTEGER == uiFileSize) {
		uiFileSize = 0;
	}

	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFile) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szComponentId) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szFileName) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 4, uiFileSize) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szVersion) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 6, szLanguage) || 
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 7, iAttributes) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 8, iSequence) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("File"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertFile\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the Font table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertFont(LPCTSTR szFile_, LPCTSTR szFontTitle, SkuSet *pSkuSet,
				   int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(2);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFile_) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szFontTitle) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Font"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertFont\n"));
#endif

    return hr;
}


////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the BindImage table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertBindImage(LPCTSTR szFile_, LPCTSTR szPath, SkuSet *pSkuSet, 
						int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(2);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFile_) ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szPath) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string")
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("BindImage"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertBindImage\n"));
#endif

    return hr;
}


////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the SelfReg table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertSelfReg(LPCTSTR szFile_, UINT uiCost, SkuSet *pSkuSet, 
					  int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(2);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFile_) ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 2, uiCost) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("SelfReg"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertSelfReg\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the MoveFile table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertMoveFile(LPCTSTR szFileKey, LPCTSTR szComponent_, 
					   LPCTSTR szSourceName, LPCTSTR szDestName, 
					   LPCTSTR szSourceFolder, LPCTSTR szDestFolder,
					   UINT uiOptions, SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(7);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFileKey)		 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szComponent_)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szSourceName)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szDestName)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szSourceFolder) ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 6, szDestFolder)	 ||
		    ERROR_SUCCESS != MsiRecordSetInteger(hRec, 7, uiOptions) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("MoveFile"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertMoveFile\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the RemoveFile table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertRemoveFile(LPCTSTR szFileKey, LPCTSTR szComponent_, 
					   LPCTSTR szFileName, LPCTSTR szDirProperty, 
					   UINT uiInstallMode, SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(7);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szFileKey)		 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szComponent_)	 ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szFileName)	 ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szDirProperty)	 ||
			ERROR_SUCCESS != MsiRecordSetInteger(hRec, 5, uiInstallMode) )
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("RemoveFile"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertRemoveFile\n"));
#endif

    return hr;
}


////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the IniFile table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertIniFile(LPCTSTR szIniFile, LPCTSTR szFileName, 
					  LPCTSTR szDirProperty, LPCTSTR szSection, LPCTSTR szKey,
					  LPCTSTR szValue, UINT uiAction, LPCTSTR szComponent_,
					  SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(8);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szIniFile)		 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szFileName)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szDirProperty)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szSection)		 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szKey)			 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 6, szValue)		 ||
		    ERROR_SUCCESS != MsiRecordSetInteger(hRec, 7, uiAction)		 ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 8, szComponent_)	)
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("IniFile"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertIniFile\n"));
#endif

    return hr;
}

//ISSUE: this function is virtually the same as the InsertIniFIle. 
//		 Make them one function?
////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the RemoveIniFile table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertRemoveIniFile(LPCTSTR szRemoveIniFile, LPCTSTR szFileName, 
						    LPCTSTR szDirProperty, LPCTSTR szSection, 
							LPCTSTR szKey, LPCTSTR szValue, UINT uiAction, 
							LPCTSTR szComponent_, SkuSet *pSkuSet, 
							int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(8);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szRemoveIniFile)||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 2, szFileName)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szDirProperty)	 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szSection)		 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szKey)			 ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 6, szValue)		 ||
		    ERROR_SUCCESS != MsiRecordSetInteger(hRec, 7, uiAction)		 ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 8, szComponent_)	)
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("RemoveIniFile"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertRemoveIniFile\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the RemoveRegistry table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertRegistry(LPCTSTR szRegistry, int iRoot, LPCTSTR szKey, 
					   LPCTSTR szName, LPCTSTR szValue, LPCTSTR szComponent_, 
					   SkuSet *pSkuSet, int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(6);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szRegistry)	  ||
		    ERROR_SUCCESS != MsiRecordSetInteger(hRec, 2, iRoot)		  ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szKey)			  ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szName)		  ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szValue)		  ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 6, szComponent_)	)
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("Registry"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertRegistry\n"));
#endif

    return hr;
}

////////////////////////////////////////////////////////////////////////////
// Helper function: Insert into the RemoveRegistry table
////////////////////////////////////////////////////////////////////////////
HRESULT InsertRemoveRegistry(LPCTSTR szRemoveRegistry, int iRoot, 
						     LPCTSTR szKey, LPCTSTR szName, 
							 LPCTSTR szComponent_, SkuSet *pSkuSet, 
							 int iSkuIndex)
{
    HRESULT hr=S_OK;

	PMSIHANDLE hRec = MsiCreateRecord(5);
	if (hRec != NULL)
	{
		if (ERROR_SUCCESS != MsiRecordSetString(hRec, 1, szRemoveRegistry)||
		    ERROR_SUCCESS != MsiRecordSetInteger(hRec, 2, iRoot)		  ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 3, szKey)			  ||
		    ERROR_SUCCESS != MsiRecordSetString(hRec, 4, szName)		  ||
			ERROR_SUCCESS != MsiRecordSetString(hRec, 5, szComponent_)	)
		{
			_tprintf(TEXT("Internal Error: Failed to set MsiRecord string") 
					 TEXT("parameters\n"));
			return E_FAIL;
		}

		hr = InsertDBTable_SKU(TEXT("RemoveRegistry"), hRec, pSkuSet, iSkuIndex);
	}
	else
		_tprintf(TEXT("Internal Error: Failed to create a new msi record\n"));

#ifdef DEBUG
	if (FAILED(hr)) _tprintf(TEXT("Error in function: InsertRemoveRegistry\n"));
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\wmc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       wmc.h
//              Main header file for the wmc project
//--------------------------------------------------------------------------

#ifndef XMSI_WMC_H
#define XMSI_WMC_H

#include <Windows.h>
#include <assert.h>
#include <stdio.h>   // printf/wprintf
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include <stdlib.h>  // exit
#include <objbase.h>
#include <initguid.h>
#include <map>
#include <set>
#include <vector>
#include <algorithm> // find

#include "MsiQuery.h"
#include "Msidefs.h"
#include "msxml.h"

#include "CommandOpt.h"
#include "query.h"
#include "SkuSet.h"

using namespace std;

//____________________________________________________________________________
//
// COM pointer encapsulation to force the Release call at destruction
// The encapsulated pointer is also Release'd on assignment of a new value.
// The object may be used where either a pointer is expected.
// This object behaves as a pointer when using operators: ->, *, and &.
// A non-null pointer may be tested for simply by using: if(PointerObj).
// Typedefs may be defined for the individual template instantiations
//____________________________________________________________________________

template <class T> class CComPointer
{
 public:
		CComPointer() : m_pi(NULL) {}
        CComPointer(T* pi) : m_pi(pi){}
        CComPointer(IUnknown& ri, const IID& riid) 
		{
			ri.QueryInterface(riid, (void**)&m_pi);
		}
        CComPointer(const CComPointer<T>& r) // copy constructor, calls AddRef
        {
			if(r.m_pi)
				((IUnknown*)r.m_pi)->AddRef();
			m_pi = r.m_pi;
        }
		// release ref count at destruction
		~CComPointer() {if (m_pi) ((IUnknown*)m_pi)->Release();} 
		
		// copy assignment, calls AddRef
        CComPointer<T>& operator =(const CComPointer<T>& r) 
        {
            if(r.m_pi)
                    ((IUnknown*)r.m_pi)->AddRef();
            if (m_pi) ((IUnknown*)m_pi)->Release();
            m_pi=r.m_pi;
            return *this;
	    }
        CComPointer<T>& operator =(T* pi)
        {
			if (m_pi) ((IUnknown*)m_pi)->Release(); m_pi = pi; return *this;
		}

		// returns pointer, no ref count change
        operator T*() {return m_pi;}    
		// allow use of -> to call member functions
        T* operator ->() {return m_pi;}  
		// allow dereferencing (can't be null)
        T& operator *()  {return *m_pi;} 
        T** operator &() 
		{
			if (m_pi) ((IUnknown*)m_pi)->Release(); m_pi = 0; return &m_pi;
		}
 private:
        T* m_pi;
};

//////////////////////////////////////////////////////////////////////////////
// Smart pointer definition for each MSXML interfaces
typedef CComPointer<IXMLDOMDocument/*2*/> PIXMLDOMDocument2;
typedef CComPointer<IXMLDOMNode> PIXMLDOMNode;
typedef CComPointer<IXMLDOMNodeList> PIXMLDOMNodeList;
typedef CComPointer<IXMLDOMElement> PIXMLDOMElement;
typedef CComPointer<IXMLDOMParseError> PIXMLDOMParseError;
//////////////////////////////////////////////////////////////////////////////


// the required less operator for map and set definitions that use LPTSTR
// as keys
struct Cstring_less {
	 bool operator()(LPCTSTR p, LPCTSTR q) const { return _tcscmp(p, q)<0; }
};

/* used to hold a Feature name and a module name that has the following
	relationship: the feature claims ownership of the module through a 
	<UseModule> tag */
typedef struct
{
	LPTSTR szFeature;
	LPTSTR szModule;
} FOM; /*FeatureOwnModule */

/* used to hold a Table value and a LockObject value to be used by 
   ProcessLockPermissions */
typedef struct
{
	LPTSTR szTable;
	LPTSTR szLockObject;
} TableLockObj;

/* used to hold a ComponentID, a Root of Registry, a Key of Registry
   to be passed from ProcessRegistry to ProcessDelete and ProcessCreate
*/
typedef struct
{
	LPTSTR szComponent;
	int iRoot;
	LPTSTR szKey;
} CompRootKey;

/* Most of the values passed among functions are either int or LPTSTR.
   Also the values of the columns in the DB are also int or string.
   So use a union to represent such values */
typedef enum 
{
	INTEGER=0, 
	INSTALL_LEVEL, 
	STRING, 
	STRING_LIST, 
	FM_PAIR,
	TABLELOCKOBJ,
	COMPROOTKEY,
} ValType;

typedef union
{
	int intVal;
	LPTSTR szVal;
	set<LPTSTR, Cstring_less> *pSetString;
	FOM *pFOM;
	TableLockObj *pTableLockObj;
	CompRootKey *pCompRootKey;
} IntStringValue;

/* the following structure is used to store a value that is associated with
	a set of SKUs */
typedef struct 
{
	SkuSet *pSkuSet;
	IntStringValue isVal;
} SkuSetVal;

/* where the information should go: Property table, summary info, or both */
typedef enum {PROPERTY_TABLE = 0, SUMMARY_INFO, BOTH }INFODESTINATION;

/* ISSUE: define the following under XMSI own namespace */
typedef enum
{
	PLACEHOLDER = 0,
	PRODUCTFAMILY,
	SKUMANAGEMENT,
	SKUS,
	SKU,
	SKUGROUPS,
	SKUGROUP,
	INFORMATION,
	PRODUCTNAME,
	PRODUCTCODE,
	UPGRADECODE,
	PRODUCTVERSION,
	MANUFACTURER,
	KEYWORDS,
	TEMPLATE,
	INSTALLERVERSIONREQUIRED,
	LONGFILENAMES,
	SOURCECOMPRESSED,
	CODEPAGE,
	SUMMARYCODEPAGE,
	PACKAGEFILENAME,
	DIRECTORIES,
	DIRECTORY,
	NAME,
	TARGETDIR,
	TARGETPROPERTY,
	INSTALLLEVELS,
	XMSI_INSTALLLEVEL,
	FEATURES,
	FEATURE,
	TITLE,
	DESCRIPTION,
	DISPLAYSTATE,
	ILEVEL,
	ILEVELCONDITION,
	DIR,
	STATE,
	FAVOR,
	ADVERTISE,
	DISALLOWABSENT,
	USEMODULE,
	TAKEOWNERSHIP,
	OWNSHORTCUTS,
	OWNCLASSES,
	OWNTYPELIBS,
	OWNEXTENSIONS,
	OWNQUALIFIEDCOMPONENTS,
	MODULES,
	MODULE,
	COMPONENT,
	XMSI_GUID,
	COMPONENTDIR,
	CREATEFOLDER,
	LOCKPERMISSION,
	COMPONENTATTRIBUTES,
	RUNFROM,
	SHAREDDLLREFCOUNT,
	PERMANENT,
	TRANSITIVE,
	NEVEROVERWRITE,
	CONDITION,
	XMSI_FILE,
	FILENAME,
	FILESIZE,
	FILEVERSION,
	FILELANGUAGE,
	FILEATTRIBUTES,
	READONLY,
	HIDDEN,
	SYSTEM,
	VITAL,
	CHECKSUM,
	COMPRESSED,
	FONT,
	BINDIMAGE,
	SELFREG,
	MOVEFILE,
	SOURCENAME,
	DESTNAME,
	SOURCEFOLDER,
	DESTFOLDER,
	COPYFILE,
	REMOVEFILE,
	FNAME_REMOVEFILE,
	DIRPROPERTY,
	XMSI_INSTALLMODE,
	INIFILE,
	FNAME_INIFILE,
	DIRPROPERTY_INIFILE,
	SECTION,
	KEY,	
	VALUE_INIFILE,	
	ACTION,
	REMOVEINIFILE,
	FNAME_REMOVEINIFILE,
	DIRPROPERTY_REMOVEINIFILE,
	VALUE_REMOVEINIFILE,
	ACTION_REMOVEINIFILE,
	XMSI_REGISTRY,
	XMSI_DELETE,
	XMSI_CREATE
} NodeIndex;

////////////////////////////////////////////////////////////////////////////
// class definitions

// this class stores a sequence of <SkuSet, IntStringValue> pairs and
// provides a set of interfaces to access the stored information.

class SkuSetValues
{
public:
	SkuSetValues();

	~SkuSetValues();

	/* call DirectInsert when it is sure that the SkuSet
	   to be inserted doesn't overlap with any SkuSet stored. */

	// store the pointer (caller should allocate memory)
	void DirectInsert(SkuSetVal *pSkuSetVal);
	// construct a new SkuSetVal object using the passed-in values
	// (caller should allocate memory for *pSkuSet)
	void DirectInsert(SkuSet *pSkuSet, IntStringValue isVal);

	/* call SplitInsert when the SkuSet to be inserted might overlap
	   with the SkuSets stored. During insertion, the collisions will be
	   solved by splitting the existing SkuSet. This often happens when 
	   more than one node in the XML file corresponds to one column value 
	   in the DB. So this function also takes a function pointer that tells
	   how to update the value stored if a collision happens */

	// caller allocates memory for *pSkuSetVal
	HRESULT SplitInsert(SkuSetVal *pSkuSetVal, 
						HRESULT (*UpdateFunc)
							(IntStringValue *pIsValOut, 
							 IntStringValue isVal1, 
							 IntStringValue isVal2));

	// caller allocates memory for *pSkuSet 
	HRESULT SplitInsert(SkuSet *pSkuSet, IntStringValue isVal, 
				HRESULT (*UpdateFunc)(IntStringValue *pIsValOut, IntStringValue isVal1, 
									  IntStringValue isVal2));

	// CollapseInsert: Sometimes when inserting into the list of <SkuSet, Value>
	//				   data structure, we want to collapse the SkuSets with the
	//				   same value into one slot. One example is when inserting
	//				   into a data structure storing references (to Directories,
	//				   to InstallLevels, etc.)
	//				   when NoRepeat is set to true, the compiler will check 
	//				   that for any given SKU, the value to be inserted is not 
	//				   on the list already. This solves the problem of checking
	//				   the uniqueness of an attribute - sometimes an attribute
	//				   corresponds to a DB column(primary key) instead of the 
	//				   element that the attribute belongs to
	HRESULT SkuSetValues::CollapseInsert(SkuSet *pSkuSet, IntStringValue isVal, 
										bool NoDuplicate);

	// return the value(s) of a set of Skus in the form of
	// a SkuSetValues object. Returhn E_FAIL if some of the SKUs
	// don't exist in the data structure since this function
	// will be mainly used to query stored references.
	HRESULT GetValueSkuSet(SkuSet *pSkuSet, 
							SkuSetValues **ppSkuSetValuesRetVal);

	// return the value stored for any given SKU
	IntStringValue GetValue(int iPos);

	// return the pointer to the SkuSetVal that stores the most common
	// value (its SkuSet has the most bits set)
	SkuSetVal *GetMostCommon();

	// Following access functions mimic an iterator
	SkuSetVal *Start();
	SkuSetVal *End();
	SkuSetVal *Next();

	bool Empty();

	// erase the element from the storage W/O freeing memory
	void Erase(SkuSetVal *pSkuSetVal);

	// The type of the value store
	void SetValType(ValType vt) {m_vt = vt;}
	ValType GetValType() {return m_vt;}

	void Print();
private:
	vector<SkuSetVal *> *m_pVecSkuSetVals;
	vector<SkuSetVal *>::iterator m_iter;

	ValType m_vt;
};

/* This class stores the per Sku information */
class Sku {
public:

	MSIHANDLE m_hDatabase;  // handle to the output database
	MSIHANDLE m_hTemplate;  // handle to the template database
	MSIHANDLE m_hSummaryInfo; // handle to the output summary information
	
	Sku():m_szID(NULL), 
		  m_hDatabase(NULL), 
		  m_hTemplate(NULL), 
		  m_hSummaryInfo(), 
		  m_mapCQueries() {}

	Sku(LPTSTR sz):m_hDatabase(NULL), 
				   m_hTemplate(NULL), 
				   m_hSummaryInfo(NULL),
				   m_mapCQueries(),
				   m_setModules() {m_szID = _tcsdup(sz); assert(m_szID);}

	~Sku();

	void FreeCQueries();
	
	void CloseDBHandles();

	bool TableExists(LPTSTR szTable);

	CQuery *GetInsertQuery(LPTSTR szTable)
	{
		if (0 == m_mapCQueries.count(szTable))
		{
			return NULL;
		}
		else
			return m_mapCQueries[szTable];
	}
	
	HRESULT CreateCQuery(LPTSTR szTable);

	void SetOwnedModule(LPTSTR szModule);

	bool OwnModule(LPTSTR szModule) 
	{return (0 != m_setModules.count(szModule));}

	// member access functions
	LPTSTR GetID() {return m_szID;}
	void SetID(LPTSTR sz) {m_szID = _tcsdup(sz);}

private:
	UINT m_index;  // the position of this SKU in the bit field
	LPTSTR m_szID;   // the Sku ID

	// Store the CQueries for DB table insertion (one CQuery per table)
	map<LPTSTR, CQuery *, Cstring_less> m_mapCQueries;

	// Store all the modules owned by this SKU
	set<LPTSTR, Cstring_less> m_setModules; 
};


// Represent an element that 
//			(1) corresponds to a row in the DB
//			(2) has Skuable children
//
// Notice:
//	 The following sequence has to be strictly enforced
//	for now:
//		(1) Call SetNodeIndex and SetValType;
//		(2) Call SetValue. Finish processing all children.
//			if there are more than one child correspoding to one column,
//			make sure to call SetNodeIndex at the beginning of processing
//			each child. SetNodeIndex guarantees 2 things:
//				(a) If there is an error happened, it is used to get the
//					node name;
//				(b) It resets the SkuSet that is used to check for
//					uniqueness
//			Failing to call SetNodeIndex will result in error!
//			
//		(3) Call Finalize;
//		(4) Call GetCommonValue and GetCommonSet
//		(5) Call GetValue
//	 Also: don't call GetValue on a Sku that belongs to 
//		the CommonSet

class ElementEntry
{
public:
	IntStringValue m_isValInfo; // very often some infomation needs to 
								// be passed into the children node
								// (Component ID, e.g.)
	ElementEntry():m_cColumns(0), m_rgValTypes(NULL), m_pSkuSetAppliesTo(NULL),
				   m_rgCommonValues(NULL), m_pSkuSetCommon(NULL),
				   m_rgpSkuSetValuesXVals(NULL), m_rgNodeIndices(NULL)
	{}

	ElementEntry(int cColumns, SkuSet *pSkuSetAppliesTo);

	~ElementEntry();

	ValType GetValType(int iColumn);
	void SetValType(ValType vt, int iColumn);

	NodeIndex GetNodeIndex(int iColumn);
	void SetNodeIndex(NodeIndex ni, int iColumn);

	/* the following 2 functions set the value of a column for a group 
		of Skus */

	// When the column value is decided by one kind of node in the WIML file
	HRESULT SetValue(IntStringValue isVal, int iColumn, 
					 SkuSet *pskuSetAppliesTo);

	// Store a list of values (a SkuSetValues object) for a column
	// Caller should allocate and free *pSkuSetValues
	HRESULT SetValueSkuSetValues(SkuSetValues *pSkuSetValues, int iColumn);

	// When the column value is decided by more than one type of node in the
	// WIML file. The passed-in function pointer tells how to update the 
	// column value.
	HRESULT SetValueSplit(IntStringValue isVal, int iColumn, 
						  SkuSet *pskuSetAppliesTo,
						  HRESULT (*UpdateFunc)
								(IntStringValue *pIsValOut, 
								 IntStringValue isVal1, 
								 IntStringValue isVal2));

	// return the value of a column for a specific SKU
	IntStringValue GetValue(int iColumn, int iPos);
	// return the common value of a column
	IntStringValue GetCommonValue(int iColumn);
	// return the SkuSet that the common values apply to
	SkuSet GetCommonSkuSet();
	// finalize the common values and the common set 
	// also check for missing required entities
	HRESULT Finalize();

	// should be called before calling Finalize on 
	// columns that are set by SetValueSplit
	SkuSetValues *GetColumnValue(int iColumn) 
	{ return m_rgpSkuSetValuesXVals[iColumn-1]; }

private:
	int m_cColumns;	// # columns in the DB table for this element
	ValType *m_rgValTypes; // an array storing the value type of each column
	SkuSet *m_pSkuSetAppliesTo; // The set of Skus this entry covers
	SkuSetVal **m_rgCommonValues; // common case values
	SkuSet *m_pSkuSetCommon; // the set of Skus that share the common values
	SkuSetValues **m_rgpSkuSetValuesXVals;	// an array of pointers to 
											// SkuSetValues 
											// storing the values that are
											// different from the common
											// ones
	NodeIndex *m_rgNodeIndices; // the NodeIndex of the node corresponding 
								// to each column
	SkuSet **m_rgpSkuSetValidate; // an array of pointers to SkuSets to 
								  // store all the Skus that have the
								  // column value set already
	SkuSet **m_rgpSkuSetUnique; // for those columns that will be decided
									// by more than one node. Need 2 SkuSets
									// to validate: one checking for uniqueness
									// one checking for not missing

};


// the Component class stores information related to processing <Component>
// entity
class Component {
public:
	PIXMLDOMNode m_pNodeComponent;
	Component();

	~Component();

	void SetSkuSet(SkuSet *pSkuSet);
	SkuSet *GetSkuSet();

	void SetUsedByFeature(LPTSTR szFeature, SkuSet *pSkuSet);
	SkuSetValues *GetFeatureUse();

	HRESULT SetOwnership(FOM *pFOM, SkuSetValues *pSkuSetValuesOwnership);
	HRESULT GetOwnership(NodeIndex ni, SkuSet *pSkuSet, 
						SkuSetValues **ppSkuSetValuesRetVal);

	HRESULT SetKeyPath(LPTSTR szKeyPath, SkuSet *pSkuSet);
	HRESULT GetKeyPath(SkuSet *pSkuSet, SkuSetValues **ppSkuSetValuesRetVal);

	void Print();

private:

	// the set of Skus that include this component
	SkuSet *m_pSkuSet;

	// store the ID of all the <Feature>s that use this component. essentially,
	// this is a list of lists of Feature IDs stored together with SkuSets
	SkuSetValues *m_pSkuSetValuesFeatureUse;

	// an array of SkuSetValues storing the ownership info of this component
	SkuSetValues *m_rgpSkuSetValuesOwnership[5];

	// Store the Keypath information 
	SkuSetValues *m_pSkuSetValuesKeyPath;
};
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// value_type definition for maps used 
typedef map<LPTSTR, int, Cstring_less>::value_type LI_ValType;
typedef map<LPTSTR, LPTSTR, Cstring_less>::value_type LL_ValType;
typedef map<LPTSTR, CQuery *, Cstring_less>::value_type LQ_ValType;
typedef map<LPTSTR, SkuSet *, Cstring_less>::value_type LS_ValType;
typedef map<LPTSTR, Component *, Cstring_less>::value_type LC_ValType;
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// struct definitions
typedef struct {
	NodeIndex enumNodeIndex;
	LPTSTR szPropertyName;
	INFODESTINATION enumDestination; 
	UINT uiPropertyID;
	VARTYPE vt;
	bool bIsGUID;
} INFO_CHILD;

typedef HRESULT (*PF_H_XIS)(PIXMLDOMNode &,
						   const IntStringValue *isVal_In, SkuSet *);

typedef HRESULT (*PF_H_XIES)(PIXMLDOMNode &, int iColumn,
							  ElementEntry *pEE, SkuSet *);

typedef struct {
	NodeIndex enumNodeIndex;
	PF_H_XIS pNodeProcessFunc;
} Node_Func_H_XIS;

typedef struct {
	NodeIndex enumNodeIndex;
	PF_H_XIES pNodeProcessFunc;
	ValType   vt; 
	int       iColumn;
} Node_Func_H_XIES;

typedef struct {
	NodeIndex enumNodeIndex;
	UINT uiBit;
} AttrBit_SKU;

typedef struct {
	LPTSTR EnumValue;
	UINT uiBit;
} EnumBit;

typedef struct {
	LPTSTR szNodeName;
	LPTSTR szAttributeName;
	bool   bIsRequired;
	UINT   uiOccurence; /* if uiOccurence = 0, this node can occur 0+ times 
							if bIsRequired=false, or 1+ times 
							if bIsRequire = true */
} NODE;
////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Global Variables
// Issue: Handles to databases and summary infos have to be associated 
//		  with SKU in the future

extern bool g_bVerbose;			
extern bool g_bValidationOnly;	
extern FILE *g_pLogFile;	

// used to store Sku groups
// Key: SkuGroupID		Value: pointer to a SkuSet object
extern map<LPTSTR, SkuSet *, Cstring_less> g_mapSkuSets;

// used to store Directory references
// Key: DirectoryID		Value: Primary key in table Directory
extern map<LPTSTR, SkuSetValues *, Cstring_less> g_mapDirectoryRefs_SKU;

// used to store InstallLevel references
// Key: InstallLevel ID		Value: numeric value of install level
extern map<LPTSTR, SkuSetValues *, Cstring_less> g_mapInstallLevelRefs_SKU;

// used to store Components
// Key: Component table primary key		Value: pointer to a Component object
extern map<LPTSTR, Component *, Cstring_less> g_mapComponents;

extern map<LPTSTR, SkuSet *, Cstring_less> g_mapFiles;

// for each table type, there is a counter that is
// incremented when each time the GetName function is called
// with that particular table name
extern map<LPTSTR, int, Cstring_less> g_mapTableCounter;


extern NODE rgXMSINodes[];

extern const int cAttrBits_TakeOwnership;
extern AttrBit_SKU rgAttrBits_TakeOwnership[];

// the array of SKU objects
extern Sku **g_rgpSkus;

// number of SKUs
extern int g_cSkus;

// the root node of the document
extern IXMLDOMNode *g_pNodeProductFamily;

////////////////////////////////////////////////////////////




#endif // XMSI_WMC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\res\sources.inc ===
!INCLUDE ..\..\MsiMake.inc
TARGETNAME=
SOURCES=
TARGETTYPE=NOTARGET
NTTARGETFILE0=ResAll
SYNCHRONIZE_BLOCK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\res\autoapi.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       autoapi.cpp
//
//--------------------------------------------------------------------------

#define TYPELIB_MAJOR_VERSION 1  // released version, not rmj
#define TYPELIB_MINOR_VERSION 0  // released version, not rmm

#ifdef RC_INVOKED
1 typelib AutoApi.tlb
#endif

#include "AutoApi.h"   // help context ID definitions, dispatch IDs
#define MAKE_VERSION(a,b) a##.##b
[
    uuid(000C1092-0000-0000-C000-000000000046), // LIBID_MsiApiTypeLib
    helpfile("Msi.CHM"),
#ifdef DEBUG
    helpstring("Microsoft Windows Installer Object Library - Debug"),
#else
    helpstring("Microsoft Windows Installer Object Library"),
#endif
    lcid(0x0409),
    version( MAKE_VERSION(TYPELIB_MAJOR_VERSION, TYPELIB_MINOR_VERSION) )
]
library WindowsInstaller
{
    importlib("stdole32.tlb");
    dispinterface Installer;
    dispinterface Record;
    dispinterface SummaryInfo;
    dispinterface Database;
    dispinterface View;
    dispinterface Session;
    dispinterface UIPreview;
    dispinterface FeatureInfo;
    dispinterface StringList;
    dispinterface RecordList;

#ifdef DEBUG
#define enumcontext(x) helpcontext(x)
#else  // save size in ship type library
#define enumcontext(x)
#define helpstring(x)
#endif

typedef enum {
    [enumcontext(HELPID_MsiRecord_IntegerData)] msiDatabaseNullInteger  = 0x80000000,
} Constants;

typedef [helpcontext(HELPID_MsiInstall_OpenDatabase), helpstring("OpenDatabase creation options")] enum {
    [enumcontext(HELPID_MsiInstall_OpenDatabase)] msiOpenDatabaseModeReadOnly     = 0,
    [enumcontext(HELPID_MsiInstall_OpenDatabase)] msiOpenDatabaseModeTransact     = 1,
    [enumcontext(HELPID_MsiInstall_OpenDatabase)] msiOpenDatabaseModeDirect       = 2,
    [enumcontext(HELPID_MsiInstall_OpenDatabase)] msiOpenDatabaseModeCreate       = 3,
    [enumcontext(HELPID_MsiInstall_OpenDatabase)] msiOpenDatabaseModeCreateDirect = 4,
    [enumcontext(HELPID_MsiInstall_OpenDatabase)] msiOpenDatabaseModePatchFile    = 32,
} MsiOpenDatabaseMode;

typedef [helpcontext(HELPID_MsiDatabase_DatabaseState), helpstring("Read-only or read-write state for database")] enum {
    [enumcontext(HELPID_MsiDatabase_DatabaseState)] msiDatabaseStateRead  = 0,
    [enumcontext(HELPID_MsiDatabase_DatabaseState)] msiDatabaseStateWrite = 1
} MsiDatabaseState;

typedef [helpcontext(HELPID_MsiView_ColumnInfo), helpstring("Column attribute to return for View.ColumnInfo")] enum {
    [enumcontext(HELPID_MsiView_ColumnInfo)] msiColumnInfoNames = 0,
    [enumcontext(HELPID_MsiView_ColumnInfo)] msiColumnInfoTypes = 1
} MsiColumnInfo;

typedef [helpcontext(HELPID_MsiRecord_ReadStream), helpstring("Conversion options for Record.ReadStream")] enum {
    [enumcontext(HELPID_MsiRecord_ReadStream)] msiReadStreamInteger = 0,
    [enumcontext(HELPID_MsiRecord_ReadStream)] msiReadStreamBytes   = 1,
    [enumcontext(HELPID_MsiRecord_ReadStream)] msiReadStreamAnsi    = 2,
    [enumcontext(HELPID_MsiRecord_ReadStream)] msiReadStreamDirect  = 3,
} MsiReadStream;

typedef [helpcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo), helpstring("Error suppression flags for Database.CreateTransformSummaryInfo")] enum {
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorNone                   = 0,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorAddExistingRow         = 1,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorDeleteNonExistingRow   = 2,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorAddExistingTable       = 4,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorDeleteNonExistingTable = 8,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorUpdateNonExistingRow   = 16,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorChangeCodePage         = 32,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformErrorViewTransform          = 256,
} MsiTransformError;

typedef [helpcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo), helpstring("Validation option flags for Database.CreateTransformSummaryInfo")] enum {
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationNone           = 0,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationLanguage       = 1,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationProduct        = 2,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationPlatform       = 4,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationMajorVer       = 8,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationMinorVer       = 16,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationUpdateVer      = 32,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationLess           = 64,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationLessOrEqual    = 128,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationEqual          = 256,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationGreaterOrEqual = 512,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationGreater        = 1024,
    [enumcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo)] msiTransformValidationUpgradeCode    = 2048,
} MsiTransformValidation;

typedef [helpcontext(HELPID_MsiView_Modify), helpstring("Operation for View.Modify")] enum {
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifySeek           =-1,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyRefresh        = 0,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyInsert         = 1,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyUpdate         = 2,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyAssign         = 3,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyReplace        = 4,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyMerge          = 5,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyDelete         = 6,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyInsertTemporary= 7,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyValidate       = 8,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyValidateNew    = 9,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyValidateField  = 10,
    [enumcontext(HELPID_MsiView_Modify)] msiViewModifyValidateDelete = 11,
} MsiViewModify;

typedef [helpcontext(HELPID_MsiEngine_EvaluateCondition), helpstring("Return status from Session.EvaluateCondition")] enum {
    [enumcontext(HELPID_MsiEngine_EvaluateCondition)] msiEvaluateConditionFalse = 0,
    [enumcontext(HELPID_MsiEngine_EvaluateCondition)] msiEvaluateConditionTrue  = 1,
    [enumcontext(HELPID_MsiEngine_EvaluateCondition)] msiEvaluateConditionNone  = 2,
    [enumcontext(HELPID_MsiEngine_EvaluateCondition)] msiEvaluateConditionError = 3
} MsiEvaluateCondition;

typedef [helpcontext(HELPID_MsiEngine_DoAction), helpstring("Return status from Session.DoAction and Session.Sequence")] enum {
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusNoAction     = 0,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusSuccess      = 1,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusUserExit     = 2,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusFailure      = 3,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusSuspend      = 4,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusFinished     = 5,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusWrongState   = 6,
    [enumcontext(HELPID_MsiEngine_DoAction)] msiDoActionStatusBadActionData= 7
} MsiDoActionStatus;

typedef [helpcontext(HELPID_MsiEngine_Message), helpstring("Session.Message types and options")] enum {
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeFatalExit       = 0x00000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeError           = 0x01000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeWarning         = 0x02000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeUser            = 0x03000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeInfo            = 0x04000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeFilesInUse      = 0x05000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeResolveSource   = 0x06000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeOutOfDiskSpace  = 0x07000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeActionStart     = 0x08000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeActionData      = 0x09000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeProgress        = 0x0A000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeCommonData      = 0x0B000000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeOk              = 0,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeOkCancel        = 1,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeAbortRetryIgnore= 2,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeYesNoCancel     = 3,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeYesNo           = 4,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeRetryCancel     = 5,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeDefault1        = 0x000,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeDefault2        = 0x100,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageTypeDefault3        = 0x200
} MsiMessageType;

typedef [helpcontext(HELPID_MsiEngine_Message), helpstring("Return codes from Session.Message")] enum {
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusError  =-1,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusNone   = 0,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusOk     = 1,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusCancel = 2,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusAbort  = 3,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusRetry  = 4,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusIgnore = 5,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusYes    = 6,
    [enumcontext(HELPID_MsiEngine_Message)] msiMessageStatusNo     = 7
} MsiMessageStatus;

typedef [helpcontext(HELPID_MsiInstallState), helpstring("Install states for products and features")] enum {
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateNotUsed      = -7,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateBadConfig    = -6,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateIncomplete   = -5,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateSourceAbsent = -4,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateInvalidArg   = -2,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateUnknown      = -1,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateBroken       =  0,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateAdvertised   =  1,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateRemoved      =  1,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateAbsent       =  2,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateLocal        =  3,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateSource       =  4,
    [enumcontext(HELPID_MsiInstallState)] msiInstallStateDefault      =  5,
} MsiInstallState;

typedef [helpcontext(HELPID_MsiReinstallMode), helpstring("Reinstall option bit flags")] enum {
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeFileMissing      = 0x0002,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeFileOlderVersion = 0x0004,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeFileEqualVersion = 0x0008,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeFileExact        = 0x0010,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeFileVerify       = 0x0020,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeFileReplace      = 0x0040,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeMachineData      = 0x0080,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeUserData         = 0x0100,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModeShortcut         = 0x0200,
    [enumcontext(HELPID_MsiReinstallMode)] msiReinstallModePackage          = 0x0400,
} MsiReinstallMode;

typedef [helpcontext(HELPID_MsiInstallMode), helpstring("Install options for ProvideComponent, UseFeature")] enum {
    [enumcontext(HELPID_MsiInstallMode)] msiInstallModeNoSourceResolution = -3,
    [enumcontext(HELPID_MsiInstallMode)] msiInstallModeNoDetection = -2,
    [enumcontext(HELPID_MsiInstallMode)] msiInstallModeExisting    = -1,
    [enumcontext(HELPID_MsiInstallMode)] msiInstallModeDefault     =  0,
} MsiInstallMode;

typedef [helpcontext(HELPID_MsiInstall_UILevel), helpstring("UI mode for installation")] enum {
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelNoChange = 0,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelDefault  = 1,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelNone     = 2,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelBasic    = 3,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelReduced  = 4,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelFull     = 5,
	[enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelHideCancel = 0x20,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelProgressOnly  = 0x40,
    [enumcontext(HELPID_MsiInstall_UILevel)] msiUILevelEndDialog= 0x80,
} MsiUILevel;

typedef [helpcontext(HELPID_MsiEngine_FeatureCost), helpstring("Extent of feature cost relative to tree")] enum {
    [enumcontext(HELPID_MsiEngine_FeatureCost)] msiCostTreeSelfOnly = 0,
    [enumcontext(HELPID_MsiEngine_FeatureCost)] msiCostTreeChildren = 1,
    [enumcontext(HELPID_MsiEngine_FeatureCost)] msiCostTreeParents  = 2,
} MsiCostTree;

typedef [helpcontext(HELPID_MsiInstall_ApplyPatch), helpstring("Type of image to patch")] enum {
    [enumcontext(HELPID_MsiInstall_ApplyPatch)] msiInstallTypeDefault      = 0,
    [enumcontext(HELPID_MsiInstall_ApplyPatch)] msiInstallTypeNetworkImage = 1,
}MsiInstallType;

typedef [helpcontext(HELPID_MsiEngine_Mode), helpstring("Install session mode bits")] enum {
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeAdmin           =  0,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeAdvertise       =  1,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeMaintenance     =  2,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeRollbackEnabled =  3,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeLogEnabled      =  4,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeOperations      =  5,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeRebootAtEnd     =  6,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeRebootNow       =  7,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeCabinet         =  8,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeSourceShortNames=  9,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeTargetShortNames= 10,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeWindows9x       = 12,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeZawEnabled      = 13,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeScheduled       = 16,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeRollback        = 17,
    [enumcontext(HELPID_MsiEngine_Mode)] msiRunModeCommit          = 18,
}MsiRunMode;

typedef [helpcontext(HELPID_MsiInstall_FileSignatureInfo), helpstring("FileSignatureInfo Error flags")] enum {
	[enumcontext(HELPID_MsiInstall_FileSignatureInfo)] msiSignatureOptionInvalidHashFatal = 1,
}MsiSignatureOption;

typedef [helpcontext(HELPID_MsiInstall_FileSignatureInfo), helpstring("FileSignatureInfo format type")] enum {
	[enumcontext(HELPID_MsiInstall_FileSignatureInfo)] msiSignatureInfoCertificate = 0,
	[enumcontext(HELPID_MsiInstall_FileSignatureInfo)] msiSignatureInfoHash        = 1,
}MsiSignatureInfo;

    [
        uuid(000C1090-0000-0000-C000-000000000046),  // IID_IMsiApiInstall
        helpcontext(HELPID_MsiInstall_Object), helpstring("Top-level Windows Installer object")
    ]
    dispinterface Installer
    {
        properties:
            [id(DISPID_MsiInstall_UILevel), helpcontext(HELPID_MsiInstall_UILevel), helpstring("The UI level used to open a package")]
                MsiUILevel UILevel;
        methods:
            [id(DISPID_MsiInstall_CreateRecord), helpcontext(HELPID_MsiInstall_CreateRecord), helpstring("Creates a cleared record object")]
                Record* CreateRecord([in] long Count);
            [id(DISPID_MsiInstall_OpenPackage), helpcontext(HELPID_MsiInstall_OpenPackage), helpstring("Creates an installer instance from a package path")]
                Session* OpenPackage([in] variant PackagePath);
            [id(DISPID_MsiInstall_OpenProduct), helpcontext(HELPID_MsiInstall_OpenProduct), helpstring("Creates an installer instance from a product code")]
                Session* OpenProduct([in] BSTR ProductCode);
            [id(DISPID_MsiInstall_OpenDatabase), helpcontext(HELPID_MsiInstall_OpenDatabase), helpstring("Creates a database object from a file path")]
                Database* OpenDatabase([in] BSTR DatabasePath, [in] variant OpenMode);
            [id(DISPID_MsiInstall_SummaryInformation), propget, helpcontext(HELPID_MsiInstall_SummaryInformation), helpstring("Returns the summary information object for a database or transform")]
                SummaryInfo* SummaryInformation([in] BSTR PackagePath, [in, defaultvalue(0)] long UpdateCount);
            [id(DISPID_MsiInstall_EnableLog), helpcontext(HELPID_MsiInstall_EnableLog), helpstring("Set the logging mode and file")]
                void EnableLog([in] BSTR LogMode, [in] BSTR LogFile);
            [id(DISPID_MsiInstall_InstallProduct), helpcontext(HELPID_MsiInstall_InstallProduct), helpstring("Installs a new package")]
                void InstallProduct([in] BSTR PackagePath, [in, defaultvalue(0)] BSTR PropertyValues);
            [id(DISPID_MsiInstall_Version), propget, helpcontext(HELPID_MsiInstall_Version), helpstring("The MSI build version string")]
                BSTR Version();
            [id(DISPID_MsiInstall_LastErrorRecord), helpcontext(HELPID_MsiInstall_LastErrorRecord), helpstring("Returns last cached error record object")]
                Record* LastErrorRecord();
            [id(DISPID_MsiInstall_RegistryValue), helpcontext(HELPID_MsiInstall_RegistryValue), helpstring("Returns a value from the registry")]
                BSTR RegistryValue([in] variant Root, [in] BSTR Key, [in, optional] VARIANT Value);
            [id(DISPID_MsiInstall_FileAttributes), helpcontext(HELPID_MsiInstall_FileAttributes), helpstring("Returns file attributes for path")]
                long FileAttributes([in] BSTR FilePath);
            [id(DISPID_MsiInstall_FileSize), helpcontext(HELPID_MsiInstall_FileSize), helpstring("Returns file size for path")]
                long FileSize([in] BSTR FilePath);
            [id(DISPID_MsiInstall_FileVersion), helpcontext(HELPID_MsiInstall_FileVersion), helpstring("Returns file version or languages for path")]
                BSTR FileVersion([in] BSTR FilePath, [in, optional] VARIANT Language);
            [id(DISPID_MsiInstall_Environment), propget, helpcontext(HELPID_MsiInstall_Environment), helpstring("The value of an environment variable")]
                BSTR Environment([in] BSTR Variable);
            [id(DISPID_MsiInstall_Environment), propput]
                void Environment([in] BSTR Variable, [in] BSTR Value);
            [id(DISPID_MsiInstall_ProductState), propget, helpcontext(HELPID_MsiInstall_ProductState), helpstring("Current installed state the product")]
                MsiInstallState ProductState([in] BSTR Product);
            [id(DISPID_MsiInstall_ProductInfo), propget, helpcontext(HELPID_MsiInstall_ProductInfo), helpstring("Value for specified registered product attribute")]
                BSTR ProductInfo([in] BSTR Product, [in] BSTR Attribute);
            [id(DISPID_MsiInstall_ConfigureProduct), helpcontext(HELPID_MsiInstall_ConfigureProduct), helpstring("Alters the installed state for the product")]
                void ConfigureProduct([in] BSTR Product, [in] long InstallLevel, [in] MsiInstallState InstallState);
            [id(DISPID_MsiInstall_ReinstallProduct), helpcontext(HELPID_MsiInstall_ReinstallProduct), helpstring("Reinstalls the product in various modes")]
                void ReinstallProduct([in] BSTR Product, [in] MsiReinstallMode ReinstallMode);
            [id(DISPID_MsiInstall_CollectUserInfo), helpcontext(HELPID_MsiInstall_CollectUserInfo), helpstring("Runs a product action (dialog) that requests user information")]
                void CollectUserInfo([in] BSTR Product);
            [id(DISPID_MsiInstall_ApplyPatch), helpcontext(HELPID_MsiInstall_ApplyPatch), helpstring("Applies a patch to the product")]
                void ApplyPatch([in] BSTR PatchPackage, [in] BSTR InstallPackage, [in] MsiInstallType InstallType, [in] BSTR CommandLine);
            [id(DISPID_MsiInstall_FeatureParent), propget, helpcontext(HELPID_MsiInstall_FeatureParent), helpstring("The parent feature for the specified feature")]
                BSTR FeatureParent([in] BSTR Product, [in] BSTR Feature);
            [id(DISPID_MsiInstall_FeatureState), propget, helpcontext(HELPID_MsiInstall_FeatureState), helpstring("The installed state for the specified feature")]
                MsiInstallState FeatureState([in] BSTR Product, [in] BSTR Feature);
            [id(DISPID_MsiInstall_UseFeature), helpcontext(HELPID_MsiInstall_UseFeature), helpstring("Insures feature is present, bumps usage count")]
                void UseFeature([in] BSTR Product, [in] BSTR Feature, [in] MsiInstallMode InstallMode);
            [id(DISPID_MsiInstall_FeatureUsageCount), propget, helpcontext(HELPID_MsiInstall_FeatureUsageCount), helpstring("Usage count for specified feature")]
                long FeatureUsageCount([in] BSTR Product, [in] BSTR Feature);
            [id(DISPID_MsiInstall_FeatureUsageDate), propget, helpcontext(HELPID_MsiInstall_FeatureUsageDate), helpstring("Last used date for specified feature")]
                date FeatureUsageDate([in] BSTR Product, [in] BSTR Feature);
            [id(DISPID_MsiInstall_ConfigureFeature), helpcontext(HELPID_MsiInstall_ConfigureFeature), helpstring("Alters the installed state for a feature")]
                void ConfigureFeature([in] BSTR Product, [in] BSTR Feature, [in] MsiInstallState InstallState);
            [id(DISPID_MsiInstall_ReinstallFeature), helpcontext(HELPID_MsiInstall_ReinstallFeature), helpstring("Reinstalls a specified feature")]
                void ReinstallFeature([in] BSTR Product, [in] BSTR Feature, [in] MsiReinstallMode ReinstallMode);
            [id(DISPID_MsiInstall_ProvideComponent), helpcontext(HELPID_MsiInstall_ProvideComponent), helpstring("Insures a feature to be present, returns component path")]
                BSTR ProvideComponent([in] BSTR Product, [in] BSTR Feature, [in] BSTR Component, [in] long InstallMode);
            [id(DISPID_MsiInstall_ComponentPath), propget, helpcontext(HELPID_MsiInstall_ComponentPath), helpstring("Returns the path for a specified component for a specified product")]
                BSTR ComponentPath([in] BSTR Product, [in] BSTR Component);
            [id(DISPID_MsiInstall_ProvideQualifiedComponent), helpcontext(HELPID_MsiInstall_ProvideQualifiedComponent), helpstring("Returns path to a componentn, specified by a category and qualifier, installing as necessary")]
                BSTR ProvideQualifiedComponent([in] BSTR Category, [in] BSTR Qualifier, [in] long InstallMode);
            [id(DISPID_MsiInstall_QualifierDescription), propget, helpcontext(HELPID_MsiInstall_QualifierDescription), helpstring("Descriptive text for a give qualifier")]
                BSTR QualifierDescription([in] BSTR Category, [in] BSTR Qualifier);
            [id(DISPID_MsiInstall_ComponentQualifiers), propget, helpcontext(HELPID_MsiInstall_ComponentQualifiers), helpstring("The set of registered qualifiers for a category")]
                StringList* ComponentQualifiers([in] BSTR Category);
            [id(DISPID_MsiInstall_Products), propget, helpcontext(HELPID_MsiInstall_Products), helpstring("The set of registered products, user + machine")]
                StringList* Products();
            [id(DISPID_MsiInstall_Features), propget, helpcontext(HELPID_MsiInstall_Features), helpstring("The set of registered features for a product")]
                StringList* Features([in] BSTR Product);
            [id(DISPID_MsiInstall_Components), propget, helpcontext(HELPID_MsiInstall_Components), helpstring("The set of registered components for the system")]
                StringList* Components();
            [id(DISPID_MsiInstall_ComponentClients), propget, helpcontext(HELPID_MsiInstall_ComponentClients), helpstring("The set of products that have installed the component")]
                StringList* ComponentClients([in] BSTR Component);
            [id(DISPID_MsiInstall_Patches), propget, helpcontext(HELPID_MsiInstall_Patches), helpstring("The set of patches applied to the product")]
                StringList* Patches([in] BSTR Product);
            [id(DISPID_MsiInstall_RelatedProducts), propget, helpcontext(HELPID_MsiInstall_RelatedProducts), helpstring("The set of related products")]
                StringList* RelatedProducts([in] BSTR UpgradeCode);
            [id(DISPID_MsiInstall_PatchInfo), propget, helpcontext(HELPID_MsiInstall_PatchInfo), helpstring("Returns the value for specified registered patch attribute")]
                BSTR PatchInfo([in] BSTR Patch, [in] BSTR Attribute);
            [id(DISPID_MsiInstall_PatchTransforms), propget, helpcontext(HELPID_MsiInstall_PatchTransforms), helpstring("Returns the list of transforms applied for patch")]
                BSTR PatchTransforms([in] BSTR Product, [in] BSTR Patch);
            [id(DISPID_MsiInstall_AddSource), helpcontext(HELPID_MsiInstall_AddSource), helpstring("Adds a source to the list of valid network sources for the product")]
                void AddSource([in] BSTR Product, [in] BSTR User, [in] BSTR Source);
            [id(DISPID_MsiInstall_ClearSourceList), helpcontext(HELPID_MsiInstall_ClearSourceList), helpstring("Removes all network sources from the list")]
                void ClearSourceList([in] BSTR Product, [in] BSTR User);
            [id(DISPID_MsiInstall_ForceSourceListResolution), helpcontext(HELPID_MsiInstall_ForceSourceListResolution),
                helpstring("Forces the installer to use the source resiliency system for the product the next time a source for the install is needed")]
                void ForceSourceListResolution([in] BSTR Product, [in] BSTR User);
            [id(DISPID_MsiInstall_GetShortcutTarget), propget, helpcontext(HELPID_MsiInstall_GetShortcutTarget),
                helpstring("Retrieves product code, feature id, and component code if available from a shortcut")]
                Record* GetShortcutTarget([in] BSTR ShortcutPath);
            [id(DISPID_MsiInstall_FileHash), helpcontext(HELPID_MsiInstall_FileHash), helpstring("Returns 128-bit hash for path, stored in a 4-field Record")]
                Record* FileHash([in] BSTR FilePath, [in] long Options);
            [id(DISPID_MsiInstall_FileSignatureInfo), helpcontext(HELPID_MsiInstall_FileSignatureInfo), helpstring("Returns the encoded signer certificate or hash of a digitally signed file")]
                SAFEARRAY(unsigned char) FileSignatureInfo([in] BSTR FilePath, [in] long Options, [in] MsiSignatureInfo Format);
    };

    [
        uuid(000C1093-0000-0000-C000-000000000046),  // IID_IMsiApiRecord
        helpcontext(HELPID_MsiRecord_Object), helpstring("Object holding a set of values")
    ]
    dispinterface Record
    {
        properties:
        methods:
            [id(DISPID_MsiRecord_StringData), propget, helpcontext(HELPID_MsiRecord_StringData), helpstring("The string value of the indexed field")]
                BSTR StringData([in] long Field);
            [id(DISPID_MsiRecord_StringData), propput]
                void StringData([in] long Field, [in] BSTR Value);
            [id(DISPID_MsiRecord_IntegerData), propget, helpcontext(HELPID_MsiRecord_IntegerData), helpstring("The integer value of the indexed field")]
                long IntegerData([in] long Field);
            [id(DISPID_MsiRecord_IntegerData), propput]
                void IntegerData([in] long Field, [in] long Value);
            [id(DISPID_MsiRecord_SetStream), helpcontext(HELPID_MsiRecord_SetStream), helpstring("Copies a file into indicated field")]
                void SetStream([in] long Field, [in] BSTR FilePath);
            [id(DISPID_MsiRecord_ReadStream), helpcontext(HELPID_MsiRecord_ReadStream), helpstring("Copies bytes from a stream as a string")]
                BSTR ReadStream([in] long Field, [in] long Length, [in] MsiReadStream Format);
            [id(DISPID_MsiRecord_FieldCount), propget, helpcontext(HELPID_MsiRecord_FieldCount), helpstring("Number of fields in record")]
                long FieldCount();
            [id(DISPID_MsiRecord_IsNull), propget, helpcontext(HELPID_MsiRecord_IsNull), helpstring("True if indexed field contains a null value")]
                boolean IsNull([in] long Field);
            [id(DISPID_MsiRecord_DataSize), propget, helpcontext(HELPID_MsiRecord_DataSize), helpstring("Size in bytes of data for indicated field")]
                long DataSize([in] long Field);
            [id(DISPID_MsiRecord_ClearData), helpcontext(HELPID_MsiRecord_ClearData), helpstring("Clears all fields in record")]
                void ClearData();
            [id(DISPID_MsiRecord_FormatText), helpcontext(HELPID_MsiRecord_FormatText), helpstring("Format fields according to template in field 0")]
                BSTR FormatText();
    };

    [
        uuid(000C109D-0000-0000-C000-000000000046),  // IID_IMsiApiDatabase
        helpcontext(HELPID_MsiDatabase_Object), helpstring("Opened database object")
    ]
    dispinterface Database
    {
        properties:
        methods:
            [id(DISPID_MsiDatabase_DatabaseState), propget, helpcontext(HELPID_MsiDatabase_DatabaseState), helpstring("Returns the update state of the database")]
                MsiDatabaseState DatabaseState();
            [id(DISPID_MsiDatabase_SummaryInformation), propget, helpcontext(HELPID_MsiDatabase_SummaryInformation), helpstring("Returns the summary information object for the database")]
                SummaryInfo* SummaryInformation([in, defaultvalue(0)] long UpdateCount);
            [id(DISPID_MsiDatabase_OpenView), helpcontext(HELPID_MsiDatabase_OpenView), helpstring("Opens a view using a SQL string")]
                View* OpenView([in] BSTR Sql);
            [id(DISPID_MsiDatabase_Commit), helpcontext(HELPID_MsiDatabase_Commit), helpstring("Commits the database to persistent storage")]
                void Commit();
            [id(DISPID_MsiDatabase_PrimaryKeys), propget, helpcontext(HELPID_MsiDatabase_PrimaryKeys), helpstring("Returns a record contining the primary key names")]
                Record* PrimaryKeys([in] BSTR Table);
            [id(DISPID_MsiDatabase_Import), helpcontext(HELPID_MsiDatabase_Import), helpstring("Imports an archived table to the database")]
                void Import([in] BSTR Folder, [in] BSTR File);
            [id(DISPID_MsiDatabase_Export), helpcontext(HELPID_MsiDatabase_Export), helpstring("Exports a table to an archive file")]
                void Export([in] BSTR Table, [in] BSTR Folder, [in] BSTR File);
            [id(DISPID_MsiDatabase_Merge), helpcontext(HELPID_MsiDatabase_Merge), helpstring("Merges another database")]
                boolean Merge([in] Database* Database, [in, defaultvalue(0)] BSTR ErrorTable);
            [id(DISPID_MsiDatabase_GenerateTransform), helpcontext(HELPID_MsiDatabase_GenerateTransform), helpstring("Generates a transform using a reference database")]
                boolean GenerateTransform([in] Database* ReferenceDatabase, [in, defaultvalue(0)] BSTR TransformFile);
            [id(DISPID_MsiDatabase_ApplyTransform), helpcontext(HELPID_MsiDatabase_ApplyTransform), helpstring("Applies a transform to the database")]
                void ApplyTransform([in] BSTR TransformFile, [in] MsiTransformError ErrorConditions);
            [id(DISPID_MsiDatabase_EnableUIPreview), helpcontext(HELPID_MsiDatabase_EnableUIPreview), helpstring("Enables preview of UI dialogs and billboards")]
                UIPreview* EnableUIPreview();
            [id(DISPID_MsiDatabase_TablePersistent), propget, helpcontext(HELPID_MsiDatabase_TablePersistent), helpstring("Returns the persistent state of the table")]
                MsiEvaluateCondition TablePersistent([in] BSTR Table);
            [id(DISPID_MsiDatabase_CreateTransformSummaryInfo), helpcontext(HELPID_MsiDatabase_CreateTransformSummaryInfo), helpstring("Creates transform summary information stream")]
                void CreateTransformSummaryInfo([in] Database* ReferenceDatabase, [in] BSTR TransformFile, [in] MsiTransformError ErrorConditions, [in] MsiTransformValidation Validation);
    };

    [
        uuid(000C109C-0000-0000-C000-000000000046),  // IID_IMsiApiView
        helpcontext(HELPID_MsiView_Object), helpstring("Opened database view object")
    ]
    dispinterface View
    {
        properties:
        methods:
            [id(DISPID_MsiView_Execute), helpcontext(HELPID_MsiView_Execute), helpstring("Executes the query with optional parameters")]
                void Execute([in, defaultvalue(0)] Record* Params);
            [id(DISPID_MsiView_Fetch), helpcontext(HELPID_MsiView_Fetch), helpstring("Fetches a record")]
                Record* Fetch();
            [id(DISPID_MsiView_Modify), helpcontext(HELPID_MsiView_Modify), helpstring("Modifies or validate the view data")]
                void Modify([in] MsiViewModify Mode, Record* Record);
            [id(DISPID_MsiView_ColumnInfo), propget, helpcontext(HELPID_MsiView_ColumnInfo), helpstring("Fetches column names or definitions")]
                Record* ColumnInfo([in] MsiColumnInfo Info);
            [id(DISPID_MsiView_Close), helpcontext(HELPID_MsiView_Close), helpstring("Closes the open view")]
                void Close();
            [id(DISPID_MsiView_GetError), helpcontext(HELPID_MsiView_GetError), helpstring("Gets the next validation column error")]
                BSTR GetError();
    };

    [
        uuid(000C109B-0000-0000-C000-000000000046),  // IID_IMsiApiSummaryInfo
        helpcontext(HELPID_MsiSummaryInfo_Object), helpstring("Object accessing database summary information stream")
    ]
    dispinterface SummaryInfo
    {
        properties:
        methods:
            [id(DISPID_MsiSummaryInfo_Property), propget, helpcontext(HELPID_MsiSummaryInfo_Property), helpstring("Property")]
                variant Property([in] long Pid);
            [id(DISPID_MsiSummaryInfo_Property), propput]
                void Property([in] long Pid, [in] variant Value);
            [id(DISPID_MsiSummaryInfo_PropertyCount), propget, helpcontext(HELPID_MsiSummaryInfo_PropertyCount), helpstring("PropertyCount")]
                long PropertyCount();
            [id(DISPID_MsiSummaryInfo_Persist), helpcontext(HELPID_MsiSummaryInfo_Persist), helpstring("Persist      ")]
                void Persist();
    };

    [
        uuid(000C109A-0000-0000-C000-000000000046),  // IID_IMsiApiUIPreview
        helpcontext(HELPID_MsiUIPreview_Object), helpstring("Object allowing dialogs to be viewed")
    ]
    dispinterface UIPreview
    {
        properties:
        methods:
            [id(DISPID_MsiUIPreview_Property), propget, helpcontext(HELPID_MsiEngine_Property), helpstring("The string value of the indicated property")]
                BSTR Property([in] BSTR Name);
            [id(DISPID_MsiUIPreview_Property), propput]
                void Property([in] BSTR Name, [in] BSTR Value);
            [id(DISPID_MsiUIPreview_ViewDialog), helpcontext(HELPID_MsiUIPreview_ViewDialog   ), helpstring("Displays a UI Dialog")]
                void ViewDialog([in] BSTR Dialog);
            [id(DISPID_MsiUIPreview_ViewBillboard), helpcontext(HELPID_MsiUIPreview_ViewBillboard), helpstring("Displays a UI Billboard")]
                void ViewBillboard([in] BSTR Control, [in] BSTR Billboard);
    };

    [
        uuid(000C109E-0000-0000-C000-000000000046),  // IID_IMsiApiEngine
        helpcontext(HELPID_MsiEngine_Object), helpstring("Active install session object")
    ]
    dispinterface Session
    {
        properties:
        methods:
            [id(DISPID_MsiEngine_Application), propget, helpcontext(HELPID_MsiEngine_Application), helpstring("The installer object")]
                Installer* Installer();
            [id(DISPID_MsiEngine_Property), propget, helpcontext(HELPID_MsiEngine_Property), helpstring("The string value of the indicated property")]
                BSTR Property([in] BSTR Name);
            [id(DISPID_MsiEngine_Property), propput]
                void Property([in] BSTR Name, [in] BSTR Value);
            [id(DISPID_MsiEngine_Language), propget, helpcontext(HELPID_MsiEngine_Language), helpstring("The language ID used by the current install")]
                long Language();
            [id(DISPID_MsiEngine_Mode), propget, helpcontext(HELPID_MsiEngine_Mode), helpstring("The boolean value of the indicated mode flag")]
                boolean Mode([in] MsiRunMode Flag);
            [id(DISPID_MsiEngine_Mode), propput]
                void Mode([in] MsiRunMode Flag, [in] boolean Value);
            [id(DISPID_MsiEngine_Database), propget, helpcontext(HELPID_MsiEngine_Database), helpstring("Returns the active database")]
                Database* Database();
            [id(DISPID_MsiEngine_SourcePath), propget, helpcontext(HELPID_MsiEngine_SourcePath), helpstring("The source path for a folder")]
                BSTR SourcePath([in] BSTR Folder);
            [id(DISPID_MsiEngine_TargetPath), propget, helpcontext(HELPID_MsiEngine_TargetPath), helpstring("The target path for a folder")]
                BSTR TargetPath([in] BSTR Folder);
            [id(DISPID_MsiEngine_TargetPath), propput]
                void TargetPath([in] BSTR Folder, [in] BSTR Path);
            [id(DISPID_MsiEngine_DoAction), helpcontext(HELPID_MsiEngine_DoAction), helpstring("Performs indicated action")]
                MsiDoActionStatus DoAction([in] BSTR Action);
            [id(DISPID_MsiEngine_Sequence), helpcontext(HELPID_MsiEngine_Sequence), helpstring("Executes actions in a sequence table")]
                MsiDoActionStatus Sequence([in] BSTR Table, [in, optional] VARIANT Mode);
            [id(DISPID_MsiEngine_EvaluateCondition), helpcontext(HELPID_MsiEngine_EvaluateCondition), helpstring("Evaluates a conditional expression")]
                MsiEvaluateCondition EvaluateCondition([in] BSTR Expression);
            [id(DISPID_MsiEngine_FormatRecord), helpcontext(HELPID_MsiEngine_FormatRecord), helpstring("Formats record data with a template string")]
                BSTR FormatRecord([in] Record* Record);
            [id(DISPID_MsiEngine_Message), helpcontext(HELPID_MsiEngine_Message), helpstring("Processes and dispatches a message record")]
                MsiMessageStatus Message([in] MsiMessageType Kind, [in] Record* Record);
            [id(DISPID_MsiEngine_FeatureCurrentState), propget, helpcontext(HELPID_MsiEngine_FeatureCurrentState), helpstring("The current installed state for a feature")]
                MsiInstallState FeatureCurrentState([in] BSTR Feature);
            [id(DISPID_MsiEngine_FeatureRequestState), propget, helpcontext(HELPID_MsiEngine_FeatureRequestState), helpstring("The requested installed state for a feature")]
                MsiInstallState FeatureRequestState([in] BSTR Feature);
            [id(DISPID_MsiEngine_FeatureRequestState), propput]
                void FeatureRequestState([in] BSTR Feature, [in] MsiInstallState State);
            [id(DISPID_MsiEngine_FeatureValidStates), propget, helpcontext(HELPID_MsiEngine_FeatureValidStates), helpstring("The permitted installed states for a feature")]
                long FeatureValidStates([in] BSTR Feature);
            [id(DISPID_MsiEngine_FeatureCost), propget, helpcontext(HELPID_MsiEngine_FeatureCost), helpstring("The disk space cost for a feature")]
                long FeatureCost([in] BSTR Feature, [in] MsiCostTree CostTree, [in] MsiInstallState State);
            [id(DISPID_MsiEngine_ComponentCurrentState), propget, helpcontext(HELPID_MsiEngine_ComponentCurrentState), helpstring("The current installed state for a component")]
                MsiInstallState ComponentCurrentState([in] BSTR Component);
            [id(DISPID_MsiEngine_ComponentRequestState), propget, helpcontext(HELPID_MsiEngine_ComponentRequestState), helpstring("The requested installed state for a component")]
                MsiInstallState ComponentRequestState([in] BSTR Component);
            [id(DISPID_MsiEngine_ComponentRequestState), propput]
                void ComponentRequestState([in] BSTR Component, [in] MsiInstallState State);
            [id(DISPID_MsiEngine_SetInstallLevel), helpcontext(HELPID_MsiEngine_SetInstallLevel), helpstring("Sets the install level for a new product")]
                void SetInstallLevel([in] long Level);
            [id(DISPID_MsiEngine_VerifyDiskSpace), propget, helpcontext(HELPID_MsiEngine_VerifyDiskSpace), helpstring("Whether sufficient disk space exists for the current install")]
                boolean VerifyDiskSpace();
            [id(DISPID_MsiEngine_ProductProperty), propget, helpcontext(HELPID_MsiEngine_ProductProperty), helpstring("Specified property value from an opened product")]
                BSTR ProductProperty([in] BSTR Property);
            [id(DISPID_MsiEngine_FeatureInfo), propget, helpcontext(HELPID_MsiEngine_FeatureInfo), helpstring("Object containing information for specified product feature")]
                FeatureInfo* FeatureInfo([in] BSTR Feature);
            [id(DISPID_MsiEngine_ComponentCosts), propget, helpcontext(HELPID_MsiEngine_ComponentCosts), helpstring("The set of record objects that hold information on volume names, costs and temporary costs")]
                RecordList* ComponentCosts([in] BSTR Component, [in] MsiInstallState State);
    };

    [
        uuid(000C109F-0000-0000-C000-000000000046),  // IID_IMsiApiFeatureInfo
        helpcontext(HELPID_MsiFeatureInfo_Object), helpstring("Feature attributes from Session.FeatureInfo")
    ]
    dispinterface FeatureInfo
    {
        properties:
            [id(DISPID_MsiFeatureInfo_Attributes), helpcontext(HELPID_MsiFeatureInfo_Attributes), helpstring("Installation option bits for feature")]
                long Attributes;
        methods:
            [id(DISPID_MsiFeatureInfo_Title)      , propget, helpcontext(HELPID_MsiFeatureInfo_Title), helpstring("Short title for feature, key")]
                BSTR Title();
            [id(DISPID_MsiFeatureInfo_Description), propget, helpcontext(HELPID_MsiFeatureInfo_Description), helpstring("Description of feature, localized")]
                BSTR Description();

    };

    [
        uuid(000C1095-0000-0000-C000-000000000046),  // IID_IMsiApiCollection
        helpcontext(HELPID_MsiCollection_Object), helpstring("Collection of string installer registration data")
    ]
    dispinterface StringList
    {
        properties:
        methods:
            [id(DISPID_NEWENUM)      ]
                IUnknown* _NewEnum();
            [id(DISPID_VALUE), propget, helpcontext(HELPID_MsiCollection_Item)]
                BSTR Item(long Index);
            [id(DISPID_MsiCollection_Count), propget, helpcontext(HELPID_MsiCollection_Count)]
                long Count();
    };

    [
        uuid(000C1096-0000-0000-C000-000000000046),  // iidMsiRecordCollection
        helpcontext(HELPID_MsiRecordCollection_Object), helpstring("Collection of record data")
    ]
    dispinterface RecordList
    {
        properties:
        methods:
            [id(DISPID_NEWENUM)      ]
                IUnknown* _NewEnum();
            [id(DISPID_VALUE), propget, helpcontext(HELPID_MsiCollection_Item)]
                RECORD* Item(long Index);
            [id(DISPID_MsiCollection_Count), propget, helpcontext(HELPID_MsiCollection_Count)]
                long Count();
    };

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\msitools\xmsi\utilities.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 2000
//
//  File:       Utilities.h
//              
//				Utility functions
//--------------------------------------------------------------------------

#ifndef XMSI_UTILITIES_H
#define XMSI_UTILITIES_H

#include "wmc.h"

////////////////////////////////////////////////////////////////////////////
//	Free the memory used by the global data structures
////////////////////////////////////////////////////////////////////////////
void CleanUp();

////////////////////////////////////////////////////////////////////////////
//	Commit changes made to the DB. Final step for the compiler
////////////////////////////////////////////////////////////////////////////
UINT CommitChanges();

////////////////////////////////////////////////////////////////////////////
//	Dynamically generate a GUID
////////////////////////////////////////////////////////////////////////////
HRESULT GeneratePackageCode(MSIHANDLE hSummaryInfo);

////////////////////////////////////////////////////////////////////////////
//  Given a Sku filter string, return the SkuSet that represents the result
//		Sku Group.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessSkuFilter(LPTSTR szInputSkuFilter, SkuSet **ppskuSet);

////////////////////////////////////////////////////////////////////////////
// GetSkuSet
//    Given a node:
//		1) Get the Sku Filter specified with the node;
//		2) Process the filter and get the result SkuSet;
//		3) Return the SkuSet via ppskuSet;
////////////////////////////////////////////////////////////////////////////
HRESULT GetSkuSet(PIXMLDOMNode &pNode, SkuSet **ppskuSet);

////////////////////////////////////////////////////////////////////////////
// ProcessAttribute
//    Given a parent node, an attribute name and an attribute type (int or
//	  string),  this function returns the string value of the attribute 
//	  via isVal. If the attribute doesn't exist, value returned will be
//	  NULL if vt = STRING, or 0 if vt = INTEGER
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessAttribute(PIXMLDOMNode &pNodeParent, LPCTSTR szAttributeName,
						 ValType vt, IntStringValue *isVal, 
						 const SkuSet *pskuSet);

////////////////////////////////////////////////////////////////////////////
//   Process nodes with Short attribute and long attribute and form a C-style 
//   string: Short|Long
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessShortLong_SKU(PIXMLDOMNode &pNode, IntStringValue *pIsValOut,
							 SkuSet *pSkuSet);

////////////////////////////////////////////////////////////////////////////
// Process the On/Off entities which set certain bit in a attribute
// value. 
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessOnOffAttributes_SKU(PIXMLDOMNode &pNodeParent, 
								   AttrBit_SKU *rgAttrBits,
								   UINT cAttrBits, 
								   ElementEntry *pEE, int iColumn,
								   SkuSet *pSkuSet);

HRESULT ProcessSimpleElement(PIXMLDOMNode &pNode, int iColumn, 
							 ElementEntry *pEE, SkuSet *pSkuSet);

HRESULT ProcessRefElement(PIXMLDOMNode &pNodeRef,  int iColumn, 
 						  ElementEntry *pEE, SkuSet *pSkuSet);

////////////////////////////////////////////////////////////////////////////
// Process KeyPath attribute of an element
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessKeyPath(PIXMLDOMNode &pNode, LPTSTR szComponent, 
					   LPTSTR szKeyPath, SkuSet *pSkuSet);

////////////////////////////////////////////////////////////////////////////
// Function: ProcessEnumAttributes
//		This function processes a single element which can take a value of 
//		among an enumeration that corresponds to certain bits in a bit field.
//		(Attributes of Component, File, etc.)
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessEnumAttributes(PIXMLDOMNode &pNodeParent, 
								  NodeIndex ni, EnumBit *rgEnumBits,
								  UINT cEnumBits, ElementEntry *pEE, 
								  int iColumn, SkuSet *pSkuSet);

////////////////////////////////////////////////////////////////////////////
//   Given a parent node and a child node name, this function finds all the
//   children node of that name and sequentially process them using the 
//   function passed in.
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenList_SKU(PIXMLDOMNode &pNodeParent, 
								NodeIndex niChild, bool bIsRequired,
								IntStringValue isVal, 
								HRESULT (*ProcessFunc)
									(PIXMLDOMNode &, IntStringValue isVal, 
										SkuSet *pSkuSet), 
								SkuSet *pSkuSet);

HRESULT ProcessChildrenList_SKU(PIXMLDOMNode &pNodeParent, 
								NodeIndex niChild, bool bIsRequired,
								IntStringValue isVal, 
								HRESULT (*ProcessFunc)
									(PIXMLDOMNode &, IntStringValue isVal, 
										SkuSet *pSkuSet), 
								SkuSet *pSkuSet, SkuSet *pSkuSetCheck);

HRESULT ProcessChildrenList_SKU(PIXMLDOMNode &pNodeParent, 
								NodeIndex niChild, bool bIsRequired,
								FOM *pFOM, SkuSetValues *pSkuSetValues, 
								HRESULT (*ProcessFunc)
									(PIXMLDOMNode &, FOM *pFOM, 
									 SkuSetValues *pSkuSetValues, 
									 SkuSet *pSkuSet), 
								SkuSet *pSkuSet, SkuSet *pSkuSetCheck);

////////////////////////////////////////////////////////////////////////////
//   Given a parent node(<ProductFamily> or <Information>) and an array of 
//	 nodeFuncs, this function loops through the array and sequentially process 
//   them using the functions given in the array
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenArray_H_XIS(PIXMLDOMNode &pNodeParent, 
								 Node_Func_H_XIS *rgNodeFuncs, UINT cNodeFuncs,
								 const IntStringValue *isVal_In,
								 SkuSet *pskuSet);

////////////////////////////////////////////////////////////////////////////
// Function: ProcessChildrenArray_H_XIES
//   Given a parent node(<Feature> <Component> <File>) and an array of 
//	 nodeFuncs, this function loops through the array and sequentially process 
//   them using the functions given in the array
////////////////////////////////////////////////////////////////////////////
HRESULT ProcessChildrenArray_H_XIES(PIXMLDOMNode &pNodeParent, 
									Node_Func_H_XIES *rgNodeFuncs,
									UINT cNodeFuncs, 
									ElementEntry *pEE,
									SkuSet *pskuSet);


////////////////////////////////////////////////////////////////////////////
// Helper function: Insert a record into the specified table in the database
//				    This function will either perform insertion for a set
//					of Skus or just for a single Sku, depending on whether
//					pskuSet == NULL or not.
////////////////////////////////////////////////////////////////////////////
HRESULT InsertDBTable_SKU(LPTSTR szTable, PMSIHANDLE &hRec, SkuSet *pskuSet,
						  int iSkuIndex);

//////////////////////////////////////////////////////////////////////////////
//Functions that insert into a certain type of DB table
HRESULT InsertProperty(LPCTSTR szProperty, LPCTSTR szValue, SkuSet *pskuSet,
					   int iSkuIndex);

HRESULT InsertDirectory(LPCTSTR szDirectory, LPCTSTR szDirectory_Parent, 
						LPCTSTR szDefaultDir, SkuSet *pSkuSet, int iSkuIndex);
HRESULT InsertFeature(LPCTSTR szFeature, LPCTSTR szFeatureParent, 
					  LPCTSTR szTitle, LPCTSTR szDescription, int iDisplay, 
					  int iInstallLevel, LPCTSTR szDirectory, UINT iAttribute,
					  SkuSet *pSkuSet, int iSkuIndex);
HRESULT InsertCondition(LPCTSTR szFeature_, int iLevel, LPCTSTR szCondition, 
					  SkuSet *pSkuSet, int iSkuIndex);
HRESULT InsertFeatureComponents(LPCTSTR szFeature, LPCTSTR szComponent, 
								SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertComponent(LPCTSTR szComponent, LPCTSTR szComponentId, 
						LPCTSTR szDirectory_, UINT iAttributes, 
						LPCTSTR szCondition, LPCTSTR szKeyPath, 
						SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertCreateFolder(LPCTSTR szDirectory, LPCTSTR szComponent, 
						   SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertLockPermissions(LPCTSTR szLockObject, LPCTSTR szTable, 
							  LPCTSTR szDomain, LPCTSTR szUser,
			  				  int uiPermission, SkuSet *pSkuSet, 
							  int iSkuIndex);

HRESULT InsertFile(LPCTSTR szFile, LPCTSTR szComponentId,
				   LPCTSTR szFileName, UINT uiFileSize, LPCTSTR szVersion, 
				   LPCTSTR szLanguage, UINT iAttributes, INT iSequence,
				   SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertFont(LPCTSTR szFile_, LPCTSTR szFontTitle, SkuSet *pSkuSet,
				   int iSkuIndex);

HRESULT InsertBindImage(LPCTSTR szFile_, LPCTSTR szPath, SkuSet *pSkuSet, 
						int iSkuIndex);

HRESULT InsertSelfReg(LPCTSTR szFile_, UINT uiCost, SkuSet *pSkuSet, 
					  int iSkuIndex);

HRESULT InsertMoveFile(LPCTSTR szFileKey, LPCTSTR szComponent_, 
					   LPCTSTR szSourceName, LPCTSTR szDestName, 
					   LPCTSTR szSourceFolder, LPCTSTR szDestFolder,
					   UINT uiOptions, SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertRemoveFile(LPCTSTR szFileKey, LPCTSTR szComponent_, 
					   LPCTSTR szFileName, LPCTSTR szDirProperty, 
					   UINT uiInstallMode, SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertIniFile(LPCTSTR szIniFile, LPCTSTR szFileName, 
					  LPCTSTR szDirProperty, LPCTSTR szSection, LPCTSTR szKey,
					  LPCTSTR szValue, UINT uiAction, LPCTSTR szComponent_,
					  SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertRemoveIniFile(LPCTSTR szRemoveIniFile, LPCTSTR szFileName, 
						    LPCTSTR szDirProperty, LPCTSTR szSection, LPCTSTR szKey,
							LPCTSTR szValue, UINT uiAction, LPCTSTR szComponent_,
							SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertRegistry(LPCTSTR szRegistry, int iRoot, LPCTSTR szKey, 
					   LPCTSTR szName, LPCTSTR szValue, LPCTSTR szComponent_, 
					   SkuSet *pSkuSet, int iSkuIndex);

HRESULT InsertRemoveRegistry(LPCTSTR szRemoveRegistry, int iRoot, 
						     LPCTSTR szKey, LPCTSTR szName, 
							 LPCTSTR szComponent_, SkuSet *pSkuSet, 
							 int iSkuIndex);
///////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Read in the scheme from a template DB and create a DB Table with 
// specified name
////////////////////////////////////////////////////////////////////////////
HRESULT CreateTable_SKU(LPTSTR szTable, SkuSet *pskuSet);

////////////////////////////////////////////////////////////////////////////
// GetSQLCreateQuery: 
//		Given a template DB and a table name, return the SQL query string
//		for creating that table via pszSQLCreate
////////////////////////////////////////////////////////////////////////////
HRESULT GetSQLCreateQuery(LPTSTR szTable, MSIHANDLE hDBTemplate, LPTSTR *pszSQLCreate);

////////////////////////////////////////////////////////////////////////////
// return the child node of pParent with the specified name via pChild
////////////////////////////////////////////////////////////////////////////
HRESULT GetChildNode(PIXMLDOMNode &pParent, LPCTSTR szChildName, 
					 PIXMLDOMNode &pChild);
HRESULT GetChildNode(IXMLDOMNode *pParent, LPCTSTR szChildName, 
					 PIXMLDOMNode &pChild);
////////////////////////////////////////////////////////////////////////////
// return a list of all the children node of pParent with the specified name
// via pChild
////////////////////////////////////////////////////////////////////////////
HRESULT GetChildrenNodes(PIXMLDOMNode &pParent, LPCTSTR szChildName,
						 PIXMLDOMNodeList &pChildren);

////////////////////////////////////////////////////////////////////////////
// for debug purpose, print out the name of pNode, map ...
HRESULT PrintNodeName(PIXMLDOMNode &pNode);

void PrintMap_LI(map<LPTSTR, int, Cstring_less> &LI_map);
void PrintMap_LL(map<LPTSTR, LPTSTR, Cstring_less> &LL_map);
void PrintMap_LC(map<LPTSTR, Component *, Cstring_less> &LC_map);
void PrintMap_LS(map<LPTSTR, SkuSet *, Cstring_less> &LS_map);

void PrintMap_DirRef(map<LPTSTR, SkuSetValues *, Cstring_less> &map_DirRef);

void PrintError(UINT errorCode);
void PrintSkuIDs(SkuSet *pSkuSet);
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// return the value of pNode's attribute with name szAttrName via vAttrValue
////////////////////////////////////////////////////////////////////////////
HRESULT GetAttribute(PIXMLDOMNode &pNode, LPCTSTR szAttrName, 
					 VARIANT &vAttrValue);

////////////////////////////////////////////////////////////////////////////
// Return the value of pNode's ID attribute via szID
////////////////////////////////////////////////////////////////////////////
HRESULT GetID(PIXMLDOMNode &pNode, LPCTSTR &szID);

////////////////////////////////////////////////////////////////////////////
// Load an XML Document from the specified file or URL synchronously.
////////////////////////////////////////////////////////////////////////////
HRESULT LoadDocumentSync(PIXMLDOMDocument2 &pDoc, BSTR pBURL);

////////////////////////////////////////////////////////////////////////////
// Report parsing error information
////////////////////////////////////////////////////////////////////////////
HRESULT ReportError(PIXMLDOMParseError &pXMLError);

////////////////////////////////////////////////////////////////////////////
// Check load results
////////////////////////////////////////////////////////////////////////////
HRESULT CheckLoad(PIXMLDOMDocument2 &pDoc);

////////////////////////////////////////////////////////////////////////////
// an enhancement of MsiRecordGetString. szValueBuf will be automatically 
// increased if necessary 
////////////////////////////////////////////////////////////////////////////
UINT WmcRecordGetString(MSIHANDLE hRecord, unsigned int iField,
						LPTSTR &szValueBuf, DWORD *pcchValueBuf);

////////////////////////////////////////////////////////////////////////////
// String converstion functions

BSTR LPTSTRToBSTR(LPCTSTR szFName);

LPTSTR BSTRToLPTSTR(BSTR bString);

HRESULT GUIDToLPTSTR(LPGUID pGUID, LPTSTR &szGUID);
////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////
// Return a unique name by postfixing szName with a unique number
////////////////////////////////////////////////////////////////////////////
LPTSTR GetName(LPTSTR szName);

////////////////////////////////////////////////////////////////////////////
// Return a unique number (each time return a number 1 bigger than last time
////////////////////////////////////////////////////////////////////////////
ULONG GetUniqueNumber();

////////////////////////////////////////////////////////////////////////////
// convert a UUID string to all uppercases and add '{' '}' to the beginning 
// and end of the string
////////////////////////////////////////////////////////////////////////////
HRESULT FormatGUID(LPTSTR &szValue);

////////////////////////////////////////////////////////////////////////////
// compares the relationship of the 2 modules in the module tree. Return 
// the comparison result through iResult. if szModule1 is an ancestor
// of szModule2, *iResult is set to -1. if szModule1 is a descendant of 
// szModule2, *iResult is set to 1. if szModule1 is the same as szModule2 
// or the 2 modules doesn't belong to the same Module subtree, iResult is
// set to 0. This is an error to catch.
////////////////////////////////////////////////////////////////////////////
HRESULT CompareModuleRel(LPTSTR szModule1, LPTSTR szModule2, int *iResult);

#endif //XMSI_UTILITIES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\create.dll\sources.inc ===
TARGETNAME=create

!INCLUDE ..\..\..\MsiMake.inc

!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

TARGETTYPE=DYNLINK

USE_LIBCMT=1

USE_NOLIBS=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\create.def

INCLUDES=$(INC_DIR);$(SDK_INC_PATH);$(RES_OBJDIR)

TARGETLIBS=\
        $(SDK_LIB_PATH)\netapi32.lib \
		$(SDK_LIB_PATH)\user32.lib \
		$(SDK_LIB_PATH)\kernel32.lib \
        $(BUILD_DIR)\msi.lib

SOURCES=..\create.cpp \
		..\create.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\res\make.inc ===
!INCLUDE ..\..\MsiMake.inc

RES_INTL_DIR=$(RES_DIR)\intl

ResAll: $(BUILD_DIR) \
	$(BUILD_COMMONDIR) \
	$(RES_OBJDIR)\msi.rcv \
	$(RES_OBJDIR)\msiAll.res \
	$(RES_OBJDIR)\enumsi.res # for localization only, not used in builds

clean:
	del $(BUILD_DIR)\*.bsc
	del $(BUILD_DIR)\*.exe
	del $(BUILD_DIR)\*.dll
	del $(BUILD_DIR)\*.pdb
	del $(BUILD_DIR)\*.lib
	del $(BUILD_DIR)\*.exp

	
#Create target directories if not already existing
#-------------------------------------------------
$(BUILD_DIR): 
	md $(BUILD_DIR)

$(BUILD_COMMONDIR):
	md $(BUILD_COMMONDIR)

#Build our msi.rcv token file
#----------------------------
$(RES_OBJDIR)\msi.rcv: $(INC_DIR)\rcv.src $(INC_DIR)\rcv.tok
	@if not exist $(RES_OBJDIR) md $(RES_OBJDIR)
	$(TOOLS_DIR)\tok -q -f $(INC_DIR)\rcv.tok $(INC_DIR)\rcv.src > $@



{$(RES_DIR)}.rc{$(RES_OBJDIR)}.res:
	rc $(C_DEFINES) -d_RC32 -Fo$*.res -i $(INC_DIR) -i $(BUILD_COMMONDIR) -i $(SDK_INC_PATH) -i $(RES_OBJDIR) -dNEUTRAL_SUBLANGUAGE $< 


$(RES_OBJDIR)\msiAll.res: $(RES_OBJDIR)\msi.res $(RES_OBJDIR)\msiENU.res $(RES_INTL_DIR)\msi???.res $(RES_OBJDIR)\enuerr.rc $(RES_OBJDIR)\autoapii.tlb
	copy /b $(RES_OBJDIR)\msi.res + $(RES_OBJDIR)\msiENU.res + $(RES_INTL_DIR)\msi???.res /b $@

$(RES_OBJDIR)\msi.res: $(RES_OBJDIR)\msi.rcv $(RES_DIR)\msi.rc $(RES_OBJDIR)\autoapii.tlb

$(RES_OBJDIR)\autoapii.tlb: ..\autoapi.cpp $(INC_DIR)\autoapi.h $(INC_DIR)\msi.hh
	midl -char unsigned -ms_ext -c_ext $(C_DEFINES) -D__MKTYPLIB__  -tlb $@ /I$(INC_DIR) /I$(SDK_INC_PATH) -cpp_cmd $(MIDL_CPP) -mktyplib203 ..\autoapi.cpp
#	mktyplib $(C_DEFINES) /tlb $@ /w0 /I $(INC_DIR) ..\autoapi.cpp

$(RES_OBJDIR)\msiENU.res: $(RES_DIR)\msiENU.rc $(RES_OBJDIR)\enuerr.rc $(RES_OBJDIR)\EventENU.bin

# for localization only, not used in builds
$(RES_OBJDIR)\enumsi.res: ..\msiENU.rc
	rc $(C_DEFINES) -d_RC32 -Fo$(RES_OBJDIR)\enumsi.res -i $(INC_DIR) -i $(BUILD_COMMONDIR) -i $(SDK_INC_PATH) -i $(RES_OBJDIR) ..\msiENU.rc

$(RES_OBJDIR)\enuerr.rc: $(MSI_BUILDTOOLS_DIR)\genenuer.prl
	$(TOOLS_DIR)\perl $(MSI_BUILDTOOLS_DIR)\genenuer.prl $(SDK_INC_PATH)\msi.h $@

$(RES_OBJDIR)\EventENU.bin $(INC_DIR)\Eventlog.h: $(RES_DIR)\Eventlog.mc
	mc -h $(RES_OBJDIR) -r $(RES_OBJDIR) $(RES_DIR)\Eventlog.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\create.dll\create.cpp ===
#if 0  // makefile definitions
DESCRIPTION = CreateUserAccount on Local Machine
MODULENAME = create
FILEVERSION = Msi
ENTRY = CreateUserAccount
UNICODE=1
LINKLIBS = netapi32.lib
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

// Required headers
#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>
#ifndef RC_INVOKED    // start of source code

#include "msiquery.h"
#include "msidefs.h"
#include <windows.h>
#include <basetsd.h>
#include <stdlib.h>
#include <lm.h>

#define UNICODE 1

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000-2001
//
//  File:       create.cpp
//
//  Notes: DLL custom action, must be used in conjunction with the DLL
//         custom actions included in process.cpp and remove.cpp
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f create.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 DLL project
//      2. Add create.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib and netapi32.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//      5. Add /DUNICODE to the project options in the Project Settings dialog
//
//------------------------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////////////
// CreateUserAccount
//
//     Attempts to create a user account on the local machine according
//       to the "instructions" provided in the CustomActionData property
//
//     As a deferred custom action, you do not have access to the database.
//       The only source of infromation comes from a property that another
//       custom action can set to provide the information you need.  This
//       property is written into the script
//
UINT __stdcall CreateUserAccount(MSIHANDLE hInstall)
{
	const WCHAR* wszSep = L"\001";
	const int iCreationError = 25001;
	const int iCreationDuplicate = 25002;

	// Grab the CustomActionData property
	WCHAR* wszCAData = 0;
	DWORD cchCAData = 0;
	::MsiGetPropertyW(hInstall, IPROPNAME_CUSTOMACTIONDATA, L"", &cchCAData);
	wszCAData = new WCHAR[++cchCAData];
	UINT uiStat = ::MsiGetPropertyW(hInstall, IPROPNAME_CUSTOMACTIONDATA, wszCAData, &cchCAData);
	if (ERROR_SUCCESS != uiStat)
	{
		if (wszCAData)
			delete [] wszCAData;
		return ERROR_INSTALL_FAILURE; // error -- should never happen
	}

	USER_INFO_1 ui;
	DWORD dwLevel = 1; // represents USER_INFO_1 struct
	DWORD dwError = 0;
	NET_API_STATUS nStatus;

	//
	// Parse CustomActionDataProperty
	//
	WCHAR* wszUserName = wcstok(wszCAData, wszSep);
	WCHAR* wszPassWd   = wcstok(NULL, wszSep);
	WCHAR* pwch = wcstok(NULL, wszSep);
	if (!pwch)
	{
		if (wszCAData)
			delete [] wszCAData;
		return ERROR_INSTALL_FAILURE; // error -- should never happen
	}
	int iUserFlags = wcstol(pwch, 0, 10);
	
	//
	// Set up the USER_INFO_1 structure.
	//  USER_PRIV_USER: name identifies a user, 
	//    rather than an administrator or a guest.
	//  UF_SCRIPT: required for LAN Manager 2.0 and
	//    Windows NT/Windows 2000.
	//
	ui.usri1_name = wszUserName;
	ui.usri1_password = wszPassWd;
	ui.usri1_priv = USER_PRIV_USER;
	ui.usri1_flags = UF_SCRIPT | iUserFlags;
	ui.usri1_home_dir = NULL;
	ui.usri1_comment = NULL;
	ui.usri1_script_path = NULL;

	// Send ActionData message (template in ActionText table)
	PMSIHANDLE hRec = ::MsiCreateRecord(1);
	::MsiRecordSetStringW(hRec, 1, wszUserName);
	::MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);

	//
	// Call the NetUserAdd function, specifying level 1.
	//
	nStatus = NetUserAdd(NULL /*local machine*/, dwLevel, (LPBYTE)&ui, &dwError);  

	if (nStatus != NERR_Success)
	{
		PMSIHANDLE hRecErr = ::MsiCreateRecord(3);
		::MsiRecordSetInteger(hRecErr, 1, (nStatus == NERR_UserExists) ? iCreationDuplicate : iCreationError);
		::MsiRecordSetStringW(hRecErr, 2, wszUserName);
		::MsiRecordSetInteger(hRecErr, 3, nStatus);
		::MsiProcessMessage(hInstall, INSTALLMESSAGE_ERROR, hRecErr);
		if (wszCAData)
			delete [] wszCAData;

		return ERROR_INSTALL_FAILURE; // error
	}
	if (wszCAData)
		delete [] wszCAData;
	return ERROR_SUCCESS;
}

#else // RC_INVOKED, end of source code, start of resources
// resource definition go here

#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\custexe\sources.inc ===
TARGETNAME=custexe1
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

NO_BINPLACE=1

UMTYPE=windows
UMENTRY=$(MSI_WINENTRY)

USE_LIBCMT=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\msi.lib

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(INCLUDES);$(INC_DIR)

SOURCES=..\custexe1.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\custdll\custact1.cpp ===
#pragma message("Simple Custom Action DLL.  Copyright (c) 1997 - 2001 Microsoft Corp.")
#if 0  // makefile definitions
DESCRIPTION = Custom Action Test DLL
MODULENAME = CustAct1
FILEVERSION = 0.20
ENTRY = Action1,Action129,Action193,Action257,Action513,Action769,Action1025,Action1281,Action1537,KitchenSink,GPFault,DllRegisterServer,DllUnregisterServer
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       custact1.cpp
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f custact1.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 DLL project
//      2. Add custact1.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------

// test of external database access
#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>  // included for both CPP and RC passes
#ifndef RC_INVOKED    // start of CPP source code
#include <stdio.h>    // printf/wprintf
#include <tchar.h>    // define UNICODE=1 on nmake command line to build UNICODE
#include "MsiQuery.h" // must be in this directory or on INCLUDE path

HRESULT __stdcall DllRegisterServer()
{
	Beep(1000, 500);
	return 0;
}

HRESULT __stdcall DllUnregisterServer()
{
	Beep(500, 500);
	return 0;
}

static UINT Action(MSIHANDLE hInstall, int iType, const TCHAR* szPass)
{
	TCHAR szProperty[] = TEXT("TESTACTION");
	TCHAR szValue[200];
	DWORD cchValue = sizeof(szValue)/sizeof(TCHAR);
	if (MsiGetProperty(hInstall, szProperty, szValue, &cchValue) != ERROR_SUCCESS || szValue[0] == 0)
		lstrcpy(szValue, TEXT("(none)"));
	if (iType & 128)  // asyncronous action, cannot call MsiProcessMessage without blocking install
	{
		TCHAR szMessage[256];
		wsprintf(szMessage, TEXT("Action %i, called from %s, TESTACTION = %s\rOK to succeed, CANCEL to fail"),
				 iType, szPass, szValue);
		return ::MessageBox(0, szMessage, TEXT("Installer custom action test"), MB_OKCANCEL);
	}
	PMSIHANDLE hrec = ::MsiCreateRecord(34);
	::MsiRecordSetString(hrec, 0, TEXT("Called from [2], TESTACTION = [3]\rOK to succeed, CANCEL to fail"));
	::MsiRecordSetInteger(hrec, 1, iType);  // not really an error code
	::MsiRecordSetString(hrec, 2, szPass);
	::MsiRecordSetString(hrec, 3, szValue);
	return ::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_USER + MB_OKCANCEL), hrec)
		== IDOK ? ERROR_SUCCESS : ERROR_INSTALL_USEREXIT;
}

UINT __stdcall Action1   (MSIHANDLE hInstall) { return Action(hInstall,   1, TEXT("Always run")); }
UINT __stdcall Action129 (MSIHANDLE hInstall) { return Action(hInstall, 129, TEXT("Always, asynch in sequence")); }
UINT __stdcall Action193 (MSIHANDLE hInstall) { return Action(hInstall, 193, TEXT("Always, asynch for session")); }
UINT __stdcall Action257 (MSIHANDLE hInstall) { return Action(hInstall, 257, TEXT("Once, client preferred")); }
UINT __stdcall Action513 (MSIHANDLE hInstall) { return Action(hInstall, 513, TEXT("Once per process")); }
UINT __stdcall Action769 (MSIHANDLE hInstall) { return Action(hInstall, 769, TEXT("Client 2nd sequence")); }
UINT __stdcall Action1025(MSIHANDLE hInstall) { return Action(hInstall,1025, TEXT("Execution script")); }
UINT __stdcall Action1281(MSIHANDLE hInstall) { return Action(hInstall,1281, TEXT("Rollback script")); }
UINT __stdcall Action1537(MSIHANDLE hInstall) { return Action(hInstall,1537, TEXT("Commit script")); }

UINT __stdcall GPFault(MSIHANDLE hInstall)
{
	if (::MessageBox(0, TEXT("OK to GPFault,  CANCEL to skip"), TEXT("GPFault Text"), MB_OKCANCEL)
			== IDCANCEL)
		return ERROR_SUCCESS;
	TCHAR* sz = (TCHAR*)0;
	sz[0] = 0;
	return ERROR_INSTALL_FAILURE;
}

void CheckError(UINT ui)
{
	if (ERROR_SUCCESS != ui)
		MessageBox(0, TEXT("FAILURE"), 0, 0);
}

UINT __stdcall KitchenSink(MSIHANDLE hInstall) 
{ 
	char  rgchAnsi[100];
	WCHAR rgchWide[100];
	DWORD cchBufAnsi = sizeof(rgchAnsi)/sizeof(char);
	DWORD cchBufWide = sizeof(rgchWide)/sizeof(WCHAR);
	MSIHANDLE h;
	
	CheckError(MsiGetPropertyA(hInstall, "ProductName", rgchAnsi, &cchBufAnsi));
	if (0 != lstrcmpA(rgchAnsi, "TestDb") || cchBufAnsi != sizeof("TestDb")/sizeof(char)-1)
		CheckError(E_FAIL);

	CheckError(MsiGetPropertyW(hInstall, L"ProductName", rgchWide, &cchBufWide));
	if (0 != lstrcmpW(rgchWide, L"TestDb") || cchBufWide != sizeof(L"TestDb")/sizeof(WCHAR)-1)
		CheckError(E_FAIL);

	h = MsiCreateRecord(4);
	CheckError(h == 0 ? E_FAIL : S_OK);
	CheckError(MsiCloseHandle(h));

	CheckError(MsiCloseAllHandles());

	PMSIHANDLE hDatabase;
	hDatabase = MsiGetActiveDatabase(hInstall);
	CheckError(hDatabase == 0 ? E_FAIL : S_OK);

	PMSIHANDLE hView;
	CheckError(MsiDatabaseOpenViewA(hDatabase, "SELECT `Value` FROM `Property` WHERE `Property`=?", &hView));
	PMSIHANDLE hRecord = MsiCreateRecord(1);
	CheckError(MsiRecordSetStringA(hRecord, 1, "ProductName"));
	CheckError(MsiViewExecute(hView, hRecord));
	PMSIHANDLE hResults;
	CheckError(MsiViewFetch(hView, &hResults));
	
	cchBufAnsi = sizeof(rgchAnsi)/sizeof(char);
	CheckError(MsiRecordGetStringA(hResults, 1, rgchAnsi, &cchBufAnsi));
	if (0 != lstrcmpA(rgchAnsi, "TestDb") || cchBufAnsi != sizeof("TestDb")/sizeof(char) - 1)
		CheckError(E_FAIL);

	CheckError(MsiSetMode(hInstall, MSIRUNMODE_REBOOTATEND, TRUE));
	if (TRUE != MsiGetMode(hInstall, MSIRUNMODE_REBOOTATEND))
		CheckError(E_FAIL);
	CheckError(MsiSetMode(hInstall, MSIRUNMODE_REBOOTATEND, FALSE));
	if (FALSE != MsiGetMode(hInstall, MSIRUNMODE_REBOOTATEND))
		CheckError(E_FAIL);

	INSTALLSTATE installed, action;
	CheckError(MsiSetFeatureStateA(hInstall, "QuickTest", INSTALLSTATE_SOURCE));
	CheckError(MsiGetFeatureStateA(hInstall, "QuickTest", &installed, &action));
	if (installed != INSTALLSTATE_ABSENT || action != INSTALLSTATE_SOURCE)
		CheckError(E_FAIL);
	



	return ERROR_SUCCESS;

/*
	HRESULT         __stdcall ViewGetError(unsigned long hView, ichar* szColumnNameBuffer,unsigned long* pcchBuf, int *pMsidbError);
	
	HRESULT         __stdcall ViewModify(unsigned long hView, long eUpdateMode, unsigned long hRecord);
	HRESULT         __stdcall ViewClose(unsigned long hView);
	HRESULT         __stdcall OpenDatabase(const ichar* szDatabasePath, const ichar* szPersist,unsigned long *phDatabase);
	HRESULT         __stdcall DatabaseCommit(unsigned long hDatabase);
	HRESULT         __stdcall DatabaseGetPrimaryKeys(unsigned long hDatabase, const ichar * szTableName,unsigned long *phRecord);
	HRESULT         __stdcall RecordIsNull(unsigned long hRecord, unsigned int iField, boolean *pfIsNull);
	HRESULT         __stdcall RecordDataSize(unsigned long hRecord, unsigned int iField,unsigned int* puiSize);
	HRESULT         __stdcall RecordSetInteger(unsigned long hRecord, unsigned int iField, int iValue);
	HRESULT         __stdcall RecordSetString(unsigned long hRecord,	unsigned int iField, const ichar* szValue);
	HRESULT         __stdcall RecordGetInteger(unsigned long hRecord, unsigned int iField, int *piValue);
	HRESULT         __stdcall RecordGetString(unsigned long hRecord, unsigned int iField, ichar* szValueBuf,unsigned long *pcchValueBuf);
	HRESULT         __stdcall RecordGetFieldCount(unsigned long hRecord,unsigned int* piCount);
	HRESULT         __stdcall RecordSetStream(unsigned long hRecord, unsigned int iField, const ichar* szFilePath);
	HRESULT         __stdcall RecordReadStream(unsigned long hRecord, unsigned int iField, char *szDataBuf,unsigned long *pcbDataBuf);
	HRESULT         __stdcall RecordClearData(unsigned long hRecord);
	HRESULT         __stdcall GetSummaryInformation(unsigned long hDatabase, const ichar*  szDatabasePath, unsigned int    uiUpdateCount, unsigned long *phSummaryInfo);
	HRESULT         __stdcall SummaryInfoGetPropertyCount(unsigned long hSummaryInfo,	unsigned int *puiPropertyCount);
	HRESULT         __stdcall SummaryInfoSetProperty(unsigned long hSummaryInfo,unsigned intuiProperty, unsigned intuiDataType, int iValue, FILETIME *pftValue, const ichar* szValue); 
	HRESULT         __stdcall SummaryInfoGetProperty(unsigned long hSummaryInfo,unsigned intuiProperty,unsigned int *puiDataType, int *piValue, FILETIME *pftValue, ichar*  szValueBuf,unsigned long *pcchValueBuf);
	HRESULT         __stdcall SummaryInfoPersist(unsigned long hSummaryInfo);
	
	HRESULT         __stdcall SetProperty(unsigned long hInstall, const ichar* szName, const ichar* szValue);
	HRESULT         __stdcall GetLanguage(unsigned long hInstall,unsigned short* pLangId);
	HRESULT         __stdcall GetMode(unsigned long hInstall, long eRunMode, boolean* pfSet); 
	HRESULT         __stdcall SetMode(unsigned long hInstall, long eRunMode, boolean fState);
	HRESULT         __stdcall FormatRecord(unsigned long hInstall, unsigned long hRecord, ichar* szResultBuf,unsigned long *pcchResultBuf);
	HRESULT         __stdcall DoAction(unsigned long hInstall, const ichar* szAction);    
	HRESULT         __stdcall Sequence(unsigned long hInstall, const ichar* szTable, int iSequenceMode);   
	HRESULT         __stdcall ProcessMessage(unsigned long hInstall, long eMessageType, unsigned long hRecord, int* piRes);
	HRESULT         __stdcall EvaluateCondition(unsigned long hInstall, const ichar* szCondition, int *piCondition);
	HRESULT         __stdcall GetComponentState(unsigned long hInstall, const ichar* szComponent, long *piInstalled, long *piAction);
	HRESULT         __stdcall SetComponentState(unsigned long hInstall, const ichar*     szComponent, long iState);
	HRESULT         __stdcall GetFeatureCost(unsigned long hInstall, const ichar* szFeature, int iCostTree, long iState, int *piCost);
	HRESULT         __stdcall SetInstallLevel(unsigned long hInstall, int iInstallLevel);
	HRESULT         __stdcall GetFeatureValidStates(unsigned long hInstall, const ichar* szFeature,unsigned long *dwInstallStates);
	HRESULT         __stdcall DatabaseIsTablePersistent(unsigned long hDatabase, const ichar* szTableName, int *piCondition);
	HRESULT         __stdcall ViewGetColumnInfo(unsigned long hView, long eColumnInfo,unsigned long *phRecord);
	HRESULT         __stdcall GetLastErrorRecord(unsigned long *phRecord);
	HRESULT         __stdcall GetSourcePath(unsigned long hInstall, const ichar* szFolder, ichar* szPathBuf, unsigned long *pcchPathBuf);
	HRESULT         __stdcall GetTargetPath(unsigned long hInstall, const ichar* szFolder, ichar* szPathBuf, unsigned long *pcchPathBuf); 
	HRESULT         __stdcall SetTargetPath(unsigned long hInstall, const ichar* szFolder, const ichar* szFolderPath);
	HRESULT         __stdcall VerifyDiskSpace(unsigned long hInstall);

*/

}

#else // RC_INVOKED, end of CPP source code, start of resource definitions
// resource definition go here
#endif // RC_INVOKED
#if 0  // required at end of source file, to hide makefile terminator
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\custdll\sources.inc ===
TARGETNAME=custact1
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=DYNLINK
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

NO_BINPLACE=1

UMTYPE=windows
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\custact1.def

USE_LIBCMT=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\msi.lib

C_DEFINES=$(C_DEFINES) 

INCLUDES=$(INCLUDES);$(INC_DIR)

SOURCES=..\custact1.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\process.dll\process.cpp ===
#if 0  // makefile definitions
DESCRIPTION = Process UserAccounts Database Table
MODULENAME = process
FILEVERSION = Msi
ENTRY = ProcessUserAccounts,UninstallUserAccounts
LINKLIBS = netapi32.lib
UNICODE=1
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

// Required headers
#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>
#ifndef RC_INVOKED    // start of source code

#include "msiquery.h"
#include <windows.h>
#include <basetsd.h>
#include <lm.h>

#define UNICODE 1

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000-2001
//
//  File:       process.cpp
//
//  Notes: DLL custom actions, must be used in conjunction with the DLL
//         custom actions included in create.cpp and remove.cpp
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f process.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 DLL project
//      2. Add process.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.libto the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//      5. Add /DUNICODE to the project options in the Project Settings dialog
//
//------------------------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////
// ProcessUserAccounts (resides in process.dll)
//
//     Process the UserAccounts custom table generating deferred actions
//       to handle account creation (requires elevated priviledges) and
//       rollback
//
UINT __stdcall ProcessUserAccounts(MSIHANDLE hInstall)
{
	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	PMSIHANDLE hView = 0;
	
	//
	// constants -- custom action names, SQL query, separator
	//
	// wszCreateCA = name of deferred CA to create account
	// wszRollbackCA = name of rollback CA to rollback account creation
	//
	const WCHAR wszCreateCA[] = L"CreateAccount";
	const WCHAR wszRollbackCA[] = L"RollbackAccount";
	const WCHAR wszSQL[] = L"SELECT `UserName`, `TempPassWord`, `Attributes` FROM `CustomUserAccounts`";
	const WCHAR wchSep = '\001';

	UINT uiStat;
	if (ERROR_SUCCESS != (uiStat = ::MsiDatabaseOpenViewW(hDatabase, wszSQL, &hView)))
	{
		if (ERROR_BAD_QUERY_SYNTAX == uiStat)
			return ERROR_SUCCESS; // table not present
		else
			return ERROR_INSTALL_FAILURE; // error -- should never happen
	}
	if (ERROR_SUCCESS != (uiStat = ::MsiViewExecute(hView, 0)))
		return ERROR_INSTALL_FAILURE; // error -- should never happen

	// Fetch all entries from the CustomUserAccounts table
	PMSIHANDLE hRecFetch = 0;
	while (ERROR_SUCCESS == (uiStat = ::MsiViewFetch(hView, &hRecFetch)))
	{
		// Obtain user name
		WCHAR* wszUser = 0;
		DWORD dwUser = 0;
		::MsiRecordGetStringW(hRecFetch, 1, L"", &dwUser);
		wszUser = new WCHAR[++dwUser];
		if (ERROR_SUCCESS != ::MsiRecordGetStringW(hRecFetch, 1, wszUser, &dwUser))
		{
			if (wszUser)
				delete [] wszUser;
			return ERROR_INSTALL_FAILURE; // error -- should never happen
		}
		
		// Obtain temporary password
		WCHAR* wszPassWd = 0;
		DWORD dwPassWd = 0;
		::MsiRecordGetStringW(hRecFetch, 2, L"", &dwPassWd);
		wszPassWd = new WCHAR[++dwPassWd];
		if (ERROR_SUCCESS != ::MsiRecordGetStringW(hRecFetch, 2, wszPassWd, &dwPassWd))
		{
			if (wszUser)
				delete [] wszUser;
			if (wszPassWd)
				delete [] wszPassWd;
			return ERROR_INSTALL_FAILURE; // error -- should never happen
		}
		
		// Obtain attributes of user account
		WCHAR* wszAttrib  = 0;
		DWORD dwAttrib = 0;
		::MsiRecordGetStringW(hRecFetch, 3, L"", &dwAttrib);
		wszAttrib = new WCHAR[++dwAttrib];
		if (ERROR_SUCCESS != ::MsiRecordGetStringW(hRecFetch, 3, wszAttrib, &dwAttrib))
		{
			if (wszUser)
				delete [] wszUser;
			if (wszPassWd)
				delete [] wszPassWd;
			if (wszAttrib)
				delete [] wszAttrib;
			return ERROR_INSTALL_FAILURE; // error -- should never happen
		}

		// Generate the customized property that the deferred action will read
		WCHAR* wszBuf = new WCHAR[dwUser + dwPassWd + dwAttrib + 4];
		wsprintf(wszBuf, L"%s%c%s%c%s", wszUser, wchSep, wszPassWd, wchSep, wszAttrib);

		// Add action data (template is in ActionText table), but do not display temp passwd
		PMSIHANDLE hRecInfo = ::MsiCreateRecord(2);
		::MsiRecordSetStringW(hRecInfo, 1, wszUser);
		::MsiRecordSetStringW(hRecInfo, 2, wszAttrib);
		::MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRecInfo);

		// Rollback custom action goes first
		// Create a rollback custom action (in case install is stopped and rolls back)
		// Rollback custom action can't read tables, so we have to set a property
		::MsiSetPropertyW(hInstall, wszRollbackCA, wszUser);
		::MsiDoActionW(hInstall, wszRollbackCA);

		// Create a deferred custom action (gives us the right priviledges to create the user account)
		// Deferred custom actions can't read tables, so we have to set a property
		::MsiSetPropertyW(hInstall, wszCreateCA, wszBuf);
		::MsiDoActionW(hInstall, wszCreateCA);


		if (wszBuf)
			delete [] wszBuf;
		if (wszUser)
			delete [] wszUser;
		if (wszPassWd)
			delete [] wszPassWd;
		if (wszAttrib)
			delete [] wszAttrib;
	}
	return (ERROR_NO_MORE_ITEMS != uiStat) ? ERROR_INSTALL_FAILURE : ERROR_SUCCESS;
}

//////////////////////////////////////////////////////////////////////////
// UninstallUserAccounts (resides in process.dll)
//
//     Process the UserAccounts custom table generating deferred actions
//       to handle removal of user accounts
//
UINT __stdcall UninstallUserAccounts(MSIHANDLE hInstall)
{
	//
	// constants -- custom action name SQL query
	//
	// wszRemoveCA = name of deferred CA to remove user account
	//
	const WCHAR wszRemoveCA[] = L"RemoveAccount";
	const WCHAR wszSQL[] = L"SELECT `UserName` FROM `CustomUserAccounts`";

	PMSIHANDLE hDatabase = ::MsiGetActiveDatabase(hInstall);
	PMSIHANDLE hView = 0;

	UINT uiStat;
	if (ERROR_SUCCESS != (uiStat = ::MsiDatabaseOpenViewW(hDatabase, wszSQL, &hView)))
	{
		if (ERROR_BAD_QUERY_SYNTAX == uiStat)
			return ERROR_SUCCESS; // table not present
		else
			return ERROR_INSTALL_FAILURE; // error -- should never happen
	}

	if (ERROR_SUCCESS != (uiStat = ::MsiViewExecute(hView, 0)))
		return ERROR_INSTALL_FAILURE; // error -- should never happen

	// Fetch all entries from the UserAccounts custom table
	PMSIHANDLE hRecFetch = 0;
	while (ERROR_SUCCESS == (uiStat = ::MsiViewFetch(hView, &hRecFetch)))
	{
		// Obtain user name
		WCHAR* wszUser = 0;
		DWORD dwUser = 0;
		::MsiRecordGetStringW(hRecFetch, 1, L"", &dwUser);
		wszUser = new WCHAR[++dwUser];
		if (ERROR_SUCCESS != ::MsiRecordGetStringW(hRecFetch, 1, wszUser, &dwUser))
		{
			if (wszUser)
				delete [] wszUser;
			return ERROR_INSTALL_FAILURE; // error -- should never happen
		}
		
		// Send ActionData message (template is in ActionText table)
		PMSIHANDLE hRecInfo = ::MsiCreateRecord(1);
		::MsiRecordSetStringW(hRecInfo, 1, wszUser);
		::MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRecInfo);

		// We can't do a rollback custom action here (well, we could, but it wouldn't be correct)
		// After a user account has been deleted, it cannot be recreated exactly as it was before
		// because it will have been assigned a new SID.  In the case of uninstall, we won't
		// rollback the deletion.

		// Create a deferred custom action (gives us the right priviledges to create the user account)
		// Deferred custom actions can't read tables, so we have to set a property
		::MsiSetPropertyW(hInstall, wszRemoveCA, wszUser);
		::MsiDoActionW(hInstall, wszRemoveCA);

		if (wszUser)
			delete [] wszUser;
	}
	if (ERROR_NO_MORE_ITEMS != uiStat)
		return ERROR_INSTALL_FAILURE; // error -- should never happen

	return ERROR_SUCCESS;
}

#else // RC_INVOKED, end of source code, start of resources
// resource definition go here

#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\custexe\custexe1.cpp ===
#pragma message("Custom Action Test EXE.  Copyright (c) 1997 - 2001 Microsoft Corporation. All rights reserved.")
#if 0  // makefile definitions
DESCRIPTION = Custom Action Test EXE
MODULENAME  = CustExe1
FILEVERSION = 1.0,0,0
SUBSYSTEM = windows
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       custexe1.cpp
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f custexe1.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 Application project
//      2. Add custexe1.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------

#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#define IDD_TEST 1
#ifndef RC_INVOKED   // start of CPP source code

BOOL CALLBACK DialogProc(HWND  hwndDlg, UINT uMsg, WPARAM wParam, LPARAM  lParam)
{
	switch (uMsg)
	{
	case WM_INITDIALOG: return TRUE; // indicate we did not set focus to the control
	case WM_COMMAND:
		switch (wParam)
		{
		case IDOK:     PostQuitMessage(0); return TRUE;
		case IDCANCEL: PostQuitMessage(1); return TRUE;
		}
		return FALSE;
	default: return FALSE;
	};
}

extern "C" int __stdcall _tWinMain(HINSTANCE hInst, HINSTANCE/*hPrev*/, TCHAR* szCmdLine, int/*show*/)
{
	if ((szCmdLine[0]=='-' || szCmdLine[0]=='/') && (szCmdLine[1]=='Q' || szCmdLine[1]=='q'))
		return 0;
	HWND hWnd = ::CreateDialog(hInst, MAKEINTRESOURCE(1), 0, (DLGPROC)DialogProc);
	if (hWnd == 0)
		return 2;
	::SetDlgItemText(hWnd, 8, szCmdLine);
//	::ShowWindow(hWnd, SW_SHOW); //!! why do we need this?
	MSG msg;
	while (::GetMessage(&msg, 0, 0, 0) == TRUE)
		::IsDialogMessage(hWnd, &msg);
	::DestroyWindow(hWnd);
	return (int) msg.wParam;
}

#else // RC_INVOKED, end of source code, start of resources
IDD_TEST DIALOG 150, 150, 160, 75
STYLE DS_MODALFRAME | DS_NOIDLEMSG | WS_POPUP | WS_CAPTION | WS_VISIBLE
CAPTION "Custom Action Test EXE"
FONT 12, "Arial"
{
 LTEXT      "",         8,         20,  7, 120, 40
 PUSHBUTTON "&Succeed", IDOK,      20, 50,  40, 16
 PUSHBUTTON "&Fail",    IDCANCEL, 100, 50,  40, 16
}
#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\process.dll\sources.inc ===
TARGETNAME=process

!INCLUDE ..\..\..\MsiMake.inc

!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

TARGETTYPE=DYNLINK

USE_LIBCMT=1

USE_NOLIBS=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\process.def

INCLUDES=$(SDK_INC_PATH);$(INC_DIR);$(RES_OBJDIR)

TARGETLIBS=\
        $(SDK_LIB_PATH)\netapi32.lib \
		$(SDK_LIB_PATH)\user32.lib \
		$(SDK_LIB_PATH)\kernel32.lib \
        $(BUILD_DIR)\msi.lib

SOURCES=..\process.cpp \
		..\process.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\testdb\sources.inc ===
TARGETNAME=testdb
!INCLUDE ..\..\..\MsiMake.inc

TARGETTYPE=PROGRAM
SUBSYSTEM_VERSION=4.0
SUBSYSTEM_WINVER=4.0

NO_BINPLACE=1

UMTYPE=console
UMENTRY=Entry
UMENTRYABS=Entry

USE_NOLIBS=1

TARGETLIBS=\
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\msi.lib

C_DEFINES=$(C_DEFINES) -D_EXE

INCLUDES=$(INCLUDES);$(INC_DIR)

SOURCES=\
    ..\testdb.rc    \
    ..\testdb.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\remove.dll\remove.cpp ===
#if 0  // makefile definitions
DESCRIPTION = RemoveUserAccount from Local Machine
MODULENAME = remove
FILEVERSION = Msi
ENTRY = RemoveUserAccount
UNICODE=1
LINKLIBS = netapi32.lib
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

// Required headers
#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>
#ifndef RC_INVOKED    // start of source code

#include "msiquery.h"
#include "msidefs.h"
#include <windows.h>
#include <basetsd.h>
#include <lm.h>

#define UNICODE 1

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000-2001
//
//  File: remove.cpp
//
//  Notes: DLL custom action, must be used in conjunction with the DLL
//         custom actions included in process.cpp and create.cpp
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f remove.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 DLL project
//      2. Add remove.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib and netapi32.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//      5. Add /DUNICODE to the project options in the Project Settings dialog
//
//------------------------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////
// RemoveUserAccount
//
//     Attempts to remove a user account on the local machine according
//       to the "instructions" provided in the CustomActionData property
//
//     As a deferred custom action, you do not have access to the database.
//       The only source of infromation comes from a property that another
//       custom action can set to provide the information you need.  This
//       property is written into the script
//
UINT __stdcall RemoveUserAccount(MSIHANDLE hInstall)
{
	// determine mode in which we are called
	BOOL bRollback = MsiGetMode(hInstall, MSIRUNMODE_ROLLBACK); // true for rollback, else regular deferred version (for uninstall)

	const int iRemoveError = 25003;
	const int iRemoveWarning = 25004;

	// Grab the CustomActionData property
	WCHAR* wszCAData = 0;
	DWORD cchCAData = 0;
	::MsiGetPropertyW(hInstall, IPROPNAME_CUSTOMACTIONDATA, L"", &cchCAData);
	wszCAData = new WCHAR[++cchCAData];
	UINT uiStat = ::MsiGetPropertyW(hInstall, IPROPNAME_CUSTOMACTIONDATA, wszCAData, &cchCAData);
	if (ERROR_SUCCESS != uiStat)
	{
		if (wszCAData)
			delete [] wszCAData;
		return ERROR_INSTALL_FAILURE; // error -- should never happen
	}

	// send ActionData message (template in ActionText table)
	PMSIHANDLE hRec = ::MsiCreateRecord(1);
	::MsiRecordSetStringW(hRec, 1, wszCAData);
	::MsiProcessMessage(hInstall, INSTALLMESSAGE_ACTIONDATA, hRec);

	//
	// Call the NetUserDel function, 
	//
	NET_API_STATUS nStatus = NetUserDel(NULL /*local machine*/, wszCAData /*user name*/);
	
	if (NERR_Success != nStatus)
	{
		PMSIHANDLE hRecErr = ::MsiCreateRecord(3);
		::MsiRecordSetStringW(hRecErr, 2, wszCAData);
		if (wszCAData)
			delete [] wszCAData;
		// NERR_UserNotFound is only an error if we are not in Rollback mode
		// In rollback mode, NERR_UserNotFound means cancel button depressed in middle of deferred CA trying to create this account
		if (!bRollback && NERR_UserNotFound == nStatus)
		{
			::MsiRecordSetInteger(hRecErr, 1, iRemoveWarning);
			// just pop up an OK button
			// OPTIONALLY, could specify multiple buttons and cancel
			// install based on user selection by handling the return value
			// from MsiProcessMessage
			::MsiProcessMessage(hInstall, INSTALLMESSAGE(INSTALLMESSAGE_WARNING|MB_ICONWARNING|MB_OK), hRecErr);
			return ERROR_SUCCESS; // ignorable error
		}
		else
		{
			::MsiRecordSetInteger(hRecErr, 1, iRemoveError);
			::MsiRecordSetInteger(hRecErr, 3, nStatus);
			::MsiProcessMessage(hInstall, INSTALLMESSAGE_ERROR, hRecErr);
		    return ERROR_INSTALL_FAILURE; // error
		}
	}

	if (wszCAData)
		delete [] wszCAData;
	return ERROR_SUCCESS;
}


#else // RC_INVOKED, end of source code, start of resources
// resource definition go here

#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\tutorial.dll\sources.inc ===
TARGETNAME=tutorial

!INCLUDE ..\..\..\MsiMake.inc

!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

TARGETTYPE=DYNLINK

USE_LIBCMT=1

USE_NOLIBS=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\tutorial.def

INCLUDES=$(SDK_INC_PATH);$(INC_DIR);$(RES_OBJDIR)

TARGETLIBS=\
		$(SDK_LIB_PATH)\user32.lib \
		$(SDK_LIB_PATH)\kernel32.lib \
		$(SDK_LIB_PATH)\shell32.lib \
        $(BUILD_DIR)\msi.lib

SOURCES=..\tutorial.cpp \
		..\tutorial.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\testdb\testdb.cpp ===
#include <windows.h>
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE

void Entry(){MessageBox(0, TEXT("This is testdb.exe"), TEXT("Test"), MB_OK);}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\remove.dll\sources.inc ===
TARGETNAME=remove

!INCLUDE ..\..\..\MsiMake.inc

!if "$(MSI_BROWSER_INFO)"=="1"
BROWSER_INFO=1
!endif

TARGETTYPE=DYNLINK

USE_LIBCMT=1

USE_NOLIBS=1
DLLENTRY=_DllMainCRTStartup
DLLDEF=..\remove.def

INCLUDES=$(INC_DIR);$(SDK_INC_PATH);$(RES_OBJDIR)

TARGETLIBS=\
        $(SDK_LIB_PATH)\netapi32.lib \
		$(SDK_LIB_PATH)\user32.lib \
		$(SDK_LIB_PATH)\kernel32.lib \
        $(BUILD_DIR)\msi.lib

SOURCES=..\remove.cpp \
		..\remove.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\src\samples\tutorial.dll\tutorial.cpp ===
#if 0  // makefile definitions
DESCRIPTION = Microsoft Installer for Windows\256 Test
MODULENAME = tutorial
FILEVERSION = Msi
LINKLIBS = shell32.lib
ENTRY = LaunchTutorial
!include "..\TOOLS\MsiTool.mak"
!if 0  #nmake skips the rest of this file
#endif // end of makefile definitions

// Required headers
#define WINDOWS_LEAN_AND_MEAN  // faster compile
#include <windows.h>
#ifndef RC_INVOKED    // start of source code

#include "msiquery.h"
#include <tchar.h>   // define UNICODE=1 on nmake command line to build UNICODE
#include <shellapi.h>

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000-2001
//
//  File:       tutorial.cpp
//
//--------------------------------------------------------------------------

//-----------------------------------------------------------------------------------------
//
// BUILD Instructions
//
// notes:
//	- SDK represents the full path to the install location of the
//     Windows Installer SDK
//
// Using NMake:
//		%vcbin%\nmake -f tutorial.cpp include="%include;SDK\Include" lib="%lib%;SDK\Lib"
//
// Using MsDev:
//		1. Create a new Win32 DLL project
//      2. Add tutorial.cpp to the project
//      3. Add SDK\Include and SDK\Lib directories on the Tools\Options Directories tab
//      4. Add msi.lib to the library list in the Project Settings dialog
//          (in addition to the standard libs included by MsDev)
//
//------------------------------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////////////
// LaunchTutorial
//
// Launches a installed file at the end of setup
//
UINT __stdcall LaunchTutorial(MSIHANDLE hInstall)
{
	UINT uiStat = 0;
	const TCHAR szTutorialFileKey[] = TEXT("[#Tutorial]");
	PMSIHANDLE hRecTutorial = ::MsiCreateRecord(1);
	::MsiRecordSetString(hRecTutorial, 0, szTutorialFileKey);

	// determine buffer size
	DWORD dwPath = 0;
	::MsiFormatRecord(hInstall, hRecTutorial, TEXT(""), &dwPath);
	TCHAR* szPath = new TCHAR[++dwPath];
	// determine path to installed file
	if (ERROR_SUCCESS != ::MsiFormatRecord(hInstall, hRecTutorial, szPath, &dwPath))
	{
		if (szPath)
			delete [] szPath;
		return ERROR_INSTALL_FAILURE;
	}

	// set up ShellExecute structure
	// file is the full path to the installed file
	SHELLEXECUTEINFO sei;
	sei.fMask = SEE_MASK_FLAG_NO_UI; // don't show error UI, we'll just silently fail
	sei.hwnd = 0;
	sei.lpVerb = NULL; // use default verb, typically open
	sei.lpFile = szPath;
	sei.lpParameters = NULL;
	sei.lpDirectory = NULL;
	sei.nShow = SW_SHOWNORMAL;
	sei.cbSize = sizeof(sei);

	// spawn the browser to display HTML tutorial
	BOOL fSuccess = ShellExecuteEx(&sei);

	if (szPath)
		delete [] szPath;

	return (fSuccess) ? ERROR_SUCCESS : ERROR_INSTALL_FAILURE;
}

#else // RC_INVOKED, end of source code, start of resources
// resource definition go here

#endif // RC_INVOKED
#if 0 
!endif // makefile terminator
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\tools\inc\fusion.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for fusion.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fusion_h__
#define __fusion_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAssemblyName_FWD_DEFINED__
#define __IAssemblyName_FWD_DEFINED__
typedef interface IAssemblyName IAssemblyName;
#endif 	/* __IAssemblyName_FWD_DEFINED__ */


#ifndef __IApplicationContext_FWD_DEFINED__
#define __IApplicationContext_FWD_DEFINED__
typedef interface IApplicationContext IApplicationContext;
#endif 	/* __IApplicationContext_FWD_DEFINED__ */


#ifndef __IAssembly_FWD_DEFINED__
#define __IAssembly_FWD_DEFINED__
typedef interface IAssembly IAssembly;
#endif 	/* __IAssembly_FWD_DEFINED__ */


#ifndef __IAssemblyBindSink_FWD_DEFINED__
#define __IAssemblyBindSink_FWD_DEFINED__
typedef interface IAssemblyBindSink IAssemblyBindSink;
#endif 	/* __IAssemblyBindSink_FWD_DEFINED__ */


#ifndef __IAssemblyBinding_FWD_DEFINED__
#define __IAssemblyBinding_FWD_DEFINED__
typedef interface IAssemblyBinding IAssemblyBinding;
#endif 	/* __IAssemblyBinding_FWD_DEFINED__ */


#ifndef __IFusionBindLog_FWD_DEFINED__
#define __IFusionBindLog_FWD_DEFINED__
typedef interface IFusionBindLog IFusionBindLog;
#endif 	/* __IFusionBindLog_FWD_DEFINED__ */


#ifndef __IAssemblyManifestImport_FWD_DEFINED__
#define __IAssemblyManifestImport_FWD_DEFINED__
typedef interface IAssemblyManifestImport IAssemblyManifestImport;
#endif 	/* __IAssemblyManifestImport_FWD_DEFINED__ */


#ifndef __IAssemblyModuleImport_FWD_DEFINED__
#define __IAssemblyModuleImport_FWD_DEFINED__
typedef interface IAssemblyModuleImport IAssemblyModuleImport;
#endif 	/* __IAssemblyModuleImport_FWD_DEFINED__ */


#ifndef __IAssemblyCacheItem_FWD_DEFINED__
#define __IAssemblyCacheItem_FWD_DEFINED__
typedef interface IAssemblyCacheItem IAssemblyCacheItem;
#endif 	/* __IAssemblyCacheItem_FWD_DEFINED__ */


#ifndef __IAssemblyEnum_FWD_DEFINED__
#define __IAssemblyEnum_FWD_DEFINED__
typedef interface IAssemblyEnum IAssemblyEnum;
#endif 	/* __IAssemblyEnum_FWD_DEFINED__ */


#ifndef __IAssemblyScavenger_FWD_DEFINED__
#define __IAssemblyScavenger_FWD_DEFINED__
typedef interface IAssemblyScavenger IAssemblyScavenger;
#endif 	/* __IAssemblyScavenger_FWD_DEFINED__ */


#ifndef __IAssemblyCache_FWD_DEFINED__
#define __IAssemblyCache_FWD_DEFINED__
typedef interface IAssemblyCache IAssemblyCache;
#endif 	/* __IAssemblyCache_FWD_DEFINED__ */


#ifndef __IHistoryAssembly_FWD_DEFINED__
#define __IHistoryAssembly_FWD_DEFINED__
typedef interface IHistoryAssembly IHistoryAssembly;
#endif 	/* __IHistoryAssembly_FWD_DEFINED__ */


#ifndef __IHistoryReader_FWD_DEFINED__
#define __IHistoryReader_FWD_DEFINED__
typedef interface IHistoryReader IHistoryReader;
#endif 	/* __IHistoryReader_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_fusion_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// fusion.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Fusion Interfaces.

#define STREAM_FORMAT_COMPLIB_MODULE    0
#define STREAM_FORMAT_COMPLIB_MANIFEST  1
#define STREAM_FORMAT_WIN32_MODULE      2
#define STREAM_FORMAT_WIN32_MANIFEST    4










EXTERN_C const IID IID_IAssemblyName;       
EXTERN_C const IID IID_IApplicationContext;       
EXTERN_C const IID IID_IAssembly;           
EXTERN_C const IID IID_IAssemblyBindSink;   
EXTERN_C const IID IID_IAssemblyBinding;   
EXTERN_C const IID IID_IAssemblyManifestImport;
EXTERN_C const IID IID_IAssemblyModuleImport;  
EXTERN_C const IID IID_IAssemblyCacheItem;  
EXTERN_C const IID IID_IAssemblyScavenger;      
EXTERN_C const IID IID_IAssemblyCache;      
EXTERN_C const IID IID_IHistoryAssembly;      
EXTERN_C const IID IID_IHistoryReader;      
#ifndef _LPFUSION_DEFINED
#define _LPFUSION_DEFINED
#define IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH (0x00000001)
#define QUERYASMINFO_FLAG_VALIDATE             (0x1)
#define ASSEMBLYINFO_FLAG_INSTALLED (0x00000001)
#define ASSEMBLYINFO_FLAG_PAYLOADRESIDENT (0x00000002)
typedef struct _ASSEMBLY_INFO
    {
    ULONG cbAssemblyInfo;
    DWORD dwAssemblyFlags;
    ULARGE_INTEGER uliAssemblySizeInKB;
    LPWSTR pszCurrentAssemblyPathBuf;
    ULONG cchBuf;
    } 	ASSEMBLY_INFO;

#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED (1)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE (2)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED (3)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING (4)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED (1)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED (2)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED (3)


extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_s_ifspec;

#ifndef __IAssemblyName_INTERFACE_DEFINED__
#define __IAssemblyName_INTERFACE_DEFINED__

/* interface IAssemblyName */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyName *LPASSEMBLYNAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0001
    {	ASM_NAME_PUBLIC_KEY	= 0,
	ASM_NAME_PUBLIC_KEY_TOKEN	= ASM_NAME_PUBLIC_KEY + 1,
	ASM_NAME_HASH_VALUE	= ASM_NAME_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NAME	= ASM_NAME_HASH_VALUE + 1,
	ASM_NAME_MAJOR_VERSION	= ASM_NAME_NAME + 1,
	ASM_NAME_MINOR_VERSION	= ASM_NAME_MAJOR_VERSION + 1,
	ASM_NAME_BUILD_NUMBER	= ASM_NAME_MINOR_VERSION + 1,
	ASM_NAME_REVISION_NUMBER	= ASM_NAME_BUILD_NUMBER + 1,
	ASM_NAME_CULTURE	= ASM_NAME_REVISION_NUMBER + 1,
	ASM_NAME_PROCESSOR_ID_ARRAY	= ASM_NAME_CULTURE + 1,
	ASM_NAME_OSINFO_ARRAY	= ASM_NAME_PROCESSOR_ID_ARRAY + 1,
	ASM_NAME_HASH_ALGID	= ASM_NAME_OSINFO_ARRAY + 1,
	ASM_NAME_ALIAS	= ASM_NAME_HASH_ALGID + 1,
	ASM_NAME_CODEBASE_URL	= ASM_NAME_ALIAS + 1,
	ASM_NAME_CODEBASE_LASTMOD	= ASM_NAME_CODEBASE_URL + 1,
	ASM_NAME_NULL_PUBLIC_KEY	= ASM_NAME_CODEBASE_LASTMOD + 1,
	ASM_NAME_NULL_PUBLIC_KEY_TOKEN	= ASM_NAME_NULL_PUBLIC_KEY + 1,
	ASM_NAME_CUSTOM	= ASM_NAME_NULL_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NULL_CUSTOM	= ASM_NAME_CUSTOM + 1,
	ASM_NAME_MVID	= ASM_NAME_NULL_CUSTOM + 1,
	ASM_NAME_32_BIT_ONLY	= ASM_NAME_MVID + 1,
	ASM_NAME_MAX_PARAMS	= ASM_NAME_32_BIT_ONLY + 1
    } 	ASM_NAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0002
    {	ASM_BINDF_FORCE_CACHE_INSTALL	= 0x1,
	ASM_BINDF_RFS_INTEGRITY_CHECK	= 0x2,
	ASM_BINDF_RFS_MODULE_CHECK	= 0x4,
	ASM_BINDF_BINPATH_PROBE_ONLY	= 0x8,
	ASM_BINDF_SHARED_BINPATH_HINT	= 0x10
    } 	ASM_BIND_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0003
    {	ASM_DISPLAYF_VERSION	= 0x1,
	ASM_DISPLAYF_CULTURE	= 0x2,
	ASM_DISPLAYF_PUBLIC_KEY_TOKEN	= 0x4,
	ASM_DISPLAYF_PUBLIC_KEY	= 0x8,
	ASM_DISPLAYF_CUSTOM	= 0x10,
	ASM_DISPLAYF_PROCESSORARCHITECTURE	= 0x20,
	ASM_DISPLAYF_LANGUAGEID	= 0x40
    } 	ASM_DISPLAY_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0004
    {	ASM_CMPF_NAME	= 0x1,
	ASM_CMPF_MAJOR_VERSION	= 0x2,
	ASM_CMPF_MINOR_VERSION	= 0x4,
	ASM_CMPF_BUILD_NUMBER	= 0x8,
	ASM_CMPF_REVISION_NUMBER	= 0x10,
	ASM_CMPF_PUBLIC_KEY_TOKEN	= 0x20,
	ASM_CMPF_CULTURE	= 0x40,
	ASM_CMPF_CUSTOM	= 0x80,
	ASM_CMPF_ALL	= ASM_CMPF_NAME | ASM_CMPF_MAJOR_VERSION | ASM_CMPF_MINOR_VERSION | ASM_CMPF_REVISION_NUMBER | ASM_CMPF_BUILD_NUMBER | ASM_CMPF_PUBLIC_KEY_TOKEN | ASM_CMPF_CULTURE | ASM_CMPF_CUSTOM,
	ASM_CMPF_DEFAULT	= 0x100
    } 	ASM_CMP_FLAGS;


EXTERN_C const IID IID_IAssemblyName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")
    IAssemblyName : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finalize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ REFIID refIID,
            /* [in] */ IAssemblyBindSink *pAsmBindSink,
            /* [in] */ IApplicationContext *pApplicationContext,
            /* [in] */ LPCOLESTR szCodeBase,
            /* [in] */ LONGLONG llFlags,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyName **pName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyName * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *Finalize )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IAssemblyName * This,
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IAssemblyName * This,
            /* [in] */ REFIID refIID,
            /* [in] */ IAssemblyBindSink *pAsmBindSink,
            /* [in] */ IApplicationContext *pApplicationContext,
            /* [in] */ LPCOLESTR szCodeBase,
            /* [in] */ LONGLONG llFlags,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IAssemblyName * This,
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IAssemblyName * This,
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IAssemblyName * This,
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyName * This,
            /* [out] */ IAssemblyName **pName);
        
        END_INTERFACE
    } IAssemblyNameVtbl;

    interface IAssemblyName
    {
        CONST_VTBL struct IAssemblyNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyName_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyName_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyName_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyName_SetProperty(This,PropertyId,pvProperty,cbProperty)	\
    (This)->lpVtbl -> SetProperty(This,PropertyId,pvProperty,cbProperty)

#define IAssemblyName_GetProperty(This,PropertyId,pvProperty,pcbProperty)	\
    (This)->lpVtbl -> GetProperty(This,PropertyId,pvProperty,pcbProperty)

#define IAssemblyName_Finalize(This)	\
    (This)->lpVtbl -> Finalize(This)

#define IAssemblyName_GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)	\
    (This)->lpVtbl -> GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)

#define IAssemblyName_BindToObject(This,refIID,pAsmBindSink,pApplicationContext,szCodeBase,llFlags,pvReserved,cbReserved,ppv)	\
    (This)->lpVtbl -> BindToObject(This,refIID,pAsmBindSink,pApplicationContext,szCodeBase,llFlags,pvReserved,cbReserved,ppv)

#define IAssemblyName_GetName(This,lpcwBuffer,pwzName)	\
    (This)->lpVtbl -> GetName(This,lpcwBuffer,pwzName)

#define IAssemblyName_GetVersion(This,pdwVersionHi,pdwVersionLow)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersionHi,pdwVersionLow)

#define IAssemblyName_IsEqual(This,pName,dwCmpFlags)	\
    (This)->lpVtbl -> IsEqual(This,pName,dwCmpFlags)

#define IAssemblyName_Clone(This,pName)	\
    (This)->lpVtbl -> Clone(This,pName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyName_SetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [in] */ LPVOID pvProperty,
    /* [in] */ DWORD cbProperty);


void __RPC_STUB IAssemblyName_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [out] */ LPVOID pvProperty,
    /* [out][in] */ LPDWORD pcbProperty);


void __RPC_STUB IAssemblyName_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Finalize_Proxy( 
    IAssemblyName * This);


void __RPC_STUB IAssemblyName_Finalize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetDisplayName_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPOLESTR szDisplayName,
    /* [out][in] */ LPDWORD pccDisplayName,
    /* [in] */ DWORD dwDisplayFlags);


void __RPC_STUB IAssemblyName_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_BindToObject_Proxy( 
    IAssemblyName * This,
    /* [in] */ REFIID refIID,
    /* [in] */ IAssemblyBindSink *pAsmBindSink,
    /* [in] */ IApplicationContext *pApplicationContext,
    /* [in] */ LPCOLESTR szCodeBase,
    /* [in] */ LONGLONG llFlags,
    /* [in] */ LPVOID pvReserved,
    /* [in] */ DWORD cbReserved,
    /* [out] */ LPVOID *ppv);


void __RPC_STUB IAssemblyName_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetName_Proxy( 
    IAssemblyName * This,
    /* [out][in] */ LPDWORD lpcwBuffer,
    /* [out] */ WCHAR *pwzName);


void __RPC_STUB IAssemblyName_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetVersion_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPDWORD pdwVersionHi,
    /* [out] */ LPDWORD pdwVersionLow);


void __RPC_STUB IAssemblyName_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_IsEqual_Proxy( 
    IAssemblyName * This,
    /* [in] */ IAssemblyName *pName,
    /* [in] */ DWORD dwCmpFlags);


void __RPC_STUB IAssemblyName_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Clone_Proxy( 
    IAssemblyName * This,
    /* [out] */ IAssemblyName **pName);


void __RPC_STUB IAssemblyName_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyName_INTERFACE_DEFINED__ */


#ifndef __IApplicationContext_INTERFACE_DEFINED__
#define __IApplicationContext_INTERFACE_DEFINED__

/* interface IApplicationContext */
/* [unique][uuid][object][local] */ 

// App context configuration variables
#define ACTAG_APP_BASE_URL            L"APPBASE"
#define ACTAG_MACHINE_CONFIG          L"MACHINE_CONFIG"
#define ACTAG_APP_PRIVATE_BINPATH     L"PRIVATE_BINPATH"
#define ACTAG_APP_SHARED_BINPATH      L"SHARED_BINPATH"
#define ACTAG_APP_SNAPSHOT_ID         L"SNAPSHOT_ID"
#define ACTAG_APP_CONFIG_FILE         L"APP_CONFIG_FILE"
#define ACTAG_APP_ID                  L"APPLICATION_ID"
#define ACTAG_APP_SHADOW_COPY_DIRS    L"SHADOW_COPY_DIRS"
#define ACTAG_APP_DYNAMIC_BASE        L"DYNAMIC_BASE"
#define ACTAG_APP_CACHE_BASE          L"CACHE_BASE"
#define ACTAG_APP_NAME                L"APP_NAME"
#define ACTAG_DEV_PATH                L"DEV_PATH"
// App context flag overrides
#define ACTAG_FORCE_CACHE_INSTALL     L"FORCE_CACHE_INSTALL"
#define ACTAG_RFS_INTEGRITY_CHECK     L"RFS_INTEGRITY_CHECK"
#define ACTAG_RFS_MODULE_CHECK        L"RFS_MODULE_CHECK"
#define ACTAG_BINPATH_PROBE_ONLY      L"BINPATH_PROBE_ONLY"
typedef /* [unique] */ IApplicationContext *LPAPPLICATIONCONTEXT;

typedef /* [public] */ 
enum __MIDL_IApplicationContext_0001
    {	APP_CTX_FLAGS_INTERFACE	= 0x1
    } 	APP_FLAGS;


EXTERN_C const IID IID_IApplicationContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7c23ff90-33af-11d3-95da-00a024a85b51")
    IApplicationContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetContextNameObject( 
            /* [in] */ LPASSEMBLYNAME pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextNameObject( 
            /* [out] */ LPASSEMBLYNAME *ppName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ LPCOLESTR szName,
            /* [in] */ LPVOID pvValue,
            /* [in] */ DWORD cbValue,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ LPCOLESTR szName,
            /* [out] */ LPVOID pvValue,
            /* [out][in] */ LPDWORD pcbValue,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDynamicDirectory( 
            /* [out] */ LPWSTR wzDynamicDir,
            /* [out][in] */ LPDWORD pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppCacheDirectory( 
            /* [out] */ LPWSTR wzAppCacheDir,
            /* [out][in] */ LPDWORD pdwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IApplicationContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IApplicationContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IApplicationContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetContextNameObject )( 
            IApplicationContext * This,
            /* [in] */ LPASSEMBLYNAME pName);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextNameObject )( 
            IApplicationContext * This,
            /* [out] */ LPASSEMBLYNAME *ppName);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IApplicationContext * This,
            /* [in] */ LPCOLESTR szName,
            /* [in] */ LPVOID pvValue,
            /* [in] */ DWORD cbValue,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            IApplicationContext * This,
            /* [in] */ LPCOLESTR szName,
            /* [out] */ LPVOID pvValue,
            /* [out][in] */ LPDWORD pcbValue,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDynamicDirectory )( 
            IApplicationContext * This,
            /* [out] */ LPWSTR wzDynamicDir,
            /* [out][in] */ LPDWORD pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppCacheDirectory )( 
            IApplicationContext * This,
            /* [out] */ LPWSTR wzAppCacheDir,
            /* [out][in] */ LPDWORD pdwSize);
        
        END_INTERFACE
    } IApplicationContextVtbl;

    interface IApplicationContext
    {
        CONST_VTBL struct IApplicationContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApplicationContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApplicationContext_SetContextNameObject(This,pName)	\
    (This)->lpVtbl -> SetContextNameObject(This,pName)

#define IApplicationContext_GetContextNameObject(This,ppName)	\
    (This)->lpVtbl -> GetContextNameObject(This,ppName)

#define IApplicationContext_Set(This,szName,pvValue,cbValue,dwFlags)	\
    (This)->lpVtbl -> Set(This,szName,pvValue,cbValue,dwFlags)

#define IApplicationContext_Get(This,szName,pvValue,pcbValue,dwFlags)	\
    (This)->lpVtbl -> Get(This,szName,pvValue,pcbValue,dwFlags)

#define IApplicationContext_GetDynamicDirectory(This,wzDynamicDir,pdwSize)	\
    (This)->lpVtbl -> GetDynamicDirectory(This,wzDynamicDir,pdwSize)

#define IApplicationContext_GetAppCacheDirectory(This,wzAppCacheDir,pdwSize)	\
    (This)->lpVtbl -> GetAppCacheDirectory(This,wzAppCacheDir,pdwSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IApplicationContext_SetContextNameObject_Proxy( 
    IApplicationContext * This,
    /* [in] */ LPASSEMBLYNAME pName);


void __RPC_STUB IApplicationContext_SetContextNameObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_GetContextNameObject_Proxy( 
    IApplicationContext * This,
    /* [out] */ LPASSEMBLYNAME *ppName);


void __RPC_STUB IApplicationContext_GetContextNameObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_Set_Proxy( 
    IApplicationContext * This,
    /* [in] */ LPCOLESTR szName,
    /* [in] */ LPVOID pvValue,
    /* [in] */ DWORD cbValue,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IApplicationContext_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_Get_Proxy( 
    IApplicationContext * This,
    /* [in] */ LPCOLESTR szName,
    /* [out] */ LPVOID pvValue,
    /* [out][in] */ LPDWORD pcbValue,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IApplicationContext_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_GetDynamicDirectory_Proxy( 
    IApplicationContext * This,
    /* [out] */ LPWSTR wzDynamicDir,
    /* [out][in] */ LPDWORD pdwSize);


void __RPC_STUB IApplicationContext_GetDynamicDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IApplicationContext_GetAppCacheDirectory_Proxy( 
    IApplicationContext * This,
    /* [out] */ LPWSTR wzAppCacheDir,
    /* [out][in] */ LPDWORD pdwSize);


void __RPC_STUB IApplicationContext_GetAppCacheDirectory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApplicationContext_INTERFACE_DEFINED__ */


#ifndef __IAssembly_INTERFACE_DEFINED__
#define __IAssembly_INTERFACE_DEFINED__

/* interface IAssembly */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssembly *LPASSEMBLY;

typedef /* [public][public] */ 
enum __MIDL_IAssembly_0001
    {	ASMLOC_UNKNOWN	= 0,
	ASMLOC_GAC	= ASMLOC_UNKNOWN + 1,
	ASMLOC_DOWNLOAD_CACHE	= ASMLOC_GAC + 1,
	ASMLOC_RUN_FROM_SOURCE	= ASMLOC_DOWNLOAD_CACHE + 1
    } 	ASM_LOCATION;


EXTERN_C const IID IID_IAssembly;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ff08d7d4-04c2-11d3-94aa-00c04fc308ff")
    IAssembly : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyNameDef( 
            /* [out] */ IAssemblyName **ppAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextAssemblyNameRef( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyName **ppAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextAssemblyModule( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyModuleImport **ppModImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleByName( 
            /* [in] */ LPCOLESTR szModuleName,
            /* [out] */ IAssemblyModuleImport **ppModImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManifestModulePath( 
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyPath( 
            /* [size_is][out] */ LPOLESTR pStr,
            /* [out][in] */ LPDWORD lpcwBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyLocation( 
            /* [out] */ ASM_LOCATION *pAsmLocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssembly * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssembly * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssembly * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyNameDef )( 
            IAssembly * This,
            /* [out] */ IAssemblyName **ppAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssemblyNameRef )( 
            IAssembly * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyName **ppAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssemblyModule )( 
            IAssembly * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyModuleImport **ppModImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleByName )( 
            IAssembly * This,
            /* [in] */ LPCOLESTR szModuleName,
            /* [out] */ IAssemblyModuleImport **ppModImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestModulePath )( 
            IAssembly * This,
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyPath )( 
            IAssembly * This,
            /* [size_is][out] */ LPOLESTR pStr,
            /* [out][in] */ LPDWORD lpcwBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyLocation )( 
            IAssembly * This,
            /* [out] */ ASM_LOCATION *pAsmLocation);
        
        END_INTERFACE
    } IAssemblyVtbl;

    interface IAssembly
    {
        CONST_VTBL struct IAssemblyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssembly_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssembly_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssembly_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssembly_GetAssemblyNameDef(This,ppAssemblyName)	\
    (This)->lpVtbl -> GetAssemblyNameDef(This,ppAssemblyName)

#define IAssembly_GetNextAssemblyNameRef(This,nIndex,ppAssemblyName)	\
    (This)->lpVtbl -> GetNextAssemblyNameRef(This,nIndex,ppAssemblyName)

#define IAssembly_GetNextAssemblyModule(This,nIndex,ppModImport)	\
    (This)->lpVtbl -> GetNextAssemblyModule(This,nIndex,ppModImport)

#define IAssembly_GetModuleByName(This,szModuleName,ppModImport)	\
    (This)->lpVtbl -> GetModuleByName(This,szModuleName,ppModImport)

#define IAssembly_GetManifestModulePath(This,szModulePath,pccModulePath)	\
    (This)->lpVtbl -> GetManifestModulePath(This,szModulePath,pccModulePath)

#define IAssembly_GetAssemblyPath(This,pStr,lpcwBuffer)	\
    (This)->lpVtbl -> GetAssemblyPath(This,pStr,lpcwBuffer)

#define IAssembly_GetAssemblyLocation(This,pAsmLocation)	\
    (This)->lpVtbl -> GetAssemblyLocation(This,pAsmLocation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssembly_GetAssemblyNameDef_Proxy( 
    IAssembly * This,
    /* [out] */ IAssemblyName **ppAssemblyName);


void __RPC_STUB IAssembly_GetAssemblyNameDef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetNextAssemblyNameRef_Proxy( 
    IAssembly * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IAssemblyName **ppAssemblyName);


void __RPC_STUB IAssembly_GetNextAssemblyNameRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetNextAssemblyModule_Proxy( 
    IAssembly * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IAssemblyModuleImport **ppModImport);


void __RPC_STUB IAssembly_GetNextAssemblyModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetModuleByName_Proxy( 
    IAssembly * This,
    /* [in] */ LPCOLESTR szModuleName,
    /* [out] */ IAssemblyModuleImport **ppModImport);


void __RPC_STUB IAssembly_GetModuleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetManifestModulePath_Proxy( 
    IAssembly * This,
    /* [size_is][out] */ LPOLESTR szModulePath,
    /* [out][in] */ LPDWORD pccModulePath);


void __RPC_STUB IAssembly_GetManifestModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetAssemblyPath_Proxy( 
    IAssembly * This,
    /* [size_is][out] */ LPOLESTR pStr,
    /* [out][in] */ LPDWORD lpcwBuffer);


void __RPC_STUB IAssembly_GetAssemblyPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssembly_GetAssemblyLocation_Proxy( 
    IAssembly * This,
    /* [out] */ ASM_LOCATION *pAsmLocation);


void __RPC_STUB IAssembly_GetAssemblyLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssembly_INTERFACE_DEFINED__ */


#ifndef __IAssemblyBindSink_INTERFACE_DEFINED__
#define __IAssemblyBindSink_INTERFACE_DEFINED__

/* interface IAssemblyBindSink */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyBindSink *LPASSEMBLY_BIND_SINK;

typedef /* [public] */ 
enum __MIDL_IAssemblyBindSink_0001
    {	ASM_NOTIFICATION_START	= 0,
	ASM_NOTIFICATION_PROGRESS	= ASM_NOTIFICATION_START + 1,
	ASM_NOTIFICATION_SUSPEND	= ASM_NOTIFICATION_PROGRESS + 1,
	ASM_NOTIFICATION_ATTEMPT_NEXT_CODEBASE	= ASM_NOTIFICATION_SUSPEND + 1,
	ASM_NOTIFICATION_BIND_LOG	= ASM_NOTIFICATION_ATTEMPT_NEXT_CODEBASE + 1,
	ASM_NOTIFICATION_DONE	= ASM_NOTIFICATION_BIND_LOG + 1
    } 	ASM_NOTIFICATION;


EXTERN_C const IID IID_IAssemblyBindSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("af0bc960-0b9a-11d3-95ca-00a024a85b51")
    IAssemblyBindSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnProgress( 
            /* [in] */ DWORD dwNotification,
            /* [in] */ HRESULT hrNotification,
            /* [in] */ LPCWSTR szNotification,
            /* [in] */ DWORD dwProgress,
            /* [in] */ DWORD dwProgressMax,
            /* [in] */ IUnknown *pUnk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyBindSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyBindSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyBindSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyBindSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnProgress )( 
            IAssemblyBindSink * This,
            /* [in] */ DWORD dwNotification,
            /* [in] */ HRESULT hrNotification,
            /* [in] */ LPCWSTR szNotification,
            /* [in] */ DWORD dwProgress,
            /* [in] */ DWORD dwProgressMax,
            /* [in] */ IUnknown *pUnk);
        
        END_INTERFACE
    } IAssemblyBindSinkVtbl;

    interface IAssemblyBindSink
    {
        CONST_VTBL struct IAssemblyBindSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyBindSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyBindSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyBindSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyBindSink_OnProgress(This,dwNotification,hrNotification,szNotification,dwProgress,dwProgressMax,pUnk)	\
    (This)->lpVtbl -> OnProgress(This,dwNotification,hrNotification,szNotification,dwProgress,dwProgressMax,pUnk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyBindSink_OnProgress_Proxy( 
    IAssemblyBindSink * This,
    /* [in] */ DWORD dwNotification,
    /* [in] */ HRESULT hrNotification,
    /* [in] */ LPCWSTR szNotification,
    /* [in] */ DWORD dwProgress,
    /* [in] */ DWORD dwProgressMax,
    /* [in] */ IUnknown *pUnk);


void __RPC_STUB IAssemblyBindSink_OnProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyBindSink_INTERFACE_DEFINED__ */


#ifndef __IAssemblyBinding_INTERFACE_DEFINED__
#define __IAssemblyBinding_INTERFACE_DEFINED__

/* interface IAssemblyBinding */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyBinding *LPASSEMBLY_BINDINDING;


EXTERN_C const IID IID_IAssemblyBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cfe52a80-12bd-11d3-95ca-00a024a85b51")
    IAssemblyBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Control( 
            /* [in] */ HRESULT hrControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoDefaultUI( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *Control )( 
            IAssemblyBinding * This,
            /* [in] */ HRESULT hrControl);
        
        HRESULT ( STDMETHODCALLTYPE *DoDefaultUI )( 
            IAssemblyBinding * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwFlags);
        
        END_INTERFACE
    } IAssemblyBindingVtbl;

    interface IAssemblyBinding
    {
        CONST_VTBL struct IAssemblyBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyBinding_Control(This,hrControl)	\
    (This)->lpVtbl -> Control(This,hrControl)

#define IAssemblyBinding_DoDefaultUI(This,hWnd,dwFlags)	\
    (This)->lpVtbl -> DoDefaultUI(This,hWnd,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyBinding_Control_Proxy( 
    IAssemblyBinding * This,
    /* [in] */ HRESULT hrControl);


void __RPC_STUB IAssemblyBinding_Control_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyBinding_DoDefaultUI_Proxy( 
    IAssemblyBinding * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAssemblyBinding_DoDefaultUI_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyBinding_INTERFACE_DEFINED__ */


#ifndef __IFusionBindLog_INTERFACE_DEFINED__
#define __IFusionBindLog_INTERFACE_DEFINED__

/* interface IFusionBindLog */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IFusionBindLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("67E9F87D-8B8A-4a90-9D3E-85ED5B2DCC83")
    IFusionBindLog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetResultCode( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBindLog( 
            /* [in] */ DWORD dwDetailLevel,
            /* [out] */ LPSTR pszDebugLog,
            /* [out][in] */ DWORD *pcbDebugLog) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFusionBindLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFusionBindLog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFusionBindLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFusionBindLog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResultCode )( 
            IFusionBindLog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindLog )( 
            IFusionBindLog * This,
            /* [in] */ DWORD dwDetailLevel,
            /* [out] */ LPSTR pszDebugLog,
            /* [out][in] */ DWORD *pcbDebugLog);
        
        END_INTERFACE
    } IFusionBindLogVtbl;

    interface IFusionBindLog
    {
        CONST_VTBL struct IFusionBindLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFusionBindLog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFusionBindLog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFusionBindLog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFusionBindLog_GetResultCode(This)	\
    (This)->lpVtbl -> GetResultCode(This)

#define IFusionBindLog_GetBindLog(This,dwDetailLevel,pszDebugLog,pcbDebugLog)	\
    (This)->lpVtbl -> GetBindLog(This,dwDetailLevel,pszDebugLog,pcbDebugLog)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFusionBindLog_GetResultCode_Proxy( 
    IFusionBindLog * This);


void __RPC_STUB IFusionBindLog_GetResultCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFusionBindLog_GetBindLog_Proxy( 
    IFusionBindLog * This,
    /* [in] */ DWORD dwDetailLevel,
    /* [out] */ LPSTR pszDebugLog,
    /* [out][in] */ DWORD *pcbDebugLog);


void __RPC_STUB IFusionBindLog_GetBindLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFusionBindLog_INTERFACE_DEFINED__ */


#ifndef __IAssemblyManifestImport_INTERFACE_DEFINED__
#define __IAssemblyManifestImport_INTERFACE_DEFINED__

/* interface IAssemblyManifestImport */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyManifestImport *LPASSEMBLY_MANIFEST_IMPORT;


EXTERN_C const IID IID_IAssemblyManifestImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("de9a68ba-0fa2-11d3-94aa-00c04fc308ff")
    IAssemblyManifestImport : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyNameDef( 
            /* [out] */ IAssemblyName **ppAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextAssemblyNameRef( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyName **ppAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNextAssemblyModule( 
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyModuleImport **ppImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleByName( 
            /* [in] */ LPCOLESTR szModuleName,
            /* [out] */ IAssemblyModuleImport **ppModImport) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManifestModulePath( 
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyManifestImportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyManifestImport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyManifestImport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyManifestImport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyNameDef )( 
            IAssemblyManifestImport * This,
            /* [out] */ IAssemblyName **ppAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssemblyNameRef )( 
            IAssemblyManifestImport * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyName **ppAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssemblyModule )( 
            IAssemblyManifestImport * This,
            /* [in] */ DWORD nIndex,
            /* [out] */ IAssemblyModuleImport **ppImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleByName )( 
            IAssemblyManifestImport * This,
            /* [in] */ LPCOLESTR szModuleName,
            /* [out] */ IAssemblyModuleImport **ppModImport);
        
        HRESULT ( STDMETHODCALLTYPE *GetManifestModulePath )( 
            IAssemblyManifestImport * This,
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath);
        
        END_INTERFACE
    } IAssemblyManifestImportVtbl;

    interface IAssemblyManifestImport
    {
        CONST_VTBL struct IAssemblyManifestImportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyManifestImport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyManifestImport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyManifestImport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyManifestImport_GetAssemblyNameDef(This,ppAssemblyName)	\
    (This)->lpVtbl -> GetAssemblyNameDef(This,ppAssemblyName)

#define IAssemblyManifestImport_GetNextAssemblyNameRef(This,nIndex,ppAssemblyName)	\
    (This)->lpVtbl -> GetNextAssemblyNameRef(This,nIndex,ppAssemblyName)

#define IAssemblyManifestImport_GetNextAssemblyModule(This,nIndex,ppImport)	\
    (This)->lpVtbl -> GetNextAssemblyModule(This,nIndex,ppImport)

#define IAssemblyManifestImport_GetModuleByName(This,szModuleName,ppModImport)	\
    (This)->lpVtbl -> GetModuleByName(This,szModuleName,ppModImport)

#define IAssemblyManifestImport_GetManifestModulePath(This,szModulePath,pccModulePath)	\
    (This)->lpVtbl -> GetManifestModulePath(This,szModulePath,pccModulePath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetAssemblyNameDef_Proxy( 
    IAssemblyManifestImport * This,
    /* [out] */ IAssemblyName **ppAssemblyName);


void __RPC_STUB IAssemblyManifestImport_GetAssemblyNameDef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetNextAssemblyNameRef_Proxy( 
    IAssemblyManifestImport * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IAssemblyName **ppAssemblyName);


void __RPC_STUB IAssemblyManifestImport_GetNextAssemblyNameRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetNextAssemblyModule_Proxy( 
    IAssemblyManifestImport * This,
    /* [in] */ DWORD nIndex,
    /* [out] */ IAssemblyModuleImport **ppImport);


void __RPC_STUB IAssemblyManifestImport_GetNextAssemblyModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetModuleByName_Proxy( 
    IAssemblyManifestImport * This,
    /* [in] */ LPCOLESTR szModuleName,
    /* [out] */ IAssemblyModuleImport **ppModImport);


void __RPC_STUB IAssemblyManifestImport_GetModuleByName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyManifestImport_GetManifestModulePath_Proxy( 
    IAssemblyManifestImport * This,
    /* [size_is][out] */ LPOLESTR szModulePath,
    /* [out][in] */ LPDWORD pccModulePath);


void __RPC_STUB IAssemblyManifestImport_GetManifestModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyManifestImport_INTERFACE_DEFINED__ */


#ifndef __IAssemblyModuleImport_INTERFACE_DEFINED__
#define __IAssemblyModuleImport_INTERFACE_DEFINED__

/* interface IAssemblyModuleImport */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyModuleImport *LPASSEMBLY_MODULE_IMPORT;


EXTERN_C const IID IID_IAssemblyModuleImport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("da0cd4b0-1117-11d3-95ca-00a024a85b51")
    IAssemblyModuleImport : public IStream
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModuleName( 
            /* [size_is][out] */ LPOLESTR szModuleName,
            /* [out][in] */ LPDWORD pccModuleName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHashAlgId( 
            /* [out] */ LPDWORD pdwHashAlgId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHashValue( 
            /* [size_is][out] */ BYTE *pbHashValue,
            /* [out][in] */ LPDWORD pcbHashValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [out] */ LPDWORD pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModulePath( 
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath) = 0;
        
        virtual BOOL STDMETHODCALLTYPE IsAvailable( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToObject( 
            /* [in] */ IAssemblyBindSink *pBindSink,
            /* [in] */ IApplicationContext *pAppCtx,
            /* [in] */ LONGLONG llFlags,
            /* [out] */ LPVOID *ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyModuleImportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyModuleImport * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyModuleImport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyModuleImport * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IAssemblyModuleImport * This,
            /* [length_is][size_is][out] */ void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IAssemblyModuleImport * This,
            /* [size_is][in] */ const void *pv,
            /* [in] */ ULONG cb,
            /* [out] */ ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IAssemblyModuleImport * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [out] */ ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            IAssemblyModuleImport * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            IAssemblyModuleImport * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [out] */ ULARGE_INTEGER *pcbRead,
            /* [out] */ ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IAssemblyModuleImport * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            IAssemblyModuleImport * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            IAssemblyModuleImport * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            IAssemblyModuleImport * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            IAssemblyModuleImport * This,
            /* [out] */ STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyModuleImport * This,
            /* [out] */ IStream **ppstm);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleName )( 
            IAssemblyModuleImport * This,
            /* [size_is][out] */ LPOLESTR szModuleName,
            /* [out][in] */ LPDWORD pccModuleName);
        
        HRESULT ( STDMETHODCALLTYPE *GetHashAlgId )( 
            IAssemblyModuleImport * This,
            /* [out] */ LPDWORD pdwHashAlgId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHashValue )( 
            IAssemblyModuleImport * This,
            /* [size_is][out] */ BYTE *pbHashValue,
            /* [out][in] */ LPDWORD pcbHashValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IAssemblyModuleImport * This,
            /* [out] */ LPDWORD pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetModulePath )( 
            IAssemblyModuleImport * This,
            /* [size_is][out] */ LPOLESTR szModulePath,
            /* [out][in] */ LPDWORD pccModulePath);
        
        BOOL ( STDMETHODCALLTYPE *IsAvailable )( 
            IAssemblyModuleImport * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindToObject )( 
            IAssemblyModuleImport * This,
            /* [in] */ IAssemblyBindSink *pBindSink,
            /* [in] */ IApplicationContext *pAppCtx,
            /* [in] */ LONGLONG llFlags,
            /* [out] */ LPVOID *ppv);
        
        END_INTERFACE
    } IAssemblyModuleImportVtbl;

    interface IAssemblyModuleImport
    {
        CONST_VTBL struct IAssemblyModuleImportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyModuleImport_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyModuleImport_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyModuleImport_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyModuleImport_Read(This,pv,cb,pcbRead)	\
    (This)->lpVtbl -> Read(This,pv,cb,pcbRead)

#define IAssemblyModuleImport_Write(This,pv,cb,pcbWritten)	\
    (This)->lpVtbl -> Write(This,pv,cb,pcbWritten)


#define IAssemblyModuleImport_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition)

#define IAssemblyModuleImport_SetSize(This,libNewSize)	\
    (This)->lpVtbl -> SetSize(This,libNewSize)

#define IAssemblyModuleImport_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten)

#define IAssemblyModuleImport_Commit(This,grfCommitFlags)	\
    (This)->lpVtbl -> Commit(This,grfCommitFlags)

#define IAssemblyModuleImport_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#define IAssemblyModuleImport_LockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType)

#define IAssemblyModuleImport_UnlockRegion(This,libOffset,cb,dwLockType)	\
    (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType)

#define IAssemblyModuleImport_Stat(This,pstatstg,grfStatFlag)	\
    (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag)

#define IAssemblyModuleImport_Clone(This,ppstm)	\
    (This)->lpVtbl -> Clone(This,ppstm)


#define IAssemblyModuleImport_GetModuleName(This,szModuleName,pccModuleName)	\
    (This)->lpVtbl -> GetModuleName(This,szModuleName,pccModuleName)

#define IAssemblyModuleImport_GetHashAlgId(This,pdwHashAlgId)	\
    (This)->lpVtbl -> GetHashAlgId(This,pdwHashAlgId)

#define IAssemblyModuleImport_GetHashValue(This,pbHashValue,pcbHashValue)	\
    (This)->lpVtbl -> GetHashValue(This,pbHashValue,pcbHashValue)

#define IAssemblyModuleImport_GetFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetFlags(This,pdwFlags)

#define IAssemblyModuleImport_GetModulePath(This,szModulePath,pccModulePath)	\
    (This)->lpVtbl -> GetModulePath(This,szModulePath,pccModulePath)

#define IAssemblyModuleImport_IsAvailable(This)	\
    (This)->lpVtbl -> IsAvailable(This)

#define IAssemblyModuleImport_BindToObject(This,pBindSink,pAppCtx,llFlags,ppv)	\
    (This)->lpVtbl -> BindToObject(This,pBindSink,pAppCtx,llFlags,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetModuleName_Proxy( 
    IAssemblyModuleImport * This,
    /* [size_is][out] */ LPOLESTR szModuleName,
    /* [out][in] */ LPDWORD pccModuleName);


void __RPC_STUB IAssemblyModuleImport_GetModuleName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetHashAlgId_Proxy( 
    IAssemblyModuleImport * This,
    /* [out] */ LPDWORD pdwHashAlgId);


void __RPC_STUB IAssemblyModuleImport_GetHashAlgId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetHashValue_Proxy( 
    IAssemblyModuleImport * This,
    /* [size_is][out] */ BYTE *pbHashValue,
    /* [out][in] */ LPDWORD pcbHashValue);


void __RPC_STUB IAssemblyModuleImport_GetHashValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetFlags_Proxy( 
    IAssemblyModuleImport * This,
    /* [out] */ LPDWORD pdwFlags);


void __RPC_STUB IAssemblyModuleImport_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_GetModulePath_Proxy( 
    IAssemblyModuleImport * This,
    /* [size_is][out] */ LPOLESTR szModulePath,
    /* [out][in] */ LPDWORD pccModulePath);


void __RPC_STUB IAssemblyModuleImport_GetModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE IAssemblyModuleImport_IsAvailable_Proxy( 
    IAssemblyModuleImport * This);


void __RPC_STUB IAssemblyModuleImport_IsAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyModuleImport_BindToObject_Proxy( 
    IAssemblyModuleImport * This,
    /* [in] */ IAssemblyBindSink *pBindSink,
    /* [in] */ IApplicationContext *pAppCtx,
    /* [in] */ LONGLONG llFlags,
    /* [out] */ LPVOID *ppv);


void __RPC_STUB IAssemblyModuleImport_BindToObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyModuleImport_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCacheItem_INTERFACE_DEFINED__
#define __IAssemblyCacheItem_INTERFACE_DEFINED__

/* interface IAssemblyCacheItem */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyCacheItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCacheItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortItem( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCacheItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCacheItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCacheItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *AbortItem )( 
            IAssemblyCacheItem * This);
        
        END_INTERFACE
    } IAssemblyCacheItemVtbl;

    interface IAssemblyCacheItem
    {
        CONST_VTBL struct IAssemblyCacheItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCacheItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCacheItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCacheItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCacheItem_CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)	\
    (This)->lpVtbl -> CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)

#define IAssemblyCacheItem_Commit(This,dwFlags,pulDisposition)	\
    (This)->lpVtbl -> Commit(This,dwFlags,pulDisposition)

#define IAssemblyCacheItem_AbortItem(This)	\
    (This)->lpVtbl -> AbortItem(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_CreateStream_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszStreamName,
    /* [in] */ DWORD dwFormat,
    /* [in] */ DWORD dwFormatFlags,
    /* [out] */ IStream **ppIStream,
    /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);


void __RPC_STUB IAssemblyCacheItem_CreateStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_Commit_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCacheItem_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_AbortItem_Proxy( 
    IAssemblyCacheItem * This);


void __RPC_STUB IAssemblyCacheItem_AbortItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCacheItem_INTERFACE_DEFINED__ */


#ifndef __IAssemblyEnum_INTERFACE_DEFINED__
#define __IAssemblyEnum_INTERFACE_DEFINED__

/* interface IAssemblyEnum */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21b8916c-f28e-11d2-a473-00c04f8ef448")
    IAssemblyEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNextAssembly( 
            /* [out] */ IApplicationContext **ppAppCtx,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyEnum **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssembly )( 
            IAssemblyEnum * This,
            /* [out] */ IApplicationContext **ppAppCtx,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyEnum * This,
            /* [out] */ IAssemblyEnum **ppEnum);
        
        END_INTERFACE
    } IAssemblyEnumVtbl;

    interface IAssemblyEnum
    {
        CONST_VTBL struct IAssemblyEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyEnum_GetNextAssembly(This,ppAppCtx,ppName,dwFlags)	\
    (This)->lpVtbl -> GetNextAssembly(This,ppAppCtx,ppName,dwFlags)

#define IAssemblyEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IAssemblyEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyEnum_GetNextAssembly_Proxy( 
    IAssemblyEnum * This,
    /* [out] */ IApplicationContext **ppAppCtx,
    /* [out] */ IAssemblyName **ppName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAssemblyEnum_GetNextAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Reset_Proxy( 
    IAssemblyEnum * This);


void __RPC_STUB IAssemblyEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Clone_Proxy( 
    IAssemblyEnum * This,
    /* [out] */ IAssemblyEnum **ppEnum);


void __RPC_STUB IAssemblyEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyEnum_INTERFACE_DEFINED__ */


#ifndef __IAssemblyScavenger_INTERFACE_DEFINED__
#define __IAssemblyScavenger_INTERFACE_DEFINED__

/* interface IAssemblyScavenger */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyScavenger;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21b8916c-f28e-11d2-a473-00ccff8ef448")
    IAssemblyScavenger : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ScavengeAssemblyCache( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCacheDiskQuotas( 
            /* [out] */ DWORD *pdwZapQuotaInGAC,
            /* [out] */ DWORD *pdwDownloadQuotaAdmin,
            /* [out] */ DWORD *pdwDownloadQuotaUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCacheDiskQuotas( 
            /* [in] */ DWORD dwZapQuotaInGAC,
            /* [in] */ DWORD dwDownloadQuotaAdmin,
            /* [in] */ DWORD dwDownloadQuotaUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentCacheUsage( 
            /* [out] */ DWORD *dwZapUsage,
            /* [out] */ DWORD *dwDownloadUsage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyScavengerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyScavenger * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyScavenger * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyScavenger * This);
        
        HRESULT ( STDMETHODCALLTYPE *ScavengeAssemblyCache )( 
            IAssemblyScavenger * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCacheDiskQuotas )( 
            IAssemblyScavenger * This,
            /* [out] */ DWORD *pdwZapQuotaInGAC,
            /* [out] */ DWORD *pdwDownloadQuotaAdmin,
            /* [out] */ DWORD *pdwDownloadQuotaUser);
        
        HRESULT ( STDMETHODCALLTYPE *SetCacheDiskQuotas )( 
            IAssemblyScavenger * This,
            /* [in] */ DWORD dwZapQuotaInGAC,
            /* [in] */ DWORD dwDownloadQuotaAdmin,
            /* [in] */ DWORD dwDownloadQuotaUser);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentCacheUsage )( 
            IAssemblyScavenger * This,
            /* [out] */ DWORD *dwZapUsage,
            /* [out] */ DWORD *dwDownloadUsage);
        
        END_INTERFACE
    } IAssemblyScavengerVtbl;

    interface IAssemblyScavenger
    {
        CONST_VTBL struct IAssemblyScavengerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyScavenger_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyScavenger_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyScavenger_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyScavenger_ScavengeAssemblyCache(This)	\
    (This)->lpVtbl -> ScavengeAssemblyCache(This)

#define IAssemblyScavenger_GetCacheDiskQuotas(This,pdwZapQuotaInGAC,pdwDownloadQuotaAdmin,pdwDownloadQuotaUser)	\
    (This)->lpVtbl -> GetCacheDiskQuotas(This,pdwZapQuotaInGAC,pdwDownloadQuotaAdmin,pdwDownloadQuotaUser)

#define IAssemblyScavenger_SetCacheDiskQuotas(This,dwZapQuotaInGAC,dwDownloadQuotaAdmin,dwDownloadQuotaUser)	\
    (This)->lpVtbl -> SetCacheDiskQuotas(This,dwZapQuotaInGAC,dwDownloadQuotaAdmin,dwDownloadQuotaUser)

#define IAssemblyScavenger_GetCurrentCacheUsage(This,dwZapUsage,dwDownloadUsage)	\
    (This)->lpVtbl -> GetCurrentCacheUsage(This,dwZapUsage,dwDownloadUsage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyScavenger_ScavengeAssemblyCache_Proxy( 
    IAssemblyScavenger * This);


void __RPC_STUB IAssemblyScavenger_ScavengeAssemblyCache_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyScavenger_GetCacheDiskQuotas_Proxy( 
    IAssemblyScavenger * This,
    /* [out] */ DWORD *pdwZapQuotaInGAC,
    /* [out] */ DWORD *pdwDownloadQuotaAdmin,
    /* [out] */ DWORD *pdwDownloadQuotaUser);


void __RPC_STUB IAssemblyScavenger_GetCacheDiskQuotas_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyScavenger_SetCacheDiskQuotas_Proxy( 
    IAssemblyScavenger * This,
    /* [in] */ DWORD dwZapQuotaInGAC,
    /* [in] */ DWORD dwDownloadQuotaAdmin,
    /* [in] */ DWORD dwDownloadQuotaUser);


void __RPC_STUB IAssemblyScavenger_SetCacheDiskQuotas_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyScavenger_GetCurrentCacheUsage_Proxy( 
    IAssemblyScavenger * This,
    /* [out] */ DWORD *dwZapUsage,
    /* [out] */ DWORD *dwDownloadUsage);


void __RPC_STUB IAssemblyScavenger_GetCurrentCacheUsage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyScavenger_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCache_INTERFACE_DEFINED__
#define __IAssemblyCache_INTERFACE_DEFINED__

/* interface IAssemblyCache */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e707dcde-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UninstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ PVOID pvReserved,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAssemblyInfo( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyCacheItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyScavenger( 
            /* [out] */ IAssemblyScavenger **ppAsmScavenger) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ PVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCache * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *UninstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ PVOID pvReserved,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAssemblyInfo )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyCacheItem )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyScavenger )( 
            IAssemblyCache * This,
            /* [out] */ IAssemblyScavenger **ppAsmScavenger);
        
        HRESULT ( STDMETHODCALLTYPE *InstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ PVOID pvReserved);
        
        END_INTERFACE
    } IAssemblyCacheVtbl;

    interface IAssemblyCache
    {
        CONST_VTBL struct IAssemblyCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCache_UninstallAssembly(This,dwFlags,pszAssemblyName,pvReserved,pulDisposition)	\
    (This)->lpVtbl -> UninstallAssembly(This,dwFlags,pszAssemblyName,pvReserved,pulDisposition)

#define IAssemblyCache_QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)	\
    (This)->lpVtbl -> QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)

#define IAssemblyCache_CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)	\
    (This)->lpVtbl -> CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)

#define IAssemblyCache_CreateAssemblyScavenger(This,ppAsmScavenger)	\
    (This)->lpVtbl -> CreateAssemblyScavenger(This,ppAsmScavenger)

#define IAssemblyCache_InstallAssembly(This,dwFlags,pszManifestFilePath,pvReserved)	\
    (This)->lpVtbl -> InstallAssembly(This,dwFlags,pszManifestFilePath,pvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCache_UninstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [in] */ PVOID pvReserved,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCache_UninstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_QueryAssemblyInfo_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);


void __RPC_STUB IAssemblyCache_QueryAssemblyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyCacheItem_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ PVOID pvReserved,
    /* [out] */ IAssemblyCacheItem **ppAsmItem,
    /* [optional][in] */ LPCWSTR pszAssemblyName);


void __RPC_STUB IAssemblyCache_CreateAssemblyCacheItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyScavenger_Proxy( 
    IAssemblyCache * This,
    /* [out] */ IAssemblyScavenger **ppAsmScavenger);


void __RPC_STUB IAssemblyCache_CreateAssemblyScavenger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_InstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszManifestFilePath,
    /* [in] */ PVOID pvReserved);


void __RPC_STUB IAssemblyCache_InstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCache_INTERFACE_DEFINED__ */


#ifndef __IHistoryAssembly_INTERFACE_DEFINED__
#define __IHistoryAssembly_INTERFACE_DEFINED__

/* interface IHistoryAssembly */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHistoryAssembly;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e6096a07-e188-4a49-8d50-2a0172a0d205")
    IHistoryAssembly : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyName( 
            /* [out] */ LPWSTR wzAsmName,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPublicKeyToken( 
            /* [out] */ LPWSTR wzPublicKeyToken,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCulture( 
            /* [out] */ LPWSTR wzCulture,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReferenceVersion( 
            /* [out] */ LPWSTR wzVerRef,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivationDate( 
            /* [out] */ LPWSTR wzActivationDate,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppCfgVersion( 
            /* [out] */ LPWSTR pwzVerAppCfg,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPublisherCfgVersion( 
            /* [out] */ LPWSTR pwzVerPublisherCfg,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAdminCfgVersion( 
            /* [out] */ LPWSTR pwzAdminCfg,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHistoryAssemblyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHistoryAssembly * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHistoryAssembly * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHistoryAssembly * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyName )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzAsmName,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPublicKeyToken )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzPublicKeyToken,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCulture )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzCulture,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetReferenceVersion )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzVerRef,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationDate )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR wzActivationDate,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppCfgVersion )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR pwzVerAppCfg,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetPublisherCfgVersion )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR pwzVerPublisherCfg,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdminCfgVersion )( 
            IHistoryAssembly * This,
            /* [out] */ LPWSTR pwzAdminCfg,
            /* [out][in] */ DWORD *pdwSize);
        
        END_INTERFACE
    } IHistoryAssemblyVtbl;

    interface IHistoryAssembly
    {
        CONST_VTBL struct IHistoryAssemblyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHistoryAssembly_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHistoryAssembly_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHistoryAssembly_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHistoryAssembly_GetAssemblyName(This,wzAsmName,pdwSize)	\
    (This)->lpVtbl -> GetAssemblyName(This,wzAsmName,pdwSize)

#define IHistoryAssembly_GetPublicKeyToken(This,wzPublicKeyToken,pdwSize)	\
    (This)->lpVtbl -> GetPublicKeyToken(This,wzPublicKeyToken,pdwSize)

#define IHistoryAssembly_GetCulture(This,wzCulture,pdwSize)	\
    (This)->lpVtbl -> GetCulture(This,wzCulture,pdwSize)

#define IHistoryAssembly_GetReferenceVersion(This,wzVerRef,pdwSize)	\
    (This)->lpVtbl -> GetReferenceVersion(This,wzVerRef,pdwSize)

#define IHistoryAssembly_GetActivationDate(This,wzActivationDate,pdwSize)	\
    (This)->lpVtbl -> GetActivationDate(This,wzActivationDate,pdwSize)

#define IHistoryAssembly_GetAppCfgVersion(This,pwzVerAppCfg,pdwSize)	\
    (This)->lpVtbl -> GetAppCfgVersion(This,pwzVerAppCfg,pdwSize)

#define IHistoryAssembly_GetPublisherCfgVersion(This,pwzVerPublisherCfg,pdwSize)	\
    (This)->lpVtbl -> GetPublisherCfgVersion(This,pwzVerPublisherCfg,pdwSize)

#define IHistoryAssembly_GetAdminCfgVersion(This,pwzAdminCfg,pdwSize)	\
    (This)->lpVtbl -> GetAdminCfgVersion(This,pwzAdminCfg,pdwSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetAssemblyName_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzAsmName,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetAssemblyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetPublicKeyToken_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzPublicKeyToken,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetPublicKeyToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetCulture_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzCulture,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetCulture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetReferenceVersion_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzVerRef,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetReferenceVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetActivationDate_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR wzActivationDate,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetActivationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetAppCfgVersion_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR pwzVerAppCfg,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetAppCfgVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetPublisherCfgVersion_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR pwzVerPublisherCfg,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetPublisherCfgVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryAssembly_GetAdminCfgVersion_Proxy( 
    IHistoryAssembly * This,
    /* [out] */ LPWSTR pwzAdminCfg,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryAssembly_GetAdminCfgVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHistoryAssembly_INTERFACE_DEFINED__ */


#ifndef __IHistoryReader_INTERFACE_DEFINED__
#define __IHistoryReader_INTERFACE_DEFINED__

/* interface IHistoryReader */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IHistoryReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1d23df4d-a1e2-4b8b-93d6-6ea3dc285a54")
    IHistoryReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFilePath( 
            /* [out] */ LPWSTR wzFilePath,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetApplicationName( 
            /* [out] */ LPWSTR wzAppName,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEXEModulePath( 
            /* [out] */ LPWSTR wzExePath,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumActivations( 
            /* [out] */ DWORD *pdwNumActivations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivationDate( 
            /* [in] */ DWORD dwIdx,
            /* [out] */ FILETIME *pftDate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRunTimeVersion( 
            /* [in] */ FILETIME *pftActivationDate,
            /* [out] */ LPWSTR wzRunTimeVersion,
            /* [out][in] */ DWORD *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumAssemblies( 
            /* [in] */ FILETIME *pftActivationDate,
            /* [out] */ DWORD *pdwNumAsms) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHistoryAssembly( 
            /* [in] */ FILETIME *pftActivationDate,
            /* [in] */ DWORD dwIdx,
            /* [out] */ IHistoryAssembly **ppHistAsm) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHistoryReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHistoryReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHistoryReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHistoryReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFilePath )( 
            IHistoryReader * This,
            /* [out] */ LPWSTR wzFilePath,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetApplicationName )( 
            IHistoryReader * This,
            /* [out] */ LPWSTR wzAppName,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetEXEModulePath )( 
            IHistoryReader * This,
            /* [out] */ LPWSTR wzExePath,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumActivations )( 
            IHistoryReader * This,
            /* [out] */ DWORD *pdwNumActivations);
        
        HRESULT ( STDMETHODCALLTYPE *GetActivationDate )( 
            IHistoryReader * This,
            /* [in] */ DWORD dwIdx,
            /* [out] */ FILETIME *pftDate);
        
        HRESULT ( STDMETHODCALLTYPE *GetRunTimeVersion )( 
            IHistoryReader * This,
            /* [in] */ FILETIME *pftActivationDate,
            /* [out] */ LPWSTR wzRunTimeVersion,
            /* [out][in] */ DWORD *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumAssemblies )( 
            IHistoryReader * This,
            /* [in] */ FILETIME *pftActivationDate,
            /* [out] */ DWORD *pdwNumAsms);
        
        HRESULT ( STDMETHODCALLTYPE *GetHistoryAssembly )( 
            IHistoryReader * This,
            /* [in] */ FILETIME *pftActivationDate,
            /* [in] */ DWORD dwIdx,
            /* [out] */ IHistoryAssembly **ppHistAsm);
        
        END_INTERFACE
    } IHistoryReaderVtbl;

    interface IHistoryReader
    {
        CONST_VTBL struct IHistoryReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHistoryReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHistoryReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHistoryReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHistoryReader_GetFilePath(This,wzFilePath,pdwSize)	\
    (This)->lpVtbl -> GetFilePath(This,wzFilePath,pdwSize)

#define IHistoryReader_GetApplicationName(This,wzAppName,pdwSize)	\
    (This)->lpVtbl -> GetApplicationName(This,wzAppName,pdwSize)

#define IHistoryReader_GetEXEModulePath(This,wzExePath,pdwSize)	\
    (This)->lpVtbl -> GetEXEModulePath(This,wzExePath,pdwSize)

#define IHistoryReader_GetNumActivations(This,pdwNumActivations)	\
    (This)->lpVtbl -> GetNumActivations(This,pdwNumActivations)

#define IHistoryReader_GetActivationDate(This,dwIdx,pftDate)	\
    (This)->lpVtbl -> GetActivationDate(This,dwIdx,pftDate)

#define IHistoryReader_GetRunTimeVersion(This,pftActivationDate,wzRunTimeVersion,pdwSize)	\
    (This)->lpVtbl -> GetRunTimeVersion(This,pftActivationDate,wzRunTimeVersion,pdwSize)

#define IHistoryReader_GetNumAssemblies(This,pftActivationDate,pdwNumAsms)	\
    (This)->lpVtbl -> GetNumAssemblies(This,pftActivationDate,pdwNumAsms)

#define IHistoryReader_GetHistoryAssembly(This,pftActivationDate,dwIdx,ppHistAsm)	\
    (This)->lpVtbl -> GetHistoryAssembly(This,pftActivationDate,dwIdx,ppHistAsm)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHistoryReader_GetFilePath_Proxy( 
    IHistoryReader * This,
    /* [out] */ LPWSTR wzFilePath,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryReader_GetFilePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetApplicationName_Proxy( 
    IHistoryReader * This,
    /* [out] */ LPWSTR wzAppName,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryReader_GetApplicationName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetEXEModulePath_Proxy( 
    IHistoryReader * This,
    /* [out] */ LPWSTR wzExePath,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryReader_GetEXEModulePath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetNumActivations_Proxy( 
    IHistoryReader * This,
    /* [out] */ DWORD *pdwNumActivations);


void __RPC_STUB IHistoryReader_GetNumActivations_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetActivationDate_Proxy( 
    IHistoryReader * This,
    /* [in] */ DWORD dwIdx,
    /* [out] */ FILETIME *pftDate);


void __RPC_STUB IHistoryReader_GetActivationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetRunTimeVersion_Proxy( 
    IHistoryReader * This,
    /* [in] */ FILETIME *pftActivationDate,
    /* [out] */ LPWSTR wzRunTimeVersion,
    /* [out][in] */ DWORD *pdwSize);


void __RPC_STUB IHistoryReader_GetRunTimeVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetNumAssemblies_Proxy( 
    IHistoryReader * This,
    /* [in] */ FILETIME *pftActivationDate,
    /* [out] */ DWORD *pdwNumAsms);


void __RPC_STUB IHistoryReader_GetNumAssemblies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHistoryReader_GetHistoryAssembly_Proxy( 
    IHistoryReader * This,
    /* [in] */ FILETIME *pftActivationDate,
    /* [in] */ DWORD dwIdx,
    /* [out] */ IHistoryAssembly **ppHistAsm);


void __RPC_STUB IHistoryReader_GetHistoryAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHistoryReader_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_fusion_0122 */
/* [local] */ 

STDAPI CreateHistoryReader(LPCWSTR wzFilePath, IHistoryReader **ppHistReader);
STDAPI LookupHistoryAssembly(LPCWSTR pwzFilePath, FILETIME *pftActivationDate, LPCWSTR pwzAsmName, LPCWSTR pwzPublicKeyToken, LPCWSTR wzCulture, LPCWSTR pwzVerRef, IHistoryAssembly **pHistAsm);
STDAPI GetHistoryFileDirectory(LPWSTR wzDir, DWORD *pdwSize);
STDAPI AddAssemblyToCacheW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow);
STDAPI AddAssemblyToCacheA(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);
STDAPI RemoveAssemblyFromCacheW(HWND hwnd, HINSTANCE hinst, LPWSTR lpszCmdLine, int nCmdShow);
STDAPI RemoveAssemblyFromCacheA(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);
STDAPI CreateAssemblyNameObject(LPASSEMBLYNAME *ppAssemblyNameObj, LPCWSTR szAssemblyName, DWORD dwFlags, LPVOID pvReserved);             
STDAPI CreateApplicationContext(IAssemblyName *pName, LPAPPLICATIONCONTEXT *ppCtx);             
STDAPI CreateAssemblyCache(IAssemblyCache **ppAsmCache, DWORD dwReserved); 
STDAPI CreateAssemblyEnum(IAssemblyEnum **pEnum, IApplicationContext *pAppCtx, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);      
STDAPI SetSchemaVersion(DWORD dwNewMinorVersion, DWORD dwCacheId, BOOL fIsNameRes); 
typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusion_0122_0001
    {	CANOF_PARSE_DISPLAY_NAME	= 0x1,
	CANOF_SET_DEFAULT_VALUES	= 0x2
    } 	CREATE_ASM_NAME_OBJ_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusion_0122_0002
    {	ASM_CACHE_ZAP	= 0x1,
	ASM_CACHE_GAC	= 0x2,
	ASM_CACHE_DOWNLOAD	= 0x4
    } 	ASM_CACHE_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusion_0122_0003
    {	SH_INIT_FOR_GLOBAL	= 0,
	SH_INIT_FOR_USER	= SH_INIT_FOR_GLOBAL + 1
    } 	SH_INIT_FLAGS;

#endif


extern RPC_IF_HANDLE __MIDL_itf_fusion_0122_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0122_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\darwin\tools\inc\pbt.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1995
*
*  TITLE:       PBT.H
*
*  VERSION:     1.0
*
*  DATE:        15 Jan 1994
*
*  Definitions for the Virtual Power Management Device.
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  15 Jan 1994 TCS Original implementation.
*
*******************************************************************************/

#ifndef _INC_PBT
#define _INC_PBT

#ifndef WM_POWERBROADCAST
#define WM_POWERBROADCAST               0x218
#endif

#define PBT_APMQUERYSUSPEND             0x0000
#define PBT_APMQUERYSTANDBY             0x0001

#define PBT_APMQUERYSUSPENDFAILED       0x0002
#define PBT_APMQUERYSTANDBYFAILED       0x0003

#define PBT_APMSUSPEND                  0x0004
#define PBT_APMSTANDBY                  0x0005

#define PBT_APMRESUMECRITICAL           0x0006
#define PBT_APMRESUMESUSPEND            0x0007
#define PBT_APMRESUMESTANDBY            0x0008

#define PBTF_APMRESUMEFROMFAILURE       0x00000001

#define PBT_APMBATTERYLOW               0x0009
#define PBT_APMPOWERSTATUSCHANGE        0x000A

#define PBT_APMOEMEVENT                 0x000B

#endif // _INC_PBT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\adpass.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Admin password page
//
// 2-4-98 sburns



#ifndef ADPASS_HPP_INCLUDED
#define ADPASS_HPP_INCLUDED



#include "page.hpp"
#include "PasswordEditBox.hpp"



class AdminPasswordPage : public DCPromoWizardPage
{
   public:

   AdminPasswordPage();

   protected:

   virtual ~AdminPasswordPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   AdminPasswordPage(const AdminPasswordPage&);
   const AdminPasswordPage& operator=(const AdminPasswordPage&);

   // NTRAID#NTBUG9-202238-2000/11/07-sburns
   
   PasswordEditBox password;
   PasswordEditBox confirm;
};



#endif   // ADPASS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\answerfile.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// answerfile reader object
//
// 12-15-97 sburns



#ifndef ANSWER_HPP_INCLUDED
#define ANSWER_HPP_INCLUDED



class AnswerFile
{
   public:

   explicit
   AnswerFile(const String& filename);

   ~AnswerFile();

   bool
   IsKeyPresent(
      const String& section,
      const String& key);

   String
   ReadKey(const String& section, const String& key);

   EncodedString
   EncodedReadKey(const String& section, const String& key);

   void
   WriteKey(const String& section, const String& key, const String& value);

   private:

   String filename;
};



#endif   // ANSWER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\adpass.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Admin password page
//
// 2-4-98 sburns



#include "headers.hxx"
#include "adpass.hpp"
#include "resource.h"
#include "state.hpp"
#include "ds.hpp"




AdminPasswordPage::AdminPasswordPage()
   :
   DCPromoWizardPage(
      IDD_ADMIN_PASSWORD,
      IDS_PASSWORD_PAGE_TITLE,
      IDS_PASSWORD_PAGE_SUBTITLE)
{
   LOG_CTOR(AdminPasswordPage);
}



AdminPasswordPage::~AdminPasswordPage()
{
   LOG_DTOR(AdminPasswordPage);
}



void
AdminPasswordPage::OnInit()
{
   LOG_FUNCTION(AdminPasswordPage::OnInit);

   // NTRAID#NTBUG9-202238-2000/11/07-sburns
   
   password.Init(Win::GetDlgItem(hwnd, IDC_PASSWORD));
   confirm.Init(Win::GetDlgItem(hwnd, IDC_CONFIRM));

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      EncodedString pwd =
         state.GetEncodedAnswerFileOption(State::OPTION_ADMIN_PASSWORD);

      Win::SetDlgItemText(hwnd, IDC_PASSWORD, pwd);
      Win::SetDlgItemText(hwnd, IDC_CONFIRM,  pwd);
   }
}


   
static
String
getPasswordMessage()
{
   LOG_FUNCTION(getPasswordMessage);

   State& state = State::GetInstance();
   unsigned id = IDS_ENTER_DOMAIN_ADMIN_PASSWORD;
   switch (state.GetOperation())
   {
      case State::FOREST:
      case State::TREE:
      case State::CHILD:
      {
         // do nothing, id is already set.
         break;
      }
      case State::ABORT_BDC_UPGRADE:
      case State::DEMOTE:
      {
         id = IDS_ENTER_LOCAL_ADMIN_PASSWORD;
         break;
      }
      case State::REPLICA:
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return String::load(id);
}



bool
AdminPasswordPage::OnSetActive()
{
   LOG_FUNCTION(AdminPasswordPage::OnSetActive);
   
   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      // fully-qualify the Validate call, as it is virtual...

      int nextPage = AdminPasswordPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   Win::SetDlgItemText(hwnd, IDC_MESSAGE, getPasswordMessage());

   return true;
}



int
AdminPasswordPage::Validate()
{
   LOG_FUNCTION(AdminPasswordPage::Validate);

   EncodedString password =
      Win::GetEncodedDlgItemText(hwnd, IDC_PASSWORD);
   EncodedString confirm =
      Win::GetEncodedDlgItemText(hwnd, IDC_CONFIRM);

   if (password != confirm)
   {
      String blank;
      Win::SetDlgItemText(hwnd, IDC_PASSWORD, blank);
      Win::SetDlgItemText(hwnd, IDC_CONFIRM, blank);
      popup.Gripe(
         hwnd,
         IDC_PASSWORD,
         IDS_PASSWORD_MISMATCH);
      return -1;
   }

   State& state = State::GetInstance();
   state.SetAdminPassword(password);

   int nextPage = -1;
   switch (state.GetOperation())
   {
      case State::ABORT_BDC_UPGRADE:
      case State::DEMOTE:
      {
         nextPage = IDD_CONFIRMATION;
         break;
      }
      case State::REPLICA:
      case State::FOREST:
      case State::TREE:
      case State::CHILD:
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\answerfile.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// answerfile reader object
//
// 12-15-97 sburns



#include "headers.hxx"
#include "AnswerFile.hpp"



AnswerFile::AnswerFile(const String& filename_)
   :
   filename(filename_)
{
   LOG_CTOR(AnswerFile);
   ASSERT(!filename.empty());
}



AnswerFile::~AnswerFile()
{
   LOG_DTOR(AnswerFile);
}



String
AnswerFile::ReadKey(const String& section, const String& key)
{
   LOG_FUNCTION2(
      AnswerFile::ReadKey,
      String::format(
         L"Section=%1 Key=%2",
         section.c_str(),
         key.c_str()));
   ASSERT(!section.empty());
   ASSERT(!key.empty());

   String result =
      Win::GetPrivateProfileString(section, key, String(), filename);

   // Don't log the value, as it may be a password.
   // LOG(L"value=" + result);

   return result.strip(String::BOTH);
}



EncodedString
AnswerFile::EncodedReadKey(const String& section, const String& key)
{
   LOG_FUNCTION2(
      AnswerFile::EncodedReadKey,
      String::format(
         L"Section=%1 Key=%2",
         section.c_str(),
         key.c_str()));
   ASSERT(!section.empty());
   ASSERT(!key.empty());

   EncodedString retval;
   unsigned      bufSize = 1023;
   PWSTR         buffer  = 0;   

   do
   {
      buffer = new WCHAR[bufSize + 1];
      ::ZeroMemory(buffer, (bufSize + 1) * sizeof(WCHAR));

      DWORD result =
         ::GetPrivateProfileString(
            section.c_str(),
            key.c_str(),
            L"",
            buffer,
            bufSize,
            filename.c_str());

      if (!result)
      {
         break;
      }

      // values were found.  check to see if they were truncated.

      if (result == bufSize - 2)
      {
         // buffer was too small, so the value was truncated.  Resize the
         // buffer and try again.

         // Since the buffer may have contained passwords, scribble it
         // out
         
         ::ZeroMemory(buffer, sizeof(WCHAR) * (bufSize + 1));
         
         delete[] buffer;
         bufSize *= 2;
         continue;
      }

      // don't need to trim whitespace, GetPrivateProfileString does that
      // for us.

      retval.Encode(buffer);

      break;
   }
   while (true);

   // Since the buffer may have contained passwords, scribble it
   // out
   
   ::ZeroMemory(buffer, sizeof(WCHAR) * (bufSize + 1));
   
   delete[] buffer;

   // Don't log the value, as it may be a password.
   // LOG(L"value=" + result);

   return retval;
}
   


void
AnswerFile::WriteKey(
   const String& section,
   const String& key,
   const String& value)
{
   LOG_FUNCTION2(
      AnswerFile::WriteKey,
      String::format(
         L"Section=%1 Key=%2",
         section.c_str(),
         key.c_str()));
   ASSERT(!section.empty());
   ASSERT(!key.empty());

   HRESULT hr =
      Win::WritePrivateProfileString(section, key, value, filename);

   ASSERT(SUCCEEDED(hr));
}



bool
AnswerFile::IsKeyPresent(
   const String& section,
   const String& key)
{
   LOG_FUNCTION2(
      AnswerFile::IsKeyPresent, 
      String::format(
         L"Section=%1 Key=%2",
         section.c_str(),
         key.c_str()));
   ASSERT(!section.empty());
   ASSERT(!key.empty());

   bool present = false;
         
   // our first call is with a large buffer, hoping that it will suffice...

   StringList results;
   unsigned   bufSize  = 1023;
   PWSTR      buffer   = 0;   

   do
   {
      buffer = new WCHAR[bufSize + 1];
      ::ZeroMemory(buffer, (bufSize + 1) * sizeof(WCHAR));

      DWORD result =
         ::GetPrivateProfileString(
            section.c_str(),
            0,
            L"default",
            buffer,
            bufSize,
            filename.c_str());

      if (!result)
      {
         break;
      }

      // values were found.  check to see if they were truncated.

      if (result == bufSize - 2)
      {
         // buffer was too small, so the value was truncated.  Resize the
         // buffer and try again.

         // Since the buffer may have contained passwords, scribble it
         // out
         
         ::ZeroMemory(buffer, (bufSize + 1) * sizeof(WCHAR));
         
         delete[] buffer;
         bufSize *= 2;
         continue;
      }

      // copy out the strings results into list elements

      PWSTR p = buffer;
      while (*p)
      {
         results.push_back(p);
         p += wcslen(p) + 1;
      }

      break;
   }

   //lint -e506   ok that this looks like "loop forever"
      
   while (true);

   // Since the buffer may have contained passwords, scribble it
   // out
   
   ::ZeroMemory(buffer, (bufSize + 1) * sizeof(WCHAR));
   
   delete[] buffer;

   if (std::find(results.begin(), results.end(), key) != results.end())
   {
      present = true;
   }

   LOG(present ? L"true" : L"false");

   return present;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\dll\dllmain.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// dcpromo setup entry points
//
// 2-11-98 sburns



#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
HINSTANCE hDLLModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME = L"dcpromos";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;



BOOL
APIENTRY
DllMain(
   HINSTANCE   hInstance,
   DWORD       dwReason,
   PVOID       /* lpReserved */ )
{
   switch (dwReason)
   {
      case DLL_PROCESS_ATTACH:
      {
         hResourceModuleHandle = hInstance;
         hDLLModuleHandle = hInstance;

         LOG(L"DLL_PROCESS_ATTACH");
         break;
      }
      case DLL_PROCESS_DETACH:
      {
         LOG(L"DLL_PROCESS_DETACH");

         break;
      }
      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
      default:
      {
         break;
      }
   }

   return TRUE;
}



DWORD
APIENTRY
DcPromoSaveDcStateForUpgrade(PCWSTR answerFile)
{
   LOG_FUNCTION(DcPromoSaveDcStateForUpgrade);

   DWORD result = ERROR_SUCCESS;

   if (!IsDSRunning())
   {
      LOG(L"Calling DsRoleServerSaveStateForUpgrade");
      LOG(String::format(L"AnswerFile : %1",
         answerFile ? answerFile : L"(null)"));

      result = ::DsRoleServerSaveStateForUpgrade(answerFile);

      LOG(String::format(L"Error 0x%1!X! (!0 => error)", result));
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\capslockballoontip.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Caps lock warning Balloon tip window
//
// 7 Nov 2000 sburns (that would be election day)
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns



#ifndef CAPSLOCKBALLOONTIP_HPP_INCLUDED
#define CAPSLOCKBALLOONTIP_HPP_INCLUDED



// Class used to show a balloon-style tool tip window that complains to the
// user that caps lock is on.  Used by PasswordEditBox.

class CapsLockBalloonTip
{
   public:



   CapsLockBalloonTip();



   // destroys the tool tip window, if it still exists
      
   ~CapsLockBalloonTip();


   // Initialize the tool tip, but don't show it.
   // 
   // parentWindow - in, the parent window handle of the control to have the
   // tool tip.  (The password edit control window).
   
   HRESULT
   Init(HWND parentWindow);
   


   // Show or hide the tip window.
   //
   // notHidden - in, if true, show the window.  If false, hide it.

   void
   Show(bool notHidden);
   

   
   private:

   // not implemented: no copying allowed

   CapsLockBalloonTip(const CapsLockBalloonTip&);
   const CapsLockBalloonTip& operator=(const CapsLockBalloonTip&);

   String title;
   String text;
   bool   visible;
   HWND   tipWindow;
   HWND   parentWindow;
};



#endif   // CAPSLOCKBALLOONTIP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\autoconfigurednspage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// auto config dns page
//
// 3-17-98 sburns



#ifndef AUTOCONFIGUREDNSPAGE_HPP_INCLUDED
#define AUTOCONFIGUREDNSPAGE_HPP_INCLUDED



class AutoConfigureDnsPage : public DCPromoWizardPage
{
   public:

   AutoConfigureDnsPage();

   protected:

   virtual ~AutoConfigureDnsPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // WizardPage overrides

   virtual
   bool
   OnWizBack();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   AutoConfigureDnsPage(const AutoConfigureDnsPage&);
   const AutoConfigureDnsPage& operator=(const AutoConfigureDnsPage&);
};



#endif   // AUTOCONFIGUREDNSPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\autoconfigurednspage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// auto config dns page
//
// 3-17-98 sburns



#include "headers.hxx"
#include "page.hpp"
#include "AutoConfigureDnsPage.hpp"
#include "resource.h"
#include "state.hpp"



AutoConfigureDnsPage::AutoConfigureDnsPage()
   :
   DCPromoWizardPage(
      IDD_AUTO_CONFIG_DNS,
      IDS_AUTO_CONFIG_DNS_PAGE_TITLE,
      IDS_AUTO_CONFIG_DNS_PAGE_SUBTITLE)
{
   LOG_CTOR(AutoConfigureDnsPage);
}



AutoConfigureDnsPage::~AutoConfigureDnsPage()
{
   LOG_CTOR(AutoConfigureDnsPage);
}



void
AutoConfigureDnsPage::OnInit()
{
   LOG_FUNCTION(AutoConfigureDnsPage::OnInit);

   State& state = State::GetInstance();
   int button = IDC_AUTO_CONFIG;

   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(State::OPTION_AUTO_CONFIG_DNS);

      if (option.icompare(State::VALUE_YES) == 0)
      {
         button = IDC_AUTO_CONFIG;
      }
      else
      {
         button = IDC_DONT_AUTO_CONFIG;
      }

   }

   Win::CheckDlgButton(hwnd, button, BST_CHECKED);
}



bool
AutoConfigureDnsPage::OnSetActive()
{
   LOG_FUNCTION(AutoConfigureDnsPage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = AutoConfigureDnsPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   return true;
}



int
AutoConfigureDnsPage::Validate()
{
   LOG_FUNCTION(AutoConfigureDnsPage::Validate);

   bool autoConfig = Win::IsDlgButtonChecked(hwnd, IDC_AUTO_CONFIG);
   State& state = State::GetInstance();

   state.SetAutoConfigureDNS(autoConfig);

   return IDD_RAS_FIXUP;
}



bool
AutoConfigureDnsPage::OnWizBack()
{
   LOG_FUNCTION(AutoConfigureDnsPage::OnWizBack);

   // make sure we reset the auto-config flag => the only way it gets set
   // it on the 'next' button.
   State::GetInstance().SetAutoConfigureDNS(false);

   return DCPromoWizardPage::OnWizBack();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\badcomputernamedialog.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Dlg to inform user of a bad computer name
//
// 21 Aug 2000 sburns



#ifndef BADCOMPUTERNAMEDIALOG_HPP_INCLUDED
#define BADCOMPUTERNAMEDIALOG_HPP_INCLUDED


                        
class BadComputerNameDialog : public Dialog
{
   public:

   explicit
   BadComputerNameDialog(const String& message_);

   virtual ~BadComputerNameDialog();

   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   String message;

   // not defined: no copying allowed

   BadComputerNameDialog(const BadComputerNameDialog&);
   const BadComputerNameDialog& operator=(const BadComputerNameDialog&);
};



#endif   // BADCOMPUTERNAMEDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\childpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new child page
//
// 1-5-98 sburns



#ifndef CHILDPAGE_HPP_INCLUDED
#define CHILDPAGE_HPP_INCLUDED



class ChildPage : public DCPromoWizardPage
{
   public:

   ChildPage();

   protected:

   virtual ~ChildPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   ChildPage(const ChildPage&);
   const ChildPage& operator=(const ChildPage&);
};



#endif   // CHILDPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\checkportavailability.cpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Check availability of ports used by Active Directory
//
// 1 Nov 2000 sburns



#include "headers.hxx"
#include "state.hpp"
#include "resource.h"
#include "CheckPortAvailability.hpp"



static const DWORD HELP_MAP[] =
{
   0, 0
};



PortsUnavailableErrorDialog::PortsUnavailableErrorDialog(
   StringList& portsInUseList_)
   :
   Dialog(IDD_PORTS_IN_USE_ERROR, HELP_MAP),
   portsInUseList(portsInUseList_)
{
   LOG_CTOR(PortsUnavailableErrorDialog);

   ASSERT(portsInUseList.size());
}



PortsUnavailableErrorDialog::~PortsUnavailableErrorDialog()
{
   LOG_DTOR(PortsUnavailableErrorDialog);
}



void
PortsUnavailableErrorDialog::OnInit()
{
   LOG_FUNCTION(PortsUnavailableErrorDialog::OnInit);

   // Load up the edit box with the DNs we aliased in the ctor.

   String text;
   for (
      StringList::iterator i = portsInUseList.begin();
      i != portsInUseList.end();
      ++i)
   {
      text += *i + L"\r\n";
   }

   Win::SetDlgItemText(hwnd, IDC_PORT_LIST, text);
}



bool
PortsUnavailableErrorDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(PortsUnavailableErrorDialog::OnCommand);

   if (code == BN_CLICKED)
   {
      switch (controlIDFrom)
      {
         case IDOK:
         case IDCANCEL:
         {
            Win::EndDialog(hwnd, controlIDFrom);
            return true;
         }
         default:
         {
            // do nothing
         }
      }
   }

   return false;
}



// Determine the service name, aliases of that name, and protocol used for a
// given port number.  Return S_OK on success, else return a failure code.
//
// winsock must have been initialized prior to calling this function.
// 
// portNumber - in, the port number for which the info should be determined.
// 
// name - out, the name of the service that runs on that port
// 
// aliases - out, other names for the service that runs on the port
// 
// protocol - out, the name of the protocol used on the port.

HRESULT
GetServiceOnPort(
   int         portNumber,
   String&     name,
   StringList& aliases,
   String&     protocol)
{
   LOG_FUNCTION2(GetServiceOnPort, String::format(L"%1!d!", portNumber));
   ASSERT(portNumber);

   HRESULT hr = S_OK;
   name.erase();
   aliases.clear();
   protocol.erase();

   int portNetByteOrder = htons((u_short) portNumber);
   servent* se = ::getservbyport(portNetByteOrder, 0);
   if (!se)
   {
      hr = Win32ToHresult((DWORD) ::WSAGetLastError());
   }
   else
   {
      if (se->s_name)
      {
         name = se->s_name;
      }
      if (se->s_proto)
      {
         protocol = se->s_proto;
      }

      char** a = se->s_aliases;
      while (*a)
      {
         aliases.push_back(*a);
         ++a;
      }
   }

#ifdef LOGGING_BUILD
   LOG_HRESULT(hr);
   LOG(name);
   for (
      StringList::iterator i = aliases.begin();
      i != aliases.end();
      ++i)
   {
      LOG(*i);
   }
   LOG(protocol);
#endif

   return hr;
}



// S_FALSE if an application has the port open in exclusive mode, S_OK if not,
// and error otherwise.
//
// winsock must have been initialized prior to calling this function.
//
// portNumber - in, port to check.

HRESULT
CheckPortAvailability(int portNumber)
{
   LOG_FUNCTION2(CheckPortAvailability, String::format(L"%1!d!", portNumber));
   ASSERT(portNumber);

   HRESULT hr = S_OK;

   do
   {
      sockaddr_in local;
      ::ZeroMemory(&local, sizeof local);
      local.sin_family      = AF_INET;       
      local.sin_port        = htons((u_short) portNumber);
      local.sin_addr.s_addr = INADDR_ANY;    

      SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
   
      if (sock == INVALID_SOCKET)
      {
         LOG(L"can't build socket");
         hr = Win32ToHresult((DWORD) ::WSAGetLastError());
         break;
      }

      if (
         bind(
            sock,
            (sockaddr*) &local,
            sizeof local) == SOCKET_ERROR)
      {
         LOG(L"bind failed");

         DWORD sockerr = ::WSAGetLastError();

         if (sockerr == WSAEADDRINUSE)
         {
            // a process on this box already has the socket open in
            // exclusive mode.

            hr = S_FALSE;
         }
         else
         {
            hr = Win32ToHresult(sockerr);
         }
         break;
      }

      // at this point, the bind was successful
      
      ASSERT(hr == S_OK);
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}

   

// Create a string that represents the port and the service name(s) running on
// that port.  This string is presented in the ui.
// 
// winsock must have been initialized prior to calling this function.
//
// portNumber - in, port to check.

String
MakeUnavailablePortListEntry(int portNumber)
{
   LOG_FUNCTION(MakeUnavailablePortListEntry);
   ASSERT(portNumber);

   String entry;

   do
   {
      String name;
      String protocol;
      StringList aliases;
      
      HRESULT hr = GetServiceOnPort(portNumber, name, aliases, protocol);   
      if (FAILED(hr))
      {
         // make a simple entry with just the port number

         entry = String::format(L"%1!d!", portNumber);
         break;
      }
                  
      if (aliases.size())
      {
         // combine the aliases into a comma-separated list

         String aliasParam;
         int j = 0;
         for (
            StringList::iterator i = aliases.begin();
            i != aliases.end();
            ++i, ++j)
         {
            aliasParam += *i;
            if (j < (aliases.size() - 1))
            {
               aliasParam += L", ";
            }
         }

         entry =
            String::format(
               L"%1!d! %2 (%3)",
               portNumber,
               name.c_str(),
               aliasParam.c_str());
      }
      else
      {
         // no aliases
         
         entry = String::format(L"%1!d! %2", portNumber, name.c_str());
      }
   }
   while (0);

   LOG(entry);

   return entry;
}



// Determine if any of a set of tcp ports required by the DS is already in use
// by another application on this machine.  Return S_OK if the list can be
// made, a failure code otherwise.
// 
// portsInUseList - out, a list of strings representing the ports in use and
// the name(s) of the services that are running on them, suitable for UI
// presentation.

HRESULT
EnumerateRequiredPortsInUse(StringList& portsInUseList)
{
   LOG_FUNCTION(EnumerateRequiredPortsInUse);

   portsInUseList.clear();
   HRESULT hr = S_FALSE;
   bool cleanupWinsock = false;

   do
   {
      WSADATA data;
      hr = Win32ToHresult((DWORD) ::WSAStartup(MAKEWORD(2,0), &data));
      BREAK_ON_FAILED_HRESULT(hr);

      cleanupWinsock = true;

      static const int REQUIRED_PORTS[] =
      {
         88,   // TCP/UDP Kerberos
         389,  // TCP LDAP
         636,  // TCP sldap
         3268, // TCP ldap/GC
         3269, // TCP sldap/GC
         0
      };

      const int* port = REQUIRED_PORTS;
      while (*port)
      {
         HRESULT hr2 = CheckPortAvailability(*port);
         if (hr2 == S_FALSE)
         {
            // Make an entry in the "in use" list
            
            portsInUseList.push_back(MakeUnavailablePortListEntry(*port));
         }
         
         // we ignore any other type of failure and check the remaining
         // ports.
         
         ++port;
      }
   }
   while (0);

   if (cleanupWinsock)
   {
      ::WSACleanup();
   }

#ifdef LOGGING_BUILD
   LOG_HRESULT(hr);

   for (
      StringList::iterator i = portsInUseList.begin();
      i != portsInUseList.end();
      ++i)
   {
      LOG(*i);
   }
#endif

   return hr;
}
   

    
bool
AreRequiredPortsAvailable()
{
   LOG_FUNCTION(AreRequiredPortsAvailable);

   bool result = true;

   do
   {
      State::RunContext context = State::GetInstance().GetRunContext();
      if (context == State::NT5_DC)
      {
         // already a DC, so we don't care about the port status, as the
         // only thing the user will be able to do is demote the box.

         LOG(L"already a DC -- port check skipped");
         ASSERT(result);

         break;
      }

      // Find the list of IP ports required by the DS that are already in use
      // (if any).  If we find some, gripe at the user.

      StringList portsInUseList;
      HRESULT hr = EnumerateRequiredPortsInUse(portsInUseList);
      if (FAILED(hr))
      {
         // if we can't figure out if the required ports are in use, then
         // just muddle on -- the user will have to clean up after the
         // promote.

         ASSERT(result);
         break;
      }

      if (hr == S_FALSE || portsInUseList.size() == 0)
      {
         LOG(L"No required ports already in use");
         ASSERT(result);
         
         break;
      }

      result = false;
         
      // there should be at least one port in the list.

      ASSERT(portsInUseList.size());

      PortsUnavailableErrorDialog(portsInUseList).ModalExecute(
         Win::GetDesktopWindow());
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\badcomputernamedialog.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Dlg to inform user of a bad computer name
//
// 21 Aug 2000 sburns


#include "headers.hxx"
#include "BadComputerNameDialog.hpp"
#include "resource.h"



static const DWORD HELP_MAP[] =
{
   0, 0
};



BadComputerNameDialog::BadComputerNameDialog(
   const String& message_)
   :
   Dialog(IDD_BAD_COMPUTER_NAME, HELP_MAP),
   message(message_)
{
   LOG_CTOR(BadComputerNameDialog);
   ASSERT(!message.empty());
}



BadComputerNameDialog::~BadComputerNameDialog()
{
   LOG_DTOR(BadComputerNameDialog);
}



bool
BadComputerNameDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIdFrom,
   unsigned    code)
{
   switch (controlIdFrom)
   {
      case IDCANCEL:
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            // the value with which we end this dialog is not important:
            // there is only one choice to the user: ACK

            Win::EndDialog(hwnd, 1);
            return true;
         }
         break;
      }
      case IDC_SHOW_HELP:
      {
         if (code == BN_CLICKED)
         {
            Win::HtmlHelp(
               hwnd,
               L"DNSConcepts.chm",
               HH_DISPLAY_TOPIC, 
               reinterpret_cast<DWORD_PTR>(L"error_dcpromo.htm"));
            return true;
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



void
BadComputerNameDialog::OnInit()
{
   LOG_FUNCTION(BadComputerNameDialog::OnInit);

   Win::SetDlgItemText(hwnd, IDC_TEXT, message);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\childpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new child page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "ChildPage.hpp"
#include "resource.h"
#include "dns.hpp"
#include "common.hpp"
#include "state.hpp"



ChildPage::ChildPage()
   :
   DCPromoWizardPage(
      IDD_NEW_CHILD,
      IDS_CHILD_PAGE_TITLE,
      IDS_CHILD_PAGE_SUBTITLE)
{
   LOG_CTOR(ChildPage);
}



ChildPage::~ChildPage()
{
   LOG_DTOR(ChildPage);
}



void
ChildPage::OnInit()
{
   LOG_FUNCTION(ChildPage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_PARENT),
      DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY);
   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_LEAF),
      Dns::MAX_LABEL_LENGTH);
      
   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_PARENT,
         state.GetAnswerFileOption(State::OPTION_PARENT_DOMAIN_NAME));
      Win::SetDlgItemText(
         hwnd,
         IDC_LEAF,
         state.GetAnswerFileOption(State::OPTION_CHILD_NAME));
   }
   else
   {
      // default domain is that to which the server is joined.

      Win::SetDlgItemText(
         hwnd,
         IDC_PARENT,
         state.GetComputer().GetDomainDnsName());
      
      // @@ if PDC_UPGRADE, set the pdc flat name as the leaf name here
   }
}


static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int next =
         (  !Win::GetTrimmedDlgItemText(dialog, IDC_PARENT).empty()
         && !Win::GetTrimmedDlgItemText(dialog, IDC_LEAF).empty() )
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);
}


   
bool
ChildPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(ChildPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_BROWSE:
      {
         if (code == BN_CLICKED)
         {
            String domain = BrowseForDomain(hwnd);
            if (!domain.empty())
            {
               Win::SetDlgItemText(hwnd, IDC_PARENT, domain);
            }

            return true;
         }
         break;
      }
      case IDC_LEAF:
      case IDC_PARENT:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);

            String parent = Win::GetTrimmedDlgItemText(hwnd, IDC_PARENT);
            String leaf = Win::GetTrimmedDlgItemText(hwnd, IDC_LEAF);
            String domain = leaf + L"." + parent;

            Win::SetDlgItemText(hwnd, IDC_DOMAIN, domain);
            enable(hwnd);
            return true;                                                     
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



bool
ChildPage::OnSetActive()
{
   LOG_FUNCTION(ChildPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::CHILD);

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = ChildPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   enable(hwnd);
   return true;
}

   

int
ChildPage::Validate()
{
   LOG_FUNCTION(Child::Validate);

   String parent = Win::GetTrimmedDlgItemText(hwnd, IDC_PARENT);
   String leaf = Win::GetTrimmedDlgItemText(hwnd, IDC_LEAF);
   String domain = leaf + L"." + parent;

   State& state = State::GetInstance();
   int nextPage = -1;

   // SPB:251431 do validation even if this page is untouched, as upstream
   // pages may have been changed in such a fashion that re-validation is
   // required.

   // if (!WasChanged(IDC_PARENT) && !WasChanged(IDC_LEAF))
   // {
   //    return nextPage;
   // }

   do
   {
      if (parent.empty())
      {
         popup.Gripe(hwnd, IDC_PARENT, IDS_MUST_ENTER_PARENT);
         break;
      }

      if (leaf.empty())
      {
         popup.Gripe(hwnd, IDC_LEAF, IDS_MUST_ENTER_LEAF);
         break;
      }

      bool parentIsNonRfc = false;
      if (
         !ValidateDomainDnsNameSyntax(
            hwnd,
            IDC_PARENT,
            true,
            &parentIsNonRfc))
      {
         break;
      }

      if (!ValidateChildDomainLeafNameLabel(hwnd, IDC_LEAF, parentIsNonRfc))
      {
         break;
      }

      // now ensure that the parent domain exists

      String dnsName;
      if (!ValidateDomainExists(hwnd, IDC_PARENT, dnsName))
      {
         break;
      }
      if (!dnsName.empty())
      {
         // the user specified the netbios name of the domain, and
         // confirmed it, so use the dns domain name returned.

         parent = dnsName;
         domain = leaf + L"." + parent;
         Win::SetDlgItemText(hwnd, IDC_PARENT, dnsName);
         Win::SetDlgItemText(hwnd, IDC_DOMAIN, domain);
      }

      if (!state.IsDomainInForest(parent))
      {
         popup.Gripe(
            hwnd,
            IDC_DOMAIN,
            String::format(
               IDS_DOMAIN_NOT_IN_FOREST,
               parent.c_str(),
               state.GetUserForestName().c_str()));
         break;
      }
         
      if (domain.length() > DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY)
      {
         String message =
            String::format(
               IDS_DNS_NAME_TOO_LONG,
               domain.c_str(),
               DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY,
               DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8);
         popup.Gripe(hwnd, IDC_LEAF, message);
         break;
      }

      // validate the resulting child domain name, not warning on non-RFCness

      if (
         !ValidateDomainDnsNameSyntax(
            hwnd,
            domain,
            IDC_LEAF,
            !parentIsNonRfc) )
      {
         break;
      }

      // now ensure that the child domain name does not exist

      if (!ValidateDomainDoesNotExist(hwnd, domain, IDC_LEAF))
      {
         break;
      }

      // valid

      ClearChanges();
      state.SetParentDomainDNSName(Win::GetTrimmedDlgItemText(hwnd, IDC_PARENT));
      state.SetNewDomainDNSName(domain);

      nextPage =
            state.GetRunContext() == State::PDC_UPGRADE
         ?  IDD_PATHS
         :  IDD_NETBIOS_NAME;
   }
   while (0);

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\checkportavailability.hpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Check availability of ports used by Active Directory
//
// 1 Nov 2000 sburns



#ifndef CHECKPORTAVAILABILITY_HPP_INCLUDED
#define CHECKPORTAVAILABILITY_HPP_INCLUDED



// Return true if all the IP ports used by the DS are available on this
// machine, false if not. If the result is false, then also pop up a dialog
// listing the ports that are in use.
// 
// NTRAID#NTBUG9-129955-2000/11/01-sburns

bool
AreRequiredPortsAvailable();



class PortsUnavailableErrorDialog : public Dialog
{
   public:

   PortsUnavailableErrorDialog(StringList& portsInUseList);

   virtual
   ~PortsUnavailableErrorDialog();

   private:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // not defined: no copying allowed

   PortsUnavailableErrorDialog(const PortsUnavailableErrorDialog&);
   const PortsUnavailableErrorDialog& operator=(const PortsUnavailableErrorDialog&);

   StringList& portsInUseList;
};



#endif   // CHECKPORTAVAILABILITY_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\common.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// code common to several pages
//
// 12-16-97 sburns



#include "headers.hxx"
#include "common.hpp"
#include "resource.h"
#include "state.hpp"
#include "ds.hpp"
#include <DiagnoseDcNotFound.hpp>



// Creates the fonts for setLargeFonts().
// 
// hDialog - handle to a dialog to be used to retrieve a device
// context.
// 
// bigBoldFont - receives the handle of the big bold font created.

void
InitFonts(
   HWND     hDialog,
   HFONT&   bigBoldFont)
{
   ASSERT(Win::IsWindow(hDialog));

   HRESULT hr = S_OK;

   do
   {
      NONCLIENTMETRICS ncm;
      memset(&ncm, 0, sizeof(ncm));
      ncm.cbSize = sizeof(ncm);

      hr = Win::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
      BREAK_ON_FAILED_HRESULT(hr);

      LOGFONT bigBoldLogFont = ncm.lfMessageFont;
      bigBoldLogFont.lfWeight = FW_BOLD;

      String fontName = String::load(IDS_BIG_BOLD_FONT_NAME);

      // ensure null termination 260237

      memset(bigBoldLogFont.lfFaceName, 0, LF_FACESIZE * sizeof(TCHAR));
      size_t fnLen = fontName.length();
      fontName.copy(
         bigBoldLogFont.lfFaceName,

         // don't copy over the last null

         min(LF_FACESIZE - 1, fnLen));

      unsigned fontSize = 0;
      String::load(IDS_BIG_BOLD_FONT_SIZE).convert(fontSize);
      ASSERT(fontSize);
 
      HDC hdc = 0;
      hr = Win::GetDC(hDialog, hdc);
      BREAK_ON_FAILED_HRESULT(hr);

      bigBoldLogFont.lfHeight =
         - ::MulDiv(
            static_cast<int>(fontSize),
            Win::GetDeviceCaps(hdc, LOGPIXELSY),
            72);

      hr = Win::CreateFontIndirect(bigBoldLogFont, bigBoldFont);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::ReleaseDC(hDialog, hdc);
   }
   while (0);
}



void
SetControlFont(HWND parentDialog, int controlID, HFONT font)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(controlID);
   ASSERT(font);

   HWND control = Win::GetDlgItem(parentDialog, controlID);

   if (control)
   {
      Win::SetWindowFont(control, font, true);
   }
}



void
SetLargeFont(HWND dialog, int bigBoldResID)
{
   ASSERT(Win::IsWindow(dialog));
   ASSERT(bigBoldResID);

   static HFONT bigBoldFont = 0;
   if (!bigBoldFont)
   {
      InitFonts(dialog, bigBoldFont);
   }

   SetControlFont(dialog, bigBoldResID, bigBoldFont);
}



bool
ValidateDomainDnsNameSyntax(
   HWND  dialog,      
   int   editResID,   
   bool  warnOnNonRFC,
   bool* isNonRFC)    
{
   return
      ValidateDomainDnsNameSyntax(
         dialog,
         String(),
         editResID,
         warnOnNonRFC,
         isNonRFC);
}



// return true if the name is a reserved name, false otherwise.  If true, also
// set message to an error message describing the problem.

bool
IsReservedDnsName(const String& dnsName, String& message)
{
   LOG_FUNCTION2(IsReservedDnsName, dnsName);
   ASSERT(!dnsName.empty());

   message.erase();
   bool result = false;

// We're still trying to decide if we should restrict these names
//
//    // names with these as the last labels are illegal.
// 
//    static const String RESERVED[] =
//    {
//       L"in-addr.arpa",
//       L"ipv6.int",
// 
//       // RFC 2606 documents these:
// 
//       L"test",
//       L"example",
//       L"invalid",
//       L"localhost",
//       L"example.com",
//       L"example.org",
//       L"example.net"
//    };
// 
//    String name(dnsName);
//    name.to_upper();
//    if (name[name.length() - 1] == L'.')
//    {
//       // remove the trailing dot
// 
//       name.resize(name.length() - 1);
//    }
// 
//    for (int i = 0; i < sizeof(RESERVED) / sizeof(String); ++i)
//    {
//       String res = RESERVED[i];
//       res.to_upper();
// 
//       size_t pos = name.rfind(res);
// 
//       if (pos == String::npos)
//       {
//          continue;
//       }
// 
//       if (pos == 0 && name.length() == res.length())
//       {
//          ASSERT(name == res);
// 
//          result = true;
//          message =
//             String::format(
//                IDS_RESERVED_NAME,
//                dnsName.c_str());
//          break;
//       }
// 
//       if ((pos == name.length() - res.length()) && (name[pos - 1] == L'.'))
//       {
//          // the name has reserved as a suffix.
// 
//          result = true;
//          message =
//             String::format(
//                IDS_RESERVED_NAME_SUFFIX,
//                dnsName.c_str(),
//                RESERVED[i].c_str());
//          break;
//       }
//    }

   return result;
}



bool
ValidateDomainDnsNameSyntax(
   HWND           dialog,
   const String&  domainName,
   int            editResID,
   bool           warnOnNonRFC,
   bool*          isNonRFC)
{
   LOG_FUNCTION(ValidateDomainDnsNameSyntax);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResID > 0);

   bool valid = false;
   String message;
   String dnsName =
         domainName.empty()
      ?  Win::GetTrimmedDlgItemText(dialog, editResID)
      :  domainName;
   if (isNonRFC)
   {
      *isNonRFC = false;
   }

   LOG(L"validating " + dnsName);

   switch (
      Dns::ValidateDnsNameSyntax(
         dnsName,
         DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY,
         DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8) )
   {
      case Dns::NON_RFC:
      {
         if (isNonRFC)
         {
            *isNonRFC = true;
         }
         if (warnOnNonRFC)
         {
            // warn about non-rfc names

            String msg = String::format(IDS_NON_RFC_NAME, dnsName.c_str());
            if (!State::GetInstance().RunHiddenUnattended())
            {
               popup.Info(
                  dialog,
                  msg);
            }
            else
            {
               LOG(msg);
            }
         }

         // fall through
         //lint -e616   allow fall thru
      }
      case Dns::VALID:
      {
         valid = !IsReservedDnsName(dnsName, message);
         break;
      }
      case Dns::TOO_LONG:
      {
         message =
            String::format(
               IDS_DNS_NAME_TOO_LONG,
               dnsName.c_str(),
               DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY,
               DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8);
         break;
      }
      case Dns::NUMERIC:
      case Dns::BAD_CHARS:
      case Dns::INVALID:
      default:
      {
         message =
            String::format(
               IDS_BAD_DNS_SYNTAX,
               dnsName.c_str(),
               Dns::MAX_LABEL_LENGTH);
         break;
      }
   }

   if (!valid)
   {
      popup.Gripe(dialog, editResID, message);
   }

   return valid;
}



HRESULT
GetDcName(const String& domainName, String& resultDcName)
{
   LOG_FUNCTION(GetDcName);
   ASSERT(!domainName.empty());

   resultDcName.erase();

   HRESULT hr = S_OK;

   do
   {
      DOMAIN_CONTROLLER_INFO* info = 0;
      hr =
         MyDsGetDcName(
            0,
            domainName,  

            // pass the force rediscovery flag to make sure we don't pick up
            // a dc that is down 262221

            DS_DIRECTORY_SERVICE_REQUIRED | DS_FORCE_REDISCOVERY,
            info);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(info->DomainControllerName);

      if (info->DomainControllerName)
      {
         // we found an NT5 domain

         resultDcName =
            Computer::RemoveLeadingBackslashes(info->DomainControllerName);

         LOG(resultDcName);
      }

      ::NetApiBufferFree(info);

      if (resultDcName.empty())
      {
         hr = Win32ToHresult(ERROR_DOMAIN_CONTROLLER_NOT_FOUND);
      }
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT
BrowserSetComputer(const SmartInterface<IDsBrowseDomainTree>& browser)            
{
   LOG_FUNCTION(BrowserSetComputer);

   HRESULT hr = S_OK;
   do
   {
      State& state = State::GetInstance();

      String username =
            MassageUserName(
               state.GetUserDomainName(),
               state.GetUsername());
      EncodedString password = state.GetPassword();

      String computer;
      hr =
         GetDcName(
            state.GetUserDomainName(),
            computer);
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"Calling IDsBrowseDomainTree::SetComputer");
      LOG(String::format(L"pszComputerName : %1", computer.c_str()));
      LOG(String::format(L"pszUserName     : %1", username.c_str()));

      WCHAR* cleartext = password.GetDecodedCopy();
      
      hr =
         browser->SetComputer(
            computer.c_str(),
            username.c_str(),
            cleartext);

      ::ZeroMemory(cleartext, sizeof(WCHAR) * password.GetLength());
      delete[] cleartext;
                  
      LOG_HRESULT(hr);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT
ReadDomainsHelper(bool bindWithCredentials, Callback* callback)
{
   LOG_FUNCTION(ReadDomainsHelper);

   HRESULT hr = S_OK;

   do
   {
      hr = ::CoInitialize(0);
      BREAK_ON_FAILED_HRESULT(hr);

      SmartInterface<IDsBrowseDomainTree> browser;
      hr = browser.AcquireViaCreateInstance(
            CLSID_DsDomainTreeBrowser,
            0,
            CLSCTX_INPROC_SERVER,
            IID_IDsBrowseDomainTree);
      BREAK_ON_FAILED_HRESULT(hr);

      if (bindWithCredentials)
      {
         LOG(L"binding with credentials");

         hr = BrowserSetComputer(browser);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      LOG(L"Calling IDsBrowseDomainTree::GetDomains");
         
      DOMAIN_TREE* tree = 0;
      hr = browser->GetDomains(&tree, 0);
      BREAK_ON_FAILED_HRESULT(hr);
      ASSERT(tree);

      if (tree && callback)
      {
         //lint -e534   ignore return value
         callback->Execute(tree);
      }

      hr = browser->FreeDomains(&tree);
      ASSERT(SUCCEEDED(hr));
   }
   while (0);

   return hr;
}



String
BrowseForDomain(HWND parent)
{
   LOG_FUNCTION(BrowseForDomain);
   ASSERT(Win::IsWindow(parent));

   String retval;
   HRESULT hr = S_OK;
   
   do
   {
      Win::WaitCursor cursor;

      hr = ::CoInitialize(0);
      BREAK_ON_FAILED_HRESULT(hr);

      // CODEWORK: the credential page could cache an instance of the browser,
      // rebuilding and setting the search root when only when new credentials
      // are entered.  Since the browser caches the last result, this would
      // make subsequent retreivals of the domain much faster.
      // addendum: tho the revised browser seems pretty quick

      SmartInterface<IDsBrowseDomainTree> browser;
      hr = browser.AcquireViaCreateInstance(
            CLSID_DsDomainTreeBrowser,
            0,
            CLSCTX_INPROC_SERVER,
            IID_IDsBrowseDomainTree);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = BrowserSetComputer(browser);
      BREAK_ON_FAILED_HRESULT(hr);

      PWSTR result = 0;
      hr = browser->BrowseTo(parent, &result, 0);
      BREAK_ON_FAILED_HRESULT(hr);

      if (result)
      {
         retval = result;
         ::CoTaskMemFree(result);
      }
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(parent, hr, IDS_CANT_BROWSE_FOREST);
   }

   return retval;
}



class RootDomainCollectorCallback : public Callback
{
   public:

   explicit
   RootDomainCollectorCallback(StringList& domains_)
      :
      Callback(),
      domains(domains_)
   {
      ASSERT(domains.empty());
      domains.clear();
   }

   virtual
   ~RootDomainCollectorCallback()
   {
   }
   
   virtual
   int
   Execute(void* param)
   {
      ASSERT(param);

      // root domains are all those on the sibling link of the root
      // node of the domain tree.

      DOMAIN_TREE* tree = reinterpret_cast<DOMAIN_TREE*>(param);
      if (tree)
      {
         for (
            DOMAIN_DESC* desc = &(tree->aDomains[0]);
            desc;
            desc = desc->pdNextSibling)
         {
            LOG(
               String::format(
                  L"pushing root domain %1",
                  desc->pszName));

            domains.push_back(desc->pszName);
         }
      }

      return 0;
   }

   private:

   StringList& domains;
};




HRESULT
ReadRootDomains(bool bindWithCredentials, StringList& domains)
{
   LOG_FUNCTION(ReadRootDomains);

   RootDomainCollectorCallback rdcc(domains);

   return
      ReadDomainsHelper(
         bindWithCredentials,
         &rdcc);
}



bool
IsRootDomain(bool bindWithCredentials)
{
   LOG_FUNCTION(IsRootDomain);

   static bool computed = false;
   static bool isRoot = false;

   if (!computed)
   {
      StringList domains;
      if (SUCCEEDED(ReadRootDomains(bindWithCredentials, domains)))
      {
         String domain =
            State::GetInstance().GetComputer().GetDomainDnsName();
         for (
            StringList::iterator i = domains.begin();
            i != domains.end();
            ++i)
         {
            if (Dns::CompareNames((*i), domain) == DnsNameCompareEqual)
            {
               LOG(String::format(L"found match: %1", (*i).c_str()));

               ASSERT(!(*i).empty());

               isRoot = true;
               break;
            }
         }

         computed = true;
      }
   }

   LOG(isRoot ? L"is root" : L"is not root");

   return isRoot;
}



// first = child, second = parent

typedef std::pair<String, String> StringPair;

typedef
   std::list<
      StringPair,
      Burnslib::Heap::Allocator<StringPair> >
   ChildParentList;

class ChildDomainCollectorCallback : public Callback
{
   public:

   explicit
   ChildDomainCollectorCallback(ChildParentList& domains_)
      :
      Callback(),
      domains(domains_)
   {
      ASSERT(domains.empty());
      domains.clear();
   }

   virtual
   ~ChildDomainCollectorCallback()
   {
   }
   
   virtual
   int
   Execute(void* param)
   {
      LOG_FUNCTION(ChildDomainCollectorCallback::Execute);

      ASSERT(param);

      DOMAIN_TREE* tree = reinterpret_cast<DOMAIN_TREE*>(param);
      if (tree)
      {
         typedef
            std::deque<
               DOMAIN_DESC*,
               Burnslib::Heap::Allocator<DOMAIN_DESC*> >
            DDDeque;
            
         std::stack<DOMAIN_DESC*, DDDeque> s;

         // first we push all the nodes for all root domains.  These are
         // the nodes on the sibling link of the tree root.  Hereafter,
         // the sibling link is only used to chase child domains.

         for (
            DOMAIN_DESC* desc = &(tree->aDomains[0]);
            desc;
            desc = desc->pdNextSibling)
         {
            LOG(
               String::format(
                  L"pushing root domain %1",
                  desc->pszName));

            s.push(desc);
         }

         // next, we work thru the stack, looking for nodes that have
         // nodes on their child links.  When we find such a node, we
         // collect in the child list all the children on that link, and
         // push them so that they will in turn be evaluated.

         DWORD count = 0;
         while (!s.empty())
         {
            DOMAIN_DESC* desc = s.top();
            s.pop();
            ASSERT(desc);

            if (desc)
            {
               count++;
               LOG(String::format(L"evaluating %1", desc->pszName));

               String parentname = desc->pszName;

               for (
                  DOMAIN_DESC* child = desc->pdChildList;
                  child;
                  child = child->pdNextSibling)
               {
                  s.push(child);
                  
                  String childname = child->pszName;

                  LOG(
                     String::format(
                        L"parent: %1 child: %2",
                        parentname.c_str(),
                        childname.c_str()));

                  domains.push_back(std::make_pair(childname, parentname));
               }
            }
         }

         ASSERT(count == tree->dwCount);
      }

      return 0;
   }

   private:

   ChildParentList& domains;
};



HRESULT
ReadChildDomains(bool bindWithCredentials, ChildParentList& domains)
{
   LOG_FUNCTION(ReadChildDomains);

   ChildDomainCollectorCallback cdcc(domains);

   return
      ReadDomainsHelper(
         bindWithCredentials,
         &cdcc);
}



String
GetParentDomainDnsName(
   const String&  childDomainDNSName,
   bool           bindWithCredentials)
{
   LOG_FUNCTION2(GetParentDomainDnsName, childDomainDNSName);
   ASSERT(!childDomainDNSName.empty());

   ChildParentList domains;

   if (SUCCEEDED(ReadChildDomains(bindWithCredentials, domains)))
   {
      for (
         ChildParentList::iterator i = domains.begin();
         i != domains.end();
         ++i)
      {
         if (
            Dns::CompareNames(
               (*i).first,
               childDomainDNSName) == DnsNameCompareEqual)
         {
            LOG(
               String::format(
                  L"found parent: %1",
                  (*i).second.c_str()));

            ASSERT(!(*i).second.empty());

            return (*i).second;
         }
      }
   }

   LOG(L"domain is not a child");

   return String();
}



class DomainCollectorCallback : public Callback
{
   public:

   explicit
   DomainCollectorCallback(StringList& domains_)
      :
      Callback(),
      domains(domains_)
   {
      ASSERT(domains.empty());
      domains.clear();
   }

   virtual
   ~DomainCollectorCallback()
   {
   }
   
   virtual
   int
   Execute(void* param)
   {
      LOG_FUNCTION(DomainCollectorCallback::Execute);

      ASSERT(param);

      DOMAIN_TREE* tree = reinterpret_cast<DOMAIN_TREE*>(param);
      if (tree)
      {
         for (DWORD i = 0; i < tree->dwCount; ++i)
         {
            PCWSTR name = tree->aDomains[i].pszName;

            LOG(String::format(L"domain found: %1", name));

            domains.push_back(name);
         }
      }

      return 0;
   }

   private:

   StringList& domains;
};



HRESULT
ReadDomains(StringList& domains)
{
   LOG_FUNCTION(ReadDomains);

   DomainCollectorCallback dcc(domains);

   return ReadDomainsHelper(true, &dcc);
}



String
BrowseForFolder(HWND parent, int titleResID)
{
   LOG_FUNCTION(BrowseForFolder);
   ASSERT(Win::IsWindow(parent));
   ASSERT(titleResID > 0);

   String       result;
   HRESULT      hr      = S_OK;
   LPMALLOC     pmalloc = 0;   
   LPITEMIDLIST drives  = 0;   
   LPITEMIDLIST pidl    = 0;   

   do
   {
      hr = Win::SHGetMalloc(pmalloc);
      if (FAILED(hr) or !pmalloc)
      {
         break;
      }

      // get a pidl for the local drives (really My Computer)

      hr = Win::SHGetSpecialFolderLocation(parent, CSIDL_DRIVES, drives);
      BREAK_ON_FAILED_HRESULT(hr);

      BROWSEINFO info;
      memset(&info, 0, sizeof(info));
      String title = String::load(titleResID);
      wchar_t buf[MAX_PATH + 1];
      memset(buf, 0, sizeof(buf));

      info.hwndOwner      = parent;      
      info.pidlRoot       = drives;        
      info.pszDisplayName = buf;        
      info.lpszTitle      = title.c_str();              
      info.ulFlags        = BIF_RETURNONLYFSDIRS | BIF_RETURNFSANCESTORS;

      pidl = Win::SHBrowseForFolder(info);

      if (pidl)
      {
         result = Win::SHGetPathFromIDList(pidl);
      }

   }
   while (0);

   if (pmalloc)
   {
      pmalloc->Free(pidl);
      pmalloc->Free(drives);
      pmalloc->Release();
   }
            
   return result;
}



bool
CheckDriveType(const String& path)
{
   LOG_FUNCTION(CheckDriveType);
   ASSERT(!path.empty());

   UINT type = Win::GetDriveType(path);
   switch (type)
   {
      case DRIVE_FIXED:
      {
         return true;
      }
      case DRIVE_REMOVABLE:
      {
         // only legal iff volume = system volume
         String vol = FS::GetRootFolder(path);
         String sys = FS::GetRootFolder(Win::GetSystemDirectory());
         if (vol.icompare(sys) == 0)
         {
            return true;
         }
         break;
      }
      default:
      {
         // all others bad
         break;         
      }
   }


   return false;
}



bool
ValidateDcInstallPath(
   const String&  path,
   HWND           parent,
   int            editResID,
   bool           requiresNTFS5)
{
   LOG_FUNCTION(ValidateDcInstallPath);
   ASSERT(!path.empty());

   bool result = false;
   String message;
   do
   {
      if (
            (path.icompare(Win::GetWindowsDirectory()) == 0)
         || (path.icompare(Win::GetSystemWindowsDirectory()) == 0) )
      {
         message = String::format(IDS_PATH_IS_WINDIR, path.c_str());
         break;
      }

      if (path.icompare(Win::GetSystemDirectory()) == 0)
      {
         message = String::format(IDS_PATH_IS_SYSTEM32, path.c_str());
         break;
      }

      if (FS::GetPathSyntax(path) != FS::SYNTAX_ABSOLUTE_DRIVE)
      {
         message = String::format(IDS_BAD_PATH_FORMAT, path.c_str());
         break;
      }

      if (!CheckDriveType(path))
      {
         message = String::format(IDS_BAD_DRIVE_TYPE, path.c_str());
         break;
      }

      if (requiresNTFS5 && (FS::GetFileSystemType(path) != FS::NTFS5))
      {
         message = String::format(IDS_NOT_NTFS5, path.c_str());
         break;
      }

      // prohibit paths that contain mounted volumes 325264
      // even when they don't exist 435428
                       
      String mountRoot;
      HRESULT hr = FS::GetVolumePathName(path, mountRoot);

      ASSERT(SUCCEEDED(hr));

      // '3' == length of root of a "normal" volume ("C:\")

      if (mountRoot.length() > 3)
      {
         message =
            String::format(
               IDS_PATH_CONTAINS_MOUNTED_VOLUMES,
               path.c_str(),
               mountRoot.c_str());
         break;
      }

      DWORD attrs = 0;
      hr = Win::GetFileAttributes(path, attrs);

      if (SUCCEEDED(hr))
      {
         // path exists

         // reject paths that refer an existing file

         if (!(attrs & FILE_ATTRIBUTE_DIRECTORY))
         {
            message = String::format(IDS_PATH_NOT_DIRECTORY, path.c_str());
            break;
         }

         if (!FS::IsFolderEmpty(path))
         {
            if (
               popup.MessageBox(
                  parent,
                  String::format(IDS_EMPTY_PATH, path.c_str()),
                  MB_ICONWARNING | MB_YESNO) == IDNO)
            {
               // don't gripe...silently disapprove

               HWND edit = Win::GetDlgItem(parent, editResID);
               Win::SendMessage(edit, EM_SETSEL, 0, -1);
               Win::SetFocus(edit);
               break;
            }
         }
      }

      result = true;
   }
   while (0);

   if (!message.empty())
   {
      popup.Gripe(parent, editResID, message);
   }
      
   return result;
}



bool
DoLabelValidation(
   HWND dialog,        
   int  editResID,     
   int  badSyntaxResID,
   bool gripeOnNonRFC = true,
   bool gripeOnNumericLabel = true) 
{
   LOG_FUNCTION(DoLabelValidation);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResID > 0);

   bool valid = false;
   String label = Win::GetTrimmedDlgItemText(dialog, editResID);
   switch (Dns::ValidateDnsLabelSyntax(label))
   {
      case Dns::NON_RFC:
      {
         if (gripeOnNonRFC)
         {
            // warn about non-rfc names
            popup.Info(
               dialog,
               String::format(IDS_NON_RFC_NAME, label.c_str()));
         }

         // fall thru
      }
      case Dns::VALID:
      {
         valid = true;
         break;
      }
      case Dns::TOO_LONG:
      {
         popup.Gripe(
            dialog,
            editResID,
            String::format(
               IDS_DNS_LABEL_TOO_LONG,
               label.c_str(),
               Dns::MAX_LABEL_LENGTH));
         break;
      }
      case Dns::NUMERIC:
      {
         if (!gripeOnNumericLabel)
         {
            valid = true;
            break;
         }

         // fall thru
      }
      case Dns::BAD_CHARS:
      case Dns::INVALID:
      default:
      {
         popup.Gripe(
            dialog,
            editResID,
            String::format(badSyntaxResID, label.c_str()));
         break;
      }
   }

   return valid;
}



bool
ValidateChildDomainLeafNameLabel(
   HWND dialog,        
   int  editResID,     
   bool parentIsNonRFC)
{
   LOG_FUNCTION(ValidateChildDomainLeafNameLabel);

   String name = Win::GetTrimmedDlgItemText(dialog, editResID);
   if (name.empty())
   {
      popup.Gripe(dialog, editResID, IDS_BLANK_LEAF_NAME);
      return false;
   }

   // If parent is non-RFC, then so will be the child.  The user has been
   // griped to already, so don't gripe twice
   // 291558

   return
      DoLabelValidation(
         dialog,
         editResID,
         IDS_BAD_LABEL_SYNTAX,
         !parentIsNonRFC,

         // allow numeric labels. NTRAID#NTBUG9-321168-2001/02/20-sburns
         
         false);
}



bool
ValidateSiteName(HWND dialog, int editResID)
{
   LOG_FUNCTION(ValidateSiteName);

   String name = Win::GetTrimmedDlgItemText(dialog, editResID);
   if (name.empty())
   {
      popup.Gripe(dialog, editResID, IDS_BLANK_SITE_NAME);
      return false;
   }

   // A site name is just a DNS label

   return DoLabelValidation(dialog, editResID, IDS_BAD_SITE_SYNTAX);
}



void
ShowTroubleshooter(HWND parent, int topicResID)
{
   LOG_FUNCTION(ShowTroubleshooter);
   ASSERT(Win::IsWindow(parent));

   String file = String::load(IDS_HTML_HELP_FILE);
   String topic = String::load(topicResID);
   ASSERT(!topic.empty());

   LOG(String::format(L"file: %1 topic: %2", file.c_str(), topic.c_str()));

   Win::HtmlHelp(
      parent,
      file, 
      HH_DISPLAY_TOPIC,
      reinterpret_cast<DWORD_PTR>(topic.c_str()));
}



String
MassageUserName(const String& domainName, const String& userName)
{
   LOG_FUNCTION2(MassageUserName, userName);
   ASSERT(!userName.empty());

   String result = userName;

   do
   {
      if (userName.find(L"@") != String::npos)
      {
         // userName includes an @, looks like a UPN to us, so don't
         // mess with it further 17699

         LOG(L"looks like a UPN");
         break;
      }

      if (!domainName.empty())
      {
         static const String DOMAIN_SEP_CHAR = L"\\";
         String name = userName;
         size_t pos = userName.find(DOMAIN_SEP_CHAR);

         if (pos != String::npos)
         {
            // remove the domain name in the userName string and replace it
            // with the domainName String

            name = userName.substr(pos + 1);
            ASSERT(!name.empty());
         }

         result = domainName + DOMAIN_SEP_CHAR + name;
         break;
      }

      // otherwise, the username appears as "foo\bar", so we don't touch it.
   }
   while (0);

   LOG(result);

   return result;
}



bool
IsChildDomain(bool bindWithCredentials)
{
   LOG_FUNCTION(IsChildDomain);

   static bool computed = false;
   static String parent;

   if (!computed)
   {
      parent =
         GetParentDomainDnsName(
            State::GetInstance().GetComputer().GetDomainDnsName(),
            bindWithCredentials);
      computed = true;
   }

   LOG(
         parent.empty()
      ?  String(L"not a child")
      :  String::format(L"is child.  parent: %1", parent.c_str()));

   return !parent.empty();
}



bool
IsForestRootDomain()
{
   LOG_FUNCTION(IsForestRootDomain);

   const Computer& c = State::GetInstance().GetComputer();

   bool result = (c.GetDomainDnsName() == c.GetForestDnsName());

   LOG(
      String::format(
         L"%1 a forest root domain",
         result ? L"is" : L"is not"));

   return result;
}



bool
ValidateDomainExists(HWND dialog, int editResID, String& domainDnsName)
{
   return ValidateDomainExists(dialog, String(), editResID, domainDnsName);
}



bool
ValidateDomainExists(
   HWND           dialog,
   const String&  domainName,
   int            editResId,
   String&        domainDnsName)
{
   LOG_FUNCTION(ValidateDomainExists);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResId > 0);

   String name =
         domainName.empty()
      ?  Win::GetTrimmedDlgItemText(dialog, editResId)
      :  domainName;

   // The invoking code should verify this condition, but we will handle
   // it just in case.

   ASSERT(!name.empty());

   domainDnsName.erase();

   Win::WaitCursor cursor;

   bool valid      = false;
   DOMAIN_CONTROLLER_INFO* info = 0;

   do
   {
      if (name.empty())
      {
         popup.Gripe(
            dialog,
            editResId,
            String::load(IDS_MUST_ENTER_DOMAIN));
         break;
      }
      
      // determine whether we can reach a DC for the domain, and whether it is
      // a DS dc, and whether the name we're validating is truly the DNS name
      // of the domain.

      LOG(L"Validating " + name);
      HRESULT hr =
         MyDsGetDcName(
            0, 
            name,

            // force discovery to ensure that we don't pick up a cached
            // entry for a domain that may no longer exist

            DS_FORCE_REDISCOVERY | DS_DIRECTORY_SERVICE_PREFERRED,
            info);
      if (FAILED(hr) || !info)
      {
         ShowDcNotFoundErrorDialog(
            dialog,
            editResId,
            name,
            String::load(IDS_WIZARD_TITLE),
            String::format(IDS_DC_NOT_FOUND, name.c_str()),

            // name might be netbios
            
            false);
            
         break;
      }

      if (!(info->Flags & DS_DS_FLAG))
      {
         // domain is not a DS domain, or the locator could not find a DS DC
         // for that domain, so the candidate name is bad

         ShowDcNotFoundErrorDialog(
            dialog,
            editResId,
            name,
            String::load(IDS_WIZARD_TITLE),            
            String::format(IDS_DC_NOT_FOUND, name.c_str()),

            // name might be netbios
            
            false);
            
         break;
      }

      LOG(name + L" refers to DS domain");

      // here we rely on the fact that if DsGetDcName is provided a flat
      // domain name, then info->DomainName will also be the (same,
      // normalized) flat name.  Likewise, if provided a DNS domain name,
      // info->DomainName will be the (same, normalized) DNS domain name.

      if (info->Flags & DS_DNS_DOMAIN_FLAG)
      {
         // we can infer that name is a DNS domain name, since
         // info->DomainName is a DNS domain name.

         LOG(L"name is the DNS name");
         ASSERT(
               Dns::CompareNames(name, info->DomainName)
            == DnsNameCompareEqual);

         valid = true;
         break;
      }

      LOG(name + L" is not the DNS domain name");

      // the candidate name is not the DNS name of the domain.  Make another
      // call to DsGetDcName to determine the DNS domain name so we can get
      // the user to confirm.

      DOMAIN_CONTROLLER_INFO* info2 = 0;
      hr = MyDsGetDcName(0, name, DS_RETURN_DNS_NAME, info2);
      if (FAILED(hr) || !info2)
      {
         ShowDcNotFoundErrorDialog(
            dialog,
            editResId,
            name,
            String::load(IDS_WIZARD_TITLE),            
            String::format(IDS_DC_NOT_FOUND, name.c_str()),

            // name is probably netbios
            false);
            
         break;
      }

      String message =
         String::format(
            IDS_CONFIRM_DNS_NAME,
            name.c_str(),
            info2->DomainName);

      if (
         popup.MessageBox(
            dialog,
            message,
            MB_YESNO) == IDYES)
      {
         domainDnsName = info2->DomainName;

         // The user accept the dns name as the name he meant to enter. As one
         // last step, we call DsGetDcName with the dns domain name. If this
         // fails, then we are in the situation where a DC can be found with
         // netbios but not dns.  So the user has a dns configuration problem.
         // 28298

         DOMAIN_CONTROLLER_INFO* info3 = 0;
         hr =
            MyDsGetDcName(
               0, 
               domainDnsName,

               // force discovery to ensure that we don't pick up a cached
               // entry for a domain that may no longer exist

               DS_FORCE_REDISCOVERY | DS_DIRECTORY_SERVICE_PREFERRED,
               info3);
         if (FAILED(hr) || !info3)
         {
            ShowDcNotFoundErrorDialog(
               dialog,
               editResId,
               domainDnsName,
               String::load(IDS_WIZARD_TITLE),
               String::format(IDS_DC_NOT_FOUND, domainDnsName.c_str()),

               // we know the name is not netbios
               
               true);

            domainDnsName.erase();
            break;
         }
   
         ::NetApiBufferFree(info3);
         valid = true;
      }

      // the user rejected the dns name, so they are admitting that what
      // they entered was bogus.  Don't pop up an error box in this case,
      // as we have pestered the user enough.

      ::NetApiBufferFree(info2);
   }
   while (0);

   if (info)
   {
      ::NetApiBufferFree(info);
   }

#ifdef DBG
   if (!valid)
   {
      ASSERT(domainDnsName.empty());
   }
#endif

   return valid;
}



bool
ValidateDomainDoesNotExist(
   HWND           dialog,
   int            editResID)
{
   return ValidateDomainDoesNotExist(dialog, String(), editResID);
}



bool
ValidateDomainDoesNotExist(
   HWND           dialog,
   const String&  domainName,
   int            editResID)
{
   LOG_FUNCTION(ValidateDomainDoesNotExist);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResID > 0);

   // this can take awhile.

   Win::WaitCursor cursor;

   String name =
         domainName.empty()
      ?  Win::GetTrimmedDlgItemText(dialog, editResID)
      :  domainName;

   // The invoking code should verify this condition, but we will handle
   // it just in case.

   ASSERT(!name.empty());

   bool valid = true;
   String message;
   do
   {
      if (name.empty())
      {
         message = String::load(IDS_MUST_ENTER_DOMAIN);
         valid = false;
         break;
      }
      if (IsDomainReachable(name) || DS::IsDomainNameInUse(name))
      {
         message = String::format(IDS_DOMAIN_NAME_IN_USE, name.c_str());
         valid = false;
         break;
      }

      // otherwise the domain does not exist
   }
   while (0);

   if (!valid)
   {
      popup.Gripe(dialog, editResID, message);
   }

   return valid;
}



void
DisableConsoleLocking()
{
   LOG_FUNCTION(disableConsoleLocking);

   HRESULT hr = S_OK;
   do
   {
      BOOL screenSaverEnabled = FALSE;

      hr = 
         Win::SystemParametersInfo(
            SPI_GETSCREENSAVEACTIVE,
            0,
            &screenSaverEnabled,
            0);
      BREAK_ON_FAILED_HRESULT(hr);

      if (screenSaverEnabled)
      {
         // disable it.

         screenSaverEnabled = FALSE;
         hr =
            Win::SystemParametersInfo(
               SPI_SETSCREENSAVEACTIVE,
               0,
               &screenSaverEnabled,
               SPIF_SENDCHANGE);

         ASSERT(SUCCEEDED(hr));
      }
   }
   while (0);


   // turn off lock computer option in winlogon

   do
   {
      RegistryKey key;

      hr =
         key.Create(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
      BREAK_ON_FAILED_HRESULT(hr);

      // '2' means "disable for this session, reset to 0 on reboot."

      hr = key.SetValue(L"DisableLockWorkstation", 2);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);
}




void
EnableConsoleLocking()
{
   LOG_FUNCTION(EnableConsoleLocking);

#ifdef DBG
   State& state = State::GetInstance();
   ASSERT(
      state.GetRunContext() != State::PDC_UPGRADE and
      state.GetRunContext() != State::BDC_UPGRADE);
#endif 

   // CODEWORK: we don't re-enable the screensaver (we need to remember
   // if it was enabled when we called DisableConsoleLocking)

   HRESULT hr = S_OK;
   do
   {
      RegistryKey key;

      hr =
         key.Create(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
      BREAK_ON_FAILED_HRESULT(hr);

      // 0 means "enable"

      hr = key.SetValue(L"DisableLockWorkstation", 0);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);
}



bool
CheckDiskSpace(const String& path, unsigned minSpaceMB)
{
   LOG_FUNCTION(checkDiskSpace);
   ASSERT(FS::IsValidPath(path));

   String vol = FS::GetRootFolder(path);

   ULONGLONG spaceInBytes;
   memset(&spaceInBytes, 0, sizeof(ULONGLONG));

   HRESULT hr = FS::GetAvailableSpace(vol, spaceInBytes);

   if (SUCCEEDED(hr))
   {
      ULONGLONG spaceInMb = spaceInBytes / (1 << 20);

      if (spaceInMb >= minSpaceMB)
      {
         return true;
      }
   }

   return false;
}



String
GetFirstNtfs5HardDrive()
{
   LOG_FUNCTION(GetFirstNtfs5HardDrive);

   String result;
   do
   {
      StringVector dl;
      HRESULT hr = FS::GetValidDrives(std::back_inserter(dl));
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(dl.size());
      for (
         StringVector::iterator i = dl.begin();
         i != dl.end();
         ++i)
      {
         LOG(*i);

         if (
               FS::GetFileSystemType(*i) == FS::NTFS5
            && Win::GetDriveType(*i) == DRIVE_FIXED )
         {
            // found one.  good to go

            LOG(String::format(L"%1 is NTFS5", i->c_str()));

            result = *i;
            break;
         }
      }
   }
   while (0);

   LOG(result);

   return result;
}



bool
ConfirmNetbiosLookingNameIsReallyDnsName(HWND parentDialog, int editResID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(editResID > 0);

   // check if the name is a single DNS label (a single label with a trailing
   // dot does not count.  If the user is DNS-saavy enough to use an absolute
   // DNS name, then we will pester him no further.)

   String domain = Win::GetTrimmedDlgItemText(parentDialog, editResID);
   if (domain.find(L'.') == String::npos)
   {
      // no dot found: must be a single label

      if (
         popup.MessageBox(
            parentDialog,
            String::format(
               IDS_CONFIRM_NETBIOS_LOOKING_NAME,
               domain.c_str(),
               domain.c_str()),
            MB_YESNO | MB_DEFBUTTON2) == IDNO)
      {
         // user goofed.  or we frightened them.

         HWND edit = Win::GetDlgItem(parentDialog, editResID);
         Win::SendMessage(edit, EM_SETSEL, 0, -1);
         Win::SetFocus(edit);
         return false;
      }
   }

   return true;
}



bool
ComputerWasRenamedAndNeedsReboot()
{
   LOG_FUNCTION(ComputerWasRenamedAndNeedsReboot);
   
   bool result = false;

   do
   {
      String active = Computer::GetActivePhysicalNetbiosName();
      String future = Computer::GetFuturePhysicalNetbiosName();
      
      if (active.icompare(future) != 0)
      {
         // a name change is pending reboot.

         LOG(L"netbios name was changed");
         LOG(active);
         LOG(future);
      
         result = true;
         break;
      }

      // At this point, the netbios names are the same, or there is no future
      // netbios name.  So check the DNS names.

      if (IsTcpIpInstalled())
      {
         // DNS names only exist if tcp/ip is installed.

         active = Computer::GetActivePhysicalFullDnsName();
         future = Computer::GetFuturePhysicalFullDnsName();

         if (Dns::CompareNames(active, future) == DnsNameCompareNotEqual)
         {
            LOG(L"dns name was changed");
            LOG(active);
            LOG(future);
         
            result = true;
            break;
         }
      }

      // At this point, we have confirmed that there is no pending name
      // change.

      LOG(L"No pending computer name change");   
   }
   while (0);
   
   LOG_BOOL(result);
   
   return result;
}



String
GetForestName(const String& domain, HRESULT* hrOut)
{
   LOG_FUNCTION2(GetForestName, domain);
   ASSERT(!domain.empty());

   String dnsForestName;

   DOMAIN_CONTROLLER_INFO* info = 0;
   HRESULT hr =
      MyDsGetDcName(
         0,
         domain,
         DS_RETURN_DNS_NAME,
         info);
   if (SUCCEEDED(hr) && info)
   {
      ASSERT(info->DnsForestName);
      
      if (info->DnsForestName)
      {
         dnsForestName = info->DnsForestName;
      }
      ::NetApiBufferFree(info);
   }

   if (hrOut)
   {
      *hrOut = hr;
   }
   
   return dnsForestName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\capslockballoontip.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Caps lock warning Balloon tip window
//
// 7 Nov 2000 sburns (that would be election day)
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns
//
// most of this is stolen and cleaned up from johnstep's common cred ui
// ds/win32/credui



#include "headers.hxx"
#include "CapsLockBalloonTip.hpp"
#include "resource.h"



CapsLockBalloonTip::CapsLockBalloonTip()
   :
   title(String::load(IDS_CAPS_LOCK_TIP_TITLE)),
   text(String::load(IDS_CAPS_LOCK_TIP_TEXT)),
   tipWindow(0),
   parentWindow(0),
   visible(false)
{
   LOG_CTOR(CapsLockBalloonTip);
   ASSERT(!title.empty());
   ASSERT(!text.empty());
}



CapsLockBalloonTip::~CapsLockBalloonTip()
{
   LOG_DTOR(CapsLockBalloonTip);

   if (Win::IsWindow(tipWindow))
   {
      Win::DestroyWindow(tipWindow);
      tipWindow = 0;
   }
}



HRESULT
CapsLockBalloonTip::Init(HWND parentWindow_)
{
   LOG_FUNCTION(CapsLockBalloonTip::Init);
   ASSERT(Win::IsWindow(parentWindow_));

   // should not call init on the same instance twice
   
   ASSERT(!parentWindow);
   ASSERT(!tipWindow);

   if (Win::IsWindow(tipWindow))
   {
      Win::DestroyWindow(tipWindow);
   }

   HRESULT hr = S_OK;

   do
   {
      hr = Win::CreateWindowEx(
         WS_EX_TOPMOST,
         TOOLTIPS_CLASS,
         L"",
         WS_POPUP | TTS_NOPREFIX | TTS_BALLOON,
         CW_USEDEFAULT,
         CW_USEDEFAULT,
         CW_USEDEFAULT,
         CW_USEDEFAULT,
         parentWindow_,
         0,
         0,
         tipWindow);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(tipWindow);
               
      parentWindow = parentWindow_;

      TOOLINFO info;
      ::ZeroMemory(&info, sizeof(info));

      // we want to specify the stem position, so we set TTF_TRACK.  We use
      // the HWND of the parent window as the tool id, because that if what
      // v.5 of comctl32 requires (or the balloon never appears).  This is
      // a bug that has been fixed in v.6, but until fusion manifests are
      // working properly, you can't get v.6
      //
      // (when manifests are working, then we could remove TTF_IDISHWND and
      // set uId to be some fixed integer)
      
      info.uFlags   = TTF_IDISHWND | TTF_TRACK;   
      info.hwnd     = parentWindow;
      info.uId      = reinterpret_cast<UINT_PTR>(parentWindow); 
      info.lpszText = const_cast<PWCHAR>(text.c_str());

      Win::ToolTip_AddTool(tipWindow, info);
      Win::ToolTip_SetTitle(tipWindow, TTI_WARNING, title);
   }
   while (0);

   return hr;
}



void
CapsLockBalloonTip::Show(bool notHidden)
{
//   LOG_FUNCTION(CapsLockBalloonTip::Show);

   TOOLINFO info;
   ::ZeroMemory(&info, sizeof info);

   // set these members the same as in the Init method, in order to
   // identify the proper tool.
   
   info.hwnd = parentWindow; 
   info.uId = reinterpret_cast<UINT_PTR>(parentWindow); 
   
   if (notHidden)
   {
      if (!visible && Win::IsWindowEnabled(parentWindow))
      {
         Win::SetFocus(parentWindow);

         RECT rect;
         Win::GetWindowRect(parentWindow, rect);

         Win::ToolTip_TrackPosition(
            tipWindow,

            // put the stem at the point 90% along the x axis
            
            rect.left + 90 * (rect.right - rect.left) / 100,

            // and 76% along the y axis of the edit control
            
            rect.top + 76 * (rect.bottom - rect.top) / 100);

         Win::ToolTip_TrackActivate(tipWindow, true, info);   

         visible = true;
      }
   }
   else
   {
      // hide the tip window
      
      if (visible)
      {
         Win::ToolTip_TrackActivate(tipWindow, false, info);   
         visible = false;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\common.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// code common to several pages
//
// 12-16-97 sburns



String
BrowseForDomain(HWND parent);



String
BrowseForFolder(HWND parent, int titleResID);



// Returns true if the available space on the path is >= minSpaceMB.
// "available" means "taking into account quotas."
// 
// path - Fully qualified path to test.
// 
// minSpaceMB - minimum disk space in megabytes to ensure is availble on that
// path.

bool
CheckDiskSpace(const String& path, unsigned minSpaceMB);



// Return true if either of the netbios or fully-qualified computer names of
// the machine have been changed since the last time the computer was
// restarted, false otherwise.

bool
ComputerWasRenamedAndNeedsReboot();



// If the new domain name is a single DNS label, then ask the user to confirm
// that name.  If the user rejects the name, set focus to the domain name edit
// box, return false.  Otherwise, return true.
// 
// parentDialog - HWND of the dialog with the edit box control.
// 
// editResID - resource ID of the domain name edit box containing the name to
// be confirmed.
//
// 309670

bool
ConfirmNetbiosLookingNameIsReallyDnsName(HWND parentDialog, int editResID);



// Check if a screen saver or low power sleep mode is enabled.  If one is,
// disable it.  Also tell winlogon not to allow locking the console if
// necessary.  
// 
// This is to prevent the computer or user from locking the console while a
// lenthy operation is taking place.  Since the user may be logged on as an
// account that the operation destroys, once the machine is locked, there's no
// way to unlock it. 290581, 311161

void
DisableConsoleLocking();



// Enable winlogon console locking

void
EnableConsoleLocking();



// Locates a domain controller for the domain specified by the user on the
// credential page.  Returns S_OK and sets computerName if a domain controller
// is found, otherwise the error returned by DsGetDcName, converted to an
// HRESULT.
//
// domainName - the name of the domain for which a DC should be located.
//
// computerName - string to receive the domain controller name, set to empty
// on error.

HRESULT
GetDcName(const String& domainName, String& computerName);



// Return the drive letter of the first NTFS 5 drive on the system (as "X:\"),
// or empty if no such drive can be found.

String
GetFirstNtfs5HardDrive();



// Return the DNS domain name of the forest root domain for the forest that
// contains the given domain.  Return empty string if that name can't be
// determined.
// 
// domain - in, netbios or DNS domain name of a domain in a forest.
//
// hr - in/out, if the caller is curious about the failure code, he can
// retrieve it by passing a non-null pointer here.

String
GetForestName(const String& domain, HRESULT* hr = 0);



// Return the DNS name of the domain that is the parent domain of the given
// domain, or return the empty string if the domain is not a child domain
// (i.e. is a tree root domain).
// 
// childDomainDNSName - DNS name of the candidate child domain.  It is assumed
// that this domain exits.
// 
// bindWithCredentials - true: discover the parent domain by using the the
// credentials information collected on the CredentialsPage.  false: use the
// current logged-on user's credentials.

String
GetParentDomainDnsName(
   const String&  childDomainDNSName,
   bool           bindWithCredentials);



bool
IsChildDomain(bool bindWithCredentials);



bool
IsRootDomain(bool bindWithCredentials);



bool
IsForestRootDomain();



String
MassageUserName(const String& domainName, const String& userName);



HRESULT
ReadDomains(StringList& domains);



// Sets the font of a given control in a dialog.
// 
// parentDialog - Dialog containing the control.
// 
// controlID - Res ID of the control for which the font will be
// changed.
// 
// font - handle to the new font for the control.

void
SetControlFont(HWND parentDialog, int controlID, HFONT font);



// Sets the font of a control to a large point bold font as per Wizard '97
// spec.
// 
// dialog - handle to the dialog that is the parent of the control
// 
// bigBoldResID - resource id of the control to change

void
SetLargeFont(HWND dialog, int bigBoldResID);



void
ShowTroubleshooter(HWND parent, int topicResID);



// Validates a dns domain name for proper syntax and length.  If validation
// fails, presents appropriate error messages to the user, and sets the input
// focus to a given control.  Syntactically valid but non-RFC compliant dns
// names cause a warning message to be presented (but validation does not
// fail).  Returns true if the validation succeed, false if not.
// 
// dialog - handle to the dialog containing the edit box that: contains the
// name to be validated and receives focus if the validation fails.
// 
// domainName - the domain name to validate.  If the empty string, then the
// name is taken from the edit control identified by editResID.
// 
// editResID - the resource id of the edit control containing the domain name
// to be validated (if the domainName parameter is empty), also receives input
// focus if validation fails.
//
// warnOnNonRFC - issue a non-fatal warning if the name is not RFC compliant.
//
// isNonRFC - optional pointer to bool to be set to true if the name is
// not a RFC-compliant name.

bool
ValidateDomainDnsNameSyntax(
   HWND           dialog,
   const String&  domainName,
   int            editResID,
   bool           warnOnNonRFC,
   bool*          isNonRFC = 0);


// Overloads ValidateDomainDnsNameSyntax such that the domain name to be
// validated is taken from the edit control specified by editResID.

bool
ValidateDomainDnsNameSyntax(
   HWND     dialog,
   int      editResID,
   bool     warnOnNonRFC,
   bool*    isNonRFC = 0);


bool
ValidateDcInstallPath(
   const String&  path,
   HWND           parent,
   int            editResID,
   bool           requiresNTFS5 = false);



bool
ValidateChildDomainLeafNameLabel(HWND dialog, int editResID, bool parentIsNonRFC);



bool
ValidateSiteName(HWND dialog, int editResID);



// Determine if the domain name provided refers to an existing DS domain.
// Return true if it does, false if not (or if it does not refer to the domain
// the user expected).
//
// dialog - handle to the dialog containing the edit box that: contains the
// name to be validated and receives focus if the validation fails.
// 
// domainName - the domain name to validate.  If the empty string, then the
// name is taken from the edit control identified by editResID.
// 
// editResID - the resource id of the edit control containing the domain name
// to be validated (if the domainName parameter is empty), also receives input
// focus if validation fails.
//
// domainDNSName - if domainName is a netbios domain name, and it refers to a
// DS domain, then this parameter receives the DNS domain name of the domain.
// In this case, the user is prompted to confirm whether or not he intended to
// refer to the domain (because a netbios name is also a legal DNS name).  If
// the user indicates yes, that was his intention, then validation succeeds
// and the caller should use the value returned through this parameter as the
// DNS domain name.  If the answer is no, validation fails, and this parameter
// is empty.  If domainName does not refer to a DS domain, validation fails,
// and this parameter is empty.

bool
ValidateDomainExists(
   HWND           dialog,
   const String&  domainName,
   int            editResID,
   String&        domainDNSName);


// Overloads ValidateDomainExists such that the domain name to be
// validated is taken from the edit control specified by editResID.

bool
ValidateDomainExists(HWND dialog, int editResID, String& domainDNSName);



bool
ValidateDomainDoesNotExist(
   HWND           dialog,
   const String&  domainName,
   int            editResID);



bool
ValidateDomainDoesNotExist(
   HWND           dialog,
   int            editResID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\configurednsclientpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// dns client configuration page
//
// 12-22-97 sburns



#ifndef CONFIGUREDNSCLIENTPAGE_HPP_INCLUDED
#define CONFIGUREDNSCLIENTPAGE_HPP_INCLUDED



class ConfigureDnsClientPage : public DCPromoWizardPage
{
   public:

   ConfigureDnsClientPage();

   protected:

   virtual ~ConfigureDnsClientPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   ConfigureDnsClientPage(const ConfigureDnsClientPage&);
   const ConfigureDnsClientPage& operator=(const ConfigureDnsClientPage&);
};



#endif   // CONFIGUREDNSCLIENTPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\confirmationpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// confirmation page
//
// 12-22-97 sburns



#ifndef CONFIRM_HPP_INCLUDED
#define CONFIRM_HPP_INCLUDED



#include "page.hpp"
#include "MultiLineEditBoxThatForwardsEnterKey.hpp"



class ConfirmationPage : public DCPromoWizardPage
{
   public:

   ConfirmationPage();

   protected:

   virtual ~ConfirmationPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   bool
   OnWizNext();

   virtual
   int
   Validate();

   private:

   bool needToKillSelection;
   MultiLineEditBoxThatForwardsEnterKey multiLineEdit;
   
   // not defined; no copying allowed
   ConfirmationPage(const ConfirmationPage&);
   const ConfirmationPage& operator=(const ConfirmationPage&);
};



#endif   // CONFIRM_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\confirmationpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// confirmation page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "ConfirmationPage.hpp"
#include "common.hpp"
#include "resource.h"
#include "ProgressDialog.hpp"
#include "ds.hpp"
#include "state.hpp"
#include "GetCredentialsDialog.hpp"
#include "postop.hpp"
#include <DiagnoseDcNotFound.hpp>



void PromoteThreadProc(ProgressDialog& progress);



ConfirmationPage::ConfirmationPage()
   :
   DCPromoWizardPage(
      IDD_CONFIRMATION,
      IDS_CONFIRMATION_PAGE_TITLE,
      IDS_CONFIRMATION_PAGE_SUBTITLE),
   needToKillSelection(false)      
{
   LOG_CTOR(ConfirmationPage);
}



ConfirmationPage::~ConfirmationPage()
{
   LOG_DTOR(ConfirmationPage);
}



void
ConfirmationPage::OnInit()
{
   LOG_FUNCTION(ConfirmationPage::OnInit);

   // Since the multi-line edit control has a bug that causes it to eat
   // enter keypresses, we will subclass the control to make it forward
   // those keypresses to the page as WM_COMMAND messages
   // This workaround from phellyar.
   // NTRAID#NTBUG9-232092-2000/11/22-sburns

   multiLineEdit.Init(Win::GetDlgItem(hwnd, IDC_MESSAGE));
}



int
ConfirmationPage::Validate()
{
   LOG_FUNCTION(ConfirmationPage::Validate);

   // this function should never be called, as we override OnWizNext.
   ASSERT(false);

   return 0;
}



static
String
GetMessage()
{
   LOG_FUNCTION(GetMessage);

   String message;
   State& state = State::GetInstance();

   String netbiosName;
   State::RunContext context = state.GetRunContext();

   if (
         context == State::BDC_UPGRADE
      or context == State::PDC_UPGRADE)
   {
      netbiosName = state.GetComputer().GetDomainNetbiosName();
   }
   else
   {
      netbiosName = state.GetNewDomainNetbiosName();
   }

   switch (state.GetOperation())
   {
      case State::REPLICA:
      {
         message =
            String::format(
               IDS_CONFIRM_MESSAGE_REPLICA,
               state.GetReplicaDomainDNSName().c_str());

         if (state.ReplicateFromMedia())
         {
            message +=
               String::format(
                  IDS_CONFIRM_MESSAGE_REPLICATE_FROM_MEDIA,
                  state.GetReplicationSourcePath().c_str());
         }
               
         break;
      }
      case State::FOREST:
      {
         message =
            String::format(
               IDS_CONFIRM_MESSAGE_FOREST,
               state.GetNewDomainDNSName().c_str(),
               netbiosName.c_str());
         break;
      }
      case State::TREE:
      {
         message =
            String::format(
               IDS_CONFIRM_MESSAGE_TREE,
               state.GetNewDomainDNSName().c_str(),
               netbiosName.c_str(),
               state.GetParentDomainDnsName().c_str());
         break;
      }
      case State::CHILD:
      {
         message =
            String::format(
               IDS_CONFIRM_MESSAGE_CHILD,
               state.GetNewDomainDNSName().c_str(),
               netbiosName.c_str(),
               state.GetParentDomainDnsName().c_str());
         break;
      }
      case State::DEMOTE:
      {
         String domain = state.GetComputer().GetDomainDnsName();
         if (state.IsLastDCInDomain())
         {
            message =
               String::format(
                  IDS_CONFIRM_MESSAGE_DEMOTE_LAST_DC,
                  domain.c_str());
         }
         else
         {
            message =
               String::format(
                  IDS_CONFIRM_MESSAGE_DEMOTE,
                  domain.c_str());
         }
         break;
      }
      case State::ABORT_BDC_UPGRADE:
      {
         message =
            String::format(
               IDS_CONFIRM_ABORT_BDC_UPGRADE,
               netbiosName.c_str());
         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return message;
}



bool
ConfirmationPage::OnSetActive()
{
   LOG_FUNCTION(ConfirmationPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() != State::NONE);

   State& state = State::GetInstance();
   String message = GetMessage();

   State::Operation operation = state.GetOperation();
   switch (operation)
   {
      case State::REPLICA:
      case State::FOREST:
      case State::TREE:
      case State::CHILD:
      {
         // write the path options into the text box

         String pathText =
            String::format(
               IDS_CONFIRM_PATHS_MESSAGE,
               state.GetDatabasePath().c_str(),
               state.GetLogPath().c_str(),
               state.GetSYSVOLPath().c_str());

         message += pathText;

         if (state.ShouldInstallAndConfigureDns())
         {
            message += String::load(IDS_CONFIRM_INSTALL_DNS);
         }

         if (operation != State::REPLICA)
         {
            if (state.ShouldAllowAnonymousAccess())
            {
               // Only show the anon access message in forest, tree, child
               // 394387

               message += String::load(IDS_CONFIRM_DO_RAS_FIXUP);
            }

            message += String::load(IDS_DOMAIN_ADMIN_PASSWORD);
         }

         break;
      }
      case State::DEMOTE:
      case State::ABORT_BDC_UPGRADE:
      {
         // hide the path controls: do nothing

         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   Win::SetDlgItemText(hwnd, IDC_MESSAGE, message);
   needToKillSelection = true;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   if (state.RunHiddenUnattended())
   {
      return ConfirmationPage::OnWizNext();
   }

   return true;
}




void
DoOperation(
   HWND                       parentDialog,
   ProgressDialog::ThreadProc threadProc,
   int                        animationResID)
{
   LOG_FUNCTION(DoOperation);
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(threadProc);
   ASSERT(animationResID > 0);

   // the ProgressDialog::OnInit actually starts the thread.
   ProgressDialog dialog(threadProc, animationResID);
   if (
         dialog.ModalExecute(parentDialog)
      == static_cast<int>(ProgressDialog::THREAD_SUCCEEDED))
   {
      LOG(L"OPERATION SUCCESSFUL");
   }
   else
   {
      LOG(L"OPERATION FAILED");
   }
}



int
DetermineAnimation()
{
   LOG_FUNCTION(DetermineAnimation);

   State& state = State::GetInstance();
   int aviID = IDR_AVI_DOMAIN;

   switch (state.GetOperation())
   {
      case State::REPLICA:
      {
         aviID = IDR_AVI_REPLICA;
         break;
      }
      case State::DEMOTE:
      {
         aviID = IDR_AVI_DEMOTE;
         break;
      }
      case State::FOREST:
      case State::TREE:
      case State::CHILD:
      case State::ABORT_BDC_UPGRADE:
      case State::NONE:
      default:
      {
         // do nothing
         break;
      }
   }

   return aviID;
}



bool
ConfirmationPage::OnWizNext()
{
   LOG_FUNCTION(ConfirmationPage::OnWizNext);

   State& state = State::GetInstance();
   
   DoOperation(hwnd, PromoteThreadProc, DetermineAnimation());
   if (state.GetNeedsReboot())
   {
      Win::PropSheet_RebootSystem(Win::GetParent(hwnd));
   }

   int nextPage = IDD_FAILURE;
   
   if (!state.IsOperationRetryAllowed())
   {
      nextPage = IDD_FINISH;
   }
   
   GetWizard().SetNextPageID(hwnd, nextPage);
      
   return true;
}



// noRoleMessageResId - resource ID of the string to use to format messages
// when no role change error message is available.
// 
// roleMessageResId - resource ID of the string to use to format messages when
// a role change error message is available.
// 
// "is available" => an operation results message has been set on the global
// state object.

String
ComposeFailureMessageHelper(
   const Win::Error& error,
   unsigned          noRoleMessageResId,
   unsigned          roleMessageResId)
{
   State& state         = State::GetInstance();              
   String win32_message = error.GetMessage();                
   String opMessage     = state.GetOperationResultsMessage();
   String message;

   if (
          error.GetHresult() == Win32ToHresult(ERROR_DS_CANT_ON_NON_LEAF)
      and state.GetOperation() == State::DEMOTE)
   {
      // supercede the meaningless error text for this situation.

      win32_message = String::load(IDS_DEMOTE_DOMAIN_HAS_DEPENDENTS);
   }

   if (error.GetHresult() == Win32ToHresult(ERROR_CANCELLED))
   {
      // this message may be a failure message from the operation that was
      // taking place when the cancel request was received.  In that case,
      // since the cancel has occurred, we don't care about this message

      opMessage.erase();
   }

   if (error.GetHresult() == Win32ToHresult(ERROR_BAD_NETPATH))
   {
      // n27117

      win32_message = String::load(IDS_RAS_BAD_NETPATH);
   }

   if (opMessage.empty())
   {
      message =
         String::format(
            noRoleMessageResId,
            win32_message.c_str());
   }
   else
   {
      message =
         String::format(
            roleMessageResId,
            win32_message.c_str(),
            opMessage.c_str());
   }

   return message;
}
  


void
ComposeFailureMessage(
   const Win::Error& error,
   bool              wasDisjoined,
   const String&     originalDomainName)

{
   LOG_FUNCTION(ComposeFailureMessage);

   String message =
      ComposeFailureMessageHelper(
         error,
         IDS_OPERATION_FAILED_NO_RESULT_MESSAGE,
         IDS_OPERATION_FAILED);

   if (wasDisjoined)
   {
      message += String::format(IDS_DISJOINED, originalDomainName.c_str());
   }

   State& state = State::GetInstance();
   
   if (
         state.GetOperationResultsFlags()
      &  DSROLE_IFM_RESTORED_DATABASE_FILES_MOVED)
   {
      message += L"\r\n\r\n" + String::load(IDS_MUST_RESTORE_IFM_FILES_AGAIN);
   }

   state.SetFailureMessage(message);
}



String
GetSbsLimitMessage()
{
   LOG_FUNCTION(GetSbsLimitMessage);

   static String SBSLIMIT_DLL(L"sbslimit.dll");

   String message;

   HMODULE sbsDll = 0;
   HRESULT hr = 
      Win::LoadLibraryEx(
         SBSLIMIT_DLL,
         LOAD_LIBRARY_AS_DATAFILE,
         sbsDll);
   if (FAILED(hr))
   {
      LOG(L"Unable to load SBSLIMIT_DLL");

      // fall back to a message of our own

      message = String::load(IDS_SBS_LIMITATION_MESSAGE);
   }
   else
   {
      // string 3 is the dcpromo message

      message = Win::LoadString(3, sbsDll);

      HRESULT unused = Win::FreeLibrary(sbsDll);

      ASSERT(SUCCEEDED(unused));
   }

   return message;
}



// Check if this is a Small Business Server product; if so, present throw an
// error, as SBS should only allow new forest & demote.  Rather brutal to do
// it in this fashion, but SBS users should not be using dcpromo directly.
// 353854, 353856 

void
CheckSmallBusinessServerLimitations(HWND hwnd)
throw (DS::Error)
{
   LOG_FUNCTION(CheckSmallBusinessServerLimitations);
   ASSERT(Win::IsWindow(hwnd));

   State& state = State::GetInstance();
   State::Operation op = state.GetOperation();

   switch (op)
   {
      case State::TREE:
      case State::CHILD:
      case State::REPLICA:
      {
         // Tree and child operations are not allowed with the SBS product.
         // Replica is allowed, if it is of a forest root domain.

         OSVERSIONINFOEX info;
         HRESULT hr = Win::GetVersionEx(info);
         BREAK_ON_FAILED_HRESULT(hr);

         if (info.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED)
         {
            if (op == State::REPLICA)
            {
               String domain = state.GetReplicaDomainDNSName();

               // Since domain has been previously validated by calling
               // DsGetDcName, we don't anticipate that GetForestName will
               // have any difficulty.
               
               HRESULT hr = S_OK;
               String forest = GetForestName(domain, &hr);
               if (FAILED(hr))
               {
                  ShowDcNotFoundErrorDialog(
                     hwnd,
                     -1,
                     domain,
                     String::load(IDS_WIZARD_TITLE),            
                     String::format(IDS_DC_NOT_FOUND, domain.c_str()),
                     false);

                  throw
                     DS::Error(
                        hr,
                        String::format(
                           IDS_UNABLE_TO_DETERMINE_FOREST,
                           domain.c_str()),
                        String::load(IDS_WIZARD_TITLE));
               }
                              
               DNS_RELATE_STATUS compare = Dns::CompareNames(domain, forest);
               if (compare == DnsNameCompareEqual)
               {
                  LOG(L"replica is of forest root, allowing promote");
                  break;
               }
            }

            // This machine is an SBS machine under restricted license.
            // Extract an error message from an SBS dll.

            LOG(L"Is SBS Restricted");

            String message = GetSbsLimitMessage();

            // do not call state.SetOperationResultsMessage with this
            // message, rather, include it in the thrown error.

            throw
               DS::Error(
                  S_OK,    // don't trigger cred retry
                  message,
                  String::load(IDS_SMALL_BUSINESS_LIMIT));
         }

         break;
      }
      case State::DEMOTE:
      case State::FOREST:
      case State::ABORT_BDC_UPGRADE:
      case State::NONE:
      default:
      {
         // do nothing
         break;
      }
   }
}



// Picks the name of a domain controller suitable for the creation of a
// replica.  Since a server must be a member of the domain before it can be
// made a replica of that domain, the server may also be joined to the domain
// before the replica operation is attempted.
// 
// We need to ensure that the domain controller used to join the domain is the
// same domain controller used to replicate the domain.  Also, since a machine
// account for the server may already exist on one or more -- but not
// necessarily all -- domain controllers, we need to pick a domain controller
// that has that machine account.  406462
// 
// domainName - DNS domain name of domain for which a replica is to be found.
// 
// resultDcName - receives the located name, or the empty string on failure.

HRESULT
GetJoinAndReplicaDcName(const String& domainName, String& resultDcName)
{
   LOG_FUNCTION(GetJoinAndReplicaDcName);
   ASSERT(!domainName.empty());

   resultDcName.erase();

   HRESULT hr = S_OK;

   do
   {
      // determine the local computer's domain machine account name.  This is the
      // name of the local computer, plus a "$"
   
      String netbiosName = Win::GetComputerNameEx(ComputerNameNetBIOS);
      String accountName = netbiosName + L"$";

      LOG(accountName);

      // look for a domain controller that has a machine account for the local
      // computer.  Not all domain controllers may have this account, due to
      // replication latency.

      DOMAIN_CONTROLLER_INFO* info = 0;
      hr =
         MyDsGetDcNameWithAccount(
            0,
            accountName,
            UF_WORKSTATION_TRUST_ACCOUNT | UF_SERVER_TRUST_ACCOUNT,
            domainName,
            DS_DIRECTORY_SERVICE_REQUIRED | DS_FORCE_REDISCOVERY,
            info);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(info->DomainControllerName);

      if (info->DomainControllerName)
      {
         resultDcName =
            Computer::RemoveLeadingBackslashes(info->DomainControllerName);

         LOG(resultDcName);
      }

      ::NetApiBufferFree(info);

      if (!resultDcName.empty())
      {
         return hr;
      }
   }
   while (0);

   // either there is no domain controller reachable with the required
   // account, or the account does not exist, or DsGetDcName returned an
   // empty name

   LOG(L"Falling back to non-account DsGetDcName");

   return GetDcName(domainName, resultDcName);
}



void
EvaluateRoleChangeState()
throw (DS::Error)
{
   LOG_FUNCTION(EvaluateRoleChangeState);

   int messageResId = 0;   

   DSROLE_OPERATION_STATE opState = ::DsRoleOperationIdle;
   DSROLE_OPERATION_STATE_INFO* info = 0;
   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr) && info)
   {
      opState = info->OperationState;
      ::DsRoleFreeMemory(info);
   }
   else
   {
      throw
         DS::Error(
            hr,
            String::load(IDS_UNABLE_TO_DETERMINE_OP_STATE),
            String::load(IDS_WIZARD_TITLE));
   }
   
   switch (opState)
   {
      case ::DsRoleOperationIdle:
      {
         // do nothing
         
         break;
      }
      case ::DsRoleOperationActive:
      {
         // a role change operation is underway
         
         messageResId = IDS_ROLE_CHANGE_IN_PROGRESS;
         break;
      }
      case ::DsRoleOperationNeedReboot:
      {
         // a role change has already taken place, need to reboot before
         // attempting another.
         
         messageResId = IDS_ROLE_CHANGE_NEEDS_REBOOT;
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   if (messageResId)
   {
      throw
         DS::Error(
            S_OK,
            String::load(messageResId),
            String::load(IDS_WIZARD_TITLE));
   }
}



// Verify that the current role of the machine is correct for the type of
// operation we're about to attempt.  Throw an exception if it is not.

void
DoubleCheckRoleChangeState()
throw (DS::Error)
{
   LOG_FUNCTION(DoubleCheckRoleChangeState);

   // Make sure that an operation is not in progress or pending reboot.
   
   EvaluateRoleChangeState();
   
   State& state = State::GetInstance();
   Computer& computer = state.GetComputer();

   HRESULT hr = computer.Refresh();
   if (FAILED(hr))
   {
      throw
         DS::Error(
            hr,
            String::load(IDS_UNABLE_TO_DETERMINE_COMPUTER_CONFIG),
            String::load(IDS_WIZARD_TITLE));
   }
   
   switch (state.GetOperation())
   {
      case State::TREE:
      case State::CHILD:
      case State::REPLICA:
      case State::FOREST:
      case State::ABORT_BDC_UPGRADE:
      {
         // Make sure the machine is not already a DC. If the machine is
         // an NT4 DC finishing upgrade, then its role will be member
         // server, not domain controller.

         if (computer.IsDomainController())
         {
            throw
               DS::Error(
                  S_OK,
                  String::load(IDS_MACHINE_IS_ALREADY_DC),
                  String::load(IDS_WIZARD_TITLE));
         }

         break;
      }
      case State::DEMOTE:
      {
         // Make sure the machine is still a DC

         if (!computer.IsDomainController())
         {
            throw
               DS::Error(
                  S_OK,
                  String::load(IDS_MACHINE_IS_NOT_ALREADY_DC),
                  String::load(IDS_WIZARD_TITLE));
         }

         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         
         // do nothing

         break;
      }
   }
}



// thread launched by ProgressDialog::OnInit.
// CODEWORK: Man, this function has evolved into a real mess.

void 
PromoteThreadProc(ProgressDialog& progress)
{
   LOG_FUNCTION(PromoteThreadProc);

   //
   // Access to members of ProgressDialog is not, by default, threadsafe.
   // However, since the only members we access are atomic data types, this
   // is not a problem.  Note also that calls to ProgressDialog Update
   // methods usually resolve to calls to SendMessage on UI elements of the
   // dialog.  This too is threadsafe, as SendMessage is always executed
   // in the thread that created the window (tho it may block the calling
   // thread).
   //

   UINT   message      = ProgressDialog::THREAD_SUCCEEDED;
   bool   retry        = false;                           
   bool   wasDisjoined = false;                           
   State& state        = State::GetInstance();            
   String originalDomainName;

   // a reference, as we will refresh the object
   
   Computer& computer = state.GetComputer();
   State::RunContext context = state.GetRunContext();

   do
   {
      LOG(L"top of retry loop");

      DisableConsoleLocking();

      // clear the state of the operation attempt
      
      bool exceptionWasThrown = false;
      Win::Error errorThrown(0, 0);
      message = ProgressDialog::THREAD_SUCCEEDED;
      retry = false;
      state.SetOperationResultsMessage(String());
      state.SetOperationResultsFlags(0);

      progress.UpdateText(IDS_STARTING);

      try
      {
         CheckSmallBusinessServerLimitations(progress.GetHWND());

         // Double check that the role of the machine is still ok for the
         // operation to proceed.  This is mostly a paranoid check, but there
         // have been cases during development where the promotion actually
         // succeeded, but reported a failure, and attempting the operation
         // again trashes the DS.  Such problems indicate the presence of
         // other serious bugs, but if we can cheaply avoid zorching a DC,
         // then bully for us.
         // NTRAID#NTBUG9-345115-2001/03/23-sburns
         
         DoubleCheckRoleChangeState();
         
         switch (state.GetOperation())
         {
            case State::REPLICA:
            {
               // if we're using an answerfile, look for a replication partner
               // there. 107143

               String replDc;
               if (state.UsingAnswerFile())
               {
                  replDc =
                     state.GetAnswerFileOption(
                        State::OPTION_REPLICATION_SOURCE);
                  state.SetReplicationPartnerDC(replDc);
               }

               if (context != State::BDC_UPGRADE)
               {
                  String replicaDnsDomainName =
                     state.GetReplicaDomainDNSName();
                  if (!computer.IsJoinedToDomain(replicaDnsDomainName) )
                  {
                     // need to join the domain we will replicate. Determine
                     // the name of a domain controller to use for join and
                     // replication. 270233

                     if (replDc.empty())
                     {
                        // answerfile did not specify a dc.  So pick one
                        // ourselves.

                        HRESULT hr =
                           GetJoinAndReplicaDcName(
                              replicaDnsDomainName,
                              replDc);
                        if (FAILED(hr))
                        {
                           throw
                              DS::Error(
                                 hr,
                                 IDS_JOIN_DOMAIN_FAILED);
                        }
                        state.SetReplicationPartnerDC(replDc);
                     }

                     if (computer.IsJoinedToDomain())
                     {
                        originalDomainName =
                           computer.GetDomainNetbiosName();
                     }

                     progress.UpdateText(IDS_CHANGING_DOMAIN);

                     // this will unjoin if necessary

                     DS::JoinDomain(
                        replicaDnsDomainName,
                        replDc,
                        state.GetUsername(),
                        state.GetPassword(),
                        state.GetUserDomainName());

                     if (ComputerWasRenamedAndNeedsReboot())
                     {
                        // If we make it to this point, the machine was joined
                        // to a domain, and the name changed as a side-effect,
                        // and will need to be rebooted even if the promote
                        // fails. Set a flag to note that fact.
                        // NTRAID#NTBUG9-346120-2001/04/04-sburns

                        state.SetNeedsReboot();
                     }
                     
                     HRESULT hr = computer.Refresh();
                     ASSERT(SUCCEEDED(hr));

                     if (!originalDomainName.empty())
                     {
                        wasDisjoined = true;
                     }
                  }
                  
                  DS::CreateReplica(progress);
               }
               else
               {
                  DS::UpgradeBDC(progress);
               }
               break;
            }
            case State::FOREST:
            case State::TREE:
            case State::CHILD:
            {
               if (context != State::PDC_UPGRADE)
               {
                  if (computer.IsJoinedToDomain())
                  {
                     // need to unjoin the domain we belong to

                     originalDomainName = computer.GetDomainNetbiosName();
                     ASSERT(!originalDomainName.empty());

                     progress.UpdateText(
                        String::format(IDS_DISJOINING_PROGRESS,
                        originalDomainName.c_str()));

                     if (!DS::DisjoinDomain())
                     {
                        // the computer account was not removed.
                        if (!state.RunHiddenUnattended())
                        {
                           popup.Info(
                              progress.GetHWND(), 
                              String::load(IDS_COULDNT_REMOVE_COMPUTER_ACCOUNT_TEXT));
                        }
                     }

                     if (ComputerWasRenamedAndNeedsReboot())
                     {
                        // If we make it to this point, the machine was
                        // disjoined from a domain, and the name changed as a
                        // side-effect, and will need to be rebooted even if
                        // the promote fails. Set a flag to note that fact.
                        // NTRAID#NTBUG9-346120-2001/04/04-sburns

                        state.SetNeedsReboot();
                     }
                     
                     HRESULT hr = computer.Refresh();
                     ASSERT(SUCCEEDED(hr));

                     wasDisjoined = true;
                  }

                  DS::CreateNewDomain(progress);
               }
               else
               {
                  DS::UpgradePDC(progress);
               }
               break;
            }
            case State::ABORT_BDC_UPGRADE:
            {
               ASSERT(state.GetRunContext() == State::BDC_UPGRADE);
               DS::AbortBDCUpgrade();
               break;
            }
            case State::DEMOTE:
            {
               DS::DemoteDC(progress);
               break;
            }
            case State::NONE:
            default:
            {
               ASSERT(false);
               message = ProgressDialog::THREAD_FAILED;
            }
         }

         //
         // At this point, the operation was successfully completed.
         // 

         DoPostOperationStuff(progress);
         state.SetOperationResults(State::SUCCESS);
         state.SetNeedsReboot();
      }
      catch (const Win::Error& err)
      {
         LOG(L"Exception caught");

         exceptionWasThrown = true;
         errorThrown = err;

         LOG(L"catch completed");
      }

      if (exceptionWasThrown)
      {
         LOG(L"handling exception");

         // go interactive from now on

         state.ClearHiddenWhileUnattended();    // 22935

         if (
            state.GetRunContext() != State::PDC_UPGRADE and
            state.GetRunContext() != State::BDC_UPGRADE)
         {
            // re-enable console locking if not a downlevel upgrade 28496

            EnableConsoleLocking();
         }

         state.SetOperationResults(State::FAILURE);
         progress.UpdateText(String());
         message = ProgressDialog::THREAD_FAILED;

         HRESULT errorThrownHresult = errorThrown.GetHresult();

         if (!state.IsOperationRetryAllowed())
         {
            // The operation failure was such that the user should not be
            // allowed to retry it. In this case, we skip our special-case
            // handling of known failure codes (as expressed by the other else
            // if clauses here), and just report the failure.
            //         
            // NTRAID#NTBUG9-296872-2001/01/29-sburns
            
            retry = false;
         }
         else if (
               errorThrownHresult == Win32ToHresult(ERROR_ACCESS_DENIED)
            or errorThrownHresult == Win32ToHresult(ERROR_LOGON_FAILURE)
            or errorThrownHresult == Win32ToHresult(ERROR_NOT_AUTHENTICATED)
            or errorThrownHresult == Win32ToHresult(RPC_S_SEC_PKG_ERROR)
            or errorThrownHresult == Win32ToHresult(ERROR_DS_DRA_ACCESS_DENIED)
            or errorThrownHresult == Win32ToHresult(ERROR_INVALID_PASSWORD)
            or errorThrownHresult == Win32ToHresult(ERROR_PASSWORD_EXPIRED)
            or errorThrownHresult == Win32ToHresult(ERROR_ACCOUNT_DISABLED)
            or errorThrownHresult == Win32ToHresult(ERROR_ACCOUNT_LOCKED_OUT) )
         {
            // bad credentials.  ask for new ones

            String failureMessage =
               ComposeFailureMessageHelper(
                  errorThrown,
                  IDS_OPERATION_FAILED_GET_CRED_NO_RESULT,
                  IDS_OPERATION_FAILED_GET_CRED);

            GetCredentialsDialog dlg(failureMessage);
            if (dlg.ModalExecute(progress) == IDOK)
            {
               retry = true;

               // jump to top of operation loop

               continue;
            }

            LOG(L"credential retry canceled");

            ComposeFailureMessage(
               errorThrown,
               wasDisjoined,
               originalDomainName);
               
            break;
         }
         else if (errorThrownHresult == Win32ToHresult(ERROR_DOMAIN_EXISTS))
         {
            LOG(L"domain exists: prompting for re-install");

            // ask if the user wishes to reinstall the domain.

            if (
               popup.MessageBox(
                  progress.GetHWND(),
                  String::format(
                     IDS_REINSTALL_DOMAIN_MESSAGE,
                     state.GetNewDomainDNSName().c_str()),
                  MB_YESNO | MB_ICONWARNING) == IDYES)
            {
               state.SetDomainReinstallFlag(true);
               retry = true;

               // jump to top of operation loop

               continue;
            }

            LOG(L"reinstall domain retry canceled");
         }
         else if (
            errorThrownHresult ==
               Win32ToHresult(ERROR_DOMAIN_CONTROLLER_EXISTS))
         {
            LOG(L"domain controller exists: prompting to force promote");

            // ask if the user wants to re-install the domain controller

            if (
               popup.MessageBox(
                  progress.GetHWND(),
                  String::format(
                     IDS_REINSTALL_DOMAIN_CONTROLLER_MESSAGE,
                     state.GetComputer().GetNetbiosName().c_str()),
                     MB_YESNO | MB_ICONWARNING) == IDYES)
            {
               state.SetDomainControllerReinstallFlag(true);
               retry = true;

               // jump to the top of the operation loop

               continue;
            }

            LOG(L"reinstall domain controller retry canceled");
         }

         // if we're retrying, then we should have jumped to the top of
         // the loop.

         ASSERT(!retry);
         
         ComposeFailureMessage(
            errorThrown,
            wasDisjoined,
            originalDomainName);

         Win::MessageBox(
            progress.GetHWND(),
            state.GetFailureMessage(),
            errorThrown.GetSummary(), // title the error was built with
            MB_OK | MB_ICONERROR | MB_SYSTEMMODAL);
      }
   }
   while (retry);

#ifdef DBG
   if (message == ProgressDialog::THREAD_FAILED)
   {
      ASSERT(state.GetOperationResultsCode() == State::FAILURE);
   }
   else
   {
      ASSERT(state.GetOperationResultsCode() == State::SUCCESS);
   }
#endif

   LOG(L"posting message to progress window");

   HRESULT hr = Win::PostMessage(progress.GetHWND(), message, 0, 0);

   ASSERT(SUCCEEDED(hr));

   // do not call _endthread here, or stack will not be properly cleaned up
}



bool
ConfirmationPage::OnCommand(
   HWND        windowFrom,
   unsigned    controlIdFrom,
   unsigned    code)
{
   bool result = false;
   
   switch (controlIdFrom)
   {
      case IDCANCEL:
      {
         // multi-line edit control eats escape keys.  This is a workaround
         // from ericb, to forward the message to the prop sheet.

         Win::SendMessage(
            Win::GetParent(hwnd),
            WM_COMMAND,
            MAKEWPARAM(controlIdFrom, code),
            (LPARAM) windowFrom);
         break;   
      }
      case IDC_MESSAGE:
      {
         switch (code)
         {
            case EN_SETFOCUS:
            {
               if (needToKillSelection)
               {
                  // kill the text selection

                  Win::Edit_SetSel(windowFrom, -1, -1);
                  needToKillSelection = false;
                  result = true;
               }
               break;
            }
            case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
            {
               // our subclasses mutli-line edit control will send us
               // WM_COMMAND messages when the enter key is pressed.  We
               // reinterpret this message as a press on the default button of
               // the prop sheet.
               // This workaround from phellyar.
               // NTRAID#NTBUG9-232092-2000/11/22-sburns
   
               HWND propSheet = Win::GetParent(hwnd);
               WORD defaultButtonId =
                  LOWORD(Win::SendMessage(propSheet, DM_GETDEFID, 0, 0));
   
               // we expect that there is always a default button on the prop sheet
                  
               ASSERT(defaultButtonId);
   
               Win::SendMessage(
                  propSheet,
                  WM_COMMAND,
                  MAKELONG(defaultButtonId, BN_CLICKED),
                  0);
   
               result = true;
               break;
            }
         }
         break;
      }
      default:
      {
         // do nothing
         
         break;
      }
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\credentialspage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// credentials page
//
// 12-22-97 sburns



#ifndef CREDENTIALSPAGE_HPP_INCLUDED
#define CREDENTIALSPAGE_HPP_INCLUDED



class CredentialsPage : public DCPromoWizardPage
{
   public:

   CredentialsPage();

   protected:

   virtual ~CredentialsPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();

   bool
   ShouldSkipPage();

   int
   DetermineNextPage();

   bool readAnswerfile;

   // not defined; no copying allowed
   CredentialsPage(const CredentialsPage&);
   const CredentialsPage& operator=(const CredentialsPage&);
};



#endif   // CREDENTIALSPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\configurednsclientpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// dns client configuration page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "ConfigureDnsClientPage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"



ConfigureDnsClientPage::ConfigureDnsClientPage()
   :
   DCPromoWizardPage(
      IDD_CONFIG_DNS_CLIENT,
      IDS_CONFIG_DNS_CLIENT_PAGE_TITLE,
      IDS_CONFIG_DNS_CLIENT_PAGE_SUBTITLE)
{
   LOG_CTOR(ConfigureDnsClientPage);
}



ConfigureDnsClientPage::~ConfigureDnsClientPage()
{
   LOG_DTOR(ConfigureDnsClientPage);
}



bool
ConfigureDnsClientPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(ConfigureDnsClientPage::OnCommand);

   if (controlIDFrom == IDC_JUMP)
   {
      if (code == BN_CLICKED)
      {
         ShowTroubleshooter(hwnd, IDS_CONFIG_DNS_HELP_TOPIC);
         return true;
      }
   }

   return false;
}


           
void
ConfigureDnsClientPage::OnInit()
{
   LOG_FUNCTION(ConfigureDnsClientPage::OnInit);
}



bool
ConfigureDnsClientPage::OnSetActive()
{
   LOG_FUNCTION(ConfigureDnsClientPage::OnSetActive);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended() || Dns::IsClientConfigured())
   {
      LOG(L"planning to Skip Configure DNS Client page");

      Wizard& wiz = GetWizard();

      if (wiz.IsBacktracking())
      {
         // backup once again
         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = ConfigureDnsClientPage::Validate();
      if (nextPage != -1)
      {
         LOG(L"skipping DNS Client Page");         
         wiz.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



int
ConfigureDnsClientPage::Validate()
{
   LOG_FUNCTION(ConfigureDnsClientPage::Validate);

   int nextPage = -1;

   if (Dns::IsClientConfigured())
   {
      State& state = State::GetInstance();
      if (state.GetRunContext() == State::BDC_UPGRADE)
      {
         ASSERT(state.GetOperation() == State::REPLICA);

         // Get the DNS name of the domain.  If it is empty, then the domain is
         // not NT5 DS yet.

         // this will search for the domain if necessary.

         String dnsDomainName = state.GetComputer().GetDomainDnsName();
         if (dnsDomainName.empty())
         {
            String message = String::load(IDS_CONVERT_PDC_FIRST);

            LOG(message);

            popup.Info(hwnd, message);
            nextPage = IDD_REPLICA_OR_MEMBER;
         }
         else
         {
            state.SetReplicaDomainDNSName(dnsDomainName);
            nextPage = IDD_GET_CREDENTIALS;
         }
      }
      else
      {
         switch (state.GetOperation())
         {
            case State::FOREST:
            case State::TREE:
            case State::CHILD:
            case State::REPLICA:
            {
               nextPage = IDD_GET_CREDENTIALS;
               break;
            }
            case State::ABORT_BDC_UPGRADE:
            case State::DEMOTE:
            case State::NONE:
            default:
            {
               ASSERT(false);
               break;
            }
         }
      }
   }
   else
   {
      String message = String::load(IDS_CONFIG_DNS_FIRST);

      popup.Info(hwnd, message);
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\credentialspage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// get credentials page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "CredentialsPage.hpp"
#include "resource.h"
#include "state.hpp"
#include "ds.hpp"
#include "CredentialUiHelpers.hpp"
#include "common.hpp"
#include <DiagnoseDcNotFound.hpp>



CredentialsPage::CredentialsPage()
   :
   DCPromoWizardPage(
      IDD_GET_CREDENTIALS,
      IDS_CREDENTIALS_PAGE_TITLE,
      IDS_CREDENTIALS_PAGE_SUBTITLE),
   readAnswerfile(false)
{
   LOG_CTOR(CredentialsPage);

   CredUIInitControls();
}



CredentialsPage::~CredentialsPage()
{
   LOG_DTOR(CredentialsPage);
}



void
CredentialsPage::OnInit()
{
   LOG_FUNCTION(CredentialsPage::OnInit);

   HWND hwndCred = Win::GetDlgItem(hwnd, IDC_CRED);
   Credential_SetUserNameMaxChars(hwndCred, DS::MAX_USER_NAME_LENGTH);
   Credential_SetPasswordMaxChars(hwndCred, DS::MAX_PASSWORD_LENGTH);

   // Only use the smartcard flag when the machine is joined to a domain. On a
   // standalone machine, the smartcard won't have access to any domain
   // authority to authenticate it.
   // NTRAID#NTBUG9-287538-2001/01/23-sburns
   
   State& state = State::GetInstance();
   Computer& computer = state.GetComputer();
   
   DWORD flags = CRS_NORMAL | CRS_USERNAMES;
   if (
         computer.IsJoinedToDomain()

         // can only use smartcards on replica promotions
         // NTRAID#NTBUG9-311150-2001/02/19-sburns
         
      && state.GetOperation() == State::REPLICA)
   {
      flags |= CRS_SMARTCARDS;
   }
   Credential_InitStyle(hwndCred, flags);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      Dns::MAX_NAME_LENGTH);
}



void
CredentialsPage::Enable()
{
// LOG_FUNCTION(CredentialsPage::Enable);

   int next =
         (  !CredUi::GetUsername(Win::GetDlgItem(hwnd, IDC_CRED)).empty() 
         && !Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN).empty() )
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | next);
}


   
bool
CredentialsPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(CredentialsPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_CRED:
      {
         if (code == CRN_USERNAMECHANGE)
         {
            SetChanged(controlIDFrom);
            Enable();
            return true;
         }
         break;
      }
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);

            Enable();
            return true;
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



bool
CredentialsPage::ShouldSkipPage()
{
   LOG_FUNCTION(CredentialsPage::ShouldSkipPage);

   State& state = State::GetInstance();
   State::Operation oper = state.GetOperation();

   bool result = false;

   switch (oper)
   {
      case State::FOREST:
      {
         // never need credentials for new forest.

         result = true;
         break;
      }
      case State::DEMOTE:
      {
         // The demote page should circumvent this page if necessary, so if
         // we make it here, don't skip the page.

         break;
      }
      case State::ABORT_BDC_UPGRADE:
      case State::REPLICA:
      case State::TREE:
      case State::CHILD:
      {
         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return result;
}



int
CredentialsPage::DetermineNextPage()
{
   LOG_FUNCTION(CredentialsPage::DetermineNextPage);

   State& state = State::GetInstance();

   int id = IDD_PATHS;
   switch (state.GetOperation())
   {
      case State::DEMOTE:
      case State::ABORT_BDC_UPGRADE:
      {
         id = IDD_ADMIN_PASSWORD;
         break;
      }
      case State::FOREST:
      {
         id = IDD_NEW_FOREST;
         break;
      }
      case State::REPLICA:
      {
         if (state.GetRunContext() == State::BDC_UPGRADE)
         {
            id = IDD_PATHS;
         }
         else
         {
            id = IDD_REPLICA;
         }
         break;
      }
      case State::TREE:
      {
         id = IDD_NEW_TREE;
         break;
      }
      case State::CHILD:
      {
         id = IDD_NEW_CHILD;
         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return id;
}



String
GetMessage()
{
   String message;
   State& state = State::GetInstance();

   switch (state.GetOperation())
   {
      case State::ABORT_BDC_UPGRADE:
      {
         message = String::load(IDS_ABORT_BDC_UPGRADE_CREDENTIALS);
         break;
      }
      case State::TREE:
      case State::CHILD:
      case State::REPLICA:
      {
         message = String::load(IDS_PROMOTION_CREDENTIALS);
         break;
      }
      case State::DEMOTE:
      {
         // 318736 demote requires enterprise admin credentials -- for
         // root and child domains alike.

         message =
            String::format(
               IDS_ROOT_DOMAIN_CREDENTIALS,
               state.GetComputer().GetForestDnsName().c_str());
         break;
      }
      case State::FOREST:
      {
         // do nothing, the page will be skipped.

         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return message;
}



String
DefaultUserDomainName()
{
   String d;
   State& state = State::GetInstance();
   const Computer& computer = state.GetComputer();

   switch (state.GetOperation())
   {
      case State::ABORT_BDC_UPGRADE:
      case State::FOREST:
      {
         // do nothing

         break;
      }
      case State::DEMOTE:     // 301361
      case State::TREE:
      {
         d = computer.GetForestDnsName();
         break;
      }
      case State::CHILD:
      {
         d = computer.GetDomainDnsName();
         break;
      }
      case State::REPLICA:
      {
         d = computer.GetDomainDnsName();
         if (d.empty() && state.ReplicateFromMedia())
         {
            d = state.GetReplicaDomainDNSName();
         }
         break;
      }
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return d;
}


      
bool
CredentialsPage::OnSetActive()
{
   LOG_FUNCTION(CredentialsPage::OnSetActive);

   Win::WaitCursor cursor;

   State&  state    = State::GetInstance();
   Wizard& wiz      = GetWizard();         
   HWND    hwndCred = Win::GetDlgItem(hwnd, IDC_CRED);

   if (ShouldSkipPage())
   {
      LOG(L"skipping CredentialsPage");

      if (wiz.IsBacktracking())
      {
         // backup once again

         wiz.Backtrack(hwnd);
      }
      else
      {
         wiz.SetNextPageID(hwnd, DetermineNextPage());
      }

      return true;
   }

   if (!readAnswerfile && state.UsingAnswerFile())
   {
      CredUi::SetUsername(
         hwndCred,
         state.GetAnswerFileOption(State::OPTION_USERNAME));
      CredUi::SetPassword(
         hwndCred,
         state.GetEncodedAnswerFileOption(State::OPTION_PASSWORD));

      String domain = state.GetAnswerFileOption(State::OPTION_USER_DOMAIN);
      if (domain.empty())
      {
         domain = DefaultUserDomainName();
      }
      Win::SetDlgItemText(
         hwnd,
         IDC_DOMAIN,
         domain);

      readAnswerfile = true;
   }

   if (state.RunHiddenUnattended())
   {
      int nextPage = CredentialsPage::Validate();
      if (nextPage != -1)
      {
         wiz.SetNextPageID(hwnd, nextPage);
         return true;
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   // use the credentials last entered (for browsing, etc.)

   CredUi::SetUsername(hwndCred, state.GetUsername());
   CredUi::SetPassword(hwndCred, state.GetPassword());

   Win::SetDlgItemText(hwnd, IDC_DOMAIN, state.GetUserDomainName());

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);
   Enable();

   Win::SetDlgItemText(hwnd, IDC_MESSAGE, GetMessage());

   if (Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN).empty())
   {
      // supply a default domain if none already present

      Win::SetDlgItemText(hwnd, IDC_DOMAIN, DefaultUserDomainName());
   }

   return true;
}



int
CredentialsPage::Validate()
{
   LOG_FUNCTION(CredentialsPage::Validate);

   int nextPage = -1;
   
   do
   {
      if (
            !WasChanged(IDC_CRED)
         && !WasChanged(IDC_DOMAIN))
      {
         // nothing changed => nothing to validate

         nextPage = DetermineNextPage();
         break;
      }

      State& state = State::GetInstance();

      HWND          hwndCred = Win::GetDlgItem(hwnd, IDC_CRED);
      String        username = CredUi::GetUsername(hwndCred);

      if (username.empty())
      {
         popup.Gripe(hwnd, IDC_CRED, IDS_MUST_ENTER_USERNAME);
         break;
      }

      String domain = Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN);
      if (domain.empty())
      {
         popup.Gripe(hwnd, IDC_DOMAIN, IDS_MUST_ENTER_USER_DOMAIN);
         break;
      }

      Win::WaitCursor cursor;

      // the domain must be an NT 5 domain: no user of a downlevel domain
      // could perform operations in an NT 5 forest.  We get the forest name
      // of the domain ('cause that may be useful for the new tree scenario)
      // as a means of validating the domain name.  If the domain does not
      // exist, or is not an NT5 domain, then this call will fail.

      String forest = GetForestName(domain);
      if (forest.empty())
      {
         ShowDcNotFoundErrorDialog(
            hwnd,
            IDC_DOMAIN,
            domain,
            String::load(IDS_WIZARD_TITLE),            
            String::format(IDS_DC_NOT_FOUND, domain.c_str()),
            false);
         break;
      }

      if (state.GetOperation() == State::TREE)
      {
         // For the new tree case, we need to validate the forest name (a dns
         // domain name) by ensuring that we can find a writable DS DC in that
         // domain. The user may have supplied a netbios domain name, and it
         // is possible that the domain's DNS registration is broken.  Since
         // we will use the forest name as the parent domain name in the call
         // to DsRoleDcAsDc, we need to make sure we can find DCs with that
         // name. 122886

         DOMAIN_CONTROLLER_INFO* info = 0;
         HRESULT hr =
            MyDsGetDcName(
               0, 
               forest,

               // force discovery to ensure that we don't pick up a cached
               // entry for a domain that may no longer exist, writeable
               // and DS because we happen to know that's what the
               // DsRoleDcAsDc API will require.

                  DS_FORCE_REDISCOVERY
               |  DS_WRITABLE_REQUIRED
               |  DS_DIRECTORY_SERVICE_REQUIRED,
               info);
         if (FAILED(hr) || !info)
         {
            ShowDcNotFoundErrorDialog(
               hwnd,
               IDC_DOMAIN,
               forest,
               String::load(IDS_WIZARD_TITLE),               
               String::format(IDS_DC_FOR_ROOT_NOT_FOUND, forest.c_str()),

               // we know the name can't be netbios: forest names are always
               // DNS names
               
               true);
            break;
         }
   
         ::NetApiBufferFree(info);
      }

      state.SetUserForestName(forest);

      // set these now so we can read the domain topology

      state.SetUsername(username);
      state.SetPassword(CredUi::GetPassword(hwndCred));
      state.SetUserDomainName(domain);

      // cache the domain topology: this is used to validate new tree,
      // child, and replica domain names in later pages.  It's also a
      // pretty good validation of the credentials.

      HRESULT hr = state.ReadDomains();
      if (FAILED(hr))
      {
         popup.Gripe(
            hwnd,
            IDC_DOMAIN,
            hr,
            String::format(IDS_UNABLE_TO_READ_FOREST));
         break;
      }

      // valid

      ClearChanges();

      nextPage = DetermineNextPage();
   }
   while (0);

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\credentialuihelpers.cpp ===
// Copyright (c) 2000 Microsoft Corporation
// 
// Wrappers of wincrui.h APIs
// 
// 19 July 2000 sburns



#include "headers.hxx"
#include "CredentialUiHelpers.hpp"



String
CredUi::GetUsername(HWND credControl)
{
//   LOG_FUNCTION(CredUi::GetUsername);
   ASSERT(Win::IsWindow(credControl));

   String result;
   size_t length = Credential_GetUserNameLength(credControl);

   if (length)
   {
      result.resize(length + 1, 0);
      BOOL succeeded =
         Credential_GetUserName(credControl, 
         const_cast<WCHAR*>(result.c_str()),
         length);
      ASSERT(succeeded);

      if (succeeded)
      {
         result.resize(wcslen(result.c_str()));
      }
      else
      {
         result.erase();
      }
   }

//   LOG(result);

   return result;
}



EncodedString
CredUi::GetPassword(HWND credControl)
{
   LOG_FUNCTION(CredUi::GetPassword);
   ASSERT(Win::IsWindow(credControl));

   EncodedString result;

   // add 1 for super-paranoid null terminator.
   
   size_t length = Credential_GetPasswordLength(credControl) + 1;

   if (length)
   {
      WCHAR* cleartext = new WCHAR[length];
      ::ZeroMemory(cleartext, sizeof(WCHAR) * length);
      
      BOOL succeeded =
         Credential_GetPassword(
            credControl,
            cleartext,
            length - 1);
      ASSERT(succeeded);

      result.Encode(cleartext);

      // make sure we scribble out the cleartext.
      
      ::ZeroMemory(cleartext, sizeof(WCHAR) * length);
      delete[] cleartext;
   }

   // don't log the password...

   return result;
}
   


HRESULT
CredUi::SetUsername(HWND credControl, const String& username)
{
   LOG_FUNCTION(CredUi::SetUsername);
   ASSERT(Win::IsWindow(credControl));

   HRESULT hr = S_OK;

   // username may be empty

   BOOL succeeded = Credential_SetUserName(credControl, username.c_str());
   ASSERT(succeeded);

   // BUGBUG what if it failed?  Is GetLastError valid?

   return hr;
}



HRESULT
CredUi::SetPassword(HWND credControl, const EncodedString& password)
{
   LOG_FUNCTION(CredUi::SetPassword);
   ASSERT(Win::IsWindow(credControl));

   HRESULT hr = S_OK;

   // password may be empty

   WCHAR* cleartext = password.GetDecodedCopy();
   BOOL succeeded = Credential_SetPassword(credControl, cleartext);
   ASSERT(succeeded);

   ::ZeroMemory(cleartext, sizeof(WCHAR) * password.GetLength());
   delete[] cleartext;

   // BUGBUG what if it failed?  Is GetLastError valid?
   
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\credentialuihelpers.hpp ===
// Copyright (c) 2000 Microsoft Corporation
// 
// Wrappers of wincrui.h APIs
// 
// 19 July 2000 sburns



#ifndef CREDENTIALUIHELPERS_HPP_INCLUDED
#define CREDENTIALUIHELPERS_HPP_INCLUDED



namespace CredUi
{
   String
   GetUsername(HWND credControl);

   HRESULT
   SetUsername(HWND credControl, const String& username);

   EncodedString
   GetPassword(HWND credControl);

   HRESULT
   SetPassword(HWND credControl, const EncodedString& password);
}  // namespace CredUi



#endif   // #ifndef CREDENTIALUIHELPERS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\dcpromo.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// domain controller promotion wizard, Mark II
//
// 12-12-97 sburns



#include "headers.hxx"
#include "common.hpp"
#include "adpass.hpp"
#include "BadComputerNameDialog.hpp"
#include "CheckPortAvailability.hpp"
#include "ChildPage.hpp"
#include "CredentialsPage.hpp"
#include "ConfirmationPage.hpp"
#include "DemotePage.hpp"
#include "DynamicDnsPage.hpp"
#include "ConfigureDnsClientPage.hpp"
#include "DnsOnNetPage.hpp"
#include "FailurePage.hpp"
#include "finish.hpp"
#include "ForestPage.hpp"
#include "ForestVersionPage.hpp"
#include "GcConfirmationPage.hpp"
#include "NetbiosNamePage.hpp"
#include "NewDomainPage.hpp"
#include "NewSitePage.hpp"
#include "NonDomainNc.hpp"
#include "NonRfcComputerNameDialog.hpp"
#include "PathsPage.hpp"
#include "Paths2Page.hpp"
#include "PickSitePage.hpp"
#include "rasfixup.hpp"
#include "RebootDialog.hpp"
#include "ReplicaOrNewDomainPage.hpp"
#include "ReplicateFromMediaPage.hpp"
#include "ReplicaPage.hpp"
#include "ReplicaOrMemberPage.hpp"
#include "resource.h"
#include "safemode.hpp"
#include "state.hpp"
#include "InstallTcpIpPage.hpp"
#include "TreePage.hpp"
#include "WelcomePage.hpp"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;   // no context help available



// don't change this: it is also the name of a mutex that the net id ui
// uses to determine if dcpromo is running.

const wchar_t* RUNTIME_NAME = L"dcpromoui";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;


// a system modal popup thingy
Popup popup(IDS_WIZARD_TITLE, true);

// this is the mutex that indicates the dcpromo is running.

HANDLE dcpromoRunningMutex = INVALID_HANDLE_VALUE;



// these are the valid exit codes returned from the dcpromo.exe process

enum ExitCode
{
   // the operation failed.

   EXIT_CODE_UNSUCCESSFUL = 0,

   // the operation succeeded

   EXIT_CODE_SUCCESSFUL = 1,

   // the operation succeeded, and the user opted not to have the wizard
   // restart the machine, either manually or by specifying
   // RebootOnSuccess=NoAndNoPromptEither in the answerfile

   EXIT_CODE_SUCCESSFUL_NO_REBOOT = 2,

   // the operation failed, but the machine needs to be rebooted anyway

   EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT = 3
};



// Checks the platform and os version number.  Returns the resource ID of the
// string to present to the user if platform/os ver requirements are not met,
// or 0 if they are met.

unsigned
CheckPlatform()
{
   LOG_FUNCTION(CheckPlatform);

   unsigned retval = 0;

   Computer::Role role = State::GetInstance().GetComputer().GetRole();
   switch (role)
   {
      case Computer::STANDALONE_WORKSTATION:
      case Computer::MEMBER_WORKSTATION:
      {
         retval = IDS_WORKSTATION_NOT_SUPPORTED;
         break;
      }
      case Computer::STANDALONE_SERVER:
      case Computer::MEMBER_SERVER:
      case Computer::PRIMARY_CONTROLLER:
      case Computer::BACKUP_CONTROLLER:
      {
         // check OS version

         OSVERSIONINFOEX info;
         memset(&info, 0, sizeof(info));
         HRESULT hr = Win::GetVersionEx(info);
         BREAK_ON_FAILED_HRESULT(hr);

         if (
            
            // require an NT-based OS
            
               info.dwPlatformId != VER_PLATFORM_WIN32_NT

            // require Whistler (version 5.1)
               
            || !(info.dwMajorVersion == 5 && info.dwMinorVersion == 1))
         {
            retval = IDS_NT51_REQUIRED;
            break;   
         }

         if (info.wSuiteMask & VER_SUITE_BLADE)
         {
            // machine is a web blade.  Don't allow promotion.
            // NTRAID#NTBUG9-195265-2001/04/03-sburns
            
            retval = IDS_WEB_BLADE_NOT_SUPPORTED;
            break;
         }

         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return retval;
}



// Checks the role change state of the machine.  Returns the resource ID of
// the string to present to the user if the state is such that another role
// change cannot be attempted, or 0 if a role change attempt may proceed.

unsigned
CheckRoleChangeState()
{
   LOG_FUNCTION(CheckRoleChangeState);

   unsigned retval = 0;

   // check to see if a role change has taken place, or is in progress.

   DSROLE_OPERATION_STATE_INFO* info = 0;
   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr) && info)
   {
      switch (info->OperationState)
      {
         case DsRoleOperationIdle:
         {
            // do nothing
            break;
         }
         case DsRoleOperationActive:
         {
            // a role change operation is underway
            retval = IDS_ROLE_CHANGE_IN_PROGRESS;
            break;
         }
         case DsRoleOperationNeedReboot:
         {
            // a role change has already taken place, need to reboot before
            // attempting another.
            retval = IDS_ROLE_CHANGE_NEEDS_REBOOT;
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }

      ::DsRoleFreeMemory(info);
   }

   return retval;
}



// Checks for the presence of at least 1 logical drive formatted with NTFS5.
// Returns the resource ID of the string to present to the user if no such
// drive is found (which implies that the user will not be able to pick a
// sysvol path that is formatted w/ NTFS5, which implies that proceeding would
// be a waste of time.

unsigned
CheckForNtfs5()
{
   LOG_FUNCTION(CheckForNtfs5);

   if (GetFirstNtfs5HardDrive().empty())
   {
      return IDS_NO_NTFS5_DRIVES;
   }

   return 0;
}



// Checks if the machine is running in safeboot mode.  You can run dcpromo
// while in safeboot mode.

unsigned
CheckSafeBootMode()
{
   LOG_FUNCTION(CheckSafeBootMode);

   static const String
      SAFEBOOT_KEY(L"System\\CurrentControlSet\\Control\\Safeboot\\Option");

   do
   {
      RegistryKey key;

      HRESULT hr = key.Open(HKEY_LOCAL_MACHINE, SAFEBOOT_KEY);
      BREAK_ON_FAILED_HRESULT(hr);

      DWORD mode = 0;
      hr = key.GetValue(L"OptionValue", mode);

      if (mode)
      {
         return IDS_SAFEBOOT_MODE;
      }
   }
   while (0);

   return 0;
}



unsigned
CheckCertService()
{
   LOG_FUNCTION(CheckCertService);

   // If not a downlevel DC upgrade, then refuse to run until cert service
   // is removed.  356399
   
   State::RunContext context = State::GetInstance().GetRunContext();
   if (context != State::BDC_UPGRADE && context != State::PDC_UPGRADE)
   {
      if (NTService(L"CertSvc").IsInstalled())
      {
         return IDS_CERT_SERVICE_IS_INSTALLED;
      }
   }

   return 0;
}



unsigned
CheckWindirSpace()
{
   LOG_FUNCTION(CheckWindirSpace);

   // if you change this, change the error message resource too.

   static const unsigned WINDIR_MIN_SPACE_MB = 20;

   String windir = Win::GetSystemWindowsDirectory();

   if (!CheckDiskSpace(windir, 20))
   {
      return IDS_WINDIR_LOW_SPACE;
   }

   return 0;
}



// NTRAID#NTBUG9-199759-2000/10/27-sburns

unsigned
CheckComputerWasRenamedAndNeedsReboot()
{
   LOG_FUNCTION(CheckComputerWasRenamedAndNeedsReboot);

   if (ComputerWasRenamedAndNeedsReboot())
   {
      return IDS_NAME_CHANGE_NEEDS_REBOOT;
   }

   return 0;
}



// Start the Network Identification UI (aka Computer Name UI).  After calling
// this function, the app must not initiate a role change.  It should
// terminate.

void
LaunchNetId()
{
   LOG_FUNCTION(LaunchNetId);
   ASSERT(dcpromoRunningMutex != INVALID_HANDLE_VALUE);

   // net id ui attempts acquisition of our mutex to determine if we are
   // running.  So, before starting the net id ui, we need to close the
   // mutex.  Otherwise, we would create a race condition between the start of
   // the net id ui and the closure of this app.  (And yes, cynical reader, I
   // did think of that before actually encountering a problem.)

   do
   {
      Win::CloseHandle(dcpromoRunningMutex);

      // It would be extraordinarily unlikely, but in case the mutex close
      // fails, we're gonna start the net id ui anyway and risk the race
      // condition.

      String sys32Folder = Win::GetSystemDirectory();

      String commandLine =
         String::format(
            IDS_LAUNCH_NETID_COMMAND_LINE,
            sys32Folder.c_str());

      PROCESS_INFORMATION procInfo;
      ::ZeroMemory(&procInfo, sizeof(procInfo));

      STARTUPINFO startup;
      ::ZeroMemory(&startup, sizeof(startup));

      LOG(L"Calling CreateProcess");
      LOG(commandLine);

      HRESULT hr =
         Win::CreateProcess(
            commandLine,
            0,
            0,
            false, 
            0,
            0,
            String(),
            startup,
            procInfo);
      BREAK_ON_FAILED_HRESULT(hr);

      Win::CloseHandle(procInfo.hThread);
      Win::CloseHandle(procInfo.hProcess);
   }
   while (0);
}
   


// Return false if the local machine's dns hostname is bad, also pop up an
// error dialog.  Return true if the name is OK.  A bad name is one we believe
// will have problems being registered in DNS after a promotion.  The user
// must fix a bad name before proceeding.

bool
IsComputerNameOk()
{
   LOG_FUNCTION(IsComputerNameOk);

   bool result = true;

   do
   {
      State::RunContext context = State::GetInstance().GetRunContext();
      if (
            context == State::BDC_UPGRADE
         || context == State::PDC_UPGRADE
         || context == State::NT5_DC
         || !IsTcpIpInstalled() )
      {
         // If the machine is already a DC, then we don't worry about the name.
         // 
         // If the machine is a downlevel DC undergoing upgrade, then the name
         // can't be changed until dcpromo is complete.  So, we say nothing now,
         // but remind the user to rename the machine in the Finish Page.
         //
         // If TCP/IP is not installed, then the machine has no hostname
         // to check.  In this case, we will check for that with the
         // InstallTcpIpPage

         ASSERT(result == true);
        
         break;
      }

      // Then check the computer name to ensure that it can be registered in
      // DNS.

      String hostname =
         Win::GetComputerNameEx(::ComputerNamePhysicalDnsHostname);

      DNS_STATUS status =
         MyDnsValidateName(hostname, ::DnsNameHostnameLabel);

      switch (status)
      {
         case DNS_ERROR_NON_RFC_NAME:
         {
            INT_PTR dlgResult = 
               NonRfcComputerNameDialog(hostname).ModalExecute(0);

            switch (dlgResult)
            {
               case NonRfcComputerNameDialog::CONTINUE:
               {
                  // continue on with the non-rfc name

                  ASSERT(result == true);
                     
                  break;
               }
               default:
               {
                  // close the wizard and rename.

                  result = false;

                  // after calling this, we must not allow any promote
                  // operation.  We will fall out of this function, then
                  // end the app.

                  LaunchNetId();
                  break;
               }
            }

            break;
         }
         case DNS_ERROR_NUMERIC_NAME:
         {
            result = false;

            String message =
               String::format(
                  IDS_COMPUTER_NAME_IS_NUMERIC,
                  hostname.c_str());

            BadComputerNameDialog(message).ModalExecute(0);

            break;
         }
         case DNS_ERROR_INVALID_NAME_CHAR:
         case ERROR_INVALID_NAME:
         {
            result = false;

            String message =
               String::format(
                  IDS_COMPUTER_NAME_HAS_BAD_CHARS,
                  hostname.c_str());

            BadComputerNameDialog(message).ModalExecute(0);
            
            break;
         }
         case ERROR_SUCCESS:
         default:
         {
               
            break;
         }
      }
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}
      


// NTRAID#NTBUG9-346120-2001/04/04-sburns

ExitCode
HandleRebootCases()
{
   LOG_FUNCTION(HandleRebootCases);
   
   // There are two possible reasons for needing to reboot the machine:
   // the operation was successful, or the operation failed, but in the
   // attempt the machine's joined state changed.

   State& state = State::GetInstance();

   ExitCode exitCode =
         (state.GetOperationResultsCode() == State::SUCCESS)
      ?  EXIT_CODE_SUCCESSFUL
      :  EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT;

   switch (exitCode)
   {
      case EXIT_CODE_SUCCESSFUL:
      {
         if (state.RunHiddenUnattended())
         {
            String option =
               state.GetAnswerFileOption(State::OPTION_REBOOT);
            if (option.icompare(State::VALUE_YES) == 0)
            {
               ASSERT(exitCode == EXIT_CODE_SUCCESSFUL);
               HRESULT hr = Reboot();
               if (FAILED(hr))
               {
                  popup.Error(
                     Win::GetDesktopWindow(),
                     hr,
                     IDS_CANT_REBOOT);
               }
               break;
            }
            else if (option.icompare(State::VALUE_NO_DONT_PROMPT) == 0)
            {
               // user opted not to reboot the machine via answerfile
         
               LOG(L"Not rebooting, and not prompting either");

               exitCode = EXIT_CODE_SUCCESSFUL_NO_REBOOT;   
               break;
            }
         }

         RebootDialog dlg(false);
         if (dlg.ModalExecute(0))
         {
            // user opted to reboot the machine
      
            HRESULT hr = Reboot();

            ASSERT(SUCCEEDED(hr));
            ASSERT(exitCode == EXIT_CODE_SUCCESSFUL);
         }
         else
         {
            // user opted not to reboot the machine
      
            exitCode = EXIT_CODE_SUCCESSFUL_NO_REBOOT;
         }
         break;
      }
      case EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT:
      {
         // If the operation failed, then the wizard has gone into interactive
         // mode.
         
         RebootDialog dlg(true);
         if (dlg.ModalExecute(0))
         {
            // user opted to reboot the machine

            exitCode = EXIT_CODE_UNSUCCESSFUL;
            HRESULT hr = Reboot();

            ASSERT(SUCCEEDED(hr));
         }
         else
         {
            // user opted not to reboot the machine
      
            ASSERT(exitCode == EXIT_CODE_UNSUCCESSFUL_NEEDS_REBOOT);
         }
         
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return exitCode;
}



ExitCode
RunWizard()
{
   LOG_FUNCTION(RunWizard);

   // this is necessary to use the hotlink-style static text control.
// // 
// //    BOOL b = LinkWindow_RegisterClass();
// //    ASSERT(b);

   Wizard wiz(
      IDS_WIZARD_TITLE,
      IDB_BANNER16,
      IDB_BANNER256,
      IDB_WATERMARK16,
      IDB_WATERMARK256);

   // Welcome must be first
   
   wiz.AddPage(new WelcomePage());

   // These are not in any particular order...
   
   wiz.AddPage(new AdminPasswordPage());
   wiz.AddPage(new ChildPage());
   wiz.AddPage(new ConfigureDnsClientPage());
   wiz.AddPage(new ConfirmationPage());
   wiz.AddPage(new CredentialsPage());
   wiz.AddPage(new DemotePage());
   wiz.AddPage(new DnsOnNetPage());
   wiz.AddPage(new DynamicDnsPage());
   wiz.AddPage(new FailurePage());
   wiz.AddPage(new FinishPage());
   wiz.AddPage(new ForestPage());
   wiz.AddPage(new ForestVersionPage());
   wiz.AddPage(new GcConfirmationPage());
   wiz.AddPage(new InstallTcpIpPage());
   wiz.AddPage(new NetbiosNamePage());
   wiz.AddPage(new NewDomainPage());
   wiz.AddPage(new NewSitePage());
   wiz.AddPage(new Paths2Page());
   wiz.AddPage(new PathsPage());
   wiz.AddPage(new PickSitePage());
   wiz.AddPage(new RASFixupPage());
   wiz.AddPage(new ReplicaOrMemberPage());
   wiz.AddPage(new ReplicaOrNewDomainPage());
   wiz.AddPage(new ReplicaPage());
   wiz.AddPage(new ReplicateFromMediaPage());
   wiz.AddPage(new SafeModePasswordPage());
   wiz.AddPage(new TreePage());

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;

   switch (wiz.ModalExecute(Win::GetDesktopWindow()))
   {
      case -1:
      {
         popup.Error(
            Win::GetDesktopWindow(),
            E_FAIL,
            IDS_PROP_SHEET_FAILED);
         break;
      }
      case ID_PSREBOOTSYSTEM:
      {
         exitCode = HandleRebootCases();
         break;
      }
      default:
      {
         // do nothing.
         break;
      }
   }

   return exitCode;
}



// NTRAID#NTBUG9-350777-2001/04/24-sburns

bool
ShouldCancelBecauseMachineIsAppServer()
{
   LOG_FUNCTION(ShouldCancelBecauseMachineIsAppServer);

   bool result = false;
   
   do
   {
      State& state = State::GetInstance();
      State::RunContext context = state.GetRunContext();
      if (context == State::NT5_DC)
      {
         // already a DC: nothing to gripe about.
         
         break;
      }
      
      OSVERSIONINFOEX info;
      ::ZeroMemory(&info, sizeof(info));
      HRESULT hr = Win::GetVersionEx(info);
      BREAK_ON_FAILED_HRESULT(hr);

      // you're running app server if you're running terminal server and
      // not single user terminal server.
      
      bool isAppServer =
            (info.wSuiteMask & VER_SUITE_TERMINAL)
         && !(info.wSuiteMask & VER_SUITE_SINGLEUSERTS);

      if (isAppServer)
      {
         // warn the user that promotion will whack the ts policy settings

         LOG(L"machine has app server installed");

         if (!state.RunHiddenUnattended())
         {
            if (
               popup.MessageBox(
                  Win::GetDesktopWindow(),
                  IDS_APP_SERVER_WARNING,
                  MB_OKCANCEL) == IDCANCEL)
            {
               // user wishes to bail out.
            
               result = true;
               break;
            }
         }
      }
   }
   while (0);

   LOG_BOOL(result);

   return result;
}              

   

ExitCode
Start()
{
   LOG_FUNCTION(Start);

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;
   unsigned id = 0;
   do
   {
      // do the admin check first of all, cause others may fail for non-admin
      // 292749

      id = IsCurrentUserAdministrator() ? 0 : IDS_NOT_ADMIN;
      if (id)
      {
         break;
      }

      // If cert service is installed, we will probably break it on promote
      // or demote.
      // 324653

      id = CheckCertService();
      if (id)
      {
         break;
      }

      id = CheckSafeBootMode();
      if (id)
      {
         break;
      }

      // do the role change check before the platform check, as the platform
      // check may be unreliable after a demote.

      id = CheckRoleChangeState();
      if (id)
      {
         break;
      }

      id = CheckPlatform();
      if (id)
      {
         break;
      }

      id = CheckForNtfs5();
      if (id)
      {
         break;
      }

      id = CheckWindirSpace();
      if (id)
      {
         break;
      }

      id = CheckComputerWasRenamedAndNeedsReboot();
      if (id)
      {
         break;
      }
   }
   while(0);

   do
   {
      if (id)
      {
         popup.Error(
            Win::GetDesktopWindow(),
            String::load(id));
         break;
      }

      if (!IsComputerNameOk())
      {
         break;
      }

      if (ShouldCancelBecauseMachineIsAppServer())
      {
         break;
      }
      
      // NTRAID#NTBUG9-129955-2000/11/02-sburns left commented out until
      // PM decides what the real fix to this bug is.
      
      // if (!AreRequiredPortsAvailable())
      // {
      //    break;
      // }

      // there's always one more thing to check.  120143

      if (IsLastReplicaOfNonDomainNamingContexts())
      {
         break;
      }

      exitCode = RunWizard();
   }
   while (0);

   LOG(String::format(L"exitCode = %1!d!", static_cast<int>(exitCode)));
   
   return exitCode;
}



void
ShowCommandLineHelp()
{
   // CODEWORK: replace this with WinHelp, someday

   popup.MessageBox(Win::GetDesktopWindow(), IDS_COMMAND_LINE_HELP, MB_OK);
}



int WINAPI
WinMain(
   HINSTANCE   hInstance,
   HINSTANCE   /* hPrevInstance */ ,
   PSTR        /* lpszCmdLine */ ,
   int         /* nCmdShow */)
{
   hResourceModuleHandle = hInstance;

   ExitCode exitCode = EXIT_CODE_UNSUCCESSFUL;

   HRESULT hr = Win::CreateMutex(0, true, RUNTIME_NAME, dcpromoRunningMutex);
   if (hr == Win32ToHresult(ERROR_ALREADY_EXISTS))
   {
      popup.Error(Win::GetDesktopWindow(), IDS_ALREADY_RUNNING);
   }
   else
   {
      hr = ::CoInitialize(0);
      ASSERT(SUCCEEDED(hr));

      // change structure instance name so as not to accidentally offend
      // the sensibilities of the delicate reader.
      // NTRAID#NTBUG9-382719-2001/05/01-sburns
      
      INITCOMMONCONTROLSEX init_structure_not_to_contain_a_naughty_word;
      init_structure_not_to_contain_a_naughty_word.dwSize =
         sizeof(init_structure_not_to_contain_a_naughty_word);      
      init_structure_not_to_contain_a_naughty_word.dwICC  =
         ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES;

      BOOL init =
         ::InitCommonControlsEx(&init_structure_not_to_contain_a_naughty_word);
      ASSERT(init);
         
      State::Init();

      if (State::GetInstance().NeedsCommandLineHelp())
      {
         ShowCommandLineHelp();
      }
      else
      {
         exitCode = Start();
      }

      State::Destroy();
   }

   return static_cast<int>(exitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\demotepage.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// demote page
//
// 1-20-98 sburns



#ifndef DEMOTE_HPP_INCLUDED
#define DEMOTE_HPP_INCLUDED



class DemotePage : public DCPromoWizardPage
{
   public:

   DemotePage();

   protected:

   virtual ~DemotePage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   DemotePage(const DemotePage&);
   const DemotePage& operator=(const DemotePage&);

   void
   SetBulletFont();

   HFONT bulletFont;
   HICON warnIcon;
};



#endif   // DEMOTE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\dnsonnetpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// test DNS configured page
//
// 12-18-97 sburns



#include "headers.hxx"
#include "DnsOnNetPage.hpp"
#include "resource.h"
#include "state.hpp"



DnsOnNetPage::DnsOnNetPage()
   :
   DCPromoWizardPage(
      IDD_DNS_ON_NET,
      IDS_DNS_ON_NET_PAGE_TITLE,
      IDS_DNS_ON_NET_PAGE_SUBTITLE)
{
   LOG_CTOR(DnsOnNetPage);
}



DnsOnNetPage::~DnsOnNetPage()
{
   LOG_DTOR(DnsOnNetPage);
}



void
DnsOnNetPage::OnInit()
{
   LOG_FUNCTION(DnsOnNetPage::OnInit);

   if (State::GetInstance().UsingAnswerFile())
   {
      String option =
         State::GetInstance().GetAnswerFileOption(
            State::OPTION_DNS_ON_NET);
      if (option.icompare(State::VALUE_NO) == 0)
      {
         Win::CheckDlgButton(hwnd, IDC_DNS_NOT_ON_NET, BST_CHECKED);
         return;
      }
   }

   // it's important that this be the default in case the page is skipped.
   Win::CheckDlgButton(hwnd, IDC_CONFIG_CLIENT, BST_CHECKED);
}



bool
DnsOnNetPage::OnSetActive()
{
   LOG_FUNCTION(DnsOnNetPage::OnSetActive);

   // put up a wait cursor, as DNS detection may take a teeny bit of time

   Win::CursorSetting cursor(IDC_WAIT);

   State& state = State::GetInstance();
   if (Dns::IsClientConfigured() || state.RunHiddenUnattended())
   {
      Wizard& wiz = GetWizard();

      // skip this page
      if (wiz.IsBacktracking())
      {
         // backtrack once more
         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = DnsOnNetPage::Validate();
      if (nextPage != -1)
      {
         wiz.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_NEXT | PSWIZB_BACK);

   return true;
}



int
DnsOnNetPage::Validate() 
{
   LOG_FUNCTION(DnsOnNetPage::Validate);

   bool dnsOnNet = !Win::IsDlgButtonChecked(hwnd, IDC_DNS_NOT_ON_NET);
   State& state = State::GetInstance();

   state.SetDNSOnNetwork(dnsOnNet);
   
   return dnsOnNet ? IDD_CONFIG_DNS_CLIENT : IDD_NEW_FOREST;
}



bool
DnsOnNetPage::OnWizBack()
{
   LOG_FUNCTION(DnsOnNetPage::OnWizBack);

   // make sure we clear the dns on net flag => the only way it gets cleared
   // it on the 'next' button.

   State::GetInstance().SetDNSOnNetwork(true);

   return DCPromoWizardPage::OnWizBack();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\dnsonnetpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// test DNS configured page
//
// 12-18-97 sburns



#ifndef DNSNET_HPP_INCLUDED
#define DNSNET_HPP_INCLUDED



#include "page.hpp"



class DnsOnNetPage : public DCPromoWizardPage
{
   public:

   DnsOnNetPage();

   protected:

   virtual ~DnsOnNetPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // WizardPage overrides

   virtual
   bool
   OnWizBack();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   DnsOnNetPage(const DnsOnNetPage&);
   const DnsOnNetPage& operator=(const DnsOnNetPage&);
};



#endif   // DNSNET_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\ds.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// DS API wrappers
//
// 12-16-97 sburns



#include "headers.hxx"
#include "ds.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"
#include "ProgressDialog.hpp"



// CODEWORK: remove the exception throwing architecture.



DS::Error::Error(HRESULT hr_, int summaryResID)
   :
   Win::Error(hr_, summaryResID)
{
}



DS::Error::Error(HRESULT hr_, const String& msg, const String& sum)
   :
   Win::Error(hr_, msg, sum)
{
}



bool
DS::IsDomainNameInUse(const String& domainName)
{
   LOG_FUNCTION(DS::IsDomainNameInUse);
   ASSERT(!domainName.empty());

   bool result = false;
   if (!domainName.empty())
   {
      HRESULT hr = MyNetValidateName(domainName, ::NetSetupNonExistentDomain);
      if (hr == Win32ToHresult(ERROR_DUP_NAME))
      {
         result = true;
      }
   }

   LOG(
      String::format(
         L"The domain name %1 %2 in use.",
         domainName.c_str(),
         result ? L"is" : L"is NOT"));

   return result;
}



bool
DS::DisjoinDomain()
throw (DS::Error)
{
   LOG_FUNCTION(DS::DisjoinDomain);

   // make 1st attempt assuming that the current user has account
   // deletion priv on the domain.

   LOG(L"Calling NetUnjoinDomain (w/ account delete)");

   HRESULT hr =
      Win32ToHresult(
         ::NetUnjoinDomain(
            0, // this server
            0, // current account,
            0, // current password
            NETSETUP_ACCT_DELETE));

   LOG_HRESULT(hr);

   if (FAILED(hr))
   {
      // make another attempt, not removing the computer account

      LOG(L"Calling NetUnjoinDomain again, w/o account delete");

      hr = Win32ToHresult(::NetUnjoinDomain(0, 0, 0, 0));

      LOG_HRESULT(hr);

      if (SUCCEEDED(hr))
      {
         // the unjoin was successful, but the computer account was
         // left behind.

         return false;
      }
   }

   if (FAILED(hr))
   {
      throw DS::Error(hr, IDS_DISJOIN_DOMAIN_FAILED);
   }

   return true;
}



void
DS::JoinDomain(
   const String&        domainDNSName, 
   const String&        dcName,        
   const String&        userName,      
   const EncodedString& password,      
   const String&        userDomainName)
throw (DS::Error)
{
   LOG_FUNCTION(DS::JoinDomain);
   ASSERT(!domainDNSName.empty());
   ASSERT(!userName.empty());

   // password may be empty

   ULONG flags =
         NETSETUP_JOIN_DOMAIN
      |  NETSETUP_ACCT_CREATE
      |  NETSETUP_DOMAIN_JOIN_IF_JOINED
      |  NETSETUP_ACCT_DELETE;

   String massagedUserName = MassageUserName(userDomainName, userName);
   String domain = domainDNSName;

   if (!dcName.empty())
   {
      domain += L"\\" + dcName;
   }

   WCHAR* cleartext = password.GetDecodedCopy();
   
   HRESULT hr =
      MyNetJoinDomain(
         domain.c_str(),
         massagedUserName.c_str(),
         cleartext,
         flags);

   ::ZeroMemory(cleartext, sizeof(WCHAR) * password.GetLength());
   delete[] cleartext;         

   LOG_HRESULT(hr);

   if (FAILED(hr))
   {
      State& state = State::GetInstance();      
      state.SetOperationResultsMessage(
         String::format(IDS_UNABLE_TO_JOIN_DOMAIN, domainDNSName.c_str()));

      throw DS::Error(hr, IDS_JOIN_DOMAIN_FAILED);
   }
}



DWORD
MyDsRoleCancel(DSROLE_SERVEROP_HANDLE& handle)
{
   LOG(L"Calling DsRoleCancel");
   LOG(L"lpServer     : (null)");

   DWORD status = ::DsRoleCancel(0, handle);

   LOG(String::format(L"Error 0x%1!X! (!0 => error)", status));

   return status;
}



DWORD
MyDsRoleGetDcOperationProgress(
   DSROLE_SERVEROP_HANDLE& handle,
   DSROLE_SERVEROP_STATUS*& status)
{
   // LOG(L"Calling DsRoleGetDcOperationProgress");

   status = 0;
   DWORD err = ::DsRoleGetDcOperationProgress(0, handle, &status);

   // LOG(
   //    String::format(
   //       L"Error 0x%1!X! (!0 => error, 0x%2!X! = ERROR_IO_PENDING)",
   //       err,
   //       ERROR_IO_PENDING));

   // if (status)
   // {
   //    LOG(
   //       String::format(
   //          L"OperationStatus : 0x%1!X!",
   //          status->OperationStatus));
   //    LOG(status->CurrentOperationDisplayString);
   // }

   // DWORD err = ERROR_IO_PENDING;
   // status = new DSROLE_SERVEROP_STATUS;
   // status->CurrentOperationDisplayString = L"proceeding";
   // status->OperationStatus = 0;

   return err;
}



void
DoProgressLoop(
   DSROLE_SERVEROP_HANDLE& handle,
   ProgressDialog&         progressDialog)
throw (DS::Error)
{
   LOG_FUNCTION(DoProgressLoop);

   State& state = State::GetInstance();

   if (state.GetOperation() == State::DEMOTE)
   {
      // not cancelable -- turn off the cancel button.

      progressDialog.UpdateButton(String());
   }
   else
   {
      // turn on the cancel button.

      progressDialog.UpdateButton(IDS_PROGRESS_CANCEL);
   }

   DWORD  netErr                     = 0;    
   bool   criticalComplete           = false;
   bool   buttonUpdatedToFinishLater = false;
   String lastMessage;              
   ProgressDialog::WaitCode cancelButton;

   do
   {
      // wait 1500ms or for the user to hit cancel

      cancelButton = progressDialog.WaitForButton(1500);

      // get the current status of the operation

      DSROLE_SERVEROP_STATUS* status = 0;
      netErr = MyDsRoleGetDcOperationProgress(handle, status);

      if (netErr != ERROR_SUCCESS && netErr != ERROR_IO_PENDING)
      {
         // operation complete

         break;
      }

      if (!status)
      {
         LOG(L"Operation status not returned!");
         ASSERT(false);
         continue;
      }

      // update the message display

      String message = status->CurrentOperationDisplayString;
      if (message != lastMessage)
      {
         progressDialog.UpdateText(message);
         lastMessage = message;
      }

      // save the status flags for later use.

      ULONG statusFlags = status->OperationStatus;

      ::DsRoleFreeMemory(status);

      do
      {
         if (cancelButton != ProgressDialog::PRESSED)
         {
            break;
         }

         // if we make it here, user pressed the cancel button

         LOG(L"DoProgressLoop: handling cancel");
         
         ASSERT(state.GetOperation() != State::DEMOTE);

         if (criticalComplete)
         {
            // inform the user that the install is done, and that they're
            // cancelling the non-critical replication.

            popup.Info(
               progressDialog.GetHWND(),
               String::load(IDS_CANCEL_NON_CRITICAL_REPLICATION));

            // this should return ERROR_SUCCESS, and the promotion will
            // be considered complete.

            progressDialog.UpdateText(IDS_CANCELLING_REPLICATION);
            netErr = MyDsRoleCancel(handle);

            // fall out of the inner, then the outer, loop.  Then we will
            // get the operation results, which should indicate that the
            // promotion is complete, and non-critical replication was
            // canceled.

            break;
         }

         // Still doing promote, verify that the user really wants to roll
         // back to server state.

         if (
            popup.MessageBox(
               progressDialog.GetHWND(),
               String::load(IDS_CANCEL_PROMOTE),
               MB_YESNO | MB_ICONWARNING) == IDYES)
         {
            // this should return ERROR_SUCCESS, and the promotion will
            // be rolled back.

            progressDialog.UpdateText(IDS_CANCELLING);
            netErr = MyDsRoleCancel(handle);

            // fall out of the inner, then the outer, loop.  Then we will
            // get the operation results, which should indicate that the
            // promotion was cancelled as a failure code.  We handle this
            // failure code in the same manner as all others.

            break;
         }

         // user decided to press on.  reset the cancel button

         progressDialog.UpdateButton(IDS_PROGRESS_CANCEL);
         buttonUpdatedToFinishLater = false;
      }
      while (0);

      criticalComplete =
            criticalComplete
         || statusFlags & DSROLE_CRITICAL_OPERATIONS_COMPLETED;

      if (criticalComplete)
      {
         if (cancelButton == ProgressDialog::PRESSED)
         {
            // we add this message without actually checking the operation
            // results flags because for all we know, the replication will
            // finish before we get around to checking.  It is still correct
            // to say the the replication has stopped, and will start after
            // reboot.  This is always the case.

            state.AddFinishMessage(
               String::load(IDS_NON_CRITICAL_REPLICATION_CANCELED));
         }
         else
         {
            if (!buttonUpdatedToFinishLater)
            {
               progressDialog.UpdateButton(IDS_FINISH_REPLICATION_LATER);
               buttonUpdatedToFinishLater = true;
            }
         }
      }
   }
   while (netErr == ERROR_IO_PENDING);

   progressDialog.UpdateButton(String());
   buttonUpdatedToFinishLater = false;

   LOG(L"Progress loop complete.");

   if (netErr == ERROR_SUCCESS)
   {
      // we successfully endured the wait.  let's see how it turned out.

      DSROLE_SERVEROP_RESULTS* results;

      LOG(L"Calling DsRoleGetDcOperationResults");

      netErr = ::DsRoleGetDcOperationResults(0, handle, &results);

      LOG(String::format(L"Error 0x%1!X! (!0 => error)", netErr));

      if (netErr == ERROR_SUCCESS)
      {
         // we got the results

         ASSERT(results);
         if (results)
         {
            LOG(L"Operation results:");
            LOG(
               String::format(
                  L"OperationStatus      : 0x%1!X! !0 => error",
                  results->OperationStatus));
            LOG(
               String::format(
                  L"DisplayString        : %1",
                  results->OperationStatusDisplayString));
            LOG(
               String::format(
                  L"ServerInstalledSite  : %1",
                  results->ServerInstalledSite));
            LOG(
               String::format(
                  L"OperationResultsFlags: 0x%1!X!",
                  results->OperationResultsFlags));

            netErr = results->OperationStatus;

            // here, netErr will be some error code if the promote was
            // cancelled and successfully rolled back.  Since it may be
            // possible that the cancel was too late (e.g. the user took
            // too long to confirm the cancel), the promote may have
            // finished.  If that's the case, tell the user that the cancel
            // failed.

            if (
                  netErr == ERROR_SUCCESS
               && cancelButton == ProgressDialog::PRESSED)
            {
               // the promote finished, and the cancel button was pressed.

               if (!criticalComplete)  // 363590
               {
                  // we didn't find out if the non-critical replication phase
                  // started.  So the cancel button still said 'Cancel', and
                  // yet, the operation finished. so, this means that the
                  // promote simply completed before the cancel was received.

                  popup.Info(
                     progressDialog.GetHWND(),
                     IDS_CANCEL_TOO_LATE);
               }
            }

            String message =
                  results->OperationStatusDisplayString
               ?  results->OperationStatusDisplayString
               :  L"";
            String site =
                  results->ServerInstalledSite
               ?  results->ServerInstalledSite
               :  L"";

            progressDialog.UpdateText(message);

            if (!site.empty())
            {
               state.SetInstalledSite(site);
            }
            if (!message.empty())
            {
               state.SetOperationResultsMessage(message);
            }

            state.SetOperationResultsFlags(results->OperationResultsFlags);
            
            if (
                  results->OperationResultsFlags
               &  DSROLE_NON_FATAL_ERROR_OCCURRED)
            {
               state.AddFinishMessage(
                  String::load(IDS_NON_FATAL_ERRORS_OCCURRED));
            }
            if (
                  (results->OperationResultsFlags
                   & DSROLE_NON_CRITICAL_REPL_NOT_FINISHED)
               && cancelButton != ProgressDialog::PRESSED )
            {
               // cancel not pressed and critial replication bombed

               state.AddFinishMessage(
                  String::load(IDS_NON_CRITICAL_REPL_FAILED));
            }
            if (
                  results->OperationResultsFlags
               &  DSROLE_IFM_RESTORED_DATABASE_FILES_MOVED)
            {
               LOG(L"restored files were moved");

               if (netErr != ERROR_SUCCESS)
               {
                  // only need to mention this in the case of a fatal failure;
                  // e.g. don't add this finish text if non-fatal errors
                  // occurred.
                  // NTRAID#NTBUG9-330378-2001/02/28-sburns
                  
                  state.AddFinishMessage(
                     String::load(IDS_MUST_RESTORE_IFM_FILES_AGAIN));
               }
            }

            ::DsRoleFreeMemory(results);
         }
      }
   }

   if (netErr != ERROR_SUCCESS)
   {
      // couldn't get progress updates, or couldn't get results,
      // or result was a failure

      throw DS::Error(Win32ToHresult(netErr), IDS_SET_ROLE_AS_DC_FAILED);
   }
}



void
EmptyFolder(const String& path)
throw (DS::Error)
{
   LOG_FUNCTION2(EmptyFolder, path);
   ASSERT(!path.empty());

   // check for files/subfolders once again (we checked the first time on
   // validating the path), in case something has written to the folder
   // since we validated it last.

   if (!FS::IsFolderEmpty(path))
   {
      // nuke the files in the directory

      LOG(String::format(L"Emptying %1", path.c_str()));

      String wild = path;

      if (wild[wild.length() - 1] != L'\\')
      {
         wild += L"\\";
      }

      wild += L"*.*";

      FS::Iterator iter(
         wild,
            FS::Iterator::INCLUDE_FILES
         |  FS::Iterator::RETURN_FULL_PATHS);

      HRESULT hr = S_OK;
      String current;

      while ((hr = iter.GetCurrent(current)) == S_OK)
      {
         LOG(String::format(L"Deleting %1", current.c_str()));

         hr = Win::DeleteFile(current);
         if (FAILED(hr))
         {
            int msgId = IDS_EMPTY_DIR_FAILED;

            if (hr == Win32ToHresult(ERROR_ACCESS_DENIED))
            {
               msgId = IDS_EMPTY_DIR_FAILED_ACCESS_DENIED;
            }

            throw 
               DS::Error(
                  S_OK, // so as not to trigger credentials dialog
                  String::format(
                     msgId,
                     GetErrorMessage(hr).c_str(),
                     path.c_str()),
                  String::load(IDS_ERROR_PREPARING_OPERATION));
         }

         hr = iter.Increment();
         BREAK_ON_FAILED_HRESULT(hr);
      }
   }
}



HRESULT
SetupPaths()
{
   LOG_FUNCTION(SetupPaths);

   State& state      = State::GetInstance();   
   String dbPath     = state.GetDatabasePath();
   String logPath    = state.GetLogPath();     
   String sysvolPath = state.GetSYSVOLPath();  

   ASSERT(!dbPath.empty());
   ASSERT(!logPath.empty());
   ASSERT(!sysvolPath.empty());

   HRESULT hr = S_OK;

   do
   {
      if (FS::PathExists(dbPath))
      {
         EmptyFolder(dbPath);
      }
      else
      {
         hr = FS::CreateFolder(dbPath);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      if (FS::PathExists(logPath))
      {
         EmptyFolder(logPath);
      }
      else
      {
         hr = FS::CreateFolder(logPath);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      if (FS::PathExists(sysvolPath))
      {
         EmptyFolder(sysvolPath);
      }
      else
      {
         hr = FS::CreateFolder(sysvolPath);
         BREAK_ON_FAILED_HRESULT(hr);
      }
   }
   while (0);

   return hr;
}



// Sets the promotion flags based on options set in the unattended execution
// answerfile.
// 
// state - IN reference to the global State object
// 
// flags - IN/OUT promote API flags, may be modified on exit

void
SetAnswerFilePromoteFlags(
   State& state,
   ULONG& flags)
{
   LOG_FUNCTION(SetAnswerFilePromoteFlags);

   if (state.UsingAnswerFile())
   {
      // set flags based on unattended execution options

      // if the safe mode admin password is not specified, then we set a
      // flag to cause the promote APIs to copy the current local admin
      // password.

      EncodedString safeModePassword = state.GetSafeModeAdminPassword();

      if (safeModePassword.IsEmpty() && state.RunHiddenUnattended())
      {
         // user did not supply a safemode password, and he did not have
         // an opportunity to do so (if the wizard went interactive)

         if (!state.IsSafeModeAdminPwdOptionPresent())
         {
            // the safe mode pwd key is not present in the answerfile

            flags |= DSROLE_DC_DEFAULT_REPAIR_PWD;
         }
      }

      String option =
         state.GetAnswerFileOption(State::OPTION_CRITICAL_REPLICATION_ONLY);
      if (option.icompare(State::VALUE_YES) == 0)
      {
         flags |= DSROLE_DC_CRITICAL_REPLICATION_ONLY;
      }
   }

   LOG(String::format(L"0x%1!X!", flags));
}



void
DS::CreateReplica(ProgressDialog& progressDialog, bool invokeForUpgrade)
throw (DS::Error)
{
   LOG_FUNCTION(DS::CreateReplica);

   State& state = State::GetInstance();

   String domain           = state.GetReplicaDomainDNSName(); 
   String dbPath           = state.GetDatabasePath();         
   String logPath          = state.GetLogPath();              
   String sysvolPath       = state.GetSYSVOLPath();           
   String site             = state.GetSiteName();             
   String username         = state.GetUsername();             
   String replicationDc    = state.GetReplicationPartnerDC(); 
   String sourcePath       = state.GetReplicationSourcePath();
   bool   useSourcePath    = state.ReplicateFromMedia();

   EncodedString syskey           = state.GetSyskey();               
   EncodedString safeModePassword = state.GetSafeModeAdminPassword();
   EncodedString password         = state.GetPassword();             

   bool useCurrentUserCreds = username.empty();
   ULONG flags =
         DSROLE_DC_FORCE_TIME_SYNC
      |  DSROLE_DC_CREATE_TRUST_AS_REQUIRED;

   if (invokeForUpgrade)
   {
      flags |= DSROLE_DC_DOWNLEVEL_UPGRADE;
   }
   if (state.GetDomainControllerReinstallFlag())
   {
      flags |= DSROLE_DC_ALLOW_DC_REINSTALL;
   }

   SetAnswerFilePromoteFlags(state, flags);

   if (useSourcePath)
   {
      if (state.GetRestoreGc())
      {
         flags |= DSROLE_DC_REQUEST_GC;
      }
   }

   ASSERT(!domain.empty());

   if (!useCurrentUserCreds)
   {
      String user_domain = state.GetUserDomainName();
      username = MassageUserName(user_domain, username);
   }

   HRESULT hr = S_OK;
   do
   {
      hr = SetupPaths();
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"Calling DsRoleDcAsReplica");
      LOG(               L"lpServer               : (null)");
      LOG(String::format(L"lpDnsDomainName        : %1", domain.c_str()));
      LOG(String::format(L"lpReplicaServer        : %1", replicationDc.empty() ? L"(null)" : replicationDc.c_str()));
      LOG(String::format(L"lpSiteName             : %1", site.empty() ? L"(null)" : site.c_str()));
      LOG(String::format(L"lpDsDatabasePath       : %1", dbPath.c_str()));
      LOG(String::format(L"lpDsLogPath            : %1", logPath.c_str()));
      LOG(String::format(L"lpRestorePath          : %1", useSourcePath ? sourcePath.c_str() : L"(null)"));
      LOG(String::format(L"lpSystemVolumeRootPath : %1", sysvolPath.c_str()));
      LOG(String::format(L"lpAccount              : %1", useCurrentUserCreds ? L"(null)" : username.c_str()));
      LOG(String::format(L"Options                : 0x%1!X!", flags));

      WCHAR* safeModePasswordCopy = 0;
      if (!safeModePassword.IsEmpty())
      {
         safeModePasswordCopy = safeModePassword.GetDecodedCopy();
      }
      
      WCHAR* passwordCopy = 0;
      if (!useCurrentUserCreds)
      {
         passwordCopy = password.GetDecodedCopy();
      }
      
      // The api wants to scribble over the syskey, so we make a copy for
      // it to do so.

      WCHAR* syskeyCopy = 0;
      if (useSourcePath && !syskey.IsEmpty())
      {
         syskeyCopy = syskey.GetDecodedCopy();
      }

      DSROLE_SERVEROP_HANDLE handle = 0;
      hr =
         Win32ToHresult(
            ::DsRoleDcAsReplica(
               0, // this server
               domain.c_str(),

               // possibly empty, e.g. if we didn't join a domain...

               replicationDc.empty() ? 0 : replicationDc.c_str(),
               site.empty() ? 0 : site.c_str(),
               dbPath.c_str(),
               logPath.c_str(),
               useSourcePath ? sourcePath.c_str() : 0,
               sysvolPath.c_str(),
               syskeyCopy,
               (useCurrentUserCreds ? 0 : username.c_str()),
               passwordCopy,
               safeModePasswordCopy,
               flags,
               &handle));

      if (safeModePasswordCopy)
      {
         ::ZeroMemory(
            safeModePasswordCopy,
            sizeof(WCHAR) * safeModePassword.GetLength());
         delete[] safeModePasswordCopy;
      }

      if (passwordCopy)
      {
         ::ZeroMemory(passwordCopy, sizeof(WCHAR) * password.GetLength());
         delete[] passwordCopy;
      }
               
      // the copy of the syskey has already been scribbled on, so just
      // delete it.
      
      delete[] syskeyCopy;

      BREAK_ON_FAILED_HRESULT(hr);

      DoProgressLoop(handle, progressDialog);
   }
   while (0);

   if (FAILED(hr))
   {
      throw DS::Error(hr, IDS_SET_ROLE_AS_DC_FAILED);
   }
}



void
DS::CreateNewDomain(ProgressDialog& progressDialog)
throw (DS::Error)
{
   LOG_FUNCTION(DS::CreateNewDomain);

   State& state = State::GetInstance();

   String domain           = state.GetNewDomainDNSName();     
   String flatName         = state.GetNewDomainNetbiosName(); 
   String site             = state.GetSiteName();             
   String dbPath           = state.GetDatabasePath();         
   String logPath          = state.GetLogPath();              
   String sysvolPath       = state.GetSYSVOLPath();           
   String parent           = state.GetParentDomainDnsName();  
   String username         = state.GetUsername();             

   EncodedString password         = state.GetPassword();             
   EncodedString safeModePassword = state.GetSafeModeAdminPassword();
   EncodedString adminPassword    = state.GetAdminPassword();        

   State::Operation operation = state.GetOperation();
   bool useParent =
      (  operation == State::TREE
      || operation == State::CHILD);
   bool useCurrentUserCreds = username.empty();

   ULONG flags =
         DSROLE_DC_CREATE_TRUST_AS_REQUIRED
      |  DSROLE_DC_FORCE_TIME_SYNC;

   if (state.GetDomainReinstallFlag())
   {
      flags |= DSROLE_DC_ALLOW_DOMAIN_REINSTALL;
   }

   if (state.GetDomainControllerReinstallFlag())
   {
      flags |= DSROLE_DC_ALLOW_DC_REINSTALL;
   }

   if (operation == State::TREE)
   {
      flags |= DSROLE_DC_TRUST_AS_ROOT;

      ASSERT(!parent.empty());
   }

   SetAnswerFilePromoteFlags(state, flags);

   if (state.ShouldAllowAnonymousAccess())
   {
      flags |= DSROLE_DC_ALLOW_ANONYMOUS_ACCESS;
   }

   if (operation == State::FOREST)
   {
      flags |= DSROLE_DC_NO_NET;

      ASSERT(!site.empty());
   }

#ifdef DBG

   else if (operation == State::CHILD)
   {
      ASSERT(!parent.empty());
   }

   ASSERT(!domain.empty());
   ASSERT(!flatName.empty());

   // parent may be empty

#endif

   if (!useCurrentUserCreds)
   {
      String userDomain = state.GetUserDomainName();
      username = MassageUserName(userDomain, username);
   }

   HRESULT hr = S_OK;
   do
   {
      hr = SetupPaths();
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"Calling DsRoleDcAsDc");
      LOG(               L"lpServer               : (null)");
      LOG(String::format(L"lpDnsDomainName        : %1", domain.c_str()));
      LOG(String::format(L"lpFlatDomainName       : %1", flatName.c_str()));
      LOG(String::format(L"lpSiteName             : %1", site.empty() ? L"(null)" : site.c_str()));
      LOG(String::format(L"lpDsDatabasePath       : %1", dbPath.c_str()));
      LOG(String::format(L"lpDsLogPath            : %1", logPath.c_str()));
      LOG(String::format(L"lpSystemVolumeRootPath : %1", sysvolPath.c_str()));
      LOG(String::format(L"lpParentDnsDomainName  : %1", useParent ? parent.c_str() : L"(null)"));
      LOG(               L"lpParentServer         : (null)");
      LOG(String::format(L"lpAccount              : %1", useCurrentUserCreds ? L"(null)" : username.c_str()));
      LOG(String::format(L"Options                : 0x%1!X!", flags));

      WCHAR* safeModePasswordCopy = 0;
      if (!safeModePassword.IsEmpty())
      {
         safeModePasswordCopy = safeModePassword.GetDecodedCopy();
      }

      WCHAR* adminPasswordCopy = 0;
      if (!adminPassword.IsEmpty())
      {
         adminPasswordCopy = adminPassword.GetDecodedCopy();
      }

      WCHAR* passwordCopy = 0;
      if (!useCurrentUserCreds)
      {
         passwordCopy = password.GetDecodedCopy();
      }
      
      DSROLE_SERVEROP_HANDLE handle = 0;
      hr =
         Win32ToHresult(
            DsRoleDcAsDc(
               0, // this server
               domain.c_str(),
               flatName.c_str(),
               adminPasswordCopy,
               site.empty() ? 0 : site.c_str(),
               dbPath.c_str(),
               logPath.c_str(),
               sysvolPath.c_str(),
               (useParent ? parent.c_str() : 0),
               0, // let API pick a server
               (useCurrentUserCreds ? 0 : username.c_str()),
               passwordCopy,
               safeModePasswordCopy,
               flags,
               &handle));
      BREAK_ON_FAILED_HRESULT(hr);

      if (safeModePasswordCopy)
      {
         ::ZeroMemory(
            safeModePasswordCopy,
            sizeof(WCHAR) * safeModePassword.GetLength());
         delete[] safeModePasswordCopy;
      }

      if (adminPasswordCopy)
      {
         ::ZeroMemory(
            adminPasswordCopy,
            sizeof(WCHAR) * adminPassword.GetLength());
         delete[] adminPasswordCopy;
      }

      if (passwordCopy)
      {
         ::ZeroMemory(passwordCopy, sizeof(WCHAR) * password.GetLength());
         delete[] passwordCopy;
      }
      
      DoProgressLoop(handle, progressDialog);
   }
   while (0);

   if (FAILED(hr))
   {
      throw DS::Error(hr, IDS_SET_ROLE_AS_DC_FAILED);
   }
}



void
DS::UpgradeBDC(ProgressDialog& progressDialog)
throw (DS::Error)
{
   LOG_FUNCTION(DS::UpgradeBDC);

   // seems non-intuitive to abort the upgrade to do the upgrade, but here
   // the abort removes dcpromo autostart, and turns the machine into a
   // standalone server.  Then we proceed to make it a replica.

   DS::AbortBDCUpgrade(true);
   DS::CreateReplica(progressDialog, true);
}



void
DS::UpgradePDC(ProgressDialog& progressDialog)
throw (DS::Error)
{
   LOG_FUNCTION(DS::UpgradePDC);

   State& state = State::GetInstance();
   ASSERT(state.GetRunContext() == State::PDC_UPGRADE);

   String domain           = state.GetNewDomainDNSName();     
   String site             = state.GetSiteName();             
   String dbPath           = state.GetDatabasePath();         
   String logPath          = state.GetLogPath();              
   String sysvolPath       = state.GetSYSVOLPath();           
   String parent           = state.GetParentDomainDnsName();  
   String username         = state.GetUsername();             

   EncodedString password         = state.GetPassword();             
   EncodedString safeModePassword = state.GetSafeModeAdminPassword();

   State::Operation operation = state.GetOperation();
   bool useParent =
      (  operation == State::TREE
      || operation == State::CHILD);
   bool useCurrentUserCreds = username.empty();

   ULONG flags = DSROLE_DC_CREATE_TRUST_AS_REQUIRED;

   if (state.GetDomainReinstallFlag())
   {
      flags |= DSROLE_DC_ALLOW_DOMAIN_REINSTALL;
   }

   if (state.GetDomainControllerReinstallFlag())
   {
      flags |= DSROLE_DC_ALLOW_DC_REINSTALL;
   }

   if (state.GetSetForestVersionFlag())
   {
      flags |= DSROLE_DC_SET_FOREST_CURRENT;
   }

   if (operation == State::TREE)
   {
      flags |= DSROLE_DC_TRUST_AS_ROOT | DSROLE_DC_FORCE_TIME_SYNC;
      ASSERT(!parent.empty());
   }
   else if (operation == State::CHILD)
   {
      flags |= DSROLE_DC_FORCE_TIME_SYNC;
      ASSERT(!parent.empty());
   }

   SetAnswerFilePromoteFlags(state, flags);

   if (state.ShouldAllowAnonymousAccess())
   {
      flags |= DSROLE_DC_ALLOW_ANONYMOUS_ACCESS;
   }

#ifdef DBG
   ASSERT(!domain.empty());

   // parent may be empty

   if (operation == State::FOREST)
   {
      ASSERT(!site.empty());
   }
#endif

   if (!useCurrentUserCreds)
   {
      String userDomain = state.GetUserDomainName();
      username = MassageUserName(userDomain, username);
   }

   HRESULT hr = S_OK;
   do
   {
      hr = SetupPaths();
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"Calling DsRoleUpgradeDownlevelServer");
      LOG(String::format(L"lpDnsDomainName        : %1", domain.c_str()));
      LOG(String::format(L"lpSiteName             : %1", site.empty() ? L"(null)" : site.c_str()));
      LOG(String::format(L"lpDsDatabasePath       : %1", dbPath.c_str()));
      LOG(String::format(L"lpDsLogPath            : %1", logPath.c_str()));
      LOG(String::format(L"lpSystemVolumeRootPath : %1", sysvolPath.c_str()));
      LOG(String::format(L"lpParentDnsDomainName  : %1", useParent ? parent.c_str() : L"(null)"));
      LOG(               L"lpParentServer         : (null)");
      LOG(String::format(L"lpAccount              : %1", useCurrentUserCreds ? L"(null)" : username.c_str()));
      LOG(String::format(L"Options                : 0x%1!X!", flags));

      WCHAR* safeModePasswordCopy = 0;
      if (!safeModePassword.IsEmpty())
      {
         safeModePasswordCopy = safeModePassword.GetDecodedCopy();
      }
      
      WCHAR* passwordCopy = 0;
      if (!useCurrentUserCreds)
      {
         passwordCopy = password.GetDecodedCopy();
      }

      DSROLE_SERVEROP_HANDLE handle = 0;
      hr =
         Win32ToHresult(   
            ::DsRoleUpgradeDownlevelServer(
               domain.c_str(),
               site.empty() ? 0 : site.c_str(),
               dbPath.c_str(),
               logPath.c_str(),
               sysvolPath.c_str(),
               (useParent ? parent.c_str() : 0),
               0, // let API pick a server
               (useCurrentUserCreds ? 0 : username.c_str()),
               passwordCopy,
               safeModePasswordCopy,
               flags,
               &handle));
      BREAK_ON_FAILED_HRESULT(hr);

      if (safeModePasswordCopy)
      {
         ::ZeroMemory(
            safeModePasswordCopy,
            sizeof(WCHAR) * safeModePassword.GetLength());
         delete[] safeModePasswordCopy;
      }
      
      if (passwordCopy)
      {
         ::ZeroMemory(passwordCopy, sizeof(WCHAR) * password.GetLength());
         delete[] passwordCopy;
      }

      DoProgressLoop(handle, progressDialog);
   }
   while (0);

   if (FAILED(hr))
   {
      throw DS::Error(hr, IDS_UPGRADE_DC_FAILED);
   }
}



void
DS::DemoteDC(ProgressDialog& progressDialog)
throw (DS::Error)
{
   LOG_FUNCTION(DS::DemoteDC);

   State& state = State::GetInstance();

   String username            = state.GetUsername();     
   bool   useCurrentUserCreds = username.empty();        
   bool   isLastDc            = state.IsLastDCInDomain();
   EncodedString adminPassword= state.GetAdminPassword();
   EncodedString password     = state.GetPassword();     

   if (!useCurrentUserCreds)
   {
      String userDomain = state.GetUserDomainName();
      username = MassageUserName(userDomain, username);
   }

   ULONG options = DSROLE_DC_CREATE_TRUST_AS_REQUIRED;
   if (isLastDc)
   {
      options |= DSROLE_DC_DELETE_PARENT_TRUST;
   }

   LOG(L"Calling DsRoleDemoteDc");
   LOG(               L"lpServer               : (null)");
   LOG(               L"lpDnsDomainName        : (null)");
   LOG(String::format(L"ServerRole             : %1", isLastDc ? L"DsRoleServerStandalone" : L"DsRoleServerMember"));
   LOG(String::format(L"lpAccount              : %1", useCurrentUserCreds ? L"(null)" : username.c_str()));
   LOG(String::format(L"Options                : 0x%1!X!", options));
   LOG(String::format(L"fLastDcInDomain        : %1", isLastDc ? L"true" : L"false"));

   WCHAR* adminPasswordCopy = 0;
   if (!adminPassword.IsEmpty())
   {
      adminPasswordCopy = adminPassword.GetDecodedCopy();
   }
   
   WCHAR* passwordCopy = 0;
   if (!useCurrentUserCreds)
   {
      passwordCopy = password.GetDecodedCopy();
   }

   DSROLE_SERVEROP_HANDLE handle = 0;
   HRESULT hr =
      Win32ToHresult(
         ::DsRoleDemoteDc(
            0, // this server
            0, // "default" domain hosted by this server
            isLastDc ? DsRoleServerStandalone : DsRoleServerMember,
            (useCurrentUserCreds ? 0 : username.c_str()),
            passwordCopy,
            options,
            isLastDc ? TRUE : FALSE,
            adminPasswordCopy,
            &handle));
   LOG_HRESULT(hr);

   if (adminPasswordCopy)
   {
      ::ZeroMemory(
         adminPasswordCopy,
         sizeof(WCHAR) * adminPassword.GetLength());
      delete[] adminPasswordCopy;
   }
   
   if (passwordCopy)
   {
      ::ZeroMemory(passwordCopy, sizeof(WCHAR) * password.GetLength());
      delete[] passwordCopy;
   }

   if (SUCCEEDED(hr))
   {
      DoProgressLoop(handle, progressDialog);
   }
   else
   {
      throw DS::Error(hr, IDS_DEMOTE_DC_FAILED);
   }
}



void
DS::AbortBDCUpgrade(bool abortForReplica)
throw (DS::Error)
{
   LOG_FUNCTION(DS::AbortBDCUpgrade);

   State& state = State::GetInstance();
   ASSERT(state.GetRunContext() == State::BDC_UPGRADE);

   String username            = state.GetUsername();     
   bool   useCurrentUserCreds = username.empty();        

   EncodedString adminPassword       = state.GetAdminPassword();
   EncodedString password            = state.GetPassword();     
   
   if (!useCurrentUserCreds)
   {
      String userDomain = state.GetUserDomainName();
      username = MassageUserName(userDomain, username);
   }

   ULONG options =
      abortForReplica ? DSROLEP_ABORT_FOR_REPLICA_INSTALL : 0;

   LOG(L"Calling DsRoleAbortDownlevelServerUpgrade");
   LOG(String::format(L"lpAccount : %1", useCurrentUserCreds ? L"(null)" : username.c_str()));
   LOG(String::format(L"Options   : 0x%1!X!", options));

   WCHAR* adminPasswordCopy = 0;
   if (!adminPassword.IsEmpty())
   {
      adminPasswordCopy = adminPassword.GetDecodedCopy();
   }
   
   WCHAR* passwordCopy = 0;
   if (!useCurrentUserCreds)
   {
      passwordCopy = password.GetDecodedCopy();
   }

   HRESULT hr =
      Win32ToHresult(
         ::DsRoleAbortDownlevelServerUpgrade(
            adminPasswordCopy,
            (useCurrentUserCreds ? 0 : username.c_str()),
            passwordCopy,
            options));
   LOG_HRESULT(hr);

   if (adminPasswordCopy)
   {
      ::ZeroMemory(
         adminPasswordCopy,
         sizeof(WCHAR) * adminPassword.GetLength());
      delete[] adminPasswordCopy;
   }
   
   if (passwordCopy)
   {
      ::ZeroMemory(passwordCopy, sizeof(WCHAR) * password.GetLength());
      delete[] passwordCopy;
   }
   
   if (FAILED(hr))
   {
      throw DS::Error(hr, IDS_ABORT_UPGRADE_FAILED);
   }
}



DS::PriorServerRole
DS::GetPriorServerRole(bool& isUpgrade)
{
   LOG_FUNCTION(DS::GetPriorServerRole);

   isUpgrade = false;
   DSROLE_UPGRADE_STATUS_INFO* info = 0;

   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr) && info)
   {
      isUpgrade =
         ( (info->OperationState & DSROLE_UPGRADE_IN_PROGRESS)
         ? true
         : false );
      DSROLE_SERVER_STATE state = info->PreviousServerState;

      ::DsRoleFreeMemory(info);

      switch (state)
      {
         case DsRoleServerPrimary:
         {
            return PDC;
         }
         case DsRoleServerBackup:
         {
            return BDC;
         }
         case DsRoleServerUnknown:
         default:
         {
            return UNKNOWN;
         }
      }
   }

   return UNKNOWN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\demotepage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// demote page
//
// 1-20-98 sburns



#include "headers.hxx"
#include "page.hpp"
#include "DemotePage.hpp"
#include "resource.h"
#include "state.hpp"
#include "ds.hpp"
#include "common.hpp"



DemotePage::DemotePage()
   :
   DCPromoWizardPage(
      IDD_DEMOTE,
      IDS_DEMOTE_PAGE_TITLE,
      IDS_DEMOTE_PAGE_SUBTITLE),
   bulletFont(0),
   warnIcon(0)
{
   LOG_CTOR(DemotePage);
}



DemotePage::~DemotePage()
{
   LOG_DTOR(DemotePage);

   HRESULT hr = S_OK;

   if (warnIcon)
   {
      hr = Win::DestroyIcon(warnIcon);

      ASSERT(SUCCEEDED(hr));
   }

   if (bulletFont)
   {
      hr = Win::DeleteObject(bulletFont);

      ASSERT(SUCCEEDED(hr));
   }
}



void
DemotePage::SetBulletFont()
{
   LOG_FUNCTION(DemotePage::SetBulletFont);

   HRESULT hr = S_OK;
   do
   {
      NONCLIENTMETRICS ncm;
      memset(&ncm, 0, sizeof(ncm));
      ncm.cbSize = sizeof(ncm);
      hr = Win::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
      BREAK_ON_FAILED_HRESULT(hr);

      LOGFONT logFont = ncm.lfMessageFont;

      logFont.lfWeight = FW_BOLD;

      String fontName = String::load(IDS_BULLET_FONT_NAME);

      // ensure null termination

      memset(logFont.lfFaceName, 0, LF_FACESIZE * sizeof(TCHAR));
      size_t fnLen = fontName.length();
      fontName.copy(
         logFont.lfFaceName,

         // don't copy over the last null

         min(LF_FACESIZE - 1, fnLen));
    
      hr = Win::CreateFontIndirect(logFont, bulletFont);
      BREAK_ON_FAILED_HRESULT(hr);

      SetControlFont(hwnd, IDC_BULLET1, bulletFont);
      SetControlFont(hwnd, IDC_BULLET2, bulletFont);
   }
   while (0);
}



void
DemotePage::OnInit()
{
   LOG_FUNCTION(DemotePage::OnInit);

   // 361172
   //
   // CODEWORK: the bullets aren't very impressive.  I'm told an icon is
   // a better way to do this

   SetBulletFont();

   HRESULT hr = Win::LoadImage(IDI_WARN, warnIcon);

   ASSERT(SUCCEEDED(hr));

   if (SUCCEEDED(hr))
   {
      Win::SendMessage(
         Win::GetDlgItem(hwnd, IDC_WARNING_ICON),
         STM_SETICON,
         reinterpret_cast<WPARAM>(warnIcon),
         0);
   }

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(State::OPTION_IS_LAST_DC);
      if (option.icompare(State::VALUE_YES) == 0)
      {
         Win::CheckDlgButton(hwnd, IDC_LAST, BST_CHECKED);
         return;
      }
   }
   else
   {
      // determine if this machine is a GC, if so pop up a warning message

      if (state.IsGlobalCatalog())
      {
         popup.Info(GetHWND(), IDS_DEMOTE_GC_WARNING);
      }
   }

   // you may ask yourself: "Why not set the state of the checkbox based
   // on the result of IsReallyLastDcInDomain?"  Because demoting the
   // last DC deletes the domain, too.  We want the user to be very
   // deliberate when checking that checkbox.
}



bool
DemotePage::OnSetActive()
{
   LOG_FUNCTION(DemotePage::OnSetActive);

   State& state = State::GetInstance();
   
   if (state.RunHiddenUnattended())
   {
      int nextPage = DemotePage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



bool
OtherDcFound(const String& domainName)
{
   LOG_FUNCTION2(OtherDcFound, domainName);
   ASSERT(!domainName.empty());

   bool result = false;
   HRESULT hr = S_OK;

   do
   {
      DOMAIN_CONTROLLER_INFO* info = 0;
      hr =
         MyDsGetDcName(
            0,
            domainName,  
               DS_FORCE_REDISCOVERY
            |  DS_AVOID_SELF
            |  DS_DIRECTORY_SERVICE_REQUIRED,
            info);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(info->DomainControllerName);

      ::NetApiBufferFree(info);

      result = true;
   }
   while (0);

   LOG_HRESULT(hr);
   LOG(result ? L"true" : L"false");

   return result;
}



int
DemotePage::Validate()
{
   LOG_FUNCTION(DemotePage::Validate);

   State& state = State::GetInstance();
   ASSERT(state.GetOperation() == State::DEMOTE);

   bool isLast = Win::IsDlgButtonChecked(hwnd, IDC_LAST);

   if (isLast)
   {
      if (!state.IsReallyLastDcInDomain())
      {
         // user checked the box, but we found other dc objects in the DS.
         // verify that the user really meant to check the checkbox.

         if (
            popup.MessageBox(
               hwnd,
               String::format(
                  IDS_VERIFY_LAST_DC,
                  state.GetComputer().GetDomainDnsName().c_str()),
               MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2) != IDYES)
         {
            state.SetIsLastDCInDomain(false);
            return -1;
         }
      }
   }
   else
   {
      // the user unchecked the box, check for other DCs for that domain

      Win::WaitCursor cursor;

      if (!OtherDcFound(state.GetComputer().GetDomainDnsName()))
      {
         if (
            popup.MessageBox(
               hwnd,
               String::format(
                  IDS_VERIFY_NOT_LAST_DC,
                  state.GetComputer().GetDomainDnsName().c_str()),
               MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2) != IDYES)
         {
            // user clicked no or cancel

            state.SetIsLastDCInDomain(false);
            return -1;
         }

         // The user clicked "yes, proceed even if I lose changes"

         // CODEWORK: set flag to allow demote and abandon local changes
         // here...

      }
   }

   state.SetIsLastDCInDomain(isLast);

   // jump to credentials page if the user checked the "last dc in domain"
   // checkbox, unless this is last dc in forest root domain. 318736, 391440

   const Computer& computer = state.GetComputer();
   bool isForestRootDomain =
      (computer.GetDomainDnsName().icompare(computer.GetForestDnsName()) == 0);

   return
         isLast and !isForestRootDomain
      ?  IDD_GET_CREDENTIALS
      :  IDD_ADMIN_PASSWORD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\dnssetup.cpp ===
// Copyright (C) 1998 Microsoft Corporation
//
// DNS installation and configuration code 
//
// 6-16-98 sburns



#include "headers.hxx"
#include "resource.h"
#include "ProgressDialog.hpp"



static const DWORD HELP_MAP[] =
{
   0, 0
};
static const int NAP_TIME = 3000; // in ms



int
millisecondsToSeconds(int millis)
{
   static const int MILLIS_PER_SECOND = 1000;

   return millis / MILLIS_PER_SECOND;
}



bool
pollForDNSServiceStart(ProgressDialog& progressDialog)
{
   LOG_FUNCTION(PollForDNSServiceStart);

   for (int waitCount = 0; /* empty */ ; waitCount++)
   {
      progressDialog.UpdateText(
         String::format(
            IDS_WAITING_FOR_SERVICE_START,
            millisecondsToSeconds(NAP_TIME * waitCount)));

      if (progressDialog.WaitForButton(NAP_TIME) == ProgressDialog::PRESSED)
      {
         progressDialog.UpdateButton(String());
         popup.Info(
            progressDialog.GetHWND(),
            String::load(IDS_SKIP_DNS_MESSAGE));
         break;
      }

      if (Dns::IsServiceRunning())
      {
         // success!
         return true;
      }
   }

   return false;
}



bool
pollForDNSServiceInstallAndStart(ProgressDialog& progressDialog)
{
   LOG_FUNCTION(pollForDNSServiceInstallAndStart);

   for (int waitCount = 0; /* empty */ ; waitCount++)   
   {
      progressDialog.UpdateText(
         String::format(
            IDS_WAITING_FOR_SERVICE_INSTALL,
            millisecondsToSeconds(NAP_TIME * waitCount)));

      if (progressDialog.WaitForButton(NAP_TIME) == ProgressDialog::PRESSED)
      {
         progressDialog.UpdateButton(String());
         popup.Info(
            progressDialog.GetHWND(),
            String::load(IDS_SKIP_DNS_MESSAGE));
         break;
      }

      if (Dns::IsServiceInstalled())
      {
         // Service is installed.  Now check to see if it is running.               
         return pollForDNSServiceStart(progressDialog);
      }
   }

   return false;
}



HRESULT
createTempFile(const String& name, int textResID)
{
   LOG_FUNCTION2(createTempFile, name);
   ASSERT(!name.empty());
   ASSERT(textResID);

   HRESULT hr = S_OK;
   HANDLE h = INVALID_HANDLE_VALUE;

   do
   {
      hr =
         FS::CreateFile(
            name,
            h,
            GENERIC_WRITE,
            0, 
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL);
      BREAK_ON_FAILED_HRESULT(hr);

      AnsiString ansi;
      String::load(textResID).convert(ansi);
      ASSERT(!ansi.empty());

      // write to file with end of file character.

      hr = FS::Write(h, ansi + "\032");
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   Win::CloseHandle(h);

   return hr;
}



HRESULT
spawnDNSInstaller(PROCESS_INFORMATION& info)
{
   LOG_FUNCTION(spawnDNSInstaller);

   HRESULT hr = S_OK;
   // CODEWORK: use GetTempPath?

   String sysFolder    = Win::GetSystemDirectory();
   String infPath      = sysFolder + L"\\dcpinf.000"; 
   String unattendPath = sysFolder + L"\\dcpunat.001";

   // create the inf and unattend files for the oc manager
   do
   {
      hr = createTempFile(infPath, IDS_INSTALL_DNS_INF_TEXT);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = createTempFile(unattendPath, IDS_INSTALL_DNS_UNATTEND_TEXT);
      BREAK_ON_FAILED_HRESULT(hr);

      String commandLine =
         String::format(
            IDS_INSTALL_DNS_COMMAND_LINE,
            sysFolder.c_str(),
            infPath.c_str(),
            unattendPath.c_str());

      STARTUPINFO startup;
      memset(&startup, 0, sizeof(startup));

      LOG(L"Calling CreateProcess");
      LOG(commandLine);

      hr =
         Win::CreateProcess(
            commandLine,
            0,
            0,
            false, 
            0,
            0,
            String(),
            startup,
            info);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



bool
installDNS(ProgressDialog& progressDialog)
{
   LOG_FUNCTION(installDNS);

   if (Dns::IsServiceInstalled())
   {
      LOG(L"DNS service is already installed");

      if (Dns::IsServiceRunning())
      {
         LOG(L"DNS service is already running");
         return true;
      }

      // @@ start the DNS service Dns::StartService?
   }

   progressDialog.UpdateText(String::load(IDS_INSTALLING_DNS));

   PROCESS_INFORMATION info;
   HRESULT hr = spawnDNSInstaller(info);
         
   if (FAILED(hr))
   {
      progressDialog.UpdateText(
         String::load(IDS_PROGRESS_ERROR_INSTALLING_DNS));
      popup.Error(
         progressDialog.GetHWND(),
         hr,
         IDS_ERROR_LAUNCHING_INSTALLER);
      return false;   
   }

   progressDialog.UpdateButton(IDS_PROGRESS_BUTTON_SKIP_DNS);

   // monitor the state of the installer process.
   for (int waitCount = 0; /* empty */ ; waitCount++)   
   {
      progressDialog.UpdateText(
         String::format(
            IDS_WAITING_FOR_INSTALLER,
            millisecondsToSeconds(NAP_TIME * waitCount)));

      if (progressDialog.WaitForButton(NAP_TIME) == ProgressDialog::PRESSED)
      {
         progressDialog.UpdateButton(String());
         popup.Info(
            progressDialog.GetHWND(),
            String::load(IDS_SKIP_DNS_MESSAGE));
         break;
      }

      DWORD exitCode = 0;         
      hr = Win::GetExitCodeProcess(info.hProcess, exitCode);
      if (FAILED(hr))
      {
         LOG(L"GetExitCodeProcess failed");
         LOG_HRESULT(hr);

         progressDialog.UpdateText(
            String::load(IDS_PROGRESS_ERROR_INSTALLING_DNS));
         popup.Error(
            progressDialog.GetHWND(),
            hr,
            IDS_ERROR_QUERYING_INSTALLER);
         return false;
      }

      if (exitCode != STILL_ACTIVE)
      {
         // installer has terminated.  Now check the status of the DNS
         // service
         return pollForDNSServiceInstallAndStart(progressDialog);
      }
   }

   // user bailed out
   return false;
}



bool
InstallAndConfigureDns(
   ProgressDialog&      progressDialog,
   const String&        domainDNSName)
{
   LOG_FUNCTION2(DNSSetup, domainDNSName);
   ASSERT(!domainDNSName.empty());

   if (!installDNS(progressDialog))
   {
      return false;
   }

   progressDialog.UpdateText(String::load(IDS_CONFIGURING_DNS));

   HINSTANCE dnsmgr = 0;
   HRESULT hr = Win::LoadLibrary(String::load(IDS_DNSMGR_DLL_NAME), dnsmgr);

   if (SUCCEEDED(hr))
   {
      FARPROC proc = 0;
      hr = Win::GetProcAddress(dnsmgr, L"DnsSetup", proc);

      if (SUCCEEDED(hr))
      {
         String p1 = domainDNSName;
         if (*(p1.rbegin()) != L'.')
         {
            // add trailing dot
            p1 += L'.';
         }

         String p2 = p1 + L"dns";

         LOG(L"Calling DnsSetup");
         LOG(String::format(L"lpszFwdZoneName     : %1", p1.c_str()));
         LOG(String::format(L"lpszFwdZoneFileName : %1", p2.c_str()));
         LOG(               L"lpszRevZoneName     : (null)");
         LOG(               L"lpszRevZoneFileName : (null)");
         LOG(               L"dwFlags             : 0");

         typedef HRESULT (*DNSSetup)(PCWSTR, PCWSTR, PCWSTR, PCWSTR, DWORD);      
         DNSSetup dnsproc = reinterpret_cast<DNSSetup>(proc);

         hr = dnsproc(p1.c_str(), p2.c_str(), 0, 0, 0);
      }
      else
      {
         LOG(L"unable to locate DnsSetup proc address");
      }

      HRESULT unused = Win::FreeLibrary(dnsmgr);

      ASSERT(SUCCEEDED(unused));
   }
   else
   {
      LOG(L"unable to load DNSMGR");
   }

   LOG_HRESULT(hr);

   if (FAILED(hr))
   {
      // unable to configure DNS, but it was installed.
      progressDialog.UpdateText(
         String::load(IDS_PROGRESS_ERROR_CONFIGURING_DNS));
      popup.Error(
         progressDialog.GetHWND(),
         hr,
         String::format(IDS_ERROR_CONFIGURING_DNS, domainDNSName.c_str()));

      return false;
   }

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\dnssetup.hpp ===
// Copyright (C) 1998 Microsoft Corporation
//
// DNS installation and configuration code 
//
// 6-16-98 sburns



#ifndef DNSSETUP_HPP_INCLUDED
#define DNSSETUP_HPP_INCLUDED



bool
InstallAndConfigureDns(
   ProgressDialog&   progressDialog,
   const String&     domainDNSName);



#endif   // DNSSETUP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\dynamicdnsdetailsdialog.hpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Dlg to show the details of the Dynamic DNS registration diagnostic
//
// 5 Oct 2000 sburns



#ifndef DYNAMICDNSDETAILSDIALOG_HPP_INCLUDED
#define DYNAMICDNSDETAILSDIALOG_HPP_INCLUDED


                        
class DynamicDnsDetailsDialog : public Dialog
{
   public:

   DynamicDnsDetailsDialog(
      const String& details,
      const String& helpTopicLink);

   virtual ~DynamicDnsDetailsDialog();

   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   String details;
   String helpTopicLink;

   // not defined: no copying allowed

   DynamicDnsDetailsDialog(const DynamicDnsDetailsDialog&);
   const DynamicDnsDetailsDialog& operator=(const DynamicDnsDetailsDialog&);
};



#endif   // DYNAMICDNSDETAILSDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\ds.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// DS API wrappers
//
// 12-16-97 sburns



#ifndef DS_HPP_INCLUDED
#define DS_HPP_INCLUDED



class ProgressDialog;



namespace DS
{
   const int MAX_NETBIOS_NAME_LENGTH = DNLEN;
   const int MAX_USER_NAME_LENGTH = UNLEN;
   const int MAX_PASSWORD_LENGTH = PWLEN;

   class Error : public Win::Error
   {
      public:

      // Constructs a new instance.
      // 
      // hr - The HRESULT this error represents.
      // 
      // summaryResID - ID of the string resource that corresponds to
      // the summary text to be returned by GetSummary().

      Error(HRESULT hr, int summaryResID);

      Error(HRESULT hr, const String& message, const String& summary);
   };

   // abortForReplica - true if this call is a precursor to calling
   // CreateReplica (used to upgrade a BDC to a replica), false if the call is
   // to leave the server as a member server.

   void
   AbortBDCUpgrade(bool abortForReplica = false)
   throw (DS::Error);

   void
   DemoteDC(ProgressDialog& progressDialog)
   throw (DS::Error);

   void
   CreateNewDomain(ProgressDialog& progressDialog)
   throw (DS::Error);

   void
   CreateReplica(
      ProgressDialog&   progressDialog,
      bool              invokeForUpgrade = false)
   throw (DS::Error);

   bool
   DisjoinDomain()
   throw (DS::Error);

   // Returns true if the domain is located, false if the name is unknown
   // or some other error occurred.
   //
   // domainDNSName - DNS or Netbios name of domain to search for.

   bool
   DomainExists(const String& domainName);

   enum PriorServerRole
   {
      UNKNOWN,
      PDC,
      BDC
   };

   PriorServerRole
   GetPriorServerRole(bool& isUpgrade);

   bool
   IsDomainNameInUse(const String& domainName);

   bool
   IsDSRunning();

   void
   JoinDomain(
      const String&        domainDNSName, 
      const String&        dcName,        
      const String&        userName,      
      const EncodedString& password,      
      const String&        userDomainName)
   throw (DS::Error);

   void
   UpgradeBDC(ProgressDialog& progressDialog)
   throw (DS::Error);

   void
   UpgradePDC(ProgressDialog& progressDialog)
   throw (DS::Error);
}



#endif   // DS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\dynamicdnsdetailsdialog.cpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Dlg to show the details of the Dynamic DNS registration diagnostic
//
// 5 Oct 2000 sburns



#include "headers.hxx"
#include "DynamicDnsDetailsDialog.hpp"
#include "resource.h"



static const DWORD HELP_MAP[] =
{
   0, 0
};



DynamicDnsDetailsDialog::DynamicDnsDetailsDialog(
   const String&  details_,
   const String&  helpTopicLink_)
   :
   Dialog(
         helpTopicLink_.empty()
      ?  IDD_DYNAMIC_DNS_DETAILS_OK
      :  IDD_DYNAMIC_DNS_DETAILS_OK_HELP,
      HELP_MAP),
   details(details_),
   helpTopicLink(helpTopicLink_)
{
   LOG_CTOR(DynamicDnsDetailsDialog);
   ASSERT(!details.empty());
}



DynamicDnsDetailsDialog::~DynamicDnsDetailsDialog()
{
   LOG_DTOR(DynamicDnsDetailsDialog);
}



void
DynamicDnsDetailsDialog::OnInit()
{
   LOG_FUNCTION(DynamicDnsDetailsDialog::OnInit);

   Win::SetDlgItemText(hwnd, IDC_DETAILS, details);
}



bool
DynamicDnsDetailsDialog::OnCommand(
   HWND     /* windowFrom */ ,   
   unsigned controlIDFrom,
   unsigned code)         
{
//   LOG_FUNCTION(DynamicDnsDetailsDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDCANCEL:
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, controlIDFrom);

            ASSERT(SUCCEEDED(unused));

            return true;
         }

         break;
      }
      case IDHELP:
      {
         if (code == BN_CLICKED)
         {
            if (!helpTopicLink.empty())
            {
               Win::HtmlHelp(hwnd, helpTopicLink, HH_DISPLAY_TOPIC, 0);
            }

            return true;
         }

         break;
      }
      default:
      {
         // do nothing
         
         break;
      }
   }

   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\failurepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// failure page
//
// 12-22-97 sburns



#ifndef FAILUREPAGE_HPP_INCLUDED
#define FAILUREPAGE_HPP_INCLUDED



class FailurePage : public DCPromoWizardPage
{
   public:

   FailurePage();

   protected:

   virtual ~FailurePage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   FailurePage(const FailurePage&);
   const FailurePage& operator=(const FailurePage&);
};



#endif   // FAILUREPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\dynamicdnspage.hpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Dynamic DNS detection/diagnostic page
//
// 22 Aug 2000 sburns



#ifndef DYNAMICDNSPAGE_HPP_INCLUDED
#define DYNAMICDNSPAGE_HPP_INCLUDED



class DynamicDnsPage : public DCPromoWizardPage
{
   public:

   DynamicDnsPage();

   protected:

   virtual ~DynamicDnsPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // WizardPage overrides

   virtual
   bool
   OnWizBack();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   enum DiagnosticCode
   {
      // These codes correspond to the message numbers in the spec diagram
      // of the diagnostic algorithm.

      SUCCESS                   = 1,
      SERVER_CANT_UPDATE        = 2,
      ERROR_TESTING_SERVER      = 3,
      UNEXPECTED_FINDING_SERVER = 4,
      ERROR_FINDING_SERVER      = 6,
      ZONE_IS_ROOT              = 8,
      TIMEOUT                   = 11
   };

   DiagnosticCode
   DiagnoseDnsRegistration(
      const String&  newDomainDnsName,
      DNS_STATUS&    errorCode,
      String&        authZone,
      String&        authServer,
      String&        authServerIpAddress);

   void
   DoDnsTestAndUpdatePage();

   void
   SelectRadioButton(int buttonResId);

   void
   ShowButtons(bool hidden);

   DiagnosticCode diagnosticResultCode;
   String         details;
   String         helpTopicLink;
   unsigned       testPassCount;

   // not defined; no copying allowed

   DynamicDnsPage(const DynamicDnsPage&);
   const DynamicDnsPage& operator=(const DynamicDnsPage&);
};



#endif   // DYNAMICDNSPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\dynamicdnspage.cpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Dynamic DNS detection/diagnostic page
//
// 22 Aug 2000 sburns



#include "headers.hxx"
#include "page.hpp"
#include "DynamicDnsPage.hpp"
#include "DynamicDnsDetailsDialog.hpp"
#include "resource.h"
#include "state.hpp"



DynamicDnsPage::DynamicDnsPage()
   :
   DCPromoWizardPage(
      IDD_DYNAMIC_DNS,
      IDS_DYNAMIC_DNS_PAGE_TITLE,
      IDS_DYNAMIC_DNS_PAGE_SUBTITLE),
   testPassCount(0),
   diagnosticResultCode(UNEXPECTED_FINDING_SERVER)
{
   LOG_CTOR(DynamicDnsPage);

   WSADATA data;
   DWORD err = ::WSAStartup(MAKEWORD(2,0), &data);

   // if winsock startup fails, that's a shame.  The gethostbyname will
   // not work, but there's not much we can do about that.

   ASSERT(!err);
}



DynamicDnsPage::~DynamicDnsPage()
{
   LOG_DTOR(DynamicDnsPage);

   ::WSACleanup();
}



void
DynamicDnsPage::ShowButtons(bool shown)
{
   LOG_FUNCTION(DynamicDnsPage::ShowButtons);

   int state = shown ? SW_SHOW : SW_HIDE;

   Win::ShowWindow(Win::GetDlgItem(hwnd, IDC_RETRY),       state);
   Win::ShowWindow(Win::GetDlgItem(hwnd, IDC_INSTALL_DNS), state);
   Win::ShowWindow(Win::GetDlgItem(hwnd, IDC_IGNORE),      state);
}



void
DynamicDnsPage::SelectRadioButton(int buttonResId)
{
   // If the order of the buttons changes, then this must be changed.  The
   // buttons also need to have consecutively numbered res IDs in the tab
   // order.

   Win::CheckRadioButton(hwnd, IDC_RETRY, IDC_IGNORE, buttonResId);
}



void
DynamicDnsPage::OnInit()
{
   LOG_FUNCTION(DynamicDnsPage::OnInit);

   SelectRadioButton(IDC_IGNORE);

   // Hide the radio buttons initially

   ShowButtons(false);
}



// Adds a trailing '.' to the supplied name if one is not already present.
// 
// name - in, name to add a trailing '.' to, if it doesn't already have one.
// If this value is the empty string, then '.' is returned.

String
FullyQualifyDnsName(const String& name)
{
   LOG_FUNCTION2(FullyQualifyDnsName, name);

   if (name.empty())
   {
      return L".";
   }

   // needs a trailing dot

   if (name[name.length() - 1] != L'.')
   {
      return name + L".";
   }

   // already has a trailing dot

   return name;
}



// Scans a linked list of DNS_RECORDs, returning a pointer to the first record
// of type SOA, or 0 if no record of that type is in the list.
// 
// recordList - in, linked list of DNS_RECORDs, as returned from DnsQuery

DNS_RECORD*
FindSoaRecord(DNS_RECORD* recordList)
{
   LOG_FUNCTION(FindSoaRecord);
   ASSERT(recordList);

   DNS_RECORD* result = recordList;
   while (result)
   {
      if (result->wType == DNS_TYPE_SOA)
      {
         LOG(L"SOA record found");

         break;
      }

      result = result->pNext;
   }

   return result;
}



// Returns the textual representation of the IP address for the given server
// name, in the form "xxx.xxx.xxx.xxx", or the empty string if not IP address
// can be determined.
// 
// serverName - in, the host name of the server for which to find the IP
// address.  If the value is the empty string, then the empty string is
// returned from the function.

String
GetIpAddress(const String& serverName)
{
   LOG_FUNCTION2(GetIpAddress, serverName);
   ASSERT(!serverName.empty());

   String result;

   do
   {
      if (serverName.empty())
      {
         break;
      }

      LOG(L"Calling gethostbyname");

      AnsiString ansi;
      serverName.convert(ansi);

      HOSTENT* host = gethostbyname(ansi.c_str());
      if (host)
      {
         struct in_addr a;
         memcpy(&a.S_un.S_addr, host->h_addr_list[0], sizeof(a.S_un.S_addr));
         result = inet_ntoa(a);

         break;
      }

      LOG(String::format(L"WSAGetLastError = 0x%1!0X", WSAGetLastError()));
   }
   while (0);

   LOG(result);

   return result;
}



// Find the DNS server that is authoritative for registering the given server
// name, i.e. what server would register the name.  Returns NO_ERROR on
// success, or a DNS status code (a win32 error) on failure.  On failure, the
// out parameters are all empty strings.
// 
// serverName - in, candidate name for registration.  This value should not be the
// empty string.
// 
// authZone - out, the zone the name would be registered in.
// 
// authServer - out, the name of the DNS server that would have the
// registration.
// 
// authServerIpAddress - out, textual representation of the IP address of the
// server named by authServer.

DNS_STATUS
FindAuthoritativeServer(
   const String& serverName,
   String&       authZone,
   String&       authServer,
   String&       authServerIpAddress)
{
   LOG_FUNCTION2(FindAuthoritativeServer, serverName);
   ASSERT(!serverName.empty());

   authZone.erase();
   authServer.erase();
   authServerIpAddress.erase();

   // ensure that the server name ends with a "." so that we have a stop
   // point for our loop

   String currentName = FullyQualifyDnsName(serverName);

   DNS_STATUS result = NO_ERROR;
   DNS_RECORD* queryResults = 0;

   while (!currentName.empty())
   {
      result =
         MyDnsQuery(
            currentName,
            DNS_TYPE_SOA,
            DNS_QUERY_BYPASS_CACHE,
            queryResults);
      if (
            result == ERROR_TIMEOUT
         || result == DNS_ERROR_RCODE_SERVER_FAILURE)
      {
         // we bail out entirely

         LOG(L"failed to find autoritative server.");

         break;
      }

      // search for an SOA RR

      DNS_RECORD* soaRecord =
         queryResults ? FindSoaRecord(queryResults) : 0;
      if (soaRecord)
      {
         // collect return values, and we're done.

         LOG(L"autoritative server found");

         authZone            = soaRecord->pName;                      
         authServer          = soaRecord->Data.SOA.pNamePrimaryServer;
         authServerIpAddress = GetIpAddress(authServer);              

         break;
      }

      // no SOA record found.

      if (currentName == L".")
      {
         // We've run out of names to query.  This situation is so unlikely
         // that the DNS server would have to be seriously broken to put
         // us in this state.  So this is almost an assert case.

         LOG(L"Root zone reached without finding SOA record!");
         
         result = DNS_ERROR_ZONE_HAS_NO_SOA_RECORD;
         break;
      }

      // whack off the leftmost label, and iterate again on the parent
      // zone.

      currentName = Dns::GetParentDomainName(currentName);

      MyDnsRecordListFree(queryResults);
      queryResults = 0;
   }

   MyDnsRecordListFree(queryResults);

   LOG(String::format(L"result = %1!08X!", result));
   LOG(L"authZone            = " + authZone);           
   LOG(L"authServer          = " + authServer);         
   LOG(L"authServerIpAddress = " + authServerIpAddress);

   return result;
}

            

DNS_STATUS
MyDnsUpdateTest(const String& name)
{
   LOG_FUNCTION2(MyDnsUpdateTest, name);
   ASSERT(!name.empty());

   LOG(L"Calling DnsUpdateTest");
   LOG(               L"hContextHandle : 0");
   LOG(String::format(L"pszName        : %1", name.c_str()));
   LOG(               L"fOptions       : 0");
   LOG(               L"aipServers     : 0");

   DNS_STATUS status =
      ::DnsUpdateTest(
         0,
         const_cast<wchar_t*>(name.c_str()),
         0,
         0);

   LOG(String::format(L"status = %1!08X!", status));
   LOG(MyDnsStatusString(status));

   return status;
}



// Returns result code that corresponds to what messages to be displayed and
// what radio buttons to make available as a result of the diagnostic.
// 
// Also returns thru out parameters information to be included in the
// messages.
//
// serverName - in, the name of the domain contoller to be registered.
// 
// errorCode - out, the DNS error code (a win32 error) encountered when
// running the diagnostic.
//
// authZone - out, the zone the name would be registered in.
// 
// authServer - out, the name of the DNS server that would have the
// registration.
// 
// authServerIpAddress - out, textual representation of the IP address of the
// server named by authServer.

DynamicDnsPage::DiagnosticCode
DynamicDnsPage::DiagnoseDnsRegistration(
   const String&  serverName,
   DNS_STATUS&    errorCode,
   String&        authZone,
   String&        authServer,
   String&        authServerIpAddress)
{
   LOG_FUNCTION(DynamicDnsPage::DiagnoseDnsRegistration);
   ASSERT(!serverName.empty());

   DiagnosticCode result = UNEXPECTED_FINDING_SERVER;
      
   errorCode =
      FindAuthoritativeServer(
         serverName,
         authZone,
         authServer,
         authServerIpAddress);

   switch (errorCode)
   {
      case NO_ERROR:
      {
         if (authZone == L".")
         {
            // Message 8

            LOG(L"authZone is root");

            result = ZONE_IS_ROOT;
         }
         else
         {
            errorCode = MyDnsUpdateTest(serverName);

            switch (errorCode)
            {
               case DNS_ERROR_RCODE_NO_ERROR:
               case DNS_ERROR_RCODE_YXDOMAIN:
               {
                  // Message 1

                  LOG(L"DNS registration support verified.");

                  result = SUCCESS;
                  break;
               }
               case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
               case DNS_ERROR_RCODE_REFUSED:
               {
                  // Message 2

                  LOG(L"Server does not support update");

                  result = SERVER_CANT_UPDATE;
                  break;
               }
               default:
               {
                  // Message 3

                  result = ERROR_TESTING_SERVER;
                  break;
               }
            }
         }

         break;            
      }
      case DNS_ERROR_RCODE_SERVER_FAILURE:
      {
         // Message 6

         result = ERROR_FINDING_SERVER;
         break;
      }
      case ERROR_TIMEOUT:
      {
         // Message 11

         result = TIMEOUT;
         break;
      }
      default:
      {
         // Message 4

         LOG(L"Unexpected error");

         result = UNEXPECTED_FINDING_SERVER;
         break;
      }
   }

   LOG(String::format(L"DiagnosticCode = %1!x!", result));

   return result;
}



// do the test, update the text on the page, update the radio buttons
// enabled state, choose a radio button default if neccessary

void
DynamicDnsPage::DoDnsTestAndUpdatePage()
{
   LOG_FUNCTION(DynamicDnsPage::DoDnsTestAndUpdatePage);

   // this might take a while.

   Win::WaitCursor cursor;

   State& state  = State::GetInstance();       
   String domain = state.GetNewDomainDNSName();

   DNS_STATUS errorCode = 0;
   String authZone;
   String authServer;
   String authServerIpAddress;
   String serverName = L"_ldap._tcp.dc._msdcs." + domain;

   diagnosticResultCode =
      DiagnoseDnsRegistration(
         serverName,
         errorCode,
         authZone,
         authServer,
         authServerIpAddress);
   ++testPassCount;

   String message;
   int    defaultButton = IDC_IGNORE;

   switch (diagnosticResultCode)
   {
      // Message 1

      case SUCCESS:
      {
         message = String::load(IDS_DYN_DNS_MESSAGE_SUCCESS);
         details =
            String::format(
               IDS_DYN_DNS_DETAIL_FULL,
               testPassCount,
               authServer.c_str(),
               authServerIpAddress.c_str(),
               authZone.c_str(),
               GetErrorMessage(Win32ToHresult(errorCode)).c_str(),
               errorCode,
               MyDnsStatusString(errorCode).c_str());
         helpTopicLink = L"";
         defaultButton = IDC_IGNORE;
         ShowButtons(false);

         break;
      }

      // Message 2   

      case SERVER_CANT_UPDATE:   
      {
         message = String::load(IDS_DYN_DNS_MESSAGE_SERVER_CANT_UPDATE);
         details =
            String::format(
               IDS_DYN_DNS_DETAIL_FULL,
               testPassCount,
               authServer.c_str(),
               authServerIpAddress.c_str(),
               authZone.c_str(),
               GetErrorMessage(Win32ToHresult(errorCode)).c_str(),
               errorCode,
               MyDnsStatusString(errorCode).c_str());

         if (Dns::CompareNames(authZone, domain) == DnsNameCompareEqual)
         {
            helpTopicLink =
               L"DNSConcepts.chm::/sag_DNS_tro_dynamic_message2a.htm";
         }
         else
         {
            helpTopicLink =
               L"DNSConcepts.chm::/sag_DNS_tro_dynamic_message2b.htm";
         }
         
         defaultButton = IDC_RETRY;
         ShowButtons(true);

         break;
      }

      // Message 3

      case ERROR_TESTING_SERVER:
      {
         message = String::load(IDS_DYN_DNS_MESSAGE_ERROR_TESTING_SERVER);
         details =
            String::format(
               IDS_DYN_DNS_DETAIL_FULL,
               testPassCount,
               authServer.c_str(),
               authServerIpAddress.c_str(),
               authZone.c_str(),
               GetErrorMessage(Win32ToHresult(errorCode)).c_str(),
               errorCode,
               MyDnsStatusString(errorCode).c_str());
         helpTopicLink = "DNSConcepts.chm::/sag_DNS_tro_dynamic_message3.htm";
         defaultButton = IDC_RETRY;
         ShowButtons(true);
         break;
      }

      // Message 6

      case ERROR_FINDING_SERVER:
      {
         ASSERT(authServer.empty());
         ASSERT(authZone.empty());
         ASSERT(authServerIpAddress.empty());

         message = String::load(IDS_DYN_DNS_MESSAGE_ERROR_FINDING_SERVER);
         details =
            String::format(
               IDS_DYN_DNS_DETAIL_SCANT,
               testPassCount,
               serverName.c_str(),
               GetErrorMessage(Win32ToHresult(errorCode)).c_str(),
               errorCode,
               MyDnsStatusString(errorCode).c_str());
         helpTopicLink = "DNSConcepts.chm::/sag_DNS_tro_dynamic_message6.htm";
         defaultButton = IDC_INSTALL_DNS;
         ShowButtons(true);
         break;
      }

      // Message 8

      case ZONE_IS_ROOT:   
      {
         message = String::load(IDS_DYN_DNS_MESSAGE_ZONE_IS_ROOT);
         details =
            String::format(
               IDS_DYN_DNS_DETAIL_ROOT_ZONE,
               testPassCount,
               authServer.c_str(),
               authServerIpAddress.c_str());
         helpTopicLink = L"DNSConcepts.chm::/sag_DNS_tro_dynamic_message8.htm";
         defaultButton = IDC_INSTALL_DNS;
         ShowButtons(true);
         break;
      }

      // Message 11

      case TIMEOUT:
      {
         message = String::load(IDS_DYN_DNS_MESSAGE_TIMEOUT);
         details =
            String::format(
               IDS_DYN_DNS_DETAIL_SCANT,
               testPassCount,
               serverName.c_str(),
               GetErrorMessage(Win32ToHresult(errorCode)).c_str(),
               errorCode,
               MyDnsStatusString(errorCode).c_str());
         helpTopicLink = L"DNSConcepts.chm::/sag_DNS_tro_dynamic_message11.htm";
         defaultButton = IDC_INSTALL_DNS;
         ShowButtons(true);
         break;
      }

      // Message 4

      case UNEXPECTED_FINDING_SERVER:

      // Anything else

      default:
      {
         
#ifdef DBG
         ASSERT(authServer.empty());
         ASSERT(authZone.empty());
         ASSERT(authServerIpAddress.empty());

         if (diagnosticResultCode != UNEXPECTED_FINDING_SERVER)
         {
            ASSERT(false);
         }
#endif

         message = String::load(IDS_DYN_DNS_MESSAGE_UNEXPECTED);

         details =
            String::format(
               IDS_DYN_DNS_DETAIL_SCANT,
               testPassCount,
               serverName.c_str(),
               GetErrorMessage(Win32ToHresult(errorCode)).c_str(),
               errorCode,
               MyDnsStatusString(errorCode).c_str());
         helpTopicLink = L"DNSConcepts.chm::/sag_DNS_tro_dynamic_message4.htm";
         defaultButton = IDC_RETRY;
         ShowButtons(true);
         break;
      }

   }


   Win::SetDlgItemText(hwnd, IDC_MESSAGE, message);
   Win::SetDlgItemText(
      hwnd,
      IDC_TEST_PASS,
      String::format(IDS_TEST_PASS_COUNT, testPassCount));

   // success always forces the ignore option

   if (diagnosticResultCode == SUCCESS)
   {
      SelectRadioButton(IDC_IGNORE);
   }
   else
   {
      // On the first pass only, decide what radio button to set.  On
      // subsequent passes, the user will have had the chance to change the
      // button selection, so we don't change his selections.

      if (testPassCount == 1)
      {
         int button = defaultButton;

         ASSERT(diagnosticResultCode != SUCCESS);

         // if the test failed, and the wizard is running unattended, then
         // consult the answer file for the user's preference in dealing
         // with the failure.

         if (state.UsingAnswerFile())
         {
            String option =
               state.GetAnswerFileOption(State::OPTION_AUTO_CONFIG_DNS);

            if (option.icompare(State::VALUE_YES) == 0)
            {
               button = IDC_INSTALL_DNS;
            }
            else
            {
               button = IDC_IGNORE;
            }
         }

         SelectRadioButton(button);
      }
   }
}



bool
DynamicDnsPage::OnSetActive()
{
   LOG_FUNCTION(DynamicDnsPage::OnSetActive);

   State& state = State::GetInstance();
   State::Operation oper = state.GetOperation(); 

   // these are the only operations for which this page is valid; i.e.
   // new domain scenarios

   if (
         oper == State::FOREST
      || oper == State::CHILD
      || oper == State::TREE)
   {
      DoDnsTestAndUpdatePage();
   }

   if (
         (  oper != State::FOREST
         && oper != State::CHILD
         && oper != State::TREE)
      || state.RunHiddenUnattended() )
   {
      LOG(L"Planning to Skip DynamicDnsPage");

      Wizard& wizard = GetWizard();

      if (wizard.IsBacktracking())
      {
         // backup once again

         wizard.Backtrack(hwnd);
         return true;
      }

      int nextPage = Validate();
      if (nextPage != -1)
      {
         LOG(L"skipping DynamicDnsPage");
         wizard.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



void
DumpButtons(HWND dialog)
{
   LOG(String::format(L"retry  : (%1)", Win::IsDlgButtonChecked(dialog, IDC_RETRY) ? L"*" : L" "));
   LOG(String::format(L"ignore : (%1)", Win::IsDlgButtonChecked(dialog, IDC_IGNORE) ? L"*" : L" "));
   LOG(String::format(L"install: (%1)", Win::IsDlgButtonChecked(dialog, IDC_INSTALL_DNS) ? L"*" : L" "));
}



int
DynamicDnsPage::Validate()
{
   LOG_FUNCTION(DynamicDnsPage::Validate);

   int nextPage = -1;

   do
   {
      State& state = State::GetInstance();
      State::Operation oper = state.GetOperation(); 
      
      DumpButtons(hwnd);

      if (
            oper != State::FOREST
         && oper != State::CHILD
         && oper != State::TREE)
      {
         // by definition valid, as the page does not apply

         State::GetInstance().SetAutoConfigureDNS(false);
         nextPage = IDD_RAS_FIXUP;
         break;
      }
      
      if (
            diagnosticResultCode == SUCCESS
         || Win::IsDlgButtonChecked(hwnd, IDC_IGNORE))
      {
         // You can go about your business.  Move along, move long.

         // Force ignore, even if the user previously had encountered a
         // failure and chose retry or install DNS. We do this in case the
         // user backed up in the wizard and corrected the domain name.

         State::GetInstance().SetAutoConfigureDNS(false);
         nextPage = IDD_RAS_FIXUP;
         break;
      }

      // if the radio button selection = retry, then do the test over again,
      // and stick to this page.

      if (Win::IsDlgButtonChecked(hwnd, IDC_RETRY))
      {
         DoDnsTestAndUpdatePage();
         break;
      }

      ASSERT(Win::IsDlgButtonChecked(hwnd, IDC_INSTALL_DNS));

      State::GetInstance().SetAutoConfigureDNS(true);
      nextPage = IDD_RAS_FIXUP;
      break;
   }
   while (0);

   LOG(String::format(L"nextPage = %1!d!", nextPage));

   return nextPage;
}



bool
DynamicDnsPage::OnWizBack()
{
   LOG_FUNCTION(DynamicDnsPage::OnWizBack);

   // make sure we reset the auto-config flag => the only way it gets set
   // it on the 'next' button.
   State::GetInstance().SetAutoConfigureDNS(false);

   return DCPromoWizardPage::OnWizBack();
}



bool
DynamicDnsPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIdFrom,
   unsigned    code)
{
   bool result = false;
   
   switch (controlIdFrom)
   {
      case IDC_DETAILS:
      {
         if (code == BN_CLICKED)
         {
            // bring up the diagnostics details window

            DynamicDnsDetailsDialog(details, helpTopicLink).ModalExecute(hwnd);
               
            result = true;
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\failurepage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// failure page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "FailurePage.hpp"
#include "resource.h"
#include "state.hpp"



FailurePage::FailurePage()
   :
   DCPromoWizardPage(
      IDD_FAILURE,
      IDS_FAILURE_PAGE_TITLE,
      IDS_FAILURE_PAGE_SUBTITLE)
{
   LOG_CTOR(FailurePage);
}



FailurePage::~FailurePage()
{
   LOG_DTOR(FailurePage);
}



void
FailurePage::OnInit()
{
   LOG_FUNCTION(FailurePage::OnInit);
}



bool
FailurePage::OnSetActive()
{
   LOG_FUNCTION(FailurePage::OnSetActive);

   State& state = State::GetInstance();
   if (
         state.GetOperationResultsCode() == State::SUCCESS
      || state.RunHiddenUnattended() )
   {
      LOG(L"planning to Skip failure page");

      Wizard& wiz = GetWizard();

      if (wiz.IsBacktracking())
      {
         // backup once again
         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = FailurePage::Validate();
      if (nextPage != -1)
      {
         wiz.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Win::SetDlgItemText(hwnd, IDC_MESSAGE, state.GetFailureMessage());

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



int
FailurePage::Validate()
{
   LOG_FUNCTION(FailurePage::Validate);

   return IDD_FINISH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\finish.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// finish page
//
// 12-19-97 sburns



#include "headers.hxx"
#include "finish.hpp"
#include "resource.h"
#include "common.hpp"
#include "state.hpp"



FinishPage::FinishPage()
   :
   WizardPage(
      IDD_FINISH,
      IDS_FINISH_PAGE_TITLE,
      IDS_FINISH_PAGE_SUBTITLE,
      false)
{
   LOG_CTOR(FinishPage);
}



FinishPage::~FinishPage()
{
   LOG_DTOR(FinishPage);
}



void
FinishPage::OnInit()
{
   LOG_FUNCTION(FinishPage::OnInit);

   SetLargeFont(hwnd, IDC_BIG_BOLD_TITLE);
   Win::PropSheet_CancelToClose(Win::GetParent(hwnd));
}



static
String
getCompletionMessage()
{
   LOG_FUNCTION(getCompletionMessage);

   String message;
   State& state = State::GetInstance();
   State::Operation operation = state.GetOperation();

   if (state.GetOperationResultsCode() == State::SUCCESS)
   {
      switch (operation)
      {
         case State::REPLICA:
         case State::FOREST:
         case State::TREE:
         case State::CHILD:
         {
            String domain =
                  operation == State::REPLICA
               ?  state.GetReplicaDomainDNSName()
               :  state.GetNewDomainDNSName();
            message = String::format(IDS_FINISH_PROMOTE, domain.c_str());

            String site = state.GetInstalledSite();
            if (!site.empty())
            {
               message +=
                  String::format(
                     IDS_FINISH_SITE,
                     site.c_str());
            }
            break;
         }
         case State::DEMOTE:
         {
            message = String::load(IDS_FINISH_DEMOTE);
            break;
         }
         case State::ABORT_BDC_UPGRADE:
         {
            message = String::load(IDS_FINISH_ABORT_BDC_UPGRADE);
            break;
         }
         case State::NONE:
         default:
         {
            ASSERT(false);
            break;
         }
      }
   }
   else
   {
      switch (operation)
      {
         case State::REPLICA:
         case State::FOREST:
         case State::TREE:
         case State::CHILD:
         {
            message = String::load(IDS_FINISH_FAILURE);
            break;
         }
         case State::DEMOTE:
         {
            message = String::load(IDS_FINISH_DEMOTE_FAILURE);
            break;
         }
         case State::ABORT_BDC_UPGRADE:
         {
            message = String::load(IDS_FINISH_ABORT_BDC_UPGRADE_FAILURE);
            break;
         }
         case State::NONE:
         default:
         {
            ASSERT(false);
            break;
         }
      }
   }

   return message + L"\r\n\r\n" + state.GetFinishMessages();
}



bool
FinishPage::OnSetActive()
{
   LOG_FUNCTION(FinishPage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_FINISH);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      Win::PropSheet_PressButton(Win::GetParent(hwnd), PSBTN_FINISH);
   }
   else
   {
      Win::SetDlgItemText(hwnd, IDC_MESSAGE, getCompletionMessage());
   }

   return true;
}



bool
FinishPage::OnWizFinish()
{
   LOG_FUNCTION(FinishPage::OnWizFinish);

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\forestpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new forest page
//
// 1-6-98 sburns



#ifndef FORESTPAGE_HPP_INCLUDED
#define FORESTPAGE_HPP_INCLUDED



class ForestPage : public DCPromoWizardPage
{
   public:

   ForestPage();

   protected:

   virtual ~ForestPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   ForestPage(const ForestPage&);
   const ForestPage& operator=(const ForestPage&);
};



#endif   // FORESTPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\forestpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new forest page
//
// 1-6-98 sburns



#include "headers.hxx"
#include "resource.h"
#include "page.hpp"
#include "ForestPage.hpp"
#include "state.hpp"
#include "common.hpp"



ForestPage::ForestPage()
   :
   DCPromoWizardPage(
      IDD_NEW_FOREST,
      IDS_NEW_FOREST_PAGE_TITLE,
      IDS_NEW_FOREST_PAGE_SUBTITLE)
{
   LOG_CTOR(ForestPage);
}



ForestPage::~ForestPage()
{
   LOG_DTOR(ForestPage);
}



void
ForestPage::OnInit()
{
   LOG_FUNCTION(ForestPage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_DOMAIN,
         state.GetAnswerFileOption(State::OPTION_NEW_DOMAIN_NAME));
   }
}



static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int next =
         !Win::GetTrimmedDlgItemText(dialog, IDC_DOMAIN).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);
}



bool
ForestPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(ForestPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



bool
ForestPage::OnSetActive()
{
   LOG_FUNCTION(ForestPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::FOREST);
      
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = ForestPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   enable(hwnd);
   return true;
}



bool
ForestValidateDomainDoesNotExist(
   HWND dialog,   
   int  editResID)
{
   LOG_FUNCTION(ForestValidateDomainDoesNotExist);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResID > 0);

   // this can take awhile.

   Win::WaitCursor cursor;

   String name = Win::GetTrimmedDlgItemText(dialog, editResID);

   // The invoking code should verify this condition, but we will handle
   // it just in case.

   ASSERT(!name.empty());

   bool valid = true;
   String message;
   do
   {
      if (name.empty())
      {
         message = String::load(IDS_MUST_ENTER_DOMAIN);
         valid = false;
         break;
      }
      if (IsDomainReachable(name))
      {
         message = String::format(IDS_DOMAIN_NAME_IN_USE, name.c_str());
         valid = false;
         break;
      }

      HRESULT hr = MyNetValidateName(name, ::NetSetupNonExistentDomain);

      if (hr == Win32ToHresult(ERROR_DUP_NAME))
      {
         message = String::format(IDS_DOMAIN_NAME_IN_USE, name.c_str());
         valid = false;
         break;
      }

      if (hr == Win32ToHresult(ERROR_NETWORK_UNREACHABLE))
      {
         // 25968

         if (
            popup.MessageBox(
               dialog,
               String::format(
                  IDS_NET_NOT_REACHABLE,
                  name.c_str()),
               MB_YESNO | MB_ICONWARNING) != IDYES)
         {
            message.erase();
            valid = false;

            HWND edit = Win::GetDlgItem(dialog, editResID);
            Win::SendMessage(edit, EM_SETSEL, 0, -1);
            Win::SetFocus(edit);
         }
      }

      // otherwise the domain does not exist
   }
   while (0);

   if (!valid && !message.empty())
   {
      popup.Gripe(dialog, editResID, message);
   }

   return valid;
}



int
ForestPage::Validate()
{
   LOG_FUNCTION(ForestPage::Validate);

   String domain = Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN);
   if (domain.empty())
   {
      popup.Gripe(hwnd, IDC_DOMAIN, IDS_MUST_ENTER_DOMAIN);
      return -1;
   }

   State& state = State::GetInstance();
   int nextPage =
         state.GetRunContext() == State::PDC_UPGRADE
      ?  IDD_FOREST_VERSION
      :  IDD_NETBIOS_NAME;

   if (WasChanged(IDC_DOMAIN))
   {
      if (
            !ValidateDomainDnsNameSyntax(hwnd, IDC_DOMAIN, true)
         || !ConfirmNetbiosLookingNameIsReallyDnsName(hwnd, IDC_DOMAIN)

         // do this test last, as it is expensive

         || !ForestValidateDomainDoesNotExist(hwnd, IDC_DOMAIN))
      {
         nextPage = -1;
      }
      else
      {
         ClearChanges();
      }
   }

   if (nextPage != -1)
   {
      state.SetNewDomainDNSName(domain);
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\finish.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// finish page
//
// 12-19-97 sburns



#ifndef FINISH_HPP_INCLUDED
#define FINISH_HPP_INCLUDED



class FinishPage : public WizardPage
{
   public:

   FinishPage();

   protected:

   virtual ~FinishPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   virtual
   bool
   OnWizFinish();

   private:

   // not defined; no copying allowed
   FinishPage(const FinishPage&);
   const FinishPage& operator=(const FinishPage&);
};



#endif   // FINISH_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\forestversionpage.hpp ===
// Copyright (C) 1997-2001 Microsoft Corporation
//
// allow user to set forest version 
//
// 18 Apr 2001 sburns



#ifndef FORESTVERSIONPAGE_HPP_INCLUDED
#define FORESTVERSIONPAGE_HPP_INCLUDED



class ForestVersionPage : public DCPromoWizardPage
{
   public:

   ForestVersionPage();

   protected:

   virtual ~ForestVersionPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   ForestVersionPage(const ForestVersionPage&);
   const ForestVersionPage& operator=(const ForestVersionPage&);
};



#endif   // FORESTVERSIONPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\forestversionpage.cpp ===
// Copyright (C) 1997-2001 Microsoft Corporation
//
// allow user to set forest version
// NTRAID#NTBUG9-159663-2001/04/18-sburns
//
// 18 Apr 2001 sburns



#include "headers.hxx"
#include "resource.h"
#include "page.hpp"
#include "ForestVersionPage.hpp"
#include "state.hpp"



ForestVersionPage::ForestVersionPage()
   :
   DCPromoWizardPage(
      IDD_FOREST_VERSION,
      IDS_FOREST_VERSION_PAGE_TITLE,
      IDS_FOREST_VERSION_PAGE_SUBTITLE)
{
   LOG_CTOR(ForestVersionPage);
}



ForestVersionPage::~ForestVersionPage()
{
   LOG_DTOR(ForestVersionPage);
}



void
ForestVersionPage::OnInit()
{
   LOG_FUNCTION(ForestVersionPage::OnInit);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(State::OPTION_SET_FOREST_VERSION);
      if (option.icompare(State::VALUE_YES) == 0)
      {
         Win::CheckDlgButton(hwnd, IDC_SET_VERSION, BST_CHECKED);
         return;
      }
   }

   Win::CheckDlgButton(hwnd, IDC_SET_VERSION, BST_UNCHECKED);
}



bool
ForestVersionPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(ForestVersionPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_SET_VERSION:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            return true;
         }
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



bool
ForestVersionPage::OnSetActive()
{
   LOG_FUNCTION(ForestVersionPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::FOREST);
      
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      // skip the page.

      LOG(L"skipping ForestVersionPage");

      Wizard& wiz = GetWizard();

      if (wiz.IsBacktracking())
      {
         // backup once again

         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = ForestVersionPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   return true;
}



int
ForestVersionPage::Validate()
{
   LOG_FUNCTION(ForestVersionPage::Validate);

   State& state = State::GetInstance();

   int nextPage = IDD_PATHS;
   state.SetSetForestVersionFlag(Win::IsDlgButtonChecked(hwnd, IDC_SET_VERSION));

   LOG(String::format(L"next = %1!d!", nextPage));
      
   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\getcredentialsdialog.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Dlg to get credentials for browsing domain forest
//
// 1-8-98 sburns



#ifndef GETCREDENTIALSDIALOG_HPP_INCLUDED
#define GETCREDENTIALSDIALOG_HPP_INCLUDED


                        
class GetCredentialsDialog : public Dialog
{
   public:

   explicit
   GetCredentialsDialog(const String& failureMessage);

   virtual ~GetCredentialsDialog();

   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   void
   Enable();

   String failureMessage;

   // not defined: no copying allowed

   GetCredentialsDialog(const GetCredentialsDialog&);
   const GetCredentialsDialog& operator=(const GetCredentialsDialog&);
};



#endif   // GETCREDENTIALSDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\indicate.hpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Progress Indicator class
//
// 12-29-97 sburns



#ifndef INDICATE_HPP_INCLUDED
#define INDICATE_HPP_INCLUDED



class ProgressIndicator
{
   public:

   // obtain the HWND of a dialog containing a static text control and
   // a progress bar control.  Then, constuct a ProgressIndicator
   // object from the HWND and the resource ids of the controls.

   ProgressIndicator(
      HWND  parentDialog,
      int   messageTextResID);

   ~ProgressIndicator();

   void
   Update(const String& message);

   private:

   void
   showControls(bool newState);

   HWND  parentDialog;
   HWND  messageText;
   bool  showState;

   // not implemented: no copying allowed
   ProgressIndicator(const ProgressIndicator&);
   const ProgressIndicator& operator=(const ProgressIndicator&);
};



#endif   // PROGRESS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\gcconfirmationpage.cpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// confirm user want gc for replicate from media
//
// 28 Apr 2000 sburns



#include "headers.hxx"
#include "resource.h"
#include "page.hpp"
#include "GcConfirmationPage.hpp"
#include "state.hpp"



GcConfirmationPage::GcConfirmationPage()
   :
   DCPromoWizardPage(
      IDD_GC_CONFIRM,
      IDS_GC_CONFIRM_PAGE_TITLE,
      IDS_GC_CONFIRM_PAGE_SUBTITLE)
{
   LOG_CTOR(GcConfirmationPage);
}



GcConfirmationPage::~GcConfirmationPage()
{
   LOG_DTOR(GcConfirmationPage);
}



void
GcConfirmationPage::OnInit()
{
   LOG_FUNCTION(GcConfirmationPage::OnInit);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(State::OPTION_GC_CONFIRM);
      if (option.icompare(State::VALUE_YES) == 0)
      {
         Win::CheckDlgButton(hwnd, IDC_GC_YES, BST_CHECKED);
         return;
      }
   }

   Win::CheckDlgButton(hwnd, IDC_GC_NO, BST_CHECKED);
}



bool
GcConfirmationPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(GcConfirmationPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_GC_YES:
      case IDC_GC_NO:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            return true;
         }
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



bool
GcConfirmationPage::OnSetActive()
{
   LOG_FUNCTION(GcConfirmationPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::REPLICA);
      
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended() || !state.IsAdvancedMode())
   {
      // skip the page.

      LOG(L"skipping GcConfirmationPage");

      Wizard& wiz = GetWizard();

      if (wiz.IsBacktracking())
      {
         // backup once again

         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = GcConfirmationPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   return true;
}



int
GcConfirmationPage::Validate()
{
   LOG_FUNCTION(GcConfirmationPage::Validate);

   State& state = State::GetInstance();

   int nextPage = IDD_CONFIG_DNS_CLIENT;
   state.SetRestoreGc(Win::IsDlgButtonChecked(hwnd, IDC_GC_YES));

   LOG(String::format(L"next = %1!d!", nextPage));
      
   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\getcredentialsdialog.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Dlg to get credentials for browsing domain forest
//
// 1-8-98 sburns



#include "headers.hxx"
#include "GetCredentialsDialog.hpp"
#include "resource.h"
#include "state.hpp"
#include "ds.hpp"
#include "common.hpp"
#include "CredentialUiHelpers.hpp"



static const DWORD HELP_MAP[] =
{
   0, 0
};



GetCredentialsDialog::GetCredentialsDialog(const String& failureMessage_)
   :
   Dialog(IDD_NEW_CREDENTIALS, HELP_MAP),
   failureMessage(failureMessage_)
{
   LOG_CTOR(GetCredentialsDialog);
   ASSERT(!failureMessage.empty());

   CredUIInitControls();
}



GetCredentialsDialog::~GetCredentialsDialog()
{
   LOG_DTOR(GetCredentialsDialog);
}



void
GetCredentialsDialog::Enable()
{
// LOG_FUNCTION(GetCredentialsDialog::Enable);

   bool okEnabled =
         !CredUi::GetUsername(Win::GetDlgItem(hwnd, IDC_CRED)).empty()
      && !Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN).empty();

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDOK), okEnabled);
}



String
GetCredentialMessage()
{
   LOG_FUNCTION(GetCredentialMessage);

   int id = 0;
   String arg;
   State& state = State::GetInstance();

   switch (state.GetOperation())
   {
      case State::REPLICA:
      {
         id = IDS_REPLICA_CREDENTIALS;
         arg = state.GetReplicaDomainDNSName();
         break;
      }
      case State::TREE:
      {
         id = IDS_SIBLING_CREDENTIALS;
         arg = state.GetParentDomainDnsName();
         break;
      }
      case State::CHILD:
      {
         id = IDS_PARENT_CREDENTIALS;
         arg = state.GetParentDomainDnsName();
         break;
      }
      case State::DEMOTE:
      {
         const Computer& computer = state.GetComputer();         
         arg =
            GetParentDomainDnsName(computer.GetDomainDnsName(), false);
         if (!arg.empty())
         {
            // dc is for a child domain

            id = IDS_PARENT_DEMOTE_CREDENTIALS;
         }
         else
         {
            // dc is for forest root or tree root domain

            arg = computer.GetForestDnsName();
            id = IDS_ROOT_DOMAIN_CREDENTIALS;
         }
         break;
      }
      case State::ABORT_BDC_UPGRADE:
      {
         id = IDS_ABORT_BDC_UPGRADE_CREDENTIALS;
         arg.erase();
         break;
      }
      case State::FOREST:
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   if (id)
   {
      return String::format(id, arg.c_str());
   }

   return String();
}



String
GetDefaultUserDomainName()
{
   LOG_FUNCTION(GetDefaultUserDomainName);

   String def;
   State& state = State::GetInstance();   
   switch (state.GetOperation())
   {
      case State::REPLICA:
      {
         def = state.GetReplicaDomainDNSName();
         break;
      }
      case State::TREE:
      case State::CHILD:
      {
         def = state.GetParentDomainDnsName();
         break;
      }
      case State::DEMOTE:
      {
         String parent = 
            GetParentDomainDnsName(
               State::GetInstance().GetComputer().GetDomainDnsName(), false);

         if (state.IsLastDCInDomain() && !parent.empty())
         {
            def = parent;
         }
         else
         {
            def = state.GetComputer().GetDomainDnsName();
         }
         break;
      }
      case State::FOREST:
      case State::ABORT_BDC_UPGRADE:
      case State::NONE:
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return def;
}
   


void
GetCredentialsDialog::OnInit()
{
   LOG_FUNCTION(GetCredentialsDialog::OnInit);

   HWND hwndCred = Win::GetDlgItem(hwnd, IDC_CRED);
   Credential_SetUserNameMaxChars(hwndCred, DS::MAX_USER_NAME_LENGTH);
   Credential_SetPasswordMaxChars(hwndCred, DS::MAX_PASSWORD_LENGTH);

   // Only use the smartcard flag when the machine is joined to a domain. On a
   // standalone machine, the smartcard won't have access to any domain
   // authority to authenticate it.
   // NTRAID#NTBUG9-287538-2001/01/23-sburns
   
   State& state = State::GetInstance();
   Computer& computer = state.GetComputer();
   
   DWORD flags = CRS_NORMAL | CRS_USERNAMES;
   if (
         computer.IsJoinedToDomain()

         // can only use smartcards on replica promotions
         // NTRAID#NTBUG9-311150-2001/02/19-sburns
         
      && state.GetOperation() == State::REPLICA)
   {
      flags |= CRS_SMARTCARDS;
   }
   Credential_InitStyle(hwndCred, flags);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      Dns::MAX_NAME_LENGTH);

   Win::SetDlgItemText(hwnd, IDC_FAILURE_MESSAGE, failureMessage);
   Win::SetDlgItemText(hwnd, IDC_MESSAGE, GetCredentialMessage());

   String domain = state.GetUserDomainName();
   if (domain.empty())
   {
      domain = GetDefaultUserDomainName();
   }
   Win::SetDlgItemText(hwnd, IDC_DOMAIN, domain);      

   CredUi::SetUsername(hwndCred, state.GetUsername());
   CredUi::SetPassword(hwndCred, state.GetPassword());

   Enable();
}



bool
GetCredentialsDialog::OnCommand(
   HWND     /* windowFrom */ ,   
   unsigned controlIDFrom,
   unsigned code)         
{
//   LOG_FUNCTION(GetCredentialsDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            // transfer the dialog contents to the state object.

            State& state = State::GetInstance();
            HWND hwndCred = Win::GetDlgItem(hwnd, IDC_CRED);

            state.SetUsername(CredUi::GetUsername(hwndCred));
            state.SetPassword(CredUi::GetPassword(hwndCred));
            state.SetUserDomainName(
               Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN));

            HRESULT unused = Win::EndDialog(hwnd, controlIDFrom);

            ASSERT(SUCCEEDED(unused));

            return true;
         }

         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, controlIDFrom);

            ASSERT(SUCCEEDED(unused));

            return true;
         }

         break;
      }
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);         
            Enable();
            return true;
         }

         break;
      }
      case IDC_CRED:
      {
         if (code == CRN_USERNAMECHANGE)
         {
            SetChanged(controlIDFrom);         
            Enable();
            return true;
         }

         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\indicate.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Progress Indicator class
//
// 12-29-97 sburns



#include "headers.hxx"
#include "indicate.hpp"



ProgressIndicator::ProgressIndicator(
   HWND  parentDialog,
   int   messageTextResID)
   :
   parentDialog(parentDialog_)
{
   LOG_CTOR(ProgressIndicator);

   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(messageTextResID > 0);

   messageText = Win::GetDlgItem(parentDialog, messageTextResID);
   ASSERT(Win::IsWindow(messageText));

   showState = true;
   showControls(false);
}



ProgressIndicator::~ProgressIndicator()
{
   LOG_DTOR(ProgressIndicator);
}



void
ProgressIndicator::Update(const String& message)
{
   showControls(true);
   Win::SetWindowText(messageText, message);
}



void
ProgressIndicator::showControls(bool newState)
{
   if (newState != showState)
   {
      Win::ShowWindow(messageText, newState);
      showState = newState;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\gcconfirmationpage.hpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// confirm user want gc for replicate from media
//
// 28 Apr 2000 sburns



#ifndef GCCONFIRMATIONPAGE_HPP_INCLUDED
#define GCCONFIRMATIONPAGE_HPP_INCLUDED



class GcConfirmationPage : public DCPromoWizardPage
{
   public:

   GcConfirmationPage();

   protected:

   virtual ~GcConfirmationPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   GcConfirmationPage(const GcConfirmationPage&);
   const GcConfirmationPage& operator=(const GcConfirmationPage&);
};



#endif   // GCCONFIRMATIONPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\installtcpippage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// install tcp/ip page
//
// 12-18-97 sburns



#ifndef INSTALLTCPIPPAGE_HPP_INCLUDED
#define INSTALLTCPIPPAGE_HPP_INCLUDED



#include "page.hpp"



class InstallTcpIpPage : public DCPromoWizardPage
{
   public:

   InstallTcpIpPage();

   protected:

   virtual ~InstallTcpIpPage();

   // Dialog overrides

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lparam);
   
   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   InstallTcpIpPage(const InstallTcpIpPage&);
   const InstallTcpIpPage& operator=(const InstallTcpIpPage&);
};



#endif   // INSTALLTCPIPPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\netbiosnamepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// netbios domain name page
//
// 1-6-98 sburns



#ifndef NETBIOSNAMEPAGE_HPP_INCLUDED
#define NETBIOSNAMEPAGE_HPP_INCLUDED



class NetbiosNamePage : public DCPromoWizardPage
{
   public:

   NetbiosNamePage();

   protected:

   virtual ~NetbiosNamePage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage oveerrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   NetbiosNamePage(const NetbiosNamePage&);
   const NetbiosNamePage& operator=(const NetbiosNamePage&);
};



#endif   // NETBIOSNAMEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\installtcpippage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// install tcp/ip page
//
// 12-18-97 sburns



#include "headers.hxx"
#include "InstallTcpIpPage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"



// artshel recommends that we use WSAIoctl + SIO_ADDRESS_LIST_QUERY instead of
// GetIpAddrTable because "it's more "official" and less likely to change,
// which means less work for everyone when we upgrade/revise IPHLPAPI," but
// confirms that for Whistler, they are equivalent.
// NTRAID#NTBUG9--2001/04/24-sburns

// sample code:

// // 
// // DWORD
// // GetIPv4Addresses(
// //     IN LPSOCKET_ADDRESS_LIST *ppList)
// // {
// //     LPSOCKET_ADDRESS_LIST pList = NULL;
// //     ULONG                 ulSize = 0;
// //     DWORD                 dwErr;
// //     DWORD                 dwBytesReturned;
// //     SOCKET                s;
// // 
// //     *ppList = NULL;
// // 
// //     s = socket(AF_INET, SOCK_DGRAM, 0);
// //     if (s == INVALID_SOCKET)
// //         return WSAGetLastError();
// // 
// //     for (;;) {
// //         dwErr = WSAIoctl(s, SIO_ADDRESS_LIST_QUERY, NULL, 0, pList, ulSize, 
// //                          &dwBytesReturned, NULL, NULL);
// // 
// //         if (!dwErr) {
// //             break;
// //         }
// // 
// //         if (pList) {
// //             FREE(pList);
// //             pList = NULL;
// //         }
// //     
// //         dwErr = WSAGetLastError();
// //         if (dwErr != WSAEFAULT)
// //             break;
// //     
// //         pList = MALLOC(dwBytesReturned);
// //         if (!pList) {
// //             dwErr = ERROR_NOT_ENOUGH_MEMORY;
// //             break;
// //         }
// // 
// //         ulSize = dwBytesReturned;
// //     }
// // 
// //     closesocket(s);
// // 
// //     *ppList = pList;
// //     return dwErr;
// // }



// Returns true if tcp/ip is "working" (can send/receive packets on at least
// one IP address.

bool
IsTcpIpFunctioning()
{
   LOG_FUNCTION(IsTcpIpFunctioning);

   bool result = false;

   // As per nksrin, we will call GetIpAddrTable.  If no addresses are in
   // the table, then the IP stack is not in a state to send/rcv packets
   // with the rest of the world

   HRESULT hr = S_OK;
   BYTE* buf = 0;
   do
   {
      // first, determine the size of the table

      ULONG tableSize = 0;
      DWORD err = ::GetIpAddrTable(0, &tableSize, FALSE);
      if (err != ERROR_INSUFFICIENT_BUFFER)
      {
         LOG(L"GetIpAddrTable for table size failed");
         LOG_HRESULT(Win32ToHresult(err));
         break;
      }

      // allocate space for the table.

      buf = new BYTE[tableSize + 1];
      memset(buf, 0, tableSize + 1);
      PMIB_IPADDRTABLE table = reinterpret_cast<PMIB_IPADDRTABLE>(buf);

      LOG(L"Calling GetIpAddrTable");

      hr =
         Win32ToHresult(
            ::GetIpAddrTable(
               table,
               &tableSize,
               FALSE));
      BREAK_ON_FAILED_HRESULT2(hr, L"GetIpAddrTable failed");

      LOG(String::format(L"dwNumEntries: %1!d!", table->dwNumEntries));

      for (int i = 0; i < table->dwNumEntries; ++i)
      {
         DWORD addr = table->table[i].dwAddr;
         LOG(String::format(L"entry %1!d!", i));
         LOG(String::format(
            L"dwAddr %1!X! (%2!d!.%3!d!.%4!d!.%5!d!)",
            addr,
				((BYTE*)&addr)[0],
				((BYTE*)&addr)[1],
				((BYTE*)&addr)[2],
				((BYTE*)&addr)[3]));

         // skip loopback, etc.

         if (
               INADDR_ANY        == addr
            || INADDR_BROADCAST  == addr
            || INADDR_LOOPBACK   == addr
            || 0x0100007f        == addr )
         {
            LOG(L"is loopback/broadcast -- skipping");

            continue;
         }

         // Exclude MCAST addresses (class D).

         if (
               IN_CLASSA(htonl(addr))
            || IN_CLASSB(htonl(addr))
            || IN_CLASSC(htonl(addr)) )
         {
            LOG(L"is class A/B/C");

            result = true;
            break;
         }

         LOG(L"not class A/B/C -- skipping");
      }
   }
   while (0);

   delete[] buf;

   LOG(String::format(L"TCP/IP %1 functioning", result ? L"is" : L"is NOT"));

   return result;
}



InstallTcpIpPage::InstallTcpIpPage()
   :
   DCPromoWizardPage(
      IDD_INSTALL_TCPIP,
      IDS_INSTALL_TCPIP_PAGE_TITLE,
      IDS_INSTALL_TCPIP_PAGE_SUBTITLE)
{
   LOG_CTOR(InstallTcpIpPage);
}



InstallTcpIpPage::~InstallTcpIpPage()
{
   LOG_DTOR(InstallTcpIpPage);
}



void
InstallTcpIpPage::OnInit()
{
   LOG_FUNCTION(InstallTcpIpPage::OnInit);
}



bool
InstallTcpIpPage::OnSetActive()
{
   LOG_FUNCTION(InstallTcpIpPage::OnSetActive);

   State& state = State::GetInstance();   
   if (
         state.RunHiddenUnattended()
      or (IsTcpIpInstalled() and IsTcpIpFunctioning()) )
   {
      LOG(L"Planning to Skip InstallTcpIpPage");

      Wizard& wizard = GetWizard();

      if (wizard.IsBacktracking())
      {
         // backup once again

         wizard.Backtrack(hwnd);
         return true;
      }

      int nextPage = Validate();
      if (nextPage != -1)
      {
         LOG(L"skipping InstallTcpIpPage");
         wizard.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



bool
InstallTcpIpPage::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR controlIDFrom,
   UINT     code,
   LPARAM   /* lParam */ )
{
//   LOG_FUNCTION(InstallTcpIpPage::OnNotify);

   bool result = false;
   
   if (controlIDFrom == IDC_JUMP)
   {
      switch (code)
      {
         case NM_CLICK:
         case NM_RETURN:
         {
            ShowTroubleshooter(hwnd, IDS_INSTALL_TCPIP_HELP_TOPIC);
            result = true;
         }
         default:
         {
            // do nothing
            
            break;
         }
      }
   }
   
   return result;
}



int
InstallTcpIpPage::Validate() 
{
   LOG_FUNCTION(InstallTcpIpPage::Validate);

   int nextPage = -1;
   if (IsTcpIpInstalled() and IsTcpIpFunctioning())
   {
      State& state = State::GetInstance();
      switch (state.GetRunContext())
      {
         case State::BDC_UPGRADE:
         {
            ASSERT(state.GetOperation() == State::REPLICA);
            nextPage = IDD_REPLICATE_FROM_MEDIA; // IDD_CONFIG_DNS_CLIENT;
            break;
         }
         case State::PDC_UPGRADE:
         {
            nextPage = IDD_TREE_OR_CHILD;
            break;
         }
         case State::NT5_STANDALONE_SERVER:
         case State::NT5_MEMBER_SERVER:
         {
            nextPage = IDD_REPLICA_OR_DOMAIN;
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }
   }
   else
   {
      String message = String::load(IDS_INSTALL_TCPIP_FIRST);

      popup.Info(hwnd, message);
   }


   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\multilineeditboxthatforwardsenterkey.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// multi-line edit box control wrapper
//
// 22 Nov 2000 sburns
//
// added to fix NTRAID#NTBUG9-232092-2000/11/22-sburns



#include "headers.hxx"
#include "MultiLineEditBoxThatForwardsEnterKey.hpp"



MultiLineEditBoxThatForwardsEnterKey::MultiLineEditBoxThatForwardsEnterKey()
{
   LOG_CTOR(MultiLineEditBoxThatForwardsEnterKey);
}



MultiLineEditBoxThatForwardsEnterKey::~MultiLineEditBoxThatForwardsEnterKey()
{
   LOG_DTOR(MultiLineEditBoxThatForwardsEnterKey);
}



HRESULT
MultiLineEditBoxThatForwardsEnterKey::Init(HWND editControl)
{
   LOG_FUNCTION(MultiLineEditBoxThatForwardsEnterKey::Init);
   ASSERT(Win::GetClassName(editControl) == L"Edit");

   HRESULT hr = ControlSubclasser::Init(editControl);

   return hr;
}



LRESULT
MultiLineEditBoxThatForwardsEnterKey::OnMessage(
   UINT   message,
   WPARAM wparam, 
   LPARAM lparam) 
{
   // LOG_FUNCTION(MultiLineEditBoxThatForwardsEnterKey::OnMessage);

   switch (message)
   {
      case WM_KEYDOWN:
      {
		  switch (wparam)
         {
            case VK_RETURN:
            {
               // Send the parent window a WM_COMMAND message with IDOK as
               // the notification code.
               
               Win::SendMessage(
                  Win::GetParent(hwnd),
                  WM_COMMAND,
                  MAKELONG(::GetDlgCtrlID(hwnd), FORWARDED_ENTER),
                  reinterpret_cast<LPARAM>(hwnd));
               break;
            }
            default:
            {
               // do nothing

               break;
            }
         }

         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return ControlSubclasser::OnMessage(message, wparam, lparam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\multilineeditboxthatforwardsenterkey.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// multi-line edit box control wrapper
//
// 22 Nov 2000 sburns
//
// added to fix NTRAID#NTBUG9-232092-2000/11/22-sburns



#ifndef MULTILINEEDITBOXTHATFORWARDSENTERKEY_HPP_INCLUDED
#define MULTILINEEDITBOXTHATFORWARDSENTERKEY_HPP_INCLUDED



#include "ControlSubclasser.hpp"



// Class for hooking the window proc of a multi-line edit control to cause
// it to forward enter keypresses to its parent window as WM_COMMAND
// messages.

class MultiLineEditBoxThatForwardsEnterKey : public ControlSubclasser
{
   public:

   static const WORD FORWARDED_ENTER = 1010;
   
   MultiLineEditBoxThatForwardsEnterKey();

   virtual 
   ~MultiLineEditBoxThatForwardsEnterKey();



   // subclasses the edit control
   //
   // editControl - in, handle to the edit control to be hooked.  This must be
   // a handle to an edit control, or we assert and throw rotten eggs.
   
   HRESULT
   Init(HWND editControl);



   // Invoked upon receipt of any window message.
   // 
   // message - in, the message code passed to the dialog window.
   // 
   // wparam - in, the WPARAM parameter accompanying the message.
   // 
   // lparam - in, the LPARAM parameter accompanying the message.
   
   LRESULT
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);
   


   private:

   // not implemented: no copying allowed

   MultiLineEditBoxThatForwardsEnterKey(
      const MultiLineEditBoxThatForwardsEnterKey&);
   const MultiLineEditBoxThatForwardsEnterKey&
   operator=(const MultiLineEditBoxThatForwardsEnterKey&);
};



#endif   // MULTILINEEDITBOXTHATFORWARDSENTERKEY_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\netbiosnamepage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// netbios domain name page
//
// 1-6-98 sburns



#include "headers.hxx"
#include "page.hpp"
#include "NetbiosNamePage.hpp"
#include "common.hpp"
#include "resource.h"
#include "state.hpp"
#include "ds.hpp"



NetbiosNamePage::NetbiosNamePage()
   :
   DCPromoWizardPage(
      IDD_NETBIOS_NAME,
      IDS_NETBIOS_NAME_PAGE_TITLE,
      IDS_NETBIOS_NAME_PAGE_SUBTITLE)
{
   LOG_CTOR(NetbiosNamePage);
}



NetbiosNamePage::~NetbiosNamePage()
{
   LOG_DTOR(NetbiosNamePage);
}



void
NetbiosNamePage::OnInit()
{
   LOG_FUNCTION(NetbiosNamePage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_NETBIOS),
      DS::MAX_NETBIOS_NAME_LENGTH);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_NETBIOS,
         state.GetAnswerFileOption(State::OPTION_NEW_DOMAIN_NETBIOS_NAME));
   }
}



static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int next =
         !Win::GetTrimmedDlgItemText(dialog, IDC_NETBIOS).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);
}



bool
NetbiosNamePage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(NetbiosNamePage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_NETBIOS:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            enable(hwnd);
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



HRESULT
MyDsRoleDnsNameToFlatName(
   const String&  domainDNSName,
   String&        result,
   bool&          nameWasTweaked)
{
   LOG_FUNCTION(MyDsRoleDnsNameToFlatName);
   ASSERT(!domainDNSName.empty());

   nameWasTweaked = false;
   result.erase();

   LOG(L"Calling DsRoleDnsNameToFlatName");
   LOG(               L"lpServer  : (null)");
   LOG(String::format(L"lpDnsName : %1", domainDNSName.c_str()));

   PWSTR flatName = 0;
   ULONG flags = 0;
   HRESULT hr =
      Win32ToHresult(
         ::DsRoleDnsNameToFlatName(
            0, // this server
            domainDNSName.c_str(),
            &flatName,
            &flags));

   LOG_HRESULT(hr);

   if (SUCCEEDED(hr) && flatName)
   {
      LOG(String::format(L"lpFlatName   : %1", flatName));
      LOG(String::format(L"lpStatusFlag : %1!X!", flags));

      result = flatName;
      if (result.length() > DNLEN)
      {
         result.resize(DNLEN);
      }
      ::DsRoleFreeMemory(flatName);

      // the name was tweaked if it is not the default.  338443

      nameWasTweaked = !(flags & DSROLE_FLATNAME_DEFAULT);
   }

   return hr;
}



// return true if the name generated has already been validated, false
// if not.

bool
GenerateDefaultNetbiosName(HWND parent)
{
   LOG_FUNCTION(GenerateDefaultNetbiosName);
   ASSERT(Win::IsWindow(parent));

   Win::CursorSetting cursor(IDC_WAIT);

   bool result = false;

   String dnsDomainName = State::GetInstance().GetNewDomainDNSName();
   bool nameWasTweaked = false;
   String generatedName;
   HRESULT hr = 
      MyDsRoleDnsNameToFlatName(
         dnsDomainName,
         generatedName,
         nameWasTweaked);
   if (FAILED(hr))
   {
      // if the api call failed, the name could not have been validated.

      result = false;

      // fall back to just the first 15 characters of the first label

      generatedName =
         dnsDomainName.substr(0, min(DNLEN, dnsDomainName.find(L'.')));

      LOG(String::format(L"falling back to %1", generatedName.c_str()));
   }
   else
   {
      // the api validated the name for us.

      result = true;
   }

   generatedName.to_upper();

   if (generatedName.is_numeric())
   {
      // the generated name is all-numeric.  This is not allowed.  So we
      // toss it out.   368777 bis

      generatedName.erase();
      nameWasTweaked = false;
   }

   Win::SetDlgItemText(
      parent,
      IDC_NETBIOS,
      generatedName);

   // inform the user that the default NetBIOS name was adjusted due
   // to name collision on the network

   if (nameWasTweaked)
   {
      popup.Info(
         parent,
         String::format(
            IDS_GENERATED_NAME_WAS_TWEAKED,
            generatedName.c_str()));
   }

   return result;
}



bool
NetbiosNamePage::OnSetActive()
{
   LOG_FUNCTION(NetbiosNamePage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   // do this here instead of in init to regenerate a default name if the
   // user has not annointed one already.

   if (
         !state.UsingAnswerFile()
      && state.GetNewDomainNetbiosName().empty())
   {
      // 338443

      if (GenerateDefaultNetbiosName(hwnd))
      {
         // Clear the changes so we don't validate the generated name: it's
         // supposed to already be valid.

         ClearChanges();
      }
   }
      
   enable(hwnd);
   return true;
}



bool
ValidateDomainNetbiosName(HWND dialog, int editResID)
{
   LOG_FUNCTION(ValidateDomainNetbiosName);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResID > 0);

   Win::CursorSetting cursor(IDC_WAIT);

   String name = Win::GetTrimmedDlgItemText(dialog, editResID);
   if (name.empty())
   {
      return false;
   }

   if (name.find(L".") != String::npos)
   {
      popup.Gripe(
         dialog,
         editResID,
         IDS_NO_DOTS_IN_NETBIOS_NAME);
      return false;
   }

   // Check that the name is not a number.  368777
   if (name.is_numeric())
   {
      popup.Gripe(
         dialog,
         editResID,
         String::format(IDS_NUMERIC_NETBIOS_NAME, name.c_str()));
      return false;
   }

   // we pretend that the candidate name is a hostname, and attempt to
   // generate a netbios name from it.  If that can't be done, then the
   // candidate name can't be a legal netbios name.

   HRESULT hr = S_OK;
   String s = Dns::HostnameToNetbiosName(name, &hr);
   if (FAILED(hr))
   {
      popup.Gripe(
         dialog,
         editResID,
         hr,
         String::format(IDS_BAD_NETBIOS_NAME, name.c_str()));
      return false;
   }
   if (s.length() < name.length())
   {
      // the name was truncated.
      popup.Gripe(
         dialog,
         editResID,
         String::format(
            IDS_NETBIOS_NAME_TOO_LONG,
            name.c_str(),
            DS::MAX_NETBIOS_NAME_LENGTH));
      return false;
   }
   if (ValidateNetbiosDomainName(s) != VALID_NAME)
   {
      popup.Gripe(
         dialog,
         editResID,
         String::format(
            IDS_BAD_NETBIOS_CHARACTERS,
            s.c_str()));
      return false;
   }

   hr = MyNetValidateName(name, ::NetSetupNonExistentDomain);

   if (hr == Win32ToHresult(ERROR_DUP_NAME))
   {
      popup.Gripe(
         dialog,
         editResID,
         String::format(IDS_FLATNAME_IN_USE, name.c_str()));
      return false;
   }

   if (hr == Win32ToHresult(ERROR_NETWORK_UNREACHABLE))
   {
      // 25968

      if (
         popup.MessageBox(
            dialog,
            String::format(
               IDS_NET_NOT_REACHABLE,
               name.c_str()),
            MB_YESNO | MB_ICONWARNING) != IDYES)
      {
         HWND edit = Win::GetDlgItem(dialog, editResID);
         Win::SendMessage(edit, EM_SETSEL, 0, -1);
         Win::SetFocus(edit);
         
         return false;
      }
   }

   return true;
}


   
int
NetbiosNamePage::Validate()
{
   LOG_FUNCTION(NetbiosNamePage::Validate);

   int nextPage = IDD_PATHS; 

   if (WasChanged(IDC_NETBIOS))
   {
      if (!ValidateDomainNetbiosName(hwnd, IDC_NETBIOS))
      {
         nextPage = -1;
      }
   }

   if (nextPage != -1)
   {
      ClearChanges();
      State& state = State::GetInstance();
      state.SetNewDomainNetbiosName(
         Win::GetTrimmedDlgItemText(hwnd, IDC_NETBIOS));
   }
      
   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\newdomainpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// New domain page
//
// 9 Feb 2000 sburns



#include "headers.hxx"
#include "page.hpp"
#include "NewDomainPage.hpp"
#include "resource.h"
#include "state.hpp"



NewDomainPage::NewDomainPage()
   :
   DCPromoWizardPage(
      IDD_NEW_DOMAIN,
      IDS_NEW_DOMAIN_PAGE_TITLE,
      IDS_NEW_DOMAIN_PAGE_SUBTITLE)
{
   LOG_CTOR(NewDomainPage);
}



NewDomainPage::~NewDomainPage()
{
   LOG_DTOR(NewDomainPage);
}



int
CheckForWin2kOptions(const State& state)
{
   LOG_FUNCTION(CheckForWin2kOptions);

   int result = IDC_FOREST;

   // look for old (win2k) options

   String treeOrChild  = state.GetAnswerFileOption(L"TreeOrChild").to_upper(); 
   String createOrJoin = state.GetAnswerFileOption(L"CreateOrJoin").to_upper();

   static const String TREE(L"TREE");
   static const String CREATE(L"CREATE");

   do
   {
      // we set defaults such that they are the same as in win2k

      if (treeOrChild != TREE)
      {
         result = IDC_CHILD;
         break;
      }

      if (createOrJoin != CREATE)
      {
         result = IDC_TREE;
      }
   }
   while (0);

   return result;
}



void
NewDomainPage::OnInit()
{
   LOG_FUNCTION(NewDomainPage::OnInit);

   State& state = State::GetInstance();

   int button = IDC_FOREST;
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(State::OPTION_NEW_DOMAIN);

      // NewDomain trumps the old TreeOrChild/CreateOrJoin options.

      if (option.empty())
      {
         button = CheckForWin2kOptions(state);
      }
      else if (option.icompare(State::VALUE_TREE) == 0)
      {
         button = IDC_TREE;
      }
      else if (option.icompare(State::VALUE_CHILD) == 0)
      {
         button = IDC_CHILD;
      }
   }

   Win::CheckDlgButton(hwnd, button, BST_CHECKED);
}



bool
NewDomainPage::OnSetActive()
{
   LOG_FUNCTION(NewDomainPage::OnSetActive);
   
   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = NewDomainPage::Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



int
NewDomainPage::Validate()
{
   LOG_FUNCTION(NewDomainPage::Validate);

   State& state = State::GetInstance();
   int nextPage = -1;

   if (Win::IsDlgButtonChecked(hwnd, IDC_CHILD))
   {
      state.SetOperation(State::CHILD);
      nextPage = IDD_CONFIG_DNS_CLIENT;
   }
   else if (Win::IsDlgButtonChecked(hwnd, IDC_TREE))
   {
      state.SetOperation(State::TREE);
      nextPage = IDD_CONFIG_DNS_CLIENT;
   }
   else if (Win::IsDlgButtonChecked(hwnd, IDC_FOREST))
   {
      state.SetOperation(State::FOREST);
      nextPage = IDD_DNS_ON_NET;
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\newdomainpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// New domain page
//
// 9 Feb 2000 sburns



#ifndef NEWDOMAINPAGE_HPP_INCLUDED
#define NEWDOMAINPAGE_HPP_INCLUDED



class NewDomainPage : public DCPromoWizardPage
{
   public:

   NewDomainPage();

   protected:

   virtual ~NewDomainPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   NewDomainPage(const NewDomainPage&);
   const NewDomainPage& operator=(const NewDomainPage&);
};



#endif   // NEWDOMAINPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\newsitepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new site page
//
// 1-6-98 sburns



#ifndef NEWSITEPAGE_HPP_INCLUDED
#define NEWSITEPAGE_HPP_INCLUDED



class NewSitePage : public DCPromoWizardPage
{
   public:

   NewSitePage();

   protected:

   virtual ~NewSitePage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();

   // not defined; no copying allowed

   NewSitePage(const NewSitePage&);
   const NewSitePage& operator=(const NewSitePage&);
};



#endif   // NEWSITEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\newsitepage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new site page
//
// 1-6-98 sburns



#include "headers.hxx"
#include "page.hpp"
#include "NewSitePage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"
#include "dns.hpp"



NewSitePage::NewSitePage()
   :
   DCPromoWizardPage(
      IDD_NEW_SITE,
      IDS_NEW_SITE_PAGE_TITLE,
      IDS_NEW_SITE_PAGE_SUBTITLE)
{
   LOG_CTOR(NewSitePage);
}



NewSitePage::~NewSitePage()
{
   LOG_DTOR(NewSitePage);
}



void
NewSitePage::OnInit()
{
   LOG_FUNCTION(NewSitePage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_SITE),
      Dns::MAX_LABEL_LENGTH);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_SITE,
         state.GetAnswerFileOption(State::OPTION_SITE_NAME));
   }

   if (Win::GetTrimmedDlgItemText(hwnd, IDC_SITE).empty())
   {
      // assign a default site name

      Win::SetDlgItemText(
         hwnd,
         IDC_SITE,
         String::load(IDS_FIRST_SITE));
   }
}



void
NewSitePage::Enable()
{
   int next =
         !Win::GetTrimmedDlgItemText(hwnd, IDC_SITE).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | next);
}


   
bool
NewSitePage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(NewSitePage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_SITE:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);            
            Enable();
            return true;
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



bool
NewSitePage::OnSetActive()
{
   LOG_FUNCTION(NewSitePage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   Wizard& wizard = GetWizard();

   if (wizard.IsBacktracking())
   {
      // backup once again

      wizard.Backtrack(hwnd);
   }
   else
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         wizard.SetNextPageID(hwnd, nextPage);
         return true;
      }
      else
      {
         State::GetInstance().ClearHiddenWhileUnattended();
      }
   }

   Enable();
   return true;
}



int
NewSitePage::Validate()
{
   LOG_FUNCTION(NewSitePage::Validate);

   State& state = State::GetInstance();

   // this page is only used in new forest scenarios

   ASSERT(state.GetOperation() == State::FOREST);

   int nextPage = -1;
   String site = Win::GetTrimmedDlgItemText(hwnd, IDC_SITE);
   if (!site.empty())
   {
      if (ValidateSiteName(hwnd, IDC_SITE))
      {
         state.SetSiteName(Win::GetTrimmedDlgItemText(hwnd, IDC_SITE));
         nextPage = IDD_RAS_FIXUP;
      }
   }
   else
   {
      popup.Gripe(hwnd, IDC_SITE, IDS_MUST_SPECIFY_SITE);
   }

   if (nextPage != -1)
   {
      if (!state.IsDNSOnNetwork())
      {
         nextPage = IDD_RAS_FIXUP;
      }
      else
      {
         nextPage = IDD_DYNAMIC_DNS;
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\passwordeditbox.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// password edit control wrapper
//
// 6 Nov 2000 sburns
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns



#ifndef PASSWORDEDITBOX_HPP_INCLUDED
#define PASSWORDEDITBOX_HPP_INCLUDED



#include "CapsLockBalloonTip.hpp"
#include "ControlSubclasser.hpp"



// Class for hooking the window proc of an edit control to add a balloon
// tooltip that is shown when the caps lock key is pressed.

class PasswordEditBox : public ControlSubclasser
{
   public:

   PasswordEditBox();

   virtual 
   ~PasswordEditBox();



   // subclasses the edit control, inits the balloon tip, and sets the text
   // limit appropriately.
   //
   // editControl - in, handle to the edit control to be hooked.  This must be
   // a handle to an edit control, or we fire an assertion.
   
   HRESULT
   Init(HWND editControl);



   // Invoked upon receipt of any window message.
   // 
   // message - in, the message code passed to the dialog window.
   // 
   // wparam - in, the WPARAM parameter accompanying the message.
   // 
   // lparam - in, the LPARAM parameter accompanying the message.
   
   LRESULT
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);
   


   private:

   // not implemented: no copying allowed

   PasswordEditBox(const PasswordEditBox&);
   const PasswordEditBox& operator=(const PasswordEditBox&);

   CapsLockBalloonTip balloonTip;        
};



#endif   // PASSWORDEDITBOX_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\nondomainnc.hpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Non-domain Naming Context checking code
//
// 13 July 2000 sburns, from code supplied by jeffparh



#ifndef NONDOMAINNC_HPP_INCLUDED
#define NONDOMAINNC_HPP_INCLUDED



// return true if this machine hosts the last replica of at least one
// non-domain NC, or if such determination cannot be made due to an error.
// 
// If the result is true, then also pop up a dialog listing the NCs and
// hinting at how to remove them, or in the case of an error, report the
// failure. If true is returned, the wizard should terminate.
// 
// return false if the machine is not a domain controller, or is not the last
// replica of a non-domain NC.  In this case, the wizard can proceed.
// 
// NTRAID#NTBUG9-120143-2000/11/02-sburns

bool
IsLastReplicaOfNonDomainNamingContexts();



class NonDomainNcErrorDialog : public Dialog
{
   public:

   NonDomainNcErrorDialog(StringList& ndncList_);

   virtual
   ~NonDomainNcErrorDialog();

   private:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   void
   PopulateListView();   

   // not defined: no copying allowed

   NonDomainNcErrorDialog(const NonDomainNcErrorDialog&);
   const NonDomainNcErrorDialog& operator=(const NonDomainNcErrorDialog&);

   StringList& ndncList;
   HICON       warnIcon;
};



#endif   // NONDOMAINNC_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\nonrfccomputernamedialog.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Dlg to inform user of a non-rfc computer name
//
// 18 Aug 2000 sburns



#ifndef NONRFCCOMPUTERNAMEDIALOG_HPP_INCLUDED
#define NONRFCCOMPUTERNAMEDIALOG_HPP_INCLUDED


                        
class NonRfcComputerNameDialog : public Dialog
{
   public:

   explicit
   NonRfcComputerNameDialog(const String& computerName_);

   virtual ~NonRfcComputerNameDialog();

   enum ResultCode
   {
      CONTINUE,
      RENAME
   };
      
   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   String computerName;

   // not defined: no copying allowed

   NonRfcComputerNameDialog(const NonRfcComputerNameDialog&);
   const NonRfcComputerNameDialog& operator=(const NonRfcComputerNameDialog&);
};



#endif   // NONRFCCOMPUTERNAMEDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\nonrfccomputernamedialog.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// Dlg to inform user of a non-rfc computer name
//
// 18 Aug 2000 sburns


#include "headers.hxx"
#include "NonRfcComputerNameDialog.hpp"
#include "resource.h"



static const DWORD HELP_MAP[] =
{
   0, 0
};



NonRfcComputerNameDialog::NonRfcComputerNameDialog(
   const String& computerName_)
   :
   Dialog(IDD_NON_RFC_COMPUTER_NAME, HELP_MAP),
   computerName(computerName_)
{
   LOG_CTOR(NonRfcComputerNameDialog);
   ASSERT(!computerName.empty());
}



NonRfcComputerNameDialog::~NonRfcComputerNameDialog()
{
   LOG_DTOR(NonRfcComputerNameDialog);
}



bool
NonRfcComputerNameDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIdFrom,
   unsigned    code)
{
   switch (controlIdFrom)
   {
      case IDCANCEL:
      case IDC_CONTINUE:
      {
         if (code == BN_CLICKED)
         {
            Win::EndDialog(hwnd, CONTINUE);
            return true;
         }
         break;
      }
      case IDC_RENAME:
      {
         if (code == BN_CLICKED)
         {
            Win::EndDialog(hwnd, RENAME);
            return true;
         }
         break;
      }
      case IDC_SHOW_HELP:
      {
         if (code == BN_CLICKED)
         {
            Win::HtmlHelp(
               hwnd,
               L"DNSConcepts.chm",
               HH_DISPLAY_TOPIC, 
               reinterpret_cast<DWORD_PTR>(L"error_dcpromo.htm"));
            return true;
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



void
NonRfcComputerNameDialog::OnInit()
{
   LOG_FUNCTION(NonRfcComputerNameDialog::OnInit);

   String message =
      String::format(IDS_COMPUTER_NAME_NON_RFC, computerName.c_str());

   Win::SetDlgItemText(hwnd, IDC_TEXT, message);   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\nondomainnc.cpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// Non-domain Naming Context checking code
//
// 13 July 2000 sburns, from code supplied by jeffparh



#include "headers.hxx"
#include "state.hpp"
#include "resource.h"
#include "NonDomainNc.hpp"



#ifdef LOGGING_BUILD
   #define LOG_LDAP(msg, ldap) LOG(msg); LOG(String::format(L"LDAP error %1!ld!", (ldap)))
#else
   #define LOG_LDAP(msg, ldap)
#endif



HRESULT
LdapToHresult(int ldapError)
{
   // CODEWORK: I'm told that ldap_get_option for LDAP_OPT_SERVER_ERROR or
   // LDAP_OPT_SERVER_EXT_ERROR (or perhaps LDAP_OPT_ERROR_STRING?) will give
   // an error result with "higher fidelity"
   
   return Win32ToHresult(::LdapMapErrorToWin32(ldapError));
}



// provided by jeffparh

DWORD
IsLastReplicaOfNC(
    IN  LDAP *  hld,
    IN  LPWSTR  pszConfigNC,
    IN  LPWSTR  pszNC,
    IN  LPWSTR  pszNtdsDsaDN,
    OUT BOOL *  pfIsLastReplica
    )
/*++

Routine Description:

    Determine whether any DSAs other than that with DN pszNtdsDsaDN hold
    replicas of a particular NC.

Arguments:

    hld (IN) - LDAP handle to execute search with.
    
    pszConfigNC (IN) - DN of the config NC.  Used as a base for the search.
    
    pszNC (IN) - NC for which to check for other replicas.
    
    pszNtdsDsaDN (IN) - DN of the DSA object known to currently have a replica
        of the NC.  We are specifically looking for replicas *other than* this
        one.
        
    pfIsLastReplica (OUT) - On successful return, TRUE iff no DSAs hold replicas
        of pszNC other than that with DN pszNtdsDsaDN.

Return Values:

    Win error.

--*/
{
   LOG_FUNCTION2(IsLastReplicaOfNC, pszNC ? pszNC : L"(null)");
   ASSERT(hld);
   ASSERT(pszConfigNC);
   ASSERT(pszNC);
   ASSERT(pszNtdsDsaDN);
   ASSERT(pfIsLastReplica);

   if (
         !hld
      || !pszConfigNC
      || !pszNC
      || !pszNtdsDsaDN
      || !pfIsLastReplica)
   {
      return ERROR_INVALID_PARAMETER;
   }

    // Just checking for existence -- don't really want any attributes
    // returned.

    static LPWSTR rgpszDsaAttrsToRead[] = {
        L"__invalid_attribute_name__",
        NULL
    };

    static WCHAR szFilterFormat[]
        = L"(&(objectCategory=ntdsDsa)(hasMasterNCs=%ls)(!(distinguishedName=%ls)))";

   *pfIsLastReplica = TRUE;
   
    int                 ldStatus = 0;
    DWORD               err = 0;
    LDAPMessage *       pDsaResults = NULL;
    LDAPMessage *       pDsaEntry = NULL;
    size_t              cchFilter;
    PWSTR               pszFilter;
    LDAP_TIMEVAL        lTimeout = {3*60, 0};   // three minutes

   do
   {
        cchFilter = sizeof(szFilterFormat) / sizeof(*szFilterFormat)
                    + wcslen(pszNtdsDsaDN)
                    + wcslen(pszNC);

        pszFilter = (PWSTR) new BYTE[sizeof(WCHAR) * cchFilter];

        swprintf(pszFilter, szFilterFormat, pszNC, pszNtdsDsaDN);

        // Search config NC for any ntdsDsa object that hosts this NC other
        // than that with dn pszNtdsDsaDN.  Note that we cap the search at one
        // returned object -- we're not really trying to enumerate, just
        // checking for existence.

        ldStatus = ldap_search_ext_sW(hld, pszConfigNC, LDAP_SCOPE_SUBTREE,
                                      pszFilter, rgpszDsaAttrsToRead, 0,
                                      NULL, NULL, &lTimeout, 1, &pDsaResults);
        if (pDsaResults)
        {
            // Ignore any error (such as LDAP_SIZELIMIT_EXCEEDED) when the
            // search returns results.

            ldStatus = 0;
            
            pDsaEntry = ldap_first_entry(hld, pDsaResults);
            
            *pfIsLastReplica = (NULL == pDsaEntry);
        } else if (ldStatus)
        {
            // Search failed and returned no results.

            LOG_LDAP(L"Config NC search failed", ldStatus);
            break;
        } else
        {
            // No error, no results.  This shouldn't happen.

            LOG("ldap_search_ext_sW returned no results and no error!");
            ASSERT(false);
        }
   }
   while (0);

   if (NULL != pDsaResults) {
      ldap_msgfree(pDsaResults);
   }

   if (pszFilter)
   {
      delete[] pszFilter;
   }

   if (!err && ldStatus) {
     err = LdapMapErrorToWin32(ldStatus);
   }
    
   return err;
}



// S_OK if this machine (the localhost) is the last replica of at least one
// non-domain NC, S_FALSE if not, or error otherwise.  If S_OK, then the
// StringList will contain the DNs of the non domain NCs for which this
// machine is the last replica.
//
// based on code from jeffparh
//
// hld (IN) - LDAP handle bound to DSA to evaluate.
//
// result (OUT) - string list to receive DNs of the non-domain NCs.

HRESULT
IsLastNdncReplica(LDAP* hld, StringList& result)
{
   LOG_FUNCTION(IsLastNdncReplica);
   ASSERT(hld);
   ASSERT(result.empty());

   HRESULT      hr          = S_FALSE;
   LDAPMessage* rootResults = 0;      
   PWSTR*       configNc    = 0;      
   PWSTR*       schemaNc    = 0;      
   PWSTR*       domainNc    = 0;      
   PWSTR*       masterNcs   = 0;      
   PWSTR*       ntdsDsaDn   = 0;      

   do
   {
      // Gather basic rootDSE info.

      static PWSTR ROOT_ATTRS_TO_READ[] =
      {
         LDAP_OPATT_NAMING_CONTEXTS_W,
         LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W,
         LDAP_OPATT_CONFIG_NAMING_CONTEXT_W,
         LDAP_OPATT_SCHEMA_NAMING_CONTEXT_W,
         LDAP_OPATT_DS_SERVICE_NAME_W,
         0
      };

      LOG(L"Calling ldap_search_s");

      int ldStatus =
         ldap_search_sW(
            hld,
            0,
            LDAP_SCOPE_BASE,
            L"(objectClass=*)",
            ROOT_ATTRS_TO_READ,
            0,
            &rootResults);
      if (ldStatus)
      {
         LOG_LDAP(L"RootDSE search failed", ldStatus);
         hr = LdapToHresult(ldStatus);
         break;
      }

      configNc  = ldap_get_valuesW(hld, rootResults, LDAP_OPATT_CONFIG_NAMING_CONTEXT_W); 
      schemaNc  = ldap_get_valuesW(hld, rootResults, LDAP_OPATT_SCHEMA_NAMING_CONTEXT_W); 
      domainNc  = ldap_get_valuesW(hld, rootResults, LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W);
      masterNcs = ldap_get_valuesW(hld, rootResults, LDAP_OPATT_NAMING_CONTEXTS_W);       
      ntdsDsaDn = ldap_get_valuesW(hld, rootResults, LDAP_OPATT_DS_SERVICE_NAME_W);       

      if (
            (0 == configNc)
         || (0 == schemaNc)
         || (0 == domainNc)
         || (0 == masterNcs)
         || (0 == ntdsDsaDn))
      {
         LOG(L"Can't find key rootDSE attributes!");

         hr = Win32ToHresult(ERROR_DS_UNAVAILABLE);
         break;
      }

      // There is only one value for each of these attributes...

      ASSERT(1 == ldap_count_valuesW(configNc));
      ASSERT(1 == ldap_count_valuesW(schemaNc));
      ASSERT(1 == ldap_count_valuesW(domainNc));
      ASSERT(1 == ldap_count_valuesW(ntdsDsaDn));

      DWORD masterNcCount = ldap_count_valuesW(masterNcs);
      
      LOG(String::format(L"masterNcCount = %1!d!", masterNcCount));
         
      // '3' => 1 nc for config, 1 nc for schema, 1 nc for this DC's own
      // domain.

      if (masterNcCount <= 3)
      {
         // DSA holds no master NCs other than config, schema, and its own
         // domain.  Thus, it is not the last replica of any NDNC.

         LOG(L"This dsa holds no master NCs other than config, schema, and domain");
         
         ASSERT(3 == masterNcCount);
         ASSERT(0 == ldStatus);
         ASSERT(hr == S_FALSE);

         break;
      }

      // Loop through non-config/schema/domain NCs to determine those for
      // which the DSA is the last replica.

      for (int i = 0; 0 != masterNcs[i]; ++i)
      {
         PWSTR nc = masterNcs[i];

         LOG(L"Evaluating " + String(nc));

         if (
                (0 != wcscmp(nc, *configNc))
             && (0 != wcscmp(nc, *schemaNc))
             && (0 != wcscmp(nc, *domainNc)))
         {
            // A non-config/schema/domain NC.

            LOG(L"Calling IsLastReplicaOfNC on " + String(nc));

            BOOL isLastReplica = FALSE;
            DWORD err =
               IsLastReplicaOfNC(
                  hld,
                  *configNc,
                  nc,
                  *ntdsDsaDn,
                  &isLastReplica);
            if (err)
            {
               LOG(L"IsLastReplicaOfNC() failed");

               hr = Win32ToHresult(err);
               break;
            }

            if (isLastReplica)
            {
               // This DSA is indeed the last replica of this particular
               // NC.  Return the DN of this NC to our caller.

               LOG(L"last replica of " + String(nc));

               result.push_back(nc);
            }
            else
            {
               LOG(L"not last replica of " + String(nc));
            }
         }
      }

      // If we broke out of the prior loop with an error, jump out to the
      // cleanup section.

      BREAK_ON_FAILED_HRESULT(hr);

      hr = result.size() > 0 ? S_OK : S_FALSE;
   }
   while (0);

   if (rootResults)
   {
      ldap_msgfree(rootResults);
   }
   
   if (0 != configNc)
   {
      ldap_value_freeW(configNc);
   }

   if (0 != schemaNc)
   {
      ldap_value_freeW(schemaNc);
   }

   if (0 != domainNc)
   {
      ldap_value_freeW(domainNc);
   }

   if (0 != masterNcs)
   {
      ldap_value_freeW(masterNcs);
   }

   if (0 != ntdsDsaDn)
   {
      ldap_value_freeW(ntdsDsaDn);
   }

#ifdef LOGGING_BUILD
   LOG_HRESULT(hr);

   for (
      StringList::iterator i = result.begin();
      i != result.end();
      ++i)
   {
      LOG(*i);
   }
#endif

   return hr;
}



// S_OK if this machine (the localhost) is the last replica of at least one
// non-domain NC, S_FALSE if not, or error otherwise.
//
// result - If S_OK is returned, receives the DNs of the non domain NCs for
// which this machine is the last replica.  Should be empty on entry.

HRESULT
IsLastNonDomainNamingContextReplica(StringList& result)
{
   LOG_FUNCTION(IsLastNonDomainNamingContextReplica);
   ASSERT(result.empty());

   result.clear();

   HRESULT hr  = S_FALSE;
   LDAP*   hld = 0;   

   do
   {
      // Connect to target DSA.

      LOG(L"Calling ldap_open");

      hld = ldap_openW(L"localhost", LDAP_PORT);
      if (!hld)
      {
         LOG("Cannot open LDAP connection to localhost");
         hr = Win32ToHresult(ERROR_DS_UNAVAILABLE);
         break;
      }

      // Bind using logged-in user's credentials.

      int ldStatus = ldap_bind_s(hld, 0, 0, LDAP_AUTH_NEGOTIATE);
      if (ldStatus)
      {
         LOG_LDAP(L"LDAP bind failed", ldStatus);

         hr = LdapToHresult(ldStatus);
         break;
      }

      // go do the real work
          
      hr = IsLastNdncReplica(hld, result);
   }
   while (0);

   if (hld)
   {
      ldap_unbind(hld);
   }

   LOG_HRESULT(hr);

   return hr;
}



static const DWORD HELP_MAP[] =
{
   0, 0
};



NonDomainNcErrorDialog::NonDomainNcErrorDialog(StringList& ndncList_)
   :
   Dialog(IDD_NON_DOMAIN_NC_ERROR, HELP_MAP),
   ndncList(ndncList_),
   warnIcon(0)
{
   LOG_CTOR(NonDomainNcErrorDialog);

   ASSERT(ndncList.size());
}



NonDomainNcErrorDialog::~NonDomainNcErrorDialog()
{
   LOG_DTOR(NonDomainNcErrorDialog);

   if (warnIcon)
   {
      Win::DestroyIcon(warnIcon);
   }
}



void
NonDomainNcErrorDialog::OnInit()
{
   LOG_FUNCTION(NonDomainNcErrorDialog::OnInit);

   // set the warning icon NTRAID#NTBUG9-239678-2000/11/28-sburns
   
   HRESULT hr = Win::LoadImage(IDI_WARN, warnIcon);
   ASSERT(SUCCEEDED(hr));

   Win::SendMessage(
      Win::GetDlgItem(hwnd, IDC_WARNING_ICON),
      STM_SETICON,
      reinterpret_cast<WPARAM>(warnIcon),
      0);

   PopulateListView();
}



// Unwraps the safearray of variants inside a variant, extracts the strings
// inside them, and catenates the strings together with semicolons in between.
// Return empty string on error.
// 
// variant - in, the variant containing a safearray of variants of bstr.

String
GetNdncDescriptionHelper(VARIANT* variant)
{
   LOG_FUNCTION(GetNdncDescriptionHelper);
   ASSERT(variant);
   ASSERT(V_VT(variant) == (VT_ARRAY | VT_VARIANT));

   String result;

   SAFEARRAY* psa = V_ARRAY(variant);

   do
   {
      ASSERT(psa);
      ASSERT(psa != (SAFEARRAY*)-1);

      if (!psa or psa == (SAFEARRAY*)-1)
      {
         LOG(L"variant not safe array");
         break;
      }

      if (::SafeArrayGetDim(psa) != 1)
      {
         LOG(L"safe array: wrong number of dimensions");
         break;
      }

      VARTYPE vt = VT_EMPTY;
      HRESULT hr = ::SafeArrayGetVartype(psa, &vt);
      if (FAILED(hr) || vt != VT_VARIANT)
      {
         LOG(L"safe array: wrong element type");
         break;
      }

      long lower = 0;
      long upper = 0;
     
      hr = ::SafeArrayGetLBound(psa, 1, &lower);
      BREAK_ON_FAILED_HRESULT2(hr, L"can't get lower bound");      

      hr = ::SafeArrayGetUBound(psa, 1, &upper);
      BREAK_ON_FAILED_HRESULT2(hr, L"can't get upper bound");      
      
      VARIANT varItem;
      ::VariantInit(&varItem);

      for (long i = lower; i <= upper; ++i)
      {
         hr = ::SafeArrayGetElement(psa, &i, &varItem);
         if (FAILED(hr))
         {
            LOG(String::format(L"index %1!d! failed", i));
            continue;
         }

         result += V_BSTR(&varItem);

         if (i < upper)
         {   
            result += L";";
         }

         ::VariantClear(&varItem);
      }
      
   }
   while (0);

   LOG(result);
   
   return result;   
}



// bind to an ndnc, read it's description(s), and return them catenated
// together.  Return empty string on error.
// 
// ndncDn - in, DN of the ndnc

String
GetNdncDescription(const String& ndncDn)
{
   LOG_FUNCTION2(GetNdncDescription, ndncDn);
   ASSERT(!ndncDn.empty());

   String result;

   do
   {
      String path = L"LDAP://" + ndncDn;

      SmartInterface<IADs> iads(0);
      IADs* dumb = 0;
      
      HRESULT hr =
         ::ADsGetObject(
            path.c_str(),
            __uuidof(iads),
            reinterpret_cast<void**>(&dumb));
      BREAK_ON_FAILED_HRESULT2(hr, L"ADsGetObject failed on " + path);

      iads.Acquire(dumb);

      // description is a multivalued attrbute for no apparent good reason.
      // so we need to walk an array of values.
      
      _variant_t variant;
      hr = iads->GetEx(AutoBstr(L"description"), &variant);
      BREAK_ON_FAILED_HRESULT2(hr, L"read description failed");

      result = GetNdncDescriptionHelper(&variant);
   }
   while (0);

   LOG(result);

   return result;
}



// Build a list view with two columns, one for the DN of the ndncs for which
// this box is the last replica, another for the description(s) of those
// ndncs.

void
NonDomainNcErrorDialog::PopulateListView()
{
   LOG_FUNCTION(NonDomainNcErrorDialog::PopulateListView);

   HWND view = Win::GetDlgItem(hwnd, IDC_NDNC_LIST);

   // add a column to the list view for the DN
      
   LVCOLUMN column;
   ::ZeroMemory(&column, sizeof column);

   column.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
   column.fmt = LVCFMT_LEFT;

   int width = 0;
   String::load(IDS_NDNC_LIST_NAME_COLUMN_WIDTH).convert(width);
   column.cx = width;

   String label = String::load(IDS_NDNC_LIST_NAME_COLUMN);
   column.pszText = const_cast<wchar_t*>(label.c_str());

   Win::ListView_InsertColumn(view, 0, column);

   // add a column to the list view for description.

   String::load(IDS_NDNC_LIST_DESC_COLUMN_WIDTH).convert(width);
   column.cx = width;
   label = String::load(IDS_NDNC_LIST_DESC_COLUMN);
   column.pszText = const_cast<wchar_t*>(label.c_str());

   Win::ListView_InsertColumn(view, 1, column);
   
   // Load up the edit box with the DNs we aliased in the ctor.

   LVITEM item;
   ::ZeroMemory(&item, sizeof item);

   for (
      StringList::iterator i = ndncList.begin();
      i != ndncList.end();
      ++i)
   {
      item.mask     = LVIF_TEXT;
      item.pszText  = const_cast<wchar_t*>(i->c_str());
      item.iSubItem = 0;

      item.iItem = Win::ListView_InsertItem(view, item);

      // add the description sub-item to the list control

      String description = GetNdncDescription(*i);
      
      item.mask = LVIF_TEXT; 
      item.pszText = const_cast<wchar_t*>(description.c_str());
      item.iSubItem = 1;
      
      Win::ListView_SetItem(view, item);
   }
}



bool
NonDomainNcErrorDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(NonDomainNcErrorDialog::OnCommand);

   if (code == BN_CLICKED)
   {
      switch (controlIDFrom)
      {
         case IDOK:
         case IDCANCEL:
         {
            Win::EndDialog(hwnd, controlIDFrom);
            return true;
         }

         // NTRAID#NTBUG9-239678-2000/11/28-sburns
         
         case IDC_SHOW_HELP:
         {
            if (code == BN_CLICKED)
            {
               Win::HtmlHelp(
                  hwnd,
                  L"adconcepts.chm::/ADHelpDemoteWithNDNC.htm",
                  HH_DISPLAY_TOPIC,
                  0);
               return true;
            }
            break;
         }
         default:
         {
            // do nothing
         }
      }
   }

   return false;
}

      


bool
IsLastReplicaOfNonDomainNamingContexts()
{
   LOG_FUNCTION(IsLastReplicaOfNonDomainNamingContexts);

   bool result = false;

   do
   {
      State::RunContext context = State::GetInstance().GetRunContext();
      if (context != State::NT5_DC)
      {
         // not a DC, so can't be replica of any NCs

         LOG(L"not a DC");
         break;
      }

      // Find the list of non-domain NCs that this DC is the last replica
      // (if any).  If we find some, gripe at the user.

      StringList ndncList;
      HRESULT hr = IsLastNonDomainNamingContextReplica(ndncList);
      if (FAILED(hr))
      {
         popup.Error(
            Win::GetDesktopWindow(),
            hr,
            IDS_FAILED_TO_READ_NDNC_INFO);

         result = true;
         break;
      }

      if (hr == S_FALSE)
      {
         LOG(L"Not last replica of non-domain NCs");
         ASSERT(result == false);
         break;
      }

      result = true;
         
      // there should be at least one DN in the list.

      ASSERT(ndncList.size());

      NonDomainNcErrorDialog(ndncList).ModalExecute(Win::GetDesktopWindow());
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\page.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// dcpromo2 wizard base class
//
// 1-15-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "resource.h"
#include "state.hpp"



DCPromoWizardPage::DCPromoWizardPage(
   int   dialogResID,
   int   titleResID,
   int   subtitleResID,   
   bool  isInteriorPage)
   :
   WizardPage(dialogResID, titleResID, subtitleResID, isInteriorPage)
{
   LOG_CTOR(DCPromoWizardPage);
}

   

DCPromoWizardPage::~DCPromoWizardPage()
{
   LOG_DTOR(DCPromoWizardPage);
}



bool
DCPromoWizardPage::OnWizNext()
{
   LOG_FUNCTION(DCPromoWizardPage::OnWizNext);

   GetWizard().SetNextPageID(hwnd, Validate());
   return true;
}



bool
DCPromoWizardPage::OnQueryCancel()
{
   LOG_FUNCTION(DCPromoWizardPage::OnQueryCancel);

   State& state = State::GetInstance();

   int id = IDS_CONFIRM_CANCEL;
   switch (state.GetRunContext())
   {
      case State::BDC_UPGRADE:
      case State::PDC_UPGRADE:
      {
         id = IDS_CONFIRM_UPGRADE_CANCEL;
         break;
      }
      case State::NT5_DC:
      case State::NT5_STANDALONE_SERVER:
      case State::NT5_MEMBER_SERVER:
      default:
      {
         // do nothing
         break;
      }
   }

   Win::SetWindowLongPtr(
      hwnd,
      DWLP_MSGRESULT,
         (popup.MessageBox(hwnd, id, MB_YESNO | MB_DEFBUTTON2) == IDYES)
      ?  FALSE
      :  TRUE);

   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\page.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// dcpromo2 wizard base class
//
// 1-15-97 sburns



#ifndef PAGE_HPP_INCLUDED
#define PAGE_HPP_INCLUDED



class DCPromoWizardPage : public WizardPage
{
   public:

   virtual
   bool
   OnWizNext();

   protected:

   DCPromoWizardPage(
      int   dialogResID,
      int   titleResID,
      int   subtitleResID,   
      bool  isInteriorPage = true);

   virtual ~DCPromoWizardPage();

   // PropertyPage overrides

   virtual
   bool
   OnQueryCancel();

   virtual
   int
   Validate() = 0;

   private:

   // not defined: no copying allowed
   DCPromoWizardPage(const DCPromoWizardPage&);
   const DCPromoWizardPage& operator=(const DCPromoWizardPage&);
};



#endif   // PAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\paths2page.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// paths, part 2 page
//
// 1-8-97 sburns



#ifndef PATHS2PAGE_HPP_INCLUDED
#define PATHS2PAGE_HPP_INCLUDED



class Paths2Page : public DCPromoWizardPage
{
   public:

   Paths2Page();

   protected:

   virtual ~Paths2Page();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();

   // not defined; no copying allowed
   Paths2Page(const Paths2Page&);
   const Paths2Page& operator=(const Paths2Page&);

   bool touchWizButtons;
};



#endif   // PATHS2_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\pathspage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// paths page
//
// 12-22-97 sburns



#ifndef PATHSPAGE_HPP_INCLUDED
#define PATHSPAGE_HPP_INCLUDED



class PathsPage : public DCPromoWizardPage
{
   public:

   PathsPage();

   protected:

   virtual ~PathsPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();
   
   // not defined; no copying allowed

   PathsPage(const PathsPage&);
   const PathsPage& operator=(const PathsPage&);

   bool touchWizButtons;
};



#endif   // PATHSPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\picksitepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// pick site page
//
// 12-22-97 sburns



#ifndef PICKSITEPAGE_HPP_INCLUDED
#define PICKSITEPAGE_HPP_INCLUDED



class PickSitePage : public DCPromoWizardPage
{
   public:

   PickSitePage();

   protected:

   virtual ~PickSitePage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();

   // not defined; no copying allowed

   PickSitePage(const PickSitePage&);
   const PickSitePage& operator=(const PickSitePage&);
};



#endif   // PICKSITEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\pathspage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// paths page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "PathsPage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"



PathsPage::PathsPage()
   :
   DCPromoWizardPage(
      IDD_PATHS,
      IDS_PATHS_PAGE_TITLE,
      IDS_PATHS_PAGE_SUBTITLE),
   touchWizButtons(true)   
{
   LOG_CTOR(PathsPage);
}



PathsPage::~PathsPage()
{
   LOG_DTOR(PathsPage);
}



void
PathsPage::OnInit()
{
   LOG_FUNCTION(PathsPage::OnInit);

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_DB),  MAX_PATH);
   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_LOG), MAX_PATH);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_DB,
         Win::ExpandEnvironmentStrings(
            state.GetAnswerFileOption(State::OPTION_DATABASE_PATH)));
      Win::SetDlgItemText(
         hwnd,
         IDC_LOG,
         Win::ExpandEnvironmentStrings(
            state.GetAnswerFileOption(State::OPTION_LOG_PATH)));
   }

   String root = Win::GetSystemWindowsDirectory();
   if (Win::GetTrimmedDlgItemText(hwnd, IDC_DB).empty())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_DB,
         root + String::load(IDS_DB_SUFFIX));
   }
   if (Win::GetTrimmedDlgItemText(hwnd, IDC_LOG).empty())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_LOG,
         root + String::load(IDS_LOG_SUFFIX));
   }
}



void
PathsPage::Enable()
{
   // touchWizButtons is managed in the OnCommand handler for EN_KILLFOCUS.
   // Turns out that if you call PropSheet_SetWizButtons while handling a kill
   // focus event, you mess up the tab processing so that the focus jumps to
   // the default wizard button. That's really cool -- NOT!
   
   if (touchWizButtons)
   {
      int next =
            (  !Win::GetTrimmedDlgItemText(hwnd, IDC_DB).empty()
            && !Win::GetTrimmedDlgItemText(hwnd, IDC_LOG).empty() )
         ?  PSWIZB_NEXT : 0;

      Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), PSWIZB_BACK | next);
   }
}


   
bool
PathsPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIdFrom,
   unsigned    code)
{
//   LOG_FUNCTION(PathsPage::OnCommand);

   bool result = false;
   
   switch (controlIdFrom)
   {
      case IDC_BROWSE_DB:
      {
         if (code == BN_CLICKED)
         {
            String path = BrowseForFolder(hwnd, IDS_DB_BROWSE_TITLE);
            if (!path.empty())
            {
               Win::SetDlgItemText(hwnd, IDC_DB, path);
            }

            result = true;
         }
         break;
      }
      case IDC_BROWSE_LOG:
      {
         if (code == BN_CLICKED)
         {
            String path = BrowseForFolder(hwnd, IDS_LOG_BROWSE_TITLE);
            if (!path.empty())
            {
               Win::SetDlgItemText(hwnd, IDC_LOG, path);
            }

            result = true;
         }
         break;
      }
      case IDC_DB:
      case IDC_LOG:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               SetChanged(controlIdFrom);            
               Enable();
               result = true;
               
               break;
            }
            case EN_KILLFOCUS:
            {
               // Since the normalization fully-expands relative paths, the
               // full pathname may not match what the user entered.  So we
               // update the edit box contents to make sure they realize what
               // the relative path expands to.
               // NTRAID#NTBUG9-216148-2000/11/01-sburns

               String text = Win::GetTrimmedDlgItemText(hwnd, controlIdFrom);
               if (!text.empty())
               {
                  // turn off setting of wizard buttons so that the call to
                  // Enable made by the EN_CHANGE handler (which will be
                  // called when we set the edit box text) will not call
                  // PropSheet_SetWizButtons, which will mess up the tab
                  // processing.
               
                  touchWizButtons = false;
                  Win::SetDlgItemText(
                     hwnd,
                     controlIdFrom,
                     FS::NormalizePath(text));
                  touchWizButtons = true;
               }

               result = true;
               break;
            }
            default:
            {
               // do nothing

               break;
            }
         }
      
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return result;
}



bool
PathsPage::OnSetActive()
{
   LOG_FUNCTION(PathsPage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   Enable();
   return true;
}



int
PathsPage::Validate()
{
   LOG_FUNCTION(PathsPage::Validate);

   State& state = State::GetInstance();

   String dbPath  = FS::NormalizePath(Win::GetTrimmedDlgItemText(hwnd, IDC_DB)); 
   String logPath = FS::NormalizePath(Win::GetTrimmedDlgItemText(hwnd, IDC_LOG));

   // If you change these, make sure you change the low disk space messages in
   // the resource file!

   static const unsigned DB_MIN_SPACE_MB = 200;
   static const unsigned LOG_MIN_SPACE_MB = 50;

   int  nextPage = -1;    
   bool valid    = false; 
   int  editId   = IDC_DB;
   String message;
   do                                                      
   {
//       // if replicating from media, destination folders may not be the
//       // source path.
// 
//       if (state.ReplicateFromMedia())
//       {
//          String p = state.GetReplicationSourcePath();
//          if (p.icompare(dbPath) == 0)
//          {
//             message = String::format(IDS_DB_CANT_MATCH_SOURCE_PATH, dbPath.c_str());
//             break;
//          }
//       }

      if (ValidateDcInstallPath(dbPath, hwnd, IDC_DB))
      {
         // grab the "X:\" part of the path

         String dbVolume   = FS::GetRootFolder(dbPath);   
         String logVolume  = FS::GetRootFolder(logPath);  
         bool   sameVolume = (dbVolume.icompare(logVolume) == 0);

         if (
            !CheckDiskSpace(
               dbVolume,
               DB_MIN_SPACE_MB + (sameVolume ? LOG_MIN_SPACE_MB : 0)) )
         {
            message = String::load(IDS_LOW_SPACE_DB);
            break;
         }
         if (dbPath.icompare(logPath) != 0)
         {
            // the paths are different, so check the log path

            editId = IDC_LOG;
            if (ValidateDcInstallPath(logPath, hwnd, IDC_LOG))
            {
               if (!CheckDiskSpace(logVolume, LOG_MIN_SPACE_MB))
               {
                  message = String::load(IDS_LOW_SPACE_LOG);
                  break;
               }

               // if (state.ReplicateFromMedia())
               // {
               //    String p = state.GetReplicationSourcePath();
               //    if (p.icompare(logPath) == 0)
               //    {
               //       message =
               //          String::format(
               //             IDS_LOG_CANT_MATCH_SOURCE_PATH,
               //             logPath.c_str());
               //       break;
               //    }
               // }

               // paths differ, both are valid

               valid = true;
            }
         }
         else
         {
            // paths are the same, and we validated dbPath already

            valid = true;
         }
      }
   }
   while (0);

   if (!message.empty())
   {
      popup.Gripe(hwnd, editId, message);
   }
      
   if (valid)
   {         
      state.SetDatabasePath(dbPath);
      state.SetLogPath(logPath);
      nextPage = IDD_PATHS2;
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\picksitepage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// pick site page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "PickSitePage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"
#include "dns.hpp"



PickSitePage::PickSitePage()
   :
   DCPromoWizardPage(
      IDD_PICK_SITE,
      IDS_PICK_SITE_PAGE_TITLE,
      IDS_PICK_SITE_PAGE_SUBTITLE)
{
   LOG_CTOR(PickSitePage);
}



PickSitePage::~PickSitePage()
{
   LOG_DTOR(PickSitePage);
}



void
PickSitePage::OnInit()
{
   LOG_FUNCTION(PickSitePage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_SITE),
      Dns::MAX_LABEL_LENGTH);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_SITE,
         state.GetAnswerFileOption(State::OPTION_SITE_NAME));
   }
}



void
PickSitePage::Enable()
{
   int next =
         !Win::GetTrimmedDlgItemText(hwnd, IDC_SITE).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | next);
}


   
bool
PickSitePage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(PickSitePage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_SITE:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);            
            Enable();
            return true;
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



bool
PickSitePage::OnSetActive()
{
   LOG_FUNCTION(PickSitePage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   Wizard& wizard = GetWizard();

   if (wizard.IsBacktracking())
   {
      // backup once again
      wizard.Backtrack(hwnd);
   }
   else
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         wizard.SetNextPageID(hwnd, nextPage);
         return true;
      }
      else
      {
         State::GetInstance().ClearHiddenWhileUnattended();
      }
   }

   Enable();
   return true;
}



int
PickSitePage::Validate()
{
   LOG_FUNCTION(PickSitePage::Validate);

   State& state = State::GetInstance();
   ASSERT(state.IsDNSOnNetwork());

   int nextPage = IDD_RAS_FIXUP;
   String site = Win::GetTrimmedDlgItemText(hwnd, IDC_SITE);
   if (site.empty())
   {
      LOG(L"Site not specified.");
   }
   else
   {
      if (!ValidateSiteName(hwnd, IDC_SITE))
      {
         nextPage = -1;
      }
   }
   state.SetSiteName(Win::GetTrimmedDlgItemText(hwnd, IDC_SITE));

   if (nextPage != -1)
   {
      if (state.GetOperation() != State::REPLICA)
      {
         nextPage = IDD_DYNAMIC_DNS;
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\passwordeditbox.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// password edit control wrapper
//
// 6 Nov 2000 sburns
//
// added to fix NTRAID#NTBUG9-202238-2000/11/06-sburns
//
// most of this is stolen from johnstep's common cred ui
// ds/win32/credui



#include "headers.hxx"
#include "PasswordEditBox.hpp"
#include "ds.hpp"



PasswordEditBox::PasswordEditBox()
{
   LOG_CTOR(PasswordEditBox);
}



PasswordEditBox::~PasswordEditBox()
{
   LOG_DTOR(PasswordEditBox);
}



HRESULT
PasswordEditBox::Init(HWND editControl)
{
   LOG_FUNCTION(PasswordEditBox::Init);
   ASSERT(Win::GetClassName(editControl) == L"Edit");

//    By commenting out this code, we disable the subclassing and therefore
//    the caps lock warning bubble.  We do this because it appears that the
//    edit box common control now offers that same functionality.
//    NTRAID#NTBUG9-255537-2000/12/12-sburns to disable the code
//    NTRAID#NTBUG9-255568-2000/12/12-sburns to remove the code from the source
//    tree entirely.
//    
//    HRESULT hr = ControlSubclasser::Init(editControl);
//    if (SUCCEEDED(hr))
//    {
//       // set the options on the edit control
//       
//       Win::Edit_LimitText(hwnd, DS::MAX_PASSWORD_LENGTH);
// 
//       // (could also set the password style bit here, if we wanted.)
// 
//       balloonTip.Init(hwnd);
//    }
// 
//    return hr;

   return S_OK;
}



bool
IsCapsLockOn()
{
//   LOG_FUNCTION(IsCapsLockOn);

   return (::GetKeyState(VK_CAPITAL) & 1) ? true : false;
}



LRESULT
PasswordEditBox::OnMessage(UINT message, WPARAM wparam, LPARAM lparam)
{
   // LOG_FUNCTION(PasswordEditBox::OnMessage);

   switch (message)
   {
      case WM_KEYDOWN:
      {

		  if (wparam == VK_CAPITAL)
         {
            // user pressed caps lock key

            balloonTip.Show(IsCapsLockOn());
         }
         else
         {
            // they hit some other key, so get rid of the tool tip
            
            balloonTip.Show(false);
         }

         break;
      }
      case WM_SETFOCUS:
      {
        // Make sure no one can steal the focus while a user is entering their
        // password

        ::LockSetForegroundWindow(LSFW_LOCK);

        balloonTip.Show(IsCapsLockOn());
       
        break;
      }
      case WM_PASTE:
      {
         balloonTip.Show(false);
         break;
      }
      case WM_KILLFOCUS:
      {
         balloonTip.Show(false);
         
        // Make sure other processes can set foreground window once again.

        ::LockSetForegroundWindow(LSFW_UNLOCK);

        break;
      }
   }

   return ControlSubclasser::OnMessage(message, wparam, lparam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\postop.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Post-operation code
//
// 1 Dec 1999 sburns



#include "headers.hxx"
#include "ProgressDialog.hpp"
#include "state.hpp"
#include "shortcut.hpp"
#include "dnssetup.hpp"
#include "resource.h"



void
InstallDisplaySpecifiers(ProgressDialog& dialog)
{
   LOG_FUNCTION(InstallDisplaySpecifiers);

   State& state = State::GetInstance();

   // applies only to 1st dc in forest
   ASSERT(state.GetOperation() == State::FOREST);
 
   HRESULT hr = S_OK;
   do
   {
      // install display specifiers for all locales supported by the
      // product.  298923, 380160

      RegistryKey key;

      hr = key.Create(HKEY_LOCAL_MACHINE, REGSTR_PATH_RUNONCE);
      BREAK_ON_FAILED_HRESULT(hr);

      String exePath = Win::GetSystemDirectory() + L"\\dcphelp.exe";
               
      hr = key.SetValue(L"dcpromo disp spec import", exePath);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         dialog.GetHWND(),
         hr,
         IDS_LANGUAGE_FIXUP_FAILED);
      state.AddFinishMessage(
         String::load(IDS_LANGUAGE_FIXUP_FAILED_FINISH));
   }
}



void
DoDnsConfiguration(ProgressDialog& dialog)
{
   LOG_FUNCTION(DoDnsConfiguration);

   State& state = State::GetInstance();

   // applies only in new domain scenarios
   ASSERT(
         state.GetOperation() == State::FOREST
      or state.GetOperation() == State::TREE
      or state.GetOperation() == State::CHILD);

   if (state.ShouldInstallAndConfigureDns())
   {
      String domain = state.GetNewDomainDNSName();
      if (!InstallAndConfigureDns(dialog, domain))
      {
         state.AddFinishMessage(String::load(IDS_ERROR_DNS_CONFIG_FAILED));
      }
   }
}



// Disables media sense so that the tcp/ip stack doesn't unload if the
// net card is yanked.  This to allow laptop demos of the DS.  353687

void
DisableMediaSense()
{
   LOG_FUNCTION(DisableMediaSense);

   HRESULT hr = S_OK;
   do
   {
      RegistryKey key;

      static String
         TCPIP_KEY(L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters");
      hr = key.Create(HKEY_LOCAL_MACHINE, TCPIP_KEY);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = key.SetValue(L"DisableDHCPMediaSense", 1);
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"DHCP Media sense disabled");
   }
   while (0);

#ifdef LOGGING_BUILD
   if (FAILED(hr))
   {
      LOG(L"DHCP Media sense NOT disabled");
   }
#endif

}
   


// Disables an old LSA notification thing. 326033

void
DisablePassfiltDll()
{
   LOG_FUNCTION(DisablePassfiltDll);

   HRESULT hr = S_OK;
   do
   {
      RegistryKey key;

      static String
         LSA_KEY(L"System\\CurrentControlSet\\Control\\Lsa");
      hr =
         key.Open(
            HKEY_LOCAL_MACHINE,
            LSA_KEY,
            KEY_READ | KEY_WRITE | KEY_QUERY_VALUE);
      BREAK_ON_FAILED_HRESULT(hr);

      StringList values;
      hr = key.GetValue(L"Notification Packages", std::back_inserter(values));
      BREAK_ON_FAILED_HRESULT(hr);

      // remove all instances of "passfilt.dll" from the set of strings, if
      // present.  
      static String PASSFILT(L"passfilt.dll");
      size_t startElements = values.size();

      StringList::iterator last = values.end();
      for (
         StringList::iterator i = values.begin();
         i != last;
         /* empty */ )
      {
         if (i->icompare(PASSFILT) == 0)
         {
            values.erase(i++);
         }
         else
         {
            ++i;
         }
      }

      // if changed, write it back to the registry
      if (values.size() != startElements)
      {
         hr =
            key.SetValue(
               L"Notification Packages",
               values.begin(),
               values.end());
         BREAK_ON_FAILED_HRESULT(hr);

         LOG(L"passfilt.dll removed");
      }
      else
      {
         LOG(L"passfilt.dll not found");
      }
   }
   while (0);

#ifdef LOGGING_BUILD
   if (FAILED(hr))
   {
      LOG(L"Notification Packages not updated due to error.");
   }
#endif

}



// If the promotion was for a downlevel DC upgrade, then check if the local
// machine's dns hostname is bad, if so, add a message to the finish page.  A
// bad name is one we believe will have problems being registered in DNS after
// a promotion.
// 
// Since the computer cannot be renamed during a downlevel upgrade, we defer
// this message til the end of the upgrade.  (If the machine is not a
// downlevel upgrade, then the wizard startup code detects the bad name and
// blocks until the name is fixed.

void
CheckComputerNameOnDownlevelUpgrade()
{
   LOG_FUNCTION(CheckComputerNameOnDownlevelUpgrade);

   State& state = State::GetInstance();

   State::RunContext context = state.GetRunContext();
   if (
         context != State::BDC_UPGRADE
      && context != State::PDC_UPGRADE)
   {
      // machine is not a downlevel DC upgrade, so we need do nothing

      return;
   }
   
   // Then check the computer name to ensure that it can be registered in
   // DNS.

   String hostname =
      Win::GetComputerNameEx(::ComputerNamePhysicalDnsHostname);

   DNS_STATUS status =
      MyDnsValidateName(hostname, ::DnsNameHostnameLabel);

   switch (status)
   {
      case DNS_ERROR_NON_RFC_NAME:
      {
         state.AddFinishMessage(
            String::format(
               IDS_FINISH_NON_RFC_COMPUTER_NAME,
               hostname.c_str()));
         break;   
      }
      case DNS_ERROR_NUMERIC_NAME:
      {
         state.AddFinishMessage(
            String::format(
               IDS_FINISH_NUMERIC_COMPUTER_NAME,
               hostname.c_str()));
         break;
      }
      case DNS_ERROR_INVALID_NAME_CHAR:
      case ERROR_INVALID_NAME:
      {
         state.AddFinishMessage(
            String::format(
               IDS_FINISH_BAD_COMPUTER_NAME,
               hostname.c_str()));
         break;
      }
      case ERROR_SUCCESS:
      default:
      {
            
         break;
      }
   }
}



void
DoPostOperationStuff(ProgressDialog& progress)
{
   LOG_FUNCTION(DoPostOperationStuff);

   State& state = State::GetInstance();                  

   switch (state.GetOperation())
   {
      case State::FOREST:
      {
         // a new forest has been created

         InstallDisplaySpecifiers(progress);       // 228682

         // fall-thru
      }
      case State::TREE:
      case State::CHILD:
      {
         // a new domain has been created

         DoDnsConfiguration(progress);

         // fall-thru
      }
      case State::REPLICA:
      {
         // DoToolsInstallation(progress);   // 220660

         PromoteConfigureToolShortcuts(progress);

         DisableMediaSense();             // 353687
         DisablePassfiltDll();            // 326033
         
         // NTRAID#NTBUG9-268715-2001/01/04-sburns
         CheckComputerNameOnDownlevelUpgrade(); 
         
         break;
      }
      case State::ABORT_BDC_UPGRADE:
      case State::DEMOTE:
      {
         DemoteConfigureToolShortcuts(progress);   // 366738
         break;
      }
      case State::NONE:
      {
         ASSERT(false);
         break;
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\paths2page.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// paths, part 2 page
//
// 1-8-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "Paths2Page.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"



Paths2Page::Paths2Page()
   :
   DCPromoWizardPage(
      IDD_PATHS2,
      IDS_PATHS2_PAGE_TITLE,
      IDS_PATHS2_PAGE_SUBTITLE),
   touchWizButtons(true)   
{
   LOG_CTOR(Paths2Page);
}



Paths2Page::~Paths2Page()
{
   LOG_DTOR(Paths2Page);
}



String
DetermineDefaultSysvolPath()
{
   LOG_FUNCTION(DetermineDefaultSysvolPath);

   // prefer windir, but if that's not ntfs 5, find one that is.

   String result = Win::GetSystemWindowsDirectory();

   if (FS::GetFileSystemType(result) != FS::NTFS5)
   {
      result = GetFirstNtfs5HardDrive();
   }
   else
   {
      result += L"\\";
   }

   LOG(result);

   return result;
}



void
Paths2Page::OnInit()
{
   LOG_FUNCTION(Paths2Page::OnInit);

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_SYSVOL), MAX_PATH);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_SYSVOL,
         Win::ExpandEnvironmentStrings(
            state.GetAnswerFileOption(State::OPTION_SYSVOL_PATH)));
   }

   String root = DetermineDefaultSysvolPath();
   if (Win::GetTrimmedDlgItemText(hwnd, IDC_SYSVOL).empty())
   {
      Win::SetDlgItemText(
         hwnd,
         IDC_SYSVOL,
         root + String::load(IDS_SYSVOL_SUFFIX));
   }
}



void
Paths2Page::Enable()
{
   // touchWizButtons is managed in the OnCommand handler for EN_KILLFOCUS.
   // Turns out that if you call PropSheet_SetWizButtons while handling a kill
   // focus event, you mess up the tab processing so that the focus jumps to
   // the default wizard button. That's really cool -- NOT!
   
   if (touchWizButtons)
   {
      int next =
            !Win::GetTrimmedDlgItemText(hwnd, IDC_SYSVOL).empty()
         ?  PSWIZB_NEXT : 0;

      Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), PSWIZB_BACK | next);
   }
}


   
bool
Paths2Page::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIdFrom,
   unsigned    code)
{
//   LOG_FUNCTION(Paths2Page::OnCommand);

   bool result = false;
   
   switch (controlIdFrom)
   {
      case IDC_BROWSE:
      {
         if (code == BN_CLICKED)
         {
            String path = BrowseForFolder(hwnd, IDS_SYSVOL_BROWSE_TITLE);
            if (!path.empty())
            {
               Win::SetDlgItemText(hwnd, IDC_SYSVOL, path);
            }

            result = true;
         }
         break;
      }
      case IDC_SYSVOL:
      {
         switch (code)
         {
            case EN_CHANGE:
            {
               SetChanged(controlIdFrom);            
               Enable();
               result = true;
            
               break;
            }
            case EN_KILLFOCUS:
            {
               // Since the normalization fully-expands relative paths, the
               // full pathname may not match what the user entered.  So we
               // update the edit box contents to make sure they realize what
               // the relative path expands to.
               // NTRAID#NTBUG9-216148-2000/11/01-sburns

               String text = Win::GetTrimmedDlgItemText(hwnd, controlIdFrom);
               if (!text.empty())
               {
                  // turn off setting of wizard buttons so that the call to
                  // Enable made by the EN_CHANGE handler (which will be
                  // called when we set the edit box text) will not call
                  // PropSheet_SetWizButtons, which will mess up the tab
                  // processing.
               
                  touchWizButtons = false;
                  Win::SetDlgItemText(
                     hwnd,
                     controlIdFrom,
                     FS::NormalizePath(text));
                  touchWizButtons = true;
               }

               result = true;
               break;
            }
            default:
            {
               // do nothing

               break;
            }
         }
      
         break;
      }
      default:
      {
         // do nothing
         
         break;
      }
   }

   return false;
}



bool
Paths2Page::OnSetActive()
{
   LOG_FUNCTION(Paths2Page::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   Enable();
   return true;
}



// returns true if the path is valid, false if not.  Pesters the user on
// validation failures.

bool
ValidateSYSVOLPath(const String& path, HWND parent, unsigned editResID)
{
   LOG_FUNCTION(validateSysvolPath);
   ASSERT(Win::IsWindow(parent));
   ASSERT(!path.empty());

   // check that the path is not the same as the database or log paths
   // previously entered.  313059

   State& state = State::GetInstance();
   String db = state.GetDatabasePath();
   if (db.icompare(path) == 0)
   {
      popup.Gripe(
         parent,
         editResID,
         String::format(IDS_SYSVOL_CANT_MATCH_DB, db.c_str()));
      return false;
   }

   String log = state.GetLogPath();
   if (log.icompare(path) == 0)
   {
      popup.Gripe(
         parent,
         editResID,
         String::format(IDS_SYSVOL_CANT_MATCH_LOG, log.c_str()));
      return false;
   }

   // check that the path is not a parent folder of the database or log
   // paths previously entered. 320685

   if (FS::IsParentFolder(path, db))
   {
      popup.Gripe(
         parent,
         editResID,
         String::format(IDS_SYSVOL_CANT_BE_DB_PARENT, db.c_str()));
      return false;
   }

   if (FS::IsParentFolder(path, log))
   {
      popup.Gripe(
         parent,
         editResID,
         String::format(IDS_SYSVOL_CANT_BE_LOG_PARENT, log.c_str()));
      return false;
   }

//    // if replicating from media, destination sysvol folder may not be any
//    // of the source paths.
// 
//    if (state.ReplicateFromMedia())
//    {
//       String p = state.GetReplicationSourcePath();
//       if (p.icompare(path) == 0)
//       {
//          popup.Gripe(
//             parent,
//             editResID,
//             String::format(IDS_SYSVOL_CANT_MATCH_SOURCE_PATH, p.c_str()));
//          return false;
//       }
//    }

   // if you change this, change the error message resource too.

   static const unsigned SYSVOL_MIN_SPACE_MB = 100;

   if (!CheckDiskSpace(path, SYSVOL_MIN_SPACE_MB))
   {
      popup.Gripe(
         parent,
         editResID,
         String::format(IDS_SYSVOL_LOW_SPACE, log.c_str()));
      return false;
   }

   return true;
}
      


int
Paths2Page::Validate()
{
   LOG_FUNCTION(Paths2Page::Validate);

   int nextPage = -1;
   String path =
      FS::NormalizePath(Win::GetTrimmedDlgItemText(hwnd, IDC_SYSVOL));
   if (
         ValidateDcInstallPath(path, hwnd, IDC_SYSVOL, true)
      && ValidateSYSVOLPath(path, hwnd, IDC_SYSVOL) )
   {
      State& state = State::GetInstance();
      state.SetSYSVOLPath(path);
      if (state.GetOperation() == State::FOREST)
      {
         nextPage = IDD_NEW_SITE;
      }
      else
      {
         nextPage = IDD_PICK_SITE;
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\postop.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Post-operation code
//
// 1 Dec 1999 sburns



#ifndef POSTOP_HPP_INCLUDED
#define POSTOP_HPP_INCLUDED



void
DoPostOperationStuff(ProgressDialog& progress);



#endif   // POSTOP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\rasfixup.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// downlevel RAS server fixup page
//
// 11-23-98 sburns



#ifndef RASFIXUP_HPP_INCLUDED
#define RASFIXUP_HPP_INCLUDED



#include "page.hpp"



class RASFixupPage : public DCPromoWizardPage
{
   public:

   RASFixupPage();

   protected:

   virtual ~RASFixupPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   RASFixupPage(const RASFixupPage&);
   const RASFixupPage& operator=(const RASFixupPage&);

   HICON warnIcon;
};



#endif   // RASFIXUP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\progressdialog.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Dialog to display promotion progress
//
// 12-29-97 sburns



#include "headers.hxx"
#include "ProgressDialog.hpp"
#include "indicate.hpp"
#include "resource.h"



const UINT ProgressDialog::THREAD_SUCCEEDED = WM_USER + 999; 
const UINT ProgressDialog::THREAD_FAILED    = WM_USER + 1000;

// this string must match that in the CLASS specification of the
// dialog template in the .rc file!
static TCHAR PROGRESS_DIALOG_CLASS_NAME[] = L"dcpromo_progress";


static const DWORD HELP_MAP[] =
{
   0, 0
};



struct WrapperThreadProcParams
{
   ProgressDialog*             dialog;
   ProgressDialog::ThreadProc  realProc;
};



void _cdecl
wrapperThreadProc(void* p)
{
   ASSERT(p);

   WrapperThreadProcParams* params =
      reinterpret_cast<WrapperThreadProcParams*>(p);
   ASSERT(params->dialog);
   ASSERT(params->realProc);

   params->realProc(*(params->dialog));
}
   


ProgressDialog::ProgressDialog(
   ThreadProc   threadProc_,
   int          animationResId_)
   :
   Dialog(IDD_PROGRESS, HELP_MAP),
   animationResId(animationResId_),
   threadProc(threadProc_),
   threadParams(0),
   buttonEventHandle(0)
{
   LOG_CTOR(ProgressDialog);
   ASSERT(threadProc);
   ASSERT(animationResId > 0);

   // we subclass the window so we can change the cursor to the wait cursor

   WNDCLASSEX wndclass;
   memset(&wndclass, 0, sizeof(wndclass));

   static const wchar_t* DIALOG_WINDOW_CLASS_NAME = L"#32770";

   HRESULT hr = Win::GetClassInfoEx(DIALOG_WINDOW_CLASS_NAME, wndclass);
   ASSERT(SUCCEEDED(hr));

   wndclass.lpfnWndProc = ::DefDlgProc;
   wndclass.hInstance = Win::GetModuleHandle();
   wndclass.lpszClassName = PROGRESS_DIALOG_CLASS_NAME;

   hr = Win::LoadCursor(IDC_WAIT, wndclass.hCursor);
   ASSERT(SUCCEEDED(hr));

   ATOM unused = 0;
   hr = Win::RegisterClassEx(wndclass, unused);
   ASSERT(SUCCEEDED(hr));

   hr = Win::CreateEvent(0, false, false, buttonEventHandle);
   ASSERT(SUCCEEDED(hr));
}



ProgressDialog::~ProgressDialog()
{
   LOG_DTOR(ProgressDialog);

   delete threadParams;

   Win::UnregisterClass(PROGRESS_DIALOG_CLASS_NAME, Win::GetModuleHandle());
}


   
void
ProgressDialog::UpdateText(const String& message)
{
   LOG_FUNCTION2(ProgressDialog::UpdateText, message);

   Win::ShowWindow(
      Win::GetDlgItem(hwnd, IDC_MESSAGE),
      message.empty() ? SW_HIDE : SW_SHOW);
   Win::SetDlgItemText(hwnd, IDC_MESSAGE, message);
}



void
ProgressDialog::UpdateText(int textStringResID)
{
   LOG_FUNCTION(ProgressDialog::UpdateText);   
   ASSERT(textStringResID > 0);

   UpdateText(String::load(textStringResID));
}



void
ProgressDialog::UpdateButton(int textStringResID)
{
   LOG_FUNCTION(ProgressDialog::UpdateButton);
   ASSERT(textStringResID > 0);

   UpdateButton(String::load(textStringResID));
}



void
ProgressDialog::UpdateButton(const String& text)
{
   LOG_FUNCTION2(ProgressDialog::UpdateButton, text);   
   HWND button = Win::GetDlgItem(hwnd, IDC_BUTTON);

   DWORD waitResult = WAIT_FAILED;
   HRESULT hr = Win::WaitForSingleObject(buttonEventHandle, 0, waitResult);

   ASSERT(SUCCEEDED(hr));

   if (waitResult == WAIT_OBJECT_0)
   {
      // event is still signalled, so reset it.

      Win::ResetEvent(buttonEventHandle);
   }
      
   bool empty = text.empty();

   // Hide the button before we adjust the geometry.  On slow or heavily
   // loaded machines, the repaints show a noticable delay that has frightened
   // at least one user.
   // NTRAID#NTBUG9-353799-2001/04/05-sburns

   Win::ShowWindow(button, SW_HIDE);
   Win::EnableWindow(button, false);

   if (empty)
   {
      // leave the button hidden and disabled.
      
      return;
   }

   // resize and recenter the button

   RECT buttonRect;
   Win::GetWindowRect(button, buttonRect);
   Win::ScreenToClient(hwnd, buttonRect);

   HDC hdc = GetWindowDC(button);
   SIZE textExtent;
   Win::GetTextExtentPoint32(hdc, text, textExtent);
   Win::ReleaseDC(button, hdc);

   // add a bit of whitespace to the button label
   // NTRAID#NTBUG9-40855-2001/02/28-sburns

   textExtent.cx += 40;   

   RECT dialogRect;
   hr = Win::GetClientRect(hwnd, dialogRect);

   ASSERT(SUCCEEDED(hr));

   Win::MoveWindow(
      button,
         dialogRect.left
      +  (dialogRect.right - dialogRect.left - textExtent.cx)
      /  2,
      buttonRect.top,  
      textExtent.cx, 
      buttonRect.bottom - buttonRect.top,
      true);

   // display the button only after we have adjusted it's geometry

   Win::SetDlgItemText(hwnd, IDC_BUTTON, text);
   Win::ShowWindow(button, SW_SHOW);
   Win::EnableWindow(button, true);
}   



void
ProgressDialog::OnDestroy()
{
   LOG_FUNCTION(ProgressDialog::OnDestroy);

   // we don't delete things here, as a WM_DESTROY message may never be sent
}



void
ProgressDialog::OnInit()
{
   LOG_FUNCTION(ProgressDialog::OnInit);

   Win::Animate_Open(
      Win::GetDlgItem(hwnd, IDC_ANIMATION),
      MAKEINTRESOURCE(animationResId));

   UpdateText(String());
   UpdateButton(String());

   // deleted in the dtor, not in the wrapperThreadProc, in case the
   // wrapperThreadProc terminates abnormally.

   threadParams           = new WrapperThreadProcParams;
   threadParams->dialog   = this;      
   threadParams->realProc = threadProc;

   _beginthread(wrapperThreadProc, 0, threadParams);
}



bool
ProgressDialog::OnCommand(
   HWND        windowFrom,
   unsigned    controlIDFrom,
   unsigned    code)
{
   if (code == BN_CLICKED)
   {
      switch (controlIDFrom)
      {
         case IDC_BUTTON:
         {
            LOG(L"ProgressDialog::OnCommand -- cancel button pressed");
            
            // Since the response to the button press may be some time
            // coming, disable the button to prevent the user from pressing
            // it over and over in a frantic panic.

            Win::EnableWindow(windowFrom, false);
            Win::SetEvent(buttonEventHandle);
            break;
         }
         default:
         {
            // do nothing
         }
      }
   }

   return false;
}



bool
ProgressDialog::OnMessage(
   UINT     message,
   WPARAM   /* wparam */ ,
   LPARAM   /* lparam */ )
{
//   LOG_FUNCTION(ProgressDialog::OnMessage);

   switch (message)
   {
      case THREAD_SUCCEEDED:
      {
         Win::Animate_Stop(Win::GetDlgItem(hwnd, IDC_ANIMATION));
         UpdateText(String::load(IDS_OPERATION_DONE));

         HRESULT unused = Win::EndDialog(hwnd, THREAD_SUCCEEDED);

         ASSERT(SUCCEEDED(unused));

         return true;
      }
      case THREAD_FAILED:
      {
         Win::Animate_Stop(Win::GetDlgItem(hwnd, IDC_ANIMATION));         
         UpdateText(String::load(IDS_OPERATION_TERMINATED));

         HRESULT unused = Win::EndDialog(hwnd, THREAD_FAILED);

         ASSERT(SUCCEEDED(unused));

         return true;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



ProgressDialog::WaitCode
ProgressDialog::WaitForButton(int timeoutMillis)
{
//   LOG_FUNCTION(ProgressDialog::WaitForButton);

   DWORD result = WAIT_FAILED;
   HRESULT hr =
      Win::WaitForSingleObject(buttonEventHandle, timeoutMillis, result);

   ASSERT(SUCCEEDED(hr));

   switch (result)
   {
      case WAIT_OBJECT_0:
      {
         return PRESSED;
      }
      case WAIT_TIMEOUT:
      {
         return TIMEOUT;
      }
      case WAIT_FAILED:
      {
         // we squeltch the failure, and equate it to timeout
         // fall thru
      }
      default:
      {
         ASSERT(false);
      }
   }

   return TIMEOUT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\progressdialog.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Dialog to display promotion progress
//
// 12-29-97 sburns



#ifndef PROGRESSDIALOG_HPP_INCLUDED
#define PROGRESSDIALOG_HPP_INCLUDED


                    
class ProgressDialog : public Dialog
{
   public:

   // one of these is returned from ModalExecute
   static const UINT THREAD_SUCCEEDED;
   static const UINT THREAD_FAILED;

   typedef void (*ThreadProc) (ProgressDialog& dialog);

   // threadProc - pointer to a thread procedure that will be started when
   // the dialog is initialized (OnInit).  The procedure will be passed a
   // pointer to this instance.
   //
   // animationResID - resource ID of the AVI resource to be played while
   // the dialog is shown.

   ProgressDialog(
      ThreadProc   threadProc,
      int          animationResID);

   virtual ~ProgressDialog();

   void
   UpdateText(const String& message);

   void
   UpdateText(int textStringResID);

   void
   UpdateButton(const String& text);

   void
   UpdateButton(int textStringResID);

   enum WaitCode
   {
      PRESSED = 0,
      TIMEOUT = WAIT_TIMEOUT
   };

   // blocks calling thread until the button is pressed or the timeout
   // expires.

   WaitCode
   WaitForButton(int timeoutMillis);

   private:

   // Dialog overrides

   virtual
   void
   OnDestroy();

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   virtual
   bool
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   ThreadProc                       threadProc;
   int                              animationResId;
   struct WrapperThreadProcParams*  threadParams;
   HANDLE                           buttonEventHandle;

   // not defined: no copying allowed

   ProgressDialog(const ProgressDialog&);
   const ProgressDialog& operator=(const ProgressDialog&);
};



#endif   // PROGRESSDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\rebootdialog.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Dlg to confirm reboot
//
// 12-12-97 sburns



#include "headers.hxx"
#include "RebootDialog.hpp"
#include "resource.h"



static const DWORD HELP_MAP[] =
{
   0, 0
};



RebootDialog::RebootDialog(bool forFailure)
   :
   Dialog(
      forFailure ? IDD_REBOOT_FAILURE : IDD_REBOOT,
      HELP_MAP)
{
   LOG_CTOR(RebootDialog);
}



RebootDialog::~RebootDialog()
{
   LOG_DTOR(RebootDialog);
}



bool
RebootDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(RebootDialog::OnCommand);

   if (code == BN_CLICKED)
   {
      switch (controlIDFrom)
      {
         case IDC_RESTART_NOW:
         {
            HRESULT unused = Win::EndDialog(hwnd, 1);

            ASSERT(SUCCEEDED(unused));

            return true;
         }
         case IDCANCEL:
         case IDC_RESTART_LATER:
         {
            HRESULT unused = Win::EndDialog(hwnd, 0);

            ASSERT(SUCCEEDED(unused));

            return true;
         }
         default:
         {
            // do nothing
         }
      }
   }

   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\rebootdialog.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// Dlg to confirm reboot
//
// 12-12-97 sburns



#ifndef REBOOTDIALOG_HPP_INCLUDED
#define REBOOTDIALOG_HPP_INCLUDED


                        
class RebootDialog : public Dialog
{
   public:


   
   // forFailure - true if a reboot is needed but the operation failed anyway.
   
   RebootDialog(bool forFailure);


   
   virtual ~RebootDialog();


   
   private:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   // not defined: no copying allowed

   RebootDialog(const RebootDialog&);
   const RebootDialog& operator=(const RebootDialog&);
};



#endif   // REBOOTDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\replicaormemberpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// replica or member server page
//
// 12-16-97 sburns



#ifndef REPLMEM_HPP_INCLUDED
#define REPLMEM_HPP_INCLUDED



#include "page.hpp"



class ReplicaOrMemberPage : public DCPromoWizardPage
{
   public:

   ReplicaOrMemberPage();

   protected:

   virtual ~ReplicaOrMemberPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   ReplicaOrMemberPage(const ReplicaOrMemberPage&);
   const ReplicaOrMemberPage& operator=(const ReplicaOrMemberPage&);
};



#endif   // REPLMEM_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\rasfixup.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// downlevel RAS server fixup page
//
// 11-23-98 sburns



#include "headers.hxx"
#include "rasfixup.hpp"
#include "resource.h"
#include "state.hpp"



RASFixupPage::RASFixupPage()
   :
   DCPromoWizardPage(
      IDD_RAS_FIXUP,
      IDS_RAS_FIXUP_PAGE_TITLE,
      IDS_RAS_FIXUP_PAGE_SUBTITLE),
   warnIcon(0)
{
   LOG_CTOR(RASFixupPage);
}



RASFixupPage::~RASFixupPage()
{
   LOG_DTOR(RASFixupPage);

   if (warnIcon)
   {
      Win::DestroyIcon(warnIcon);
   }
}



void
RASFixupPage::OnInit()
{
   LOG_FUNCTION(RASFixupPage::OnInit);

   HRESULT hr = Win::LoadImage(IDI_WARN, warnIcon);
   ASSERT(SUCCEEDED(hr));

   Win::SendMessage(
      Win::GetDlgItem(hwnd, IDC_WARNING_ICON),
      STM_SETICON,
      reinterpret_cast<WPARAM>(warnIcon),
      0);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(State::OPTION_ALLOW_ANON_ACCESS);
      Win::CheckDlgButton(
         hwnd,
            (option.icompare(State::VALUE_NO) == 0)
         ?  IDC_DENY_ANON_ACCESS
         :  IDC_ALLOW_ANON_ACCESS,
         BST_CHECKED);
      return;
   }

   Win::CheckDlgButton(hwnd, IDC_ALLOW_ANON_ACCESS, BST_CHECKED);
}



bool
RASFixupPage::OnSetActive()
{
   LOG_FUNCTION(RASFixupPage::OnSetActive);

   State& state = State::GetInstance();
   bool skip = true;

   switch (state.GetOperation())
   {
      case State::FOREST:
      case State::TREE:
      case State::CHILD:
      {
         skip = false;
         break;
      }
      case State::REPLICA:
      case State::ABORT_BDC_UPGRADE:
      case State::DEMOTE:
      case State::NONE:
      {
         // do nothing: i.e. skip this page
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   if (state.RunHiddenUnattended() || skip)  // 268231
   {
      LOG(L"planning to skip RAS fixup page");

      Wizard& wizard = GetWizard();

      if (wizard.IsBacktracking())
      {
         // backup once again
         wizard.Backtrack(hwnd);
         return true;
      }

      int nextPage = Validate();
      if (nextPage != -1)
      {
         LOG(L"skipping RAS Fixup Page");         
         wizard.SetNextPageID(hwnd, nextPage);
         return true;
      }

      state.ClearHiddenWhileUnattended();
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



int
RASFixupPage::Validate()
{
   LOG_FUNCTION(RASFixupPage::Validate);

   State& state = State::GetInstance();
   if (Win::IsDlgButtonChecked(hwnd, IDC_ALLOW_ANON_ACCESS))
   {
      state.SetShouldAllowAnonymousAccess(true);
   }
   else
   {
      ASSERT(Win::IsDlgButtonChecked(hwnd, IDC_DENY_ANON_ACCESS));
      state.SetShouldAllowAnonymousAccess(false);
   }

   return IDD_SAFE_MODE_PASSWORD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\replicaormemberpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// welcome page
//
// 12-16-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "ReplicaOrMemberPage.hpp"
#include "resource.h"
#include "ds.hpp"
#include "state.hpp"



ReplicaOrMemberPage::ReplicaOrMemberPage()
   :
   DCPromoWizardPage(
      IDD_REPLICA_OR_MEMBER,
      IDS_REPLICA_OR_MEMBER_PAGE_TITLE,
      IDS_REPLICA_OR_MEMBER_PAGE_SUBTITLE)
{
   LOG_CTOR(ReplicaOrMemberPage);
}



ReplicaOrMemberPage::~ReplicaOrMemberPage()
{
   LOG_DTOR(ReplicaOrMemberPage);
}



void
ReplicaOrMemberPage::OnInit()
{
   LOG_FUNCTION(ReplicaOrMemberPage::OnInit);

   State& state = State::GetInstance();

   Win::SetDlgItemText(
      hwnd,
      IDC_PROMPT,
      String::format(
         IDS_BDC_UPGRADE_PROMPT,
         state.GetComputer().GetDomainNetbiosName().c_str()));

   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(State::OPTION_REPLICA_OR_MEMBER);
      if (option.icompare(State::VALUE_REPLICA) == 0)
      {
         Win::CheckDlgButton(hwnd, IDC_REPLICA, BST_CHECKED);
         return;
      }
   }

   Win::CheckDlgButton(hwnd, IDC_MEMBER, BST_CHECKED);
}



bool
ReplicaOrMemberPage::OnSetActive()
{
   LOG_FUNCTION(ReplicaOrMemberPage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   return true;
}



int
ReplicaOrMemberPage::Validate()
{
   LOG_FUNCTION(ReplicaOrMemberPage::Validate);

   State& state = State::GetInstance();
   int nextPage = -1;
   if (Win::IsDlgButtonChecked(hwnd, IDC_REPLICA))
   {
      state.SetOperation(State::REPLICA);
      nextPage = IDD_INSTALL_TCPIP;
   }
   else
   {
      ASSERT(Win::IsDlgButtonChecked(hwnd, IDC_MEMBER));
      state.SetOperation(State::ABORT_BDC_UPGRADE);
      nextPage = IDD_GET_CREDENTIALS;
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\replicaornewdomainpage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// replica or new domain page
//
// 12-19-97 sburns



#ifndef REPLICAORNEWDOMAINPAGE_HPP_INCLUDED
#define REPLICAORNEWDOMAINPAGE_HPP_INCLUDED



class ReplicaOrNewDomainPage : public DCPromoWizardPage
{
   public:

   ReplicaOrNewDomainPage();

   protected:

   virtual ~ReplicaOrNewDomainPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   ReplicaOrNewDomainPage(const ReplicaOrNewDomainPage&);
   const ReplicaOrNewDomainPage& operator=(const ReplicaOrNewDomainPage&);

   HICON warnIcon;
};



#endif   // REPLICAORNEWDOMAINPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\replicapage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// replica page
//
// 12-22-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "ReplicaPage.hpp"
#include "resource.h"
#include "ds.hpp"
#include "common.hpp"
#include "state.hpp"
#include "dns.hpp"



ReplicaPage::ReplicaPage()
   :
   DCPromoWizardPage(
      IDD_REPLICA,
      IDS_REPLICA_PAGE_TITLE,
      IDS_REPLICA_PAGE_SUBTITLE)
{
   LOG_CTOR(ReplicaPage);
}



ReplicaPage::~ReplicaPage()
{
   LOG_DTOR(ReplicaPage);
}



void
ReplicaPage::Enable()
{
   int next =
         !Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN).empty()
      ?  PSWIZB_NEXT : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | next);
}



bool
ReplicaPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(ReplicaPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_BROWSE:
      {
         if (code == BN_CLICKED)
         {
            String domain = BrowseForDomain(hwnd);
            if (!domain.empty())
            {
               Win::SetDlgItemText(hwnd, IDC_DOMAIN, domain);
            }

            return true;
         }
         break;
      }
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);            
            Enable();
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



void
ReplicaPage::OnInit()
{
   LOG_FUNCTION(ReplicaPage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY);

   State& state = State::GetInstance();

   if (state.UsingAnswerFile())
   {
      // Ignore the answerfile if we got the domain name from the
      // ReplicateFromMediaPage.

      if (
            !state.ReplicateFromMedia()
         || state.GetReplicaDomainDNSName().empty())
      {
         Win::SetDlgItemText(
            hwnd,
            IDC_DOMAIN,
            state.GetAnswerFileOption(
               State::OPTION_REPLICA_DOMAIN_NAME));
      }
   }
   else
   {
      // default domain is that the server is joined to.

      Win::SetDlgItemText(
         hwnd,
         IDC_DOMAIN,
         state.GetComputer().GetDomainDnsName());
   }
}



bool
ReplicaPage::ShouldSkipPage()
{
   LOG_FUNCTION(ReplicaPage::ShouldSkipPage);

   bool result = false;

   State& state = State::GetInstance();

   do
   {
      // check to see if we got the domain name from the
      // ReplicateFromMediaPage. If so, then we don't need to show this
      // page.

      if (
            state.ReplicateFromMedia()
         && !state.GetReplicaDomainDNSName().empty() )
      {
         // dns domain name is from the ReplicateFromMediaPage, which
         // saved that name in the state instance.  So put that name
         // in the ui.

         Win::SetDlgItemText(
            hwnd,
            IDC_DOMAIN,
            state.GetReplicaDomainDNSName());

         result = true;
         break;
      }

      if (state.RunHiddenUnattended())
      {
         result = true;
         break;
      }
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}
   


bool
ReplicaPage::OnSetActive()
{
   LOG_FUNCTION(ReplicaPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::REPLICA);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (ShouldSkipPage())
   {
      LOG(L"skipping ReplicaPage");

      Wizard& wiz = GetWizard();

      if (wiz.IsBacktracking())
      {
         // backup once again
         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = ReplicaPage::Validate();
      if (nextPage != -1)
      {
         wiz.SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   Enable();
   return true;
}



int
ReplicaPage::Validate()
{
   LOG_FUNCTION(ReplicaPage::Validate);

   int nextPage = -1;

   // SPB:251431 do validation even if this page is untouched, as upstream
   // pages may have been changed in such a fashion that re-validation is
   // required.
   // if (!WasChanged(IDC_DOMAIN))
   // {
   //    return nextPage;
   // }

   do
   {
      String domain = Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN);
      if (domain.empty())
      {
         popup.Gripe(hwnd, IDC_DOMAIN, IDS_MUST_ENTER_DOMAIN);
         break;
      }

      if (!ValidateDomainDnsNameSyntax(hwnd, IDC_DOMAIN, true))
      {
         break;
      }

      // now ensure that the domain exists

      String dnsName;
      if (!ValidateDomainExists(hwnd, IDC_DOMAIN, dnsName))
      {
         break;
      }
      if (!dnsName.empty())
      {
         // the user specified the netbios name of the domain, and
         // confirmed it, so use the dns domain name returned.

         Win::SetDlgItemText(hwnd, IDC_DOMAIN, dnsName);
         domain = dnsName;
      }
         
      State& state = State::GetInstance();

      if (!state.IsDomainInForest(domain))
      {
         popup.Gripe(
            hwnd,
            IDC_DOMAIN,
            String::format(
               IDS_DOMAIN_NOT_IN_FOREST,
               domain.c_str(),
               state.GetUserForestName().c_str()));
         break;
      }
         
      // valid

      ClearChanges();
      state.SetReplicaDomainDNSName(domain);

      nextPage = IDD_PATHS;
   }
   while (0);

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\replicaornewdomainpage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// replica or new domain page
//
// 12-19-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "ReplicaOrNewDomainPage.hpp"
#include "resource.h"
#include "ds.hpp"
#include "state.hpp"



ReplicaOrNewDomainPage::ReplicaOrNewDomainPage()
   :
   DCPromoWizardPage(
      IDD_REPLICA_OR_DOMAIN,
      IDS_REPLICA_OR_DOMAIN_PAGE_TITLE,
      IDS_REPLICA_OR_DOMAIN_PAGE_SUBTITLE),
   warnIcon(0)
{
   LOG_CTOR(ReplicaOrNewDomainPage);
}



ReplicaOrNewDomainPage::~ReplicaOrNewDomainPage()
{
   LOG_DTOR(ReplicaOrNewDomainPage);

   if (warnIcon)
   {
      Win::DestroyIcon(warnIcon);
   }
}



void
ReplicaOrNewDomainPage::OnInit()
{
   LOG_FUNCTION(ReplicaOrNewDomainPage::OnInit);

   HRESULT hr = Win::LoadImage(IDI_WARN, warnIcon);
   ASSERT(SUCCEEDED(hr));

   Win::SendMessage(
      Win::GetDlgItem(hwnd, IDC_WARNING_ICON),
      STM_SETICON,
      reinterpret_cast<WPARAM>(warnIcon),
      0);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      String option =
         state.GetAnswerFileOption(State::OPTION_REPLICA_OR_NEW_DOMAIN);
      Win::CheckDlgButton(
         hwnd,
            (option.icompare(State::VALUE_DOMAIN) == 0)
         ?  IDC_NEW_DOMAIN
         :  IDC_REPLICA,
         BST_CHECKED);
      return;
   }

   Win::CheckDlgButton(hwnd, IDC_NEW_DOMAIN, BST_CHECKED);
}



bool
ReplicaOrNewDomainPage::OnSetActive()
{
   LOG_FUNCTION(ReplicaOrNewDomainPage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   return true;
}



int
ReplicaOrNewDomainPage::Validate()
{
   LOG_FUNCTION(ReplicaOrNewDomainPage::Validate);

   State& state = State::GetInstance();
   int nextPage = -1;
   if (Win::IsDlgButtonChecked(hwnd, IDC_REPLICA))
   {
      state.SetOperation(State::REPLICA);
      nextPage = IDD_REPLICATE_FROM_MEDIA; // IDD_CONFIG_DNS_CLIENT;
   }
   else
   {
      ASSERT(Win::IsDlgButtonChecked(hwnd, IDC_NEW_DOMAIN));
      state.SetOperation(State::NONE);
      nextPage = IDD_TREE_OR_CHILD;
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\replicatefrommediapage.hpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// install replica from media page
//
// 7 Feb 2000 sburns



#ifndef REPLICATEFROMMEDIAPAGE_HPP_INCLUDED
#define REPLICATEFROMMEDIAPAGE_HPP_INCLUDED



class ReplicateFromMediaPage : public DCPromoWizardPage
{
   public:

   ReplicateFromMediaPage();

   protected:

   virtual ~ReplicateFromMediaPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();

   // not defined; no copying allowed

   ReplicateFromMediaPage(const ReplicateFromMediaPage&);
   const ReplicateFromMediaPage& operator=(const ReplicateFromMediaPage&);
};



#endif   // REPLICATEFROMMEDIAPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\replicapage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// replica page
//
// 12-22-97 sburns



#ifndef REPLICAPAGE_HPP_INCLUDED
#define REPLICAPAGE_HPP_INCLUDED



class ReplicaPage : public DCPromoWizardPage
{
   public:

   ReplicaPage();

   protected:

   virtual ~ReplicaPage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   void
   Enable();

   bool
   ShouldSkipPage();

   // not defined; no copying allowed

   ReplicaPage(const ReplicaPage&);
   const ReplicaPage& operator=(const ReplicaPage&);
};



#endif   // REPLICAPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\replicatefrommediapage.cpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// install replica from media page
//
// 7 Feb 2000 sburns



#include "headers.hxx"
#include "resource.h"
#include "common.hpp"
#include "page.hpp"
#include "ReplicateFromMediaPage.hpp"
#include "state.hpp"
#include "SyskeyDiskDialog.hpp"
#include "SyskeyPromptDialog.hpp"



ReplicateFromMediaPage::ReplicateFromMediaPage()
   :
   DCPromoWizardPage(
      IDD_REPLICATE_FROM_MEDIA,
      IDS_REPLICATE_FROM_MEDIA_PAGE_TITLE,
      IDS_REPLICATE_FROM_MEDIA_PAGE_SUBTITLE)
{
   LOG_CTOR(ReplicateFromMediaPage);
}



ReplicateFromMediaPage::~ReplicateFromMediaPage()
{
   LOG_DTOR(ReplicateFromMediaPage);
}



String
FirstFixedDisk()
{
   LOG_FUNCTION(FirstFixedDisk);

   String result;

   do
   {
      StringVector dl;
      HRESULT hr = FS::GetValidDrives(std::back_inserter(dl));
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(dl.size());

      for (
         StringVector::iterator i = dl.begin();
         i != dl.end();
         ++i)
      {
         String rootPath = *i + L"\\";

         if (Win::GetDriveType(rootPath) == DRIVE_FIXED)
         {
            result = *i;
            break;
         }
      }
   }
   while (0);

   if (result.empty())
   {
      // This is deadcode, really, cause we're sure to find a fixed volume
      // somewhere

      result = FS::GetRootFolder(Win::GetSystemDirectory()).substr(0, 3);
   }

   LOG(result);

   return result;
}



void
ReplicateFromMediaPage::OnInit()
{
   LOG_FUNCTION(ReplicateFromMediaPage::OnInit);

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_SOURCE), MAX_PATH);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      String option = state.GetAnswerFileOption(State::OPTION_SOURCE_PATH);
      if (!option.empty())
      {
         Win::CheckDlgButton(hwnd, IDC_USE_FILES, BST_CHECKED);
      
         Win::SetDlgItemText(
            hwnd,
            IDC_SOURCE,
            Win::ExpandEnvironmentStrings(
               state.GetAnswerFileOption(State::OPTION_SOURCE_PATH)));

         return;
      }
   }

   Win::CheckDlgButton(hwnd, IDC_USE_NET, BST_CHECKED);

   String root = FirstFixedDisk();
   Win::SetDlgItemText(
      hwnd,
      IDC_SOURCE,
      root + String::load(IDS_SOURCE_SUFFIX));
}



void
ReplicateFromMediaPage::Enable()
{
   int next = PSWIZB_NEXT;

   bool useFiles = Win::IsDlgButtonChecked(hwnd, IDC_USE_FILES);

   if (useFiles)
   {
      // if using files, the edit box must have some text.

      if (Win::GetTrimmedDlgItemText(hwnd, IDC_SOURCE).empty())
      {
         next = 0;
      }
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | next);

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_SOURCE), useFiles);
   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_BROWSE), useFiles);
}



bool
ReplicateFromMediaPage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(ReplicateFromMediaPage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_USE_NET:
      case IDC_USE_FILES:
      {
         if (code == BN_CLICKED)
         {
            SetChanged(controlIDFrom);
            Enable();
            return true;
         }
      }
      case IDC_BROWSE:
      {
         if (code == BN_CLICKED)
         {
            String path = BrowseForFolder(hwnd, IDS_SOURCE_BROWSE_TITLE);
            if (!path.empty())
            {
               Win::SetDlgItemText(hwnd, IDC_SOURCE, path);
            }

            return true;
         }
         break;
      }
      case IDC_SOURCE:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);
            Enable();
            return true;
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



bool
ReplicateFromMediaPage::OnSetActive()
{
   LOG_FUNCTION(ReplicateFromMediaPage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::REPLICA);
      
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended() || !state.IsAdvancedMode())
   {
      LOG(L"skipping ReplicateFromMediaPage");

      Wizard& wiz = GetWizard();

      if (wiz.IsBacktracking())
      {
         // backup once again
         wiz.Backtrack(hwnd);
         return true;
      }

      int nextPage = ReplicateFromMediaPage::Validate();
      if (nextPage != -1)
      {
         wiz.SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }

   Enable();
   return true;
}



bool
ValidateSourcePath(HWND parent, const String& path, int editResId)
{
   LOG_FUNCTION2(ValidateSourcePath, path);

   bool result = false;

   do
   {
      if (path.empty())
      {
         popup.Gripe(
            parent,
            editResId,
            IDS_MUST_ENTER_SOURCE_PATH);
         break;
      }

      // Path must have a drive letter

      FS::PathSyntax syn = FS::GetPathSyntax(path);
      if (syn != FS::SYNTAX_ABSOLUTE_DRIVE)
      {
         popup.Gripe(
            parent,
            editResId,
            String::format(IDS_BAD_PATH_FORMAT, path.c_str()));
         break;
      }

      // mapped network drives are not ok.  This is because the DsRole apis
      // copy the restored files on the server side of the api, in the
      // system context.
      // NTRAID#NTBUG9-309422-2001/02/12-sburns
      
      UINT type = Win::GetDriveType(path);
      if (type != DRIVE_FIXED)
      {
         popup.Gripe(
            parent,
            editResId,
            String::format(IDS_BAD_DRIVE_TYPE, path.c_str()));
         break;
      }
      
      result = true;
   }
   while (0);

   LOG(result ? L"true" : L"false")
         
   return result;
}



// Return true on success, false on failure

bool
GetDatabaseFacts(HWND parent, const String& sourcePath)
{
   LOG_FUNCTION2(GetDatabaseFacts, sourcePath);
   ASSERT(Win::IsWindow(parent));
   ASSERT(!sourcePath.empty());

   bool result = false;

   PWSTR dnsDomainName = 0;

   State& state = State::GetInstance();
   state.SetIsBackupGc(false);
   state.SetSyskeyLocation(State::STORED);

   LOG(L"Calling DsRoleGetDatabaseFacts");
   LOG(String::format(L"lpRestorePath: %1", sourcePath.c_str()));

   ULONG facts = 0;
   HRESULT hr = 
      Win32ToHresult(
         ::DsRoleGetDatabaseFacts(
            0,    // this server
            sourcePath.c_str(),
            &dnsDomainName,
            &facts));

   LOG_HRESULT(hr);

   if (SUCCEEDED(hr))
   {
      LOG(String::format(L"lpDNSDomainName: %1", dnsDomainName ? dnsDomainName : L"(null)"));
      LOG(String::format(L"State          : 0x%1!X!", facts));

      if (dnsDomainName)
      {
         // Save this domain name.  This will allow us to skip the ReplicaPage
         // since we now know the domain name.

         state.SetReplicaDomainDNSName(dnsDomainName);
         MIDL_user_free(dnsDomainName);
      }

      if (facts & DSROLE_DC_IS_GC)
      {
         LOG(L"is gc");

         state.SetIsBackupGc(true);
      }

      if (facts & DSROLE_KEY_DISK)
      {
         LOG(L"syskey on disk");

         state.SetSyskeyLocation(State::DISK);
      }
      else if (facts & DSROLE_KEY_PROMPT)
      {
         LOG(L"prompt for syskey");

         state.SetSyskeyLocation(State::PROMPT);
      }
      else if (facts & DSROLE_KEY_STORED)
      {
         LOG(L"syskey stored");

         // we set this as the default value, above.
      }
      else
      {
         // The api is insane.

         ASSERT(false);

         LOG(L"unexpected State value");
      }

      result = true;
   }
   else
   {
      popup.Error(
         parent,
         hr,
         String::format(IDS_GET_FACTS_FAILED, sourcePath.c_str()));
   }

   LOG(result ? L"true" : L"false");

   return result;
}



int
ReplicateFromMediaPage::Validate()
{
   LOG_FUNCTION(ReplicateFromMediaPage::Validate);

   State& state = State::GetInstance();

   int nextPage = -1;

   bool useFiles = Win::IsDlgButtonChecked(hwnd, IDC_USE_FILES);

   do
   {
      if (WasChanged(IDC_USE_FILES) || WasChanged(IDC_USE_NET))
      {
         state.SetReplicateFromMedia(useFiles);
      }

      if (!useFiles)
      {
         LOG(L"not using source media for replication");

         nextPage = IDD_CONFIG_DNS_CLIENT;
         break;
      }

      String sourcePath = Win::GetTrimmedDlgItemText(hwnd, IDC_SOURCE);

      if (ValidateSourcePath(hwnd, sourcePath, IDC_SOURCE) )
      {
         String s =
            FS::NormalizePath(Win::GetTrimmedDlgItemText(hwnd, IDC_SOURCE));

         state.SetReplicationSourcePath(s);
      }
      else
      {
         break;
      }

      // check the restored backup for the syskey, the domain name, and the DC
      // type.

      if (!GetDatabaseFacts(hwnd, sourcePath))
      {
         break;
      }

      State::SyskeyLocation loc = state.GetSyskeyLocation();
      if (loc == State::DISK)
      {
         if (SyskeyDiskDialog().ModalExecute(hwnd) != IDOK)
         {
            break;
         }
      }
      else if (loc == State::PROMPT)
      {
         if (SyskeyPromptDialog().ModalExecute(hwnd) != IDOK)
         {
            break;
         }
      }

      // The syskey is present, do we need to jump to the GC confirmation?

      if (state.IsBackupGc())
      {
         nextPage = IDD_GC_CONFIRM;
         break;
      }

      // The syskey is present, the backup is not a gc, so move along

      nextPage = IDD_CONFIG_DNS_CLIENT;
   }
   while (0);

   if (nextPage != -1)
   {
      // only clear changes when the user has specified valid options.
      // otherwise, we want to go thru the validation until he gets it
      // right.

      ClearChanges();
   }
    
   LOG(String::format(L"next = %1!d!", nextPage));

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_WIZARD_TITLE                2
#define IDS_BIG_BOLD_FONT_NAME          3
#define IDS_BIG_BOLD_FONT_SIZE          4
#define IDS_WORKSTATION_NOT_SUPPORTED   5
#define IDS_CONVERT_PDC_FIRST           8
#define IDS_DOMAIN_NOT_FOUND            9
#define IDS_BAD_DNS_SYNTAX              10
#define IDS_COULDNT_REMOVE_COMPUTER_ACCOUNT_TEXT 11
#define IDS_OPERATION_FAILED            13
#define IDS_OPERATION_DONE              15
#define IDS_OPERATION_TERMINATED        16
#define IDS_DISJOIN_DOMAIN_FAILED       17
#define IDS_JOIN_DOMAIN_FAILED          18
#define IDS_SET_ROLE_AS_DC_FAILED       19
#define IDS_FLATNAME_IN_USE             22
#define IDS_DOMAIN_NAME_IN_USE          23
#define IDS_FIRST_SITE                  24
#define IDS_CHILD_PAGE_TITLE            25
#define IDS_CHILD_PAGE_SUBTITLE         26
#define IDS_CONFIRMATION_PAGE_TITLE     27
#define IDS_CONFIRMATION_PAGE_SUBTITLE  28
#define IDS_CREDENTIALS_PAGE_TITLE      29
#define IDS_CREDENTIALS_PAGE_SUBTITLE   30
#define IDS_CONFIG_DNS_CLIENT_PAGE_TITLE 31
#define IDS_CONFIG_DNS_CLIENT_PAGE_SUBTITLE 32
#define IDS_DNS_ON_NET_PAGE_TITLE       35
#define IDS_DNS_ON_NET_PAGE_SUBTITLE    36
#define IDS_FAILURE_PAGE_SUBTITLE       37
#define IDS_FAILURE_PAGE_TITLE          38
#define IDS_FINISH_PAGE_SUBTITLE        39
#define IDS_FINISH_PAGE_TITLE           40
#define IDS_NEW_FOREST_PAGE_SUBTITLE    41
#define IDS_NEW_FOREST_PAGE_TITLE       42
#define IDS_NETBIOS_NAME_PAGE_SUBTITLE  45
#define IDS_NETBIOS_NAME_PAGE_TITLE     46
#define IDS_NEW_SITE_PAGE_SUBTITLE      47
#define IDS_NEW_SITE_PAGE_TITLE         48
#define IDS_PATHS_PAGE_SUBTITLE         49
#define IDS_PATHS_PAGE_TITLE            50
#define IDS_PICK_SITE_PAGE_SUBTITLE     51
#define IDS_PICK_SITE_PAGE_TITLE        52
#define IDS_REPLICA_OR_DOMAIN_PAGE_SUBTITLE 53
#define IDS_REPLICA_OR_DOMAIN_PAGE_TITLE 54
#define IDS_REPLICA_PAGE_SUBTITLE       55
#define IDS_REPLICA_PAGE_TITLE          56
#define IDS_REPLICA_OR_MEMBER_PAGE_SUBTITLE 57
#define IDS_REPLICA_OR_MEMBER_PAGE_TITLE 58
#define IDS_INSTALL_TCPIP_PAGE_SUBTITLE 59
#define IDS_INSTALL_TCPIP_PAGE_TITLE    60
#define IDS_WELCOME_PAGE_SUBTITLE       63
#define IDS_WELCOME_PAGE_TITLE          64
#define IDS_TREE_PAGE_SUBTITLE          65
#define IDS_TREE_PAGE_TITLE             66
#define IDS_CANT_BROWSE_FOREST          67
#define IDS_PATHS2_PAGE_SUBTITLE        68
#define IDS_PATHS2_PAGE_TITLE           69
#define IDS_DB_BROWSE_TITLE             70
#define IDS_LOG_BROWSE_TITLE            71
#define IDS_SYSVOL_BROWSE_TITLE         72
#define IDS_NON_RFC_NAME                73
#define IDS_PATH_IS_WINDIR              76
#define IDS_PATH_IS_SYSTEM32            77
#define IDS_BAD_PATH_FORMAT             78
#define IDS_BAD_DRIVE_TYPE              79
#define IDS_PATH_NOT_DIRECTORY          80
#define IDS_EMPTY_PATH                  81
#define IDS_LOW_SPACE_DB                83
#define IDS_LOW_SPACE_LOG               84
#define IDS_NOT_NTFS5                   85
#define IDS_NOT_ADMIN                   86
#define IDS_DNS_LABEL_TOO_LONG          87
#define IDS_MUST_ENTER_USERNAME         88
#define IDS_MUST_ENTER_USER_DOMAIN      89
#define IDS_NT51_REQUIRED               90
#define IDS_INTRO1_DEMOTE               91
#define IDS_INTRO2_DEMOTE               92
#define IDS_INTRO1_INSTALL              93
#define IDS_INTRO2_INSTALL              94
#define IDS_INTRO2_BDC_UPGRADE          95
#define IDS_INTRO2_PDC_UPGRADE          96
#define IDS_BAD_LABEL_SYNTAX            99
#define IDS_BAD_SITE_SYNTAX             100
#define IDS_CONFIG_DNS_FIRST            101
#define IDS_DEMOTE_DC_FAILED            102
#define IDI_WARN                        102
#define IDD_NON_DOMAIN_NC_ERROR         102
#define IDS_REPLICA_CREDENTIALS         103
#define IDD_BAD_COMPUTER_NAME           103
#define IDS_SIBLING_CREDENTIALS         104
#define IDR_AVI_DEMOTE                  104
#define IDS_PARENT_CREDENTIALS          105
#define IDD_UNATTEND_SPLASH             105
#define IDS_PARENT_DEMOTE_CREDENTIALS   106
#define IDS_DEMOTE_PAGE_SUBTITLE        107
#define IDI_WARNINGBIG                  107
#define IDD_WELCOME                     108
#define IDS_DEMOTE_PAGE_TITLE           108
#define IDB_BANNER16                    109
#define IDD_DYNAMIC_DNS_DETAILS         109
#define IDD_DYNAMIC_DNS_DETAILS_OK_HELP 109
#define IDB_BANNER256                   110
#define IDS_AUTO_CONFIG_DNS_PAGE_TITLE  110
#define IDB_WATERMARK16                 111
#define IDB_WATERMARK256                112
#define IDS_AUTO_CONFIG_DNS_PAGE_SUBTITLE 112
#define IDI_BIGX_ERROR                  113
#define IDD_PATHS                       123
#define IDD_PROGRESS                    138
#define IDD_REBOOT                      139
#define IDD_INSTALL_TCPIP               140
#define IDD_REPLICA_OR_MEMBER           141
#define IDD_CONFIRMATION                142
#define IDD_DNS_ON_NET                  143
#define IDD_CONFIG_DNS_CLIENT           144
#define IDD_TREE_OR_CHILD               145
#define IDD_NEW_DOMAIN                  145
#define IDD_REPLICA_OR_DOMAIN           146
#define IDD_GET_CREDENTIALS             147
#define IDD_REPLICA                     148
#define IDD_NEW_CHILD                   150
#define IDD_NEW_TREE                    152
#define IDD_PICK_SITE                   153
#define IDD_FINISH                      154
#define IDD_FAILURE                     156
#define IDD_NEW_SITE                    157
#define IDD_NEW_FOREST                  158
#define IDD_NETBIOS_NAME                159
#define IDD_NEW_CREDENTIALS             161
#define IDD_PATHS2                      162
#define IDD_DEMOTE                      163
#define IDD_ADMIN_PASSWORD              164
#define IDD_AUTO_CONFIG_DNS             165
#define IDD_RAS_FIXUP                   167
#define IDD_SAFE_MODE_PASSWORD          168
#define IDD_REPLICATE_FROM_MEDIA        169
#define IDD_SYSKEY                      170
#define IDD_SYSKEY_PROMPT               170
#define IDD_GC_CONFIRM                  171
#define IDD_SYSKEY_DISK                 172
#define IDD_DYNAMIC_DNS                 174
#define IDD_NON_RFC_COMPUTER_NAME       176
#define IDD_DYNAMIC_DNS_DETAILS_OK      177
#define IDD_PORTS_IN_USE_ERROR          178
#define IDD_REBOOT_FAILURE              179
#define IDD_FOREST_VERSION              180
#define IDS_CONFIRM_MESSAGE_REPLICA     500
#define IDS_CONFIRM_MESSAGE_FOREST      501
#define IDS_CONFIRM_MESSAGE_TREE        502
#define IDS_CONFIRM_MESSAGE_CHILD       503
#define IDS_CONFIRM_MESSAGE_DEMOTE_LAST_DC 504
#define IDS_CONFIRM_MESSAGE_DEMOTE      505
#define IDS_MUST_SPECIFY_SITE           506
#define IDC_MEMBER                      1000
#define IDC_REPLICA                     1001
#define IDC_BUTTON                      1002
#define IDC_DNS_NOT_ON_NET              1003
#define IDC_CONFIG_CLIENT               1004
#define IDC_TREE                        1005
#define IDC_CHILD                       1006
#define IDC_BROWSE_DB                   1007
#define IDC_NEW_DOMAIN                  1008
#define IDC_DOMAIN                      1009
#define IDC_FOREST                      1009
#define IDC_PROMPT                      1010
#define IDC_SOURCE                      1011
#define IDC_PARENT                      1012
#define IDC_LEAF                        1013
#define IDC_BROWSE                      1014
#define IDC_SYSKEY                      1019
#define IDC_SITE                        1020
#define IDC_GC_YES                      1020
#define IDC_GC_NO                       1021
#define IDC_NETBIOS                     1023
#define IDC_MESSAGE                     1024
#define IDC_USE_NET                     1025
#define IDC_JUMP                        1027
#define IDC_NDNC_LIST                   1027
#define IDC_INTRO1                      1028
#define IDC_CRED                        1028
#define IDC_INTRO2                      1029
#define IDC_TEXT                        1030
#define IDC_RETRY                       1031
#define IDC_INSTALL_DNS                 1032
#define IDC_LAST                        1032
#define IDC_IGNORE                      1033
#define IDC_CONFIRM                     1034
#define IDC_DETAILS                     1034
#define IDC_RENAME                      1036
#define IDC_SHOW_HELP                   1037
#define IDC_TEST_PASS                   1040
#define IDC_AUTO_CONFIG                 1041
#define IDC_DONT_AUTO_CONFIG            1042
#define IDC_SKIP                        1046
#define IDC_PORT_LIST                   1046
#define IDC_CONTINUE                    1047
#define IDC_SET_VERSION                 1048
#define IDC_ALLOW_ANON_ACCESS           1050
#define IDC_DENY_ANON_ACCESS            1051
#define IDC_FAILURE_MESSAGE             1052
#define IDC_WARNING_ICON                1053
#define IDC_BULLET1                     1054
#define IDC_BULLET2                     1055
#define IDC_DB                          1100
#define IDC_LOG                         1101
#define IDC_SYSVOL                      1102
#define IDC_BIG_BOLD_TITLE              1146
#define IDC_RESTART_NOW                 1154
#define IDC_RESTART_LATER               1155
#define IDC_ANIMATION                   1159
#define IDR_AVI_DOMAIN                  1304
#define IDR_AVI_REPLICA                 1305
#define IDS_BLANK_LEAF_NAME             1306
#define IDS_BLANK_SITE_NAME             1307
#define IDS_INSTALL_TCPIP_HELP_TOPIC    1310
#define IDS_CONFIG_DNS_HELP_TOPIC       1311
#define IDS_HTML_HELP_FILE              1312
#define IDS_PASSWORD_PAGE_SUBTITLE      1313
#define IDS_PASSWORD_PAGE_TITLE         1314
#define IDS_PASSWORD_MISMATCH           1315
#define IDS_DB_SUFFIX                   1317
#define IDS_LOG_SUFFIX                  1318
#define IDS_SYSVOL_SUFFIX               1319
#define IDS_ENTER_LOCAL_ADMIN_PASSWORD  1320
#define IDS_ENTER_DOMAIN_ADMIN_PASSWORD 1321
#define IDS_UPGRADE_DC_FAILED           1322
#define IDS_ABORT_UPGRADE_FAILED        1323
#define IDS_CONFIRM_ABORT_BDC_UPGRADE   1325
#define IDS_INTRO1_DC_UPGRADE           1326
#define IDS_DNS_NAME_TOO_LONG           1327
#define IDS_ALREADY_RUNNING             1328
#define IDS_DNSMGR_DLL_NAME             1330
#define IDS_CONFIRM_PATHS_MESSAGE       1332
#define IDS_FINISH_FAILURE              1333
#define IDS_FINISH_PROMOTE              1334
#define IDS_FINISH_SITE                 1335
#define IDS_FINISH_DEMOTE               1336
#define IDS_FINISH_ABORT_BDC_UPGRADE    1337
#define IDS_ERROR_DNS_CONFIG_FAILED     1338
#define IDS_ERROR_CONFIGURING_DNS       1339
#define IDS_ERROR_PREPARING_OPERATION   1340
#define IDS_EMPTY_DIR_FAILED            1341
#define IDS_FINISH_DEMOTE_FAILURE       1342
#define IDS_FINISH_ABORT_BDC_UPGRADE_FAILURE 1343
#define IDS_MSI_PACKAGE_FILENAME        1344
#define IDS_ERROR_CONFIGURING_SHORTCUTS 1345
#define IDS_SHORTCUTS_NOT_CONFIGURED    1346
#define IDS_CONFIGURING_SHORTCUTS       1347
#define IDS_OPERATION_FAILED_NO_RESULT_MESSAGE 1349
#define IDS_DISJOINED                   1360
#define IDS_INSTALL_TCPIP_FIRST         1361
#define IDS_ABORT_BDC_UPGRADE_CREDENTIALS 1363
#define IDS_NON_FATAL_ERRORS_OCCURRED   1364
#define IDS_CANT_REBOOT                 1365
#define IDS_INSTALL_DNS_COMMAND_LINE    1367
#define IDS_INSTALLING_DNS              1368
#define IDS_CONFIGURING_DNS             1370
#define IDS_PROGRESS_ERROR_INSTALLING_DNS 1371
#define IDS_PROGRESS_ERROR_CONFIGURING_DNS 1372
#define IDS_WAITING_FOR_INSTALLER       1373
#define IDS_WAITING_FOR_SERVICE_INSTALL 1374
#define IDS_WAITING_FOR_SERVICE_START   1375
#define IDS_ERROR_QUERYING_INSTALLER    1376
#define IDS_ERROR_LAUNCHING_INSTALLER   1377
#define IDS_SKIP_DNS_MESSAGE            1379
#define IDS_CONFIRM_INSTALL_DNS         1381
#define IDS_PROGRESS_BUTTON_SKIP_DNS    1382
#define IDS_INSTALL_DNS_INF_TEXT        1383
#define IDS_INSTALL_DNS_UNATTEND_TEXT   1384
#define IDS_BAD_NETBIOS_NAME            1385
#define IDS_NETBIOS_NAME_TOO_LONG       1386
#define IDS_NT5_DOMAIN_NOT_FOUND        1387
#define IDS_UNABLE_TO_READ_FOREST       1388
#define IDS_DOMAIN_NOT_IN_FOREST        1389
#define IDS_SUPERIOR_TO_TREE            1390
#define IDS_INFERIOR_TO_TREE            1391
#define IDS_PROP_SHEET_FAILED           1392
#define IDS_PROGRESS_CANCEL             1393
#define IDS_FINISH_REPLICATION_LATER    1394
#define IDS_PROMOTION_CREDENTIALS       1395
#define IDS_ROOT_DOMAIN_CREDENTIALS     1396
#define IDS_NO_DOTS_IN_NETBIOS_NAME     1397
#define IDS_BAD_NETBIOS_CHARACTERS      1398
#define IDS_REINSTALL_DOMAIN_MESSAGE    1399
#define IDS_CANCEL_NON_CRITICAL_REPLICATION 1400
#define IDS_CANCEL_PROMOTE              1401
#define IDS_NON_CRITICAL_REPLICATION_CANCELED 1402
#define IDS_CANCEL_TOO_LATE             1403
#define IDS_CANCELLING                  1404
#define IDS_CANCELLING_REPLICATION      1405
#define IDS_DEMOTE_DOMAIN_HAS_DEPENDENTS 1406
#define IDS_STARTING                    1407
#define IDS_RAS_FIXUP_PAGE_TITLE        1408
#define IDS_RAS_FIXUP_PAGE_SUBTITLE     1409
#define IDS_CONFIRM_DO_RAS_FIXUP        1412
#define IDS_ROLE_CHANGE_IN_PROGRESS     1413
#define IDS_ROLE_CHANGE_NEEDS_REBOOT    1414
#define IDS_LANGUAGE_FIXUP_FAILED       1415
#define IDS_LANGUAGE_FIXUP_FAILED_FINISH 1416
#define IDS_NON_CRITICAL_REPL_FAILED    1417
#define IDS_MUST_ENTER_PARENT           1418
#define IDS_MUST_ENTER_LEAF             1419
#define IDS_MUST_ENTER_DOMAIN           1420
#define IDS_NO_NTFS5_DRIVES             1421
#define IDS_DEMOTE_GC_WARNING           1422
#define IDS_CONFIRM_CANCEL              1423
#define IDS_CONFIRM_UPGRADE_CANCEL      1424
#define IDS_CONFIRM_DNS_NAME            1425
#define IDS_CONFIRM_NETBIOS_LOOKING_NAME 1426
#define IDS_SAFEBOOT_MODE               1427
#define IDS_SYSVOL_CANT_MATCH_DB        1428
#define IDS_SYSVOL_CANT_MATCH_LOG       1429
#define IDS_SYSVOL_CANT_BE_LOG_PARENT   1430
#define IDS_SYSVOL_CANT_BE_DB_PARENT    1431
#define IDS_CONFIGURING_SHORTCUTS_RETRY 1432
#define IDS_DISJOINING_PROGRESS         1433
#define IDS_PATH_CONTAINS_MOUNTED_VOLUMES 1434
#define IDS_CERT_SERVICE_IS_INSTALLED   1435
#define IDS_SAFE_MODE_PASSWORD_PAGE_TITLE 1436
#define IDS_SAFE_MODE_PASSWORD_PAGE_SUBTITLE 1437
#define IDS_SMALL_BUSINESS_LIMIT        1438
#define IDS_GENERATED_NAME_WAS_TWEAKED  1439
#define IDS_OPERATION_FAILED_GET_CRED   1440
#define IDS_OPERATION_FAILED_GET_CRED_NO_RESULT 1441
#define IDS_CHANGING_DOMAIN             1442
#define IDS_UNABLE_TO_JOIN_DOMAIN       1443
#define IDS_BULLET_FONT_NAME            1444
#define IDS_SBS_LIMITATION_MESSAGE      1445
#define IDS_NUMERIC_NETBIOS_NAME        1446
#define IDS_DC_POLICY_LINK              1447
#define IDS_DC_POLICY_DESC              1448
#define IDS_DOMAIN_POLICY_LINK          1449
#define IDS_DOMAIN_POLICY_DESC          1450
#define IDS_LOCAL_POLICY_LINK           1451
#define IDS_LOCAL_POLICY_DESC           1452
#define IDS_DS_SITE_LINK                1453
#define IDS_DS_SITE_DESC                1454
#define IDS_DS_USERS_LINK               1455
#define IDS_DS_USERS_DESC               1456
#define IDS_DS_DOMAINS_LINK             1457
#define IDS_DS_DOMAINS_DESC             1458
#define IDS_COMMAND_LINE_HELP           1460
#define IDC_USE_FILES                   1461
#define IDC_BROWSE_LOG                  1462
#define IDC_PASSWORD                    1463
#define IDS_REPLICATE_FROM_MEDIA_PAGE_TITLE 1465
#define IDS_REPLICATE_FROM_MEDIA_PAGE_SUBTITLE 1466
#define IDS_SOURCE_SUFFIX               1467
#define IDS_SOURCE_BROWSE_TITLE         1470
#define IDS_NEW_DOMAIN_PAGE_TITLE       1473
#define IDS_NEW_DOMAIN_PAGE_SUBTITLE    1474
#define IDS_BDC_UPGRADE_PROMPT          1476
#define IDS_CONFIRM_MESSAGE_REPLICATE_FROM_MEDIA 1477
#define IDS_DB_CANT_MATCH_SOURCE_PATH   1478
#define IDS_LOG_CANT_MATCH_SOURCE_PATH  1481
#define IDS_SYSVOL_CANT_MATCH_SOURCE_PATH 1484
#define IDS_RESERVED_NAME_SUFFIX        1487
#define IDS_RESERVED_NAME               1488
#define IDS_SYSVOL_LOW_SPACE            1489
#define IDS_WINDIR_LOW_SPACE            1490
#define IDS_NET_NOT_REACHABLE           1491
#define IDS_RAS_BAD_NETPATH             1492
#define IDS_VERIFY_LAST_DC              1493
#define IDS_EMPTY_DIR_FAILED_ACCESS_DENIED 1494
#define IDS_DNS_LOOKUP_FAILED           1495
#define IDS_VERIFY_NOT_LAST_DC          1496
#define IDS_MUST_ENTER_SYSKEY           1499
#define IDS_GC_CONFIRM_PAGE_TITLE       1500
#define IDS_GC_CONFIRM_PAGE_SUBTITLE    1501
#define IDS_MUST_ENTER_SOURCE_PATH      1502
#define IDS_GET_FACTS_FAILED            1503
#define IDS_SYSKEY_NOT_FOUND            1504
#define IDS_ANSWERFILE_NOT_FOUND        1505
#define IDS_DC_FOR_ROOT_NOT_FOUND       1506
#define IDS_FAILED_TO_READ_NDNC_INFO    1507
#define IDS_SAFEMODE_PASSWORD_REQUIRED  1508
#define IDS_COMPUTER_NAME_HAS_BAD_CHARS 1509
#define IDS_LAUNCH_NETID_COMMAND_LINE   1510
#define IDS_COMPUTER_NAME_NON_RFC       1511
#define IDS_COMPUTER_NAME_IS_NUMERIC    1512
#define IDS_DYNAMIC_DNS_PAGE_TITLE      1514
#define IDS_DYNAMIC_DNS_PAGE_SUBTITLE   1515
#define IDS_DYN_DNS_MESSAGE_SUCCESS     1516
#define IDS_DYN_DNS_DETAIL_FULL         1517
#define IDS_DYN_DNS_MESSAGE_SERVER_CANT_UPDATE 1518
#define IDS_DYN_DNS_MESSAGE_ZONE_IS_ROOT 1519
#define IDS_DYN_DNS_MESSAGE_ERROR_TESTING_SERVER 1520
#define IDS_DYN_DNS_MESSAGE_ERROR_FINDING_SERVER 1521
#define IDS_DYN_DNS_DETAIL_SCANT        1522
#define IDS_DYN_DNS_DETAIL_ROOT_ZONE    1523
#define IDS_REINSTALL_DOMAIN_CONTROLLER_MESSAGE 1524
#define IDS_TEST_PASS_COUNT             1525
#define IDS_DC_NOT_FOUND                1526
#define IDS_DYN_DNS_MESSAGE_TIMEOUT     1527
#define IDS_DYN_DNS_MESSAGE_UNEXPECTED  1528
#define IDS_DOMAIN_ADMIN_PASSWORD       1529
#define IDS_NAME_CHANGE_NEEDS_REBOOT    1530
#define IDS_CAPS_LOCK_TIP_TITLE         1531
#define IDS_CAPS_LOCK_TIP_TEXT          1532
#define IDS_NDNC_LIST_NAME_COLUMN_WIDTH 1533
#define IDS_NDNC_LIST_NAME_COLUMN       1534
#define IDS_NDNC_LIST_DESC_COLUMN_WIDTH 1535
#define IDS_NDNC_LIST_DESC_COLUMN       1536
#define IDS_FINISH_NON_RFC_COMPUTER_NAME 1537
#define IDS_FINISH_NUMERIC_COMPUTER_NAME 1538
#define IDS_FINISH_BAD_COMPUTER_NAME    1539
#define IDS_MUST_RESTORE_IFM_FILES_AGAIN 1540
#define IDS_UNABLE_TO_DETERMINE_OP_STATE 1541
#define IDS_UNABLE_TO_DETERMINE_COMPUTER_CONFIG 1542
#define IDS_MACHINE_IS_ALREADY_DC       1543
#define IDS_MACHINE_IS_NOT_ALREADY_DC   1544
#define IDS_WEB_BLADE_NOT_SUPPORTED     1545
#define IDS_APP_SERVER_WARNING          1546
#define IDS_FOREST_VERSION_PAGE_TITLE   1547
#define IDS_FOREST_VERSION_PAGE_SUBTITLE 1548
#define IDS_UNABLE_TO_DETERMINE_FOREST 1549
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        112
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1051
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\safemode.cpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// Safe Mode Administrator password page
//
// 6-3-99 sburns



#include "headers.hxx"
#include "safemode.hpp"
#include "resource.h"
#include "state.hpp"
#include "ds.hpp"



SafeModePasswordPage::SafeModePasswordPage()
   :
   DCPromoWizardPage(
      IDD_SAFE_MODE_PASSWORD,
      IDS_SAFE_MODE_PASSWORD_PAGE_TITLE,
      IDS_SAFE_MODE_PASSWORD_PAGE_SUBTITLE)
{
   LOG_CTOR(SafeModePasswordPage);
}



SafeModePasswordPage::~SafeModePasswordPage()
{
   LOG_DTOR(SafeModePasswordPage);
}



void
SafeModePasswordPage::OnInit()
{
   LOG_FUNCTION(SafeModePasswordPage::OnInit);

   // NTRAID#NTBUG9-202238-2000/11/07-sburns
   
   password.Init(Win::GetDlgItem(hwnd, IDC_PASSWORD));
   confirm.Init(Win::GetDlgItem(hwnd, IDC_CONFIRM));
   
   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      EncodedString pwd =
         state.GetEncodedAnswerFileOption(
            State::OPTION_SAFE_MODE_ADMIN_PASSWORD);
         
      Win::SetDlgItemText(hwnd, IDC_PASSWORD, pwd);
      Win::SetDlgItemText(hwnd, IDC_CONFIRM, pwd);
   }
}



bool
SafeModePasswordPage::OnSetActive()
{
   LOG_FUNCTION(SafeModePasswordPage::OnSetActive);
   
   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      if (
            (  state.GetRunContext() == State::BDC_UPGRADE
            || state.GetRunContext() == State::PDC_UPGRADE)
         && !state.IsSafeModeAdminPwdOptionPresent())
      {
         // If you are upgrading a downlevel DC, and running unattended, then
         // you must specify a safemode password.  In a non-upgrade case, if
         // the user does not specify a safemode password, we pass a flag to
         // the promote APIs to copy the current user's password as the
         // safemode password.  In the upgrade case, the system is running
         // under a bogus account with a random password, so copying that
         // random password would be a bad idea.  So we force the user to
         // supply a password.

         state.ClearHiddenWhileUnattended();
         popup.Gripe(
            hwnd,
            IDC_PASSWORD,
            IDS_SAFEMODE_PASSWORD_REQUIRED);
      }
      else
      {         
         int nextPage = Validate();
         if (nextPage != -1)
         {
            GetWizard().SetNextPageID(hwnd, nextPage);
         }
         else
         {
            state.ClearHiddenWhileUnattended();
         }
      }
   }

   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK | PSWIZB_NEXT);

   return true;
}



int
SafeModePasswordPage::Validate()
{
   LOG_FUNCTION(SafeModePasswordPage::Validate);

   EncodedString password =
      Win::GetEncodedDlgItemText(hwnd, IDC_PASSWORD);
   EncodedString confirm  =
      Win::GetEncodedDlgItemText(hwnd, IDC_CONFIRM);

   if (password != confirm)
   {
      String blank;
      Win::SetDlgItemText(hwnd, IDC_PASSWORD, blank);
      Win::SetDlgItemText(hwnd, IDC_CONFIRM, blank);
      popup.Gripe(
         hwnd,
         IDC_PASSWORD,
         IDS_PASSWORD_MISMATCH);
      return -1;
   }

   State& state = State::GetInstance();
   state.SetSafeModeAdminPassword(password);

   return IDD_CONFIRMATION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\safemode.hpp ===
// Copyright (C) 1999 Microsoft Corporation
//
// Safe Mode Administrator password page
//
// 6-3-99 sburns



#ifndef SAFEMODE_HPP_INCLUDED
#define SAFEMODE_HPP_INCLUDED



#include "page.hpp"
#include "PasswordEditBox.hpp"



class SafeModePasswordPage : public DCPromoWizardPage
{
   public:

   SafeModePasswordPage();

   protected:

   virtual ~SafeModePasswordPage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed
   SafeModePasswordPage(const SafeModePasswordPage&);
   const SafeModePasswordPage& operator=(const SafeModePasswordPage&);

   // NTRAID#NTBUG9-202238-2000/11/07-sburns
   
   PasswordEditBox password;
   PasswordEditBox confirm;
};



#endif   // SAFEMODE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\shortcut.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Post-operation shortcut (shell link) code
//
// 1 Dec 1999 sburns



#ifndef SHORTCUT_HPP_INCLUDED
#define SHORTCUT_HPP_INCLUDED



// add/remove shortcuts appropriately for a newly-promoted domain controller.

void
PromoteConfigureToolShortcuts(ProgressDialog& dialog);



// add/remove shortcuts appropriately for a newly-demoted domain controller.
// (the inverse of PromoteConfigureToolShortcuts)

void
DemoteConfigureToolShortcuts(ProgressDialog& dialog);



#endif   // SHORTCUT_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\syskeydiskdialog.cpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// get syskey on diskette for replica from media page
//
// 25 Apr 2000 sburns



#include "headers.hxx"
#include "resource.h"
#include "page.hpp"
#include "SyskeyDiskDialog.hpp"
#include "state.hpp"



static const DWORD HELP_MAP[] =
{
   0, 0
};



SyskeyDiskDialog::SyskeyDiskDialog()
   :
   Dialog(IDD_SYSKEY_DISK, HELP_MAP)
{
   LOG_CTOR(SyskeyDiskDialog);
}



SyskeyDiskDialog::~SyskeyDiskDialog()
{
   LOG_DTOR(SyskeyDiskDialog);
}



void
SyskeyDiskDialog::OnInit()
{
   LOG_FUNCTION(SyskeyDiskDialog::OnInit);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      if (Validate())
      {
         Win::EndDialog(hwnd, IDOK);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }
}



bool
SyskeyDiskDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIdFrom,
   unsigned    code)
{
//   LOG_FUNCTION(SyskeyDiskDialog::OnCommand);

   switch (controlIdFrom)
   {
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            if (Validate())
            {
               Win::EndDialog(hwnd, controlIdFrom);
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            Win::EndDialog(hwnd, controlIdFrom);
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



HRESULT
LocateSyskey(HWND hwnd)
{
   LOG_FUNCTION(LocateSyskey);
   ASSERT(Win::IsWindow(hwnd));

   HRESULT hr = S_OK;

   do
   {
      if (FS::PathExists(L"A:\\StartKey.Key"))
      {
         LOG(L"syskey found on a:");

         break;
      }

      hr = E_FAIL;
      popup.Error(hwnd, IDS_SYSKEY_NOT_FOUND);
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



bool
SyskeyDiskDialog::Validate()
{
   LOG_FUNCTION(SyskeyDiskDialog::Validate);

   State& state = State::GetInstance();

   bool result = false;

   do
   {
      // look for the syskey

      HRESULT hr = LocateSyskey(hwnd);

      if (FAILED(hr))
      {
         // LocateSyskey will take care of emitting error messages, so
         // we just need to bail out here

         break;
      }

      // The only drive the syskey may be present on is A:.

      EncodedString es;
      es.Encode(L"A:");
      state.SetSyskey(es);
      result = true;
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\syskeypromptdialog.cpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// get syskey for replica from media page
//
// 25 Apr 2000 sburns



#include "headers.hxx"
#include "resource.h"
#include "page.hpp"
#include "SyskeyPromptDialog.hpp"
#include "state.hpp"



static const DWORD HELP_MAP[] =
{
   0, 0
};



SyskeyPromptDialog::SyskeyPromptDialog()
   :
   Dialog(IDD_SYSKEY_PROMPT, HELP_MAP)

{
   LOG_CTOR(SyskeyPromptDialog);
}



SyskeyPromptDialog::~SyskeyPromptDialog()
{
   LOG_DTOR(SyskeyPromptDialog);
}



void
SyskeyPromptDialog::OnInit()
{
   LOG_FUNCTION(SyskeyPromptDialog::OnInit);

   Win::Edit_LimitText(Win::GetDlgItem(hwnd, IDC_SYSKEY), PWLEN);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      EncodedString option =
         state.GetEncodedAnswerFileOption(State::OPTION_SYSKEY);
      if (!option.IsEmpty())
      {
         Win::SetDlgItemText(hwnd, IDC_SYSKEY, option);
      }
   }

   if (state.RunHiddenUnattended())
   {
      if (Validate())
      {
         Win::EndDialog(hwnd, IDOK);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }
   }
}



bool
SyskeyPromptDialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIdFrom,
   unsigned    code)
{
//   LOG_FUNCTION(SyskeyPromptDialog::OnCommand);

   switch (controlIdFrom)
   {
      case IDC_SYSKEY:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIdFrom);
            return true;
         }
         break;
      }
      case IDOK:
      {
         if (code == BN_CLICKED)
         {
            if (Validate())
            {
               Win::EndDialog(hwnd, controlIdFrom);
            }
         }
         break;
      }
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            Win::EndDialog(hwnd, controlIdFrom);
         }
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return false;
}



bool
SyskeyPromptDialog::Validate()
{
   LOG_FUNCTION(SyskeyPromptDialog::Validate);

   State& state = State::GetInstance();

   bool result = false;

   do
   {
      EncodedString syskey =
         Win::GetEncodedDlgItemText(hwnd, IDC_SYSKEY);

      if (syskey.IsEmpty())
      {
         popup.Gripe(hwnd, IDC_SYSKEY, IDS_MUST_ENTER_SYSKEY);
         break;
      }

      state.SetSyskey(syskey);
      result = true;
   }
   while (0);

   LOG(result ? L"true" : L"false");

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\syskeypromptdialog.hpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// get syskey from user for replica from media page
//
// 25 Apr 2000 sburns



#ifndef SYSKEYPROMPTDIALOG_HPP_INCLUDED
#define SYSKEYPROMPTDIALOG_HPP_INCLUDED



class SyskeyPromptDialog : public Dialog
{
   public:

   SyskeyPromptDialog();

   virtual ~SyskeyPromptDialog();

   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   bool
   Validate();

   // not defined; no copying allowed

   SyskeyPromptDialog(const SyskeyPromptDialog&);
   const SyskeyPromptDialog& operator=(const SyskeyPromptDialog&);
};



#endif   // SYSKEYPROMPTDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\syskeydiskdialog.hpp ===
// Copyright (C) 1997-2000 Microsoft Corporation
//
// get syskey on diskette for replica from media page
//
// 25 Apr 2000 sburns



#ifndef SYSKEYDISKDIALOG_HPP_INCLUDED
#define SYSKEYDISKDIALOG_HPP_INCLUDED



class SyskeyDiskDialog : public Dialog
{
   public:

   SyskeyDiskDialog();

   virtual ~SyskeyDiskDialog();

   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   bool
   Validate();

   // not defined; no copying allowed

   SyskeyDiskDialog(const SyskeyDiskDialog&);
   const SyskeyDiskDialog& operator=(const SyskeyDiskDialog&);
};



#endif   // SYSKEYDISKDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\shortcut.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Post-operation shortcut (shell link) code
//
// 1 Dec 1999 sburns



#include "headers.hxx"
#include "ProgressDialog.hpp"
#include "state.hpp"
#include "resource.h"




// @@ need to make sure that, when deleting shortcuts, we consider the case
// were the shortcuts may have been added by the adminpak from the 5.0 release
// of the product, not by ourselves in a later release.
//
// This case is: promote with version 5.0, upgrade to later version, demote



struct ShortcutParams
{
   int            linkNameResId;
   int            descResId;
   const wchar_t* target;
   const wchar_t* params;
   const wchar_t* iconDll;
};



// "Add" from the point of view of promotion: these are removed on demotion.

static ShortcutParams shortcutsToAdd[] =
   {
      {
         // Active Directory Sites and Services

         IDS_DS_SITE_LINK,
         IDS_DS_SITE_DESC,
         L"dssite.msc",
         L"",

         // the .msc file contains the proper icon, so we don't need to
         // specify a dll from whence to retrieve an icon.

         L""   
      },
      {
         // Active Directory Users and Computers

         IDS_DS_USERS_LINK,
         IDS_DS_USERS_DESC,
         L"dsa.msc",
         L"",
         L""
      },
      {
         // Active Directory Domains and Trusts

         IDS_DS_DOMAINS_LINK,
         IDS_DS_DOMAINS_DESC,
         L"domain.msc",
         L"",
         L""
      },
      {
         // Domain Controller Security Policy

         // if you change this name, be sure to change the code in
         // PromoteConfigureToolShortcuts too
        
         IDS_DC_POLICY_LINK,
         
         IDS_DC_POLICY_DESC,
         L"dcpol.msc",
         L"",
         L""
      },
      {
         // Domain Security Policy         

         // if you change this name, be sure to change the code in
         // PromoteConfigureToolShortcuts too
         
         IDS_DOMAIN_POLICY_LINK,
         IDS_DOMAIN_POLICY_DESC,
         L"dompol.msc",
         L"",
         L""
      }
   };



// "Delete" from the point of view of promotion: these are added back again
// on demotion.

static ShortcutParams shortcutsToDelete[] =
   {
      {
         // Local Security Policy

         IDS_LOCAL_POLICY_LINK,
         IDS_LOCAL_POLICY_DESC,
         L"secpol.msc",
         L"/s",
         L"wsecedit.dll"
      }
   };



// Extracts the target of a shortcut: that to which the shortcut points.
// Returns S_OK on success, and sets result to that target.  On error, a COM
// error code is returned and result is empty.
// 
// shellLink - pointer to instance of object implementing IShellLink, which
// has been associated with a shortcut file.
// 
// result - receives the result -- the shortcut target path -- on sucess.

HRESULT
GetShortcutTargetPath(
   const SmartInterface<IShellLink>&   shellLink,
   String&                             result)
{
   LOG_FUNCTION(GetShortcutTargetPath);
   ASSERT(shellLink);

   result.erase();

   wchar_t target[MAX_PATH + 1];
   memset(&target, 0, sizeof(wchar_t) * (MAX_PATH + 1));

   HRESULT hr = shellLink->GetPath(target, MAX_PATH, 0, SLGP_SHORTPATH);

   if (SUCCEEDED(hr))
   {
      result = target;
   }

   return hr;
}



// Return true if the supplied target of a shortcut is such that it identifies
// the shortcut as one of those installed on promote.  Return false if not one
// such.
// 
// target - target path of the shortcut (i.e. path to that which the shortcut
// points)

bool
IsAdminpakShortcut(const String& target)
{
   LOG_FUNCTION2(IsAdminpakShortcut, target);

   // don't assert that target has a value. Some shortcuts don't, if they're
   // broken.
   // 
   // ASSERT(!target.empty());

   // If the target is of the form %systemroot%\Installer\{guid}\foo.ico,
   // then it is one of the adminpak dcpromo shortcuts.

   static String baseNames[] =
      {
         L"DTMgmt.ico",
         L"ADSSMgr.ico",
         L"ADMgr.ico",
         L"ADDcPol.ico",
         L"ADDomPol.ico"
      };

   static String root(Win::GetSystemWindowsDirectory() + L"\\Installer\\{");

   bool result = false;

   String prefix(target, 0, root.length());
   if (root.icompare(prefix) == 0)
   {
      // the prefix matches.

      String leaf = FS::GetPathLeafElement(target);
      for (int i = 0; i < (sizeof(baseNames) / sizeof(String)) ; ++i)
      {
         if (leaf.icompare(baseNames[i]) == 0)
         {
            result = true;
            break;
         }
      }
   }

   LOG(
      String::format(
         L"%1 an adminpak shortcut",
         result ? L"is" : L"is not"));

   return result;
}



bool
IsPromoteToolShortcut(const String& target)
{
   LOG_FUNCTION2(IsPromoteToolShortcut, target);
   ASSERT(!target.empty());

   // Check target against the values we used to create the shortcuts.  The
   // values we used specified a fully-qualified path to the system32 folder,
   // and we will compare the target to the full path.

   String targetPrefix = Win::GetSystemDirectory() + L"\\";

   for (
      int i = 0;
      i < sizeof(shortcutsToAdd) / sizeof(ShortcutParams);
      ++i)
   {
      if (target.icompare(targetPrefix + shortcutsToAdd[i].target) == 0)
      {
         return true;
      }
   }

   return false;
}



// Return true if the given shortcut one of those installed on promote.
// Return false if not one of those shortcuts, or on error.
// 
// shellLink - smart interface pointer to an object implementing IShellLink.
// 
// lnkPath - full file path of the shortcut (.lnk) file to be evaluated.

bool
ShouldDeleteShortcut(
   const SmartInterface<IShellLink>&   shellLink,
   const String&                       lnkPath)
{
   LOG_FUNCTION2(ShouldDeleteShortcut, lnkPath);
   ASSERT(!lnkPath.empty());
   ASSERT(shellLink);

   // Shortcut file names are localized, so we can't delete them based on
   // their names.  idea:  Open the shortcut, see what it's target is,
   // and based on that, determine if it's one we should delete.

   HRESULT hr = S_OK;
   bool result = false;
   do
   {
      // Load the shortcut file

      SmartInterface<IPersistFile> ipf;
      hr = ipf.AcquireViaQueryInterface(shellLink);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = ipf->Load(lnkPath.c_str(), STGM_READ);
      BREAK_ON_FAILED_HRESULT(hr);

      // Get the target lnkPath

      String target;
      hr = GetShortcutTargetPath(shellLink, target);
      BREAK_ON_FAILED_HRESULT(hr);

      if (IsAdminpakShortcut(target))
      {
         result = true;
         break;
      }

      // Not an adminpak shortcut.  Might be one of the ones created by
      // PromoteConfigureToolShortcuts (ourselves).

      if (IsPromoteToolShortcut(target))
      {
         result = true;
         break;
      }

      // if we make it here, the shortcut is not one we should delete.
   }
   while (0);

   LOG(
      String::format(
         L"%1 delete shortcut",
         result ? L"should" : L"should not"));

   return result;
}



HRESULT
CreateShortcut(
   const SmartInterface<IShellLink>&   shellLink,
   const String&                       destFolderPath,
   int                                 linkNameResId,
   int                                 descResId,
   const String&                       target,
   const String&                       params,
   const String&                       iconDll)
{
   LOG_FUNCTION2(CreateShortcut, target);
   ASSERT(shellLink);
   ASSERT(!destFolderPath.empty());
   ASSERT(!target.empty());
   ASSERT(linkNameResId);
   ASSERT(descResId);

   // params and iconDll may be empty

   HRESULT hr = S_OK;
   do
   {
      String sys32Folder = Win::GetSystemDirectory();
      String targetPath = sys32Folder + L"\\" + target;

      hr = shellLink->SetPath(targetPath.c_str());
      BREAK_ON_FAILED_HRESULT(hr);

      hr = shellLink->SetWorkingDirectory(sys32Folder.c_str());
      BREAK_ON_FAILED_HRESULT(hr);

      hr = shellLink->SetDescription(String::load(descResId).c_str());
      BREAK_ON_FAILED_HRESULT(hr);

      hr = shellLink->SetArguments(params.c_str());
      BREAK_ON_FAILED_HRESULT(hr);

      if (!iconDll.empty())
      {
         hr =
            shellLink->SetIconLocation(
               (sys32Folder + L"\\" + iconDll).c_str(), 0);
      }

      SmartInterface<IPersistFile> ipf;
      hr = ipf.AcquireViaQueryInterface(shellLink);
      BREAK_ON_FAILED_HRESULT(hr);

      String destPath =
         destFolderPath + L"\\" + String::load(linkNameResId) + L".lnk";

      hr = ipf->Save(destPath.c_str(), TRUE);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   LOG_HRESULT(hr);
      
   return hr;
}



HRESULT
DeleteShortcut(
   const String& folder,
   int           linkNameResId)
{
   LOG_FUNCTION(DeleteShortcut);
   ASSERT(!folder.empty());
   ASSERT(linkNameResId);
      
   HRESULT hr = S_OK;
   do
   {     
      String linkPath =
         folder + L"\\" + String::load(linkNameResId) + L".lnk";

      LOG(linkPath);

      if (FS::PathExists(linkPath))
      {
         hr = Win::DeleteFile(linkPath);
         BREAK_ON_FAILED_HRESULT(hr);
      }
   }
   while (0);

   return hr;
}



// Remove the shortcuts to the DS administration tools that were installed on
// promote.

void
DemoteConfigureToolShortcuts(ProgressDialog& dialog)
{
   LOG_FUNCTION(DemoteConfigureToolShortcuts);

   HRESULT hr = S_OK;
   State& state = State::GetInstance();
   do
   {
      String path = state.GetAdminToolsShortcutPath();
      if (path.empty())
      {
         // We were unable to determine the path at startup.

         hr = Win32ToHresult(ERROR_PATH_NOT_FOUND);
         break;
      }

      // (may) Need to init com for this thread.  

      hr = ::CoInitialize(0);
      BREAK_ON_FAILED_HRESULT(hr);
               
      SmartInterface<IShellLink> shellLink;
      hr =
         shellLink.AcquireViaCreateInstance(
            CLSID_ShellLink,
            0,
            CLSCTX_INPROC_SERVER);
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(L"enumerating shortcuts");

      FS::Iterator iter(
         path + L"\\*.lnk",
            FS::Iterator::INCLUDE_FILES
         |  FS::Iterator::RETURN_FULL_PATHS);

      String current;
      while ((hr = iter.GetCurrent(current)) == S_OK)
      {
         if (ShouldDeleteShortcut(shellLink, current))
         {
            LOG(String::format(L"Deleting %1", current.c_str()));

            // we don't bail out on an error here because we want to
            // try to delete as many shortcuts as possible.

            HRESULT unused = Win::DeleteFile(current);
            LOG_HRESULT(unused);
         }

         hr = iter.Increment();
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // add the shortcut(s) removed during promote

      for (
         int i = 0;
         i < sizeof(shortcutsToDelete) / sizeof(ShortcutParams);
         ++i)
      {
         // don't break on error -- push on to attempt to create the
         // entire set.

         CreateShortcut(
            shellLink,
            path,
            shortcutsToDelete[i].linkNameResId,
            shortcutsToDelete[i].descResId,
            shortcutsToDelete[i].target,
            shortcutsToDelete[i].params,
            shortcutsToDelete[i].iconDll);
      }
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         dialog.GetHWND(),
         hr,
         IDS_ERROR_CONFIGURING_SHORTCUTS);
      state.AddFinishMessage(
         String::load(IDS_SHORTCUTS_NOT_CONFIGURED));
   }
}



// Take a domain name in canonical (dotted) form, e.g. domain.foo.com, and
// translate it to the fully-qualified DN form, e.g. DC=domain,DC=foo,DC=com
//
// domainCanonical - in, domain name in canonical form
//
// domainDN - out, domain name in DN form

HRESULT
CannonicalToDn(const String& domainCanonical, String& domainDN)
{
   LOG_FUNCTION2(CannonicalToDn, domainCanonical);
   ASSERT(!domainCanonical.empty());

   domainDN.erase();
   HRESULT hr = S_OK;
   
   do
   {
      if (domainCanonical.empty())
      {
         hr = E_INVALIDARG;
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // add a trailing '/' to signal DsCrackNames to do a syntactical
      // munge of the string, rather than hit the wire.

      // add 1 for the null terminator, 1 for the trailing '/'
      
      PWSTR name = new WCHAR[domainCanonical.length() + 2];
      memset(name, 0, (domainCanonical.length() + 2) * sizeof(WCHAR));
      domainCanonical.copy(name, domainCanonical.length());
      name[domainCanonical.length()] = L'/';
      
      DS_NAME_RESULT* nameResult = 0;
      hr =
         Win32ToHresult(
            ::DsCrackNames(

               // no handle: this is a string munge
               
               reinterpret_cast<void*>(-1),
               
               DS_NAME_FLAG_SYNTACTICAL_ONLY,
               DS_CANONICAL_NAME,
               DS_FQDN_1779_NAME,
               1,
               &name,
               &nameResult));
      delete[] name;
      BREAK_ON_FAILED_HRESULT(hr);      

      ASSERT(nameResult);
      if (nameResult)
      {
         ASSERT(nameResult->cItems == 1);
         DS_NAME_RESULT_ITEM* items = nameResult->rItems;

         LOG(String::format(L"status : 0x%1!X!", items[0].status));
         LOG(String::format(L"pDomain: %1", items[0].pDomain));
         LOG(String::format(L"pName  : %1", items[0].pName));

         ASSERT(items[0].status == DS_NAME_NO_ERROR);

         if (items[0].pName)
         {
            domainDN = items[0].pName;
         }
         if (domainDN.empty())
         {
            hr = E_FAIL;
         }
         ::DsFreeNameResult(nameResult);
      }
   }
   while (0);

   LOG_HRESULT(hr);
   
   return hr;
}
    

    
// Create all the admin tools shortcuts that are needed after a promote.
//
// path - in, where to create the shortcuts
//
// shellLink - in, initialized shellLink interface to create the shortcuts
// with.

HRESULT
PromoteCreateShortcuts(const String& path, SmartInterface<IShellLink>& shellLink)
{
   LOG_FUNCTION(PromoteCreateShortcuts);
   ASSERT(!path.empty());
   ASSERT(shellLink);

   HRESULT hr = S_OK;

   do
   {
      State& state = State::GetInstance();

      // for the policy shortcuts, we will need to know the domain DN, so
      // determine that here.  
      // NTRAID#NTBUG9-232442-2000/11/15-sburns
      
      String domainCanonical;
      State::Operation oper = state.GetOperation();
      if (
            oper == State::FOREST
         || oper == State::TREE
         || oper == State::CHILD)
      {
         domainCanonical = state.GetNewDomainDNSName();
      }
      else if (oper == State::REPLICA)
      {
         domainCanonical = state.GetReplicaDomainDNSName();
      }
      else
      {
         // we should not be calling this function on non-promote scenarios
      
         ASSERT(false);
         hr = E_FAIL;
         BREAK_ON_FAILED_HRESULT(hr);
      }
   
      String domainDn;
      bool skipPolicyShortcuts = false;

      hr = CannonicalToDn(domainCanonical, domainDn);
      if (FAILED(hr))
      {
         LOG(L"skipping install of policy shortcuts");
         skipPolicyShortcuts = true;
      }

      for (
         int i = 0;
         i < sizeof(shortcutsToAdd) / sizeof(ShortcutParams);
         ++i)
      {
         // set the correct parameters for domain and dc security policy tools.
      
         String params;
      
         if (shortcutsToAdd[i].linkNameResId == IDS_DC_POLICY_LINK)
         {
            if (skipPolicyShortcuts)
            {
               continue;
            }
         
            params =
               String::format(
                  L"/gpobject:\"LDAP://CN={%1},CN=Policies,CN=System,%2\"",
                  STR_DEFAULT_DOMAIN_CONTROLLER_GPO_GUID,
                  domainDn.c_str());
         }
         else if (shortcutsToAdd[i].linkNameResId == IDS_DOMAIN_POLICY_LINK)
         {
            if (skipPolicyShortcuts)
            {
               continue;
            }

            params =
               String::format(
                  L"/gpobject:\"LDAP://CN={%1},CN=Policies,CN=System,%2\"",
                  STR_DEFAULT_DOMAIN_GPO_GUID,
                  domainDn.c_str());
         }
         else
         {
            params = shortcutsToAdd[i].params;
         }

         // don't break on errors -- push on to attempt to create the
         // entire set.
   
         CreateShortcut(
            shellLink,
            path,
            shortcutsToAdd[i].linkNameResId,
            shortcutsToAdd[i].descResId,
            shortcutsToAdd[i].target,
            params,
            shortcutsToAdd[i].iconDll);
      }
   }
   while (0);

   LOG_HRESULT(hr);
      
   return hr;      
}



void
PromoteConfigureToolShortcuts(ProgressDialog& dialog)
{
   LOG_FUNCTION(PromoteConfigureToolShortcuts);

   dialog.UpdateText(String::load(IDS_CONFIGURING_SHORTCUTS));

   HRESULT hr = S_OK;
   State& state = State::GetInstance();

   do
   {
      String path = state.GetAdminToolsShortcutPath();
      if (path.empty())
      {
         // We were unable to determine the path at startup.

         hr = Win32ToHresult(ERROR_PATH_NOT_FOUND);
         break;
      }

      // Need to init com for this thread.  

      hr = ::CoInitialize(0);
      BREAK_ON_FAILED_HRESULT(hr);
               
      SmartInterface<IShellLink> shellLink;
      hr =
         shellLink.AcquireViaCreateInstance(
            CLSID_ShellLink,
            0,
            CLSCTX_INPROC_SERVER);
      BREAK_ON_FAILED_HRESULT(hr);

      // add the shortcuts to the ds administration tools

      PromoteCreateShortcuts(path, shellLink);

      // remove the shortcuts to local tools

      for (
         int i = 0;
         i < sizeof(shortcutsToDelete) / sizeof(ShortcutParams);
         ++i)
      {
         // don't break on error -- push on to attempt to delete the
         // entire set.

         DeleteShortcut(
            path,
            shortcutsToDelete[i].linkNameResId);
      }
   }
   while (0);

   if (FAILED(hr))
   {
      popup.Error(
         dialog.GetHWND(),
         hr,
         IDS_ERROR_CONFIGURING_SHORTCUTS);
      state.AddFinishMessage(
         String::load(IDS_SHORTCUTS_NOT_CONFIGURED));
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\treepage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new tree page
//
// 1-7-98 sburns



#include "headers.hxx"
#include "page.hpp"
#include "TreePage.hpp"
#include "resource.h"
#include "state.hpp"
#include "common.hpp"
#include "dns.hpp"



TreePage::TreePage()
   :
   DCPromoWizardPage(
      IDD_NEW_TREE,
      IDS_TREE_PAGE_TITLE,
      IDS_TREE_PAGE_SUBTITLE)
{
   LOG_CTOR(TreePage);
}



TreePage::~TreePage()
{
   LOG_DTOR(TreePage);
}



void
TreePage::OnInit()
{
   LOG_FUNCTION(TreePage::OnInit);

   Win::Edit_LimitText(
      Win::GetDlgItem(hwnd, IDC_DOMAIN),
      DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY);

   State& state = State::GetInstance();
   if (state.UsingAnswerFile())
   {
      // this will cause IDC_DOMAIN to be marked changed, so the validation
      // code will be called.
      Win::SetDlgItemText(
         hwnd,
         IDC_DOMAIN,
         state.GetAnswerFileOption(
            State::OPTION_NEW_DOMAIN_NAME));
   }
}



static
void
enable(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int next =
      !Win::GetTrimmedDlgItemText(dialog, IDC_DOMAIN).empty()
      ? PSWIZB_NEXT
      : 0;

   Win::PropSheet_SetWizButtons(
      Win::GetParent(dialog),
      PSWIZB_BACK | next);
}



bool
TreePage::OnSetActive()
{
   LOG_FUNCTION(TreePage::OnSetActive);
   ASSERT(State::GetInstance().GetOperation() == State::TREE);
      
   Win::PropSheet_SetWizButtons(
      Win::GetParent(hwnd),
      PSWIZB_BACK);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   enable(hwnd);
   return true;
}



bool
TreePage::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    controlIDFrom,
   unsigned    code)
{
//   LOG_FUNCTION(TreePage::OnCommand);

   switch (controlIDFrom)
   {
      case IDC_DOMAIN:
      {
         if (code == EN_CHANGE)
         {
            SetChanged(controlIDFrom);            
            enable(hwnd);
         }
         break;
      }
      default:
      {
         // do nothing
         break;
      }
   }

   return false;
}



int
TreePage::Validate()
{
   LOG_FUNCTION(TreePage::Validate);

   String domain = Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN);
   if (domain.empty())
   {
      popup.Gripe(hwnd, IDC_DOMAIN, IDS_MUST_ENTER_DOMAIN);
      return -1;
   }

   State& state = State::GetInstance();
   int nextPage =
         state.GetRunContext() == State::PDC_UPGRADE
      ?  IDD_PATHS
      :  IDD_NETBIOS_NAME;

   // SPB:251431 do validation even if this page is untouched, as upstream
   // pages may have been changed in such a fashion that re-validation is
   // required.
   // if (!WasChanged(IDC_DOMAIN))
   // {
   //    return nextPage;
   // }

   do
   {
      // verify that the new domain name is properly formatted and does
      // not exist.

      if (
            !ValidateDomainDnsNameSyntax(hwnd, IDC_DOMAIN, true)
         || !ConfirmNetbiosLookingNameIsReallyDnsName(hwnd, IDC_DOMAIN)

            // do this test last, as it is expensive
            
         || !ValidateDomainDoesNotExist(hwnd, IDC_DOMAIN) )
      {
         break;
      }

      domain = Win::GetTrimmedDlgItemText(hwnd, IDC_DOMAIN);
      String conflictingDomain;
      switch (state.DomainFitsInForest(domain, conflictingDomain))
      {
         case DnsNameCompareLeftParent:
         {
            // can't encompass another tree

            popup.Gripe(
               hwnd,
               IDC_DOMAIN,
               String::format(
                  IDS_SUPERIOR_TO_TREE,
                  domain.c_str(),
                  conflictingDomain.c_str()));
            break;
         }
         case DnsNameCompareRightParent:
         {
            // should be a child domain instead

            popup.Gripe(
               hwnd,
               IDC_DOMAIN,
               String::format(
                  IDS_INFERIOR_TO_TREE,
                  domain.c_str(),
                  conflictingDomain.c_str()));
            break;
         }
         case DnsNameCompareEqual:
         {
            // shouldn't happen, ValidateDomainDNSName call above would
            // have caught it.

            ASSERT(false);
            popup.Gripe(
               hwnd,
               IDC_DOMAIN,
               String::format(IDS_DOMAIN_NAME_IN_USE, domain.c_str()));
            break;
         }
         case DnsNameCompareInvalid:
         {
            // shouldn't happen, ValidateDomainDNSName call above would
            // have caught it.

            ASSERT(false);
            popup.Gripe(
               hwnd,
               IDC_DOMAIN,
               String::format(
                  IDS_BAD_DNS_SYNTAX,
                  domain.c_str(),
                  Dns::MAX_LABEL_LENGTH));
            break;
         }
         case DnsNameCompareNotEqual:
         {
            // valid

            ClearChanges();
            state.SetParentDomainDNSName(state.GetUserForestName());
            state.SetNewDomainDNSName(domain);
            return nextPage;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }
   }
   while (0);

   return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\state.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// wizard state object
//
// 12-15-97 sburns



#include "headers.hxx"
#include "state.hpp"
#include "resource.h"
#include "ds.hpp"
#include "common.hpp"



static const String SECTION_NAME(L"DCInstall");
const String State::OPTION_NEW_DOMAIN_NAME(L"NewDomainDNSName");
const String State::OPTION_SITE_NAME(L"SiteName");
const String State::OPTION_PARENT_DOMAIN_NAME(L"ParentDomainDNSName");
const String State::OPTION_CHILD_NAME(L"ChildName");

const String State::OPTION_DNS_ON_NET(L"DNSOnNetwork");

const String State::OPTION_REPLICA_OR_NEW_DOMAIN(L"ReplicaOrNewDomain");
const String State::VALUE_DOMAIN(L"Domain");

const String State::OPTION_REPLICA_OR_MEMBER(L"ReplicaOrMember");
const String State::VALUE_REPLICA(L"Replica");

const String State::OPTION_NEW_DOMAIN(L"NewDomain");
const String State::VALUE_CHILD(L"Child");
const String State::VALUE_TREE(L"Tree");

const String State::OPTION_NEW_DOMAIN_NETBIOS_NAME(L"DomainNetbiosName");
const String State::OPTION_DATABASE_PATH(L"DatabasePath");
const String State::OPTION_LOG_PATH(L"LogPath");
const String State::OPTION_SYSVOL_PATH(L"SYSVOLPath");
const String State::OPTION_REPLICA_DOMAIN_NAME(L"ReplicaDomainDNSName");

const String State::OPTION_IS_LAST_DC(L"IsLastDCInDomain");
const String State::VALUE_YES(L"Yes");
const String State::VALUE_NO(L"No");

const String State::OPTION_ADMIN_PASSWORD(L"AdministratorPassword");
const String State::OPTION_REBOOT(L"RebootOnSuccess");
const String State::VALUE_NO_DONT_PROMPT(L"NoAndNoPromptEither");

const String State::OPTION_USERNAME(L"UserName");
const String State::OPTION_PASSWORD(L"Password");
const String State::OPTION_USER_DOMAIN(L"UserDomain");

const String State::OPTION_AUTO_CONFIG_DNS(L"AutoConfigDNS");

const String State::OPTION_ALLOW_ANON_ACCESS(L"AllowAnonymousAccess");
const String State::OPTION_REPLICATION_SOURCE(L"ReplicationSourceDC");
const String State::OPTION_SAFE_MODE_ADMIN_PASSWORD(L"SafeModeAdminPassword");
const String State::OPTION_CRITICAL_REPLICATION_ONLY(L"CriticalReplicationOnly");

const String State::OPTION_SOURCE_PATH(L"ReplicationSourcePath");
const String State::OPTION_SYSKEY(L"Syskey");
const String State::OPTION_GC_CONFIRM(L"ConfirmGc");
const String State::OPTION_SET_FOREST_VERSION("SetForestVersion");



static State* stateInstance;



void
State::Init()
{
   ASSERT(!stateInstance);

   stateInstance = new State;
}



void
State::Destroy()
{
   delete stateInstance;
};



State&
State::GetInstance()
{
   ASSERT(stateInstance);

   return *stateInstance;
}
   


// Determines the full file path of the folder where administration (incl. DS)
// tools shortcuts are placed.  On success, returns S_OK and sets result to
// the path.  On failure, returns a COM error and sets results to empty.
// 
// result - receives the folder path on success.

HRESULT
GetAdminToolsPath(String& result)
{
   LOG_FUNCTION(GetAdminToolsPath);

   result.erase();

   TCHAR buf[MAX_PATH];
   HRESULT hr =
      ::SHGetFolderPath(
         0,
         CSIDL_COMMON_ADMINTOOLS,
         0,
         SHGFP_TYPE_CURRENT,
         buf);

   if (SUCCEEDED(hr))
   {
      result = buf;
   }

   return hr;
}



State::State()
   :
   adminPassword(),
   allowAnonAccess(false),
   answerFile(0),
   autoConfigDns(false),
   computer(),
   context(),
   dbPath(),
   domainsInForest(),
   failureMessage(),
   finishMessages(),
   installedSite(),
   isAdvancedMode(false),
   isBackupGc(false),
   isDnsOnNet(true),
   isLastDc(false),
   isUpgrade(false),
   logPath(),
   needsCommandLineHelp(false),
   needsReboot(false),
   newDomainDnsName(),
   newDomainFlatName(),
   operation(NONE),
   operationResultsMessage(),
   operationResultsStatus(FAILURE),
   operationResultsFlags(0),
   parentDomainDnsName(),
   password(),
   reinstallDomain(false),
   reinstallDomainController(false),
   replicaDnsDomainName(),
   replicateFromMedia(false),
   replicationPartnerDc(),
   restoreGc(false),
   runHiddenWhileUnattended(true),
   safeModeAdminPassword(),
   setForestVersion(false),
   shortcutPath(),
   siteName(),
   splash(0),                     
   sourcePath(),
   sysvolPath(),
   syskey(),
   syskeyLocation(STORED),
   useCurrentCredentials(false),    
   userDomain(),
   userForest(),                
   username()
{
   LOG_CTOR(State);

   ArgMap args;
   MapCommandLineArgs(args);

   if (args.size() < 2)
   {
      LOG(L"no options specified");
   }
   else
   {
      // check for answerfile specification

      static const wchar_t* ANSWER1 = L"answer";
      static const wchar_t* ANSWER2 = L"u";
      static const wchar_t* ANSWER3 = L"upgrade";

      if (
            args.find(ANSWER1) != args.end()
         || args.find(ANSWER2) != args.end()
         || args.find(ANSWER3) != args.end() )
      {
         bool isDefaultAnswerfile = false;

         String filename = args[ANSWER1];
         if (filename.empty())
         {
            filename = args[ANSWER2];
         }
         if (filename.empty())
         {
            filename = args[ANSWER3];
         }
         if (filename.empty())
         {
            // default value if none specified

            filename = L"%systemdrive%\\dcpromo-ntupg.inf";

            // if this file does not exist, don't pop up an error message.

            isDefaultAnswerfile = true;
         }

         SetupAnswerFile(filename, isDefaultAnswerfile);

         args.erase(ANSWER1);
         args.erase(ANSWER2);
         args.erase(ANSWER3);
      }

      // check for /adv

      static const wchar_t* ADV = L"adv";

      if (args.find(ADV) != args.end())
      {
         LOG(L"Enabling advanced mode");

         isAdvancedMode = true;
         args.erase(ADV);
      }

      // anything left over gets you command line help, (one arg will always
      // remain: the name of the exe)

      if (args.size() > 1)
      {
         LOG(L"Unrecognized command line options specified");

         needsCommandLineHelp = true;
      }
   }

   HRESULT hr = computer.Refresh();

   // we're confident this will work, as the computer refers to the
   // local machine.

   ASSERT(SUCCEEDED(hr));
   LOG_HRESULT(hr);

   DetermineRunContext();

   // Disable locking of the console as early as possible to narrow the
   // window of opportunity for the user (or the system) to lock the
   // console before a valid machine security state is reached.  We do this
   // early only for upgrades, because upgrades autologon and autostart
   // dcpromo, and the console may sit idle for some time. 311161

   if (context == PDC_UPGRADE || context == BDC_UPGRADE)
   {
      DisableConsoleLocking();
   }

   // We must call this at startup, because once a demote operation is
   // complete, it may not be possible for the shell to determine this
   // path. 366738

   hr = GetAdminToolsPath(shortcutPath);
   ASSERT(SUCCEEDED(hr));
   LOG_HRESULT(hr);
}

           

void
State::SetupAnswerFile(const String& filename, bool isDefaultAnswerfile)
{
   LOG_FUNCTION2(State::SetupAnswerFile, filename);

   String f(filename);
   if (f.find(L"\\") == String::npos)
   {
      // GetPrivateProfileString requires a path: use the current directory
      // as a default path.

      f = L".\\" + filename;
   }

   LOG(L"answerfile specified: " + f);

   f = Win::ExpandEnvironmentStrings(f);

   LOG(L"answerfile resolved to: " + f);

   // we don't use FS::PathExist here because that function expects a
   // fully-qualified path.  The path we have may be relative.

   DWORD unused = 0;
   HRESULT hr = Win::GetFileAttributes(f, unused);
   if (SUCCEEDED(hr))
   {
      // file found.

      LOG(L"answerfile found");
      answerFile = new AnswerFile(f);

      splash = new UnattendSplashDialog();
      splash->ModelessExecute(Win::GetDesktopWindow());         
   }
   else
   {
      LOG(L"answerfile NOT found");

      if (!isDefaultAnswerfile)
      {
         popup.Error(
            Win::GetDesktopWindow(),
            String::format(IDS_ANSWERFILE_NOT_FOUND, f.c_str()));
      }
   }
}



#ifdef LOGGING_BUILD
   static const String CONTEXTS[] =
   {
      L"NT5_DC",
      L"NT5_STANDALONE_SERVER",
      L"NT5_MEMBER_SERVER",
      L"BDC_UPGRADE",
      L"PDC_UPGRADE"
   };
#endif



void
State::DetermineRunContext()
{
   LOG_FUNCTION(State::DetermineRunContext);

   DS::PriorServerRole priorRole = DS::GetPriorServerRole(isUpgrade);

   if (isUpgrade && priorRole != DS::UNKNOWN)
   {
      switch (priorRole)
      {
         case DS::PDC:
         {
            context = PDC_UPGRADE;
            break;
         }
         case DS::BDC:
         {
            context = BDC_UPGRADE;
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }
   }
   else
   {
      switch (computer.GetRole())
      {
         case Computer::STANDALONE_SERVER:
         {
            context = NT5_STANDALONE_SERVER;
            break;
         }
         case Computer::MEMBER_SERVER:
         {
            context = NT5_MEMBER_SERVER;
            break;
         }
         case Computer::PRIMARY_CONTROLLER:
         case Computer::BACKUP_CONTROLLER:
         {
            // we're already an NT5 DC
            context = NT5_DC;
            break;
         }
         case Computer::STANDALONE_WORKSTATION:
         case Computer::MEMBER_WORKSTATION:
         default:
         {
            // we checked for this at startup
            ASSERT(false);
            break;
         }
      }
   }

   LOG(CONTEXTS[context]);
}



State::~State()
{
   LOG_DTOR(State);

   delete answerFile;

   // closes the splash dialog, if visible.
   delete splash;
}



State::RunContext
State::GetRunContext() const
{
   LOG_FUNCTION2(State::GetRunContext, CONTEXTS[context]);

   return context;
}



bool
State::UsingAnswerFile() const
{
   return answerFile != 0;
}



bool
IsPasswordOption(const String& option)
{
   if (
         option.icompare(State::OPTION_PASSWORD) == 0
      || option.icompare(State::OPTION_ADMIN_PASSWORD) == 0
      || option.icompare(State::OPTION_SYSKEY) == 0 
      || option.icompare(State::OPTION_SAFE_MODE_ADMIN_PASSWORD) == 0)   // 142313
   {
      return true;
   }

   return false;
}
   


String
State::GetAnswerFileOption(const String& option) const
{
   LOG_FUNCTION2(GetAnswerFileOption, option);
   ASSERT(UsingAnswerFile());

   String result;
   if (answerFile)
   {
      result = answerFile->ReadKey(SECTION_NAME, option);

      // wipe out passwords as they are read.

      if (IsPasswordOption(option))
      {
         // caller should be using GetEncodedAnswerFileOption
         
         ASSERT(false);
         
         if (answerFile->IsKeyPresent(SECTION_NAME, option))
         {
            answerFile->WriteKey(SECTION_NAME, option, String());
         }
      }
      else
      {
         // only trace non-password fields.

         LOG(result);
      }
   }

   return result;
}



EncodedString
State::GetEncodedAnswerFileOption(const String& option) const
{
   LOG_FUNCTION2(GetEncodedAnswerFileOption, option);
   ASSERT(UsingAnswerFile());

   EncodedString result;
   if (answerFile)
   {
      result = answerFile->EncodedReadKey(SECTION_NAME, option);

      // wipe out passwords as they are read.

      if (IsPasswordOption(option))
      {
         if (answerFile->IsKeyPresent(SECTION_NAME, option))
         {
            answerFile->WriteKey(SECTION_NAME, option, String());
         }
      }
      else
      {
         // should only use the Encoded function for passwords
         
         ASSERT(false);
      }
   }

   return result;
}
   


#ifdef LOGGING_BUILD
   static const String OPERATIONS[] =
   {
      L"NONE",
      L"REPLICA",
      L"FOREST",
      L"TREE",
      L"CHILD",
      L"DEMOTE",
      L"ABORT_BDC_UPGRADE"
   };
#endif



void
State::SetOperation(Operation oper)
{
   LOG_FUNCTION2(State::SetOperation, OPERATIONS[oper]);

   operation = oper;
}



State::Operation
State::GetOperation() const
{
   LOG_FUNCTION2(State::GetOperation, OPERATIONS[operation]);

   // if aborting BDC upgrade, context must be BDC upgrade

   ASSERT(operation == ABORT_BDC_UPGRADE ? context == BDC_UPGRADE : true);

   return operation;
}



void
State::SetReplicaDomainDNSName(const String& dnsName)
{
   LOG_FUNCTION2(State:::SetReplicaDomainDNSName, dnsName);
   ASSERT(!dnsName.empty());

   replicaDnsDomainName = dnsName;

   // if the user is changing the domain to be replicated, then any
   // previous replication partner DC may no longer apply.
   // see ntbug9 #158726

   SetReplicationPartnerDC(L"");
}
   


String
State::GetDatabasePath() const
{
   LOG_FUNCTION2(State::GetDatabasePath, dbPath);

   return dbPath;
}   



String
State::GetLogPath() const
{
   LOG_FUNCTION2(State::GetLogPath, logPath);

   return logPath;
}



String
State::GetSYSVOLPath() const
{
   LOG_FUNCTION2(State::GetSYSVOLPath, sysvolPath);

   return sysvolPath;
}
 


void
State::SetDatabasePath(const String& path)
{
   LOG_FUNCTION2(State::SetDatabasePath, path);
   ASSERT(!path.empty());

   dbPath = path;
}

   

void
State::SetLogPath(const String& path)
{
   LOG_FUNCTION2(State::SetLogPath, path);
   ASSERT(!path.empty());

   logPath = path;
}



void
State::SetSYSVOLPath(const String& path)
{
   LOG_FUNCTION2(State::SetSYSVOLPath, path);
   ASSERT(!path.empty());

   sysvolPath = path;
}
   


String
State::GetUsername() const
{
   LOG_FUNCTION2(State::GetUsername, username);

   // don't assert that this is !empty -- we may use existing credentials

   return username;
}

   

EncodedString
State::GetPassword() const
{
   // don't log the password...

   LOG_FUNCTION(State::GetPassword);

   // don't assert that this is !empty -- we may use existing credentials

   return password;
}



void
State::SetUsername(const String& name)
{
   LOG_FUNCTION2(State::SetUsername, name);
   ASSERT(!name.empty());

   username = name;
}



void
State::SetPassword(const EncodedString& password_)
{
   LOG_FUNCTION(State::SetPassword);
   // password_ may be empty
//   ASSERT(!password_.empty());

   password = password_;
}



String
State::GetReplicaDomainDNSName() const
{
   LOG_FUNCTION2(
      State::GetReplicaDomainDNSName,
      replicaDnsDomainName);

   return replicaDnsDomainName;
}



String
State::GetSiteName() const
{
   LOG_FUNCTION2(State::GetSiteName, siteName);

   return siteName;
}



void
State::SetSiteName(const String& site)
{
   LOG_FUNCTION2(State::SetSiteName, site);
   
   siteName = site;
}



void
State::SetOperationResults(OperationResult result)
{
   LOG_FUNCTION2(
      State::SetOperationResults,
      String::format(L"result %1",
      result == SUCCESS ? L"SUCCESS" : L"FAILURE"));

   operationResultsStatus = result;
}



void
State::SetOperationResultsMessage(const String& message)
{
   LOG_FUNCTION2(State::SetOperationResultsMessage, message);

   operationResultsMessage = message;
}



String
State::GetParentDomainDnsName() const
{
   LOG_FUNCTION2(
      State::GetParentDomainDnsName,
      parentDomainDnsName);

   return parentDomainDnsName;
}



String
State::GetNewDomainDNSName() const
{
   LOG_FUNCTION2(State::GetNewDomainDNSName, newDomainDnsName);

   return newDomainDnsName;
}



String
State::GetNewDomainNetbiosName() const
{
   LOG_FUNCTION2(
      State::GetNewDomainNetbiosName,
      newDomainFlatName);

   return newDomainFlatName;
}



void
State::SetParentDomainDNSName(const String& name)
{
   LOG_FUNCTION2(State::SetParentDomainDNSName, name);
   ASSERT(!name.empty());

   parentDomainDnsName = name;
}



void
State::SetNewDomainDNSName(const String& name)
{
   LOG_FUNCTION2(State::SetNewDomainDNSName, name);
   ASSERT(!name.empty());

   newDomainDnsName = name;

   // This will cause the flat name to be re-generated

   newDomainFlatName.erase();
}



void
State::SetNewDomainNetbiosName(const String& name)
{
   LOG_FUNCTION2(State::SetNewDomainNetbiosName, name);
   ASSERT(!name.empty());

   newDomainFlatName = name;
}
   


void
State::SetUserDomainName(const String& name)
{
   LOG_FUNCTION2(State::SetUserDomainName, name);

   // name may be empty;

   userDomain = name;
}



String
State::GetUserDomainName() const
{
   LOG_FUNCTION2(State::GetUserDomainName, userDomain);

   return userDomain;
}



void
State::ClearHiddenWhileUnattended()
{
   LOG_FUNCTION(State::ClearHiddenWhileUnattended);

   runHiddenWhileUnattended = false;

   // closes the splash dialog, if visible.

   if (splash)
   {
      // this will delete splash, too

      splash->SelfDestruct();
      splash = 0;
   }
}



bool
State::RunHiddenUnattended() const
{
//   LOG_FUNCTION(State::RunHiddenUnattended);

   return UsingAnswerFile() && runHiddenWhileUnattended;
}



bool
State::IsLastDCInDomain() const
{
   LOG_FUNCTION2(State::IsLastDCInDomain, isLastDc ? L"true" : L"false");

   return isLastDc;
}



void
State::SetIsLastDCInDomain(bool yesNo)
{
   LOG_FUNCTION2(
      State::SetIsLastDCInDomain,
      yesNo ? L"is last dc" : L"is NOT last dc");

   isLastDc = yesNo;
}



void
State::SetAdminPassword(const EncodedString& password)
{
   LOG_FUNCTION(State::SetAdminPassword);

   adminPassword = password;
}



EncodedString
State::GetAdminPassword() const
{
   LOG_FUNCTION(State::GetAdminPassword);

   return adminPassword;
}



String
State::GetOperationResultsMessage() const
{
   LOG_FUNCTION2(
      State::GetOperationResultsMessage,
      operationResultsMessage);

   return operationResultsMessage;
}



State::OperationResult
State::GetOperationResultsCode() const
{
   LOG_FUNCTION2(
      State::GetOperationResultsCode,
      operationResultsStatus == SUCCESS ? L"SUCCESS" : L"FAILURE");

   return operationResultsStatus;
}



bool
State::AutoConfigureDNS() const
{
   LOG_FUNCTION2(
      State::AutoConfigureDNS,
      autoConfigDns ? L"true" : L"false");

   return autoConfigDns;
}

      

void
State::SetAutoConfigureDNS(bool yesNo)
{
   LOG_FUNCTION2(
      State::SetAutoConfigureDNS,
      yesNo ? L"true" : L"false");

   autoConfigDns = yesNo;
}



bool
State::IsDNSOnNetwork() const
{
   LOG_FUNCTION2(
      State::IsDNSOnNetwork,
      isDnsOnNet ? L"true" : L"false");

   return isDnsOnNet;
}



void
State::SetDNSOnNetwork(bool yesNo)
{
   LOG_FUNCTION2(
      State::SetDNSOnNetwork,
      yesNo ? L"true" : L"false");

   isDnsOnNet = yesNo;
}



String
State::GetInstalledSite() const
{
   LOG_FUNCTION2(State::GetInstalledSite, installedSite);

   // should be set before we ask for it...
   ASSERT(!installedSite.empty());

   return installedSite;
}



void
State::SetInstalledSite(const String& site)
{
   LOG_FUNCTION2(State::SetInstalledSite, site);
   ASSERT(!site.empty());

   installedSite = site;
}
   

   
void
State::AddFinishMessage(const String& message)
{
   LOG_FUNCTION2(State::AddFinishMessage, message);
   ASSERT(!message.empty());

   if (finishMessages.empty())
   {
      finishMessages += message;
   }
   else
   {
      // add a blank line between each message

      finishMessages += L"\r\n\r\n" + message;
   }
}



String
State::GetFinishMessages() const
{
   LOG_FUNCTION2(State::GetFinishMessages, finishMessages);

   return finishMessages;
}
   


Computer&
State::GetComputer()
{
   return computer;
}



void
State::SetFailureMessage(const String& message)
{
   LOG_FUNCTION2(State::SetFailureMessage, message);
   ASSERT(!message.empty());

   failureMessage = message;
}


   
String
State::GetFailureMessage() const
{
   LOG_FUNCTION2(State::GetFailureMessage, failureMessage);

   return failureMessage;
}



bool
State::ShouldInstallAndConfigureDns() const
{
   if (AutoConfigureDNS() || !IsDNSOnNetwork())
   {
      return true;
   }

   return false;
}
   


String
State::GetUserForestName() const
{
   LOG_FUNCTION2(State::GetUserForestName, userForest);
   ASSERT(!userForest.empty());

   return userForest;
}



void
State::SetUserForestName(const String& forest)
{
   LOG_FUNCTION2(State::SetUserForestName, forest);
   ASSERT(!forest.empty());

   userForest = forest;
}



bool
State::IsDomainInForest(const String& domain) const
{
   LOG_FUNCTION2(State::IsDomainInForest, domain);
   ASSERT(!domain.empty());

   for (
      DomainList::iterator i = domainsInForest.begin();
      i != domainsInForest.end();
      i++)
   {
      DNS_NAME_COMPARE_STATUS compare = Dns::CompareNames(*i, domain);
      if (compare == DnsNameCompareEqual)
      {
         LOG(L"domain is in forest");
         return true;
      }
   }

   return false;
}



HRESULT
State::ReadDomains()
{
   LOG_FUNCTION(State::ReadDomains);

   domainsInForest.clear();
   return ::ReadDomains(domainsInForest);
}



DNS_NAME_COMPARE_STATUS
State::DomainFitsInForest(const String& domain, String& conflictingDomain)
{
   LOG_FUNCTION(domainFitsInForest);
   ASSERT(!domain.empty());

   conflictingDomain.erase();

   DNS_NAME_COMPARE_STATUS relation = DnsNameCompareNotEqual;
   for (
      DomainList::iterator i = domainsInForest.begin();
      i != domainsInForest.end();
      i++)
   {
      relation = Dns::CompareNames(domain, *i);
      switch (relation)
      {
         case DnsNameCompareNotEqual:
         {
            continue;
         }
         case DnsNameCompareEqual:
         {
            ASSERT(domain == *i);
            // fall thru
         }
         case DnsNameCompareLeftParent:
         case DnsNameCompareRightParent:
         case DnsNameCompareInvalid:
         default:
         {
            conflictingDomain = *i;
            break;
         }
      }

      break;
   }

   return relation;
}



bool
State::GetDomainReinstallFlag() const
{
   LOG_FUNCTION2(
      State::GetDomainReinstallFlag,
      reinstallDomain ? L"true" : L"false");

   return reinstallDomain;
}

   

void
State::SetDomainReinstallFlag(bool newValue)
{
   LOG_FUNCTION2(
      State::SetDomainReinstallFlag,
      newValue ? L"true" : L"false");

   reinstallDomain = newValue;
}



bool
State::ShouldAllowAnonymousAccess() const
{
   LOG_FUNCTION2(
      State::ShouldAllowAnonymousAccess,
      allowAnonAccess ? L"true" : L"false");
   
   return allowAnonAccess;
}



void
State::SetShouldAllowAnonymousAccess(bool yesNo)
{
   LOG_FUNCTION2(
      State::ShouldAllowAnonymousAccess,
      yesNo ? L"true" : L"false");

   allowAnonAccess = yesNo;
}



String
State::GetReplicationPartnerDC() const
{
   LOG_FUNCTION2(State::GetReplicationPartnerDC, replicationPartnerDc);

   return replicationPartnerDc;
}



void
State::SetReplicationPartnerDC(const String dcName)
{
   LOG_FUNCTION2(State::SetReplicationPartnerDC, dcName);

   replicationPartnerDc = dcName;
}



// Retrieve domain controller info for all DCs in the domain that this dc
// is a controller.  (The result set should include this dc)
// Caller should free the result with DsFreeDomainControllerInfo

HRESULT
State::GetDomainControllerInfoForMyDomain(
   DS_DOMAIN_CONTROLLER_INFO_2W*& info,
   DWORD&                         dcCount) 
{
   LOG_FUNCTION(State::GetDomainControllerInfoForMyDomain);

   // if this assertion does not hold, then the DsBind call below should
   // fail.

   ASSERT(GetComputer().IsDomainController());

   dcCount = 0;
   info = 0;

   HRESULT hr = S_OK;
   HANDLE hds = 0;
   do
   {
      String domainDnsName = GetComputer().GetDomainDnsName();
      String dcName = Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

      ASSERT(!domainDnsName.empty());
      ASSERT(!dcName.empty());

      // Bind to self

      hr =
         MyDsBind(
            dcName,
            domainDnsName,
            hds);
      BREAK_ON_FAILED_HRESULT(hr);

      // find all the dc's for my domain.  the list should contain dcName.
      // level 2 contains the "is gc" flag

      hr =
         MyDsGetDomainControllerInfo(
            hds,
            domainDnsName,
            dcCount,
            info);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (hds)
   {
      ::DsUnBind(&hds);
      hds = 0;
   }

   return hr;
}



// returns true if no other domain controller for this DCs domain can be
// found in the DS.  False otherwise

bool
State::IsReallyLastDcInDomain()
{
   LOG_FUNCTION(State::IsReallyLastDcInDomain);

   // Assume we are alone in the universe.

   bool result = true;

   do
   {
      // find all the dc's for my domain.  the list should contain dcName.
      
      DS_DOMAIN_CONTROLLER_INFO_2W* info = 0;
      DWORD count = 0;

      HRESULT hr = GetDomainControllerInfoForMyDomain(info, count);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(count);
      ASSERT(info);

      // if there are more than 1 entry (more than the one for this dc),
      // then the DS believes that there are other DCs for this domain.

      if (count > 1)
      {
         result = false;
      }

#ifdef DBG

      // double check that we found ourselves.

      if (result && info[0].DnsHostName)
      {
         LOG(info[0].DnsHostName);

         String dcName =
            Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

         ASSERT(
            Dns::CompareNames(info[0].DnsHostName, dcName)
            == DnsNameCompareEqual);
      }

#endif 

      MyDsFreeDomainControllerInfo(count, info);
   }
   while (0);
   
   LOG(
      String::format(
         L"This box %1 the sole DC for the domain",
         result ? L"is" : L"is NOT"));

   return result;
}



// Returns true if this computer is a global catalog

bool
State::IsGlobalCatalog()
{
   LOG_FUNCTION(State::IsGlobalCatalog);

   if (!GetComputer().IsDomainController())
   {
      // can't possibly be a GC if not a DC

      return false;
   }

   bool result = false;
   do
   {
      String dcName = Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

      // find all the dc's for my domain.  the list should contain dcName.
      // level 2 contains the "is gc" flag
      
      DS_DOMAIN_CONTROLLER_INFO_2W* info = 0;
      DWORD count = 0;

      HRESULT hr = GetDomainControllerInfoForMyDomain(info, count);
      BREAK_ON_FAILED_HRESULT(hr);

      // there should be at least 1 entry (ourself)

      ASSERT(count);
      ASSERT(info);

      for (int i = 0; i < count; i++)
      {
         if (info[i].DnsHostName)   // 340723
         {
            LOG(info[i].DnsHostName);

            if (
                  Dns::CompareNames(info[i].DnsHostName, dcName)
               == DnsNameCompareEqual)
            {
               // we found ourselves in the list

               LOG(L"found!");
               result = info[i].fIsGc ? true : false;
               break;
            }
         }
      }

      MyDsFreeDomainControllerInfo(count, info);
   }
   while (0);

   LOG(
      String::format(
         L"This box %1 a global catalog",
         result ? L"is" : L"is NOT"));

   return result;
}



EncodedString
State::GetSafeModeAdminPassword() const
{
   LOG_FUNCTION(State::GetSafeModeAdminPassword);

   // don't trace the password!

   return safeModeAdminPassword;
}



void
State::SetSafeModeAdminPassword(const EncodedString& pwd)
{
   LOG_FUNCTION(State::SetSafeModeAdminPassword);

   // don't trace the password!
   // pwd may be empty.

   safeModeAdminPassword = pwd;
}



String
State::GetAdminToolsShortcutPath() const
{
   LOG_FUNCTION2(State::GetAdminToolsShortcutPath, shortcutPath);

   return shortcutPath;
}



bool
State::NeedsCommandLineHelp() const
{
   return needsCommandLineHelp;
}



bool
State::IsAdvancedMode() const
{
   return isAdvancedMode;
}



void
State::SetReplicateFromMedia(bool yesNo)
{
   LOG_FUNCTION2(
      State::SetReplicateFromMedia,
      yesNo ? L"true" : L"false");

   replicateFromMedia = yesNo;
}



void
State::SetReplicationSourcePath(const String& path)
{
   LOG_FUNCTION2(State::SetReplicationSourcePath, path);

   sourcePath = path;
}



bool
State::ReplicateFromMedia() const
{
   LOG_FUNCTION2(
      State::ReplicateFromMedia,
      replicateFromMedia ? L"true" : L"false");

   return replicateFromMedia;
}



String
State::GetReplicationSourcePath() const
{
   LOG_FUNCTION2(State::GetReplicationSourcePath, sourcePath);

   return sourcePath;
}



void
State::SetSyskeyLocation(SyskeyLocation loc)
{
   LOG_FUNCTION2(State::SetSyskeyLocation,
         loc == DISK
      ?  L"disk"
      :  ((loc == PROMPT) ? L"prompt" : L"stored"));

   syskeyLocation = loc;
}



State::SyskeyLocation
State::GetSyskeyLocation() const
{
   LOG_FUNCTION2(
      State::IsSyskeyPresent,
         syskeyLocation == DISK
      ?  L"disk"
      :  ((syskeyLocation == PROMPT) ? L"prompt" : L"stored"));

   return syskeyLocation;
}



void
State::SetIsBackupGc(bool yesNo)
{
   LOG_FUNCTION2(State::SetIsBackupGc, yesNo ? L"true" : L"false");

   isBackupGc = yesNo;
}



bool
State::IsBackupGc() const
{
   LOG_FUNCTION2(State::IsBackupGc, isBackupGc ? L"true" : L"false");

   return isBackupGc;
}



void
State::SetSyskey(const EncodedString& syskey_)
{
   // don't log the syskey!

   LOG_FUNCTION(State::SetSyskey);
   ASSERT(!syskey_.IsEmpty());

   syskey = syskey_;
}



EncodedString
State::GetSyskey() const
{
   // don't log the syskey!

   LOG_FUNCTION(State::GetSyskey);

   return syskey;
}



void
State::SetRestoreGc(bool yesNo)
{
   LOG_FUNCTION2(State::SetRestoreGc, yesNo ? L"true" : L"false");

   restoreGc = yesNo;
}



bool
State::GetRestoreGc() const
{
   LOG_FUNCTION2(State::GetRestoreGc, restoreGc ? L"true" : L"false");

   return restoreGc;
}



bool
State::IsSafeModeAdminPwdOptionPresent() const
{
   LOG_FUNCTION(State::IsSafeModeAdminPwdOptionPresent);
   ASSERT(UsingAnswerFile());

   bool result = false;

   if (answerFile)
   {
      result =
         answerFile->IsKeyPresent(
            SECTION_NAME,
            OPTION_SAFE_MODE_ADMIN_PASSWORD);
   }

   LOG(result ? L"true" : L"false");

   return result;
}



void
State::SetDomainControllerReinstallFlag(bool newValue)
{
   LOG_FUNCTION2(
      State::SetDomainControllerReinstallFlag,
      newValue ? L"true" : L"false");

   reinstallDomainController = newValue;
}



bool
State::GetDomainControllerReinstallFlag() const
{
   LOG_FUNCTION2(
      State::GetDomainControllerReinstallFlag,
      reinstallDomain ? L"true" : L"false");

   return reinstallDomainController;
}



void
State::SetOperationResultsFlags(ULONG flags)
{
   LOG_FUNCTION2(
      State::SetOperationResultsFlags,
      String::format(L"0x%1!X!", flags));

   operationResultsFlags = flags;
}



ULONG
State::GetOperationResultsFlags() const
{
   LOG_FUNCTION2(
      State::GetOperationResultsFlags,
      String::format(L"0x%1!X!", operationResultsFlags));

   return operationResultsFlags;
}



bool
State::IsOperationRetryAllowed() const
{
   LOG_FUNCTION(State::IsOperationRetryAllowed);

   bool result = true;
      
   if (operationResultsFlags & DSROLE_IFM_RESTORED_DATABASE_FILES_MOVED)
   {
      // don't allow the user to retry the operation again, as one consequence
      // of the failure is that the moved files are now trashed.  The user
      // must re-restore the files in order to attempt the operation again.
      // NTRAID#NTBUG9-296872-2001/01/29-sburns

      LOG(L"ifm files moved, retry not allowed");

      result = false;
   }

   LOG(result ? L"true" : L"false");

   return result;
}



// needing a reboot is a "sticky" setting: there's no way to turn it off.
// if you once needed to reboot the machine, you will always need to reboot
// the machine.  (at least, for now).

void
State::SetNeedsReboot()
{
   LOG_FUNCTION(State::SetNeedsReboot);
   
   needsReboot = true;
}



bool
State::GetNeedsReboot() const
{
   LOG_FUNCTION2(State::GetNeedsReboot, needsReboot ? L"true" : L"false");

   return needsReboot;
}
   

   
void
State::SetSetForestVersionFlag(bool setVersion)
{
   LOG_FUNCTION2(
      State::SetSetForestVersionFlag,
      setVersion ? L"true" : L"false");

   setForestVersion = setVersion;   
}



bool
State::GetSetForestVersionFlag() const
{
   LOG_FUNCTION2(
      State::GetSetForestVersionFlag,
      setForestVersion ? L"true" : L"false");

   return setForestVersion;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\unattendsplashdialog.hpp ===
// Copyright (C) 1998 Microsoft Corporation
//
// Splash screen for unattended mode
//
// 10-1-98 sburns



#ifndef UNATTENDSPLASHDIALOG_HPP_INCLUDED
#define UNATTENDSPLASHDIALOG_HPP_INCLUDED



class UnattendSplashDialog : public Dialog
{
   public:

   UnattendSplashDialog();

   virtual ~UnattendSplashDialog();

   // Cause the window to destroy itself and delete itself (call delete on
   // the this pointer.

   void
   SelfDestruct();

   // Dialog overrides

   virtual
   void
   OnInit();

   virtual
   bool
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   private:

   // not defined; no copying allowed

   UnattendSplashDialog(const UnattendSplashDialog&);
   const UnattendSplashDialog& operator=(const UnattendSplashDialog&);
};



#endif   // UNATTENDSPLASHDIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\treepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// new tree page
//
// 1-7-98 sburns



#ifndef TREEPAGE_HPP_INCLUDED
#define TREEPAGE_HPP_INCLUDED



class TreePage : public DCPromoWizardPage
{
   public:

   TreePage();

   protected:

   virtual ~TreePage();

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   // private:

   // not defined; no copying allowed

   TreePage(const TreePage&);
   const TreePage& operator=(const TreePage&);
};



#endif   // TREEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\state.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// wizard state object
//
// 12-15-97 sburns



#ifndef STATE_HPP_INCLUDED
#define STATE_HPP_INCLUDED



#include "AnswerFile.hpp"
#include "UnattendSplashDialog.hpp"



class State
{
   public:

   // call from WinMain to init the global instance

   static
   void
   Init();

   // call from WinMain to delete the global instance

   static
   void
   Destroy();

   static
   State&
   GetInstance();

   bool
   AutoConfigureDNS() const;

   void
   SetAutoConfigureDNS(bool yesNo);

   String
   GetNewDomainNetbiosName() const;

   void
   SetNewDomainNetbiosName(const String& name);

   String
   GetNewDomainDNSName() const;

   void
   SetNewDomainDNSName(const String& name);

   String
   GetUsername() const;

   EncodedString
   GetPassword() const;

   void
   SetUsername(const String& name);

   void
   SetPassword(const EncodedString& password);

   String
   GetDatabasePath() const;

   String
   GetLogPath() const;

   String
   GetSYSVOLPath() const;

   String
   GetSiteName() const;

   void
   SetDatabasePath(const String& path);

   void
   SetLogPath(const String& path);

   void
   SetSYSVOLPath(const String& path);
     
   enum RunContext
   {
      NT5_DC,                 // already an NT5 DC
      NT5_STANDALONE_SERVER,  // standalone to DC
      NT5_MEMBER_SERVER,      // member server to DC
      BDC_UPGRADE,            // NT4 BDC to NT5 DC
      PDC_UPGRADE             // NT4 PDC to NT5 DC
   };

   RunContext
   GetRunContext() const;

   bool
   UsingAnswerFile() const;

   static const String OPTION_ADMIN_PASSWORD;
   static const String OPTION_AUTO_CONFIG_DNS;
   static const String OPTION_CHILD_NAME;
   static const String OPTION_CRITICAL_REPLICATION_ONLY;
   static const String OPTION_DATABASE_PATH;
   static const String OPTION_DNS_ON_NET;
   static const String OPTION_ALLOW_ANON_ACCESS;
   static const String OPTION_IS_LAST_DC;
   static const String OPTION_GC_CONFIRM;
   static const String OPTION_LOG_PATH;
   static const String OPTION_NEW_DOMAIN;
   static const String OPTION_NEW_DOMAIN_NAME;
   static const String OPTION_NEW_DOMAIN_NETBIOS_NAME;
   static const String OPTION_PARENT_DOMAIN_NAME;
   static const String OPTION_PASSWORD;
   static const String OPTION_REBOOT;
   static const String OPTION_REPLICA_DOMAIN_NAME;
   static const String OPTION_REPLICA_OR_MEMBER;
   static const String OPTION_REPLICA_OR_NEW_DOMAIN;
   static const String OPTION_REPLICATION_SOURCE;
   static const String OPTION_SAFE_MODE_ADMIN_PASSWORD;
   static const String OPTION_SET_FOREST_VERSION;
   static const String OPTION_SITE_NAME;
   static const String OPTION_SYSVOL_PATH;
   static const String OPTION_SYSKEY;
   static const String OPTION_USERNAME;
   static const String OPTION_USER_DOMAIN;
   static const String VALUE_DOMAIN;
   static const String VALUE_REPLICA;
   static const String VALUE_TREE;
   static const String VALUE_CHILD;
   static const String VALUE_YES;
   static const String VALUE_NO;
   static const String VALUE_NO_DONT_PROMPT;
   static const String OPTION_SOURCE_PATH;

   String
   GetAnswerFileOption(const String& option) const;

   EncodedString
   GetEncodedAnswerFileOption(const String& option) const;
   
   String
   GetReplicaDomainDNSName() const;

   enum Operation
   {
      NONE,
      REPLICA,
      FOREST,
      TREE,
      CHILD,
      DEMOTE,
      ABORT_BDC_UPGRADE
   };

   Operation
   GetOperation() const;

   String
   GetParentDomainDnsName() const;

   void
   SetParentDomainDNSName(const String& name);

   enum OperationResult
   {
      SUCCESS,
      FAILURE
   };

   void
   SetOperationResults(OperationResult result);

   OperationResult
   GetOperationResultsCode() const;

   void
   SetOperationResultsMessage(const String& message);

   String
   GetOperationResultsMessage() const;

   void
   SetOperation(Operation oper);

   void
   SetReplicaDomainDNSName(const String& dnsName);

   void
   SetSiteName(const String& site);
       
   void
   SetUserDomainName(const String& name);

   String
   GetUserDomainName() const;

   void
   ClearHiddenWhileUnattended();

   bool
   RunHiddenUnattended() const;

   bool
   IsLastDCInDomain() const;

   void
   SetIsLastDCInDomain(bool yesNo);

   void
   SetAdminPassword(const EncodedString& password);

   EncodedString
   GetAdminPassword() const;

   bool
   IsDNSOnNetwork() const;

   void
   SetDNSOnNetwork(bool yesNo);

   String
   GetInstalledSite() const;

   void
   SetInstalledSite(const String& site);

   void
   AddFinishMessage(const String& message);

   String
   GetFinishMessages() const;

   Computer&
   GetComputer();

   void
   SetFailureMessage(const String& message);

   String
   GetFailureMessage() const;

   bool
   ShouldInstallAndConfigureDns() const;

   String
   GetUserForestName() const;

   void
   SetUserForestName(const String& forest);

   bool
   IsDomainInForest(const String& domain) const;

   HRESULT
   ReadDomains();

   DNS_NAME_COMPARE_STATUS
   DomainFitsInForest(const String& domain, String& conflictingDomain);

   bool
   GetDomainReinstallFlag() const;

   void
   SetDomainReinstallFlag(bool newValue);

   // true to indicate that the RAS permissions script should be run.

   bool
   ShouldAllowAnonymousAccess() const;

   void
   SetShouldAllowAnonymousAccess(bool yesNo);

   String
   GetReplicationPartnerDC() const;

   void
   SetReplicationPartnerDC(const String dcName);

   // returns true if the machine is hosts a global catalog

   bool
   IsGlobalCatalog();

   EncodedString
   GetSafeModeAdminPassword() const;

   void
   SetSafeModeAdminPassword(const EncodedString& pwd);

   String
   GetAdminToolsShortcutPath() const;

   bool
   NeedsCommandLineHelp() const;

   bool
   IsAdvancedMode() const;

   void
   SetReplicateFromMedia(bool yesNo);

   void
   SetReplicationSourcePath(const String& path);

   bool
   ReplicateFromMedia() const;

   String
   GetReplicationSourcePath() const;

   bool
   IsReallyLastDcInDomain();

   enum SyskeyLocation
   {
      STORED,     // stored w/ backup
      DISK,       // look on disk
      PROMPT      // prompt user
   };

   void
   SetSyskeyLocation(SyskeyLocation loc);

   SyskeyLocation
   GetSyskeyLocation() const;

   void
   SetIsBackupGc(bool yesNo);

   bool
   IsBackupGc() const;

   void
   SetSyskey(const EncodedString& syskey);

   EncodedString
   GetSyskey() const;

   void
   SetRestoreGc(bool yesNo);

   bool
   GetRestoreGc() const;

   bool
   IsSafeModeAdminPwdOptionPresent() const;

   bool
   GetDomainControllerReinstallFlag() const;

   void
   SetDomainControllerReinstallFlag(bool newValue);

   bool
   IsOperationRetryAllowed() const;

   ULONG
   GetOperationResultsFlags() const;

   void
   SetOperationResultsFlags(ULONG flags);

   void
   SetNeedsReboot();

   bool
   GetNeedsReboot() const;

   void
   SetSetForestVersionFlag(bool setVersion);

   bool
   GetSetForestVersionFlag() const;
   
   private:

   // can only be created/destroyed by Init/Destroy

   State();

   ~State();

   void
   DetermineRunContext();

   void
   SetupAnswerFile(const String& filename, bool isDefaultAnswerfile);

   HRESULT
   GetDomainControllerInfoForMyDomain(
      DS_DOMAIN_CONTROLLER_INFO_2W*& info,
      DWORD&                         dcCount);

   typedef StringList DomainList;

   EncodedString         adminPassword;             
   bool                  allowAnonAccess;               
   AnswerFile*           answerFile;                
   bool                  autoConfigDns;            
   Computer              computer;                   
   RunContext            context;                    
   String                dbPath;                    
   DomainList            domainsInForest;          
   String                failureMessage;            
   String                finishMessages;            
   String                installedSite;             
   bool                  isAdvancedMode;
   bool                  isBackupGc;
   bool                  isDnsOnNet;                 
   bool                  isLastDc;
   bool                  isUpgrade;                 
   String                logPath;                   
   bool                  needsCommandLineHelp;
   bool                  needsReboot;
   String                newDomainDnsName;        
   String                newDomainFlatName;       
   Operation             operation;                  
   String                operationResultsMessage;   
   OperationResult       operationResultsStatus;    
   ULONG                 operationResultsFlags;
   String                parentDomainDnsName;     
   EncodedString         password;                   
   bool                  reinstallDomain;
   bool                  reinstallDomainController;
   String                replicaDnsDomainName;
   bool                  replicateFromMedia;
   String                replicationPartnerDc;
   bool                  restoreGc;
   bool                  runHiddenWhileUnattended;
   EncodedString         safeModeAdminPassword;
   bool                  setForestVersion;
   String                shortcutPath;
   String                siteName;                  
   String                sourcePath;
   UnattendSplashDialog* splash;                     
   String                sysvolPath;
   EncodedString         syskey;
   SyskeyLocation        syskeyLocation;               
   bool                  useCurrentCredentials;    
   String                userDomain;                
   String                userForest;                
   String                username;

   // not defined: no copying.

   State(const State&);
   State& operator=(const State&);
};



#endif   // STATE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\unattendsplashdialog.cpp ===
// Copyright (C) 1998 Microsoft Corporation
//
// Splash screen for unattended mode
//
// 10-1-98 sburns



#include "headers.hxx"
#include "UnattendSplashDialog.hpp"
#include "resource.h"



const UINT SELF_DESTRUCT_MESSAGE = WM_USER + 200;



static const DWORD HELP_MAP[] =
{
   0, 0
};



UnattendSplashDialog::UnattendSplashDialog()
   :
   Dialog(IDD_UNATTEND_SPLASH, HELP_MAP)
{
   LOG_CTOR(UnattendSplashDialog);
}



UnattendSplashDialog::~UnattendSplashDialog()
{
   LOG_DTOR(UnattendSplashDialog);
}



void
UnattendSplashDialog::OnInit()
{
   LOG_FUNCTION(UnattendSplashDialog::OnInit);

   // Since the window does not have a title bar, we need to give it some
   // text to appear on the button label on the shell task bar.

   Win::SetWindowText(hwnd, String::load(IDS_WIZARD_TITLE));
}



void
UnattendSplashDialog::SelfDestruct()
{
   LOG_FUNCTION(UnattendSplashDialog::SelfDestruct);
      
   // Post our window proc a self destruct message.  We use Post instead of
   // send, as we expect that in some cases, this function will be called from
   // a thread other than the one that created the window.  (It is illegal to
   // try to destroy a window from a thread that it not the thread that
   // created the window.)

   Win::PostMessage(hwnd, SELF_DESTRUCT_MESSAGE, 0, 0);
}
      


bool
UnattendSplashDialog::OnMessage(
   UINT     message,
   WPARAM   /* wparam */ ,
   LPARAM   /* lparam */ )
{
   if (message == SELF_DESTRUCT_MESSAGE)
   {
      delete this;
      return true;
   }

   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\welcomepage.hpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// welcome page
//
// 12-15-97 sburns



#ifndef WELCOMEPAGE_HPP_INCLUDED
#define WELCOMEPAGE_HPP_INCLUDED



class WelcomePage : public DCPromoWizardPage
{
   public:

   WelcomePage();

   protected:

   virtual ~WelcomePage();

   // Dialog overrides

   virtual
   void
   OnInit();

   // PropertyPage overrides

   virtual
   bool
   OnSetActive();

   // DCPromoWizardPage overrides

   virtual
   int
   Validate();

   private:

   // not defined; no copying allowed

   WelcomePage(const WelcomePage&);
   const WelcomePage& operator=(const WelcomePage&);
};



#endif   // WELCOMEPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\exe\welcomepage.cpp ===
// Copyright (C) 1997 Microsoft Corporation
//
// welcome page
//
// 12-15-97 sburns



#include "headers.hxx"
#include "page.hpp"
#include "WelcomePage.hpp"
#include "resource.h"
#include "common.hpp"
#include "state.hpp"



WelcomePage::WelcomePage()
   :
   DCPromoWizardPage(
      IDD_WELCOME,
      IDS_WELCOME_PAGE_TITLE,
      IDS_WELCOME_PAGE_SUBTITLE,
      false)
{
   LOG_CTOR(WelcomePage);
}



WelcomePage::~WelcomePage()
{
   LOG_DTOR(WelcomePage);
}



void
WelcomePage::OnInit()
{
   LOG_FUNCTION(WelcomePage::OnInit);

   SetLargeFont(hwnd, IDC_BIG_BOLD_TITLE);

   Win::PropSheet_SetTitle(
      Win::GetParent(hwnd),     
      0,
      String::load(IDS_WIZARD_TITLE));

   State& state        = State::GetInstance();
   int    intro1TextId = IDS_INTRO1_INSTALL;  
   String intro2Text;                   

   switch (state.GetRunContext())
   {
      case State::NT5_DC:
      {
         intro1TextId = IDS_INTRO1_DEMOTE;
         intro2Text   = String::load(IDS_INTRO2_DEMOTE);
         break;
      }
      case State::NT5_STANDALONE_SERVER:
      case State::NT5_MEMBER_SERVER:
      {
         intro2Text   = String::load(IDS_INTRO2_INSTALL);
         break;
      }
      case State::BDC_UPGRADE:
      {
         intro1TextId = IDS_INTRO1_DC_UPGRADE;
         intro2Text   = String::load(IDS_INTRO2_BDC_UPGRADE);
         break;
      }
      case State::PDC_UPGRADE:
      {
         intro1TextId = IDS_INTRO1_DC_UPGRADE;         
         intro2Text   =
            String::format(
               IDS_INTRO2_PDC_UPGRADE,
               state.GetComputer().GetDomainNetbiosName().c_str());
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   Win::SetDlgItemText(hwnd, IDC_INTRO1, String::load(intro1TextId));
   Win::SetDlgItemText(hwnd, IDC_INTRO2, intro2Text);
}



bool
WelcomePage::OnSetActive()
{
   LOG_FUNCTION(WelcomePage::OnSetActive);
   
   Win::PropSheet_SetWizButtons(Win::GetParent(hwnd), PSWIZB_NEXT);

   State& state = State::GetInstance();
   if (state.RunHiddenUnattended())
   {
      int nextPage = Validate();
      if (nextPage != -1)
      {
         GetWizard().SetNextPageID(hwnd, nextPage);
      }
      else
      {
         state.ClearHiddenWhileUnattended();
      }

   }

   return true;
}



int
WelcomePage::Validate()
{
   LOG_FUNCTION(WelcomePage::Validate);
   int nextPage = -1;

   State& state = State::GetInstance();
   switch (state.GetRunContext())
   {
      case State::PDC_UPGRADE:
      case State::NT5_STANDALONE_SERVER:
      case State::NT5_MEMBER_SERVER:
      {
         nextPage = IDD_INSTALL_TCPIP;
         break;
      }
      case State::BDC_UPGRADE:
      {
         nextPage = IDD_REPLICA_OR_MEMBER;
         break;
      }
      case State::NT5_DC:
      {
         state.SetOperation(State::DEMOTE);
         nextPage = IDD_DEMOTE;
         break;
      }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return nextPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\accessiblewrapper.h ===
//****************************************************************************
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  File:  AccessibleWrapper.H
//
//  Copied from nt\shell\themes\themeui\SettingsPg.h
//
//****************************************************************************
#ifndef _ACCESSIBLE_WRAPPER_H_
#define _ACCESSIBLE_WRAPPER_H_
#include <oleacc.h>

class CAccessibleWrapper: public IAccessible
{
        // We need to do our own refcounting for this wrapper object
        ULONG          m_ref;

        // Need ptr to the IAccessible
        IAccessible *  m_pAcc;
        HWND           m_hwnd;

public:
        CAccessibleWrapper( HWND hwnd, IAccessible * pAcc);
        virtual ~CAccessibleWrapper();

        // IUnknown
        // (We do our own ref counting)
        virtual STDMETHODIMP            QueryInterface(REFIID riid, void** ppv);
        virtual STDMETHODIMP_(ULONG)    AddRef();
        virtual STDMETHODIMP_(ULONG)    Release();

        // IDispatch
        virtual STDMETHODIMP            GetTypeInfoCount(UINT* pctinfo);
        virtual STDMETHODIMP            GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        virtual STDMETHODIMP            GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid);
        virtual STDMETHODIMP            Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
            UINT* puArgErr);

        // IAccessible
        virtual STDMETHODIMP            get_accParent(IDispatch ** ppdispParent);
        virtual STDMETHODIMP            get_accChildCount(long* pChildCount);
        virtual STDMETHODIMP            get_accChild(VARIANT varChild, IDispatch ** ppdispChild);

        virtual STDMETHODIMP            get_accName(VARIANT varChild, BSTR* pszName);
        virtual STDMETHODIMP            get_accValue(VARIANT varChild, BSTR* pszValue);
        virtual STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR* pszDescription);
        virtual STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT *pvarRole);
        virtual STDMETHODIMP            get_accState(VARIANT varChild, VARIANT *pvarState);
        virtual STDMETHODIMP            get_accHelp(VARIANT varChild, BSTR* pszHelp);
        virtual STDMETHODIMP            get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
        virtual STDMETHODIMP            get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);
        virtual STDMETHODIMP            get_accFocus(VARIANT * pvarFocusChild);
        virtual STDMETHODIMP            get_accSelection(VARIANT * pvarSelectedChildren);
        virtual STDMETHODIMP            get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

        virtual STDMETHODIMP            accSelect(long flagsSel, VARIANT varChild);
        virtual STDMETHODIMP            accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        virtual STDMETHODIMP            accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
        virtual STDMETHODIMP            accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
        virtual STDMETHODIMP            accDoDefaultAction(VARIANT varChild);

        virtual STDMETHODIMP            put_accName(VARIANT varChild, BSTR szName);
        virtual STDMETHODIMP            put_accValue(VARIANT varChild, BSTR pszValue);
};


#endif _ACCESSIBLE_WRAPPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       debug.h
//
//  Contents:   Debugging macros and prototypes
//
//----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_


#if DBG == 1


void __cdecl _TRACE (int level, const wchar_t *format, ... );


//
// External functions
//

PCSTR StripDirPrefixA(PCSTR);



//
// These macros are used for asserting certain conditions. They are
// independent of the debugging level.
// These also require additional paranthesis to enclose the msg as
// shown below.
//

#ifdef _ASSERT
#undef _ASSERT
#undef _ASSERTMSG
#endif

#define _ASSERT(expr)                                                    \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
               _TRACE (0, L"Cert Template Snapin(Thread ID: %d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DebugBreak();                                           \
            }                                                           \
        }


#define _ASSERTMSG(expr, msg)                                            \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                _TRACE (0, L"Cert Template Snapin(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                _TRACE (0, msg);                                           \
                _TRACE (0, "\n");                                         \
                DebugBreak();                                           \
            }                                                           \
        }

    void CheckDebugOutputLevel ();

#else // !DBG


#define _TRACE 
#define _ASSERTMSG(expr, msg)

#endif



#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       debug.cpp
//
//  Contents:   Debugging support
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#if DBG == 1
static int indentLevel = 0;

#define DEBUGKEY    L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug\\LogHours"

#define DEBUG_OUTPUT_NONE       0
#define DEBUG_OUTPUT_ERROR      1
#define DEBUG_OUTPUT_WARNING    2
#define DEBUG_OUTPUT_TRACE      3
#define DEBUGLEVEL  L"debugOutput"

static bool             g_fDebugOutputLevelInit = false;
static unsigned long    g_ulDebugOutput = DEBUG_OUTPUT_NONE;

void __cdecl _TRACE (int level, const wchar_t *format, ... )
{
    if ( g_ulDebugOutput > DEBUG_OUTPUT_NONE )
    {
        va_list arglist;
        const size_t DEBUG_BUF_LEN = 512;
        WCHAR Buffer[DEBUG_BUF_LEN];
        int cb;

        if ( level < 0 )
            indentLevel += level;
        //
        // Format the output into a buffer and then print it.
        //
        wstring strTabs;

        for (int nLevel = 0; nLevel < indentLevel; nLevel++)
            strTabs += L"  ";

        OutputDebugStringW (strTabs.c_str ());

        va_start(arglist, format);

        cb = _vsnwprintf (Buffer, DEBUG_BUF_LEN, format, arglist);
        if ( cb )
        {
            OutputDebugStringW (Buffer);
        }

        va_end(arglist);

        if ( level > 0 )
            indentLevel += level;
    }
}


PCSTR
StripDirPrefixA(
    PCSTR pszPathName
    )

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    DWORD dwLen = lstrlenA(pszPathName);

    pszPathName += dwLen - 1;       // go to the end

    while (*pszPathName != '\\' && dwLen--)
    {
        pszPathName--;
    }

    return pszPathName + 1;
}

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
void CheckDebugOutputLevel ()
{
    if ( g_fDebugOutputLevelInit ) 
        return;
    g_fDebugOutputLevelInit = true;
    HKEY    hKey = 0;
    DWORD   dwDisposition = 0;
    LONG lResult = ::RegCreateKeyEx (HKEY_LOCAL_MACHINE, // handle of an open key
            DEBUGKEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,      // special options flag
            KEY_ALL_ACCESS,    // desired security access
            NULL,     // address of key security structure
			&hKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
    if (lResult == ERROR_SUCCESS)
    {
        DWORD   dwSize = sizeof(unsigned long);
        lResult = RegQueryValueExW (hKey, DEBUGLEVEL, NULL, NULL,
                                (LPBYTE)&g_ulDebugOutput, &dwSize);
        if (lResult != ERROR_SUCCESS)
        {
            g_ulDebugOutput = DEBUG_OUTPUT_NONE;
            if ( ERROR_FILE_NOT_FOUND == lResult )
            {
                RegSetValueExW (hKey, DEBUGLEVEL, 0, REG_DWORD,
                        (LPBYTE)&g_ulDebugOutput, sizeof (g_ulDebugOutput));
            }
        }
        RegCloseKey(hKey);
    }
}

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\accessiblewrapper.cpp ===
//****************************************************************************
//
//  Copyright (c) 2001, Microsoft Corporation
//
//  File:  AccessibleWrapper.cpp
//
//  Copied from nt\shell\themes\themeui\SettingsPg.h
//
//****************************************************************************
#include "stdafx.h"
#include "SchedMat.h"
#include "AccessibleWrapper.h"
#include "SchedBas.h"


CAccessibleWrapper::CAccessibleWrapper (HWND hwnd, IAccessible * pAcc)
    : m_ref( 1 ),
      m_pAcc( pAcc ),
      m_hwnd( hwnd )
{
    ASSERT( m_pAcc );
    m_pAcc->AddRef();
}

CAccessibleWrapper::~CAccessibleWrapper()
{
    m_pAcc->Release();
}


// IUnknown
// Implement refcounting ourselves
// Also implement QI ourselves, so that we return a ptr back to the wrapper.
STDMETHODIMP  CAccessibleWrapper::QueryInterface(REFIID riid, void** ppv)
{
    *ppv = NULL;

    if ((riid == IID_IUnknown)  ||
        (riid == IID_IDispatch) ||
        (riid == IID_IAccessible))
    {
        *ppv = (IAccessible *) this;
    }
    else
        return(E_NOINTERFACE);

    AddRef();
    return(NOERROR);
}


STDMETHODIMP_(ULONG) CAccessibleWrapper::AddRef()
{
    return ++m_ref;
}


STDMETHODIMP_(ULONG) CAccessibleWrapper::Release()
{
    ULONG ulRet = --m_ref;

    if( ulRet == 0 )
        delete this;

    return ulRet;
}

// IDispatch
// - pass all through m_pAcc

STDMETHODIMP  CAccessibleWrapper::GetTypeInfoCount(UINT* pctinfo)
{
    return m_pAcc->GetTypeInfoCount(pctinfo);
}


STDMETHODIMP  CAccessibleWrapper::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{
    return m_pAcc->GetTypeInfo(itinfo, lcid, pptinfo);
}


STDMETHODIMP  CAccessibleWrapper::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid)
{
    return m_pAcc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

STDMETHODIMP  CAccessibleWrapper::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
            UINT* puArgErr)
{
    return m_pAcc->Invoke(dispidMember, riid, lcid, wFlags,
            pdispparams, pvarResult, pexcepinfo,
            puArgErr);
}

// IAccessible
// - pass all through m_pAcc

STDMETHODIMP  CAccessibleWrapper::get_accParent(IDispatch ** ppdispParent)
{
    return m_pAcc->get_accParent(ppdispParent);
}


STDMETHODIMP  CAccessibleWrapper::get_accChildCount(long* pChildCount)
{
    return m_pAcc->get_accChildCount(pChildCount);
}


STDMETHODIMP  CAccessibleWrapper::get_accChild(VARIANT varChild, IDispatch ** ppdispChild)
{
    return m_pAcc->get_accChild(varChild, ppdispChild);
}



STDMETHODIMP  CAccessibleWrapper::get_accName(VARIANT varChild, BSTR* pszName)
{
    if ( !pszName )
        return E_POINTER;

    if ( VT_I4 == varChild.vt && CHILDID_SELF == varChild.lVal )
    {
        const size_t  bufLen = 256;
        WCHAR szName[bufLen];

        if ( 0 == SendMessage (m_hwnd, SCHEDMSG_GETSELDESCRIPTION, bufLen,
                (LPARAM) szName) )
        {
            *pszName = SysAllocString (szName);
            if ( *pszName )
                return S_OK;
            else
                return E_OUTOFMEMORY;
        }
        else
            return E_FAIL;
    }
    else
        return m_pAcc->get_accName(varChild, pszName);
}



STDMETHODIMP  CAccessibleWrapper::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    // varChild.lVal specifies which sub-part of the component
    // is being queried.
    // CHILDID_SELF (0) specifies the overall component - other
    // non-0 values specify a child.
    if ( !pszValue )
        return E_POINTER;

    if( varChild.vt == VT_I4 && varChild.lVal == CHILDID_SELF )
    {
        LRESULT nPercentage = SendMessage (m_hwnd, SCHEDMSG_GETPERCENTAGE, 
                0, 0L);
        CString szValue;

        if ( -1 == nPercentage )
        {
            szValue.LoadString (IDS_MATRIX_ACC_VALUE_MULTIPLE_CELLS);
        }
        else
        {
            HWND hwndParent = GetParent (m_hwnd);
            if ( hwndParent )
            {
                LRESULT nIDD = SendMessage (hwndParent, BASEDLGMSG_GETIDD, 0, 0);
                switch ( nIDD )
                {
                case IDD_REPLICATION_SCHEDULE:
                    if ( 0 == nPercentage )
                        szValue.LoadString (IDS_REPLICATION_NOT_AVAILABLE);
                    else
                        szValue.LoadString (IDS_REPLICATION_AVAILABLE);
                    break;

                case IDD_DS_SCHEDULE:
                    switch (nPercentage)
                    {
                    case 0:
                        szValue.LoadString (IDS_DO_NOT_REPLICATE);
                        break;

                    case 25:
                        szValue.LoadString (IDS_REPLICATE_ONCE_PER_HOUR);
                        break;

                    case 50:
                        szValue.LoadString (IDS_REPLICATE_TWICE_PER_HOUR);
                        break;

                    case 100:
                        szValue.LoadString (IDS_REPLICATE_FOUR_TIMES_PER_HOUR);
                        break;

                    default:
                        break;
                    }
                    break;

                case IDD_DIRSYNC_SCHEDULE:
                    if ( 0 == nPercentage )
                        szValue.LoadString (IDS_DONT_SYNCHRONIZE);
                    else
                        szValue.LoadString (IDS_SYNCHRONIZE);
                    break;

                case IDD_DIALIN_HOURS:
                case IDD_LOGON_HOURS:
                    if ( 0 == nPercentage )
                        szValue.LoadString (IDS_LOGON_DENIED);
                    else
                        szValue.LoadString (IDS_LOGON_PERMITTED);
                    break;

                default:
                    break;
                }
            }
        }

        *pszValue = SysAllocString (szValue);
        if ( *pszValue )
            return S_OK;
        else
            return E_OUTOFMEMORY;
    }
    else
    {
        // Pass requests about the sub-components to the
        // 'original' IAccessible for us).
        return m_pAcc->get_accValue(varChild, pszValue);
    }
}


STDMETHODIMP  CAccessibleWrapper::get_accDescription(VARIANT varChild, BSTR* pszDescription)
{
    if ( varChild.vt == VT_I4 && varChild.lVal == CHILDID_SELF )
    {
        CString szDescription;
        HWND hwndParent = GetParent (m_hwnd);
        if ( hwndParent )
        {
            LRESULT nIDD = SendMessage (hwndParent, BASEDLGMSG_GETIDD, 0, 0);
            switch ( nIDD )
            {
            case IDD_REPLICATION_SCHEDULE:
                szDescription.LoadString (IDS_REPLICATION_SCHEDULE_ACC_DESCRIPTION);
                break;

            case IDD_DS_SCHEDULE:
                szDescription.LoadString (IDS_DS_SCHEDULE_ACC_DESCRIPTION);
                break;

            case IDD_DIRSYNC_SCHEDULE:
                szDescription.LoadString (IDS_DIRSYNC_SCHEDULE_ACC_DESCRIPTION);
                break;

            case IDD_DIALIN_HOURS:
                szDescription.LoadString (IDS_DIALIN_HOURS_ACC_DESCRIPTION);
                break;

            case IDD_LOGON_HOURS:
                szDescription.LoadString (IDS_LOGON_HOURS_ACC_DESCRIPTION);
                break;

            default:
                break;
            }
        }

        *pszDescription = SysAllocString (szDescription);
        if ( *pszDescription )
            return S_OK;
        else
            return E_OUTOFMEMORY;
    }
    else
    {
        return m_pAcc->get_accDescription(varChild, pszDescription);
    }
}


STDMETHODIMP  CAccessibleWrapper::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    if ( !pvarRole )
        return E_POINTER;

    if ( VT_I4 == varChild.vt && CHILDID_SELF == varChild.lVal )
    {
        // reset the out variable
        V_VT(pvarRole) = VT_EMPTY;

        V_VT(pvarRole) = VT_I4;
        V_I4(pvarRole) = ROLE_SYSTEM_TABLE;
        return S_OK;
    }
    else
        return m_pAcc->get_accRole(varChild, pvarRole);
}


STDMETHODIMP  CAccessibleWrapper::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    if ( !pvarState )
        return E_POINTER;

    if ( VT_I4 == varChild.vt && CHILDID_SELF == varChild.lVal )
    {
        // reset the out variable
        V_VT(pvarState) = VT_EMPTY;

        V_VT(pvarState) = VT_I4;
        V_I4(pvarState) = STATE_SYSTEM_FOCUSED | STATE_SYSTEM_FOCUSABLE |
                STATE_SYSTEM_MULTISELECTABLE | STATE_SYSTEM_SELECTABLE |
                STATE_SYSTEM_SELECTED;
        return S_OK;
    }
    else
        return m_pAcc->get_accState(varChild, pvarState);
}


STDMETHODIMP  CAccessibleWrapper::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{
    return m_pAcc->get_accHelp(varChild, pszHelp);
}


STDMETHODIMP  CAccessibleWrapper::get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic)
{
    return m_pAcc->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
}


STDMETHODIMP  CAccessibleWrapper::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut)
{
    return m_pAcc->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
}


STDMETHODIMP  CAccessibleWrapper::get_accFocus(VARIANT * pvarFocusChild)
{
    return m_pAcc->get_accFocus(pvarFocusChild);
}


STDMETHODIMP  CAccessibleWrapper::get_accSelection(VARIANT * pvarSelectedChildren)
{
    return m_pAcc->get_accSelection(pvarSelectedChildren);
}


STDMETHODIMP  CAccessibleWrapper::get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction)
{
    return m_pAcc->get_accDefaultAction(varChild, pszDefaultAction);
}



STDMETHODIMP  CAccessibleWrapper::accSelect(long flagsSel, VARIANT varChild)
{
    return m_pAcc->accSelect(flagsSel, varChild);
}


STDMETHODIMP  CAccessibleWrapper::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    return m_pAcc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
}


STDMETHODIMP  CAccessibleWrapper::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    return m_pAcc->accNavigate(navDir, varStart, pvarEndUpAt);
}


STDMETHODIMP  CAccessibleWrapper::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{
    return m_pAcc->accHitTest(xLeft, yTop, pvarChildAtPoint);
}


STDMETHODIMP  CAccessibleWrapper::accDoDefaultAction(VARIANT varChild)
{
    return m_pAcc->accDoDefaultAction(varChild);
}



STDMETHODIMP  CAccessibleWrapper::put_accName(VARIANT varChild, BSTR szName)
{
    return m_pAcc->put_accName(varChild, szName);
}


STDMETHODIMP  CAccessibleWrapper::put_accValue(VARIANT varChild, BSTR pszValue)
{
    return m_pAcc->put_accValue(varChild, pszValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\log.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       log.cpp
//
//  Contents:   Definition of CLogOnHoursDlg
//		Dialog displaying the weekly logging hours for a particular user.
//
//	HISTORY
//	17-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "resource.h"
#include "Log.h"
#include "resource.h"

#include "log_gmt.h"		// NetpRotateLogonHours ()



#define cbLogonArrayLength	 (7 * 24)		// Number of bytes in Logon array

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CLogOnHoursDlg dialog
CLogOnHoursDlg::CLogOnHoursDlg ( UINT nIDTemplate, CWnd* pParentWnd, bool fInputAsGMT, bool bAddDaylightBias) 
		: CScheduleBaseDlg (nIDTemplate, bAddDaylightBias, pParentWnd),
        m_fInputAsGMT (fInputAsGMT)
{
	Init();
}


CLogOnHoursDlg::CLogOnHoursDlg (CWnd* pParent, bool fInputAsGMT) : 
    CScheduleBaseDlg (CLogOnHoursDlg::IDD, false, pParent),
    m_fInputAsGMT (fInputAsGMT)
{
	Init();
}

void CLogOnHoursDlg::Init()
{
	//{{AFX_DATA_INIT (CLogOnHoursDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_prgbData21 = NULL;

}

void CLogOnHoursDlg::DoDataExchange (CDataExchange* pDX)
{
	CScheduleBaseDlg::DoDataExchange (pDX);
	//{{AFX_DATA_MAP(CLogOnHoursDlg)
		DDX_Control ( pDX, IDC_BUTTON_ADD_HOURS, m_buttonAdd );
		DDX_Control ( pDX, IDC_BUTTON_REMOVE_HOURS, m_buttonRemove );
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP (CLogOnHoursDlg, CScheduleBaseDlg)
	//{{AFX_MSG_MAP(CLogOnHoursDlg)
	ON_BN_CLICKED (IDC_BUTTON_ADD_HOURS, OnButtonAddHours)
	ON_BN_CLICKED (IDC_BUTTON_REMOVE_HOURS, OnButtonRemoveHours)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP ()


BOOL CLogOnHoursDlg::OnInitDialog () 
{
	CScheduleBaseDlg::OnInitDialog ();

	// Set up the "on" legend
	m_legendOn.Init ( this, IDC_STATIC_LEGEND_ON, &m_schedulematrix, 100);

	// Set up the "off" legend
	m_legendOff.Init ( this, IDC_STATIC_LEGEND_OFF, &m_schedulematrix, 0);

    if ( GetFlags () & SCHED_FLAG_READ_ONLY )
    {
        // Disable the add and remove buttons
        m_buttonAdd.EnableWindow (FALSE);
        m_buttonRemove.EnableWindow (FALSE);
    }


	return TRUE;
} // CLogOnHoursDlg::OnInitDialog ()

void CLogOnHoursDlg::OnOK () 
{
	if (m_prgbData21 != NULL)
	{
		BYTE rgbDataT[cbLogonArrayLength];
		GetByteArray (OUT rgbDataT);
		ShrinkByteArrayToBitArray (IN rgbDataT, sizeof (rgbDataT), OUT m_prgbData21, 21);
		// Convert back the hours to GMT time.
        if ( m_fInputAsGMT )
    		ConvertLogonHoursToGMT (INOUT m_prgbData21, m_bAddDaylightBias);
	}
	CScheduleBaseDlg::OnOK ();
}

void CLogOnHoursDlg::UpdateButtons ()
{
	UINT nHour = 0;
	UINT nDay = 0;
	UINT nNumHours = 0;
	UINT nNumDays = 0;

	m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
	bool fAllSet = false;		// fAllSet && fAllClear will be changed to true only if something is selected
	bool fAllClear = false;

	if (nNumHours > 0)
	{
		fAllSet = true;
		fAllClear = true;
		for (UINT iDayOfWeek = nDay; iDayOfWeek < nDay+nNumDays; iDayOfWeek++)
		{
			for (UINT iHour = nHour; iHour < nHour+nNumHours; iHour++)
			{
				if (100 == m_schedulematrix.GetPercentage (iHour, iDayOfWeek))
				{
					fAllClear = false;
				}
				else
				{
					fAllSet = false;
				}
			} // for
		} // for
	}

	ASSERT (! (fAllSet && fAllClear));  // these can't both be true!
	m_buttonAdd.SetCheck (fAllSet ? 1 : 0);
	m_buttonRemove.SetCheck (fAllClear ? 1 : 0);
}

void CLogOnHoursDlg::OnButtonAddHours () 
{
	UINT nHour = 0;
	UINT nDay = 0;
	UINT nNumHours = 0;
	UINT nNumDays = 0;

	m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
	if (nNumHours <= 0)
		return;	// Nothing selected
	m_schedulematrix.SetPercentage (100, nHour, nDay, nNumHours, nNumDays);
	UpdateButtons ();
}

void CLogOnHoursDlg::OnButtonRemoveHours () 
{
	UINT nHour = 0;
	UINT nDay = 0;
	UINT nNumHours = 0;
	UINT nNumDays = 0;

	m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
	if (nNumHours <= 0)
		return;	// Nothing selected
	m_schedulematrix.SetPercentage (0, nHour, nDay, nNumHours, nNumDays);
	UpdateButtons ();
}




/////////////////////////////////////////////////////////////////////
//	SetLogonBitArray ()
//
//	Set the bit array representing the logon hours for a user.
//
//	The parameter rgbData is used as both an input and output parameter.
//
void CLogOnHoursDlg::SetLogonBitArray (INOUT BYTE rgbData[21])
{
	ASSERT (rgbData);
	m_prgbData21 = rgbData;
} // SetLogonBitArray ()


/////////////////////////////////////////////////////////////////////
//	ShrinkByteArrayToBitArray ()
//
//	Convert an array of bytes into an array of bits.  Each
//	byte will be stored as one bit in the array of bits.
//
//	INTERFACE NOTES
//	The first bit of the array of bits is the boolean
//	value of the first byte of the array of bytes.
//
void
ShrinkByteArrayToBitArray (
	const BYTE rgbDataIn[],		// IN: Array of bytes
	int cbDataIn,				// IN: Number of bytes in rgbDataIn
	BYTE rgbDataOut[],			// OUT: Array of bits (stored as an array of bytes)
	int /*cbDataOut*/)				// IN: Number of bytes in output buffer
{
	ASSERT (rgbDataIn);
	ASSERT (rgbDataOut);

	const BYTE * pbSrc = rgbDataIn;
	BYTE * pbDst = rgbDataOut;
	while (cbDataIn > 0)
	{
		BYTE b = 0;
		for (int i = 8; i > 0; i--)
		{
			ASSERT (cbDataIn > 0);
			cbDataIn--;
			b >>= 1;

			if ( *pbSrc )
				b |= 0x80;		// bit 0 is on the right, as in: 7 6 5 4 3 2 1 0
			pbSrc++;
		}
		*pbDst++ = b;
	} // while
} // ShrinkByteArrayToBitArray ()


/////////////////////////////////////////////////////////////////////
void
ExpandBitArrayToByteArray (
	const BYTE rgbDataIn[],		// IN: Array of bits (stored as an array of bytes)
	int cbDataIn,				// IN: Number of bytes in rgbDataIn
	BYTE rgbDataOut[],			// OUT: Array of bytes
	int /*cbDataOut*/)				// IN: Number of bytes in output buffer
{
	ASSERT (rgbDataIn);
	ASSERT (rgbDataOut);

	const BYTE * pbSrc = rgbDataIn;
	BYTE * pbDst = rgbDataOut;
	while (cbDataIn > 0)
	{
		ASSERT (cbDataIn > 0);
		cbDataIn--;
		BYTE b = *pbSrc;
		pbSrc++;
		for (int i = 8; i > 0; i--)
		{
			*pbDst = (BYTE) ((b & 0x01) ? 1 : 0);	// bit 0 is on the right of each bit
			pbDst++;
			b >>= 1;
		}
	} // while
} // ExpandBitArrayToByteArray ()


/////////////////////////////////////////////////////////////////////
//	Converts the logon hours from local time to GMT.
void 
ConvertLogonHoursToGMT (INOUT BYTE rgbData[21], IN bool	bAddDaylightBias)
{
	VERIFY ( ::NetpRotateLogonHours (rgbData, 21 * 8, TRUE, bAddDaylightBias) );
}

/////////////////////////////////////////////////////////////////////
//	Converts the logon hours from GMT to local time.
void
ConvertLogonHoursFromGMT (INOUT BYTE rgbData[21], IN bool bAddDaylightBias)
{
	VERIFY ( ::NetpRotateLogonHours (rgbData, 21 * 8, FALSE, bAddDaylightBias) );
}




/////////////////////////////////////////////////////////////////////
//	LogonScheduleDialog ()
//
//	Invoke a dialog to set/modify a schedule, for example
//      -- the logon hours for a particular user
//      -- the schedule for a connection
//
//	RETURNS
//	Return S_OK if the user clicked on the OK button.
//	Return S_FALSE if the user clicked on the Cancel button.
//	Return E_OUTOFMEMORY if there is not enough memory.
///	Return E_UNEXPECTED if an expected error occured (eg: bad parameter)
//
//	INTERFACE NOTES
//	Each bit in the array represents one hour.  As a result, the
//	expected length of the array should be (24 / 8) * 7 = 21 bytes.
//	For convenience, the first day of the week is Sunday and
//	the last day is Saturday.
//	Consequently, the first bit of the array represents the schedule
//	for Sunday during period 12 AM to 1 AM.
//	- If *pprgbData is NULL, then the routine will allocate
//	  an array of 21 bytes using LocalAlloc ().  The caller
//	  is responsible of releasing the memory using LocalFree ().
//  - If *pprgbData is not NULL, the routine re-use the array as its
//	  output parameter.
//
//	HISTORY
//	17-Jul-97	t-danm		Creation.
//	16-Sep-97	jonn		Changed to UiScheduleDialog
//

HRESULT
LogonScheduleDialog(
	HWND hwndParent,		// IN: Parent's window handle
	BYTE ** pprgbData,	    // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
	LPCTSTR pszTitle)       // IN: Dialog title
{
    return LogonScheduleDialogEx (hwndParent, pprgbData, pszTitle, SCHED_FLAG_INPUT_GMT);
}

HRESULT
LogonScheduleDialogEx(
	HWND hwndParent,		// IN: Parent's window handle
	BYTE ** pprgbData,	    // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
	LPCTSTR pszTitle,       // IN: Dialog title
    DWORD  dwFlags)		
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(::IsWindow(hwndParent));
	ASSERT(pprgbData != NULL);
	ASSERT(pszTitle != NULL);
	ENDORSE(*pprgbData == NULL);	// TRUE => Use default logon hours (7x24)

	if (*pprgbData == NULL)
	{
		BYTE * pargbData;	// Pointer to allocated array of bytes
		pargbData = (BYTE *)LocalAlloc(0, 21);	// Allocate 21 bytes
		if (pargbData == NULL)
			return E_OUTOFMEMORY;
		// Set the logon hours to be valid 24 hours a day and 7 days a week.
		memset(OUT pargbData, -1, 21);
		*pprgbData = pargbData;
	}

    // If hwndParent passed in, create a CWnd to pass as the parent window
    CWnd* pWnd = 0;
    if ( ::IsWindow (hwndParent) )
    {
        pWnd = new CWnd;
        if ( pWnd )
        {
            pWnd->Attach (hwndParent);
        }
        else
            return E_OUTOFMEMORY;
    }
    HRESULT hr = S_OK;
    bool    fInputAsGMT = true;

    if ( dwFlags & SCHED_FLAG_INPUT_LOCAL_TIME )
        fInputAsGMT = false;
    CLogOnHoursDlg dlg (pWnd, fInputAsGMT);
    dlg.SetTitle (pszTitle);
	dlg.SetLogonBitArray(INOUT *pprgbData);
    dlg.SetFlags (dwFlags);
	if (IDOK != dlg.DoModal())
		hr = S_FALSE;

    if ( pWnd )
    {
        pWnd->Detach ();
        delete pWnd;
    }

    return hr;
} // LogonScheduleDialog()

HRESULT
DialinHoursDialog (
	HWND hwndParent,		// IN: Parent's window handle
	BYTE ** pprgbData,	    // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
	LPCTSTR pszTitle)		// IN: Dialog title
{
    return DialinHoursDialogEx (hwndParent, pprgbData, pszTitle, SCHED_FLAG_INPUT_GMT);
}

HRESULT
DialinHoursDialogEx (
	HWND hwndParent,		// IN: Parent's window handle
	BYTE ** pprgbData,	    // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
	LPCTSTR pszTitle,		// IN: Dialog title
    DWORD  dwFlags) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(::IsWindow(hwndParent));
	ASSERT(pprgbData != NULL);
	ASSERT(pszTitle != NULL);
	ENDORSE(*pprgbData == NULL);	// TRUE => Use default logon hours (7x24)

	if (*pprgbData == NULL)
	{
		BYTE * pargbData;	// Pointer to allocated array of bytes
		pargbData = (BYTE *)LocalAlloc(0, 21);	// Allocate 21 bytes
		if (pargbData == NULL)
			return E_OUTOFMEMORY;
		// Set the logon hours to be valid 24 hours a day and 7 days a week.
		memset(OUT pargbData, -1, 21);
		*pprgbData = pargbData;
	}

    // If hwndParent passed in, create a CWnd to pass as the parent window
    CWnd* pWnd = 0;
    if ( ::IsWindow (hwndParent) )
    {
        pWnd = new CWnd;
        if ( pWnd )
        {
            pWnd->Attach (hwndParent);
        }
        else
            return E_OUTOFMEMORY;
    }

    HRESULT hr = S_OK;
    bool    fInputAsGMT = true;

    if ( dwFlags & SCHED_FLAG_INPUT_LOCAL_TIME )
        fInputAsGMT = false;
    CDialinHours dlg (pWnd, fInputAsGMT);
    dlg.SetTitle (pszTitle);
	dlg.SetLogonBitArray(INOUT *pprgbData);
    dlg.SetFlags (dwFlags);
	if (IDOK != dlg.DoModal())
		hr = S_FALSE;

    if ( pWnd )
    {
        pWnd->Detach ();
        delete pWnd;
    }

    return hr;
} // DialinHoursDialog()

void CLogOnHoursDlg::InitMatrix()
{
	if ( m_prgbData21 )
	{
		BYTE rgbitData[21];		// Array of logonhours bits
		// Make a copy of the logon hours (in case the user click on cancel button)
		memcpy (OUT rgbitData, IN m_prgbData21, sizeof (rgbitData));
		// Convert the hours from GMT to local hours.
        if ( m_fInputAsGMT )
		    ConvertLogonHoursFromGMT (INOUT rgbitData, m_bAddDaylightBias);
		BYTE rgbDataT[cbLogonArrayLength];
		ExpandBitArrayToByteArray (IN rgbitData, 21, OUT rgbDataT, sizeof (rgbDataT));
		// Initialize the matrix
		InitMatrix2 (IN rgbDataT);
	}
}

UINT CLogOnHoursDlg::GetPercentageToSet(const BYTE bData)
{
	ASSERT (TRUE == bData || FALSE == bData);
	return (TRUE == bData) ? 100 : 0;
}

BYTE CLogOnHoursDlg::GetMatrixPercentage(UINT nHour, UINT nDay)
{
	return (BYTE) ((100 == m_schedulematrix.GetPercentage (nHour, nDay)) ?
					TRUE : FALSE);
}

UINT CLogOnHoursDlg::GetExpectedArrayLength()
{
	return cbLogonArrayLength;
}

// Called when WM_TIMECHANGE is received
void CLogOnHoursDlg::TimeChange()
{
	m_buttonAdd.EnableWindow (FALSE);
	m_buttonRemove.EnableWindow (FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CDialinHours dialog


CDialinHours::CDialinHours(CWnd* pParent, bool fInputAsGMT)
	: CLogOnHoursDlg(CDialinHours::IDD, pParent, fInputAsGMT, false)
{
	//{{AFX_DATA_INIT(CDialinHours)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

BEGIN_MESSAGE_MAP(CDialinHours, CLogOnHoursDlg)
	//{{AFX_MSG_MAP(CDialinHours)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDialinHours message handlers


/////////////////////////////////////////////////////////////////////////////
// CDirSyncScheduleDlg dialog

CDirSyncScheduleDlg::CDirSyncScheduleDlg(CWnd* pParent /*=NULL*/)
	: CLogOnHoursDlg(CDirSyncScheduleDlg::IDD, pParent, true, false)
{
	//{{AFX_DATA_INIT(CDirSyncScheduleDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDirSyncScheduleDlg::DoDataExchange(CDataExchange* pDX)
{
	CLogOnHoursDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDirSyncScheduleDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDirSyncScheduleDlg, CLogOnHoursDlg)
	//{{AFX_MSG_MAP(CDirSyncScheduleDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CDirSyncScheduleDlg::OnInitDialog() 
{
	CLogOnHoursDlg::OnInitDialog();

	m_schedulematrix.SetSel (0, 0, 1, 1);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDirSyncScheduleDlg message handlers
//
//  The data is passed in in GMT
//

HRESULT
DirSyncScheduleDialog(
	HWND hwndParent,		// IN: Parent's window handle
	BYTE ** pprgbData,	    // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
	LPCTSTR pszTitle)		// IN: Dialog title
{
    return DirSyncScheduleDialogEx (hwndParent, pprgbData, pszTitle, 0);
} // DirSyncScheduleDialog()

HRESULT
DirSyncScheduleDialogEx(
	HWND hwndParent,		// IN: Parent's window handle
	BYTE ** pprgbData,	    // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
	LPCTSTR pszTitle,		// IN: Dialog title
    DWORD   dwFlags)        // IN: Option flags
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	ASSERT(::IsWindow(hwndParent));
	ASSERT(pprgbData != NULL);
	ASSERT(pszTitle != NULL);
	ENDORSE(*pprgbData == NULL);	// TRUE => Use default logon hours (7x24)

	if (*pprgbData == NULL)
	{
		BYTE * pargbData;	// Pointer to allocated array of bytes
		pargbData = (BYTE *)LocalAlloc(0, 21);	// Allocate 21 bytes
		if (pargbData == NULL)
			return E_OUTOFMEMORY;
		// Set the logon hours to be valid 24 hours a day and 7 days a week.
		memset(OUT pargbData, -1, 21);
		*pprgbData = pargbData;
	}

    // If hwndParent passed in, create a CWnd to pass as the parent window
    CWnd* pWnd = 0;
    if ( ::IsWindow (hwndParent) )
    {
        pWnd = new CWnd;
        if ( pWnd )
        {
            pWnd->Attach (hwndParent);
        }
        else
            return E_OUTOFMEMORY;
    }

    HRESULT             hr = S_OK;
	CDirSyncScheduleDlg dlg (pWnd);
    dlg.SetTitle (pszTitle);
	dlg.SetLogonBitArray(INOUT *pprgbData);
    dlg.SetFlags (dwFlags);
	if (IDOK != dlg.DoModal())
		hr = S_FALSE;

    if ( pWnd )
    {
        pWnd->Detach ();
        delete pWnd;
    }

	return hr;
} // DirSyncScheduleDialogEx()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\log.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       log.h
//
//  Contents:   Definition of CLogOnHoursDlg
//
//----------------------------------------------------------------------------

#if !defined(AFX_LOGHOURS_H__0F68A435_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_)
#define AFX_LOGHOURS_H__0F68A435_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "SchedBas.h"

#ifndef INOUT
	#define INOUT
	#define ENDORSE(f)	// Macro which is the opposite of ASSERT()
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	Exported Functions
//
#include "loghrapi.h"

/////////////////////////////////////////////////////////////////////////////
//
//	Private Functions
//

/////////////////////////////////////////////////////////////////////////////
void ShrinkByteArrayToBitArray(const BYTE rgbDataIn[], int cbDataIn, BYTE rgbDataOut[], int cbDataOut);
void ExpandBitArrayToByteArray(const BYTE rgbDataIn[], int cbDataIn, BYTE rgbDataOut[], int cbDataOut);


void ConvertLogonHoursToGMT(INOUT BYTE rgbData[21], IN bool bAddDaylightBias);
void ConvertLogonHoursFromGMT(INOUT BYTE rgbData[21], IN bool bAddDaylightBias);


/////////////////////////////////////////////////////////////////////////////
// CLogOnHoursDlg dialog
class CLogOnHoursDlg : public CScheduleBaseDlg
{
protected:
	CLogOnHoursDlg( UINT nIDTemplate, CWnd* pParentWnd, bool fInputAsGMT, bool bAddDaylightBias);

	void Init();

public:
	CLogOnHoursDlg(CWnd* pParent, bool fInputAsGMT);   // standard constructor

    virtual int GetIDD ()
    {
        return IDD;
    }

// Dialog Data
	//{{AFX_DATA(CLogOnHoursDlg)
	enum { IDD = IDD_LOGON_HOURS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLogOnHoursDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

protected:
	// Generated message map functions
	//{{AFX_MSG(CLogOnHoursDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnButtonAddHours();
	afx_msg void OnButtonRemoveHours();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	CLegendCell m_legendOn;
	CLegendCell m_legendOff;
	CButton m_buttonAdd;
	CButton m_buttonRemove;
	BYTE * m_prgbData21;					// Pointer to an array of 21 bytes
public:	

protected:
	virtual void TimeChange();
	virtual UINT GetExpectedArrayLength();
	virtual BYTE GetMatrixPercentage (UINT nHour, UINT nDay);
	virtual UINT GetPercentageToSet (const BYTE bData);
	virtual void InitMatrix ();
	virtual void UpdateButtons();

public:
	void SetLogonBitArray(INOUT BYTE rgbData[21]);

private:
	const bool m_fInputAsGMT;
}; // CLogOnHoursDlg

/////////////////////////////////////////////////////////////////////////////
// CDialinHours dialog

class CDialinHours : public CLogOnHoursDlg
{
// Construction
public:
	CDialinHours(CWnd* pParent, bool fInputAsGMT);   // standard constructor

    virtual int GetIDD ()
    {
        return IDD;
    }

// Dialog Data
	//{{AFX_DATA(CDialinHours)
	enum { IDD = IDD_DIALIN_HOURS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDialinHours)
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDialinHours)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CDirSyncScheduleDlg dialog

class CDirSyncScheduleDlg : public CLogOnHoursDlg
{
// Construction
public:
	CDirSyncScheduleDlg(CWnd* pParent = NULL);   // standard constructor

    virtual int GetIDD ()
    {
        return IDD;
    }

// Dialog Data
	//{{AFX_DATA(CDirSyncScheduleDlg)
	enum { IDD = IDD_DIRSYNC_SCHEDULE };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDirSyncScheduleDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnInitDialog();
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDirSyncScheduleDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


#endif // !defined(AFX_LOGHOURS_H__0F68A435_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\dcpromo\helper\dcphelp.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// domain controller promotion wizard helper
//
// 8-13-99 sburns



#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME = L"dcpromohelp";

DWORD DEFAULT_LOGGING_OPTIONS =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_HEADER;



// Template function that actually calls ADsGetObject.
// 
// Interface - The IADsXXX interface of the object to be bound.
// 
// path - The ADSI path of the object to be bound.
// 
// ptr - A null smart pointer to be bound to the interface of the object.

template <class Interface> 
static
HRESULT
TemplateGetObject(
   const String&              path,
   SmartInterface<Interface>& ptr)
{
   LOG_FUNCTION2(TemplateGetObject, path);
   ASSERT(!path.empty());

   Interface* p = 0;
   HRESULT hr = 
      ::ADsGetObject(
         path.c_str(),
         __uuidof(Interface), 
         reinterpret_cast<void**>(&p));
   if (SUCCEEDED(hr))
   {
      ptr.Acquire(p);
   }

   return hr;
}



// Start csvde.exe with appropriate parameters, running without a window
//
// domainDn - full DN of the domain into which the display specifiers are
// to be imported. e.g. DC=foo,DC=bar,DC=com

HRESULT
StartCsvde(const String& domainDn)
{
   LOG_FUNCTION2(StartCsvde, domainDn);
   ASSERT(!domainDn.empty());

   String windir   = Win::GetSystemWindowsDirectory();
   String logPath  = windir + L"\\debug";

   String sys32dir = Win::GetSystemDirectory();
   String csvPath  = sys32dir + L"\\mui\\dispspec\\dcpromo.csv";
   String exePath  = sys32dir + L"\\csvde.exe";

   String commandLine =
      String::format(
         L" -i -f %1 -c DOMAINPLACEHOLDER %2 -j %3",
         csvPath.c_str(),
         domainDn.c_str(),
         logPath.c_str());

   STARTUPINFO startupInfo;
   memset(&startupInfo, 0, sizeof(startupInfo));
   startupInfo.cb = sizeof(startupInfo);

   PROCESS_INFORMATION procInfo;
   memset(&procInfo, 0, sizeof(procInfo));

   LOG(L"Calling CreateProcess");
   LOG(exePath);
   LOG(commandLine);

   HRESULT hr = S_OK;

   size_t len = commandLine.length();
   WCHAR* tempCommandLine = new WCHAR[len + 1];
   memset(tempCommandLine, 0, sizeof(WCHAR) * (len + 1));
   commandLine.copy(tempCommandLine, len);

   BOOL result =
      ::CreateProcessW(
         exePath.c_str(),
         tempCommandLine,
         0,
         0,
         FALSE,
         CREATE_NO_WINDOW, 
         0,
         0,
         &startupInfo,
         &procInfo);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   LOG_HRESULT(hr);

   delete[] tempCommandLine;

   return hr;
}



HRESULT
DoIt()
{
   LOG_FUNCTION(DoIt);

   HRESULT hr = S_OK;
   do
   {
      hr = ::CoInitialize(0);
      BREAK_ON_FAILED_HRESULT2(hr, L"CoInitialize failed");

      // make sure the DS is running.  If it is, then this implies that the
      // local machine is a DC, the local machine is not in safe boot mode,
      // and the local machine is at least version >= 5

      if (!IsDSRunning())
      {
         LOG(L"Active Directory is not running -- unable to proceed");

         hr = E_FAIL;
         break;
      }

      // bind to the RootDse on the local machine

      SmartInterface<IADs> iads(0);
      hr = TemplateGetObject<IADs>(L"LDAP://RootDse", iads);
      BREAK_ON_FAILED_HRESULT2(hr, L"bind to rootdse failed");

      // read the default naming context.  This is the DN of the domain for
      // which the machine is a domain controller.

      _variant_t variant;
      hr = iads->Get(AutoBstr(L"defaultNamingContext"), &variant);
      BREAK_ON_FAILED_HRESULT2(hr, L"bind to default naming context failed");

      String domainDn = V_BSTR(&variant);

      LOG(domainDn);
      ASSERT(!domainDn.empty());

      hr = StartCsvde(domainDn);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



int
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   int exitCode = 0;

   HANDLE mutex = 0;
   HRESULT hr = Win::CreateMutex(0, true, RUNTIME_NAME, mutex);
   if (hr == Win32ToHresult(ERROR_ALREADY_EXISTS))
   {
      LOG(L"already running.  That's weird.");
      exitCode = 1;
   }
   else
   {
      HRESULT hr = DoIt();

      if (FAILED(hr))
      {
         LOG(GetErrorMessage(hr));

         exitCode = 2;
      }
   }

   return exitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\loghours.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       LogHours.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// LogHours.h : main header file for the LOGHOURS DLL
//

#if !defined(AFX_LOGHOURS_H__0F68A43B_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_)
#define AFX_LOGHOURS_H__0F68A43B_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CLogHoursApp
// See LogHours.cpp for the implementation of this class
//

class CLogHoursApp : public CWinApp
{
public:
	CLogHoursApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLogHoursApp)
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CLogHoursApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	virtual BOOL InitInstance ();
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOGHOURS_H__0F68A43B_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\loghrapi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       LogHrAPI.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// loghours.h : header file

#if !defined(_LOGHOURS_H_)
#define _LOGHOURS_H_

#define cbScheduleArrayLength       21      // Number of bytes in the schedule array
#define cbDsScheduleArrayLength     84      // Number of bytes in the schedule array

/////////////////////////////////////////////////////////////////////////////
//
//	Exported Functions
//

//	UiScheduleDialog()
//
//	Invoke a dialog to set/modify a schedule, for example
//      -- the logon hours for a particular user
//      -- the schedule for a connection
//
//	RETURNS
//	Return S_OK if the user clicked on the OK button.
//	Return S_FALSE if the user clicked on the Cancel button.
//	Return E_OUTOFMEMORY if there is not enough memory.
///	Return E_UNEXPECTED if an expected error occured (eg: bad parameter)
//
//	INTERFACE NOTES
//	Each bit in the array represents one hour.  As a result, the
//	expected length of the array should be (24 / 8) * 7 = 21 bytes.
//	For convenience, the first day of the week is Sunday and
//	the last day is Saturday.
//	Consequently, the first bit of the array represents the schedule
//	for Sunday during period 12 AM to 1 AM.
//	- If *pprgbData is NULL, then the routine will allocate
//	  an array of 21 bytes using LocalAlloc().  The caller
//	  is responsible of releasing the memory using LocalFree().
//  - If *pprgbData is not NULL, the routine expect the array to contain
//	  21 bytes of data and re-uses the array as its output parameter.
//
//	HISTORY
//	17-Jul-97	t-danm		Creation.
//	16-Sep-97	jonn		Changed to UiScheduleDialog
//  26-Mar-98   bryanwal	Changed to ConnectionScheduleDialog
//

///////////////////////////////////////////////////////////////////////////////
// Flags for LogonScheduleDialogEx, DialinHoursDialogEx, 
//      ConnectionScheduleDialogEx, ReplicationScheduleDialogEx
///////////////////////////////////////////////////////////////////////////////
// The input data is in GMT
#define SCHED_FLAG_INPUT_GMT        0x00000000  // default

// The input data is in local time.
#define SCHED_FLAG_INPUT_LOCAL_TIME	0x00000001  // supported only in 
                                                // LogonScheduleDialogEx and 
                                                // DialinHoursDialogEx

#define SCHED_FLAG_READ_ONLY        0x00000002  // the dialog is read-only


// This version accepts data only in GMT
HRESULT LogonScheduleDialog(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                         LPCTSTR pszTitle);     // dialog title

// This version allows the caller to specify if the data is in GMT or local time
HRESULT LogonScheduleDialogEx (HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                         LPCTSTR pszTitle,     // dialog title
                         DWORD  dwFlags);    


//  13-May-98   weijiang   
// clone of LogScheduleDialog, using different dialog template -- IDD_DIALINHOUR
// to set hours for dialin

// This version accepts data only in GMT
HRESULT DialinHoursDialog(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                         LPCTSTR pszTitle);     // dialog title
 
// This version allows the caller to specify if the data is in GMT or local time
HRESULT DialinHoursDialogEx (HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 21 bytes
                         LPCTSTR pszTitle,     // dialog title
                         DWORD  dwFlags);    

//	ConnectionScheduleDialog()
//
//	This function takes the same form as LogonScheduleDialog(), but it modifies
//	the schedule for DS replication.  This schedule has 4 bits per hours,
//	one for each 15-minute period, so the array contains 84 bytes instead of 21.
//
//  NOTE:  ConnectionScheduleDialog takes the schedule in GMT
//
//	HISTORY
//	02-Jan-98	jonn		Creation.
//  26-Mar-98   bryanwal	Changed to ConnectionScheduleDialog
//
HRESULT ConnectionScheduleDialog(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
                         LPCTSTR pszTitle);     // dialog title

HRESULT ConnectionScheduleDialogEx(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
                         LPCTSTR pszTitle,     // dialog title
                         DWORD   dwFlags);

// Same as ConnectionScheduleDialog, but 2 states are shown
HRESULT ReplicationScheduleDialog(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
                         LPCTSTR pszTitle);     // dialog title

HRESULT ReplicationScheduleDialogEx(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
                         LPCTSTR pszTitle,     // dialog title
                         DWORD   dwFlags);      // option flags

//	DirSyncScheduleDialog()
//
//	This function takes the same form as LogonScheduleDialog(), but it modifies
//	the schedule for Directory Synchronization.
//
//	HISTORY
//  11-Sep-98   bryanwal	Added DirSyncScheduleDialog
//
HRESULT DirSyncScheduleDialog(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
                         LPCTSTR pszTitle);     // dialog title

HRESULT DirSyncScheduleDialogEx(HWND hwndParent,       // parent window
                         BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
                         LPCTSTR pszTitle,     // dialog title
                         DWORD   dwFlags);      // option flags
#endif // !defined(_LOGHOURS_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\loghours.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Loghours.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// LogHours.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include <locale.h>
#include "LogHours.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CLogHoursApp

BEGIN_MESSAGE_MAP(CLogHoursApp, CWinApp)
	//{{AFX_MSG_MAP(CLogHoursApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogHoursApp construction

CLogHoursApp::CLogHoursApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

BOOL CLogHoursApp::InitInstance ()
{
	_wsetlocale (LC_ALL, L"");
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CLogHoursApp object

CLogHoursApp theApp;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\log_gmt.h ===
/*++

Copyright (c) 1987-2001  Microsoft Corporation

Module Name:

    log_gmt.h (originally named loghours.h)

Abstract:

    Private routines to support rotation of logon hours between local time
    and GMT time.

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
	16-Mar-93		cliffv		Creation.
	22-Jul-97		t-danm		Copied from /nt/private/nw/convert/nwconv/loghours.c.

--*/



//
// Procedure forwards from loghours.c
//

BOOLEAN NetpRotateLogonHoursPhase1(
    IN BOOL		ConvertToGmt,
	IN bool		bAddDaylightBias,
    OUT PULONG	RotateCount);

BOOLEAN NetpRotateLogonHoursPhase2(
    IN PBYTE LogonHours,
    IN DWORD UnitsPerWeek,
    IN LONG  RotateCount);

BOOLEAN NetpRotateLogonHours(
    IN OUT PBYTE	rgbLogonHours,
    IN DWORD		cbitUnitsPerWeek,
    IN BOOL			fConvertToGmt,
	IN bool			bAddDaylightBias);

BOOLEAN NetpRotateLogonHoursBYTE(
    IN OUT PBYTE	rgbLogonHours,
    IN DWORD		cbitUnitsPerWeek,
    IN BOOL			fConvertToGmt,
	IN bool			bAddDaylightBias);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\log_gmt.cpp ===
/*++

Copyright (c) 1987-2001  Microsoft Corporation

Module Name:

    log_gmt.cpp (originally named loghours.c)

Abstract:

    Private routines to support rotation of logon hours between local time
    and GMT time.

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:
	16-Mar-93		cliffv		Creation.
	22-Jul-97		t-danm		Copied from /nt/private/nw/convert/nwconv/loghours.c
								and adapted to loghours.dll.

--*/

//#include "stdafx.h"

#pragma warning (disable : 4514)
#pragma warning (push,3)
extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>

}

#include <limits.h>
#include <math.h>

#include <lmcons.h>
#include <lmaccess.h>
#pragma warning (pop)

#include "log_gmt.h"

//#pragma hdrstop

/*++
Routine NetpRotateLogonHoursPhase1()

    Determine the amount to rotate the logon hours by to convert to/from GMT

Arguments:

    ConvertToGmt -
        True to convert the logon hours from local time to GMT relative
        False to convert the logon hours from GMT relative to local time

    RotateCount - Returns the number of bits to shift by.

Return Value:

    TRUE if the RotateCount could be computed
    FALSE if a RotateCount could not be computed

--*/
BOOLEAN
NetpRotateLogonHoursPhase1(
    IN BOOL		ConvertToGmt,
	IN bool		bAddDaylightBias,
    OUT PLONG	RotateCount)
{
    TIME_ZONE_INFORMATION	tzi;
    LONG					BiasInHours = 0;
	LONG					DSTBias = 0;

    //
    // Get the timezone data from the registry
    //

    DWORD	dwResult = GetTimeZoneInformation( &tzi );
    if ( TIME_ZONE_ID_INVALID == dwResult ) 
	{
		return FALSE;
    }

    //
    // Compute the amount to rotate the logon hours by
    //
    // Round the bias in minutes to the closest bias in hours.
    // Take into consideration that Bias can be negative.
    // Do this by forcing the Bias to be positive, rounding,
    // then adjusting it back negative again.
    //

	if ( bAddDaylightBias )
	{
		switch (dwResult)
		{
		case TIME_ZONE_ID_DAYLIGHT:
			DSTBias = tzi.DaylightBias;
			break;

		case TIME_ZONE_ID_UNKNOWN:
		case TIME_ZONE_ID_STANDARD:
			DSTBias = tzi.StandardBias;
			break;

		default:
			return FALSE;
		}
	}

	ASSERT( tzi.Bias > -(24*60) );
    BiasInHours = ((tzi.Bias + DSTBias + (24*60) + 30)/60) - 24;


    if ( !ConvertToGmt ) 
	{
        BiasInHours = - BiasInHours;
    }

    *RotateCount = BiasInHours;
    return TRUE;
} // NetpRotateLogonHoursPhase1()



/*++ 
Routine NetpRotateLogonHoursPhase2()

    Rotate the LogonHours bit mask by the required amount.


Arguments:

    LogonHours - Pointer to LogonHour bit mask

    UnitsPerWeek - Number of bits in the bit mask. Must be UNITS_PER_WEEK (168).

    RotateCount - Number of bits to rotate by.  Must be between 31 and -31.
        Negative means to rotate left.
        Positive means to rotate right.

Return Value:

    TRUE if the rotation succeeded.
    FALSE if a parameter was out of range

--*/
BOOLEAN
NetpRotateLogonHoursPhase2(
    IN PBYTE LogonHours,
    IN DWORD UnitsPerWeek,
    IN LONG  RotateCount)
{
    //
    // Useful constants
    //
	const int DWORDS_PER_WEEK = ((UNITS_PER_WEEK+31)/32);
	const int BYTES_PER_WEEK = (UNITS_PER_WEEK/8);

    DWORD	AlignedLogonHours[DWORDS_PER_WEEK+1];
	::ZeroMemory (AlignedLogonHours, sizeof (DWORD) * (DWORDS_PER_WEEK+1));
    LONG	i = 0;

    BOOLEAN RotateLeft = FALSE;

    //
    // Ensure there are 8 bits per byte,
    //  32 bits per DWORD and
    //  units per week is even number of bytes.
    //

#pragma warning(disable : 4127)
    ASSERT( CHAR_BIT == 8 );
    ASSERT( sizeof(DWORD) * CHAR_BIT == 32 );
    ASSERT( UNITS_PER_WEEK/8*8 == UNITS_PER_WEEK );
#pragma warning (default : 4127)


    //
    // Validate the input parameters
    //

    if ( UnitsPerWeek != UNITS_PER_WEEK ) 
	{
        ASSERT( UnitsPerWeek == UNITS_PER_WEEK );
        return FALSE;
    }

    if ( RotateCount == 0 ) 
	{
        return TRUE;
    }

    RotateLeft = (RotateCount < 0);
    RotateCount = labs( RotateCount );
    if ( RotateCount > 31 ) 
	{
        ASSERT ( RotateCount <= 31 );
        return FALSE;
    }


    //
    // Do the left rotate.
    //

    if (RotateLeft) 
	{
        //
        // Copy the logon hours to a DWORD aligned buffer.
        //
        //  Duplicate the first dword at the end of the buffer to make
        //  the rotation code trivial.
        //

        RtlCopyMemory(AlignedLogonHours, LogonHours, BYTES_PER_WEEK );

        RtlCopyMemory( ((PBYTE)AlignedLogonHours)+BYTES_PER_WEEK,
                        LogonHours,
                        sizeof(DWORD) );

        //
        // Actually rotate the data.
        //

        for ( i=0; i < DWORDS_PER_WEEK; i++ ) 
		{
            AlignedLogonHours[i] =
                (AlignedLogonHours[i] >> RotateCount) |
                (AlignedLogonHours[i+1] << (32-RotateCount));
        }

        //
        // Copy the logon hours back to the input buffer.
        //

        RtlCopyMemory( LogonHours, AlignedLogonHours, BYTES_PER_WEEK );


    //
    // Do the right rotate.
    //

    } 
	else 
	{
        //
        // Copy the logon hours to a DWORD aligned buffer.
        //
        // Duplicate the last DWORD at the front of the buffer to make
        //  the rotation code trivial.
        //

        RtlCopyMemory( &AlignedLogonHours[1], LogonHours, BYTES_PER_WEEK );
        RtlCopyMemory( AlignedLogonHours,
                       &LogonHours[BYTES_PER_WEEK-4],
                        sizeof(DWORD));

        //
        // Actually rotate the data.
        //

        for ( i=DWORDS_PER_WEEK-1; i>=0; i-- ) 
		{
            AlignedLogonHours[i+1] =
                (AlignedLogonHours[i+1] << RotateCount) |
                (AlignedLogonHours[i] >> (32-RotateCount));
        }

        //
        // Copy the logon hours back to the input buffer.
        //

        RtlCopyMemory( LogonHours, &AlignedLogonHours[1], BYTES_PER_WEEK );

    }
    return TRUE;

} // NetpRotateLogonHoursPhase2()


/*++
Routine NetpRotateLogonHours()

    Rotate the LogonHours bit mask to/from GMT relative time.


Arguments:

    LogonHours - Pointer to LogonHour bit mask

    UnitsPerWeek - Number of bits in the bit mask. Must be UNITS_PER_WEEK (168).

    ConvertToGmt -
        True to convert the logon hours from local time to GMT relative
        False to convert the logon hours from GMT relative to local time

Return Value:

    TRUE if the rotation succeeded.
    FALSE if a parameter was out of range

--*/
BOOLEAN
NetpRotateLogonHours(
    IN OUT PBYTE	rgbLogonHours,		// Array of 21 bytes
    IN DWORD		cbitUnitsPerWeek,		// Must be 21 * 8 = 168
    IN BOOL			fConvertToGmt,
	IN bool			bAddDaylightBias)
{
    LONG RotateCount = 0;

    //
    // Break the functionality into two phases so that if the caller is doing
    //  this multiple time, he just calls Phase 1 once and Phase 2 multiple
    //  times.
    //

    if ( !NetpRotateLogonHoursPhase1 (fConvertToGmt, bAddDaylightBias, &RotateCount) ) 
	{
        return FALSE;
	}

    return NetpRotateLogonHoursPhase2 (rgbLogonHours, cbitUnitsPerWeek, RotateCount );
} // NetpRotateLogonHours()


/*++
Routine NetpRotateLogonHoursBYTE()

    Rotate the LogonHours BYTE array to/from GMT relative time.
	Each BYTE is one hour. The contents of a BYTE must not change


Arguments:

    LogonHours - Pointer to LogonHour bit mask

    UnitsPerWeek - Number of BYTES in the BYTE array. Must be UNITS_PER_WEEK (168).

    ConvertToGmt -
        True to convert the logon hours from local time to GMT relative
        False to convert the logon hours from GMT relative to local time

Return Value:

    TRUE if the rotation succeeded.
    FALSE if a parameter was out of range

--*/
BOOLEAN
NetpRotateLogonHoursBYTE(
    IN OUT PBYTE	rgbLogonHours,		// Array of 168 bytes
    IN DWORD		cbitUnitsPerWeek,		// Must be 21 * 8 = 168
    IN BOOL			fConvertToGmt,
	IN bool			bAddDaylightBias)
{
    LONG RotateCount = 0;

    //
    // Break the functionality into two phases so that if the caller is doing
    //  this multiple time, he just calls Phase 1 once and Phase 2 multiple
    //  times.
    //

    if ( !NetpRotateLogonHoursPhase1 (fConvertToGmt, bAddDaylightBias, &RotateCount) ) 
	{
        return FALSE;
	}

	BOOLEAN bResult = TRUE;

	ASSERT (RotateCount >= -12 && RotateCount <= 12);
	if ( RotateCount != 0 )
	{
		size_t	numBytes = abs (RotateCount);	
		PBYTE	pTemp = new BYTE[cbitUnitsPerWeek + numBytes];
		if ( pTemp )
		{
			if ( RotateCount < 0 )  // shift left
			{
				// Copy the entire array and then start over with numBytes BYTES from
				// the start of the array to fill up to the end of the temp array.
				// Then shift over numBytes BYTES and copy 168 bytes from the temp
				// array back to the original array.
				memcpy (pTemp, rgbLogonHours, cbitUnitsPerWeek);
				memcpy (pTemp + cbitUnitsPerWeek, rgbLogonHours, numBytes);
				memcpy (rgbLogonHours, pTemp + numBytes, cbitUnitsPerWeek);
			}
			else	// RotateCount > 0 -- shift right
			{
				// Copy numBytes BYTES from the end of the array and then copy 
				// the entire array to fill up to the end of the temp array.
				// The copy 168 bytes from the beginning of the temp array back
				// to the original array.
				memcpy (pTemp, rgbLogonHours + (cbitUnitsPerWeek - numBytes), numBytes);
				memcpy (pTemp + numBytes, rgbLogonHours, cbitUnitsPerWeek);
				memcpy (rgbLogonHours, pTemp, cbitUnitsPerWeek);
			}

			delete [] pTemp;
		}
		else
			bResult = FALSE;
	}

	return bResult;
} // NetpRotateLogonHours()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by log.rc
//
#define IDD_LOGON_HOURS                 800
#define IDC_STATIC_LOGON_MATRIX         800
#define IDC_STATIC_DESCRIPTION          801
#define IDC_BUTTON_ADD_HOURS            802
#define IDC_BUTTON_REMOVE_HOURS         803
#define IDC_STATIC_LEGEND_NONE          806
#define IDC_STATIC_LEGEND_ONE           807
#define IDC_STATIC_LEGEND_TWO           808
#define IDC_STATIC_LEGEND_FOUR          809
#define IDC_STATIC_LEGEND_ON            810
#define IDC_STATIC_LEGEND_OFF           811
#define IDS_TOOL_SCHEDULE_FMT_DAILY     880
#define IDS_TOOL_SCHEDULE_FMT_WEEKLY_LONG 881
#define IDS_TOOL_SCHEDULE_FMT_WEEKLY_SHORT 882
#define IDS_TIMECHANGE                  883
#define IDS_ACTIVE_DIRECTORY_MANAGER    884
#define IDS_ALL_HEADER_TEXT             885
#define IDS_CLOSE                       886
#define IDS_SUNDAY                      887
#define IDS_MONDAY                      888
#define IDS_TUESDAY                     889
#define IDS_WEDNESDAY                   890
#define IDS_THURSDAY                    891
#define IDS_FRIDAY                      892
#define IDS_SATURDAY                    893
#define IDS_MATRIX_ACC_VALUE_MULTIPLE_CELLS 895
#define IDS_REPLICATION_NOT_AVAILABLE   896
#define IDS_REPLICATION_AVAILABLE       897
#define IDS_DO_NOT_REPLICATE            898
#define IDS_REPLICATE_ONCE_PER_HOUR     899
#define IDD_DS_SCHEDULE                 900
#define IDS_REPLICATE_TWICE_PER_HOUR    900
#define IDC_RADIO_NONE                  901
#define IDD_DIALIN_HOURS                901
#define IDS_REPLICATE_FOUR_TIMES_PER_HOUR 901
#define IDC_RADIO_ONE                   902
#define IDD_DIRSYNC_SCHEDULE            902
#define IDS_DONT_SYNCHRONIZE            902
#define IDC_RADIO_TWO                   903
#define IDD_REPLICATION_SCHEDULE        903
#define IDS_SYNCHRONIZE                 903
#define IDC_RADIO_FOUR                  904
#define IDS_LOGON_DENIED                904
#define IDS_LOGON_PERMITTED             905
#define IDS_REPLICATION_SCHEDULE_ACC_DESCRIPTION 906
#define IDS_DS_SCHEDULE_ACC_DESCRIPTION 907
#define IDS_DIRSYNC_SCHEDULE_ACC_DESCRIPTION 908
#define IDS_DIALIN_HOURS_ACC_DESCRIPTION 909
#define IDS_LOGON_HOURS_ACC_DESCRIPTION 910

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        801
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         808
#define _APS_NEXT_SYMED_VALUE           801
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\schedbas.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       SchedBas.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// SchedBas.cpp : implementation file
//

#include "stdafx.h"
#include "log.h"
#include <schedule.h>
#include "SchedBas.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//****************************************************************************
//
//  ReplaceFrameWithControl ()
//
//	Use the a dialog control to set the size of the Schedule Matrix.
//
//	HISTORY
//	17-Jul-97	t-danm		Copied from sample written by Scott Walker.
//
//****************************************************************************
void ReplaceFrameWithControl (CWnd *pWnd, UINT nFrameID, CWnd *pControl, 
                                          BOOL bAssignFrameIDToControl)
	{
    CWnd *pFrame;
    CRect rect;
    
    ASSERT (pWnd != NULL);
    ASSERT (pControl != NULL);

    // Get the frame control
    pFrame = pWnd->GetDlgItem (nFrameID);
    ASSERT (pFrame != NULL);
    
    // Get the frame rect
    pFrame->GetClientRect (&rect);
    pFrame->ClientToScreen (&rect);
    pWnd->ScreenToClient (&rect);

    // Set the control on the frame
    pControl->SetWindowPos (pFrame, rect.left, rect.top, rect.Width (), rect.Height (), 
        SWP_SHOWWINDOW);

    // set the control font to match the dialog font
    pControl->SetFont (pWnd->GetFont ());

    // hide the placeholder frame
    pFrame->ShowWindow (SW_HIDE);

    if (bAssignFrameIDToControl)
        pControl->SetDlgCtrlID ( nFrameID );
	} // ReplaceFrameWithControl


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CLogOnHoursDlg dialog

void CLegendCell::Init (CWnd* pParent, UINT nCtrlID, CScheduleMatrix* pMatrix, UINT nPercentage)
{
    ASSERT (pParent && pMatrix );
    m_pMatrix = pMatrix;
    m_nPercentage = nPercentage;

    // subclass the window so that we get paint notifications
    VERIFY ( SubclassDlgItem ( nCtrlID, pParent ) );

    // Resize the legend cell to have the same interior size as the cells
    // in the schedule matrix
    CSize size = pMatrix->GetCellSize ();
    SetWindowPos ( NULL, 0, 0, size.cx+1, size.cy+1,
        SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOOWNERZORDER | SWP_NOZORDER );
}

void CLegendCell::OnPaint ()
{
    if (NULL == m_pMatrix)
    {
        ASSERT (0);
        return;
    }

    CRect rect;
    GetClientRect (rect);
    PAINTSTRUCT paintStruct;
    CDC *pdc = BeginPaint ( &paintStruct );

    m_pMatrix->DrawCell (
        pdc,
        rect,
        m_nPercentage,
        FALSE,
        m_pMatrix->GetBackColor (0,0),
        m_pMatrix->GetForeColor (0,0),
        m_pMatrix->GetBlendColor (0,0)
        );

    EndPaint (&paintStruct);
}

BEGIN_MESSAGE_MAP(CLegendCell, CStatic)
	//{{AFX_MSG_MAP(CLegendCell)
	ON_WM_PAINT ()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScheduleBaseDlg dialog


CScheduleBaseDlg::CScheduleBaseDlg(UINT nIDTemplate, bool bAddDaylightBias, CWnd* pParent /*=NULL*/)
	: CDialog(nIDTemplate, pParent),
	m_bSystemTimeChanged (false),
    m_dwFlags (0),
	m_bAddDaylightBias (bAddDaylightBias)
{
	EnableAutomation();

	//{{AFX_DATA_INIT(CScheduleBaseDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CScheduleBaseDlg::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CDialog::OnFinalRelease();
}

void CScheduleBaseDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CScheduleBaseDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CScheduleBaseDlg, CDialog)
	//{{AFX_MSG_MAP(CScheduleBaseDlg)
	//}}AFX_MSG_MAP
	ON_MN_SELCHANGE (IDC_SCHEDULE_MATRIX, OnSelChange)
	ON_WM_TIMECHANGE()
    ON_MESSAGE (BASEDLGMSG_GETIDD, OnGetIDD)
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CScheduleBaseDlg, CDialog)
	//{{AFX_DISPATCH_MAP(CScheduleBaseDlg)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IScheduleBaseDlg to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {701CFB38-AEF8-11D1-9864-00C04FB94F17}
static const IID IID_IScheduleBaseDlg =
{ 0x701cfb38, 0xaef8, 0x11d1, { 0x98, 0x64, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } };

BEGIN_INTERFACE_MAP(CScheduleBaseDlg, CDialog)
	INTERFACE_PART(CScheduleBaseDlg, IID_IScheduleBaseDlg, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScheduleBaseDlg message handlers

BOOL CScheduleBaseDlg::OnInitDialog() 
{
    _TRACE (1, L"Entering CScheduleBaseDlg::OnInitDialog\n");
	CDialog::OnInitDialog();
	
	CRect rect (0,0,0,0);

	// Set up the weekly matrix and slap it on the dialog.
    BOOL bRet =	m_schedulematrix.Create (L"WeeklyMatrix", rect, this, IDC_SCHEDULE_MATRIX);
    if ( !bRet )
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"CScheduleMatrix::Create () failed: 0x%x\n", dwErr);
    }
	::ReplaceFrameWithControl (this, IDC_STATIC_LOGON_MATRIX, &m_schedulematrix, FALSE);
	// Set the blending color for the whole matrix
	m_schedulematrix.SetBlendColor (c_crBlendColor, 0, 0, 24, 7);
	m_schedulematrix.SetForeColor (c_crBlendColor, 0, 0, 24, 7);
	

	SetWindowText (m_szTitle);

	InitMatrix ();

	UpdateUI ();
	
    if ( m_dwFlags & SCHED_FLAG_READ_ONLY )
    {
        // Change the Cancel button to Close
        CString strClose;
        VERIFY (strClose.LoadString (IDS_CLOSE));
        GetDlgItem (IDCANCEL)->SetWindowText (strClose);

        // Hide the OK button
        GetDlgItem (IDOK)->ShowWindow (SW_HIDE);
    }


    _TRACE (-1, L"Leaving CScheduleBaseDlg::OnInitDialog\n");
    return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CScheduleBaseDlg::SetTitle(LPCTSTR pszTitle)
{
	m_szTitle = pszTitle;
}

void CScheduleBaseDlg::OnSelChange ()
{
	UpdateUI ();
}

void CScheduleBaseDlg::UpdateUI ()
{
	CString strDescr;
	m_schedulematrix.GetSelDescription (OUT strDescr);
	SetDlgItemText (IDC_STATIC_DESCRIPTION, strDescr);
	UpdateButtons ();
}

/////////////////////////////////////////////////////////////////////
//	InitMatrix2 ()
//
//	Initialize the schedule matrix with an array of values
//	representing replication frequencies.
//
//	INTERFACE NOTES
//	Each byte of rgbData represent one hour.  The first day of
//	the week is Sunday and the last day is Saturday.
//
void CScheduleBaseDlg::InitMatrix2 (const BYTE rgbData[])
{
	ASSERT (rgbData);

	bool bMatrixAllSelected = true;
    bool bMatrixAllClear = true;
	const BYTE * pbData = rgbData;
	for (int iDayOfWeek = 0; iDayOfWeek < 7; iDayOfWeek++)
	{
		for (int iHour = 0; iHour < 24; iHour++)
		{
			if (!*pbData)
				bMatrixAllSelected = false;
            else
                bMatrixAllClear = false;
			m_schedulematrix.SetPercentage (GetPercentageToSet (*pbData) , iHour, iDayOfWeek);
			pbData++;
		} // for
	} // for
	// If the whole matrix is selected, then set the selection to the whole matrix
	if ( bMatrixAllSelected || bMatrixAllClear )
		m_schedulematrix.SetSel (0, 0, 24, 7);
	else
		m_schedulematrix.SetSel (0, 0, 1, 1);
} // InitMatrix2 ()


/////////////////////////////////////////////////////////////////////
//	GetByteArray ()
//
//	Get an array of bytes from the schedule matrix.  Each byte
//	is a boolean value representing one hour of logon access to a user.
//
//	INTERFACE NOTES
//	Same as SetLogonByteArray ().
//
void CScheduleBaseDlg::GetByteArray (OUT BYTE rgbData[])
{
	ASSERT (rgbData);

	BYTE * pbData = rgbData;
	for (int iDayOfWeek = 0; iDayOfWeek < 7; iDayOfWeek++)
	{
		for (int iHour = 0; iHour < 24; iHour++)
		{
			*pbData = GetMatrixPercentage (iHour, iDayOfWeek);
			pbData++;
		} // for
	} // for
} // GetByteArray ()

// If the system time or time zone has changed prompt the user to close and reopen
// the dialog. Otherwise, if the dialog data was saved, data could be corrupted.
// Disable all controls.
void CScheduleBaseDlg::OnTimeChange()
{
	if ( !m_bSystemTimeChanged )
	{
		m_bSystemTimeChanged = true;

		CString	caption;
		CString	text;

		VERIFY (caption.LoadString (IDS_ACTIVE_DIRECTORY_MANAGER));
		VERIFY (text.LoadString (IDS_TIMECHANGE));
		MessageBox (text, caption, MB_ICONINFORMATION | MB_OK);
        GetDlgItem (IDCANCEL)->SetFocus ();
		GetDlgItem (IDOK)->EnableWindow (FALSE);
		m_schedulematrix.EnableWindow (FALSE);
		TimeChange ();
	}
}

void CScheduleBaseDlg::SetFlags(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
}

DWORD CScheduleBaseDlg::GetFlags() const
{
    return m_dwFlags;
}

LRESULT CScheduleBaseDlg::OnGetIDD (WPARAM /*wParam*/, LPARAM /*lParam*/)
{
    return GetIDD ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\scheddlg.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2001
//
//  File:       SchedDlg.cpp
//
//  Contents:   Implementation of CConnectionScheduleDlg
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "SchedDlg.h"
#include "log_gmt.h"
#include "loghrapi.h"

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// The schedule block has been redefined to have 1 byte for every hour.
// CODEWORK These should be defined in SCHEDULE.H.  JonN 2/9/98
//
#define INTERVAL_MASK       0x0F
#define RESERVED            0xF0
#define FIRST_15_MINUTES    0x01
#define SECOND_15_MINUTES   0x02
#define THIRD_15_MINUTES    0x04
#define FOURTH_15_MINUTES   0x08

const int NONE_PER_HOUR = 0;
const int ONE_PER_HOUR	= 33;
const int TWO_PER_HOUR	= 67;
const int FOUR_PER_HOUR	= 100;
/////////////////////////////////////////////////////////////////////
//	ConnectionScheduleDialog ()
//
//	Invoke a dialog to set/modify a schedule, for example
//      -- the logon hours for a particular user
//      -- the schedule for a connection
//
//	RETURNS
//	Return S_OK if the user clicked on the OK button.
//	Return S_FALSE if the user clicked on the Cancel button.
//	Return E_OUTOFMEMORY if there is not enough memory.
///	Return E_UNEXPECTED if an expected error occured (eg: bad parameter)
//
//	INTERFACE NOTES
//	Each bit in the array represents one hour.  As a result, the
//	expected length of the array should be (24 / 8) * 7 = 21 bytes.
//	For convenience, the first day of the week is Sunday and
//	the last day is Saturday.
//	Consequently, the first bit of the array represents the schedule
//	for Sunday during period 12 AM to 1 AM.
//	- If *pprgbData is NULL, then the routine will allocate
//	  an array of 21 bytes using LocalAlloc ().  The caller
//	  is responsible of releasing the memory using LocalFree ().
//  - If *pprgbData is not NULL, the routine re-use the array as its
//	  output parameter.
//
//	HISTORY
//	17-Jul-97	t-danm		Creation.
//	16-Sep-97	jonn		Changed to UiScheduleDialog
//

HRESULT
ConnectionScheduleDialog (
	HWND hwndParent,		// IN: Parent's window handle
	BYTE ** pprgbData,	    // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
	LPCTSTR pszTitle)		// IN: Dialog title
{
    return ConnectionScheduleDialogEx (hwndParent, pprgbData, pszTitle, 0);
}

HRESULT
ConnectionScheduleDialogEx (
	HWND hwndParent,		// IN: Parent's window handle
	BYTE ** pprgbData,	    // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
	LPCTSTR pszTitle,		// IN: Dialog title
    DWORD   dwFlags)
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (::IsWindow (hwndParent));
	ASSERT (pprgbData);
	ASSERT (pszTitle);
	ENDORSE (NULL == *pprgbData);	// TRUE => Use default logon hours (7x24)

	if (*pprgbData == NULL)
	{
		BYTE * pargbData;	// Pointer to allocated array of bytes
		pargbData = (BYTE *)LocalAlloc (0, 7*24);	// Allocate 168 bytes
		if ( !pargbData )
			return E_OUTOFMEMORY;
		// Set the logon hours to be valid 24 hours a day and 7 days a week.
		memset (OUT pargbData, -1, 7*24);
		*pprgbData = pargbData;
	}

    // If hwndParent passed in, create a CWnd to pass as the parent window
    CWnd* pWnd = 0;
    if ( ::IsWindow (hwndParent) )
    {
        pWnd = new CWnd;
        if ( pWnd )
        {
            pWnd->Attach (hwndParent);
        }
        else
            return E_OUTOFMEMORY;
    }

    HRESULT             hr = S_OK;
	CConnectionScheduleDlg	dlg (pWnd);
    dlg.SetTitle (pszTitle);
	dlg.SetConnectionByteArray (INOUT *pprgbData);
    dlg.SetFlags (dwFlags);

	if (IDOK != dlg.DoModal ())
		hr = S_FALSE;

    // Delete CWnd
    if ( pWnd )
    {
        pWnd->Detach ();
        delete pWnd;
    }

    return hr;
} // ConnectionScheduleDialog ()



HRESULT
ReplicationScheduleDialog (
	HWND hwndParent,		// IN: Parent's window handle
	BYTE ** pprgbData,	    // INOUT: Pointer to pointer to array of 21 bytes (one bit per hour)
	LPCTSTR pszTitle)		// IN: Dialog title
{
    return ReplicationScheduleDialogEx (hwndParent, pprgbData, pszTitle, 0);
} // ReplicationScheduleDialog ()


HRESULT ReplicationScheduleDialogEx (
    HWND hwndParent,       // parent window
    BYTE ** pprgbData,     // pointer to pointer to array of 84 bytes
    LPCTSTR pszTitle,     // dialog title
    DWORD   dwFlags)      // option flags
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	ASSERT (::IsWindow (hwndParent));
	ASSERT (pprgbData);
	ASSERT (pszTitle);
	ENDORSE (NULL == *pprgbData);	// TRUE => Use default logon hours (7x24)

	if (*pprgbData == NULL)
	{
		BYTE * pargbData;	// Pointer to allocated array of bytes
		pargbData = (BYTE *)LocalAlloc (0, 7*24);	// Allocate 168 bytes
		if ( !pargbData )
			return E_OUTOFMEMORY;
		// Set the logon hours to be valid 24 hours a day and 7 days a week.
		memset (OUT pargbData, -1, 7*24);
		*pprgbData = pargbData;
	}

    // If hwndParent passed in, create a CWnd to pass as the parent window
    CWnd* pWnd = 0;
    if ( ::IsWindow (hwndParent) )
    {
        pWnd = new CWnd;
        if ( pWnd )
        {
            pWnd->Attach (hwndParent);
        }
        else
            return E_OUTOFMEMORY;
    }

    HRESULT             hr = S_OK;
	CReplicationScheduleDlg	dlg (pWnd);
    dlg.SetTitle (pszTitle);
	dlg.SetConnectionByteArray (INOUT *pprgbData);
    dlg.SetFlags (dwFlags);
	if (IDOK != dlg.DoModal ())
		hr = S_FALSE;

    // Delete CWnd
    if ( pWnd )
    {
        pWnd->Detach ();
        delete pWnd;
    }

    return hr;
}   // ReplicationScheduleDialogEx

/////////////////////////////////////////////////////////////////////////////
// CConnectionScheduleDlg dialog


CConnectionScheduleDlg::CConnectionScheduleDlg(CWnd* pParent)
	: CScheduleBaseDlg(CConnectionScheduleDlg::IDD, true, pParent),
	m_prgbData168 (0)
{
	EnableAutomation();

	//{{AFX_DATA_INIT(CConnectionScheduleDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CConnectionScheduleDlg::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CScheduleBaseDlg::OnFinalRelease();
}

void CConnectionScheduleDlg::DoDataExchange(CDataExchange* pDX)
{
	CScheduleBaseDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConnectionScheduleDlg)
	DDX_Control(pDX, IDC_RADIO_NONE, m_buttonNone);
	DDX_Control(pDX, IDC_RADIO_ONE, m_buttonOne);
	DDX_Control(pDX, IDC_RADIO_TWO, m_buttonTwo);
	DDX_Control(pDX, IDC_RADIO_FOUR, m_buttonFour);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConnectionScheduleDlg, CScheduleBaseDlg)
	//{{AFX_MSG_MAP(CConnectionScheduleDlg)
	ON_BN_CLICKED(IDC_RADIO_FOUR, OnRadioFour)
	ON_BN_CLICKED(IDC_RADIO_NONE, OnRadioNone)
	ON_BN_CLICKED(IDC_RADIO_ONE, OnRadioOne)
	ON_BN_CLICKED(IDC_RADIO_TWO, OnRadioTwo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CConnectionScheduleDlg, CScheduleBaseDlg)
	//{{AFX_DISPATCH_MAP(CConnectionScheduleDlg)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IDSScheduleDlg to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {701CFB36-AEF8-11D1-9864-00C04FB94F17}
static const IID IID_IDSScheduleDlg =
{ 0x701cfb36, 0xaef8, 0x11d1, { 0x98, 0x64, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } };

BEGIN_INTERFACE_MAP(CConnectionScheduleDlg, CScheduleBaseDlg)
	INTERFACE_PART(CConnectionScheduleDlg, IID_IDSScheduleDlg, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConnectionScheduleDlg message handlers

BOOL CConnectionScheduleDlg::OnInitDialog() 
{
	CScheduleBaseDlg::OnInitDialog();
	
	// Set up the "none" legend
	m_legendNone.Init (this, IDC_STATIC_LEGEND_NONE, &m_schedulematrix, NONE_PER_HOUR);

	// Set up the "one" legend
	m_legendOne.Init (this, IDC_STATIC_LEGEND_ONE, &m_schedulematrix, ONE_PER_HOUR);

	// Set up the "two" legend
	m_legendTwo.Init (this, IDC_STATIC_LEGEND_TWO, &m_schedulematrix, TWO_PER_HOUR);
	
	// Set up the "four" legend
	m_legendFour.Init (this, IDC_STATIC_LEGEND_FOUR, &m_schedulematrix, FOUR_PER_HOUR);
	
    if ( GetFlags () & SCHED_FLAG_READ_ONLY )
    {
        // Disable the grid settings buttons
        m_buttonNone.EnableWindow (FALSE);
        m_buttonOne.EnableWindow (FALSE);
        m_buttonTwo.EnableWindow (FALSE);
        m_buttonFour.EnableWindow (FALSE);
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CConnectionScheduleDlg::OnOK() 
{
	if ( m_prgbData168 )
	{
		GetByteArray (OUT m_prgbData168);

		// Convert back the hours to GMT time.
		ConvertConnectionHoursToGMT (INOUT m_prgbData168, m_bAddDaylightBias);
	}
	
	CScheduleBaseDlg::OnOK();
}


void CConnectionScheduleDlg::UpdateButtons ()
{
	UINT nHour = 0;
	UINT nDay = 0;
	UINT nNumHours = 0;
	UINT nNumDays = 0;

	m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);

	// Assume in each case that all selected squares are all set one way until 
	// proven otherwise.  These are 'int' so that I can add them up afterwards
	// to assure that only one of the buttons will be checked.
	int fNoneAllSet = 1;
	int fOneAllSet = 1;
	int fTwoAllSet = 1;
	int fFourAllSet = 1;

	if (nNumHours > 0)
	{
		for (UINT iDayOfWeek = nDay; iDayOfWeek < nDay+nNumDays; iDayOfWeek++)
		{
			for (UINT iHour = nHour; iHour < nHour+nNumHours; iHour++)
			{
				switch (m_schedulematrix.GetPercentage (iHour, iDayOfWeek))
				{
				case NONE_PER_HOUR:
					fOneAllSet = 0;
					fTwoAllSet = 0;
					fFourAllSet = 0;
					break;

				case ONE_PER_HOUR:
					fNoneAllSet = 0;
					fTwoAllSet = 0;
					fFourAllSet = 0;
					break;

				case TWO_PER_HOUR:
					fNoneAllSet = 0;
					fOneAllSet = 0;
					fFourAllSet = 0;
					break;

				case FOUR_PER_HOUR:
					fNoneAllSet = 0;
					fOneAllSet = 0;
					fTwoAllSet = 0;
					break;

				default:
					ASSERT (0);
					break;
				}
			} // for
		} // for
	}
	else
	{
		fNoneAllSet = 0;
		fOneAllSet = 0;
		fTwoAllSet = 0;
		fFourAllSet = 0;
	}

	// Ensure that at most, only one of these is 'true'
	ASSERT ((fNoneAllSet + fOneAllSet + fTwoAllSet + fFourAllSet <= 1));
	m_buttonNone.SetCheck (fNoneAllSet);
	m_buttonOne.SetCheck (fOneAllSet);
	m_buttonTwo.SetCheck (fTwoAllSet);
	m_buttonFour.SetCheck (fFourAllSet);
}

void CConnectionScheduleDlg::OnRadioFour() 
{
	UINT nHour = 0;
	UINT nDay = 0;
	UINT nNumHours = 0;
	UINT nNumDays = 0;

	m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
	if (nNumHours <= 0)
		return;	// Nothing selected
	m_schedulematrix.SetPercentage (FOUR_PER_HOUR, nHour, nDay, nNumHours, nNumDays);
	UpdateButtons ();
}

void CConnectionScheduleDlg::OnRadioNone() 
{
	UINT nHour = 0;
	UINT nDay = 0;
	UINT nNumHours = 0;
	UINT nNumDays = 0;

	m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
	if (nNumHours <= 0)
		return;	// Nothing selected
	m_schedulematrix.SetPercentage (NONE_PER_HOUR, nHour, nDay, nNumHours, nNumDays);
	UpdateButtons ();
}

void CConnectionScheduleDlg::OnRadioOne() 
{
	UINT nHour = 0;
	UINT nDay = 0;
	UINT nNumHours = 0;
	UINT nNumDays = 0;

	m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
	if (nNumHours <= 0)
		return;	// Nothing selected
	m_schedulematrix.SetPercentage (ONE_PER_HOUR, nHour, nDay, nNumHours, nNumDays);
	UpdateButtons ();
}

void CConnectionScheduleDlg::OnRadioTwo() 
{
	UINT nHour = 0;
	UINT nDay = 0;
	UINT nNumHours = 0;
	UINT nNumDays = 0;

	m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
	if (nNumHours <= 0)
		return;	// Nothing selected
	m_schedulematrix.SetPercentage (TWO_PER_HOUR, nHour, nDay, nNumHours, nNumDays);
	UpdateButtons ();
}

void CConnectionScheduleDlg::InitMatrix()
{
	if ( m_prgbData168 )
	{
		BYTE rgData[SCHEDULE_DATA_ENTRIES];		// Array of logonhours bits
		// Make a copy of the connection hours (in case the user click on cancel button)
		memcpy (OUT rgData, IN m_prgbData168, sizeof (rgData));
		// Convert the hours from GMT to local hours.
		ConvertConnectionHoursFromGMT (INOUT rgData, m_bAddDaylightBias);
		// Initialize the matrix
		InitMatrix2 (IN rgData);
	}
}

void CConnectionScheduleDlg::SetConnectionByteArray(INOUT BYTE rgbData [SCHEDULE_DATA_ENTRIES])
{
	ASSERT (rgbData);
	m_prgbData168 = rgbData;
}

// This table represent the numbers of bits set in the lower nibble of the BYTE.
// 0 bits -> 0
// 1 bit -> 25
// 2 or 3 bits -> 50
// 4 bits -> 100
static BYTE setConversionTable[16] = 
	{NONE_PER_HOUR,	// 0000
	ONE_PER_HOUR,	// 0001
	ONE_PER_HOUR,	// 0010
	TWO_PER_HOUR,	// 0011
	ONE_PER_HOUR,	// 0100
	TWO_PER_HOUR,	// 0101
	TWO_PER_HOUR,   // 0110
	TWO_PER_HOUR,   // 0111
	ONE_PER_HOUR,   // 1000
	TWO_PER_HOUR,   // 1001
	TWO_PER_HOUR,   // 1010
	TWO_PER_HOUR,   // 1011
	TWO_PER_HOUR,   // 1100
	TWO_PER_HOUR,   // 1101
	TWO_PER_HOUR,   // 1110
	FOUR_PER_HOUR}; // 1111

UINT CConnectionScheduleDlg::GetPercentageToSet(const BYTE bData)
{
	ASSERT ((bData & 0x0F) < 16);
	return setConversionTable[bData & 0x0F];
}


BYTE CConnectionScheduleDlg::GetMatrixPercentage(UINT nHour, UINT nDay)
{
	BYTE	byResult = 0;

	switch (m_schedulematrix.GetPercentage (nHour, nDay))
	{
	case NONE_PER_HOUR:
		// value remains 0n
		break;

	case ONE_PER_HOUR:
		byResult = FIRST_15_MINUTES;
		break;

	case TWO_PER_HOUR:
		byResult = FIRST_15_MINUTES | THIRD_15_MINUTES;
		break;

	case FOUR_PER_HOUR:
		byResult = FIRST_15_MINUTES | SECOND_15_MINUTES | THIRD_15_MINUTES | FOURTH_15_MINUTES;
		break;

	default:
		ASSERT (0);
		break;
	}

	return byResult;
}

UINT CConnectionScheduleDlg::GetExpectedArrayLength()
{
	return SCHEDULE_DATA_ENTRIES;
}

// Called when WM_TIMECHANGE is received
void CConnectionScheduleDlg::TimeChange()
{
	m_buttonNone.EnableWindow (FALSE);
	m_buttonOne.EnableWindow (FALSE);
	m_buttonTwo.EnableWindow (FALSE);
	m_buttonFour.EnableWindow (FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// CReplicationScheduleDlg dialog


CReplicationScheduleDlg::CReplicationScheduleDlg(CWnd* pParent)
	: CScheduleBaseDlg(CReplicationScheduleDlg::IDD, true, pParent),
	m_prgbData168 (0)
{
	EnableAutomation();

	//{{AFX_DATA_INIT(CReplicationScheduleDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CReplicationScheduleDlg::OnFinalRelease()
{
	// When the last reference for an automation object is released
	// OnFinalRelease is called.  The base class will automatically
	// deletes the object.  Add additional cleanup required for your
	// object before calling the base class.

	CScheduleBaseDlg::OnFinalRelease();
}

void CReplicationScheduleDlg::DoDataExchange(CDataExchange* pDX)
{
	CScheduleBaseDlg::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CReplicationScheduleDlg)
	DDX_Control(pDX, IDC_RADIO_NONE, m_buttonNone);
	DDX_Control(pDX, IDC_RADIO_FOUR, m_buttonFour);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CReplicationScheduleDlg, CScheduleBaseDlg)
	//{{AFX_MSG_MAP(CReplicationScheduleDlg)
	ON_BN_CLICKED(IDC_RADIO_FOUR, OnRadioFour)
	ON_BN_CLICKED(IDC_RADIO_NONE, OnRadioNone)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CReplicationScheduleDlg, CScheduleBaseDlg)
	//{{AFX_DISPATCH_MAP(CReplicationScheduleDlg)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IDSScheduleDlg to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {8DE6E2DA-7B4E-11d2-AC13-00C04F79DDCA}
static const IID IID_IReplicationScheduleDlg = 
{ 0x8de6e2da, 0x7b4e, 0x11d2, { 0xac, 0x13, 0x0, 0xc0, 0x4f, 0x79, 0xdd, 0xca } };

BEGIN_INTERFACE_MAP(CReplicationScheduleDlg, CScheduleBaseDlg)
	INTERFACE_PART(CReplicationScheduleDlg, IID_IReplicationScheduleDlg, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CReplicationScheduleDlg message handlers

BOOL CReplicationScheduleDlg::OnInitDialog() 
{
	CScheduleBaseDlg::OnInitDialog();
	

 	// Set up the "none" legend
	m_legendNone.Init (this, IDC_STATIC_LEGEND_NONE, &m_schedulematrix, NONE_PER_HOUR);

	// Set up the "four" legend
	m_legendFour.Init (this, IDC_STATIC_LEGEND_FOUR, &m_schedulematrix, FOUR_PER_HOUR);
	
    if ( GetFlags () & SCHED_FLAG_READ_ONLY )
    {
        // Disable the grid settings buttons
        m_buttonNone.EnableWindow (FALSE);
        m_buttonFour.EnableWindow (FALSE);
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CReplicationScheduleDlg::OnOK() 
{
	if ( m_prgbData168 )
	{
		GetByteArray (OUT m_prgbData168);

		// Convert back the hours to GMT time.
		ConvertConnectionHoursToGMT (INOUT m_prgbData168, m_bAddDaylightBias);
	}
	
	CScheduleBaseDlg::OnOK();
}


void CReplicationScheduleDlg::UpdateButtons ()
{
	UINT nHour = 0;
	UINT nDay = 0;
	UINT nNumHours = 0;
	UINT nNumDays = 0;

	m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);

	// Assume in each case that all selected squares are all set one way until 
	// proven otherwise.  These are 'int' so that I can add them up afterwards
	// to assure that only one of the buttons will be checked.
	int fNoneAllSet = 1;
    int fFourAllSet = 1;

	if (nNumHours > 0)
	{
		for (UINT iDayOfWeek = nDay; iDayOfWeek < nDay+nNumDays; iDayOfWeek++)
		{
			for (UINT iHour = nHour; iHour < nHour+nNumHours; iHour++)
			{
				switch (m_schedulematrix.GetPercentage (iHour, iDayOfWeek))
				{
				case NONE_PER_HOUR:
                    fFourAllSet = 0;
					break;

				case FOUR_PER_HOUR:
					fNoneAllSet = 0;
					break;

				default:
					ASSERT (0);
					break;
				}
			} // for
		} // for
	}
	else
	{
		fNoneAllSet = 0;
	}

    ASSERT (fNoneAllSet + fFourAllSet <= 1);
	m_buttonNone.SetCheck (fNoneAllSet);
	m_buttonFour.SetCheck (fFourAllSet);
}

void CReplicationScheduleDlg::OnRadioFour() 
{
	UINT nHour = 0;
	UINT nDay = 0;
	UINT nNumHours = 0;
	UINT nNumDays = 0;

	m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
	if (nNumHours <= 0)
		return;	// Nothing selected
	m_schedulematrix.SetPercentage (FOUR_PER_HOUR, nHour, nDay, nNumHours, nNumDays);
	UpdateButtons ();
}

void CReplicationScheduleDlg::OnRadioNone() 
{
	UINT nHour = 0;
	UINT nDay = 0;
	UINT nNumHours = 0;
	UINT nNumDays = 0;

	m_schedulematrix.GetSel (OUT nHour, OUT nDay, OUT nNumHours, OUT nNumDays);
	if (nNumHours <= 0)
		return;	// Nothing selected
	m_schedulematrix.SetPercentage (NONE_PER_HOUR, nHour, nDay, nNumHours, nNumDays);
	UpdateButtons ();
}


void CReplicationScheduleDlg::InitMatrix()
{
	if ( m_prgbData168 )
	{
		BYTE rgData[SCHEDULE_DATA_ENTRIES];		// Array of logonhours bits
		// Make a copy of the connection hours (in case the user click on cancel button)
		memcpy (OUT rgData, IN m_prgbData168, sizeof (rgData));
		// Convert the hours from GMT to local hours.
		ConvertConnectionHoursFromGMT (INOUT rgData, m_bAddDaylightBias);
		// Initialize the matrix
		InitMatrix2 (IN rgData);
	}
}

void CReplicationScheduleDlg::SetConnectionByteArray(INOUT BYTE rgbData [SCHEDULE_DATA_ENTRIES])
{
	ASSERT (rgbData);
	m_prgbData168 = rgbData;
}


// This table represent the numbers of bits set in the lower nibble of the BYTE.
// 0 bits -> 0
// 1 bit -> 25
// 2 or 3 bits -> 50
// 4 bits -> 100
static BYTE setConversionTableForReplication[16] = 
	{NONE_PER_HOUR,	// 0000
	FOUR_PER_HOUR,	// 0001
	FOUR_PER_HOUR,	// 0010
	FOUR_PER_HOUR,	// 0011
	FOUR_PER_HOUR,	// 0100
	FOUR_PER_HOUR,	// 0101
	FOUR_PER_HOUR,  // 0110
	FOUR_PER_HOUR,  // 0111
	FOUR_PER_HOUR,  // 1000
	FOUR_PER_HOUR,  // 1001
	FOUR_PER_HOUR,  // 1010
	FOUR_PER_HOUR,  // 1011
	FOUR_PER_HOUR,  // 1100
	FOUR_PER_HOUR,  // 1101
	FOUR_PER_HOUR,  // 1110
	FOUR_PER_HOUR}; // 1111

UINT CReplicationScheduleDlg::GetPercentageToSet(const BYTE bData)
{
	ASSERT ((bData & 0x0F) < 16);
	return setConversionTableForReplication[bData & 0x0F];
}


BYTE CReplicationScheduleDlg::GetMatrixPercentage(UINT nHour, UINT nDay)
{
	BYTE	byResult = 0;

	switch (m_schedulematrix.GetPercentage (nHour, nDay))
	{
	case NONE_PER_HOUR:
		// value remains 0n
		break;

	case ONE_PER_HOUR:
	case TWO_PER_HOUR:
	case FOUR_PER_HOUR:
		byResult = FIRST_15_MINUTES | SECOND_15_MINUTES | THIRD_15_MINUTES | FOURTH_15_MINUTES;
		break;

	default:
		ASSERT (0);
		break;
	}

	return byResult;
}

UINT CReplicationScheduleDlg::GetExpectedArrayLength()
{
	return SCHEDULE_DATA_ENTRIES;
}

// Called when WM_TIMECHANGE is received
void CReplicationScheduleDlg::TimeChange()
{
	m_buttonNone.EnableWindow (FALSE);
	m_buttonFour.EnableWindow (FALSE);
}


/////////////////////////////////////////////////////////////////////
//	Converts the connection hours from local time to GMT.
void 
ConvertConnectionHoursToGMT (INOUT BYTE rgbData[SCHEDULE_DATA_ENTRIES], IN bool bAddDaylightBias)
{
	VERIFY ( ::NetpRotateLogonHoursBYTE (rgbData, SCHEDULE_DATA_ENTRIES, TRUE, bAddDaylightBias) );
}

/////////////////////////////////////////////////////////////////////
//	Converts the connection hours from GMT to local time.
void
ConvertConnectionHoursFromGMT (INOUT BYTE rgbData[SCHEDULE_DATA_ENTRIES], IN bool bAddDaylightBias)
{
	VERIFY ( ::NetpRotateLogonHoursBYTE (rgbData, SCHEDULE_DATA_ENTRIES, FALSE, bAddDaylightBias) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\schedbas.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       SchedBas.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#if !defined(AFX_SCHEDBAS_H__701CFB39_AEF8_11D1_9864_00C04FB94F17__INCLUDED_)
#define AFX_SCHEDBAS_H__701CFB39_AEF8_11D1_9864_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SchedBas.h : header file
//
#include "stdafx.h"
#include "resource.h"
#include "schedmat.h"

///////////////////////////////////////////////////////////////////////////////
// Private functions
void ReplaceFrameWithControl (CWnd *pWnd, UINT nFrameID, CWnd *pControl, BOOL bAssignFrameIDToControl); 

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CLegendCell control
class CLegendCell : public CStatic
{
public:
    CLegendCell()
        : m_pMatrix( NULL ),
          m_nPercentage (0)
        {}

    void Init(CWnd* pParent, UINT nCtrlID, CScheduleMatrix* pMatrix, UINT nPercentage);

protected:
    CScheduleMatrix*	m_pMatrix;
    UINT				m_nPercentage;
    CSize				m_rectSize;

	// Generated message map functions
	//{{AFX_MSG(CLegendCell)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
#define IDC_SCHEDULE_MATRIX		20		// Id of the schedule matrix (arbitrary chosen)


/////////////////////////////////////////////////////////////////////////////
// CScheduleBaseDlg dialog
#define BASEDLGMSG_GETIDD   WM_APP+3

class CScheduleBaseDlg : public CDialog
{
// Construction
public:
	virtual int GetIDD () = 0;
	void SetFlags (DWORD dwFlags);
	void SetTitle (LPCTSTR pszTitle);
	CScheduleBaseDlg(UINT nIDTemplate, bool bAddDaylightBias, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CScheduleBaseDlg)
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CScheduleBaseDlg)
	public:
	virtual void OnFinalRelease();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    afx_msg LRESULT OnGetIDD (WPARAM wParam, LPARAM lParam);
	DWORD GetFlags () const;
	virtual void TimeChange () = 0;
	bool m_bSystemTimeChanged;
	virtual UINT GetExpectedArrayLength ()=0;
	virtual BYTE GetMatrixPercentage (UINT nHour, UINT nDay) = 0;
	void GetByteArray(OUT BYTE rgbData[]);
	void InitMatrix2 (const BYTE rgbData[]);
	virtual UINT GetPercentageToSet (const BYTE bData) = 0;
	virtual void UpdateButtons () = 0;
	virtual void InitMatrix () = 0;
	virtual void UpdateUI ();
	enum { c_crBlendColor = RGB(0, 0, 255) };	// Blending color of the schedule matrix
	CScheduleMatrix m_schedulematrix;
	const bool m_bAddDaylightBias;

	// Generated message map functions
	//{{AFX_MSG(CScheduleBaseDlg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	afx_msg void OnSelChange();
	afx_msg void OnTimeChange();
	DECLARE_MESSAGE_MAP()
	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CScheduleBaseDlg)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

private:
	DWORD m_dwFlags;
	CString m_szTitle;	// dialog title
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCHEDBAS_H__701CFB39_AEF8_11D1_9864_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\scheddlg.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2001.
//
//  File:       SchedDlg.h
//
//  Contents:   Definition of CConnectionScheduleDlg
//
//----------------------------------------------------------------------------
#if !defined(AFX_SCHEDDLG_H__701CFB37_AEF8_11D1_9864_00C04FB94F17__INCLUDED_)
#define AFX_SCHEDDLG_H__701CFB37_AEF8_11D1_9864_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SchedDlg.h : header file
//
#include <schedule.h>
#include "SchedBas.h"

#ifndef INOUT
	#define INOUT
	#define ENDORSE(f)	// Macro which is the opposite of ASSERT()
#endif

void ConvertConnectionHoursToGMT(INOUT BYTE rgbData[SCHEDULE_DATA_ENTRIES], IN bool bAddDaylightBias);
void ConvertConnectionHoursFromGMT(INOUT BYTE rgbData[SCHEDULE_DATA_ENTRIES], IN bool bAddDaylightBias);

/////////////////////////////////////////////////////////////////////////////
// CConnectionScheduleDlg dialog

class CConnectionScheduleDlg : public CScheduleBaseDlg
{
// Construction
public:
	void SetConnectionByteArray (INOUT BYTE rgbData[SCHEDULE_DATA_ENTRIES]);
	CConnectionScheduleDlg(CWnd* pParent);   // standard constructor

    virtual int GetIDD ()
    {
        return IDD;
    }

// Dialog Data
	//{{AFX_DATA(CConnectionScheduleDlg)
	enum { IDD = IDD_DS_SCHEDULE };
	CButton	m_buttonNone;
	CButton	m_buttonOne;
	CButton m_buttonTwo;
	CButton m_buttonFour;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConnectionScheduleDlg)
	public:
	virtual void OnFinalRelease();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void TimeChange();
	virtual UINT GetExpectedArrayLength();
	virtual BYTE GetMatrixPercentage(UINT nHour, UINT nDay);
	virtual UINT GetPercentageToSet (const BYTE bData);
	virtual void InitMatrix ();

	// Generated message map functions
	//{{AFX_MSG(CConnectionScheduleDlg)
	afx_msg void OnRadioFour();
	afx_msg void OnRadioNone();
	afx_msg void OnRadioOne();
	afx_msg void OnRadioTwo();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CConnectionScheduleDlg)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

	CLegendCell m_legendNone;
	CLegendCell m_legendOne;
	CLegendCell m_legendTwo;
	CLegendCell m_legendFour;

	virtual void UpdateButtons ();
private:
	BYTE* m_prgbData168;
};


/////////////////////////////////////////////////////////////////////////////
// CReplicationScheduleDlg dialog

class CReplicationScheduleDlg : public CScheduleBaseDlg
{
// Construction
public:
	CReplicationScheduleDlg(CWnd* pParent);   // standard constructor

	void SetConnectionByteArray (INOUT BYTE rgbData[SCHEDULE_DATA_ENTRIES]);

    virtual int GetIDD ()
    {
        return IDD;
    }

// Dialog Data
	//{{AFX_DATA(CReplicationScheduleDlg)
	enum { IDD = IDD_REPLICATION_SCHEDULE };
	CButton	m_buttonNone;
	CButton m_buttonFour;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CReplicationScheduleDlg)
	public:
	virtual void OnFinalRelease();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual void TimeChange();
	virtual UINT GetExpectedArrayLength();
	virtual BYTE GetMatrixPercentage(UINT nHour, UINT nDay);
	virtual UINT GetPercentageToSet (const BYTE bData);
	virtual void InitMatrix ();

	// Generated message map functions
	//{{AFX_MSG(CReplicationScheduleDlg)
	afx_msg void OnRadioFour();
	afx_msg void OnRadioNone();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CReplicationScheduleDlg)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

	CLegendCell m_legendNone;
	CLegendCell m_legendFour;

	virtual void UpdateButtons ();
private:
	BYTE* m_prgbData168;
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SCHEDDLG_H__701CFB37_AEF8_11D1_9864_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\stdafx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       stdafx.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// stdafx.cpp : source file that includes just the standard includes
//	LogHours.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\schedmat.h ===
//****************************************************************************
//
//  Copyright (c) 1997-2001, Microsoft Corporation
//
//  File:  SCHEDMAT.H
//
//  Definitions for the schedule matrix classes.  These classes provide a basic
//  schedule matrix control.  The classes defined here are:
//
//      CMatrixCell         A data structure class for the CScheduleMatrix.
//      CHourLegend         Support window class that draws the matrix legend.
//      CPercentLabel       Support window class that draws percentage labels.
//      CScheduleMatrix     A class that displays daily or weekly schedule data.
//
//  History:
//
//      Scott Walker, SEA   3/10     Created.
//
//****************************************************************************
#ifndef _SCHEDMAT_H_
#define _SCHEDMAT_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// schedmat.h : header file
//

#define SCHEDMSG_GETSELDESCRIPTION  WM_APP+1
#define SCHEDMSG_GETPERCENTAGE      WM_APP+2


#ifndef UITOOLS_CLASS
#define UITOOLS_CLASS
#endif

// Classes defined in this file
class CMatrixCell;
class CScheduleMatrix;

// Schedule matrix types
#define MT_DAILY  1        // 1x24 matrix
#define MT_WEEKLY 2        // 7x24 matrix

// GetMergeState return codes
#define MS_UNMERGED    0
#define MS_MERGED      1
#define MS_MIXEDMERGE  2

// Matrix notification codes
#define MN_SELCHANGE    (WM_USER + 175)
#define ON_MN_SELCHANGE(id, memberFxn) ON_CONTROL(MN_SELCHANGE, id, memberFxn)

/////////////////////////////////////////////////////////////////////////////
// CMatrixCell

#define DEFBACKCOLOR RGB(255,255,255)   // White
#define DEFFORECOLOR RGB(0,0,128)       // Dark blue
#define DEFBLENDCOLOR RGB(255,255,0)    // Yellow

// Cell flags
#define MC_MERGELEFT    0x00000001
#define MC_MERGETOP     0x00000002
#define MC_MERGE        0x00000004
#define MC_LEFTEDGE     0x00000010
#define MC_RIGHTEDGE    0x00000020
#define MC_TOPEDGE      0x00000040
#define MC_BOTTOMEDGE   0x00000080
#define MC_BLEND        0x00000100

#define MC_ALLEDGES (MC_LEFTEDGE | MC_RIGHTEDGE | MC_TOPEDGE | MC_BOTTOMEDGE)

class UITOOLS_CLASS CMatrixCell : public CObject
{
    DECLARE_DYNAMIC(CMatrixCell)
    friend CScheduleMatrix;

// Construction
public:
	CMatrixCell();
	virtual ~CMatrixCell();

protected:
    COLORREF m_crBackColor;
    COLORREF m_crForeColor;
    UINT m_nPercentage;

    COLORREF m_crBlendColor;

    DWORD m_dwUserValue;
    LPVOID m_pUserDataPtr;

    DWORD m_dwFlags;
};

/////////////////////////////////////////////////////////////////////////////
// CHourLegend window

class UITOOLS_CLASS CHourLegend : public CWnd
{
    DECLARE_DYNAMIC(CHourLegend)
    friend CScheduleMatrix;

// Construction
public:
	CHourLegend();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHourLegend)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHourLegend();

protected:
    HICON m_hiconSun, m_hiconMoon;
    HFONT m_hFont;
    int m_nCharHeight, m_nCharWidth;
    int m_nCellWidth;
    CRect m_rLegend;

    // Generated message map functions
protected:
	//{{AFX_MSG(CHourLegend)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CPercentLabel window

class UITOOLS_CLASS CPercentLabel : public CWnd
{
    DECLARE_DYNAMIC(CPercentLabel)
    friend CScheduleMatrix;

// Construction
public:
	CPercentLabel();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHourLegend)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CPercentLabel();

protected:
    CScheduleMatrix *m_pMatrix;
    HFONT m_hFont;
    int m_nCellWidth;
    CRect m_rHeader;
    CRect m_rLabels;

    // Generated message map functions
protected:
	//{{AFX_MSG(CPercentLabel)
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CScheduleMatrix window

// Schedule matrix command IDs
#define SM_ID_DAYBASE 100

#define SM_ID_ALL (SM_ID_DAYBASE + 0)

#define SM_ID_MONDAY (SM_ID_DAYBASE + 1)
#define SM_ID_TUESDAY (SM_ID_DAYBASE + 2)
#define SM_ID_WEDNESDAY (SM_ID_DAYBASE + 3)
#define SM_ID_THURSDAY (SM_ID_DAYBASE + 4)
#define SM_ID_FRIDAY (SM_ID_DAYBASE + 5)
#define SM_ID_SATURDAY (SM_ID_DAYBASE + 6)
#define SM_ID_SUNDAY (SM_ID_DAYBASE + 7)

#define SM_ID_HOURBASE 110

//****************************************************************************
//
//  CLASS:  CScheduleMatrix
//
//  CScheduleMatrix inplements a basic schedule matrix control.  This control
//  provides the mechanics of a daily or weekly schedule UI but has no knowledge
//  about the data it maintains.  The matrix is an array of cells representing
//  the hours in a day and optionally the days in a week.  The cells can be
//  rendered in a variety of ways to represent programmer-defined meaning in
//  each cell.  The following display properties can be set for individual cells
//  or for a block of cells at once:
//
//  BackColor       Background color of the cell (defaults white).
//  ForeColor       ForeGround color of the cell (defaults dark blue).
//  Percentage      Percentage of foreground to background color.  This is
//                  rendered as a histogram in the cell.
//  BlendColor      50% dither color on a cell to represent some binary state
//                  of the cell as compared to another cell (defaults yellow).
//  BlendState      Specifies whether blend color is showing or not.
//
//  A block of cells can be "merged" together to form a discreet block of color
//  within the matrix grid.  This is useful for schedule applications that want
//  to assign a schedule function to a time range.  It is the responsibility
//  of the program to track these blocks and prevent or resolve any confusion
//  from overlapping "merged" blocks.
//
//  Each cell can contain two kinds of programmer-defined data that are
//  maintained with the cell but not touched by the matrix control:  a DWORD
//  value and a pointer value.  These values can be used to hold data representing
//  schedule information for each hour in the matrix.
//
//  The parent window receives a notification message (MN_SELCHANGE) whenever the
//  user modifies the current selection in the matrix.
//
//?? Later:  May add Icon and Text properties per cell.
//
//  PUBLIC MEMBERS:
//
//      CScheduleMatrix             Constructor.
//      ~CScheduleMatrix            Destructor.
//      SetType                     Sets the matrix type to MT_DAILY or MT_WEEKLY.
//      Create                      Creates the control window.
//
//      Selection:
//
//      DeselectAll                 Deselects all cells.
//      SelectAll                   Selects all cells.
//      SetSel                      Selects a block of cells.
//      GetSel                      Gets the current selection.
//      GetSelDescription           Gets text description of selection range
//      CellInSel                   Tests if a cell is in the current selection
//
//      GetCellSize                 Gets the size of a cell in the current matrix
//      DrawCell                    Draws a sample cell in specified DC
//
//      Block Data Functions:
//
//      SetBackColor                Sets color used to paint cell background.
//      SetForeColor                Sets color used to paint cell percentage.
//      SetPercentage               Sets percentage of foreground to background.
//      SetBlendColor               Sets color blended onto cells.
//      SetBlendState               Turns blend on or off.
//      SetUserValue                Sets user defined DWORD value.
//      SetUserDataPtr              Sets user defined data pointer.
//      MergeCells                  Graphically merges cells so they render as a block.
//      UnMergeCells                Cancels merging for a block of cells.
//      GetMergeState               Returns merge state for a block of cells
//
//      Cell Data Functions:
//
//      GetBackColor                Gets the back color of a cell.
//      GetForeColor                Gets the forecolor of a cell.
//      GetPercentage               Gets the percentage of foreground to background.
//      GetBlendColor               Gets the blend color of cell.
//      GetBlendState               Gets the blend state of a cell.
//      GetUserValue                Gets the user defined DWORD value of the cell.
//      GetUserDataPtr              Gets the user defined data pointer of the cell.
//
//============================================================================
//
//  CScheduleMatrix::CScheduleMatrix
//
//  Constructor.  The constructor creates the data structure associated with
//  the schedule matrix.  As with other CWnd objects, the control itself must
//  be instantiated with a call to Create.
//
//  Parameters I:
//
//      void                    Default constructor.  Constructs a MT_WEEKLY
//                              schedule matrix.
//
//  Parameters II:
//
//      DWORD dwType            Type constructor.  CScheduleMatrix with initial
//                              type:  MT_DAILY or MT_WEEKLY
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetType
//
//  Sets the type of the matrix to MT_WEEKLY or MT_DAILY.  Call this function
//  after construction but before Create.
//
//  Parameters:
//
//      DWORD dwType            Matrix Type:  MT_DAILY or MT_WEEKLY
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::Create
//
//  Create initializes the control's window and attaches it to the CScheduleMatrix.
//
//  Parameters:
//
//      DWORD dwStyle       Specifies the window style of the control.
//      const RECT& rect    Specifies the position and size of the control.
//      CWnd* pParentWnd    Specifies the parent window of the control.
//      UINT nID            Specifies the control ID.
//
//  Returns:
//
//      BOOL bResult        TRUE if successful.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::DeselectAll
//
//  Deselects all cells in the matrix.
//
//  Returns:
//
//      BOOL bChanged       TRUE if selection changes.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SelectAll
//
//  Selects all cells in the matrix.
//
//  Returns:
//
//      BOOL bChanged       TRUE if selection changes.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetSel
//
//  Sets the selection to the specified block.  The selection is a continuous
//  block of cells defined by a starting hour/day pair and extending over a
//  range of hours and days.
//
//  Parameters:
//
//      UINT nHour          Starting hour for the selection.
//      UINT nDay           Starting day for the selection.
//      UINT nNumHours      Range of selection along the hour axis. (Default=1).
//      UINT nNumDays       Range of selection along the day axis. (Default=1).
//
//  Returns:
//
//      BOOL bChanged       TRUE if selection changes.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetSel
//
//  Retrieves the current selection.
//
//  Parameters:
//
//      UINT &nHour         Receiver for starting hour for the selection.
//      UINT &nDay          Receiver for starting day for the selection.
//      UINT &nNumHours     Receiver for range of selection along the hour axis.
//      UINT &nNumDays      Receiver for range of selection along the day axis.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetDescription
//
//  Returns a textual description of the specified block of cells.  This is useful
//  for applications that wish to provide feedback about merged or grouped blocks
//  in the matrix.
//
//  Parameters:
//
//      CString &sText      Receiver for description text.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetSelDescription
//
//  Returns a textual description of the current selection.  This is useful for
//  applications that wish to provide feedback about the selection.
//
//  Parameters:
//
//      CString &sText      Receiver for description text.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::CellInSel
//
//  Returns TRUE if the specified cell is selected (i.e. is in the block of
//  selected cells).
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      BOOL bSelected      TRUE if cell is selected.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetCellSize
//
//  Returns the size of a cell in the current matrix.  This function may be used
//  in conjunction with DrawCell (below) to render a sample cell for a legend.
//
//  Returns:
//
//      CSize size          Size of the cell.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::DrawCell
//
//  Renders a cell with the specified properties.  Use this function to create
//  a legend defining the cell states in the matrix.  The cell is drawn as a
//  histogram with the specified background and foreground colors in a proportion
//  specified by the percentage.  If blend state is TRUE, the blend color is
//  blended in with a 50% dither on top of the foreground and background.
//
//  Parameters:
//
//      CDC *pdc                Display context to draw into.
//      LPCRECT pRect           Cell boundaries in the specified DC.
//      UINT nPercent           Percentage if foreground to background color.
//      BOOL bBlendState        Draw blend dither if TRUE (Default = FALSE).
//      COLORREF crBackColor    Background color (Default = DEFBACKCOLOR).
//      COLORREF crForeColor    Foreground color (Default = DEFFORECOLOR).
//      COLORREF crBlendColor   Blend color (Default = DEFBLENDCOLOR).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetBackColor
//
//  Sets the background color for the specified block of cells.
//
//  Parameters:
//
//      COLORREF crColor    New color property for the block of cells.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetForeColor
//
//  Sets the foreground color for the specified block of cells.
//
//  Parameters:
//
//      COLORREF crColor    New color property for the block of cells.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetPercentage
//
//  Sets the percentage of foreground to background color for the specified block
//  of cells.  This percentage is rendered as a histogram of one color to the
//  other with foreground color on the bottom.
//
//  Parameters:
//
//      UINT nPercent       Percentage of foreground to background color.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetBlendColor
//
//  Sets the blend color for the specified block of cells.  Blend color is
//  overlayed in a 50% dither pattern on the foreground and background colors
//  of the cells.
//
//  Parameters:
//
//      COLORREF crColor    New color property for the block of cells.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetBlendState
//
//  If blend state is TRUE for a block of cells, then the blend color is applied
//  in a 50% dither pattern.
//
//  Parameters:
//
//      BOOL bState         Apply blend if TRUE.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetUserValue
//
//  Store a user-defined DWORD with each cell in the block.
//
//  Parameters:
//
//      DWORD dwValue       User-defined value to store.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::SetUserDataPtr
//
//  Store a user-defined pointer with each cell in the block.
//
//  Parameters:
//
//      LPVOID lpData       User-defined pointer to store.
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::MergeCells
//
//  Visually merges the specified block of cells to give them the appearance
//  of a contiguous block.  A merged block of cells does not contain the grid
//  lines that normally separate each cell.  Use this function to create
//  block areas that represent an event in the schedule.  Note that merged
//  blocks do not actually become a managed object in the matrix and that it
//  is therefore possible to merge a block of cells that intersects a
//  previously merged block.  It is the application's responsibility to track
//  these blocks and prevent or resolve any confusion from overlapping "merged"
//  blocks.
//
//  Parameters:
//
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::UnMergeCells
//
//  Removes the merge effect imposed by MergeCells.
//
//  Parameters:
//
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetMergeState
//
//  Retrieves the merge state of the specified block of cells.  A block can
//  have one of the following merge states:
//
//      MS_UNMERGED     No cell in the specified block is merged.
//      MS_MERGED       All cells in the specified block have been merged and
//                      in fact represent a "perfect" merge, i.e. all edges
//                      of the merged block have been accounted for.  An
//                      incomplete part of a merged block returns MS_MIXEDMERGE.
//      MS_MIXEDMERGE   The specified block is a mixture of merged and unmerged
//                      cells or an incomplete portion of a merged block has
//                      been specified.
//
//  Parameters:
//
//      UINT nHour          Starting hour for the block.
//      UINT nDay           Starting day for the block.
//      UINT nNumHours      Range of block along the hour axis. (Default=1).
//      UINT nNumDays       Range of block along the day axis. (Default=1).
//
//  Returns:
//
//      UINT nState     MS_UNMERGED, MS_MERGED, or MS_MIXEDMERGE.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetBackColor
//
//  Retrieves the background color of the specified cell.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      COLORREF crColor    Current color property for the cell.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetForeColor
//
//  Retrieves the foreground color of the specified cell.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      COLORREF crColor    Current color property for the cell.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetPercentage
//
//  Retrieves the percentage of foreground to background color in the specified
//  cell.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      UINT nPercent      Current percentage of foreground to background.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetBlendColor
//
//  Retrieves the blend color of the specified cell.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      COLORREF crColor    Current color property for the cell.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetBlendState
//
//  Retrieves the blend state of the specified cell.  If blend state is TRUE,
//  the cell is currently being rendered with a 50% blend on top of the foreground
//  and background colors.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      BOOL bState         TRUE if blend is turned on for this cell.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetUserValue
//
//  Returns the user-defined DWORD value associated with the specified cell.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      DWORD dwValue       User-defined DWORD value.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::GetUserDataPtr
//
//  Returns the user-defined data pointer associated with the specified cell.
//
//  Parameters:
//
//      UINT nHour          Hour position of the cell.
//      UINT nDay           Day position of the cell.
//
//  Returns:
//
//      LPVOID lpData       User-defined pointer.
//
//----------------------------------------------------------------------------
//
//  CScheduleMatrix::~CScheduleMatrix
//
//  Destructor.
//
//****************************************************************************

class UITOOLS_CLASS CScheduleMatrix : public CWnd
{
    DECLARE_DYNAMIC(CScheduleMatrix)

// Construction
public:
	CScheduleMatrix();
	CScheduleMatrix(UINT nType);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CScheduleMatrix)
	public:
	//}}AFX_VIRTUAL
    virtual BOOL Create(LPCTSTR lpszWindowName, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);

// Implementation
public:
	void SetType(UINT nType);
    BOOL DeselectAll();
    BOOL SelectAll();
	BOOL SetSel(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays);
	void GetSel(UINT& nHour, UINT& nDay, UINT& nNumHours, UINT& nNumDays);
    void GetSelDescription(CString &sText);
    BOOL CellInSel(UINT nHour, UINT nDay);
    CSize GetCellSize();
    void DrawCell(CDC *pdc, LPCRECT pRect, UINT nPercent, BOOL bBlendState = FALSE,
        COLORREF crBackColor = DEFBACKCOLOR, COLORREF crForeColor = DEFFORECOLOR,
        COLORREF crBlendColor = DEFBLENDCOLOR);
	void SetBackColor(COLORREF crColor, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void SetForeColor(COLORREF crColor, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void SetPercentage(UINT nPercent, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void SetBlendColor(COLORREF crColor, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void SetBlendState(BOOL bState, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void SetUserValue(DWORD dwValue, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void SetUserDataPtr(LPVOID lpData, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void MergeCells(UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	void UnMergeCells(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays=1);
    UINT GetMergeState(UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	COLORREF GetBackColor(UINT nHour, UINT nDay);
	COLORREF GetForeColor(UINT nHour, UINT nDay);
	UINT GetPercentage(UINT nHour, UINT nDay);
	COLORREF GetBlendColor(UINT nHour, UINT nDay);
	BOOL GetBlendState(UINT nHour, UINT nDay);
	DWORD GetUserValue(UINT nHour, UINT nDay);
	LPVOID GetUserDataPtr(UINT nHour, UINT nDay);
    void GetDescription(CString &sText, UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1);
	virtual ~CScheduleMatrix();

protected:
    CHourLegend m_HourLegend;
    CPercentLabel m_PercentLabel;
    UINT m_nType;

    // Data
    CMatrixCell m_CellArray[24][7];

    // Metrics
    UINT m_nCellWidth;
    UINT m_nCellHeight;
    CRect m_rHourLegend;
    CRect m_rAllHeader;
    CRect m_rHourHeader;
    CRect m_rDayHeader;
    CRect m_rCellArray;
    CRect m_rPercentLabel;

    CString m_DayStrings[8];

    // Selection
    UINT m_nSelHour, m_nSelDay, m_nNumSelHours, m_nNumSelDays;
    UINT m_nSaveHour, m_nSaveDay, m_nNumSaveHours, m_nNumSaveDays;

    // Work vars
    CBrush m_brBlend, m_brMask;
    CBitmap m_bmBlend, m_bmMask;
    HFONT m_hFont;
    CPoint m_ptDown, m_ptFocus;
    BOOL m_bShifted;

    // Generated message map functions
protected:
	CString FormatTime (UINT nHour) const;
	//{{AFX_MSG(CScheduleMatrix)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnPaint();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
    afx_msg UINT OnGetDlgCode();
    afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG

    afx_msg LRESULT OnSetFont( WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetFont( WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetObject (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetSelDescription (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetPercentage (WPARAM wParam, LPARAM lParam);

	BOOL SetSelValues(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays);
    void InvalidateCells(UINT nHour, UINT nDay, UINT nNumHours=1, UINT nNumDays=1,
        BOOL bErase = TRUE);
    void SetMatrixMetrics(int cx, int cy);
    void CellToClient(LONG &nX, LONG &nY);
    void ClientToCell(LONG &nX, LONG &nY);
	void DrawCell(CDC *pdc, CMatrixCell *pCell, int x, int y, int w, int h);
	void DrawHeader(CDC *pdc, LPCRECT lpRect, LPCTSTR pszText, BOOL bSelected);
    void Press(CPoint pt, BOOL bExtend);
    void Extend(CPoint pt);
    void Release(CPoint pt);

    DECLARE_MESSAGE_MAP()

private:
    CString GetLocaleDay (LCTYPE lcType) const;
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // _SCHEDMAT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\stdafx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       stdafx.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__0F68A43D_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_)
#define AFX_STDAFX_H__0F68A43D_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#pragma warning(push,3)

#include <xstring>
#include <list>
#include <vector>
#include <algorithm>

using namespace std;

#pragma warning(pop)

#include "debug.h"
#include "resource.h"

#define IID_PPV_ARG(Type, Expr) IID_##Type, \
	reinterpret_cast<void**>(static_cast<Type **>(Expr))

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0F68A43D_FEE5_11D0_BB0F_00C04FC9A3A3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\loghours\schedmat.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Schedmat.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// schedmat.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"

#include "schedmat.h"
#include "AccessibleWrapper.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


typedef HRESULT (WINAPI * PFNCREATESTDACCESSIBLEOBJECT)(HWND, LONG, REFIID, void **);
typedef HRESULT (WINAPI * PFNCREATESTDACCESSIBLEPROXY)(HWND, LPCTSTR, LONG, REFIID, void **);
typedef LRESULT (WINAPI * PFNLRESULTFROMOBJECT)(REFIID, WPARAM, LPUNKNOWN);

PFNCREATESTDACCESSIBLEOBJECT s_pfnCreateStdAccessibleObject = 0;
PFNCREATESTDACCESSIBLEPROXY s_pfnCreateStdAccessibleProxy = NULL;
PFNLRESULTFROMOBJECT s_pfnLresultFromObject = NULL;

BOOL g_fAttemptedOleAccLoad ;
HMODULE g_hOleAcc;

/////////////////////////////////////////////////////////////////////////////
// CMatrixCell

IMPLEMENT_DYNAMIC(CMatrixCell, CObject)

//****************************************************************************
//
//  CMatrixCell::CMatrixCell
//
//****************************************************************************
CMatrixCell::CMatrixCell()
{
    m_crBackColor = DEFBACKCOLOR;
    m_crForeColor = DEFFORECOLOR;
    m_nPercentage = 0;

    m_crBlendColor = DEFBLENDCOLOR;

    m_dwUserValue = 0;
    m_pUserDataPtr = NULL;

    m_dwFlags = 0;
}

//****************************************************************************
//
//  CMatrixCell::~CMatrixCell
//
//****************************************************************************
CMatrixCell::~CMatrixCell()
{
}

/////////////////////////////////////////////////////////////////////////////
// CScheduleMatrix

IMPLEMENT_DYNAMIC(CScheduleMatrix, CWnd)

//****************************************************************************
//
//  CScheduleMatrix::CScheduleMatrix
//
//****************************************************************************
CScheduleMatrix::CScheduleMatrix()
{
    SetType(MT_WEEKLY);

    m_hFont = NULL;

    m_nSelHour = m_nSelDay = m_nNumSelHours = m_nNumSelDays = 0;
    m_nSaveHour = m_nSaveDay = m_nNumSaveHours = m_nNumSaveDays = 0;

    m_bShifted = FALSE;
}

//****************************************************************************
//
//  CScheduleMatrix::CScheduleMatrix
//
//****************************************************************************
CScheduleMatrix::CScheduleMatrix(UINT nType)
{
    SetType(nType);

    m_hFont = NULL;

    m_nSelHour = m_nSelDay = m_nNumSelHours = m_nNumSelDays = 0;
    m_nSaveHour = m_nSaveDay = m_nNumSaveHours = m_nNumSaveDays = 0;

    m_bShifted = FALSE;
}

//****************************************************************************
//
//  CScheduleMatrix::~CScheduleMatrix
//
//****************************************************************************
CScheduleMatrix::~CScheduleMatrix()
{
}

BEGIN_MESSAGE_MAP(CScheduleMatrix, CWnd)
    //{{AFX_MSG_MAP(CScheduleMatrix)
    ON_WM_CREATE()
    ON_WM_SIZE()
    ON_WM_PAINT()
    ON_WM_SETFOCUS()
    ON_WM_KILLFOCUS()
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_MOUSEMOVE()
    ON_WM_GETDLGCODE()
    ON_WM_KEYDOWN()
    ON_WM_KEYUP()
    //}}AFX_MSG_MAP
    ON_MESSAGE(WM_SETFONT, OnSetFont)
    ON_MESSAGE(WM_GETFONT, OnGetFont)
    ON_MESSAGE(WM_GETOBJECT, OnGetObject)
    ON_MESSAGE(SCHEDMSG_GETSELDESCRIPTION, OnGetSelDescription)
    ON_MESSAGE(SCHEDMSG_GETPERCENTAGE, OnGetPercentage)
END_MESSAGE_MAP()

//****************************************************************************
//
//  CScheduleMatrix::Create
//
//****************************************************************************
BOOL CScheduleMatrix::Create(LPCTSTR lpszWindowName, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* /*pContext*/)
{
    CRect r(0,0,0,0);
    if (!m_HourLegend.Create(NULL, _T(""), WS_CHILD | WS_VISIBLE, r, pParentWnd, (UINT) -1, NULL))
        return FALSE;
    if (!m_PercentLabel.Create(NULL, _T(""), WS_CHILD | WS_VISIBLE, r, pParentWnd, (UINT) -1, NULL))
        return FALSE;

    m_PercentLabel.m_pMatrix = this;

    return CWnd::Create(NULL, lpszWindowName, WS_CHILD | WS_VISIBLE | WS_TABSTOP,
        rect, pParentWnd, nID, NULL);
}

/////////////////////////////////////////////////////////////////////////////
// CScheduleMatrix message handlers

//****************************************************************************
//
//  CScheduleMatrix::OnSize
//
//****************************************************************************
void CScheduleMatrix::OnSize(UINT nType, int cx, int cy)
{
	CWnd::OnSize(nType, cx, cy);

    SetMatrixMetrics(cx, cy);

    Invalidate();
}

//****************************************************************************
//
//  CScheduleMatrix::SetMatrixMetrics
//
//****************************************************************************
void CScheduleMatrix::SetMatrixMetrics(int cx, int cy)
{
    if (m_hWnd == NULL)
        return;

    CDC *pdc = GetDC();
    CFont *pOldFont = NULL;
    CFont *pFont = CFont::FromHandle(m_hFont);

    if (pFont != NULL)
        pOldFont = pdc->SelectObject(pFont);

    // Calculate some useful metrics
    int i;
    int nRows = (m_nType==MT_DAILY ? 1 : 8); // 8 rows = 7 days + header
    CSize size = pdc->GetTextExtent(_T("0"));
    int nCharHeight = size.cy;
    int nCharWidth = size.cx;
    int nDayWidth = 0;
    for (i=0; i<8; i++)
    {
        size = pdc->GetTextExtent(m_DayStrings[i]);
        nDayWidth = max(nDayWidth, size.cx + 2*nCharWidth);
        // If daily schedule, stop after first
        if (m_nType == MT_DAILY)
            break;
    }

    if (pOldFont != NULL)
        pdc->SelectObject(pOldFont);

    ReleaseDC(pdc);

    nDayWidth = max(nDayWidth, 2*nCharWidth);

    int nLegendHeight = nCharHeight + 4 + 16; // a little margin over char height plus icon height
    int nLabelHeight = (m_nType == MT_DAILY ? nCharHeight + 4 : 0);

    // Cell array should fill space after hour legend and %labels...
    int nBtnHeight = max(0, cy-nLegendHeight-nLabelHeight)/nRows;
    // ... but should at least accomodate label text and some margin
    nBtnHeight = max(nBtnHeight, nCharHeight + 4);

    m_nCellWidth = max(0, (cx - nDayWidth)/24);
    m_nCellHeight = nBtnHeight;

    // Leave an extra pixel for the lower right cell border
    int nArrayWidth = 24*m_nCellWidth + 1;
    int nArrayHeight = (m_nType==MT_DAILY ? 1 : 7)*m_nCellHeight + 1;

    // Adjust header width to absorb roundoff from cells
    nDayWidth = max(0, cx - nArrayWidth);
    // Adjust legend height to absorb roundoff from cells
    nLegendHeight = max(0,
        cy - (nArrayHeight + (m_nType==MT_DAILY ? 0 : nBtnHeight)) - nLabelHeight);

    m_rHourLegend.SetRect(0, 0, cx, nLegendHeight);
    if (m_nType == MT_DAILY)
    {
        m_rAllHeader.SetRect(0, nLegendHeight, nDayWidth, nLegendHeight+nBtnHeight);
        m_rHourHeader.SetRect(0,0,0,0);
        m_rDayHeader.SetRect(0,0,0,0);
        m_rCellArray.SetRect(nDayWidth, nLegendHeight, cx, cy-nLabelHeight);
        m_rPercentLabel.SetRect(0,cy-nLabelHeight,cx,cy);
    }
    else
    {
        m_rAllHeader.SetRect(0, nLegendHeight, nDayWidth, nLegendHeight+nBtnHeight);
        m_rHourHeader.SetRect(nDayWidth, nLegendHeight, cx, nLegendHeight+nBtnHeight);
        m_rDayHeader.SetRect(0, nLegendHeight+nBtnHeight, nDayWidth, cy);
        m_rCellArray.SetRect(nDayWidth, nLegendHeight + nBtnHeight, cx, cy);
        m_rPercentLabel.SetRect(0,0,0,0);
    }

    // Move the hour legend window into place
    if (m_HourLegend.GetSafeHwnd() != NULL)
    {
        CRect rHourLegend = m_rHourLegend;
        ClientToScreen(rHourLegend);
        GetParent()->ScreenToClient(rHourLegend);
        rHourLegend.right += nCharWidth;
        m_HourLegend.MoveWindow(rHourLegend);
        m_HourLegend.m_nCharHeight = nCharHeight;
        m_HourLegend.m_nCharWidth = nCharWidth;
        m_HourLegend.m_nCellWidth = m_nCellWidth;
        m_HourLegend.m_hFont = m_hFont;
        m_HourLegend.m_rLegend.SetRect(m_rCellArray.left, 0, m_rCellArray.right,
            nLegendHeight);
    }

    // Move the % label window into place
    if (m_PercentLabel.GetSafeHwnd() != NULL)
    {
        CRect rPercentLabel = m_rPercentLabel;
        ClientToScreen(rPercentLabel);
        GetParent()->ScreenToClient(rPercentLabel);
        m_PercentLabel.MoveWindow(rPercentLabel);
        m_PercentLabel.m_nCellWidth = m_nCellWidth;
        m_PercentLabel.m_hFont = m_hFont;
        m_PercentLabel.m_rHeader.SetRect(m_rAllHeader.left, 0, m_rAllHeader.right,
            nLabelHeight);
        m_PercentLabel.m_rLabels.SetRect(m_rCellArray.left, 0, m_rCellArray.right,
            nLabelHeight);
    }
}

//****************************************************************************
//
//  CScheduleMatrix::OnPaint
//
//****************************************************************************
void CScheduleMatrix::OnPaint()
{
    int i, j, x, y;
    CRect r, r2;
    BOOL bPressed;

    CPaintDC dc(this); // device context for painting

    CFont *pOldFont = NULL;
    CFont *pFont = CFont::FromHandle(m_hFont);

    if (pFont != NULL)
        pOldFont = dc.SelectObject(pFont);

    CBrush brFace(::GetSysColor(COLOR_3DFACE));
    CPen penFace(PS_SOLID, 0, ::GetSysColor(COLOR_3DFACE));

    CBrush *pbrOld = dc.SelectObject(&brFace);
    CPen *ppenOld = dc.SelectObject(&penFace);
    COLORREF crBkOld = dc.GetBkColor();
    COLORREF crTextOld = dc.GetTextColor();

    // Draw the All header

    if (GetCapture() == this && m_rAllHeader.PtInRect(m_ptDown))
        bPressed = TRUE;
    else
        bPressed = FALSE;
    DrawHeader(&dc, m_rAllHeader, m_DayStrings[0], bPressed);

    // Draw the hour header

    if (!m_rHourHeader.IsRectEmpty())
    {
        // First hour is special case
        r.SetRect(m_rHourHeader.left, m_rHourHeader.top,
            m_rHourHeader.left+m_nCellWidth+1, m_rHourHeader.bottom);
        if (GetCapture() == this && m_rHourHeader.PtInRect(m_ptDown) && CellInSel(0,0))
            bPressed = TRUE;
        else
            bPressed = FALSE;
        DrawHeader(&dc, r, NULL, bPressed);
        r = m_rHourHeader;
        r.left += 1;
        r.right = r.left + m_nCellWidth;
        for (i=1; i<24; i++)
        {
            r.OffsetRect(m_nCellWidth, 0);
            if (GetCapture() == this && m_rHourHeader.PtInRect(m_ptDown) && CellInSel(i,0))
                bPressed = TRUE;
            else
                bPressed = FALSE;
            DrawHeader(&dc, r, NULL, bPressed);
        }
    }

    // Draw the day header

    if (!m_rDayHeader.IsRectEmpty())
    {
        // First day is special case
        r.SetRect(m_rDayHeader.left, m_rDayHeader.top,
            m_rDayHeader.right, m_rDayHeader.top+m_nCellHeight+1);
        if (GetCapture() == this && m_rDayHeader.PtInRect(m_ptDown) && CellInSel(0,0))
            bPressed = TRUE;
        else
            bPressed = FALSE;
        DrawHeader(&dc, r, m_DayStrings[1], bPressed);
        r = m_rDayHeader;
        r.top += 1;
        r.bottom = r.top + m_nCellHeight;
        for (i=2; i<8; i++)
        {
            r.OffsetRect(0, m_nCellHeight);
            if (GetCapture() == this && m_rDayHeader.PtInRect(m_ptDown) && CellInSel(0,i-1))
                bPressed = TRUE;
            else
                bPressed = FALSE;
            DrawHeader(&dc, r, m_DayStrings[i], bPressed);
        }
    }

    // Draw the cell array

    int nDays = (m_nType==MT_DAILY ? 1 : 7);
    y = m_rCellArray.top;
    for (j=0; j<nDays; j++)
    {
        x = m_rCellArray.left;
        for (i=0; i<24; i++)
        {
            DrawCell(&dc, &m_CellArray[i][j], x, y, m_nCellWidth, m_nCellHeight);
            x += m_nCellWidth;
        }
        y += m_nCellHeight;
    }

    dc.SetBkColor(crBkOld);
    dc.SetTextColor(crTextOld);

    // Draw the lower right cell borders since no cell takes responsibility for it
    dc.MoveTo(m_rCellArray.left, m_rCellArray.bottom-1);
    dc.LineTo(m_rCellArray.right-1, m_rCellArray.bottom-1);
    dc.LineTo(m_rCellArray.right-1, m_rCellArray.top-1);

    // Draw selection indicator (hardwired black and white for max contrast).
    if (m_nNumSelHours != 0 && m_nNumSelDays != 0)
    {
        CRect rSel(m_nSelHour, m_nSelDay, m_nSelHour+m_nNumSelHours, m_nSelDay+m_nNumSelDays);
        CellToClient(rSel.left, rSel.top);
        CellToClient(rSel.right, rSel.bottom);
        rSel.right+=1;
        rSel.bottom+=1;
        CBrush brBlack(RGB(0,0,0)), brWhite(RGB(255,255,255));
        dc.FrameRect(rSel, &brBlack);
        if (GetFocus()==this)
            dc.DrawFocusRect(rSel);
        rSel.InflateRect(-1,-1);
        dc.FrameRect(rSel, &brBlack);
        rSel.InflateRect(-1,-1);
        dc.FrameRect(rSel, &brWhite);
    }

    if (pbrOld != NULL)
        dc.SelectObject(pbrOld);
    if (ppenOld != NULL)
        dc.SelectObject(ppenOld);
	
    if (pOldFont != NULL)
        dc.SelectObject(pOldFont);

    // Do not call CWnd::OnPaint() for painting messages
}

//****************************************************************************
//
//  CScheduleMatrix::CellToClient
//
//****************************************************************************
void CScheduleMatrix::CellToClient(LONG &nX, LONG &nY)
{
    nX = nX*m_nCellWidth + m_rCellArray.left;
    nY = nY*m_nCellHeight + m_rCellArray.top;
}

//****************************************************************************
//
//  CScheduleMatrix::ClientToCell
//
//****************************************************************************
void CScheduleMatrix::ClientToCell(LONG &nX, LONG &nY)
{
    nX = max(nX, m_rCellArray.left);
    nX = min(nX, m_rCellArray.right);
    nY = max(nY, m_rCellArray.top);
    nY = min(nY, m_rCellArray.bottom);
    nX = (nX-m_rCellArray.left)/m_nCellWidth;
    nY = (nY-m_rCellArray.top)/m_nCellHeight;
    nX = min(nX, 23);
    nY = min(nY, (m_nType == MT_DAILY ? 0 : 6));
}

//****************************************************************************
//
//  CScheduleMatrix::GetCellSize
//
//****************************************************************************
CSize CScheduleMatrix::GetCellSize()
{
    SIZE size;
    size.cx = m_nCellWidth;
    size.cy = m_nCellHeight;
    return size;
}

//****************************************************************************
//
//  CScheduleMatrix::DrawCell
//
//****************************************************************************
void CScheduleMatrix::DrawCell(CDC *pdc, LPCRECT pRect, UINT nPercent, BOOL bBlendState,
    COLORREF crBackColor, COLORREF crForeColor, COLORREF crBlendColor)
{
    CRect r(pRect);
    CMatrixCell Cell;

    ASSERT(nPercent <= 100);

    Cell.m_nPercentage = nPercent;
//??
    Cell.m_dwFlags = MC_MERGELEFT | MC_MERGETOP;
    if (bBlendState)
        Cell.m_dwFlags |= MC_BLEND;
    Cell.m_crBackColor = crBackColor;
    Cell.m_crForeColor = crForeColor;
    Cell.m_crBlendColor = crBlendColor;

    CBrush brFace(::GetSysColor(COLOR_3DFACE));
    CPen penFace(PS_SOLID, 0, ::GetSysColor(COLOR_3DFACE));

    CBrush *pbrOld = pdc->SelectObject(&brFace);
    CPen *ppenOld = pdc->SelectObject(&penFace);
    COLORREF crBkOld = pdc->GetBkColor();
    COLORREF crTextOld = pdc->GetTextColor();

    DrawCell(pdc, &Cell, r.left, r.top, r.Width(), r.Height());

    pdc->SetBkColor(crBkOld);
    pdc->SetTextColor(crTextOld);

    // Draw the lower right cell border since cell doesn't take responsibility for it
    /* //??
    pdc->MoveTo(r.left, r.bottom-1);
    pdc->LineTo(r.right-1, r.bottom-1);
    pdc->LineTo(r.right-1, r.top-1);
    */

    if (pbrOld != NULL)
        pdc->SelectObject(pbrOld);
    if (ppenOld != NULL)
        pdc->SelectObject(ppenOld);
}

//****************************************************************************
//
//  CScheduleMatrix::DrawCell
//
//****************************************************************************
void CScheduleMatrix::DrawCell(CDC *pdc, CMatrixCell *pCell, int x, int y, int w, int h)
{
    int x1, y1, nPercent;
    CRect rBack, rFore, rBlend, rClip, rCell, rWork;

    // Don't bother if not invalid
    pdc->GetClipBox(rClip);
    rCell.SetRect(x,y,x+w,y+h);
    if (!rWork.IntersectRect(rClip, rCell))
        return;

    // Calculate portions to devote to fore/back colors
    // Account for merge effect
    nPercent = MulDiv(pCell->m_nPercentage, h-(pCell->m_dwFlags & MC_MERGETOP?0:1), 100);
    if (pCell->m_dwFlags & MC_MERGELEFT)
    {
        x1 = x;
    }
    else
    {
        x1 = x + 1;
        pdc->MoveTo(x, y);
        pdc->LineTo(x, y+h);
    }
    if (pCell->m_dwFlags & MC_MERGETOP)
    {
        y1 = y;
    }
    else
    {
        y1 = y + 1;
        pdc->MoveTo(x, y);
        pdc->LineTo(x+w, y);
    }
    rBack.SetRect(x1, y1, x+w, y+h-nPercent);
    rFore.SetRect(x1, rBack.bottom, x+w, y+h);
    rBlend.SetRect(x1, y1, x+w, y+h);

    // Ensure a touch of color at the boundaries
    if (rBack.Height() == 0 && pCell->m_nPercentage != 100)
    {
        rBack.bottom+=1;
        rFore.top+=1;
    }
    if (rFore.Height() == 0 && pCell->m_nPercentage != 0)
    {
        rBack.bottom-=1;
        rFore.top-=1;
    }

    // Draw the histogram
    CBrush brBack(pCell->m_crBackColor);
    CBrush brFore(pCell->m_crForeColor);
    pdc->FillRect(rBack, &brBack);
    pdc->FillRect(rFore, &brFore);

    // Overlay the blend color
    if (pCell->m_dwFlags & MC_BLEND)
    {
        // Create the GDI work objects if necessary
        if (m_bmBlend.GetSafeHandle() == NULL)
        {
            SHORT BlendBits[] = {0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55};
            SHORT MaskBits[] = {0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA};
            m_bmBlend.CreateBitmap(8,8,1,1,&BlendBits);
            m_bmMask.CreateBitmap(8,8,1,1,&MaskBits);
            m_brBlend.CreatePatternBrush(&m_bmBlend);
            m_brMask.CreatePatternBrush(&m_bmMask);
        }

        pdc->SetTextColor(RGB(0,0,0));

        // Mask out the existing bits in the cell
        pdc->SetBkColor(RGB(255,255,255));
        pdc->SelectObject(&m_brMask);
        pdc->PatBlt(rBlend.left, rBlend.top, rBlend.Width(), rBlend.Height(), 0x00A000C9); //DPa

        // Add the blend color into the masked pixels
        pdc->SetBkColor(pCell->m_crBlendColor);
        pdc->SelectObject(&m_brBlend);
        pdc->PatBlt(rBlend.left, rBlend.top, rBlend.Width(), rBlend.Height(), 0x00FA0089); //DPo
    }
}

//****************************************************************************
//
//  CScheduleMatrix::DrawHeader
//
//****************************************************************************
void CScheduleMatrix::DrawHeader(CDC *pdc, LPCRECT lpRect, LPCTSTR pszText, BOOL bSelected)
{
    CBrush brFace(::GetSysColor(COLOR_3DFACE));
    COLORREF crTL, crBR;
    COLORREF crBkOld = pdc->GetBkColor();
    COLORREF crTextOld = pdc->GetTextColor();

    if (bSelected)
    {
        crTL = ::GetSysColor(COLOR_3DSHADOW);
        crBR = ::GetSysColor(COLOR_3DHIGHLIGHT);
    }
    else
    {
        crTL = ::GetSysColor(COLOR_3DHIGHLIGHT);
        crBR = ::GetSysColor(COLOR_3DSHADOW);
    }

    pdc->FillRect(lpRect, &brFace);
    pdc->Draw3dRect(lpRect, crTL, crBR);
    pdc->SetBkColor(::GetSysColor(COLOR_3DFACE));
    pdc->SetTextColor(::GetSysColor(COLOR_BTNTEXT));
    if (pszText != NULL)
        ::DrawTextEx(pdc->GetSafeHdc(), (LPTSTR)pszText, -1, (LPRECT)lpRect,
            DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_END_ELLIPSIS, NULL);

    pdc->SetBkColor(crBkOld);
    pdc->SetTextColor(crTextOld);
}

//****************************************************************************
//
//  CScheduleMatrix::OnSetFont
//
//****************************************************************************
LRESULT CScheduleMatrix::OnSetFont( WPARAM wParam, LPARAM lParam )
{
    m_hFont = (HFONT)wParam;
    m_HourLegend.m_hFont = m_hFont;

    CRect rClient;
    GetClientRect(rClient);
    SetMatrixMetrics(rClient.Width(), rClient.Height());
    Invalidate();

    if (HIWORD(lParam) != 0)
        UpdateWindow();

    return 0L;
}

//****************************************************************************
//
//  CScheduleMatrix::OnGetFont
//
//****************************************************************************
LRESULT CScheduleMatrix::OnGetFont( WPARAM /*wParam*/, LPARAM /*lParam*/ )
{
    return (LRESULT)m_hFont;
}


//****************************************************************************
//
//  CScheduleMatrix::SetSelValues
//
//****************************************************************************
BOOL CScheduleMatrix::SetSelValues(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    // Deselect allows "illegal" values

    if (!(nHour == 0 && nDay == 0 && nNumHours == 0 && nNumDays == 0))
    {
        UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
        ASSERT(nHour < 24);
        ASSERT(nDay < nDays);
        ASSERT(nNumHours>=1);
        ASSERT(nNumDays>=1);
        ASSERT(nHour + nNumHours <= 24);
        ASSERT(nDay + nNumDays <= nDays);
    }

    if (m_nSelHour != nHour || m_nSelDay != nDay ||
        m_nNumSelHours != nNumHours || m_nNumSelDays != nNumDays)
    {
        InvalidateCells(m_nSelHour, m_nSelDay, m_nNumSelHours, m_nNumSelDays, FALSE);

        m_nSelHour = nHour;
        m_nSelDay = nDay;
        m_nNumSelHours = nNumHours;
        m_nNumSelDays = nNumDays;

        InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);

        return TRUE;
    }

    return FALSE;
}

//****************************************************************************
//
//  CScheduleMatrix::SetSel
//
//****************************************************************************
BOOL CScheduleMatrix::SetSel(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    if (SetSelValues(nHour, nDay, nNumHours, nNumDays))
    {
        UpdateWindow();

        m_ptDown.x = nHour;
        m_ptDown.y = nDay;
        CellToClient(m_ptDown.x, m_ptDown.y);
        m_ptFocus.x = nHour + nNumHours - 1;
        m_ptFocus.y = nDay + nNumDays - 1;
        CellToClient(m_ptFocus.x, m_ptFocus.y);

        return TRUE;
    }

    return FALSE;
}

//****************************************************************************
//
//  CScheduleMatrix::SelectAll
//
//****************************************************************************
BOOL CScheduleMatrix::SelectAll()
{
    if (m_nType == MT_DAILY)
        return SetSel(0,0,23,1);

    return SetSel(0,0,23,7);
}

//****************************************************************************
//
//  CScheduleMatrix::DeselectAll
//
//****************************************************************************
BOOL CScheduleMatrix::DeselectAll()
{
    return SetSel(0,0,0,0);
}

//****************************************************************************
//
//  CScheduleMatrix::GetSel
//
//****************************************************************************
void CScheduleMatrix::GetSel(UINT & nHour, UINT & nDay, UINT & nNumHours, UINT & nNumDays)
{
    nHour = m_nSelHour;
    nDay = m_nSelDay;
    nNumHours = m_nNumSelHours;
    nNumDays = m_nNumSelDays;
}

//****************************************************************************
//
//  CScheduleMatrix::GetSelDescription
//
//****************************************************************************
void CScheduleMatrix::GetSelDescription(CString &sText)
{
    GetDescription(sText, m_nSelHour, m_nSelDay, m_nNumSelHours, m_nNumSelDays);
}


//****************************************************************************
//
//  CScheduleMatrix::FormatTime
//
//****************************************************************************
CString CScheduleMatrix::FormatTime(UINT nHour) const
{
    CString sTime;

    SYSTEMTIME	sysTime;
    ::ZeroMemory (&sysTime, sizeof (SYSTEMTIME));

    // Make sure that nHour is 0 to 24
    nHour = nHour % 24;
    sysTime.wHour = (WORD)nHour;

	// Get first time
	// Get length to allocate buffer of sufficient size
    int iLen = ::GetTimeFormat (
			LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
			TIME_NOSECONDS, //TIME_NOMINUTESORSECONDS, // flags specifying function options 
			&sysTime, // date to be formatted 
			0, // date format string 
			0, // buffer for storing formatted string 
			0); // size of buffer 
	ASSERT (iLen > 0);
	if ( iLen > 0 )
	{
        int iResult = ::GetTimeFormat (
				LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
				TIME_NOSECONDS, //TIME_NOMINUTESORSECONDS, // flags specifying function options 
				&sysTime, // date to be formatted 
				0, // date format string 
				sTime.GetBufferSetLength (iLen), // buffer for storing formatted string 
				iLen); // size of buffer 
		ASSERT (iResult);
		sTime.ReleaseBuffer ();
	}

    return sTime;
}

//****************************************************************************
//
//  CScheduleMatrix::GetDescription
//
//****************************************************************************
void CScheduleMatrix::GetDescription(CString &sText, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    CString sDay1;
    CString sDay2;
    CString sHour1;
    CString sHour2;

    if (nNumDays == 0 || nNumHours == 0)
    {
        sText.Empty();
        return;
    }

    // Get day strings
    sDay1 = m_DayStrings[nDay + 1];
    sDay2 = m_DayStrings[nDay + nNumDays];

    // Get time strings
    if ( sHour1.IsEmpty () )
        sHour1 = L"Error";

    // Get first time
    sHour1 = FormatTime (nHour);

    // Get second time
    sHour2 = FormatTime (nHour + nNumHours);

    if (m_nType == MT_DAILY)
    {
        sText.FormatMessage(IDS_TOOL_SCHEDULE_FMT_DAILY, (LPCTSTR)sHour1, (LPCTSTR)sHour2);
    }
    else
    {
        if (nNumDays == 1)
            sText.FormatMessage(IDS_TOOL_SCHEDULE_FMT_WEEKLY_SHORT, (LPCTSTR)sDay1,
                (LPCTSTR)sHour1, (LPCTSTR)sHour2);
        else
            sText.FormatMessage(IDS_TOOL_SCHEDULE_FMT_WEEKLY_LONG,
                (LPCTSTR)sDay1, (LPCTSTR)sDay2, (LPCTSTR)sHour1, (LPCTSTR)sHour2);
    }
}


//****************************************************************************
//
//  CScheduleMatrix::CellInSel
//
//****************************************************************************
BOOL CScheduleMatrix::CellInSel(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    if (m_nNumSelHours == 0 || m_nNumSelDays == 0)
        return FALSE;
    if (nHour < m_nSelHour || nHour >= m_nSelHour + m_nNumSelHours)
        return FALSE;
    if (nDay < m_nSelDay || nDay >= m_nSelDay + m_nNumSelDays)
        return FALSE;

    return TRUE;
}

//****************************************************************************
//
//  CScheduleMatrix::SetType
//
//****************************************************************************
void CScheduleMatrix::SetType(UINT nType)
{
    ASSERT(nType == MT_DAILY || nType == MT_WEEKLY);


    VERIFY (m_DayStrings[0].LoadString (IDS_ALL_HEADER_TEXT)); // "All" header
    

    // Day names start at index 1
    m_DayStrings[1] = GetLocaleDay (LOCALE_SDAYNAME7); // Sunday
    m_DayStrings[2] = GetLocaleDay (LOCALE_SDAYNAME1); // Monday, etc.
    m_DayStrings[3] = GetLocaleDay (LOCALE_SDAYNAME2);
    m_DayStrings[4] = GetLocaleDay (LOCALE_SDAYNAME3);
    m_DayStrings[5] = GetLocaleDay (LOCALE_SDAYNAME4);
    m_DayStrings[6] = GetLocaleDay (LOCALE_SDAYNAME5);
    m_DayStrings[7] = GetLocaleDay (LOCALE_SDAYNAME6);

    m_nType = nType;
}

//****************************************************************************
//
//  CScheduleMatrix::GetLocaleDay
//
//  Use the locale API to get the "official" days of the week.
//
//****************************************************************************
CString CScheduleMatrix::GetLocaleDay (LCTYPE lcType) const
{
    CString dayName;
    int     cchData = 64;
    int     iResult = 0;

    do {

        iResult = GetLocaleInfo(
                LOCALE_USER_DEFAULT,    // locale identifier
                lcType,       // information type
                const_cast <PWSTR>((PCWSTR) dayName.GetBufferSetLength (cchData)),  // information buffer
                cchData);       // size of buffer
        dayName.ReleaseBuffer ();
        if ( !iResult )
        {
            DWORD   dwErr = GetLastError ();
            switch (dwErr)
            {
            case ERROR_INSUFFICIENT_BUFFER:
                cchData += 64;
                break;

            default:
                ASSERT (0);
                switch (lcType)
                {
                case LOCALE_SDAYNAME1:
                    VERIFY (dayName.LoadString (IDS_MONDAY));
                    break;

                case LOCALE_SDAYNAME2:
                    VERIFY (dayName.LoadString (IDS_TUESDAY));
                    break;

                case LOCALE_SDAYNAME3:
                    VERIFY (dayName.LoadString (IDS_WEDNESDAY));
                    break;

                case LOCALE_SDAYNAME4:
                    VERIFY (dayName.LoadString (IDS_THURSDAY));
                    break;

                case LOCALE_SDAYNAME5:
                    VERIFY (dayName.LoadString (IDS_FRIDAY));
                    break;

                case LOCALE_SDAYNAME6:
                    VERIFY (dayName.LoadString (IDS_SATURDAY));
                    break;

                case LOCALE_SDAYNAME7:
                    VERIFY (dayName.LoadString (IDS_SUNDAY));
                    break;

                default:
                    ASSERT (0);
                    break;
                }
                break;
            }
        }
    } while (!iResult);

    return dayName;
}


//****************************************************************************
//
//  CScheduleMatrix::SetBackColor
//
//****************************************************************************
void CScheduleMatrix::SetBackColor(COLORREF crColor, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            m_CellArray[nHour+i][nDay+j].m_crBackColor = crColor;
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::SetForeColor
//
//****************************************************************************
void CScheduleMatrix::SetForeColor(COLORREF crColor, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            m_CellArray[nHour+i][nDay+j].m_crForeColor = crColor;
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::SetPercentage
//
//****************************************************************************
void CScheduleMatrix::SetPercentage(UINT nPercent, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);
    ASSERT(nPercent <= 100);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            m_CellArray[nHour+i][nDay+j].m_nPercentage = nPercent;
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::SetBlendColor
//
//****************************************************************************
void CScheduleMatrix::SetBlendColor(COLORREF crColor, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            m_CellArray[nHour+i][nDay+j].m_crBlendColor = crColor;
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::SetBlendState
//
//****************************************************************************
void CScheduleMatrix::SetBlendState(BOOL bState, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            if (bState)
                m_CellArray[nHour+i][nDay+j].m_dwFlags |= MC_BLEND;
            else
                m_CellArray[nHour+i][nDay+j].m_dwFlags &= (MC_BLEND^0xFFFFFFFF);
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::SetUserValue
//
//****************************************************************************
void CScheduleMatrix::SetUserValue(DWORD dwValue, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            m_CellArray[nHour+i][nDay+j].m_dwUserValue = dwValue;
        }
    }

    //?? If we ever have ownerdraw
    //?? InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::SetUserDataPtr
//
//****************************************************************************
void CScheduleMatrix::SetUserDataPtr(void * lpData, UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            m_CellArray[nHour+i][nDay+j].m_pUserDataPtr = lpData;
        }
    }

    //?? If we ever have ownerdraw
    //?? InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::MergeCells
//
//****************************************************************************
void CScheduleMatrix::MergeCells(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    DWORD dwFlags;
    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            dwFlags = m_CellArray[nHour+i][nDay+j].m_dwFlags;
            dwFlags |= MC_MERGE;
            dwFlags &= (MC_ALLEDGES^0xFFFFFFFF);
            if (i != 0)
                dwFlags |= MC_MERGELEFT;
            if (i == 0)
                dwFlags |= MC_LEFTEDGE;
            if (i == nNumHours-1)
                dwFlags |= MC_RIGHTEDGE;
            if (j != 0)
                dwFlags |= MC_MERGETOP;
            if (j == 0)
                dwFlags |= MC_TOPEDGE;
            if (j == nNumDays-1)
                dwFlags |= MC_BOTTOMEDGE;
            m_CellArray[nHour+i][nDay+j].m_dwFlags = dwFlags;
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::UnMergeCells
//
//****************************************************************************
void CScheduleMatrix::UnMergeCells(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    DWORD dwFlags;
    UINT i, j;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            dwFlags = m_CellArray[nHour+i][nDay+j].m_dwFlags;
            dwFlags &= (MC_ALLEDGES^0xFFFFFFFF);
            dwFlags &= (MC_MERGE^0xFFFFFFFF);
            if (i != 0)
                dwFlags &= (MC_MERGELEFT^0xFFFFFFFF);
            if (j != 0)
                dwFlags &= (MC_MERGETOP^0xFFFFFFFF);
            m_CellArray[nHour+i][nDay+j].m_dwFlags = dwFlags;
        }
    }

    InvalidateCells(nHour, nDay, nNumHours, nNumDays, FALSE);
}

//****************************************************************************
//
//  CScheduleMatrix::GetMergeState
//
//****************************************************************************
UINT CScheduleMatrix::GetMergeState(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays)
{
    // Returns:
    // 0 = Unmerged
    // 1 = Merged
    // 2 = Indeterminate (mixed)

    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);
    ASSERT(nNumHours>=1);
    ASSERT(nNumDays>=1);
    ASSERT(nHour + nNumHours <= 24);
    ASSERT(nDay + nNumDays <= nDays);

    UINT i, j;
    DWORD dwFlags;
    BOOL bFoundMergedCell = FALSE, bFoundUnmergedCell = FALSE,
        bFoundBadEdge = FALSE, bFoundBadNonEdge = FALSE;
    for (i=0; i<nNumHours; i++)
    {
        for (j=0; j<nNumDays; j++)
        {
            dwFlags = m_CellArray[nHour+i][nDay+j].m_dwFlags;
            if (dwFlags & MC_MERGE)
                bFoundMergedCell = TRUE;
            else
                bFoundUnmergedCell = TRUE;
            if (i == 0 || i == nNumHours-1 || j == 0 || j == nNumDays-1)
            {
                // If cell is an edge, make sure it's marked appropriately
                if (i == 0 && !(dwFlags & MC_LEFTEDGE))
                    bFoundBadEdge = TRUE;
                if (i == nNumHours-1 && !(dwFlags & MC_RIGHTEDGE))
                    bFoundBadEdge = TRUE;
                if (j == 0 && !(dwFlags & MC_TOPEDGE))
                    bFoundBadEdge = TRUE;
                if (j == nNumDays-1 && !(dwFlags & MC_BOTTOMEDGE))
                    bFoundBadEdge = TRUE;
            }
            else
            {
                // If cell is not an edge, make sure it's not marked as such
                if (dwFlags & MC_ALLEDGES)
                    bFoundBadNonEdge = TRUE;
            }
        }
    }

    // If we found no merged cells, we are definitely unmerged
    if (!bFoundMergedCell)
        return MS_UNMERGED;
    // If we found only good, merged cells, we are definitely merged
    if (!bFoundUnmergedCell && !bFoundBadEdge && !bFoundBadNonEdge)
        return MS_MERGED;

    return MS_MIXEDMERGE;
}

//****************************************************************************
//
//  CScheduleMatrix::GetBackColor
//
//****************************************************************************
COLORREF CScheduleMatrix::GetBackColor(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    return m_CellArray[nHour][nDay].m_crBackColor;
}

//****************************************************************************
//
//  CScheduleMatrix::GetForeColor
//
//****************************************************************************
COLORREF CScheduleMatrix::GetForeColor(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    return m_CellArray[nHour][nDay].m_crForeColor;
}

//****************************************************************************
//
//  CScheduleMatrix::GetPercentage
//
//****************************************************************************
UINT CScheduleMatrix::GetPercentage(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    return m_CellArray[nHour][nDay].m_nPercentage;
}

//****************************************************************************
//
//  CScheduleMatrix::GetBlendColor
//
//****************************************************************************
COLORREF CScheduleMatrix::GetBlendColor(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    return m_CellArray[nHour][nDay].m_crBlendColor;
}

//****************************************************************************
//
//  CScheduleMatrix::GetBlendState
//
//****************************************************************************
BOOL CScheduleMatrix::GetBlendState(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    if (m_CellArray[nHour][nDay].m_dwFlags & MC_BLEND)
        return TRUE;

    return FALSE;
}

//****************************************************************************
//
//  CScheduleMatrix::GetUserValue
//
//****************************************************************************
DWORD CScheduleMatrix::GetUserValue(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    return m_CellArray[nHour][nDay].m_dwUserValue;
}

//****************************************************************************
//
//  CScheduleMatrix::GetUserDataPtr
//
//****************************************************************************
LPVOID CScheduleMatrix::GetUserDataPtr(UINT nHour, UINT nDay)
{
    UINT nDays = (m_nType == MT_DAILY ? 1 : 7);
    ASSERT(nHour < 24);
    ASSERT(nDay < nDays);

    return m_CellArray[nHour][nDay].m_pUserDataPtr;
}

//****************************************************************************
//
//  CScheduleMatrix::OnSetFocus
//
//****************************************************************************
void CScheduleMatrix::OnSetFocus(CWnd* pOldWnd)
{
    CWnd::OnSetFocus(pOldWnd);

    CDC *pdc = GetDC();
    CRect rSel(m_nSelHour, m_nSelDay, m_nSelHour+m_nNumSelHours, m_nSelDay+m_nNumSelDays);
    CellToClient(rSel.left, rSel.top);
    CellToClient(rSel.right, rSel.bottom);
    rSel.right+=1;
    rSel.bottom+=1;
    pdc->DrawFocusRect(rSel);
    ReleaseDC(pdc);
}

//****************************************************************************
//
//  CScheduleMatrix::OnKillFocus
//
//****************************************************************************
void CScheduleMatrix::OnKillFocus(CWnd* pNewWnd)
{
    CWnd::OnKillFocus(pNewWnd);

    CDC *pdc = GetDC();
    CRect rSel(m_nSelHour, m_nSelDay, m_nSelHour+m_nNumSelHours, m_nSelDay+m_nNumSelDays);
    CellToClient(rSel.left, rSel.top);
    CellToClient(rSel.right, rSel.bottom);
    rSel.right+=1;
    rSel.bottom+=1;
    pdc->DrawFocusRect(rSel);
    ReleaseDC(pdc);
}

//****************************************************************************
//
//  CScheduleMatrix::OnLButtonDown
//
//****************************************************************************
void CScheduleMatrix::OnLButtonDown(UINT nFlags, CPoint point)
{
    SetFocus();
    SetCapture();

    m_ptDown = point;
    m_ptFocus = point;
    m_ptFocus.x = max(m_ptFocus.x, m_rCellArray.left);
    m_ptFocus.y = max(m_ptFocus.y, m_rCellArray.top);
    m_ptFocus.x = min(m_ptFocus.x, m_rCellArray.right);
    m_ptFocus.y = min(m_ptFocus.y, m_rCellArray.bottom);
    m_nSaveHour = m_nSelHour;
    m_nSaveDay = m_nSelDay;
    m_nNumSaveHours = m_nNumSelHours;
    m_nNumSaveDays = m_nNumSelDays;

    CWnd::OnLButtonDown(nFlags, point);

    // Invalidate for "button selection" effect in the headers.
    if (m_rAllHeader.PtInRect(m_ptDown))
        InvalidateRect(m_rAllHeader, FALSE);
    if (m_rHourHeader.PtInRect(m_ptDown))
        InvalidateRect(m_rHourHeader, FALSE);
    if (m_rDayHeader.PtInRect(m_ptDown))
        InvalidateRect(m_rDayHeader, FALSE);

    OnMouseMove(nFlags, point);
}

//****************************************************************************
//
//  CScheduleMatrix::OnLButtonDblClk
//
//****************************************************************************
void CScheduleMatrix::OnLButtonDblClk(UINT nFlags, CPoint point)
{
    // Same as button down
    OnLButtonDown(nFlags, point);

    CWnd::OnLButtonDblClk(nFlags, point);
}

//****************************************************************************
//
//  CScheduleMatrix::OnLButtonUp
//
//****************************************************************************
void CScheduleMatrix::OnLButtonUp(UINT nFlags, CPoint point)
{
    if (GetCapture() == this)
    {
        m_ptFocus = point;
        m_ptFocus.x = max(m_ptFocus.x, m_rCellArray.left);
        m_ptFocus.y = max(m_ptFocus.y, m_rCellArray.top);
        m_ptFocus.x = min(m_ptFocus.x, m_rCellArray.right);
        m_ptFocus.y = min(m_ptFocus.y, m_rCellArray.bottom);

        ReleaseCapture();

        // If drawing the "button selection" effect in the headers, redraw.
        if (m_rAllHeader.PtInRect(m_ptDown))
            InvalidateRect(m_rAllHeader, FALSE);
        if (m_rHourHeader.PtInRect(m_ptDown))
            InvalidateRect(m_rHourHeader, FALSE);
        if (m_rDayHeader.PtInRect(m_ptDown))
            InvalidateRect(m_rDayHeader, FALSE);

        if (m_nSaveHour != m_nSelHour || m_nSaveDay != m_nSelDay ||
            m_nNumSaveHours != m_nNumSelHours || m_nNumSaveDays != m_nNumSelDays)
        {
            GetParent()->SendMessage(WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), MN_SELCHANGE),
                (LPARAM)GetSafeHwnd());
        }
    }

    CWnd::OnLButtonUp(nFlags, point);
}

//****************************************************************************
//
//  CScheduleMatrix::OnMouseMove
//
//****************************************************************************
void CScheduleMatrix::OnMouseMove(UINT nFlags, CPoint point)
{
    if (GetCapture() == this)
    {
        m_ptFocus = point;
        m_ptFocus.x = max(m_ptFocus.x, m_rCellArray.left);
        m_ptFocus.y = max(m_ptFocus.y, m_rCellArray.top);
        m_ptFocus.x = min(m_ptFocus.x, m_rCellArray.right);
        m_ptFocus.y = min(m_ptFocus.y, m_rCellArray.bottom);

        CRect rInvalid(0,0,0,0);
        CRect rSel(m_ptDown.x, m_ptDown.y, point.x, point.y);
        if (m_rDayHeader.PtInRect(m_ptDown))
        {
            rSel.right = m_rCellArray.right;
            rInvalid = m_rDayHeader;
        }

        if (m_rHourHeader.PtInRect(m_ptDown))
        {
            rSel.bottom = m_rCellArray.bottom;
            rInvalid = m_rHourHeader;
        }

        if (m_rAllHeader.PtInRect(m_ptDown))
        {
            rSel.right = m_rCellArray.right;
            rSel.bottom = m_rCellArray.bottom;
            rInvalid = m_rAllHeader;
        }
        ClientToCell(rSel.left, rSel.top);
        ClientToCell(rSel.right, rSel.bottom);
        rSel.NormalizeRect();
        rSel.right += 1;
        rSel.bottom += 1;
        rSel.right = min(rSel.right, 24);
        rSel.bottom = min(rSel.bottom, (m_nType == MT_DAILY ? 1 : 7));
        // If we've drifted out of the down area, reset selection
        CRect rDayHeader(m_rDayHeader);
        CRect rHourHeader(m_rHourHeader);
        CRect rAllHeader(m_rAllHeader);
        CRect rCellArray(m_rCellArray);
        int nBuffer = GetSystemMetrics(SM_CXVSCROLL);
        rDayHeader.InflateRect(nBuffer,nBuffer);
        rHourHeader.InflateRect(nBuffer,nBuffer);
        rAllHeader.InflateRect(nBuffer,nBuffer);
        rCellArray.InflateRect(nBuffer,nBuffer);
        if ((m_rDayHeader.PtInRect(m_ptDown) && !rDayHeader.PtInRect(point)) ||
            (m_rHourHeader.PtInRect(m_ptDown) && !rHourHeader.PtInRect(point)) ||
            (m_rAllHeader.PtInRect(m_ptDown) && !rAllHeader.PtInRect(point)) ||
            (m_rCellArray.PtInRect(m_ptDown) && !rCellArray.PtInRect(point)))
            rSel.SetRect(m_nSaveHour, m_nSaveDay, m_nSaveHour+m_nNumSaveHours,
                m_nSaveDay+m_nNumSaveDays);

        if (SetSelValues(rSel.left, rSel.top, rSel.Width(), rSel.Height()))
            InvalidateRect(rInvalid);
    }

    CWnd::OnMouseMove(nFlags, point);
}

//****************************************************************************
//
//  CScheduleMatrix::OnGetDlgCode
//
//****************************************************************************
UINT CScheduleMatrix::OnGetDlgCode()
{
    return (DLGC_WANTCHARS | DLGC_WANTARROWS);
}

//****************************************************************************
//
//  CScheduleMatrix::OnKeyDown
//
//****************************************************************************
void CScheduleMatrix::OnKeyDown(UINT nChar, UINT /*nRepCnt*/, UINT /*nFlags*/)
{
//    BOOL bShifted = 0x8000 & GetKeyState(VK_SHIFT);

    CPoint ptCell, ptOldCell, ptClient;
    ptCell = m_ptFocus;
    ClientToCell(ptCell.x, ptCell.y);
    ptOldCell = ptCell;

    BOOL bToggle = FALSE;

    switch (nChar)
    {
        case VK_SHIFT:
            m_bShifted = TRUE;
            break;;
        case VK_SPACE:
            bToggle = TRUE;
            break;
        case VK_LEFT:
            ptCell.x -= 1;
            break;
        case VK_RIGHT:
            ptCell.x += 1;
            break;
        case VK_UP:
            ptCell.y -= 1;
            break;
        case VK_DOWN:
            ptCell.y += 1;
            break;
        case VK_PRIOR:
            ptCell.y = -1;
            break;
        case VK_NEXT:
            ptCell.y = 6;
            break;
        case VK_HOME:
            ptCell.x = -1;
            ptCell.y = -1;
            break;
        case VK_END:
            ptCell.x = 23;
            ptCell.y = 6;
            break;
    }

    // Restrict keyboard control to the matrix...
    ptCell.x = max(0, ptCell.x);
    ptCell.x = min(23, ptCell.x);
    ptCell.y = max(0, ptCell.y);
    ptCell.y = min((m_nType == MT_DAILY ? 0 : 6), ptCell.y);

    ptClient = ptCell;
    CellToClient(ptClient.x, ptClient.y);

    if (bToggle)
    {
        OnLButtonDown(MK_LBUTTON, ptClient);
        OnLButtonUp(MK_LBUTTON, ptClient);
/*
        if (bShifted)
            Extend(ptClient);
        else
        {
            Press(ptClient, FALSE);
            Release(ptClient);
        }

        ptFocus = ptClient;
*/
    }
    else if (ptCell != ptOldCell)
    {
        if (m_bShifted)
        {
//            Extend(ptClient);
            if (GetCapture() != this)
            {
                CPoint ptOldClient(ptOldCell);
                CellToClient(ptOldClient.x, ptOldClient.y);
                OnLButtonDown(MK_LBUTTON, ptOldClient);
            }
            OnMouseMove(MK_LBUTTON, ptClient);
        }
        else
        {
            OnLButtonDown(MK_LBUTTON, ptClient);
            OnLButtonUp(MK_LBUTTON, ptClient);
        }
/*
        if (bFocus)
            DrawFocus(FALSE, ptFocus, NULL);
        ptFocus = ptClient;
        if (bFocus)
            DrawFocus(TRUE, ptFocus, NULL);
*/
    }
}

//****************************************************************************
//
//  CScheduleMatrix::OnKeyUp
//
//****************************************************************************
void CScheduleMatrix::OnKeyUp(UINT nChar, UINT /*nRepCnt*/, UINT /*nFlags*/)
{
    switch (nChar)
    {
        case VK_SHIFT:
            m_bShifted = FALSE;
            OnLButtonUp(MK_LBUTTON, m_ptFocus);
            break;
        case VK_SPACE:
        case VK_LEFT:
        case VK_RIGHT:
        case VK_UP:
        case VK_DOWN:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_HOME:
        case VK_END:
//            Release(ptFocus);
            break;
    }
}

//****************************************************************************
//
//  CScheduleMatrix::InvalidateCells
//
//****************************************************************************
void CScheduleMatrix::InvalidateCells(UINT nHour, UINT nDay, UINT nNumHours, UINT nNumDays,
    BOOL bErase)
{
    CRect r(nHour, nDay, nHour+nNumHours, nDay+nNumDays);
    CellToClient(r.left, r.top);
    CellToClient(r.right, r.bottom);
    r.right += 1;
    r.bottom += 1;

    InvalidateRect(r, bErase);
}

//****************************************************************************
//
//  CScheduleMatrix::OnGetObject
//
//****************************************************************************
LRESULT CScheduleMatrix::OnGetObject (WPARAM wParam, LPARAM lParam)
{
    if ( lParam == OBJID_CLIENT )
    {
        // At this point we will try to load oleacc and get the functions
        // we need.
        if (!g_fAttemptedOleAccLoad)
        {
            g_fAttemptedOleAccLoad = TRUE;

            ASSERT (0 == s_pfnCreateStdAccessibleObject);
            ASSERT(s_pfnCreateStdAccessibleProxy == NULL);
            ASSERT(s_pfnLresultFromObject == NULL);

            g_hOleAcc = LoadLibrary (L"OLEACC");
            if (g_hOleAcc != NULL)
            {
                s_pfnCreateStdAccessibleObject = (PFNCREATESTDACCESSIBLEOBJECT)
                        GetProcAddress(g_hOleAcc, "CreateStdAccessibleObject");
                s_pfnCreateStdAccessibleProxy = (PFNCREATESTDACCESSIBLEPROXY)
                        GetProcAddress(g_hOleAcc, "CreateStdAccessibleProxyW");
                s_pfnLresultFromObject = (PFNLRESULTFROMOBJECT)
                        GetProcAddress(g_hOleAcc, "LresultFromObject");
            }
            if (s_pfnLresultFromObject == NULL || 
                    s_pfnCreateStdAccessibleProxy == NULL ||
                    0 == s_pfnCreateStdAccessibleObject)
            {
                if (g_hOleAcc)
                {
                    // No point holding on to Oleacc since we can't use it.
                    FreeLibrary(g_hOleAcc);
                    g_hOleAcc = NULL;
                }
                s_pfnLresultFromObject = NULL;
                s_pfnCreateStdAccessibleProxy = NULL;
                s_pfnCreateStdAccessibleObject = 0;
            }
        }


        if (g_hOleAcc && 
                s_pfnCreateStdAccessibleProxy && 
                s_pfnLresultFromObject && 
                s_pfnCreateStdAccessibleObject)
        {
            IAccessible*    pAcc = NULL;
            const int       CLASS_NAME_LEN = 64;
            WCHAR           szClassName[CLASS_NAME_LEN];
            int nRet = ::GetClassName(m_hWnd, szClassName, CLASS_NAME_LEN);
            if ( !nRet )
            {
                DWORD   dwErr = GetLastError ();
                
                dwErr = dwErr;
            }

            // Create default proxy.
            HRESULT hr = s_pfnCreateStdAccessibleObject (
                    m_hWnd,
                    OBJID_CLIENT,
                    IID_PPV_ARG (IAccessible, &pAcc));
            if (SUCCEEDED(hr) && pAcc)
            {
                // now wrap it up in our customized wrapper...
                IAccessible * pWrapAcc = new CAccessibleWrapper (m_hWnd, pAcc);
                // Release our ref to proxy (wrapper has its own addref'd ptr)...
                pAcc->Release();

                if (pWrapAcc != NULL)
                {

                    // ...and return the wrapper via LresultFromObject...
                    LRESULT lr = s_pfnLresultFromObject (IID_IAccessible, wParam, pWrapAcc);
                    // Release our interface pointer - OLEACC has its own addref to the object
                    pWrapAcc->Release();

                    // Return the lresult, which 'contains' a reference to our wrapper object.
                    return lr;
                    // All done!
                }
            // If it didn't work, fall through to default behavior instead.
            }
        }
    }

    return 0;
}

//****************************************************************************
//
//  CScheduleMatrix::OnGetSelDescription
//
//  wParam - length of passed in string buffer
//  lParam - wide-char string buffer
//
//****************************************************************************
LRESULT CScheduleMatrix::OnGetSelDescription (WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    PWSTR   pszDescription = (PWSTR) lParam;
    if ( pszDescription )
    {
        UINT    nMaxLen = (UINT) wParam;
        CString szDescription;
        GetSelDescription (szDescription);

        wcsncpy (pszDescription, szDescription, nMaxLen);
    }
    else
        lResult = -1;

    return lResult;
}

//****************************************************************************
//
//  CScheduleMatrix::OnGetPercentage
//
//  wParam - return % of selected cell
//  lParam - unused
//
//****************************************************************************
LRESULT CScheduleMatrix::OnGetPercentage (WPARAM /*wParam*/, LPARAM /*lParam*/)
{
    LRESULT lResult = 0;
    if ( 1 == m_nNumSelHours && 1 == m_nNumSelDays )
        lResult = GetPercentage (m_nSelHour, m_nSelDay);
    else
        lResult = -1;

    return lResult;
}


/////////////////////////////////////////////////////////////////////////////
// CHourLegend

IMPLEMENT_DYNAMIC(CHourLegend, CWnd)

//****************************************************************************
//
//  CHourLegend::CHourLegend
//
//****************************************************************************
CHourLegend::CHourLegend()
{
    m_hiconSun = m_hiconMoon = NULL;

    m_hFont = NULL;
}

//****************************************************************************
//
//  CHourLegend::~CHourLegend
//
//****************************************************************************
CHourLegend::~CHourLegend()
{
    if ( m_hiconMoon )
    {
        DestroyIcon (m_hiconMoon);
        m_hiconMoon = 0;
    }
    if ( m_hiconSun )
    {
        DestroyIcon (m_hiconSun);
        m_hiconSun = 0;
    }
}


BEGIN_MESSAGE_MAP(CHourLegend, CWnd)
	//{{AFX_MSG_MAP(CHourLegend)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHourLegend message handlers

//****************************************************************************
//
//  CHourLegend::OnPaint
//
//****************************************************************************
void CHourLegend::OnPaint()
{
    CRect rClient;

	CPaintDC dc(this); // device context for painting
	
    CFont *pOldFont = NULL;
    CFont *pFont = CFont::FromHandle(m_hFont);

    if (pFont != NULL)
        pOldFont = dc.SelectObject(pFont);

    CBrush brFace(::GetSysColor(COLOR_3DFACE));

    CBrush *pbrOld = dc.SelectObject(&brFace);

    GetClientRect(rClient);

    // Draw the hour legend

    if (m_hiconSun == NULL)
        m_hiconSun = (HICON)::LoadImage(AfxFindResourceHandle(_T("SUN16"), RT_GROUP_ICON),
            _T("SUN16"), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
    if (m_hiconMoon == NULL)
        m_hiconMoon = (HICON)::LoadImage(AfxFindResourceHandle(_T("MOON16"), RT_GROUP_ICON),
            _T("MOON16"), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
    dc.FillRect(rClient, &brFace);
    ::DrawIconEx(dc.GetSafeHdc(),m_rLegend.left-8,rClient.bottom - m_nCharHeight - 16 - 2,
        (HICON)m_hiconMoon,0,0,0,NULL,DI_NORMAL);
    ::DrawIconEx(dc.GetSafeHdc(),m_rLegend.left + m_rLegend.Width()/2 - 8,
        rClient.bottom - m_nCharHeight - 16 - 2,(HICON)m_hiconSun,0,0,0,NULL,DI_NORMAL);
    ::DrawIconEx(dc.GetSafeHdc(),m_rLegend.right-8,rClient.bottom - m_nCharHeight - 16 - 2,
        (HICON)m_hiconMoon,0,0,0,NULL,DI_NORMAL);

    // Draw the hour text

    COLORREF crBkOld = dc.GetBkColor();
    COLORREF crTextOld = dc.GetTextColor();
    COLORREF crText = ::GetSysColor(COLOR_BTNTEXT);
    COLORREF crFace = ::GetSysColor(COLOR_3DFACE);
    dc.SetBkColor(crFace);
    dc.SetTextColor(crText);

    int i, hr;
    CRect rText, rBullet;
    CString sHour;
    rText.SetRect(m_rLegend.left-m_nCharWidth, rClient.bottom - m_nCharHeight - 2,
        m_rLegend.left + m_nCharWidth, rClient.bottom - 2);
    rBullet.SetRect(m_rLegend.left + m_nCellWidth - 1, rClient.bottom - 2 - rText.Height()/2 - 1,
        m_rLegend.left + m_nCellWidth + 1, rClient.bottom - 2 - rText.Height()/2 + 1);


    bool    bIs24HourClock = false;
    CString sFormat;
    int     iLen = ::GetLocaleInfo(
                LOCALE_USER_DEFAULT,      // locale identifier
                LOCALE_ITIME,    // type of information
                0,  // address of buffer for information
                0);  // size of buffer
	ASSERT (iLen > 0);
	if ( iLen > 0 )
	{
        int iResult = ::GetLocaleInfo(
                LOCALE_USER_DEFAULT,      // locale identifier
                LOCALE_ITIME,    // type of information
                sFormat.GetBufferSetLength (iLen),  // address of buffer for information
                iLen);  // size of buffer
		ASSERT (iResult);
		sFormat.ReleaseBuffer ();
        if ( sFormat == _TEXT("1") )
            bIs24HourClock = true;
    } 

    if ( bIs24HourClock )
        hr = 0;
    else
        hr = 12;
    for (i=0; i<=24; i+=2)
    {
        if ( bIs24HourClock )
        {
            if ( 24 == hr )
                hr = 0;
        }
        else if (hr > 12)
            hr = 2;
        sHour.Format(_T("%d"), hr);
        dc.SetBkColor(crFace);  //?? FillSolidRect seems to set BkColor
        ::DrawTextEx(dc.GetSafeHdc(), (LPTSTR)(LPCTSTR)sHour, -1, rText,
            DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_END_ELLIPSIS, NULL);
        dc.FillSolidRect(rBullet, crText); //?? FillSolidRect seems to set BkColor
        hr += 2;
        rText.OffsetRect(2*m_nCellWidth, 0);
        if (i < 24)
            rBullet.OffsetRect(2*m_nCellWidth, 0);
    }

    dc.SetBkColor(crBkOld);
    dc.SetTextColor(crTextOld);

    if (pbrOld != NULL)
        dc.SelectObject(pbrOld);
	
    if (pOldFont != NULL)
        dc.SelectObject(pOldFont);

	// Do not call CWnd::OnPaint() for painting messages
}

/////////////////////////////////////////////////////////////////////////////
// CPercentLabel

IMPLEMENT_DYNAMIC(CPercentLabel, CWnd)

//****************************************************************************
//
//  CPercentLabel::CPercentLabel
//
//****************************************************************************
CPercentLabel::CPercentLabel()
{
    m_pMatrix = NULL;
    m_hFont = NULL;
}

//****************************************************************************
//
//  CPercentLabel::~CPercentLabel
//
//****************************************************************************
CPercentLabel::~CPercentLabel()
{
}


BEGIN_MESSAGE_MAP(CPercentLabel, CWnd)
	//{{AFX_MSG_MAP(CPercentLabel)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPercentLabel message handlers

//****************************************************************************
//
//  CPercentLabel::OnPaint
//
//****************************************************************************
void CPercentLabel::OnPaint()
{
    CRect rClient;

	CPaintDC dc(this); // device context for painting
	
    CFont *pOldFont = NULL;
    CFont *pFont = CFont::FromHandle(m_hFont);

    if (pFont != NULL)
        pOldFont = dc.SelectObject(pFont);

    CBrush brFace(::GetSysColor(COLOR_3DFACE));

    CBrush *pbrOld = dc.SelectObject(&brFace);

    GetClientRect(rClient);

    COLORREF crBkOld = dc.GetBkColor();
    COLORREF crTextOld = dc.GetTextColor();
    COLORREF crText = ::GetSysColor(COLOR_BTNTEXT);
    COLORREF crFace = ::GetSysColor(COLOR_3DFACE);
    dc.SetBkColor(crFace);
    dc.SetTextColor(crText);

    // Draw the header label

    CString sText(_T("%"));
    ::DrawTextEx(dc.GetSafeHdc(), (LPTSTR)(LPCTSTR)sText, -1, m_rHeader,
        DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_END_ELLIPSIS, NULL);

    // Draw the percent label text

    int i;
    UINT nPercent;
    CRect rText, rBullet;
    rText.SetRect(m_rLabels.left, 0, m_rLabels.left + m_nCellWidth, rClient.bottom);
    for (i=0; i<24; i++)
    {
        nPercent = m_pMatrix->GetPercentage(i,0);
        // Don't draw percentages greater than 99
        if (nPercent <= 99)
        {
            sText.Format(_T("%d"), nPercent);
            ::DrawTextEx(dc.GetSafeHdc(), (LPTSTR)(LPCTSTR)sText, -1, rText,
                DT_SINGLELINE | DT_CENTER | DT_VCENTER | DT_END_ELLIPSIS, NULL);
        }
        rText.OffsetRect(m_nCellWidth, 0);
    }

    dc.SetBkColor(crBkOld);
    dc.SetTextColor(crTextOld);

    if (pbrOld != NULL)
        dc.SelectObject(pbrOld);
	
    if (pOldFont != NULL)
        dc.SelectObject(pOldFont);

	// Do not call CWnd::OnPaint() for painting messages
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\cdlink.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       cdlink.cxx
//
//  Contents:
//
//  Classes:    CDlink
//
//  History:    16-Oct-91  KevinRo Created
//
//--------------------------------------------------------------------------

#include "pch.h"

//+-------------------------------------------------------------------------
//
// Member:      CDLink::LinkAfter
//
// Purpose:     Links this after dlPrev and before dlPrev->_dlNext
//
// Returns:     this
//
// Note:        None.
//
//--------------------------------------------------------------------------
VOID CDLink::LinkAfter(CDLink * dlPrev)
{
    _dlPrev = dlPrev;

    if(dlPrev != NULL)
    {
        _dlNext = dlPrev->_dlNext;
        dlPrev->_dlNext = this;

        if(_dlNext != NULL) {
            _dlNext->_dlPrev = this;
        }
    }
    else
    {
        _dlNext = NULL;
    }
}
//+-------------------------------------------------------------------------
//
// Member:      CDLink::LinkBefore
//
// Purpose:     Links this Before dlNext and after dlNext->_dlPrev
//
// Returns:     this
//
//--------------------------------------------------------------------------
VOID CDLink::LinkBefore(CDLink * dlNext)
{
    _dlNext = dlNext;

    if(dlNext != NULL)
    {
        _dlPrev = dlNext->_dlPrev;

        dlNext->_dlPrev = this;

        if(_dlPrev != NULL) {
            _dlPrev->_dlNext = this;
        }
    }
    else
    {
        _dlPrev = NULL;
    }
}

//+-------------------------------------------------------------------------
//
// Member:      CDLink::Unlink()
//
// Purpose:     Removes this from double linked list
//
// Returns:     this
//
//--------------------------------------------------------------------------
VOID CDLink::UnLink()
{
    if(_dlNext != NULL) {
        _dlNext->_dlPrev = _dlPrev;
    }
    if(_dlPrev != NULL) {
        _dlPrev->_dlNext = _dlNext;
    }
    _dlNext = _dlPrev = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\cstr.cpp ===
// This is copied from the Microsoft Foundation Classes C++ library.
// Copyright (C) Microsoft Corporation, 1992 - 1999
// All rights reserved.
//
// This has been modified from the original MFC version to provide
// two classes: CStrW manipulates and stores only wide char strings,
// and CStr uses TCHARs.
// 

#include "pch.h"
#include "proppage.h"
#if !defined(UNICODE)
#include <stdio.h>
#endif
#include "cstr.h"

#if !defined(_wcsinc)
#define _wcsinc(_pc) ((_pc)+1)
#endif

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// For an empty string, m_???Data will point here
// (note: avoids a lot of NULL pointer tests when we call standard
//  C runtime libraries
TCHAR strChNilT = '\0';

// for creating empty key strings
const CStr strEmptyStringT;

void CStr::Init()
{
        m_nDataLength = m_nAllocLength = 0;
        m_pchData = (LPTSTR)&strChNilT;
}

// declared static
void CStr::SafeDelete(LPTSTR& lpch)
{
        if (lpch != (LPTSTR)&strChNilT &&
            lpch)
        {
                delete[] lpch;
                lpch = 0;
        }
}

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CStr::CStr()
{
        Init();
}

CStr::CStr(const CStr& stringSrc)
{
        // if constructing a String from another String, we make a copy of the
        // original string data to enforce value semantics (i.e. each string
        // gets a copy of its own

        m_pchData = 0;

        stringSrc.AllocCopy(*this, stringSrc.m_nDataLength, 0, 0);
}

BOOL CStr::AllocBuffer(int nLen)
 // always allocate one extra character for '\0' termination
 // assumes [optimistically] that data length will equal allocation length
{
        dspAssert(nLen >= 0);

        if (nLen == 0)
        {
                Init();
        }
        else
        {
                m_pchData = new TCHAR[nLen+1];       //REVIEW may throw an exception
        if (!m_pchData)
        {
            Empty();
            return FALSE;
        }
                m_pchData[nLen] = '\0';
                m_nDataLength = nLen;
                m_nAllocLength = nLen;
        }
    return TRUE;
}

void CStr::Empty()
{
        SafeDelete(m_pchData);
        Init();
        dspAssert(m_nDataLength == 0);
        dspAssert(m_nAllocLength == 0);
}

CStr::~CStr()
 //  free any attached data
{
        SafeDelete(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

static inline int SafeStrlenT(LPCTSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        return (lpsz == NULL) ? 0 : lstrlen(lpsz);
}

void CStr::AllocCopy(CStr& dest, int nCopyLen, int nCopyIndex,
         int nExtraLen) const
{
        // will clone the data attached to this string
        // allocating 'nExtraLen' characters
        // Places results in uninitialized string 'dest'
        // Will copy the part or all of original data to start of new string

        int nNewLen = nCopyLen + nExtraLen;

        if (nNewLen == 0)
        {
        dest.SafeDelete(dest.m_pchData);
                dest.Init();
        }
        else
        {
                if (!dest.AllocBuffer(nNewLen)) return;
            memcpy(dest.m_pchData, &m_pchData[nCopyIndex], nCopyLen*sizeof(TCHAR));
        }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStr::CStr(LPCTSTR lpsz)
{
                int nLen;
                if ((nLen = SafeStrlenT(lpsz)) == 0)
                        Init();
                else
                {
                        if (!AllocBuffer(nLen))
            {
                Init();
                return;
            }
                    memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
                }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef UNICODE
CStr::CStr(LPCSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
        if (nSrcLen == 0)
                Init();
        else
        {
                if (!AllocBuffer(nSrcLen))
        {
            Init();
            return;
        }
            mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        }
}
#else //UNICODE
CStr::CStr(LPCWSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
        if (nSrcLen == 0)
                Init();
        else
        {
                if (!AllocBuffer(nSrcLen*2))
        {
            Init();
            return;
        }
            mmc_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
                ReleaseBuffer();
        }
}
#endif //!UNICODE


//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CStr&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CStr::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
        // check if it will fit
        if (nSrcLen > m_nAllocLength)
        {
                // it won't fit, allocate another one
                Empty();
                if (!AllocBuffer(nSrcLen)) return;
        }
        if (nSrcLen != 0)
                memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
        m_nDataLength = nSrcLen;
        m_pchData[nSrcLen] = '\0';
}

const CStr& CStr::operator=(const CStr& stringSrc)
{
        AssignCopy(stringSrc.m_nDataLength, stringSrc.m_pchData);
        return *this;
}

const CStr& CStr::operator=(LPCTSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        AssignCopy(SafeStrlenT(lpsz), lpsz);
        return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef UNICODE
const CStr& CStr::operator=(LPCSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
        // check if it will fit
        if (nSrcLen > m_nAllocLength)
        {
                // it won't fit, allocate another one
                Empty();
                if (!AllocBuffer(nSrcLen)) return *this;
        }
        if (nSrcLen != 0)
                mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        m_nDataLength = nSrcLen;
        m_pchData[nSrcLen] = '\0';
        return *this;
}
#else //!UNICODE
const CStr& CStr::operator=(LPCWSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
        nSrcLen *= 2;
        // check if it will fit
        if (nSrcLen > m_nAllocLength)
        {
                // it won't fit, allocate another one
                Empty();
                if (!AllocBuffer(nSrcLen)) return *this;
        }
        if (nSrcLen != 0)
        {
                mmc_wcstombsz(m_pchData, lpsz, nSrcLen+1);
                ReleaseBuffer();
        }
        return *this;
}
#endif  //!UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          String + String
// and for ? = TCHAR, LPCTSTR
//          String + ?
//          ? + String

void CStr::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
        int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new String object

        int nNewLen = nSrc1Len + nSrc2Len;
        if (!AllocBuffer(nNewLen)) return;
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
        memcpy(&m_pchData[nSrc1Len], lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
}

CStr STRAPI operator+(const CStr& string1, const CStr& string2)
{
        CStr s;
        s.ConcatCopy(string1.m_nDataLength, string1.m_pchData,
                string2.m_nDataLength, string2.m_pchData);
        return s;
}

CStr STRAPI operator+(const CStr& string, LPCTSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        CStr s;
        s.ConcatCopy(string.m_nDataLength, string.m_pchData, SafeStrlenT(lpsz), lpsz);
        return s;
}

CStr STRAPI operator+(LPCTSTR lpsz, const CStr& string)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        CStr s;
        s.ConcatCopy(SafeStrlenT(lpsz), lpsz, string.m_nDataLength, string.m_pchData);
        return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CStr::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
        //  -- the main routine for += operators

        // if the buffer is too small, or we have a width mis-match, just
        //   allocate a new buffer (slow but sure)
        if (m_nDataLength + nSrcLen > m_nAllocLength)
        {
                // we have to grow the buffer, use the Concat in place routine
                LPTSTR lpszOldData = m_pchData;
                ConcatCopy(m_nDataLength, lpszOldData, nSrcLen, lpszSrcData);
                dspAssert(lpszOldData != NULL);
                SafeDelete(lpszOldData);
        }
        else
        {
                // fast concatenation when buffer big enough
                memcpy(&m_pchData[m_nDataLength], lpszSrcData, nSrcLen*sizeof(TCHAR));
                m_nDataLength += nSrcLen;
        }
        dspAssert(m_nDataLength <= m_nAllocLength);
        m_pchData[m_nDataLength] = '\0';
}

const CStr& CStr::operator+=(LPCTSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        ConcatInPlace(SafeStrlenT(lpsz), lpsz);
        return *this;
}

const CStr& CStr::operator+=(TCHAR ch)
{
        ConcatInPlace(1, &ch);
        return *this;
}

const CStr& CStr::operator+=(const CStr& string)
{
        ConcatInPlace(string.m_nDataLength, string.m_pchData);
        return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CStr::GetBuffer(int nMinBufLength)
{
        dspAssert(nMinBufLength >= 0);

        if (nMinBufLength > m_nAllocLength)
        {
                // we have to grow the buffer
                LPTSTR lpszOldData = m_pchData;
                int nOldLen = m_nDataLength;        // AllocBuffer will tromp it

                if (!AllocBuffer(nMinBufLength)) return NULL;
                memcpy(m_pchData, lpszOldData, nOldLen*sizeof(TCHAR));
                m_nDataLength = nOldLen;
                m_pchData[m_nDataLength] = '\0';

                SafeDelete(lpszOldData);
        }

        // return a pointer to the character storage for this string
        dspAssert(m_pchData != NULL);
        return m_pchData;
}

void CStr::ReleaseBuffer(int nNewLength)
{
        if (nNewLength == -1)
                nNewLength = lstrlen(m_pchData); // zero terminated

        dspAssert(nNewLength <= m_nAllocLength);
        m_nDataLength = nNewLength;
        m_pchData[m_nDataLength] = '\0';
}

LPTSTR CStr::GetBufferSetLength(int nNewLength)
{
        dspAssert(nNewLength >= 0);

        GetBuffer(nNewLength);
        m_nDataLength = nNewLength;
        m_pchData[m_nDataLength] = '\0';
        return m_pchData;
}

void CStr::FreeExtra()
{
        dspAssert(m_nDataLength <= m_nAllocLength);
        if (m_nDataLength != m_nAllocLength)
        {
                LPTSTR lpszOldData = m_pchData;
                if (!AllocBuffer(m_nDataLength)) return;
                memcpy(m_pchData, lpszOldData, m_nDataLength*sizeof(TCHAR));
                dspAssert(m_pchData[m_nDataLength] == '\0');
                SafeDelete(lpszOldData);
        }
        dspAssert(m_pchData != NULL);
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CStr::Find(TCHAR ch) const
{
        // find first single character
        LPTSTR lpsz = _tcschr(m_pchData, ch);

        // return -1 if not found and index otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CStr::FindOneOf(LPCTSTR lpszCharSet) const
{
        dspAssert(IsValidString(lpszCharSet, FALSE));
        LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

///////////////////////////////////////////////////////////////////////////////
// String conversion helpers (these use the current system locale)

int mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
        if (count == 0 && mbstr != NULL)
                return 0;

        int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
                mbstr, static_cast<int>(count), NULL, NULL);
        dspAssert(mbstr == NULL || result <= (int)count);
        if (result > 0)
                mbstr[result-1] = 0;
        return result;
}

int mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
        if (count == 0 && wcstr != NULL)
                return 0;

        int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
                wcstr, static_cast<int>(count));
        dspAssert(wcstr == NULL || result <= (int)count);
        if (result > 0)
                wcstr[result-1] = 0;
        return result;
}


/////////////////////////////////////////////////////////////////////////////
// Windows extensions to strings

BOOL CStr::LoadString(HINSTANCE hInst, UINT nID)
{
        dspAssert(nID != 0);       // 0 is an illegal string ID

        // Note: resource strings limited to 511 characters
        TCHAR szBuffer[512];
        UINT nSize = StrLoadString(hInst, nID, szBuffer);
        AssignCopy(nSize, szBuffer);
        return nSize > 0;
}


int STRAPI StrLoadString(HINSTANCE hInst, UINT nID, LPTSTR lpszBuf)
{
        dspAssert(IsValidAddressz(lpszBuf, 512));  // must be big enough for 512 bytes
#ifdef DBG
        // LoadString without annoying warning from the Debug kernel if the
        //  segment containing the string is not present
        if (::FindResource(hInst, MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
        {
                lpszBuf[0] = '\0';
                return 0; // not found
        }
#endif //DBG
        int nLen = ::LoadString(hInst, nID, lpszBuf, 511);
    dspAssert(nLen);
        if (nLen == 0)
                lpszBuf[0] = '\0';
        return nLen;
}

BOOL STRAPI IsValidAddressz(const void* lp, UINT nBytes, BOOL bReadWrite)
{
        // simple version using Win-32 APIs for pointer validation.
        return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
                (!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}


BOOL STRAPI IsValidString(LPCSTR lpsz, int nLength)
{
        if (lpsz == NULL)
                return FALSE;
        return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL STRAPI IsValidString(LPCWSTR lpsz, int nLength)
{
        if (lpsz == NULL)
                return FALSE;

        return ::IsBadStringPtrW(lpsz, nLength) == 0;
}


#ifdef OLE_AUTOMATION
#ifdef  UNICODE
BSTR CStr::AllocSysString()
{
        BSTR bstr = ::SysAllocStringLen(m_pchData, m_nDataLength);
        if (bstr == NULL)
                ;//REVIEW AfxThrowMemoryException();

        return bstr;
}

BSTR CStr::SetSysString(BSTR* pbstr)
{
        dspAssert(IsValidAddressz(pbstr, sizeof(BSTR)));

        if (!::SysReAllocStringLen(pbstr, m_pchData, m_nDataLength))
                ; //REVIEW AfxThrowMemoryException();

        dspAssert(*pbstr != NULL);
        return *pbstr;
}
#endif
#endif // #ifdef OLE_AUTOMATION


///////////////////////////////////////////////////////////////////////////////
// Orginally from StrEx.cpp 


CStr::CStr(TCHAR ch, int nLength)
{
#ifndef UNICODE
        dspAssert(!IsDBCSLeadByte(ch));    // can't create a lead byte string
#endif
        if (nLength < 1)
        {
                // return empty string if invalid repeat count
                Init();
        }
        else
        {
                if (!AllocBuffer(nLength))
        {
            Init();
            return;
        }
#ifdef UNICODE
                for (int i = 0; i < nLength; i++)
                        m_pchData[i] = ch;
#else
                memset(m_pchData, ch, nLength);
#endif
        }
}

CStr::CStr(LPCTSTR lpch, int nLength)
{
        if (nLength == 0)
                Init();
        else
        {
                dspAssert(IsValidAddressz(lpch, nLength, FALSE));
                if (!AllocBuffer(nLength))
        {
            Init();
            return;
        }
            memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
        }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CStr& CStr::operator=(TCHAR ch)
{
#ifndef UNICODE
        dspAssert(!IsDBCSLeadByte(ch));    // can't set single lead byte
#endif
        AssignCopy(1, &ch);
        return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CStr STRAPI operator+(const CStr& string1, TCHAR ch)
{
        CStr s;
        s.ConcatCopy(string1.m_nDataLength, string1.m_pchData, 1, &ch);
        return s;
}

CStr STRAPI operator+(TCHAR ch, const CStr& string)
{
        CStr s;
        s.ConcatCopy(1, &ch, string.m_nDataLength, string.m_pchData);
        return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CStr CStr::Mid(int nFirst) const
{
        return Mid(nFirst, m_nDataLength - nFirst);
}

CStr CStr::Mid(int nFirst, int nCount) const
{
        dspAssert(nFirst >= 0);
        dspAssert(nCount >= 0);

        // out-of-bounds requests return sensible things
        if (nFirst + nCount > m_nDataLength)
                nCount = m_nDataLength - nFirst;
        if (nFirst > m_nDataLength)
                nCount = 0;

        CStr dest;
        AllocCopy(dest, nCount, nFirst, 0);
        return dest;
}

CStr CStr::Right(int nCount) const
{
        dspAssert(nCount >= 0);

        if (nCount > m_nDataLength)
                nCount = m_nDataLength;

        CStr dest;
        AllocCopy(dest, nCount, m_nDataLength-nCount, 0);
        return dest;
}

CStr CStr::Left(int nCount) const
{
        dspAssert(nCount >= 0);

        if (nCount > m_nDataLength)
                nCount = m_nDataLength;

        CStr dest;
        AllocCopy(dest, nCount, 0, 0);
        return dest;
}

// strspn equivalent
CStr CStr::SpanIncluding(LPCTSTR lpszCharSet) const
{
        dspAssert(IsValidString(lpszCharSet, FALSE));
        return Left(static_cast<int>(_tcsspn(m_pchData, lpszCharSet)));
}

// strcspn equivalent
CStr CStr::SpanExcluding(LPCTSTR lpszCharSet) const
{
        dspAssert(IsValidString(lpszCharSet, FALSE));
        return Left(static_cast<int>(_tcscspn(m_pchData, lpszCharSet)));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CStr::ReverseFind(TCHAR ch) const
{
        // find last single character
        LPTSTR lpsz = _tcsrchr(m_pchData, ch);

        // return -1 if not found, distance from beginning otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CStr::Find(LPCTSTR lpszSub) const
{
        dspAssert(IsValidString(lpszSub, FALSE));

        // find first matching substring
        LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

        // return -1 for not found, distance from beginning otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// String formatting

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

// formatting (using wsprintf style formatting)
void CStr::Format(LPCTSTR lpszFormat, ...)
{
        dspAssert(IsValidString(lpszFormat, FALSE));

        va_list argList;
        va_start(argList, lpszFormat);

        // make a guess at the maximum length of the resulting string
        size_t nMaxLen = 0;
        for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
        {
                // handle '%' character, but watch out for '%%'
                if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
                {
                        nMaxLen += _tclen(lpsz);
                        continue;
                }

                size_t nItemLen = 0;

                // handle '%' character with format
                int nWidth = 0;
                for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
                {
                        // check for valid flags
                        if (*lpsz == '#')
                                nMaxLen += 2;   // for '0x'
                        else if (*lpsz == '*')
                                nWidth = va_arg(argList, int);
                        else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                                *lpsz == ' ')
                                ;
                        else // hit non-flag character
                                break;
                }
                // get width and skip it
                if (nWidth == 0)
                {
                        // width indicated by
                        nWidth = _ttoi(lpsz);
                        for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                                ;
                }
                dspAssert(nWidth >= 0);

                int nPrecision = 0;
                if (*lpsz == '.')
                {
                        // skip past '.' separator (width.precision)
                        lpsz = _tcsinc(lpsz);

                        // get precision and skip it
                        if (*lpsz == '*')
                        {
                                nPrecision = va_arg(argList, int);
                                lpsz = _tcsinc(lpsz);
                        }
                        else
                        {
                                nPrecision = _ttoi(lpsz);
                                for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
                                        ;
                        }
                        dspAssert(nPrecision >= 0);
                }

                // should be on type modifier or specifier
                int nModifier = 0;
                switch (*lpsz)
                {
                // modifiers that affect size
                case 'h':
                        nModifier = FORCE_ANSI;
                        lpsz = _tcsinc(lpsz);
                        break;
                case 'l':
                        nModifier = FORCE_UNICODE;
                        lpsz = _tcsinc(lpsz);
                        break;

                // modifiers that do not affect size
                case 'F':
                case 'N':
                case 'L':
                        lpsz = _tcsinc(lpsz);
                        break;
                }

                // now should be on specifier
                switch (*lpsz | nModifier)
                {
                // single characters
                case 'c':
                case 'C':
                        nItemLen = 2;
                        va_arg(argList, TCHAR);
                        break;
                case 'c'|FORCE_ANSI:
                case 'C'|FORCE_ANSI:
                        nItemLen = 2;
                        va_arg(argList, char);
                        break;
                case 'c'|FORCE_UNICODE:
                case 'C'|FORCE_UNICODE:
                        nItemLen = 2;
                        va_arg(argList, WCHAR);
                        break;

                // strings
                case 's':
                case 'S':
                        nItemLen = lstrlen(va_arg(argList, LPCTSTR));
                        nItemLen = __max(1, nItemLen);
                        break;
                case 's'|FORCE_ANSI:
                case 'S'|FORCE_ANSI:
                        nItemLen = lstrlenA(va_arg(argList, LPCSTR));
                        nItemLen = __max(1, nItemLen);
                        break;
#ifndef _MAC
                case 's'|FORCE_UNICODE:
                case 'S'|FORCE_UNICODE:
                        nItemLen = wcslen(va_arg(argList, LPWSTR));
                        nItemLen = __max(1, nItemLen);
                        break;
#endif
                }

                // adjust nItemLen for strings
                if (nItemLen != 0)
                {
                        nItemLen = __max(nItemLen, static_cast<UINT>(nWidth));
                        if (nPrecision != 0)
                                nItemLen = __min(nItemLen, static_cast<UINT>(nPrecision));
                }
                else
                {
                        switch (*lpsz)
                        {
                        // integers
                        case 'd':
                        case 'i':
                        case 'u':
                        case 'x':
                        case 'X':
                        case 'o':
                                va_arg(argList, int);
                                nItemLen = 32;
                                nItemLen = __max(nItemLen, static_cast<UINT>(nWidth+nPrecision));
                                break;

                        case 'e':
                        case 'f':
                        case 'g':
                        case 'G':
                                va_arg(argList, _STR_DOUBLE);
                                nItemLen = 128;
                                nItemLen = __max(nItemLen, static_cast<UINT>(nWidth+nPrecision));
                                break;

                        case 'p':
                                va_arg(argList, void*);
                                nItemLen = 32;
                                nItemLen = __max(nItemLen, static_cast<UINT>(nWidth+nPrecision));
                                break;

                        // no output
                        case 'n':
                                va_arg(argList, int*);
                                break;

                        default:
                                dspAssert(FALSE);  // unknown formatting option
                        }
                }

                // adjust nMaxLen for output nItemLen
                nMaxLen += nItemLen;
        }
        va_end(argList);

        // finally, set the buffer length and format the string
        va_start(argList, lpszFormat);  // restart the arg list
        GetBuffer(static_cast<int>(nMaxLen));
        if (_vstprintf(m_pchData, lpszFormat, argList) > static_cast<int>(nMaxLen))
        {
                dspAssert(FALSE);
        }
        ReleaseBuffer();
        va_end(argList);
}

void CStr::TrimRight()
{
        // find beginning of trailing spaces by starting at beginning (DBCS aware)
        LPTSTR lpsz = m_pchData;
        LPTSTR lpszLast = NULL;
        while (*lpsz != '\0')
        {
                if (_istspace(*lpsz))
                {
                        if (lpszLast == NULL)
                                lpszLast = lpsz;
                }
                else
                        lpszLast = NULL;
                lpsz = _tcsinc(lpsz);
        }

        if (lpszLast != NULL)
        {
                // truncate at trailing space start
                *lpszLast = '\0';
                m_nDataLength = (int)(lpszLast - m_pchData);
        }
}

void CStr::TrimLeft()
{
        // find first non-space character
        LPCTSTR lpsz = m_pchData;
        while (_istspace(*lpsz))
                lpsz = _tcsinc(lpsz);

        // fix up data and length
        int nDataLength = (int)(m_nDataLength - (lpsz - m_pchData));
        memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
        m_nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// String support for template collections

void STRAPI ConstructElements(CStr* pElements, int nCount)
{
        dspAssert(IsValidAddressz(pElements, nCount * sizeof(CStr)));

        for (; nCount--; ++pElements)
                memcpy(pElements, &strEmptyStringT, sizeof(*pElements));
}

void STRAPI DestructElements(CStr* pElements, int nCount)
{
        dspAssert(IsValidAddressz(pElements, nCount * sizeof(CStr)));

        for (; nCount--; ++pElements)
                pElements->Empty();
}

//
// Added by JonN 4/16/98
//
void FreeCStrList( IN OUT CStrListItem** ppList )
{
    dspAssert( NULL != ppList );
    while (NULL != *ppList)
    {
        CStrListItem* pTemp = (*ppList)->pnext;
        delete *ppList;
        *ppList = pTemp;
    }
}
void CStrListAdd( IN OUT CStrListItem** ppList, IN LPCTSTR lpsz )
{
        dspAssert( NULL != ppList );
        CStrListItem* pnewitem = new CStrListItem;
  if (pnewitem != NULL)
  {
          pnewitem->str = lpsz;
          pnewitem->pnext = *ppList;
          *ppList = pnewitem;
  }
}
bool CStrListContains( IN CStrListItem** ppList, IN LPCTSTR lpsz )
{
        dspAssert( NULL != ppList );
        for (CStrListItem* pList = *ppList; NULL != pList; pList = pList->pnext)
        {
                if ( !_tcsicmp( lpsz, pList->str ) )
                        return true;
        }
        return false;
}
int CountCStrList( IN CStrListItem** ppList )
{
        dspAssert( NULL != ppList );
        int cCount = 0;
        for (CStrListItem* pList = *ppList; NULL != pList; pList = pList->pnext)
        {
                cCount++;
        }
        return cCount;
}

/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// For an empty string, m_???Data will point here
// (note: avoids a lot of NULL pointer tests when we call standard
//  C runtime libraries
WCHAR strChNilW = '\0';

// for creating empty key strings
const CStrW strEmptyStringW;

void CStrW::Init()
{
        m_nDataLength = m_nAllocLength = 0;
        m_pchData = (PWSTR)&strChNilW;
}

// declared static
void CStrW::SafeDelete(PWSTR& lpch)
{
        if (lpch != (PWSTR)&strChNilW &&
            lpch)
        {
                delete[] lpch;
                lpch = 0;
        }
}

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CStrW::CStrW()
{
        Init();
}

CStrW::CStrW(const CStrW& stringSrc)
{
        // if constructing a String from another String, we make a copy of the
        // original string data to enforce value semantics (i.e. each string
        // gets a copy of its own

        stringSrc.AllocCopy(*this, stringSrc.m_nDataLength, 0, 0);
}

BOOL CStrW::AllocBuffer(int nLen)
 // always allocate one extra character for '\0' termination
 // assumes [optimistically] that data length will equal allocation length
{
        dspAssert(nLen >= 0);

        if (nLen == 0)
        {
        Empty();
        }
        else
        {
                m_pchData = new WCHAR[nLen+1];       //REVIEW may throw an exception
        if (!m_pchData)
        {
            Empty();
            return FALSE;
        }
                m_pchData[nLen] = '\0';
                m_nDataLength = nLen;
                m_nAllocLength = nLen;
        }
    return TRUE;
}

void CStrW::Empty()
{
        SafeDelete(m_pchData);
        Init();
        dspAssert(m_nDataLength == 0);
        dspAssert(m_nAllocLength == 0);
}

CStrW::~CStrW()
 //  free any attached data
{
        SafeDelete(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

static inline int SafeStrlen(LPCWSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        return (int)((lpsz == NULL) ? 0 : wcslen(lpsz));
}

void CStrW::AllocCopy(CStrW& dest, int nCopyLen, int nCopyIndex,
         int nExtraLen) const
{
        // will clone the data attached to this string
        // allocating 'nExtraLen' characters
        // Places results in uninitialized string 'dest'
        // Will copy the part or all of original data to start of new string

        int nNewLen = nCopyLen + nExtraLen;

        if (nNewLen == 0)
        {
                dest.Empty();
        }
        else
        {
                if (!dest.AllocBuffer(nNewLen)) return;
            memcpy(dest.m_pchData, &m_pchData[nCopyIndex], nCopyLen*sizeof(WCHAR));
        }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStrW::CStrW(LPCWSTR lpsz)
{
                int nLen;
                if ((nLen = SafeStrlen(lpsz)) == 0)
                        Init();
                else
                {
                        if (!AllocBuffer(nLen))
            {
                Init();
                return;
            }
                    memcpy(m_pchData, lpsz, nLen*sizeof(WCHAR));
                }
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

CStrW::CStrW(LPCSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
        if (nSrcLen == 0)
                Init();
        else
        {
                if (!AllocBuffer(nSrcLen))
        {
            Init();
            return;
        }
            mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        }
}


//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CStrW&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CStrW::AssignCopy(int nSrcLen, LPCWSTR lpszSrcData)
{
        // check if it will fit
        if (nSrcLen > m_nAllocLength)
        {
                // it won't fit, allocate another one
                Empty();
                if (!AllocBuffer(nSrcLen)) return;
        }
        if (nSrcLen != 0)
                memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(WCHAR));
        m_nDataLength = nSrcLen;
        m_pchData[nSrcLen] = '\0';
}

const CStrW& CStrW::operator=(const CStrW& stringSrc)
{
        AssignCopy(stringSrc.m_nDataLength, stringSrc.m_pchData);
        return *this;
}

const CStrW& CStrW::operator=(LPCWSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        AssignCopy(SafeStrlen(lpsz), lpsz);
        return *this;
}

const CStrW& CStrW::operator=(UNICODE_STRING unistr)
{
   AssignCopy(unistr.Length/2, unistr.Buffer);
   return *this;
}

const CStrW& CStrW::operator=(UNICODE_STRING * punistr)
{
   AssignCopy(punistr->Length/2, punistr->Buffer);
   return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

const CStrW& CStrW::operator=(LPCSTR lpsz)
{
        int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
        // check if it will fit
        if (nSrcLen > m_nAllocLength)
        {
                // it won't fit, allocate another one
                Empty();
                if (!AllocBuffer(nSrcLen)) return *this;
        }
        if (nSrcLen != 0)
                mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
        m_nDataLength = nSrcLen;
        m_pchData[nSrcLen] = '\0';
        return *this;
}

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          String + String
// and for ? = WCHAR, LPCWSTR
//          String + ?
//          ? + String

void CStrW::ConcatCopy(int nSrc1Len, LPCWSTR lpszSrc1Data,
        int nSrc2Len, LPCWSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new String object

        int nNewLen = nSrc1Len + nSrc2Len;
        if (!AllocBuffer(nNewLen)) return;
        memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(WCHAR));
        memcpy(&m_pchData[nSrc1Len], lpszSrc2Data, nSrc2Len*sizeof(WCHAR));
}

CStrW STRAPI operator+(const CStrW& string1, const CStrW& string2)
{
        CStrW s;
        s.ConcatCopy(string1.m_nDataLength, string1.m_pchData,
                string2.m_nDataLength, string2.m_pchData);
        return s;
}

CStrW STRAPI operator+(const CStrW& string, LPCWSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        CStrW s;
        s.ConcatCopy(string.m_nDataLength, string.m_pchData, SafeStrlen(lpsz), lpsz);
        return s;
}

CStrW STRAPI operator+(LPCWSTR lpsz, const CStrW& string)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        CStrW s;
        s.ConcatCopy(SafeStrlen(lpsz), lpsz, string.m_nDataLength, string.m_pchData);
        return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CStrW::ConcatInPlace(int nSrcLen, LPCWSTR lpszSrcData)
{
        //  -- the main routine for += operators

        // if the buffer is too small, or we have a width mis-match, just
        //   allocate a new buffer (slow but sure)
        if (m_nDataLength + nSrcLen > m_nAllocLength)
        {
                // we have to grow the buffer, use the Concat in place routine
                PWSTR lpszOldData = m_pchData;
                ConcatCopy(m_nDataLength, lpszOldData, nSrcLen, lpszSrcData);
                dspAssert(lpszOldData != NULL);
                SafeDelete(lpszOldData);
        }
        else
        {
                // fast concatenation when buffer big enough
                memcpy(&m_pchData[m_nDataLength], lpszSrcData, nSrcLen*sizeof(WCHAR));
                m_nDataLength += nSrcLen;
        }
        dspAssert(m_nDataLength <= m_nAllocLength);
        m_pchData[m_nDataLength] = '\0';
}

const CStrW& CStrW::operator+=(LPCWSTR lpsz)
{
        dspAssert(lpsz == NULL || IsValidString(lpsz, FALSE));
        ConcatInPlace(SafeStrlen(lpsz), lpsz);
        return *this;
}

const CStrW& CStrW::operator+=(WCHAR ch)
{
        ConcatInPlace(1, &ch);
        return *this;
}

const CStrW& CStrW::operator+=(const CStrW& string)
{
        ConcatInPlace(string.m_nDataLength, string.m_pchData);
        return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

PWSTR CStrW::GetBuffer(int nMinBufLength)
{
        dspAssert(nMinBufLength >= 0);

        if (nMinBufLength > m_nAllocLength)
        {
                // we have to grow the buffer
                PWSTR lpszOldData = m_pchData;
                int nOldLen = m_nDataLength;        // AllocBuffer will tromp it

                if (!AllocBuffer(nMinBufLength)) return NULL;
                memcpy(m_pchData, lpszOldData, nOldLen*sizeof(WCHAR));
                m_nDataLength = nOldLen;
                m_pchData[m_nDataLength] = '\0';

                SafeDelete(lpszOldData);
        }

        // return a pointer to the character storage for this string
        dspAssert(m_pchData != NULL);
        return m_pchData;
}

void CStrW::ReleaseBuffer(int nNewLength)
{
        if (nNewLength == -1)
                nNewLength = static_cast<int>(wcslen(m_pchData)); // zero terminated

        dspAssert(nNewLength <= m_nAllocLength);
        m_nDataLength = nNewLength;
        m_pchData[m_nDataLength] = '\0';
}

PWSTR CStrW::GetBufferSetLength(int nNewLength)
{
        dspAssert(nNewLength >= 0);

        GetBuffer(nNewLength);
        m_nDataLength = nNewLength;
        m_pchData[m_nDataLength] = '\0';
        return m_pchData;
}

void CStrW::FreeExtra()
{
        dspAssert(m_nDataLength <= m_nAllocLength);
        if (m_nDataLength != m_nAllocLength)
        {
                PWSTR lpszOldData = m_pchData;
                if (!AllocBuffer(m_nDataLength)) return;
                memcpy(m_pchData, lpszOldData, m_nDataLength*sizeof(WCHAR));
                dspAssert(m_pchData[m_nDataLength] == '\0');
                SafeDelete(lpszOldData);
        }
        dspAssert(m_pchData != NULL);
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CStrW::Find(WCHAR ch) const
{
        // find first single character
        PWSTR lpsz = wcschr(m_pchData, ch);

        // return -1 if not found and index otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CStrW::FindOneOf(LPCWSTR lpszCharSet) const
{
        dspAssert(IsValidString(lpszCharSet, FALSE));
        PWSTR lpsz = wcspbrk(m_pchData, lpszCharSet);
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}


/////////////////////////////////////////////////////////////////////////////
// Windows extensions to strings

BOOL CStrW::LoadString(HINSTANCE hInst, UINT nID)
{
        dspAssert(nID != 0);       // 0 is an illegal string ID

        // Note: resource strings limited to 511 characters
        WCHAR szBuffer[512];
        UINT nSize = StrLoadStringW(hInst, nID, szBuffer);
        AssignCopy(nSize, szBuffer);
        return nSize > 0;
}

int STRAPI StrLoadStringW(HINSTANCE hInst, UINT nID, LPWSTR lpszBuf)
{
        dspAssert(IsValidAddressz(lpszBuf, 512));  // must be big enough for 512 bytes
#ifdef DBG
        // LoadString without annoying warning from the Debug kernel if the
        //  segment containing the string is not present
        if (::FindResource(hInst, MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
        {
                lpszBuf[0] = '\0';
                return 0; // not found
        }
#endif //DBG
        int nLen = ::LoadStringW(hInst, nID, lpszBuf, 511);
    dspAssert(nLen);
        if (nLen == 0)
                lpszBuf[0] = '\0';
        return nLen;
}


#ifdef OLE_AUTOMATION
#ifdef  UNICODE
BSTR CStrW::AllocSysString()
{
        BSTR bstr = ::SysAllocStringLen(m_pchData, m_nDataLength);
        if (bstr == NULL)
                ;//REVIEW AfxThrowMemoryException();

        return bstr;
}

BSTR CStrW::SetSysString(BSTR* pbstr)
{
        dspAssert(IsValidAddressz(pbstr, sizeof(BSTR)));

        if (!::SysReAllocStringLen(pbstr, m_pchData, m_nDataLength))
                ; //REVIEW AfxThrowMemoryException();

        dspAssert(*pbstr != NULL);
        return *pbstr;
}
#endif
#endif // #ifdef OLE_AUTOMATION


///////////////////////////////////////////////////////////////////////////////
// Orginally from StrEx.cpp 


CStrW::CStrW(WCHAR ch, int nLength)
{
        if (nLength < 1)
        {
                // return empty string if invalid repeat count
                Init();
        }
        else
        {
                if (!AllocBuffer(nLength))
        {
            Init();
            return;
        }
#ifdef UNICODE
                for (int i = 0; i < nLength; i++)
                        m_pchData[i] = ch;
#else
                memset(m_pchData, ch, nLength);
#endif
        }
}

CStrW::CStrW(LPCWSTR lpch, int nLength)
{
        if (nLength == 0)
                Init();
        else
        {
                dspAssert(IsValidAddressz(lpch, nLength, FALSE));
                if (!AllocBuffer(nLength))
        {
            Init();
            return;
        }
                memcpy(m_pchData, lpch, nLength*sizeof(WCHAR));
        }
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CStrW& CStrW::operator=(WCHAR ch)
{
        AssignCopy(1, &ch);
        return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CStrW STRAPI operator+(const CStrW& string1, WCHAR ch)
{
        CStrW s;
        s.ConcatCopy(string1.m_nDataLength, string1.m_pchData, 1, &ch);
        return s;
}

CStrW STRAPI operator+(WCHAR ch, const CStrW& string)
{
        CStrW s;
        s.ConcatCopy(1, &ch, string.m_nDataLength, string.m_pchData);
        return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CStrW CStrW::Mid(int nFirst) const
{
        return Mid(nFirst, m_nDataLength - nFirst);
}

CStrW CStrW::Mid(int nFirst, int nCount) const
{
        dspAssert(nFirst >= 0);
        dspAssert(nCount >= 0);

        // out-of-bounds requests return sensible things
        if (nFirst + nCount > m_nDataLength)
                nCount = m_nDataLength - nFirst;
        if (nFirst > m_nDataLength)
                nCount = 0;

        CStrW dest;
        AllocCopy(dest, nCount, nFirst, 0);
        return dest;
}

CStrW CStrW::Right(int nCount) const
{
        dspAssert(nCount >= 0);

        if (nCount > m_nDataLength)
                nCount = m_nDataLength;

        CStrW dest;
        AllocCopy(dest, nCount, m_nDataLength-nCount, 0);
        return dest;
}

CStrW CStrW::Left(int nCount) const
{
        dspAssert(nCount >= 0);

        if (nCount > m_nDataLength)
                nCount = m_nDataLength;

        CStrW dest;
        AllocCopy(dest, nCount, 0, 0);
        return dest;
}

// strspn equivalent
CStrW CStrW::SpanIncluding(LPCWSTR lpszCharSet) const
{
        dspAssert(IsValidString(lpszCharSet, FALSE));
        return Left(static_cast<int>(wcsspn(m_pchData, lpszCharSet)));
}

// strcspn equivalent
CStrW CStrW::SpanExcluding(LPCWSTR lpszCharSet) const
{
        dspAssert(IsValidString(lpszCharSet, FALSE));
        return Left(static_cast<int>(wcscspn(m_pchData, lpszCharSet)));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CStrW::ReverseFind(WCHAR ch) const
{
        // find last single character
        PWSTR lpsz = wcsrchr(m_pchData, ch);

        // return -1 if not found, distance from beginning otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CStrW::Find(LPCWSTR lpszSub) const
{
        dspAssert(IsValidString(lpszSub, FALSE));

        // find first matching substring
        PWSTR lpsz = wcsstr(m_pchData, lpszSub);

        // return -1 for not found, distance from beginning otherwise
        return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// String formatting

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

// formatting (using wsprintf style formatting)
void CStrW::Format(LPCWSTR lpszFormat, ...)
{
        dspAssert(IsValidString(lpszFormat, FALSE));

        va_list argList;
        va_start(argList, lpszFormat);

        // make a guess at the maximum length of the resulting string
        size_t nMaxLen = 0;
        for (LPCWSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _wcsinc(lpsz))
        {
                // handle '%' character, but watch out for '%%'
                if (*lpsz != '%' || *(lpsz = _wcsinc(lpsz)) == '%')
                {
                        nMaxLen += wcslen(lpsz);
                        continue;
                }

                size_t nItemLen = 0;

                // handle '%' character with format
                int nWidth = 0;
                for (; *lpsz != '\0'; lpsz = _wcsinc(lpsz))
                {
                        // check for valid flags
                        if (*lpsz == '#')
                                nMaxLen += 2;   // for '0x'
                        else if (*lpsz == '*')
                                nWidth = va_arg(argList, int);
                        else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
                                *lpsz == ' ')
                                ;
                        else // hit non-flag character
                                break;
                }
                // get width and skip it
                if (nWidth == 0)
                {
                        // width indicated by
                        nWidth = _wtoi(lpsz);
                        for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _wcsinc(lpsz))
                                ;
                }
                dspAssert(nWidth >= 0);

                int nPrecision = 0;
                if (*lpsz == '.')
                {
                        // skip past '.' separator (width.precision)
                        lpsz = _wcsinc(lpsz);

                        // get precision and skip it
                        if (*lpsz == '*')
                        {
                                nPrecision = va_arg(argList, int);
                                lpsz = _wcsinc(lpsz);
                        }
                        else
                        {
                                nPrecision = _wtoi(lpsz);
                                for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _wcsinc(lpsz))
                                        ;
                        }
                        dspAssert(nPrecision >= 0);
                }

                // should be on type modifier or specifier
                int nModifier = 0;
                switch (*lpsz)
                {
                // modifiers that affect size
                case 'h':
                        nModifier = FORCE_ANSI;
                        lpsz = _wcsinc(lpsz);
                        break;
                case 'l':
                        nModifier = FORCE_UNICODE;
                        lpsz = _wcsinc(lpsz);
                        break;

                // modifiers that do not affect size
                case 'F':
                case 'N':
                case 'L':
                        lpsz = _wcsinc(lpsz);
                        break;
                }

                // now should be on specifier
                switch (*lpsz | nModifier)
                {
                // single characters
                case 'c':
                case 'C':
                        nItemLen = 2;
                        va_arg(argList, WCHAR);
                        break;
                case 'c'|FORCE_ANSI:
                case 'C'|FORCE_ANSI:
                        nItemLen = 2;
                        va_arg(argList, char);
                        break;
                case 'c'|FORCE_UNICODE:
                case 'C'|FORCE_UNICODE:
                        nItemLen = 2;
                        va_arg(argList, WCHAR);
                        break;

                // strings
                case 's':
                case 'S':
                        nItemLen = wcslen(va_arg(argList, LPCWSTR));
                        nItemLen = __max(1, nItemLen);
                        break;
                case 's'|FORCE_ANSI:
                case 'S'|FORCE_ANSI:
                        nItemLen = lstrlenA(va_arg(argList, LPCSTR));
                        nItemLen = __max(1, nItemLen);
                        break;
#ifndef _MAC
                case 's'|FORCE_UNICODE:
                case 'S'|FORCE_UNICODE:
                        nItemLen = wcslen(va_arg(argList, LPWSTR));
                        nItemLen = __max(1, nItemLen);
                        break;
#endif
                }

                // adjust nItemLen for strings
                if (nItemLen != 0)
                {
                        nItemLen = __max(nItemLen, static_cast<UINT>(nWidth));
                        if (nPrecision != 0)
                                nItemLen = __min(nItemLen, static_cast<UINT>(nPrecision));
                }
                else
                {
                        switch (*lpsz)
                        {
                        // integers
                        case 'd':
                        case 'i':
                        case 'u':
                        case 'x':
                        case 'X':
                        case 'o':
                                va_arg(argList, int);
                                nItemLen = 32;
                                nItemLen = __max(nItemLen, static_cast<UINT>(nWidth+nPrecision));
                                break;

                        case 'e':
                        case 'f':
                        case 'g':
                        case 'G':
                                va_arg(argList, _STR_DOUBLE);
                                nItemLen = 128;
                                nItemLen = __max(nItemLen, static_cast<UINT>(nWidth+nPrecision));
                                break;

                        case 'p':
                                va_arg(argList, void*);
                                nItemLen = 32;
                                nItemLen = __max(nItemLen, static_cast<UINT>(nWidth+nPrecision));
                                break;

                        // no output
                        case 'n':
                                va_arg(argList, int*);
                                break;

                        default:
                                dspAssert(FALSE);  // unknown formatting option
                        }
                }

                // adjust nMaxLen for output nItemLen
                nMaxLen += nItemLen;
        }
        va_end(argList);

        // finally, set the buffer length and format the string
        va_start(argList, lpszFormat);  // restart the arg list
        GetBuffer(static_cast<int>(nMaxLen));
        if (vswprintf(m_pchData, lpszFormat, argList) > static_cast<int>(nMaxLen))
        {
                dspAssert(FALSE);
        }
        ReleaseBuffer();
        va_end(argList);
}

// formatting (using FormatMessage style formatting)
void CStrW::FormatMessage(PCWSTR pwzFormat, ...)
{
        dspAssert(IsValidString(pwzFormat, FALSE));

   // format message into temporary buffer pwzTemp
   va_list argList;
   va_start(argList, pwzFormat);
   PWSTR pwzTemp = 0;

   if (::FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
       pwzFormat, 0, 0, (PWSTR)&pwzTemp, 0, &argList) == 0 ||
       pwzTemp == NULL)
   {
      ;//REVIEW AfxThrowMemoryException();
   }

   // assign pwzTemp into the resulting string and free the temporary
   *this = pwzTemp;
   LocalFree(pwzTemp);
   va_end(argList);
}

void CStrW::FormatMessage(HINSTANCE hInst, UINT nFormatID, ...)
{
   // get format string from string table
   CStrW strFormat;
   BOOL fLoaded = strFormat.LoadString(hInst, nFormatID);
   dspAssert(fLoaded);

   // format message into temporary buffer pwzTemp
   va_list argList;
   va_start(argList, nFormatID);
   PWSTR pwzTemp;
   if (::FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
       strFormat, 0, 0, (PWSTR)&pwzTemp, 0, &argList) == 0 ||
       pwzTemp == NULL)
   {
       ;//REVIEW AfxThrowMemoryException();
   }

   // assign pwzTemp into the resulting string and free pwzTemp
   *this = pwzTemp;
   LocalFree(pwzTemp);
   va_end(argList);
}

void CStrW::TrimRight()
{
        // find beginning of trailing spaces by starting at beginning (DBCS aware)
        PWSTR lpsz = m_pchData;
        PWSTR lpszLast = NULL;
        while (*lpsz != '\0')
        {
                if (_istspace(*lpsz))
                {
                        if (lpszLast == NULL)
                                lpszLast = lpsz;
                }
                else
                        lpszLast = NULL;
                lpsz = _wcsinc(lpsz);
        }

        if (lpszLast != NULL)
        {
                // truncate at trailing space start
                *lpszLast = '\0';
                m_nDataLength = (int)(lpszLast - m_pchData);
        }
}

void CStrW::TrimLeft()
{
        // find first non-space character
        LPCWSTR lpsz = m_pchData;
        while (_istspace(*lpsz))
                lpsz = _wcsinc(lpsz);

        // fix up data and length
        int nDataLength = (int)(m_nDataLength - (lpsz - m_pchData));
        memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(WCHAR));
        m_nDataLength = nDataLength;
}

///////////////////////////////////////////////////////////////////////////////
// String support for template collections

void STRAPI ConstructElements(CStrW* pElements, int nCount)
{
        dspAssert(IsValidAddressz(pElements, nCount * sizeof(CStrW)));

        for (; nCount--; ++pElements)
                memcpy(pElements, &strEmptyStringW, sizeof(*pElements));
}

void STRAPI DestructElements(CStrW* pElements, int nCount)
{
        dspAssert(IsValidAddressz(pElements, nCount * sizeof(CStrW)));

        for (; nCount--; ++pElements)
                pElements->Empty();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\dsprop.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       dsprop.cxx
//
//  Contents:   Tables for common values for table-driven DS property pages
//
//  History:    14-July-97 Jimharr created from dsprop.cxx by ericb
//
//  Note:       Attribute LDAP display names, types, upper ranges, and so
//              forth, have been manually copied from schema.ini. Thus,
//              consistency is going to be difficult to maintain. If you know
//              of schema.ini changes that affect any of the attributes in
//              this file, then please make any necessary corrections here.
//
//              this file is #INCLUDE'd in shlprop.cxx & pagetable.cxx
//-----------------------------------------------------------------------------

// NOTE: We are handling unlimited length strings by allowing a fixed but huge length
#define ATTR_LEN_UNLIMITED  32000

//
// Attributes common to more than one object class.
//

//
// General page, icon
//
ATTR_MAP GenIcon = {IDC_DS_ICON, TRUE, FALSE, 0, {NULL, ADS_ATTR_UPDATE,
                    ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, GeneralPageIcon, NULL};
//
// Name
//
ATTR_MAP AttrName = {IDC_CN, TRUE, FALSE, 64,
                     {g_wzName, ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                      NULL, 0}, NULL, NULL};
//
// Description
//
ATTR_MAP Description = {IDC_DESCRIPTION_EDIT, FALSE, FALSE, 1024,
                        {g_wzDescription, ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

//+----------------------------------------------------------------------------
// User Object common stuff.
//-----------------------------------------------------------------------------

//
// Address page, Address
//
ATTR_MAP UAddrAddress = {IDC_ADDRESS_EDIT, FALSE, FALSE, 1024,
                         {g_wzStreet, ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Address page, POBox (Post-Office-Box)
//
ATTR_MAP UAddrPOBox = {IDC_POBOX_EDIT, FALSE, FALSE, 40,
                       {g_wzPOB, ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Address page, City (Locality-Name)
//
ATTR_MAP UAddrCity = {IDC_CITY_EDIT, FALSE, FALSE, 128,
                      {g_wzCity, ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                       NULL, 0}, NULL, NULL};
//
// Address page, State (State-Or-Provence-Name)
//
ATTR_MAP UAddrState = {IDC_STATE_EDIT, FALSE, FALSE, 128,
                       {g_wzState, ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                        NULL, 0}, NULL, NULL};
//
// Address page, ZIP (Postal-Code)
//
ATTR_MAP UAddrZIP = {IDC_ZIP_EDIT, FALSE, FALSE, 40,
                     {g_wzZIP, ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Address page, CountryName
//
ATTR_MAP UAddrCntryName = {IDC_COUNTRY_COMBO, FALSE, FALSE, 3,
                         {g_wzCountryName, ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                         NULL, 0}, CountryName, NULL};
//
// Address page, CountryCode. Thus MUST be after UAddrCntryName.
//
ATTR_MAP UAddrCntryCode = {IDC_COUNTRY_COMBO, FALSE, FALSE, 3,
                         {g_wzCountryCode, ADS_ATTR_UPDATE, ADSTYPE_INTEGER,
                         NULL, 0}, CountryCode, NULL};
//
// Address page, Text-Country
//
ATTR_MAP UAddrTextCntry = {IDC_COUNTRY_COMBO, FALSE, FALSE, 128,
                     {g_wzTextCountry, ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TextCountry, NULL};


//
// The list of attributes on the Address page.
//
PATTR_MAP rgpUAddrAttrMap[] = {{&UAddrAddress}, {&UAddrPOBox}, {&UAddrCity},
                               {&UAddrState}, {&UAddrCntryName},
                               {&UAddrCntryCode},{&UAddrTextCntry}, {&UAddrZIP}};
//
// Address page description.
//
DSPAGE UserAddress = {IDS_TITLE_ADDRESS, IDD_ADDRESS, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpUAddrAttrMap)/sizeof(PATTR_MAP),
                      rgpUAddrAttrMap};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\dll.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       dll.h
//
//  Contents:   DLL refcounting classes, wait cursor class, and error reporting
//              functions.
//
//  Classes:    CDll, CDllRef
//
//  History:    1/24/1996   RaviR   Created
//              6/09/1997   EricB   Error Reporting.
//
//____________________________________________________________________________

#ifndef _DLL_H_
#define _DLL_H_

#define MAX_TITLE       80
#define MAX_MSG_LEN     512
#define MAX_ERRORMSG    MAX_MSG_LEN

void LoadErrorMessage(HRESULT hr, int nStr, PTSTR* pptsz);

class CDll
{
public:

    static ULONG AddRef() { return InterlockedIncrement((LONG*)&s_cObjs); }
    static ULONG Release() { return InterlockedDecrement((LONG*)&s_cObjs); }

    static void LockServer(BOOL fLock) {
        (fLock == TRUE) ? InterlockedIncrement((LONG*)&s_cLocks)
                        : InterlockedDecrement((LONG*)&s_cLocks);
    }

    static HRESULT CanUnloadNow(void) {
        return (0L == s_cObjs && 0L == s_cLocks) ? S_OK : S_FALSE;
    }

    static ULONG s_cObjs;
    static ULONG s_cLocks;

};  // class CDll


class CDllRef
{
public:

    CDllRef(void) { CDll::AddRef(); }
    ~CDllRef(void) { CDll::Release(); }

}; // class CDllRef


class CWaitCursor
{
public:
    CWaitCursor() {m_cOld=SetCursor(m_cWait=LoadCursor(NULL, IDC_WAIT));}
    ~CWaitCursor() {SetCursor(m_cOld);}

    void SetWait() {SetCursor(m_cWait);}
    void SetOld() {SetCursor(m_cOld);}

private:
    HCURSOR m_cWait;
    HCURSOR m_cOld;
} ;

// This wrapper function required to make prefast shut up when we are 
// initializing a critical section in a constructor.

void ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec);

#endif // _DLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\display\proppage\group.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       group.cxx
//
//  Contents:   CDsGroupGenObjPage, the class that implements the group object
//              general property page, CDsGrpMembersPage for the group
//              membership page, and CDsGrpShlGenPage for the shell group
//              general page.
//
//  History:    10-April-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "group.h"

#include "qrybase.h"
#define BULK_ADD 1

#ifdef DSADMIN

#define DESCR_IDX   0
#define SAMNAME_IDX 1
#define EMAIL_IDX   2
#define COMMENT_IDX 3

//+----------------------------------------------------------------------------
//
//  Member:     CDsGroupGenObjPage::CDsGroupGenObjPage
//
//-----------------------------------------------------------------------------
CDsGroupGenObjPage::CDsGroupGenObjPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                       HWND hNotifyObj, DWORD dwFlags) :
    m_pCIcon(NULL),
    m_fMixed(TRUE),
    m_dwType(0),
    m_fTypeWritable(FALSE),
    m_fDescrWritable(FALSE),
    m_fSamNameWritable(FALSE),
    m_fEmailWritable(FALSE),
    m_fCommentWritable(FALSE),
    m_fTypeDirty(FALSE),
    m_fDescrDirty(FALSE),
    m_fSamNameDirty(FALSE),
    m_fEmailDirty(FALSE),
    m_fCommentDirty(FALSE),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsGroupGenObjPage,CDsGroupGenObjPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsGroupGenObjPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGroupGenObjPage::~CDsGroupGenObjPage
//
//-----------------------------------------------------------------------------
CDsGroupGenObjPage::~CDsGroupGenObjPage()
{
    TRACE(CDsGroupGenObjPage,~CDsGroupGenObjPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateGroupGenObjPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateGroupGenObjPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                      PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                      DWORD dwFlags, CDSBasePathsInfo* pBasePathsInfo,
                      HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateGroupGenObjPage);

    CDsGroupGenObjPage * pPageObj = new CDsGroupGenObjPage(pDsPage, pDataObj,
                                                           hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, pBasePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
LRESULT
CDsGroupGenObjPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == g_uChangeMsg)
    {
        OnAttrChanged(wParam);
        return TRUE;
    }

    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case PSM_QUERYSIBLINGS:
        OnQuerySiblings(wParam, lParam);
        break;

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsGroupGenObjPage::OnInitDialog(LPARAM)
{
    TRACE(CDsGroupGenObjPage,OnInitDialog);
    HRESULT hr;
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0;

    CWaitCursor Wait;

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    PTSTR ptzRDN;
    if (!UnicodeToTchar(m_pwszRDName, &ptzRDN))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        return S_OK;
    }

    SetDlgItemText(m_hPage, IDC_CN, ptzRDN);
    delete ptzRDN;

    //
    // Get the icon from the DS and put it on the page.
    //
    ATTR_DATA ad = {0, 0};

    hr = GeneralPageIcon(this, &GenIcon, NULL, 0, &ad, fInit);

    CHECK_HRESULT_REPORT(hr, m_hPage, return S_OK);

    m_pCIcon = (CDsIconCtrl *)ad.pVoid;

    m_fTypeWritable    = CheckIfWritable(g_wzGroupType);
    m_fDescrWritable   = CheckIfWritable(m_rgpAttrMap[DESCR_IDX]->AttrInfo.pszAttrName);
    m_fSamNameWritable = CheckIfWritable(m_rgpAttrMap[SAMNAME_IDX]->AttrInfo.pszAttrName);
    m_fEmailWritable   = CheckIfWritable(m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName);
    m_fCommentWritable = CheckIfWritable(m_rgpAttrMap[COMMENT_IDX]->AttrInfo.pszAttrName);

    //
    // Get description, SAM name, email address, and comment attributes.
    //
    SendDlgItemMessage(m_hPage, m_rgpAttrMap[DESCR_IDX]->nCtrlID, EM_LIMITTEXT,
                       m_rgpAttrMap[DESCR_IDX]->nSizeLimit, 0);
    SendDlgItemMessage(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID, EM_LIMITTEXT,
                       m_rgpAttrMap[SAMNAME_IDX]->nSizeLimit, 0);
    SendDlgItemMessage(m_hPage, m_rgpAttrMap[EMAIL_IDX]->nCtrlID, EM_LIMITTEXT,
                       m_rgpAttrMap[EMAIL_IDX]->nSizeLimit, 0);
    SendDlgItemMessage(m_hPage, m_rgpAttrMap[COMMENT_IDX]->nCtrlID, EM_LIMITTEXT,
                       m_rgpAttrMap[COMMENT_IDX]->nSizeLimit, 0);

    PWSTR rgpwzAttrNames[] = {m_rgpAttrMap[DESCR_IDX]->AttrInfo.pszAttrName,
                              m_rgpAttrMap[SAMNAME_IDX]->AttrInfo.pszAttrName,
                              m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName,
                              m_rgpAttrMap[COMMENT_IDX]->AttrInfo.pszAttrName,
                              g_wzGroupType};

    hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 5, &pAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, m_hPage))
    {
        return S_OK;
    }

    for (DWORD i = 0; i < cAttrs; i++)
    {
        dspAssert(pAttrs);
        dspAssert(pAttrs[i].pADsValues);
        PTSTR ptz;

        if (_wcsicmp(pAttrs[i].pszAttrName, m_rgpAttrMap[DESCR_IDX]->AttrInfo.pszAttrName) == 0)
        {
            // description.
            //
            if (!UnicodeToTchar(pAttrs[i].pADsValues->CaseIgnoreString, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                FreeADsMem(pAttrs);
                return S_OK;
            }

            SetDlgItemText(m_hPage, m_rgpAttrMap[DESCR_IDX]->nCtrlID, ptz);

            delete ptz;
        }
        if (_wcsicmp(pAttrs[i].pszAttrName, m_rgpAttrMap[SAMNAME_IDX]->AttrInfo.pszAttrName) == 0)
        {
            // SAM name.
            //
            if (!UnicodeToTchar(pAttrs[i].pADsValues->CaseIgnoreString, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                FreeADsMem(pAttrs);
                return S_OK;
            }

            SetDlgItemText(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID, ptz);

            delete ptz;
        }
        if (_wcsicmp(pAttrs[i].pszAttrName, m_rgpAttrMap[EMAIL_IDX]->AttrInfo.pszAttrName) == 0)
        {
            // email address.
            //
            if (!UnicodeToTchar(pAttrs[i].pADsValues->CaseIgnoreString, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                FreeADsMem(pAttrs);
                return S_OK;
            }

            SetDlgItemText(m_hPage, m_rgpAttrMap[EMAIL_IDX]->nCtrlID, ptz);

            delete ptz;
        }
        if (_wcsicmp(pAttrs[i].pszAttrName, m_rgpAttrMap[COMMENT_IDX]->AttrInfo.pszAttrName) == 0)
        {
            // comment.
            //
            if (!UnicodeToTchar(pAttrs[i].pADsValues->CaseIgnoreString, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                FreeADsMem(pAttrs);
                return S_OK;
            }

            SetDlgItemText(m_hPage, m_rgpAttrMap[COMMENT_IDX]->nCtrlID, ptz);

            delete ptz;
        }
        if (_wcsicmp(pAttrs[i].pszAttrName, g_wzGroupType) == 0)
        {
            // group type.
            //
            m_dwType = pAttrs[i].pADsValues->Integer;
        }
    }

    if (pAttrs)
    {
        FreeADsMem(pAttrs);
    }

    //
    // Get the domain type and set the buttons accordingly.
    //
    GetDomainMode(this, &m_fMixed);

    BOOL Sec = m_dwType & GROUP_TYPE_SECURITY_ENABLED;
    CheckDlgButton(m_hPage,
                   (Sec) ? IDC_RADIO_SEC_ENABLED :
                           IDC_RADIO_SEC_DISABLED,
                   BST_CHECKED);
    if (m_fMixed)
    {
        EnableWindow(GetDlgItem(m_hPage, (Sec) ? IDC_RADIO_SEC_DISABLED : 
                                                 IDC_RADIO_SEC_ENABLED), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_UNIVERSAL), FALSE);
    }
    UINT id;
    if (m_dwType & GROUP_TYPE_ACCOUNT_GROUP)
    {
        id = IDC_RADIO_ACCOUNT;
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_RESOURCE), FALSE);
    }
    else
    if (m_dwType & GROUP_TYPE_RESOURCE_GROUP)
    {
        id = IDC_RADIO_RESOURCE;
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_ACCOUNT), FALSE);
        if (m_dwType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
        {
            TCHAR szLabel[100];
            if (!LoadStringReport(IDS_BUILTIN_GROUP, szLabel, 100, m_hPage))
            {
                hr = E_OUTOFMEMORY;
                return S_OK;
            }
            SetWindowText(GetDlgItem(m_hPage, IDC_RADIO_RESOURCE), szLabel);
        }
    }
    else
    if (m_dwType & GROUP_TYPE_UNIVERSAL_GROUP)
    {
        id = IDC_RADIO_UNIVERSAL;
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_ACCOUNT), m_fMixed ? FALSE : TRUE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_RESOURCE), m_fMixed ? FALSE : TRUE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_UNIVERSAL), TRUE);
    }
    else
    {
      //
      // Probably a default but we should never get here anyway
      //
      id = IDC_RADIO_ACCOUNT;
#if DBG == 1
        dspAssert(FALSE && "Unknown group type!");
#endif
    }

    CheckDlgButton(m_hPage, id, BST_CHECKED);

    bool    fIsSpecialAccount = false;

    IsSpecialAccount (fIsSpecialAccount);

    if (!m_fTypeWritable || 
        (m_dwType & GROUP_TYPE_BUILTIN_LOCAL_GROUP) ||
        fIsSpecialAccount)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_ACCOUNT), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_RESOURCE), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_UNIVERSAL), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_SEC_ENABLED), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_RADIO_SEC_DISABLED), FALSE);
    }
	
    if (!m_fDescrWritable)
    {
       SendDlgItemMessage(m_hPage, m_rgpAttrMap[DESCR_IDX]->nCtrlID, EM_SETREADONLY, (WPARAM)TRUE, 0);
    }
    if (!m_fSamNameWritable)
    {
       SendDlgItemMessage(m_hPage, m_rgpAttrMap[SAMNAME_IDX]->nCtrlID, EM_SETREADONLY, (WPARAM)TRUE, 0);
    }
    if (!m_fEmailWritable)
    {
       SendDlgItemMessage(m_hPage, m_rgpAttrMap[EMAIL_IDX]->nCtrlID, EM_SETREADONLY, (WPARAM)TRUE, 0);
    }
    if (!m_fCommentWritable)
    {
       SendDlgItemMessage(m_hPage, m_rgpAttrMap[COMMENT_IDX]->nCtrlID, EM_SETREADONLY, (WPARAM)TRUE, 0);
    }

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsGroupGenObjPage::IsSpecialAccount
//
//  Synopsis:   Returns true if group RID indicates a special account
//
//-----------------------------------------------------------------------------
HRESULT CDsGroupGenObjPage::IsSpecialAccount(bool& fIsSpecialAccount)
{
    //
    // Get the group SID. This is a required attribute so bail if not found.
    //
    PWSTR rgpwzAttrNames[] = {g_wzObjectSID};
    PADS_ATTR_INFO pAttrs = 