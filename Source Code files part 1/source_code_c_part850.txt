ER | SHRVT_REGISTERIFPROMPTOK);
    }
    return hr;
}


// IDVGetEnum
HRESULT CDefView::SetEnumReadyCallback(PFDVENUMREADYBALLBACK pfn, void *pvData)
{
    _pfnEnumReadyCallback = pfn;
    _pvEnumCallbackData = pvData;
    return S_OK;
}

BOOL FilterOnAttributes(DWORD dwAttributes, DWORD grfEnumFlags)
{
    if (dwAttributes & SFGAO_FOLDER)
    {
        if (!(grfEnumFlags & SHCONTF_FOLDERS))
            return FALSE;   // item is folder but client does not want folders
    }
    else if (!(grfEnumFlags & SHCONTF_NONFOLDERS))
    {
        return FALSE;   // item is file, but client only wants folders
    }

    if (!(grfEnumFlags & SHCONTF_INCLUDEHIDDEN) &&
         (dwAttributes & SFGAO_HIDDEN))
         return FALSE;  // item is hidden by client wants non hidden

    return TRUE;
}

HRESULT CDefView::CreateEnumIDListFromContents(LPCITEMIDLIST pidlFolder, DWORD grfEnumFlags, IEnumIDList **ppenum)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlView = _GetViewPidl();
    if (pidlView)
    {
        if (ILIsEqual(pidlFolder, pidlView) && (grfEnumFlags & _GetEnumFlags()) == grfEnumFlags)
        {
            LPCITEMIDLIST *apidl;
            UINT cItems;
            hr = _GetItemObjects(&apidl, SVGIO_ALLVIEW, &cItems);
            if (SUCCEEDED(hr))
            {
                for (UINT i = 0; i < cItems; i++)
                {
                    if (!FilterOnAttributes(_Attributes(apidl[i], SFGAO_FOLDER | SFGAO_HIDDEN), grfEnumFlags))
                    {
                        apidl[i] = apidl[cItems - 1];
                        cItems--;
                        i--;
                    }
                }

                hr = CreateIEnumIDListOnIDLists(apidl, cItems, ppenum);
                LocalFree(apidl);
            }
        }
        ILFree(pidlView);
    }
    return hr;
}

HRESULT CDefView::_OnDefaultCommand()
{
    return _pcdb ? _pcdb->OnDefaultCommand(_psvOuter ? _psvOuter : this) : E_NOTIMPL;
}

HRESULT CDefView::_OnStateChange(UINT code)
{
    return _pcdb ? _pcdb->OnStateChange(_psvOuter ? _psvOuter : this, code) : E_NOTIMPL;
}

HRESULT CDefView::_IncludeObject(LPCITEMIDLIST pidl)
{
    if (_pcdb)
        return _pcdb->IncludeObject(_psvOuter ? _psvOuter : this, pidl);
    else
    {
        IFolderFilter *psff = _cCallback.GetISFF();
        return psff ? psff->ShouldShow(_pshf, NULL, pidl) : S_OK;
    }
}

HRESULT CDefView::CallCB(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return _cCallback.CallCB(uMsg, wParam, lParam);
}

// fires dispatch events to clients (address bar, webview, etc).
// this translates return values of false into "ERROR_CANCELLED"

HRESULT CDefView::_FireEvent(DISPID dispid)
{
    HRESULT hr;
    VARIANT varResult = {0};
    SHINVOKEPARAMS inv = {0};

    inv.dispidMember = dispid;
    inv.piid = &IID_NULL;
    inv.wFlags = DISPATCH_METHOD;
    inv.pvarResult = &varResult;

    if (SUCCEEDED(IUnknown_CPContainerInvokeIndirect(_pauto, DIID_DShellFolderViewEvents, &inv)))
    {
        if ((VT_BOOL == varResult.vt) && (VARIANT_FALSE == varResult.boolVal))
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
        else
        {
            hr = S_OK;
        }
        VariantClear(&varResult);
    }
    else
        hr = S_FALSE;

    return hr;
}

BOOL CDefView::_IsPositionedView()
{
    return !_fGroupView && ((_fs.ViewMode == FVM_ICON) || (_fs.ViewMode == FVM_SMALLICON) ||
                            (_fs.ViewMode == FVM_TILE) || (_fs.ViewMode == FVM_THUMBNAIL) ||
                            (_fs.ViewMode == FVM_THUMBSTRIP));
}

// reposition the selected items in a listview by dx, dy

void CDefView::_MoveSelectedItems(int dx, int dy, BOOL fAbsolute)
{
    SendMessage(_hwndListview, WM_SETREDRAW, FALSE, 0);
    for (int i = ListView_GetNextItem(_hwndListview, -1, LVNI_SELECTED);
         i >= 0;
         i = ListView_GetNextItem(_hwndListview, i, LVNI_SELECTED))
    {
        if (fAbsolute)
        {
            _SetItemPosition(i, dx, dy);
        }
        else
        {
            POINT pt;
            ListView_GetItemPosition(_hwndListview, i, &pt);

            pt.x += dx;
            pt.y += dy;

            _SetItemPosition(i, pt.x, pt.y);
        }
    }
    SendMessage(_hwndListview, WM_SETREDRAW, TRUE, 0);
}

void CDefView::_SameViewMoveIcons()
{
    POINT ptDrop;
    BOOL fAbsolute = FALSE;

    // We'll use the insert mark rect (if available) to determine a drop point
    if (_GetInsertPoint(&ptDrop))
        fAbsolute = TRUE; // Move all items to this point.
    else
    {
        ptDrop = _ptDrop;
        ptDrop.x -= _ptDragAnchor.x;
        ptDrop.y -= _ptDragAnchor.y;
        LVUtil_ClientToLV(_hwndListview, &ptDrop);
    }

    ASSERT(_IsPositionedView());

    _MoveSelectedItems(ptDrop.x, ptDrop.y, fAbsolute);
}

//
// This function checks if the current HTML wallpaper is the default
// wallpaper and returns TRUE if so. If the wallpaper is the default wallpaper,
// it reads the colors from the registry. If the colors are missing, then it
// supplies the default colors.
//
BOOL CDefView::_GetColorsFromHTMLdoc(COLORREF *pclrTextBk, COLORREF *pclrHotlight)
{
    // make sure the HTML document has reached ready-state interactive
    COLORREF clrBackground;
    BOOL bRet = SUCCEEDED(_cFrame._GetHTMLBackgroundColor(&clrBackground));
    if (bRet)
    {
        // The following are the standard colors supported on desktop
        const COLORREF  c_VgaColorTable[] =
        {
            0x000000,   // Black
            0x000080,
            0x0000FF,
            0x008000,
            0x008080,
            0x00FF00,   // Green
            0x00FFFF,   // Yellow
            0x800000,
            0x800080,
            0x808000,
            0x808080,
            0xF0CAA6,
            0xF0FBFF,
            0xFF0000,   // Blue
            0xFF00FF,   // Magenta
            0xFFFF00,   // cobalt
            0xFFFFFF    // White
        };

        // Check if the given background color is a standard color.
        // If not, use the system background (COLOR_BACKGROUND).

        *pclrTextBk = GetSysColor(COLOR_BACKGROUND);    // default

        for (int i = 0; i < ARRAYSIZE(c_VgaColorTable); i++)
        {
            if (c_VgaColorTable[i] == clrBackground)
            {
                *pclrTextBk = clrBackground;  // standard, so use it
                break;
            }
        }

        if (COLORISLIGHT(*pclrTextBk))
            *pclrHotlight = 0x000000;    //Black as hightlight color!
        else
            *pclrHotlight = 0xFFFFFF;    //White as highlight color!
    }
    return bRet;
}

// Set the colors for the folder - taking care if it's the desktop.
void CDefView::_SetFolderColors()
{
    COLORREF clrText, clrTextBk, clrWindow;

    // Is this view for the desktop?
    if (_IsDesktop())
    {
        COLORREF clrHotlight;

        Shell_SysColorChange();

        // If we show HTML wallpaper, then get the appropriate colors too!
        if (_fCombinedView && _GetColorsFromHTMLdoc(&clrTextBk, &clrHotlight))
        {
            // Set the Hotlight color!
            ListView_SetHotlightColor(_hwndListview, clrHotlight);
        }
        else
        {
            // Yep.
            // Clear the background color of the desktop to make it
            // properly handle transparency.
            clrTextBk = GetSysColor(COLOR_BACKGROUND);

            //Reset the Hotlight color sothat the system color can be used.
            ListView_SetHotlightColor(_hwndListview, CLR_DEFAULT);
        }
        // set a text color that will show up over desktop color
        if (COLORISLIGHT(clrTextBk))
            clrText = 0x000000; // black
        else
            clrText = 0xFFFFFF; // white

        clrWindow = CLR_NONE; // Assume transparent

        //
        //  if there is no wallpaper or pattern we can use
        //  a solid color for the ListView. otherwise we
        //  need to use a transparent ListView, this is much
        //  slower so dont do it unless we need to.
        //
        //  Don't do this optimization if USER is going to paint
        //  some magic text on the desktop, such as
        //
        //      "FailSafe" (SM_CLEANBOOT)
        //      "Debug" (SM_DEBUG)
        //      "Build ####" (REGSTR_PATH_DESKTOP\PaintDesktopVersion)
        //      "Evaluation Version"
        //
        //  too bad there is no SPI_GETWALLPAPER, we need to read
        //  from WIN.INI.
        //

        TCHAR szWallpaper[128], szPattern[128];
        DWORD dwPaintVersion = 0;
        szWallpaper[0] = 0;
        szPattern[0] = 0;

        HKEY hkey;
        if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DESKTOP, 0, KEY_QUERY_VALUE, &hkey) == 0)
        {
            UINT cb = sizeof(szWallpaper);
            SHQueryValueEx(hkey, TEXT("Wallpaper"), NULL, NULL, (LPBYTE)szWallpaper, (ULONG*)&cb);
            cb = sizeof(szPattern);
            SHQueryValueEx(hkey, TEXT("Pattern"), NULL, NULL, (LPBYTE)szPattern, (ULONG*)&cb);
            cb = sizeof(dwPaintVersion);
            SHQueryValueEx(hkey, TEXT("PaintDesktopVersion"), NULL, NULL, (LPBYTE)&dwPaintVersion, (ULONG*)&cb);

            // Other external criteria for painting the version
            //
            //  -   This is a beta version (has an expiration date)
            //  -   A test certificate is installed
            //
            if (dwPaintVersion == 0 && IsOS(OS_WIN2000ORGREATER))
            {
#define REGSTR_PATH_LM_ROOTCERTIFICATES \
        TEXT("SOFTWARE\\Microsoft\\SystemCertificates\\Root\\Certificates")
#define REGSTR_PATH_GPO_ROOTCERTIFICATES \
        TEXT("SOFTWARE\\Policies\\Microsoft\\SystemCertificates\\Root\\Certificates")
#define REGSTR_KEY_TESTCERTIFICATE \
        TEXT("2BD63D28D7BCD0E251195AEB519243C13142EBC3")

                dwPaintVersion = (0 != USER_SHARED_DATA->SystemExpirationDate.QuadPart) ||
                                 SHRegSubKeyExists(HKEY_LOCAL_MACHINE, REGSTR_PATH_LM_ROOTCERTIFICATES TEXT("\\") REGSTR_KEY_TESTCERTIFICATE) ||
                                 SHRegSubKeyExists(HKEY_LOCAL_MACHINE, REGSTR_PATH_GPO_ROOTCERTIFICATES TEXT("\\") REGSTR_KEY_TESTCERTIFICATE) ||
                                 SHRegSubKeyExists(HKEY_CURRENT_USER, REGSTR_PATH_GPO_ROOTCERTIFICATES TEXT("\\") REGSTR_KEY_TESTCERTIFICATE);
            }
            RegCloseKey(hkey);
        }

        if (_fCombinedView ||
            (GetSystemMetrics(SM_CLEANBOOT) == 0 &&
             GetSystemMetrics(SM_DEBUG) == 0 &&
             !dwPaintVersion &&
             (!_fHasDeskWallPaper) &&
             (szWallpaper[0] == 0 || szWallpaper[0] == TEXT('(')) &&
             (szPattern[0] == 0 || szPattern[0] == TEXT('('))))
        {
           clrWindow = GetSysColor(COLOR_BACKGROUND);
        }
    }
    else
    {
        // Nope.
        clrWindow = GetSysColor(COLOR_WINDOW);
        clrTextBk = clrWindow;
        clrText = GetSysColor(COLOR_WINDOWTEXT);

        if (_fs.fFlags & FWF_TRANSPARENT)
        {
            IWebBrowser2 *pwb;
            if (SUCCEEDED(IUnknown_QueryService(_psb, SID_SContainerDispatch, IID_PPV_ARG(IWebBrowser2, &pwb))))
            {
                IDispatch *pdisp;
                if (SUCCEEDED(pwb->get_Parent(&pdisp)))
                {
                    IUnknown_HTMLBackgroundColor(pdisp, &clrWindow);
                    pdisp->Release();
                }
                pwb->Release();
            }
        }
    }

    if (!_fClassic && ISVALIDCOLOR(_crCustomColors[CRID_CUSTOMTEXTBACKGROUND]))
        clrTextBk = _crCustomColors[CRID_CUSTOMTEXTBACKGROUND];

    if (!_fClassic && ISVALIDCOLOR(_crCustomColors[CRID_CUSTOMTEXT]))
        clrText = _crCustomColors[CRID_CUSTOMTEXT];

    BOOL bChange = FALSE;

    if (clrWindow != ListView_GetBkColor(_hwndListview))
        bChange = ListView_SetBkColor(_hwndListview, clrWindow);

    if (clrTextBk != ListView_GetTextBkColor(_hwndListview))
        bChange = ListView_SetTextBkColor(_hwndListview, clrTextBk);

    if (clrText != ListView_GetTextColor(_hwndListview))
        bChange = ListView_SetTextColor(_hwndListview, clrText);

    if (bChange)
        InvalidateRect(_hwndListview, NULL, TRUE);
}

#define ViewRequiresColumns(x)  ((x) == FVM_DETAILS || (x) == FVM_TILE)

DWORD CDefView::_LVStyleFromView()
{
    DWORD dwStyle;

    if (_IsDesktop())
    {
        dwStyle = LVS_NOSCROLL | LVS_ALIGNLEFT;
    }
    else
    {
        dwStyle = LVS_SHOWSELALWAYS;   // make sure selection is visible
    }

    // dwStyle |= _UxGetView();
    // The listview view is no longer set using the window style, so the call to the
    // view mapping code has been commented out.
    // APPCOMPAT: This may be an issue, if apps are depending the exstyle bits on the listview hwnd
    // in defview. If so, we can set them, but we must take care to exclude any bits outside the 2bit
    // "view range" in the extended style (namely, tile view)

    if (_IsAutoArrange())
        dwStyle |= LVS_AUTOARRANGE;

    if (_fs.fFlags & FWF_SINGLESEL)
        dwStyle |= LVS_SINGLESEL;

    if (_fs.fFlags & FWF_ALIGNLEFT)
        dwStyle |= LVS_ALIGNLEFT;

    if (_fs.fFlags & FWF_NOSCROLL)
        dwStyle |= LVS_NOSCROLL;

    return dwStyle;
}

DWORD CDefView::_LVExStyleFromView()
{
    DWORD dwLVExStyle = 0;

    if (_fs.fFlags & FWF_SNAPTOGRID)
        dwLVExStyle |= LVS_EX_SNAPTOGRID;

    if (_fs.fFlags & FWF_CHECKSELECT)
        dwLVExStyle |= LVS_EX_CHECKBOXES|LVS_EX_SIMPLESELECT;

    return dwLVExStyle;
}

HRESULT CDefView::_GetDetailsHelper(int i, DETAILSINFO *pdi)
{
    HRESULT hr = E_NOTIMPL;

    if (_pshf2)
    {
        hr = _pshf2->GetDetailsOf(pdi->pidl, i, (SHELLDETAILS *)&pdi->fmt);
    }

    if (FAILED(hr))   // Don't make NSEs impl all of IShellFolder2
    {
        if (_psd)
        {
            // HACK: pdi->fmt is the same layout as SHELLDETAILS
            hr = _psd->GetDetailsOf(pdi->pidl, i, (SHELLDETAILS *)&pdi->fmt);
        }
        else if (HasCB())
        {
            hr = CallCB(SFVM_GETDETAILSOF, i, (LPARAM)pdi);
        }
    }

    return hr;
}


// Determine if the given defview state struct has valid
// state info.  If is doesn't, this function massages the
// values so it does.

UINT CDefView::_GetHeaderCount()
{
    UINT cCols = 0;
    HWND hwndHead = ListView_GetHeader(_hwndListview);
    if (hwndHead)
    {
        cCols = Header_GetItemCount(hwndHead);
    }
    return cCols;
}

void CDefView::AddColumns()
{
    // so we do this once
    if (_bLoadedColumns)
        return;

    _bLoadedColumns = TRUE;

    // I also use this as a flag for whether to free pColHdr
    //
    // Calculate a reasonable size to initialize the column width to.

    _cxChar = GetControlCharWidth(_hwndListview);

    // Check whether there is any column enumerator (ShellDetails or callback)
    if (_psd || _pshf2 || HasCB())
    {
        // Some shell extensions return S_OK and NULL pstmCols.
        IStream *pstmCols = NULL;
        if (SUCCEEDED(CallCB(SFVM_GETCOLSAVESTREAM, STGM_READ, (LPARAM)&pstmCols)) && pstmCols)
        {
            _vs.LoadColumns(this, pstmCols);
            pstmCols->Release();
        }

        // Verify that this has been initialized. This may not be if there was no state stream.
        _vs.InitializeColumns(this);

        for (UINT i = 0; i < _vs.GetColumnCount(); ++i)
        {
            if (_IsColumnInListView(i))
            {
                UINT iVisible = _RealToVisibleCol(i);

                LV_COLUMN col;
                col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
                col.fmt = _vs.GetColumnFormat(i);

                // If column width is not specified in the desktop.ini.......
                col.cx = _vs.GetColumnWidth(iVisible, _vs.GetColumnCharCount(i) * _cxChar);
                col.pszText = _vs.GetColumnName(i);
                col.cchTextMax = MAX_COLUMN_NAME_LEN;
                col.iSubItem = i;

                if (col.fmt & LVCFMT_COL_HAS_IMAGES)
                {
                    ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_SUBITEMIMAGES, LVS_EX_SUBITEMIMAGES);
                    col.fmt &= ~LVCFMT_COL_HAS_IMAGES;
                }

                ListView_InsertColumn(_hwndListview, iVisible, &col);
            }
        }

        // Set the header control to have zero margin around bitmaps, for the sort arrows
        Header_SetBitmapMargin(ListView_GetHeader(_hwndListview), 0);

        ListView_SetExtendedListViewStyleEx(_hwndListview,
            LVS_EX_HEADERDRAGDROP | LVS_EX_LABELTIP,
            LVS_EX_HEADERDRAGDROP | LVS_EX_LABELTIP);

        //We added columns; so, just sync the Column order.
        _vs.SyncColumnOrder(this, TRUE);
    }

    // use real numbers, not visible
    int cCols = (int)_vs.GetColumnCount();
    if (_vs._iLastColumnClick >= cCols)
    {
        _vs.InitWithDefaults(this);

        if (_vs._iLastColumnClick >= cCols ||
            _vs._lParamSort >= cCols)
        {
            // our defaults won't work on this view....
            // hard code these defaults
            _vs._lParamSort = 0;
            _vs._iDirection = 1;
            _vs._iLastColumnClick = -1;
        }
    }
}

void CDefView::InitSelectionMode()
{
    _dwSelectionMode = 0;

    if (_fs.fFlags & FWF_SINGLECLICKACTIVATE)
    {
        _dwSelectionMode = LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE;
    }
    else if (!_fClassic)
    {
        SHELLSTATE ss;
        SHGetSetSettings(&ss, SSF_DOUBLECLICKINWEBVIEW, FALSE);

        if (!ss.fDoubleClickInWebView)
            _dwSelectionMode = LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE;
    }
}

void CDefView::_UpdateSelectionMode()
{
    InitSelectionMode();
    ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE, _dwSelectionMode);
}

DWORD _GetUnderlineStyles()
{
    DWORD dwUnderline = ICON_IE;

    // Read the icon underline settings.
    DWORD cb = sizeof(dwUnderline);
    SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                    TEXT("IconUnderline"), NULL, &dwUnderline, &cb, FALSE, &dwUnderline, cb);

    // If it says to use the IE link settings, read them in.
    if (dwUnderline == ICON_IE)
    {
        dwUnderline = ICON_YES;

        TCHAR szUnderline[8];
        cb = sizeof(szUnderline);
        SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                        TEXT("Anchor Underline"), NULL, szUnderline, &cb, FALSE, szUnderline, cb);

        // Convert the string to an ICON_ value.
        if (!lstrcmpi(szUnderline, TEXT("hover")))
            dwUnderline = ICON_HOVER;
        else if (!lstrcmpi(szUnderline, TEXT("no")))
            dwUnderline = ICON_NO;
        else
            dwUnderline = ICON_YES;
    }

    // Convert the ICON_ value into an LVS_EX value.
    DWORD dwExStyle;

    switch (dwUnderline)
    {
    case ICON_NO:
        dwExStyle = 0;
        break;

    case ICON_HOVER:
        dwExStyle = LVS_EX_UNDERLINEHOT;
        break;

    case ICON_YES:
        dwExStyle = LVS_EX_UNDERLINEHOT | LVS_EX_UNDERLINECOLD;
        break;
    }
    return dwExStyle;
}

void CDefView::_UpdateUnderlines()
{
    // Set the new LVS_EX_UNDERLINE flags.
    ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_UNDERLINEHOT | LVS_EX_UNDERLINECOLD, _GetUnderlineStyles());
}

void CDefView::_SetSysImageList()
{
    HIMAGELIST himlLarge, himlSmall;

    Shell_GetImageLists(&himlLarge, &himlSmall);
    ListView_SetImageList(_hwndListview, himlLarge, LVSIL_NORMAL);
    ListView_SetImageList(_hwndListview, himlSmall, LVSIL_SMALL);
}

void CDefView::_SetTileview()
{
    IImageList* piml;
    if (SUCCEEDED(SHGetImageList(SHIL_EXTRALARGE, IID_PPV_ARG(IImageList, &piml))))
    {
        ListView_SetImageList(_hwndListview, IImageListToHIMAGELIST(piml), LVSIL_NORMAL);
        piml->Release();
    }
}

LRESULT CDefView::_OnCreate(HWND hWnd)
{
    _hwndView = hWnd;
    _hmenuCur = NULL;
    _uState = SVUIA_DEACTIVATE;
    _hAccel = LoadAccelerators(HINST_THISDLL, MAKEINTRESOURCE(ACCEL_DEFVIEW));

    // Note that we are going to get a WM_SIZE message soon, which will
    // place this window correctly

    // Map the ViewMode to the proper listview style
    DWORD dwStyle = _LVStyleFromView() | LVS_EDITLABELS;
    DWORD dwExStyle = 0;

    // If the parent window is mirrored then the treeview window will inheret the mirroring flag
    // And we need the reading order to be Left to right, which is the right to left in the mirrored mode.

    if (IS_WINDOW_RTL_MIRRORED(hWnd))
    {
        // This means left to right reading order because this window will be mirrored.
        dwExStyle |= WS_EX_RTLREADING;
    }

    // don't set this as in webview this is normally off, having this
    // set causes a 3d edge to flash on in a refresh
    if (!_ShouldShowWebView() && !_IsDesktop() && !(_fs.fFlags & FWF_NOCLIENTEDGE))
    {
        dwExStyle |= WS_EX_CLIENTEDGE;
    }

    if (_IsOwnerData())
        dwStyle |= LVS_OWNERDATA;

    _hwndListview = CreateWindowEx(dwExStyle, WC_LISTVIEW, TEXT("FolderView"),      // MSAA name
            dwStyle | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | LVS_SHAREIMAGELISTS,
            0, 0, 0, 0, hWnd, (HMENU)ID_LISTVIEW, HINST_THISDLL, NULL);
    if (_hwndListview)
    {
        // Set up non-viewmode-dependant listview information here.
        // Other flags are set up in _SwitchToViewFVM

        DWORD dwLVExStyle = _LVExStyleFromView() | LVS_EX_INFOTIP | LVS_EX_LABELTIP;

        if (_IsDesktop())
        {
            if (GetNumberOfMonitors() > 1)
                dwLVExStyle |= LVS_EX_MULTIWORKAREAS;
        }
        else
        {
            dwLVExStyle |= LVS_EX_DOUBLEBUFFER;  // Enable double buffering for all but desktop for affects
        }

        // turn on infotips -- window was just created, so all LVS_EX bits are off
        ListView_SetExtendedListViewStyle(_hwndListview, dwLVExStyle);

        // Get the proper RTL bits to pass on to our child windows
        _fmt = 0;
        // Be sure that the OS is supporting the flags DATE_LTRREADING and DATE_RTLREADING
        if (g_bBiDiPlatform)
        {
            // Get the date format reading order
            LCID locale = GetUserDefaultLCID();
            if ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC))
            {
                // Get the real list view windows ExStyle.
                // [msadek]; we shouldn't check for either WS_EX_RTLREADING OR RTL_MIRRORED_WINDOW
                // on localized builds we have both of them to display dirve letters,..etc correctly
                // on enabled builds we have none of them. let's check on RTL_MIRRORED_WINDOW only

                if (GetWindowLong(_hwndListview, GWL_EXSTYLE) & RTL_MIRRORED_WINDOW)
                    _fmt = LVCFMT_RIGHT_TO_LEFT;
                else
                    _fmt = LVCFMT_LEFT_TO_RIGHT;
            }
        }

        // Get hwndInfotip (the control for all listview infotips).
        HWND hwndInfotip = ListView_GetToolTips(_hwndListview);
        if (hwndInfotip)
        {
            // make the tooltip window  to be topmost window (set the TTS_TOPMOST style bit for the tooltip)
            SetWindowPos(hwndInfotip, HWND_TOPMOST, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

            // Initialize hwndInfotip.
            _InitInfotipControl(hwndInfotip);
        }

        _UpdateUnderlines();

        // IShellDetails for old callers, new guys use IShellFolder2
        ASSERT(_psd == NULL);
        _pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IShellDetails, &_psd));

        // App compat - some apps need columns loaded first thing
        if (SHGetAppCompatFlags(ACF_LOADCOLUMNHANDLER) & ACF_LOADCOLUMNHANDLER)
        {
            AddColumns();
        }

        _SetFolderColors();
    }

    // Create _hwndInfotip (the control for all non-listview infotips).
    _hwndInfotip = _CreateInfotipControl(hWnd);
    if (_hwndInfotip)
    {
        // Initialize _hwndInfotip.
        _InitInfotipControl(_hwndInfotip);
    }

    return _hwndListview ? 0 : -1;  // 0 is success, -1 is failure from WM_CREATE
}

HWND CDefView::_CreateInfotipControl(HWND hwndParent)
{
    // hwndInfotip is currently expected to be destroyed by destruction of
    // the parent hwnd (hwndParent).  Thus, hwndParent should not be NULL.
    ASSERT(hwndParent != NULL); // Sanity check.

    // Create hwndInfotip.
    return ::CreateWindowEx(
        IS_WINDOW_RTL_MIRRORED(hwndParent) || IS_BIDI_LOCALIZED_SYSTEM()
            ? WS_EX_LAYOUTRTL
            : 0,
        TOOLTIPS_CLASS,
        NULL,
        0,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        hwndParent,
        NULL,
        g_hinst,
        NULL);
}

void CDefView::_InitInfotipControl(HWND hwndInfotip)
{
    ASSERT(hwndInfotip);

    // Set the length of time the pointer must remain stationary within a tool's
    // bounding rectangle before the ToolTip window appears to 2 times the default.
    INT iTime = ::SendMessage(hwndInfotip, TTM_GETDELAYTIME, TTDT_INITIAL, 0);
    ::SendMessage(hwndInfotip, TTM_SETDELAYTIME, TTDT_INITIAL, (LPARAM)(INT)MAKELONG(iTime * 2, 0));

    // Set the length of time a ToolTip window remains visible if the pointer
    // is stationary within a tool's bounding rectangle to a very large value.
    ::SendMessage(hwndInfotip, TTM_SETDELAYTIME, TTDT_AUTOPOP, (LPARAM)(INT)MAKELONG(MAXSHORT, 0));
}

// "Auto" AutoArrange means re-position if we are in a positioned view
// and the listview is not in auto-arrange mode. we do this to re-layout
// the icons in cases where that makes sense

HRESULT CDefView::_AutoAutoArrange(DWORD dwReserved)
{
    if (!_fUserPositionedItems && _IsPositionedView() &&
        !(GetWindowStyle(_hwndListview) & LVS_AUTOARRANGE))
    {
        ListView_Arrange(_hwndListview, LVA_DEFAULT);
    }
    return S_OK;
}

LRESULT CDefView::WndSize(HWND hWnd)
{
    RECT rc;

    // We need to dismiss "name edit" mode, if we are in.
    _DismissEdit();

    // Get the client size.
    GetClientRect(hWnd, &rc);

    // Set the Static to be the Client size.
    if (_hwndStatic)
    {
        MoveWindow(_hwndStatic, rc.left, rc.top,
            rc.right-rc.left, rc.bottom-rc.top, TRUE);

        HWND hAnimate = ::GetWindow (_hwndStatic, GW_CHILD);

        if (hAnimate)
        {
            MoveWindow(hAnimate, rc.left, rc.top,
                rc.right-rc.left, rc.bottom-rc.top, TRUE);
        }

        RedrawWindow(_hwndStatic, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
    }

    // Set all windows to their new rectangles.

    _cFrame.SetRect(&rc);

    // Don't resize _hwndListview if a DefViewOC is using it.
    //
    // If we're waiting for a Web View (!_fCanActivateNow), then it
    // doesn't make sense to resize the _hwndListview -- just extra
    // work, right?  But in the non-WebView case, it's this first
    // resize which sets the listview size, and then there are no
    // more.  Unfortunately, the first resize comes in when the
    // _hwndListview is created, which is *before* _fCanActivateNow
    // can possibly be set.

    if (!_fGetWindowLV && !_pDUIView)
    {
        SetWindowPos(_hwndListview, NULL, rc.left, rc.top,
            rc.right - rc.left, rc.bottom - rc.top, SWP_NOZORDER | SWP_NOACTIVATE);
        OnResizeListView();
    }

    if (_pDUIView)
    {
        _pDUIView->SetSize (&rc);
        _AutoAutoArrange(0);
    }

    CallCB(SFVM_SIZE, 0, 0);
    return 1;
}


UINT _GetMenuIDFromViewMode(UINT uViewMode)
{
    ASSERTMSG(FVM_FIRST <= uViewMode && uViewMode <= FVM_LAST, "_GetMenuIDFromViewMode received unknown uViewMode");
    return SFVIDM_VIEW_FIRSTVIEW + uViewMode - FVM_FIRST;
}

void CDefView::CheckToolbar()
{
    if (SHGetAppCompatFlags(ACF_WIN95DEFVIEW) & ACF_WIN95DEFVIEW)
    {
        int idCmdCurView = _GetMenuIDFromViewMode(_fs.ViewMode);

        // preserve win95 behavior for dumb corel apps
        for (int idCmd = SFVIDM_VIEW_ICON; idCmd <= SFVIDM_VIEW_DETAILS; idCmd++)
        {
            _psb->SendControlMsg(
                FCW_TOOLBAR, TB_CHECKBUTTON, idCmd, (LPARAM)(idCmd == idCmdCurView), NULL);
        }
    }
}

void CDefView::OnListViewDelete(int iItem, LPITEMIDLIST pidlToFree, BOOL fCallCB)
{
    LPCITEMIDLIST pidlReal = _GetPIDLParam((LPARAM)pidlToFree, iItem);

    if (fCallCB)
    {
        CallCB(SFVM_DELETEITEM, 0, (LPARAM)pidlReal);
    }

    ILFree(pidlToFree); // NULL in owner data case
}

// NOTE: many keys are handled as accelerators

void CDefView::HandleKeyDown(LV_KEYDOWN *pnmhdr)
{
    // REVIEW: these are things not handled by accelerators, see if we can
    // make them all based on accelerators

    switch (pnmhdr->wVKey)
    {
    case VK_ESCAPE:
        if (_bHaveCutStuff)
            OleSetClipboard(NULL);
        break;
    }
}

// This function checks to see if we are in virtual mode or not.  If we are in
// virtual mode, we always need to ask our folder we are viewing for the item and
// not the listview.

LPCITEMIDLIST CDefView::_GetPIDL(int i)
{
    if (_IsOwnerData())
    {
        LPCITEMIDLIST pidl = NULL;
        CallCB(SFVM_GETITEMIDLIST, i, (LPARAM)&pidl);
        return pidl;
    }

    return (LPCITEMIDLIST)LVUtil_GetLParam(_hwndListview, i);
}

LPCITEMIDLIST CDefView::_GetPIDLParam(LPARAM lParam, int i)
{
    return lParam ? (LPCITEMIDLIST)lParam : _GetPIDL(i);
}

// returns an array of LPCITEMIDLIST for objects in the view (selected or all)
// the "focused" item is always in array entry 0. this array contains poitners to pidls
// owned stored in the listview, so YOU SHOULD NOT FREE THEM OR MESS WITH THEM IN ANYWAY.
// this also implies the lifetime of this array must be shorter than the listview
// data it points to. that is if the view changes under you you are hosed.
//
// Notes: this function returns LP*C*ITEMIDLIST. The caller is not
//  supposed alter or delete them. Their lifetime are very short (until the
//  list view is modified).

typedef struct
{
    LPCITEMIDLIST pidl;
    POINT pt;
    int iItem;
} POS_SORT_INFO;

// standard compare returns
// -1 1 < 2
//  0 1 = 2
//  1 1 > 2
//
// NOTE: in the RTL_MIRRORED_WINDOW case the coords are reversed for us

int _CmpTopToBottomLeftToRight(POS_SORT_INFO *psi1, POS_SORT_INFO *psi2, LPARAM lParam)
{
    int iCmp = psi1->pt.y - psi2->pt.y;
    if (0 == iCmp)
    {
        iCmp = psi1->pt.x - psi2->pt.x;
    }
    return iCmp;
}

int _CmpLeftToRightTopToBottom(POS_SORT_INFO *psi1, POS_SORT_INFO *psi2, LPARAM lParam)
{
    int iCmp = psi1->pt.x - psi2->pt.x;
    if (0 == iCmp)
    {
        iCmp = psi1->pt.y - psi2->pt.y;
    }
    return iCmp;
}

CDPA<POS_SORT_INFO>::_PFNDPACOMPARE _GetSortFunction(HWND hwndListview)
{
    if (GetWindowStyle(hwndListview) & LVS_ALIGNLEFT)
    {
        return _CmpLeftToRightTopToBottom;  // desktop LV_VIEW_ICON case
    }
    else
    {
        UINT uViewMode = ListView_GetView(hwndListview);
        switch (uViewMode)
        {
        case LV_VIEW_DETAILS:
        case LV_VIEW_LIST:
            return _CmpLeftToRightTopToBottom;

        case LV_VIEW_TILE:
        case LV_VIEW_ICON:
        default:
            return _CmpTopToBottomLeftToRight;
        }
    }
}

UINT CDefView::_GetItemArray(LPCITEMIDLIST apidl[], UINT capidl, UINT uWhat)
{
    UINT cItems = 0;

    if ((uWhat & SVGIO_TYPE_MASK) == SVGIO_SELECTION)
    {
        cItems = ListView_GetSelectedCount(_hwndListview);
    }
    else if ((uWhat & SVGIO_TYPE_MASK) == SVGIO_CHECKED)
    {
        int iItem = ListView_GetItemCount(_hwndListview) - 1;
        for (; iItem >= 0; iItem--)
        {
            if (ListView_GetCheckState(_hwndListview, iItem))
                cItems++;
        }
    }
    else 
    {
        cItems = ListView_GetItemCount(_hwndListview);
    }

    if (apidl)
    {
        UINT uType = (SVGIO_SELECTION == (uWhat & SVGIO_TYPE_MASK)) ? LVNI_SELECTED : LVNI_ALL;
        BOOL bArrayFilled = FALSE;   // gets set on success of the sort code path

        // optimize the 1 case, the sort below is not needed
        if (!(SVGIO_FLAG_VIEWORDER & uWhat) && (capidl > 1))
        {
            CDPA<POS_SORT_INFO> dpaItemInfo;

            // pick a grow size of capidl so that we get a single alloc
            // when we add the first item to the array

            if (dpaItemInfo.Create(capidl))
            {
                POS_SORT_INFO *ppsi = new POS_SORT_INFO[capidl];
                if (ppsi)
                {
                    UINT iDPAIndex = 0;
                    for (int iListView = ListView_GetNextItem(_hwndListview, -1, uType);
                         (iListView >= 0) && (iDPAIndex < capidl);
                         iListView = ListView_GetNextItem(_hwndListview, iListView, uType))
                    {
                        // if we want checked then it must be checked, otherwise just return (or skip)
                        if ((SVGIO_CHECKED != (uWhat & SVGIO_TYPE_MASK)) || ListView_GetCheckState(_hwndListview, iListView))
                        {
                            ppsi[iDPAIndex].pidl = _GetPIDL(iListView);
                            ppsi[iDPAIndex].iItem = iListView;
                            ListView_GetItemPosition(_hwndListview, iListView, &ppsi[iDPAIndex].pt);

                            // this may fail, but we catch that case below
                            dpaItemInfo.SetPtr(iDPAIndex, &ppsi[iDPAIndex]);
                            iDPAIndex++;
                        }
                    }

                    // make sure the DPA got all of the items, if not
                    // we fall through to the unsorted case

                    if (dpaItemInfo.GetPtrCount() == capidl)
                    {
                        dpaItemInfo.Sort(_GetSortFunction(_hwndListview), 0);

                        int iFirstItem = ListView_GetNextItem(_hwndListview, -1, LVNI_FOCUSED);

                        // compute the start index in the dpa based on iFirstItem. this is to
                        // rotate the array so that iFirstItem is first in the list

                        for (iDPAIndex = 0; iDPAIndex < (UINT)dpaItemInfo.GetPtrCount(); iDPAIndex++)
                        {
                            if (dpaItemInfo.FastGetPtr(iDPAIndex)->iItem == iFirstItem)
                            {
                                break;  // iDPAIndex setup for loop below
                            }
                        }

                        for (int i = 0; i < dpaItemInfo.GetPtrCount(); i++, iDPAIndex++)
                        {
                            if (iDPAIndex >= (UINT)dpaItemInfo.GetPtrCount())
                                iDPAIndex = 0;  // wrap back to zero

                            apidl[i] = dpaItemInfo.FastGetPtr(iDPAIndex)->pidl;
                        }
                        bArrayFilled = TRUE; // we have the results we want

                        delete [] ppsi;
                    }
                }
                dpaItemInfo.Destroy();
            }
        }

        if (!bArrayFilled)
        {
            UINT i = 0;
            for (int iListView = ListView_GetNextItem(_hwndListview, -1, uType);
                 (iListView >= 0) && (i < capidl);
                 iListView = ListView_GetNextItem(_hwndListview, iListView, uType))
            {
                // if we want checked then it must be checked, otherwise just return (or skip)
                if ((SVGIO_CHECKED != (uWhat & SVGIO_TYPE_MASK)) || ListView_GetCheckState(_hwndListview, iListView))
                {
                    apidl[i++] = _GetPIDL(iListView);
                }
            }
        }
    }
    return cItems;
}

//
// get the array of IDList from the selection and calls
// IShellFolder::GetUIObjectOf member to get the specified UI object
// interface.
//
HRESULT CDefView::_GetUIObjectFromItem(REFIID riid, void **ppv, UINT uWhat, BOOL fSetPoints)
{
    LPCITEMIDLIST *apidl;
    UINT cItems;
    HRESULT hr;

    if (SVGIO_SELECTION == (uWhat & SVGIO_TYPE_MASK))
    {
        hr = GetSelectedObjects(&apidl, &cItems);
    }
    else
    {
        hr = _GetItemObjects(&apidl, uWhat, &cItems);
    }

    if (SUCCEEDED(hr))
    {
        if (cItems)
        {
            hr = _pshf->GetUIObjectOf(_hwndMain, cItems, apidl, riid, 0, ppv);
            if (SUCCEEDED(hr) && (IID_IDataObject == riid) && fSetPoints)
            {
                _SetPoints(cItems, apidl, (IDataObject *)*ppv);
            }
            LocalFree((HLOCAL)apidl);
        }
        else
            hr = E_INVALIDARG;
    }
    return hr;
}

// If the browser has a Tree then we want to use explore.
UINT CDefView::_GetExplorerFlag()
{
    return IsExplorerBrowser(_psb) ? CMF_EXPLORE : 0;
}

// creates a selection object out of the current selection.
IShellItemArray* CDefView::_CreateSelectionShellItemArray(void)
{
    IShellItemArray *pSelectionObj = NULL;
    LPCITEMIDLIST *apidl;
    UINT cItems;

    if (SUCCEEDED(_GetItemObjects(&apidl, SVGIO_SELECTION | SVGIO_FLAG_VIEWORDER, &cItems)) && cItems)
    {
        SHCreateShellItemArray(NULL, _pshf, cItems, apidl, &pSelectionObj);
        LocalFree(apidl);
    }
    return pSelectionObj;
}

DWORD CDefView::_AttributesFromSel(DWORD dwAttributesNeeded)
{
    // If this gets hit then chances are it's a performance problem...
    //
    if (_fSelectionChangePending)
    {
        TraceMsg(TF_WARNING, "Potential perf badness: may be asking for attributes during OnLVNUpdateItem!");
        if (_pSelectionShellItemArray)
            ATOMICRELEASE(_pSelectionShellItemArray);
       _pSelectionShellItemArray = _CreateSelectionShellItemArray();
    }

    DWORD dwAttributes = 0;
    if (_pSelectionShellItemArray)
    {
        _pSelectionShellItemArray->GetAttributes(SIATTRIBFLAGS_APPCOMPAT, dwAttributesNeeded, &dwAttributes);
    }
    return dwAttributes;
}


// IContextMenuSite:
// Defview's context menu implementation isn't very clean.  As a temporary step towards
// cleaning it up (CONTEXT and BACK_CONTEXT are intermingled), use the new DOCONTEXTMENUPOPUP range
//
HRESULT CDefView::DoContextMenuPopup(IUnknown* punkCM, UINT fFlags, POINT pt)
{
    return _DoContextMenuPopup(punkCM, fFlags, pt, FALSE);
}

HRESULT CDefView::_DoContextMenuPopup(IUnknown* punk, UINT fFlags, POINT pt, BOOL fListviewItem)
{
    IContextMenu* pcm;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IContextMenu, &pcm));
    if (SUCCEEDED(hr))
    {
        hr = E_OUTOFMEMORY;

        HMENU hmContext = CreatePopupMenu();
        if (hmContext)
        {
            fFlags |= _GetExplorerFlag();

            if (0 > GetKeyState(VK_SHIFT))
                fFlags |= CMF_EXTENDEDVERBS;

            IContextMenu3* pcm3;
            if (SUCCEEDED(pcm->QueryInterface(IID_PPV_ARG(IContextMenu3, &pcm3))))
            {
                fFlags |= CMF_ICM3;
                pcm3->Release();
            }

            // Give the context menu a site if it doesn't have one already
            IUnknown* punkSite;
            if (SUCCEEDED(IUnknown_GetSite(pcm, IID_PPV_ARG(IUnknown, &punkSite))))
            {
                punkSite->Release();
            }
            else
            {
                IUnknown_SetSite(pcm, SAFECAST(this, IShellView2*));
            }

            hr = pcm->QueryContextMenu(hmContext, 0, SFVIDM_BACK_CONTEXT_FIRST, SFVIDM_BACK_CONTEXT_LAST, fFlags);
            if (SUCCEEDED(hr))
            {
                // Must preinitialize to NULL; Adaptec Easy CD Creator 3.5 does not
                // null out the pointer on failure.
                ICommDlgBrowser2 *pcdb2 = NULL;
                _psb->QueryInterface(IID_PPV_ARG(ICommDlgBrowser2, &pcdb2));


                // If this is the common dialog browser, we need to make the
                // default command "Select" so that double-clicking (which is
                // open in common dialog) makes sense.
                if (_IsCommonDialog())
                {
                    // make sure this is an item
                    if (fListviewItem)
                    {
                        HMENU hmSelect = SHLoadPopupMenu(HINST_THISDLL, POPUP_COMMDLG_POPUPMERGE);

                        // If we have a pointer to the ICommDlgBrowser2 interface
                        // query if this interface wants to change the text of the
                        // default verb.  This interface is needed in the common print
                        // dialog to change the default text from 'Select' to 'Print'.
                        if (pcdb2)
                        {
                            WCHAR szTextW[MAX_PATH] = {0};

                            if (pcdb2->GetDefaultMenuText(this, szTextW, ARRAYSIZE(szTextW)) == S_OK)
                            {
                                MENUITEMINFO mi = {0};
                                mi.cbSize       = sizeof(mi);
                                mi.fMask        = MIIM_TYPE;
                                mi.fType        = MFT_STRING;
                                mi.dwTypeData   = szTextW;
                                SetMenuItemInfo(hmSelect, 0, MF_BYPOSITION, &mi);
                            }
                        }

                        // NOTE: Since commdlg always eats the default command,
                        // we don't care what id we assign hmSelect, as long as it
                        // doesn't conflict with any other context menu id.
                        // SFVIDM_CONTEXT_FIRST-1 won't conflict with anyone.
                        Shell_MergeMenus(hmContext, hmSelect, 0,
                                        (UINT)(SFVIDM_BACK_CONTEXT_FIRST-1), (UINT)-1,
                                        MM_ADDSEPARATOR);

                        SetMenuDefaultItem(hmContext, 0, MF_BYPOSITION);
                        DestroyMenu(hmSelect);
                    }
                }

                _SHPrettyMenu(hmContext);


                // If this is the common dialog browser 2, we need inform it
                // the context menu is has started.  This notifiction is use in
                // the common print dialog on NT which hosts the printers folder.
                // Common dialog want to relselect the printer object if the user
                // selected the context menu from the background.
                if (pcdb2)
                {
                    pcdb2->Notify(this, CDB2N_CONTEXTMENU_START);
                }

                // To reduce some menu message forwarding, throw away _pcmFile if we have one
                // (Since we can't have a TrackPopupMenu and a File menu open at the same time)
                IUnknown_SetSite(_pcmFile, NULL);
                ATOMICRELEASE(_pcmFile);

                // stash pcm in _pcmContextMenuPopup so we can forward menu messages
                ASSERT(NULL==_pcmContextMenuPopup);
                _pcmContextMenuPopup = pcm;
                _pcmContextMenuPopup->AddRef();

                int idDefault = GetMenuDefaultItem(hmContext, MF_BYCOMMAND, 0);
                int idCmd = TrackPopupMenu(hmContext,
                    TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                    pt.x, pt.y, 0, _hwndView, NULL);

                ATOMICRELEASE(_pcmContextMenuPopup);

                if ((idCmd == idDefault) &&
                    _OnDefaultCommand() == S_OK)
                {
                    // commdlg browser ate the default command
                }
                else if (idCmd == 0)
                {
                    // No item selected
                }
                else if (idCmd >= SFVIDM_BACK_CONTEXT_FIRST && idCmd <= SFVIDM_BACK_CONTEXT_LAST)
                {
                    idCmd -= SFVIDM_BACK_CONTEXT_FIRST;

                    // We need to special case the rename command (just in case a legacy contextmenu impl relied on this behavior)
                    TCHAR szCommandString[64];
                    ContextMenu_GetCommandStringVerb(pcm, idCmd, szCommandString, ARRAYSIZE(szCommandString));
                    if (lstrcmpi(szCommandString, c_szRename) == 0)
                    {
                        DoRename();
                    }
                    else
                    {
                        CMINVOKECOMMANDINFOEX ici = { 0 };

                        ici.cbSize = sizeof(ici);
                        ici.hwnd = _hwndMain;
                        ici.lpVerb = IntToPtr_(LPCSTR, idCmd);
                        ici.nShow = SW_NORMAL;
                        ici.ptInvoke = pt;
                        ici.fMask |= CMIC_MASK_PTINVOKE | CMIC_MASK_FLAG_LOG_USAGE;

                        // record if shift or control was being held down
                        SetICIKeyModifiers(&ici.fMask);

                        _InvokeContextMenu(pcm, &ici);
                    }
                }
                else
                {
                    RIPMSG(FALSE, "CDefView::DoContextMenuPopup - Some IContextMenu inserted an ID out of our range.  Ignoring.");
                }

                // If this is the common dialog browser 2, we need inform it
                // the context menu is done.  This notifiction is use in
                // the common print dialog on NT which hosts the printers folder.
                // Common dialog want to relselect the printer object if the user
                // selected the context menu from the background.
                if (pcdb2)
                {
                    pcdb2->Notify(this, CDB2N_CONTEXTMENU_DONE);
                    pcdb2->Release();
                }
            }

            DestroyMenu(hmContext);
        }

        // Always remove the site even if we didn't set it -- once used, the IContextMenu is dead.
        IUnknown_SetSite(pcm, NULL);

        pcm->Release();
    }

    return hr;
}

void CDefView::ContextMenu(DWORD dwPos)
{
    int iItem;
    UINT fFlags = 0;
    POINT pt;

    if (SHRestricted(REST_NOVIEWCONTEXTMENU))
    {
        return;
    }

    // if shell32's global copy of the stopwatch mode is not init'd yet, init it now.
    if (g_dwStopWatchMode == 0xffffffff)
        g_dwStopWatchMode = StopWatchMode();

    if (g_dwStopWatchMode)
        StopWatch_Start(SWID_MENU, TEXT("Defview ContextMenu Start"), SPMODE_SHELL | SPMODE_DEBUGOUT);

    if (IsWindowVisible(_hwndListview) && (IsChildOrSelf(_hwndListview, GetFocus()) == S_OK))
    {
        // Find the selected item
        iItem = ListView_GetNextItem(_hwndListview, -1, LVNI_SELECTED);
    }
    else
    {
        iItem = -1;
    }

    if (dwPos == (DWORD) -1)
    {
        if (iItem != -1)
        {
            RECT rc;
            int iItemFocus = ListView_GetNextItem(_hwndListview, -1, LVNI_FOCUSED|LVNI_SELECTED);
            if (iItemFocus == -1)
                iItemFocus = iItem;

            //
            // Note that LV_GetItemRect returns it in client coordinate!
            //
            ListView_GetItemRect(_hwndListview, iItemFocus, &rc, LVIR_ICON);
            pt.x = (rc.left + rc.right) / 2;
            pt.y = (rc.top + rc.bottom) / 2;
        }
        else
        {
            pt.x = pt.y = 0;
        }
        MapWindowPoints(_hwndListview, HWND_DESKTOP, &pt, 1);
    }
    else
    {
        pt.x = GET_X_LPARAM(dwPos);
        pt.y = GET_Y_LPARAM(dwPos);
    }

    IContextMenu* pcm;
    LPARAM uemEvent;
    if (iItem == -1)
    {
        DECLAREWAITCURSOR;
        SetWaitCursor();

        // use the background context menu wrapper
        GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARG(IContextMenu, &pcm));

        ResetWaitCursor();

        // set the max range for these, so that they are unaffected...
        uemEvent = _IsDesktop() ? UIBL_CTXTDESKBKGND : UIBL_CTXTDEFBKGND;
    }
    else
    {
        fFlags |= CMF_CANRENAME;

        // One or more items are selected, let the folder add menuitems.
        _CreateSelectionContextMenu(IID_PPV_ARG(IContextMenu, &pcm));

        uemEvent = _IsDesktop() ? UIBL_CTXTDESKITEM : UIBL_CTXTDEFITEM;
    }

    UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UICONTEXT, uemEvent);

    if (g_dwStopWatchMode)
        StopWatch_Stop(SWID_MENU, TEXT("Defview ContextMenu Stop (!SafeToDefaultVerb)"), SPMODE_SHELL | SPMODE_DEBUGOUT);

    if (IsSafeToDefaultVerb() && pcm)
    {
        _DoContextMenuPopup(pcm, fFlags, pt, iItem != -1);
    }

    ATOMICRELEASE(pcm);
}

BOOL CDefView::_GetItemSpacing(ITEMSPACING *pis)
{
    DWORD dwSize = ListView_GetItemSpacing(_hwndListview, TRUE);
    pis->cxSmall = GET_X_LPARAM(dwSize);
    pis->cySmall = GET_Y_LPARAM(dwSize);
    dwSize = ListView_GetItemSpacing(_hwndListview, FALSE);
    pis->cxLarge = GET_X_LPARAM(dwSize);
    pis->cyLarge = GET_Y_LPARAM(dwSize);

    return _fs.ViewMode != FVM_ICON;
}

BOOL _DidDropOnRecycleBin(IDataObject *pdtobj)
{
    CLSID clsid;
    return SUCCEEDED(DataObj_GetDropTarget(pdtobj, &clsid)) &&
           IsEqualCLSID(clsid, CLSID_RecycleBin);
}

void CDefView::_SetPoints(UINT cidl, LPCITEMIDLIST *apidl, IDataObject *pdtobj)
{
    POINT pt;
    GetDragPoint(&pt);

    ::SetPositionItemsPoints(SAFECAST(this, IFolderView*), apidl, cidl, pdtobj, &pt);
}

LRESULT CDefView::_OnBeginDrag(NM_LISTVIEW * pnm)
{
    POINT ptOffset = pnm->ptAction;             // hwndLV client coords

    // This DefView is used as a drag source so we need to see if it's
    // is hosted by something that can disguise the action.
    if (S_OK != _ZoneCheck(PUAF_NOUI, URLACTION_SHELL_WEBVIEW_VERB))
    {
        // This DefView is hosted in HTML, so we need to turn off the
        // ability of this defview from being a drag source.
        return 0;
    }

    _OnDelayedSelectionChange();

    if (FAILED(_FireEvent(DISPID_BEGINDRAG)))   // script canceles dragging
        return 0;

    DWORD dwEffect = _AttributesFromSel(SFGAO_CANDELETE | DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY);

    // Turn on DROPEFFECT_MOVE for any deleteable item
    // (this is so the item can be dragged to the recycle bin)
    if (SFGAO_CANDELETE & dwEffect)
    {
        dwEffect |= DROPEFFECT_MOVE;
    }
    // Mask out all attribute bits that aren't also DROPEFFECT bits:
    dwEffect &= (DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY);

    // Somebody began dragging in our window, so store that fact
    _bDragSource = TRUE;

    // save away the anchor point
    _ptDragAnchor = pnm->ptAction;
    LVUtil_ClientToLV(_hwndListview, &_ptDragAnchor);

    ClientToScreen(_hwndListview, &ptOffset);     // now in screen

    // can't use _pdoSelection here since we need fSetPoints
    IDataObject *pdtobj;
    if (SUCCEEDED(_GetUIObjectFromItem(IID_PPV_ARG(IDataObject, &pdtobj), SVGIO_SELECTION, TRUE)))
    {
        // Give the source a chance to alter the drop effect.
        CallCB(SFVM_ALTERDROPEFFECT, (WPARAM)&dwEffect, (LPARAM)pdtobj);

        if (DAD_SetDragImageFromWindow(_hwndListview, &ptOffset, pdtobj))
        {
            if (DRAGDROP_S_DROP == SHDoDragDrop(_hwndMain, pdtobj, NULL, dwEffect, &dwEffect))
            {
                if (S_OK != CallCB(SFVM_DIDDRAGDROP, (WPARAM)dwEffect, (LPARAM)pdtobj))
                {
                    // the return of DROPEFFECT_MOVE tells us we need to delete the data
                    // see if we need to do that now...

                    // NOTE: we can't trust the dwEffect return result from DoDragDrop() because
                    // some apps (adobe photoshop) return this when you drag a file on them that
                    // they intend to open. so we invented the "PreformedEffect" as a way to
                    // know what the real value is, that is why we test both of these.

                    if ((DROPEFFECT_MOVE == dwEffect) &&
                        (DROPEFFECT_MOVE == DataObj_GetDWORD(pdtobj, g_cfPerformedDropEffect, DROPEFFECT_NONE)))
                    {
                        // enable UI for the recycle bin case (the data will be lost
                        // as the recycle bin really can't recycle stuff that is not files)

                        UINT uFlags = _DidDropOnRecycleBin(pdtobj) ? 0 : CMIC_MASK_FLAG_NO_UI;
                        SHInvokeCommandOnDataObject(_hwndMain, NULL, pdtobj, uFlags,c_szDeleteA);
                    }
                }
            }

            //
            // We need to clear the dragged image only if we still have the drag context.
            //
            DAD_SetDragImage((HIMAGELIST)-1, NULL);
        }
        pdtobj->Release();
    }
    _bDragSource = FALSE;  // All done dragging
    return 0;
}

void CDefView::_FocusOnSomething(void)
{
    int iFocus = ListView_GetNextItem(_hwndListview, -1, LVNI_FOCUSED);
    if (iFocus == -1)
    {
        if (ListView_GetItemCount(_hwndListview) > 0)
        {
            // set the focus on the first item.
            ListView_SetItemState(_hwndListview, 0, LVIS_FOCUSED, LVIS_FOCUSED);
        }
    }
}

HRESULT CDefView::_InvokeContextMenu(IContextMenu *pcm, CMINVOKECOMMANDINFOEX *pici)
{
    TCHAR szWorkingDir[MAX_PATH];
    CHAR szWorkingDirAnsi[MAX_PATH];

    if (SUCCEEDED(CallCB(SFVM_GETWORKINGDIR, ARRAYSIZE(szWorkingDir), (LPARAM)szWorkingDir)))
    {
        // Fill in both the ansi working dir and the unicode one
        // since we don't know who's gonna be processing this thing.
        SHUnicodeToAnsi(szWorkingDir, szWorkingDirAnsi, ARRAYSIZE(szWorkingDirAnsi));
        pici->lpDirectory  = szWorkingDirAnsi;
        pici->lpDirectoryW = szWorkingDir;
        pici->fMask |= CMIC_MASK_UNICODE;
    }

    // In case the ptInvoke field was not already set for us, guess where
    // that could be. (dli) maybe should let the caller set all points
    if (!(pici->fMask & CMIC_MASK_PTINVOKE))
    {
        if (GetCursorPos(&pici->ptInvoke))
            pici->fMask |= CMIC_MASK_PTINVOKE;
    }

    pici->fMask |= CMIC_MASK_ASYNCOK;

    _OnDelayedSelectionChange();

    HRESULT hr = _FireEvent(DISPID_VERBINVOKED);
    if (SUCCEEDED(hr))
        hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)pici);
    return hr;
}

DWORD CDefView::_GetNeededSecurityAction(void)
{
    DWORD dwUrlAction = 0;

    // this blanks out everything that has SFGAO_FOLDER -- what about zip/cab?
    // this check is used in context menu ops to see if the default verb is
    // trusted -- for the zip/cab case, we DO trust the default verb since we
    // expose them as folders throughout the rest of the shell.
    if (!(SFGAO_FOLDER & _AttributesFromSel(SFGAO_FOLDER)))
    {
        // If we are hosted by Trident, Zone Check Action.
        // this is how we detect if we are hosted in an IFRAME or OBJECT tag
        IUnknown *punk;
        if (SUCCEEDED(_psb->QueryInterface(IID_IIsWebBrowserSB, (void **)&punk)))
        {
            dwUrlAction = URLACTION_SHELL_VERB;
            punk->Release();
        }
        else if (_fGetWindowLV)
        {
            // If we are using WebView, Zone Check Action.
            dwUrlAction = URLACTION_SHELL_WEBVIEW_VERB;
        }
    }

    return dwUrlAction;
}

HRESULT CDefView::_ZoneCheck(DWORD dwFlags, DWORD dwAllowAction)
{
    HRESULT hr = S_OK;
    DWORD dwUrlAction = _GetNeededSecurityAction();

    if (dwUrlAction && (dwUrlAction != dwAllowAction))
    {
        // First check if our parent wants to generate our context (Zone/URL).
        IInternetHostSecurityManager *pihsm;
        hr = IUnknown_QueryService(_psb, IID_IInternetHostSecurityManager, IID_PPV_ARG(IInternetHostSecurityManager, &pihsm));
        if (FAILED(hr) && _cFrame._pDocView)
        {
            // Yes, so if we are in WebView mode, check the instance of Trident that is
            // displaying the WebView content, because that content could discuise the DefView
            // and make the user unknowingly do something bad.
            hr = IUnknown_QueryService(_cFrame._pDocView, IID_IInternetHostSecurityManager, IID_PPV_ARG(IInternetHostSecurityManager, &pihsm));
        }

        if (SUCCEEDED(hr))
        {
            // This is the prefered way to do the zone check.
            hr = ZoneCheckHost(pihsm, dwUrlAction, dwFlags | PUAF_FORCEUI_FOREGROUND);
            pihsm->Release();
        }
        else
        {
            // No, we were not able to get the interface.  So fall back to zone checking the
            // URL that comes from the pidl we are at.

            TCHAR szPathSource[MAX_PATH];
            if (_GetPath(szPathSource))
            {
                // Try to get a IInternetSecurityMgrSite so our UI will be modal.
                IInternetSecurityMgrSite *pisms;
                if (SUCCEEDED(IUnknown_QueryService(_psb, SID_STopLevelBrowser, IID_PPV_ARG(IInternetSecurityMgrSite, &pisms))))
                {
                    // TODO: Have this object support IInternetSecurityMgrSite in case our parent doesn't provide one.
                    //       Make that code support ::GetWindow() and ::EnableModless() or we won't get the modal behavior
                    //       needed for VB and AOL.

                    hr = ZoneCheckUrl(szPathSource, dwUrlAction, dwFlags | PUAF_ISFILE | PUAF_FORCEUI_FOREGROUND, pisms);
                    pisms->Release();
                }
            }
        }
    }

    return hr;
}

BOOL CDefView::IsSafeToDefaultVerb(void)
{
    return S_OK == _ZoneCheck(PUAF_WARN_IF_DENIED, 0);
}

HRESULT CDefView::_InvokeContextMenuVerb(IContextMenu* pcm, LPCSTR pszVerb, UINT uKeyFlags, DWORD dwCMMask)
{
    DECLAREWAITCURSOR;
    SetWaitCursor();

    CMINVOKECOMMANDINFOEX ici = {0};
    ici.cbSize = sizeof(ici);
    ici.hwnd = _hwndMain;
    ici.nShow = SW_NORMAL;
    ici.fMask = dwCMMask;

    // Get the point where the double click is invoked.
    GetMsgPos(&ici.ptInvoke);
    ici.fMask |= CMIC_MASK_PTINVOKE;

    // record if shift or control was being held down
    SetICIKeyModifiers(&ici.fMask);

    IUnknown_SetSite(pcm, SAFECAST(this, IOleCommandTarget *));

    // Security note: we assume all non default verbs safe
    HRESULT hr;
    if (pszVerb ||
        (IsSafeToDefaultVerb() && SUCCEEDED(_FireEvent(DISPID_DEFAULTVERBINVOKED))))
    {
        WCHAR szVerbW[128];
        if (pszVerb)
        {
            ici.lpVerb = pszVerb;
            SHAnsiToUnicode(pszVerb, szVerbW, ARRAYSIZE(szVerbW));
            ici.lpVerbW = szVerbW;
            ici.fMask |= CMIC_MASK_UNICODE;
        }

        HMENU hmenu = CreatePopupMenu();
        if (hmenu)
        {
            UINT fFlags = _GetExplorerFlag();

            if (NULL == pszVerb)
                fFlags |= CMF_DEFAULTONLY;  // optmization

            // SHIFT + dbl click does a Explore by default
            if (uKeyFlags & LVKF_SHIFT)
                fFlags |= CMF_EXPLORE;

            pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, fFlags);

            if (pszVerb)
                hr = S_OK;
            else
            {
                UINT idCmd = GetMenuDefaultItem(hmenu, MF_BYCOMMAND, GMDI_GOINTOPOPUPS);
                if (idCmd == -1)
                {
                    hr = E_FAIL;
                }
                else
                {
                    ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - CONTEXTMENU_IDCMD_FIRST);
                    hr = S_OK;
                }
            }

            if (SUCCEEDED(hr))
            {
                // need to reset it so that user won't blow off the app starting  cursor
                // also so that if we won't leave the wait cursor up when we're not waiting
                // (like in a prop sheet or something that has a message loop
                ResetWaitCursor();
                hcursor_wait_cursor_save = NULL;

                hr = _InvokeContextMenu(pcm, &ici);
            }

            DestroyMenu(hmenu);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

    IUnknown_SetSite(pcm, NULL);

    if (hcursor_wait_cursor_save)
        ResetWaitCursor();

    return hr;
}

HRESULT CDefView::_InvokeContextMenuVerbOnSelection(LPCSTR pszVerb, UINT uKeyFlags, DWORD dwCMMask)
{
    if (NULL == pszVerb)
    {
        if (_IsDesktop())
            UEMFireEvent(&UEMIID_SHELL, UEME_UISCUT, UEMF_XEVENT, -1, (LPARAM)-1);

        if (S_OK == _OnDefaultCommand())
        {
            return S_FALSE;         /* commdlg browser ate the message */
        }

        if (uKeyFlags & LVKF_ALT)
            pszVerb = "properties";
    }

    // Dealing with context menus can be slow
    DECLAREWAITCURSOR;
    SetWaitCursor();

    IContextMenu *pcmSel;
    HRESULT hr = _CreateSelectionContextMenu(IID_PPV_ARG(IContextMenu, &pcmSel));

    if (SUCCEEDED(hr))
        _LogDesktopLinksAndRegitems();

    ResetWaitCursor(); // undo the cursor since the below _Invoke needs to control cursor shape

    if (SUCCEEDED(hr))
    {
        hr = _InvokeContextMenuVerb(pcmSel, pszVerb, uKeyFlags, dwCMMask);

        pcmSel->Release();
    }

    return hr;
}

//
//  We want to keep track of which desktop regitems and links the user is using.
//  This lets the desktop cleaner app know which ones can safely be
//  cleaned up.
//
//  Be careful - there are many race conditions...  You have to do the
//  GetSelectedObjects before any InvokeCommands are done, because the
//  InvokeCommand calls might change the selection state.  But you also
//  have to use the result of GetSelectedObjects immediately, because
//  it returns pidls that are owned by the defview, and if a filesys
//  notify comes in, you might end up with pidls that have been freed.
//
//  So we just do all the work up front, before actually invoking anything.
//  This does mean that if the invoke fails, we still log the usage,
//  but that seems like a small price to pay.
//
void CDefView::_LogDesktopLinksAndRegitems()
{
    if (_IsDesktop())
    {
        LPCITEMIDLIST *apidl;
        UINT cItems;
        if (SUCCEEDED(GetSelectedObjects(&apidl, &cItems)) && apidl)
        {
            for (UINT i = 0; i < cItems; i++)
            {
                TCHAR szDisplayName[GUIDSTR_MAX+2]; // +2 for leading "::"
                if (SUCCEEDED(DisplayNameOf(_pshf, apidl[i], SHGDN_INFOLDER | SHGDN_FORPARSING,
                                szDisplayName, ARRAYSIZE(szDisplayName))))
                {
                    if (_Attributes(apidl[i], SFGAO_LINK))
                    {
                        // its a link
                        UEMFireEvent(&UEMIID_SHELL, UEME_RUNPATH, UEMF_XEVENT, -1, (LPARAM)szDisplayName);
                    }
                    else if (IsRegItemName(szDisplayName, NULL))
                    {
                        // it's a regitem
                        UEMFireEvent(&UEMIID_SHELL, UEME_RUNPATH, UEMF_XEVENT, -1, (LPARAM)szDisplayName);
                    }
                }
            }
            LocalFree((HLOCAL)apidl);
        }
    }
}

void CDefView::_UpdateColData(CBackgroundColInfo *pbgci)
{
    UINT iItem = ListView_MapIDToIndex(_hwndListview, pbgci->GetId());
    if (iItem != -1)
    {
        UINT uiCol = pbgci->GetColumn();

        if (_IsColumnInListView(uiCol))
        {
            UINT iVisCol = _RealToVisibleCol(uiCol);

            ListView_SetItemText(_hwndListview, iItem, iVisCol, (LPTSTR)pbgci->GetText());
        }
    }

    delete pbgci;
}

void CDefView::_UpdateIcon(LPITEMIDLIST pidl, UINT iIcon)
{
    int i = _FindItem(pidl, NULL, FALSE, FALSE);

    if (i >= 0)
    {
        LV_ITEM item = {0};

        item.mask = LVIF_IMAGE;
        item.iItem = i;
        item.iImage = iIcon;

        ListView_SetItem(_hwndListview, &item);
    }
    ILFree(pidl);
}

void CDefView::_UpdateOverlay(int iList, int iOverlay)
{
    ASSERT (iList >= 0);

    if (_IsOwnerData())
    {
        // In the ownerdata case, tell the owner that the overlay changed
        CallCB(SFVM_SETICONOVERLAY, iList, iOverlay);
        ListView_RedrawItems(_hwndListview, iList, iList);
    }
    else
    {
        ListView_SetItemState(_hwndListview, iList, INDEXTOOVERLAYMASK(iOverlay), LVIS_OVERLAYMASK);
    }
}

HRESULT CDefView::_GetIconAsync(LPCITEMIDLIST pidl, int *piIcon, BOOL fCanWait)
{
    HRESULT hr;

    // if we are not an owner-data view then try to extract asynchronously

    UINT flags = (_IsOwnerData() ? 0 : GIL_ASYNC);

    if (GIL_ASYNC & flags)
    {
        hr = SHMapIDListToImageListIndexAsync(_pScheduler, _pshf, pidl, flags, _AsyncIconTaskCallback, this, NULL, piIcon, NULL);

        if (SUCCEEDED(hr))
        {
            return S_OK;        // indicate that we got the real icon
        }
        else if (hr == E_PENDING)
        {
            hr = S_FALSE;     // the icon index we have is a placeholder
        }
    }
    else
    {
        hr = SHGetIconFromPIDL(_pshf, _psi, pidl,  flags, piIcon);
    }

    return hr;
}

void CDefView::_AsyncIconTaskCallback(LPCITEMIDLIST pidl, void *pvData, void *pvHint, INT iIconIndex, INT iOpenIconIndex)
{
    CDefView *pdv = (CDefView *)pvData;
    ASSERT(pdv);
    if (pdv)
    {
        LPITEMIDLIST pidlClone = ILClone(pidl);
        if (pidlClone && !PostMessage(pdv->_hwndView, WM_DSV_UPDATEICON, (WPARAM)pidlClone, (LPARAM)iIconIndex))
            ILFree(pidlClone);
    }
}

HRESULT CDefView::_GetOverlayIndexAsync(LPCITEMIDLIST pidl, int iList)
{
    IRunnableTask * pTask;

    HRESULT hr = CIconOverlayTask_CreateInstance(this, pidl, iList, &pTask);
    if (SUCCEEDED(hr))
    {
        _AddTask(pTask, TOID_DVIconOverlay, 0, TASK_PRIORITY_GET_ICON, ADDTASK_ATEND);
        pTask->Release();
    }

    return hr;
}

//
// Returns: if the cursor is over a listview item, its index; otherwise, -1.
//
int CDefView::_HitTest(const POINT *ppt, BOOL fIgnoreEdge)
{
    LV_HITTESTINFO info;

    if (!_IsListviewVisible())
        return -1;

    info.pt = *ppt;
    int iRet = ListView_HitTest(_hwndListview, &info);

    if (-1 != iRet && fIgnoreEdge)
    {
        // If we're in one of these large image area modes, and the caller says
        // it's okay to ignore "edge" hits, then pretend the user is over nothing.
        // Tile mode only ignores the left edge of the icon, since the right edge
        // is all text (and usually shorter than the tile width anyway).
        if (_IsTileMode() && (info.flags & LVHT_ONLEFTSIDEOFICON))
            iRet = -1;
        else if (_IsImageMode() && (info.flags & (LVHT_ONLEFTSIDEOFICON|LVHT_ONRIGHTSIDEOFICON)))
            iRet = -1;
    }

    return iRet;
}

void CDefView::_OnGetInfoTip(NMLVGETINFOTIP *plvn)
{
    if (!SHShowInfotips())
        return;

    LPCITEMIDLIST pidl = _GetPIDL(plvn->iItem);
    if (pidl)
    {
        ATOMICRELEASE(_pBackgroundInfoTip); // Release the previous value, if any

        HRESULT hr = E_FAIL;
        _pBackgroundInfoTip = new CBackgroundInfoTip(&hr, plvn);

        if (_pBackgroundInfoTip && SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlFolder = _GetViewPidl();
            if (pidlFolder)
            {
                CStatusBarAndInfoTipTask *pTask;
                hr = CStatusBarAndInfoTipTask_CreateInstance(pidlFolder, pidl, 0, 0, _pBackgroundInfoTip, _hwndView, _pScheduler, &pTask);
                if (SUCCEEDED(hr))
                {
                    if (_pScheduler)
                    {
                        // make sure there are no other background infotip tasks going on...
                        _pScheduler->RemoveTasks(TOID_DVBackgroundInfoTip, ITSAT_DEFAULT_LPARAM, FALSE);
                    }

                    _AddTask(pTask, TOID_DVBackgroundInfoTip, 0, TASK_PRIORITY_INFOTIP, ADDTASK_ATEND);
                    pTask->Release();
                }
                ILFree(pidlFolder);
            }
        }
    }
    // Do not show a tip while the processing is happening in the background
    plvn->pszText[0] = 0;
}

HRESULT CDefView::_OnViewWindowActive()
{
    IShellView *psv = _psvOuter ? _psvOuter : SAFECAST(this, IShellView*);

    return _psb->OnViewWindowActive(psv);
}

// CLR_NONE is a special value that never matches a valid RGB
COLORREF g_crAltColor = CLR_NONE;               // uninitialized magic value
COLORREF g_crAltEncryptedColor = CLR_NONE;      // uninitialized magic value

DWORD GetRegColor(COLORREF clrDefault, LPCTSTR pszName, COLORREF *pValue)
{
    // Fetch the alternate color (for compression) if supplied.
    if (*pValue == CLR_NONE)   // initialized yet?
    {
        DWORD cbData = sizeof(*pValue);
        if (FAILED(SKGetValue(SHELLKEY_HKCU_EXPLORER, NULL, pszName, NULL, pValue, &cbData)))
        {
            *pValue = clrDefault;  // default value
        }
    }
    return *pValue;
}

LRESULT CDefView::_GetDisplayInfo(LV_DISPINFO *plvdi)
{
    LPCITEMIDLIST pidl = _GetPIDLParam(plvdi->item.lParam, plvdi->item.iItem);
    if (pidl && (plvdi->item.mask & (DEFVIEW_LISTCALLBACK_FLAGS)))
    {
        ASSERT(IsValidPIDL(pidl));
        ASSERT(plvdi->item.iSubItem != 0 ? ViewRequiresColumns(_fs.ViewMode) : TRUE);

        LV_ITEM item = {0};
        item.mask = plvdi->item.mask & (DEFVIEW_LISTCALLBACK_FLAGS);
        item.iItem = plvdi->item.iItem;
        item.iImage = plvdi->item.iImage = -1; // for iSubItem != 0 case

        if ((plvdi->item.iSubItem == 0) && (item.mask & LVIF_IMAGE))
        {
            // If the folder supports IShellIconOverlay then only need to ask for ghosted, else
            // we need to do the old stuff...
            DWORD uFlags = _Attributes(pidl, _psio ? SFGAO_GHOSTED : SFGAO_LINK | SFGAO_SHARE | SFGAO_GHOSTED);

            // set the mask
            item.mask |= LVIF_STATE;
            plvdi->item.mask |= LVIF_STATE;
            item.stateMask = LVIS_OVERLAYMASK;

            // Pick the right overlay icon. The order is significant.
            item.state = 0;
            if (_psio)
            {
                int iOverlayIndex = SFV_ICONOVERLAY_UNSET;
                if (_IsOwnerData())
                {
                    // Note: we are passing SFV_ICONOVERLAY_DEFAULT here because
                    // some owners do not respond to SFVM_GETICONOVERLAY might return
                    // iOverlayIndex unchanged and it will get
                    iOverlayIndex = SFV_ICONOVERLAY_DEFAULT;
                    CallCB(SFVM_GETICONOVERLAY, plvdi->item.iItem, (LPARAM)&iOverlayIndex);
                    if (iOverlayIndex > 0)
                    {
                        item.stateMask |= LVIS_OVERLAYMASK;
                        item.state |= INDEXTOOVERLAYMASK(iOverlayIndex);
                    }
                }

                if (iOverlayIndex == SFV_ICONOVERLAY_UNSET)
                {
                    iOverlayIndex = OI_ASYNC;
                    HRESULT hr = _psio->GetOverlayIndex(pidl, &iOverlayIndex);
                    if (E_PENDING == hr)
                        _GetOverlayIndexAsync(pidl, item.iItem);
                    else if (S_OK == hr)
                    {
                        ASSERT(iOverlayIndex >= 0);
                        ASSERT(iOverlayIndex < MAX_OVERLAY_IMAGES);

                        // In the owner data case, tell the owner we got an Overlay index
                        if (_IsOwnerData())
                            CallCB(SFVM_SETICONOVERLAY, item.iItem, iOverlayIndex);

                        item.state = INDEXTOOVERLAYMASK(iOverlayIndex);
                    }
                }
            }
            else
            {
                if (uFlags & SFGAO_LINK)
                {
                    item.state = INDEXTOOVERLAYMASK(II_LINK - II_OVERLAYFIRST + 1);
                }
                else if (uFlags & SFGAO_SHARE)
                {
                    item.state = INDEXTOOVERLAYMASK(II_SHARE - II_OVERLAYFIRST + 1);
                }
            }

            if (uFlags & SFGAO_GHOSTED)
            {
                item.stateMask |= LVIS_CUT;
                item.state |= LVIS_CUT;
            }
            else
            {
                item.stateMask |= LVIS_CUT;
                item.state &= ~LVIS_CUT;
            }

            plvdi->item.stateMask = item.stateMask;
            plvdi->item.state = item.state;

            // Get the image
            if (_IsOwnerData() && !_IsImageMode())
            {
                CallCB(SFVM_GETITEMICONINDEX, plvdi->item.iItem, (LPARAM)&item.iImage);
            }

            if (item.iImage == -1)
            {
                if (_IsImageMode())
                {
                    // Check if the item is visible.  If it is not, then the image was
                    // probably asked for by the thumbnail read ahead task, in which case, we set a 
                    // different priority.
                    if (ListView_IsItemVisible(_hwndListview, item.iItem))
                    {
                        if (S_OK != ExtractItem((UINT*)&item.iImage, item.iItem, pidl, TRUE, FALSE, PRIORITY_P5))
                        {
                            _CacheDefaultThumbnail(pidl, &item.iImage);
                        }
                    }
                    else
                    {
                        // Likely from read ahead task.
                        ExtractItem((UINT*)&item.iImage, item.iItem, pidl, TRUE, FALSE, PRIORITY_READAHEAD_EXTRACT);
                    }
                }
                else
                    _GetIconAsync(pidl, &item.iImage, TRUE);
            }

            plvdi->item.iImage = item.iImage;
        }

        if (item.mask & LVIF_TEXT)
        {
            if (plvdi->item.cchTextMax)
                *plvdi->item.pszText = 0;

            // Note that we do something different for index 0 = NAME
            if (plvdi->item.iSubItem == 0)
            {
                DisplayNameOf(_pshf, pidl, SHGDN_INFOLDER, plvdi->item.pszText, plvdi->item.cchTextMax);
            }
            else
            {
                // on the first slow column complete all of the other columns (assumed to be slow)
                // now so we get good caching from the col handlers

                UINT iReal = _VisibleToRealCol(plvdi->item.iSubItem);

                if (_vs.GetColumnState(iReal) & SHCOLSTATE_SLOW)
                {
                    UINT cCols = _vs.GetColumnCount();
                    for (UINT iVisCol = plvdi->item.iSubItem; iReal < cCols; iReal++)
                    {
                        if (_IsColumnInListView(iReal))
                        {
                            ASSERT(_vs.GetColumnState(iReal) & SHCOLSTATE_SLOW);

                            UINT uId = ListView_MapIndexToID(_hwndListview, plvdi->item.iItem);

                            // in the async case set the text to nothing (NULL). this will
                            // prevent another call to ListView_GetItemText() from invoking us
                            ListView_SetItemText(_hwndListview, plvdi->item.iItem, iVisCol++, NULL);

                            IRunnableTask *pTask;
                            if (SUCCEEDED(CExtendedColumnTask_CreateInstance(this, pidl, uId, _fmt, iReal, &pTask)))
                            {
                                _AddTask(pTask, TOID_DVBackgroundEnum, 0, TASK_PRIORITY_FILE_PROPS, ADDTASK_ATEND);
                                pTask->Release();
                            }
                        }
                    }
                    return 0;   // bail!
                }

                DETAILSINFO di;

                di.pidl = pidl;
                di.fmt  = _fmt;
                di.iImage = -1;     // Assume for now no image...

                if (SUCCEEDED(_GetDetailsHelper(iReal, &di)))
                {
                    StrRetToBuf(&di.str, pidl, plvdi->item.pszText, plvdi->item.cchTextMax);

                    if ((di.iImage != -1) && (plvdi->item.mask & LVIF_IMAGE))
                    {
                        plvdi->item.iImage = di.iImage;
                    }
                }
            }
        }

        if ((item.mask & LVIF_GROUPID) && _fGroupView)
        {
            plvdi->item.mask |= LVIF_GROUPID;
            plvdi->item.iGroupId = _GetGroupForItem(plvdi->item.iItem, pidl);
        }

        if (item.mask & LVIF_COLUMNS)
        {
            if (_fScrolling)
            {
                // Ignore any column requests if we're currently scrolling. However, don't
                // return zero for the number of columns, return I_COLUMNSCALLBACK instead, because
                // we do still want listview to call us back to ask for them if it is every displaying
                // this guy while we're not scrolling.
                plvdi->item.cColumns = I_COLUMNSCALLBACK;
                plvdi->item.puColumns = NULL;
                _fRequestedTileDuringScroll = TRUE;
            }
            else
            {
                if (_IsOwnerData())
                {
                    AddColumns();

                    if (plvdi->item.cColumns > 1)
                    {
                        // hack special case for the find folder
                        if (_MapSCIDToColumn(&SCID_DIRECTORY, &plvdi->item.puColumns[0]))
                            plvdi->item.cColumns = 1;
                    }
                }
                else
                {
                    BOOL fGotColumns = FALSE;
                    // Start a task to extract the important columns for this item.
                    LPCITEMIDLIST pidl = _GetPIDL(plvdi->item.iItem);
                    if (pidl)
                    {
                        plvdi->item.cColumns = TILEVIEWLINES;
                        if (SUCCEEDED(_PeekColumnsCache(NULL, 0, pidl, plvdi->item.puColumns, &plvdi->item.cColumns)))
                        {
                            // Make sure columns are loaded
                            AddColumns();

                            _FixupColumnsForTileview(plvdi->item.puColumns, plvdi->item.cColumns);
                            fGotColumns = TRUE;
                        }
                        else
                        {
                            IRunnableTask *pTask;
                            UINT uId = ListView_MapIndexToID(_hwndListview, plvdi->item.iItem);

                            if (SUCCEEDED(CFileTypePropertiesTask_CreateInstance(this, pidl, TILEVIEWLINES, uId, &pTask))) //pidl gets cloned
                            {
                                _AddTask(pTask, TOID_DVFileTypeProperties, 0, TASK_PRIORITY_FILE_PROPS, ADDTASK_ATEND);
                                pTask->Release();
                            }
                        }
                    }

                    if (!fGotColumns)
                    {
                        plvdi->item.cColumns = 0;
                        plvdi->item.puColumns = NULL;
                    }
                }
            }

        }

        if (plvdi->item.iSubItem == 0)
            plvdi->item.mask |= LVIF_DI_SETITEM;    // always store the name
    }
    return 0;
}

int CALLBACK GroupCompare(int iGroup1, int iGroup2, void *pvData)
{
    ICategorizer* pcat = (ICategorizer*)pvData;

    HRESULT hr = pcat->CompareCategory(CATSORT_DEFAULT, (DWORD)iGroup1, (DWORD)iGroup2);

    return ShortFromResult(hr);
}

void CDefView::_OnCategoryTaskAdd()
{
    _fInBackgroundGrouping = TRUE;
}

void CDefView::_OnCategoryTaskDone()
{
    _fInBackgroundGrouping = FALSE;

    LONG cTasksCompleteLocal;

    ENTERCRITICAL;
    {    
        _fGroupingMsgInFlight = FALSE;

        cTasksCompleteLocal = _cTasksCompleted;
        _cTasksCompleted = 0;

        // swap the DPAs
        HDPA hdpaTemp = _hdpaGroupingListBackup;
        _hdpaGroupingListBackup = _hdpaGroupingListActive;
        _hdpaGroupingListActive = hdpaTemp;
    }
    LEAVECRITICAL;


    LONG cEntries = DPA_GetPtrCount(_hdpaGroupingListBackup);

    // now process everything in _hdpaGroupingListEmpty
    for (int i = 0; i < cEntries; i++)
    {
        CBackgroundGroupInfo* pbggi = (CBackgroundGroupInfo*)DPA_GetPtr(_hdpaGroupingListBackup, i);
        if (pbggi)
        {
            if (pbggi->VerifyGroupExists(_hwndListview, _pcat))
            {
                int iItem = ListView_MapIDToIndex(_hwndListview, pbggi->GetId());

                if (iItem != -1)
                {
                    LVITEM lvi = {0};
                    lvi.mask = LVIF_GROUPID;
                    lvi.iGroupId = pbggi->GetGroupId();
                    lvi.iItem = iItem;
                    ListView_SetItem(_hwndListview, &lvi);
                }
            }
            delete pbggi;
        }
    }

    DPA_DeleteAllPtrs(_hdpaGroupingListBackup);

    if (_pidlSelectAndPosition)
    {
        POINT pt = {0};     // Don't care: Groups don't have a position

        SelectAndPositionItem(_pidlSelectAndPosition, _uSelectAndPositionFlags, &pt);

        Pidl_Set(&_pidlSelectAndPosition, NULL);
        _uSelectAndPositionFlags = 0;
    }    
    
    for (LONG i = 0; i < cTasksCompleteLocal; i++)
    {
        _ShowSearchUI(FALSE);
        _GlobeAnimation(FALSE);
    }
}

DWORD CDefView::_GetGroupForItem(int iItem, LPCITEMIDLIST pidl)
{
    DWORD dwGroup = I_GROUPIDNONE;
    if (_fGroupView)
    {
        if (_fSlowGroup)
        {
            UINT uId = ListView_MapIndexToID(_hwndListview, iItem);
            IRunnableTask* pTask;
            if (SUCCEEDED(CCategoryTask_Create(this, pidl, uId, &pTask)))
            {
                // Need to get the globe/search stuff kicked off while within the CreateViewWindow2 call,
                // so do it here instead of a posted message in the above constructor
                _OnCategoryTaskAdd();

                _AddTask(pTask, TOID_DVBackgroundGroup, 0, TASK_PRIORITY_GROUP, ADDTASK_ATEND);
                pTask->Release();
            }
        }
        else
        {
            _pcat->GetCategory(1, (LPCITEMIDLIST*)&pidl, &dwGroup);
            if (!ListView_HasGroup(_hwndListview, dwGroup))
            {
                CATEGORY_INFO ci;
                _pcat->GetCategoryInfo(dwGroup, &ci);

                LVINSERTGROUPSORTED igrp;
                igrp.pfnGroupCompare = GroupCompare;
                igrp.pvData = (void *)_pcat;
                igrp.lvGroup.cbSize = sizeof(LVGROUP);
                igrp.lvGroup.mask = LVGF_HEADER | LVGF_GROUPID;
                igrp.lvGroup.pszHeader= ci.wszName;
                igrp.lvGroup.iGroupId = (int)dwGroup;

                ListView_InsertGroupSorted(_hwndListview, &igrp);
            }
        }
    }

    return dwGroup;
}

BOOL CDefView::_EnsureSCIDCache()
{
    BOOL bRet = FALSE;
    if (_hdsaSCIDCache)
    {
        bRet = TRUE;
    }
    else if (_pshf2)
    {
        _hdsaSCIDCache = DSA_Create(sizeof(SHCOLUMNID), 30);
        if (_hdsaSCIDCache)
        {
            SHCOLUMNID scid;

            for (UINT iCol = 0; SUCCEEDED(_pshf2->MapColumnToSCID(iCol, &scid)); iCol++)
            {
                // ignore failure, just means we can't find the thing
                DSA_AppendItem(_hdsaSCIDCache, &scid);
            }
            bRet = TRUE;
        }
    }
    return bRet;
}

BOOL CDefView::_MapSCIDToColumn(const SHCOLUMNID *pscid, UINT *pnColumn)
{
    BOOL bRet = FALSE;
    *pnColumn = 0;
    if (_EnsureSCIDCache())
    {
        UINT cCol = DSA_GetItemCount(_hdsaSCIDCache);

        for (UINT iCol = 0; iCol < cCol; iCol++)
        {
            SHCOLUMNID scid;
            DSA_GetItem(_hdsaSCIDCache, iCol, &scid);
            if (IsEqualSCID(*pscid, scid))
            {
                *pnColumn = iCol;
                bRet = TRUE;
                break;
            }
        }
    }
    return bRet;
}

HRESULT CDefView::_GetPropertyUI(IPropertyUI **pppui)
{
    if (!_ppui)
        SHCoCreateInstance(NULL, &CLSID_PropertiesUI, NULL, IID_PPV_ARG(IPropertyUI, &_ppui));

    return _ppui ? _ppui->QueryInterface(IID_PPV_ARG(IPropertyUI, pppui)) : E_NOTIMPL;
}

HRESULT CDefView::_PeekColumnsCache(PTSTR pszPath, UINT cchPath, LPCITEMIDLIST pidl, UINT rguColumns[], UINT *pcColumns)
{
    TCHAR szPath[MAX_PATH];
    if (pszPath == NULL)
    {
        pszPath = szPath;
        cchPath = ARRAYSIZE(szPath);
    }

    // NOTE - need to replace this with GetDetailsEx(SCID_CANONICALTYPE) to support
    // caching properly.  then we dont need to sniff attributes or the name in order to get
    // a nice caching index.
    HRESULT hr = DisplayNameOf(_pshf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, pszPath, cchPath);
    if (SUCCEEDED(hr))
    {
        LPCWSTR pszExt = _Attributes(pidl, SFGAO_FOLDER) ? NULL : PathFindExtension(pszPath);

        hr = E_FAIL;

        // Check file table cache:
        ENTERCRITICAL;
        SHCOLUMNID *pscidCached;
        UINT cSCIDCached = pszExt ? LookupFileSCIDs(pszExt, &pscidCached) : 0; //Handle no extension case by not looking up in cache
        LEAVECRITICAL;

        if (cSCIDCached) // Found the SCIDs cache in the file table
        {
            UINT nFilled = 0;
            // Found it... we don't need to check the registry
            for (UINT nSCID = 0; nSCID < cSCIDCached && nFilled < *pcColumns; nSCID++)
            {
                if (_MapSCIDToColumn(&pscidCached[nSCID], &rguColumns[nFilled]))
                    nFilled++;
            }
            *pcColumns = nFilled;
            LocalFree(pscidCached);

            hr = S_OK;
        }
    }

    return hr;

}

// Get the important columns for this guy, based on file extension
// pidl:        The pidl of the item in question
// puColumns[]: The array which will get filled with important column indicies
// pcColumns    IN: specifies how big rguColumns[] is. OUT: specified how many slots got filled.
HRESULT CDefView::_GetImportantColumns(LPCITEMIDLIST pidl, UINT rguColumns[], UINT *pcColumns)
{
    TCHAR szPath[MAX_PATH];

    // We need to ensure that the columns are loaded here
    if (!_bLoadedColumns)
    {
        DWORD_PTR lRes = 0;
        if (!SendMessageTimeout(_hwndView, WM_DSV_ENSURE_COLUMNS_LOADED, 0, 0, SMTO_NORMAL, 5000, &lRes) || lRes == 0)
            return E_FAIL;
    }

    HRESULT hr = _PeekColumnsCache(szPath, ARRAYSIZE(szPath), pidl, rguColumns, pcColumns);
    if (FAILED(hr))
    {
        IQueryAssociations *pqa;
        hr = _pshf->GetUIObjectOf(_hwndMain, 1, &pidl, IID_PPV_ARG_NULL(IQueryAssociations, &pqa));
        if (SUCCEEDED(hr))
        {
            IPropertyUI *ppui;
            hr = _GetPropertyUI(&ppui);
            if (SUCCEEDED(hr))
            {
                TCHAR szProps[INFOTIPSIZE];
                DWORD cchOut = ARRAYSIZE(szProps);
                hr = pqa->GetString(0, ASSOCSTR_TILEINFO, NULL, szProps, &cchOut);
                if (SUCCEEDED(hr))
                {
                    UINT cNumColumns = 0;       // # of items in rguColumns
                    UINT cSCID = 0;             // # of items in rgscid
                    SHCOLUMNID rgscid[64];      // reasonable upper bound

                    ULONG chEaten = 0;          // loop variable ParsePropertyName updates this
                    while ((cSCID < ARRAYSIZE(rgscid)) &&
                           SUCCEEDED(ppui->ParsePropertyName(szProps, &rgscid[cSCID].fmtid, &rgscid[cSCID].pid, &chEaten)))
                    {
                        // Map SCID to a column (while there are more column slots)
                        if ((cNumColumns < *pcColumns) &&
                            _MapSCIDToColumn(&rgscid[cSCID], &rguColumns[cNumColumns]))
                        {
                            cNumColumns++;
                            cSCID++;
                        }
                    }
                    *pcColumns = cNumColumns;

                    LPCWSTR pszExt = _Attributes(pidl, SFGAO_FOLDER) ? NULL : PathFindExtension(szPath);
                    if (pszExt)
                    {
                        // cache for future use, except if there's no extension (cache key)
                        ENTERCRITICAL;
                        AddFileSCIDs(pszExt, rgscid, cSCID);
                        LEAVECRITICAL;
                    }
                }
                ppui->Release();
            }
            pqa->Release();
        }
    }
    return hr;
}

void CDefView::_FixupColumnsForTileview(UINT *rguColumns, UINT cColumns)
{
    // Make sure these columns are added to listview (ie. visible).
    // And then map the columns in rguColumns from real columns to visible columns
    for (UINT i = 0; i < cColumns; i++)
    {
        _AddTileColumn(rguColumns[i]);
    }

    // Now, also add the sorted by column, if it hasn't been added yet.
    if (!_fSetTileViewSortedCol)
    {
        _fSetTileViewSortedCol = TRUE;
        // It's ok if we don't actually set it.  It's the thought that counts.

        if (_vs._lParamSort != -1)
        {
            _AddTileColumn(_vs._lParamSort);

            // And set it selected, if we're not in groupview
            if (!_fGroupView)
            {
                ListView_SetSelectedColumn(_hwndListview, _RealToVisibleCol(_vs._lParamSort));
            }
        }
    }

    // This must be done after all the _AddTileColumns, or else the visible col #'s will be off.
    for (UINT i = 0; i < cColumns; i++)
    {
        rguColumns[i] = _RealToVisibleCol(rguColumns[i]);
    }
}

void CDefView::_SetImportantColumns(CBackgroundTileInfo *pbgTileInfo)
{
    UINT cColumns = pbgTileInfo->GetColumnCount();
    UINT *rguColumns = pbgTileInfo->GetColumns();

    LVTILEINFO ti = {0};
    ti.cbSize = sizeof(ti);
    ti.cColumns = cColumns;
    ti.puColumns = rguColumns;
    ti.iItem = ListView_MapIDToIndex(_hwndListview, pbgTileInfo->GetId());
    if (ti.iItem != -1)
    {
        _FixupColumnsForTileview(rguColumns, cColumns);
        // have the listview store the per item tile info that we have computed
        ListView_SetTileInfo(_hwndListview, &ti);
    }

    delete pbgTileInfo;
}

// Ensures if we're in tileview, that the tileviewinfo is set.
void CDefView::_SetView(UINT fvm)
{
    // Update our internal state
    _fs.ViewMode = fvm;

    // Map the ViewMode into a listview mode
    DWORD iView = LV_VIEW_ICON;
    // Now switch the listview
    switch (fvm)
    {
    case FVM_ICON:
    case FVM_SMALLICON:
    case FVM_THUMBNAIL:
    case FVM_THUMBSTRIP:
        iView = LV_VIEW_ICON;
        break;

    case FVM_LIST:
        iView = LV_VIEW_LIST;
        break;

    case FVM_TILE:
        iView = LV_VIEW_TILE;
        break;

    case FVM_DETAILS:
        iView = LV_VIEW_DETAILS;
        break;

    default:
        ASSERTMSG(FALSE, "_SetView got an invalid ViewMode!");
        break;
    }

    if (iView == LV_VIEW_TILE)
    {
        RECT rcLabelMargin = {1, 1, 1, 1}; // This gives us some room around the label, so the focus rect doesn't clip part of the text
        LVTILEVIEWINFO lvtvi = {0};
        lvtvi.cbSize = sizeof(lvtvi);
        lvtvi.dwMask = LVTVIM_TILESIZE | LVTVIM_COLUMNS | LVTVIM_LABELMARGIN;
        lvtvi.dwFlags = LVTVIF_AUTOSIZE;
        lvtvi.cLines = TILEVIEWLINES;
        lvtvi.rcLabelMargin = rcLabelMargin;
        ListView_SetTileViewInfo(_hwndListview, &lvtvi);
    }
    ListView_SetView(_hwndListview, iView);
    _FireEvent(DISPID_VIEWMODECHANGED);
}

// rename the selection based on the new name for the renamed item
// this makes it easy to rename groups of files to a common base name
 
HRESULT CDefView::_DoBulkRename(LPCITEMIDLIST pidlNewName)
{
    LPCITEMIDLIST *apidl;
    UINT cItems;
    HRESULT hr = _GetItemObjects(&apidl, SVGIO_SELECTION, &cItems);
    if (SUCCEEDED(hr))
    {
        if (cItems > 1)     // only interesting if more than 1
        {
            TCHAR szBase[MAX_PATH]; // seed file name used to generate other names
            hr = DisplayNameOf(_pshf, pidlNewName, SHGDN_INFOLDER | SHGDN_FORPARSING, szBase, ARRAYSIZE(szBase));
            if (SUCCEEDED(hr))
            {
                if (!SHGetAttributes(_pshf, pidlNewName, SFGAO_FOLDER))
                    PathRemoveExtension(szBase);    // remove the extension, if it is a file

                UINT cBase = 1;     // one based counter, start at "File (1)"

                // if input contains (#) use that as the sequence # base
                LPWSTR psz = StrChr(szBase, TEXT('('));
                if (psz)
                {
                    cBase = StrToInt(psz + 1) + 1;      // start at this in sequence
                    *psz = 0;                           // remove the (#) from the base name
                }

                PathRemoveBlanks(szBase);               // clean away leading/trailing blanks

                // start at 1, skipping the focused item, renaming all others in the array
                for (UINT i = 1; (i < cItems) && SUCCEEDED(hr); i++)
                {
                    TCHAR szOld[MAX_PATH];

                    hr = DisplayNameOf(_pshf, apidl[i], SHGDN_INFOLDER | SHGDN_FORPARSING, szOld, ARRAYSIZE(szOld));
                    if (SUCCEEDED(hr))
                    {
                        // Clone the pidl since isf->SetNameOf can result in synchronous update item
                        // that can free the ListView owned apidl[i].
                        LPITEMIDLIST pidlOldName = ILClone(apidl[i]);
                        if (pidlOldName)
                        {
                            // if the new name we produce conflicts with a name that
                            // already exists we will retry up to 100 times
                            for (UINT cRetry = 0; cRetry < 100; cRetry++)
                            {
                                WCHAR szName[MAX_PATH];
                                wnsprintf(szName, ARRAYSIZE(szName), TEXT("%s (%d)%s"), szBase, cBase, PathFindExtension(szOld));

                                hr = _pshf->SetNameOf(NULL, pidlOldName, szName, SHGDN_INFOLDER | SHGDN_FORPARSING, NULL);
                                if (SUCCEEDED(hr))
                                {
                                    // force sync change notify update to make sure
                                    // all renames come through (avoid UPDATEDIR)
                                    SHChangeNotifyHandleEvents();
                                    cBase++;
                                    break;  // did this one successfully
                                }
                                else if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr ||
                                        HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)
                                {
                                    cBase++;
                                    hr = S_OK;  // and keep trying
                                }
                                else
                                {
                                    break;      // other error, exit
                                }
                            }

                            ILFree(pidlOldName);
                        }
                    }
                }
            }
        }
        LocalFree(apidl);
    }
    return hr;
}


LRESULT CDefView::_OnLVNotify(NM_LISTVIEW *plvn)
{
    switch (plvn->hdr.code)
    {
    case NM_KILLFOCUS:
        // force update on inactive to not ruin save bits
        _OnStateChange(CDBOSC_KILLFOCUS);
        if (GetForegroundWindow() != _hwndMain)
            UpdateWindow(_hwndListview);
        _fHasListViewFocus = FALSE;
        _EnableDisableTBButtons();
        break;

    case NM_SETFOCUS:
    {
        if (!_fDestroying)
        {
            if (_cFrame.IsWebView())   // Do OLE stuff
            {
                UIActivate(SVUIA_ACTIVATE_FOCUS);
            }
            else
            {
                //  We should call IShellBrowser::OnViewWindowActive() before
                // calling its InsertMenus().
                _OnViewWindowActive();
                _OnStateChange(CDBOSC_SETFOCUS);
                OnActivate(SVUIA_ACTIVATE_FOCUS);
                _FocusOnSomething();
                _UpdateStatusBar(FALSE);
            }
            _fHasListViewFocus = TRUE;
            _EnableDisableTBButtons();
        }
        break;
    }

    case NM_RCLICK:
        // on the shift+right-click case we want to deselect everything and select just our item if it is
        // not already selected. if we dont do this, then listview gets confused (because he thinks
        // shift means extend selection, but in the right click case it dosent!) and will bring up the
        // context menu for whatever is currently selected instead of what the user just right clicked on.
        if ((GetKeyState(VK_SHIFT) < 0) &&
            (plvn->iItem >= 0)          &&
            !(ListView_GetItemState(_hwndListview, plvn->iItem, LVIS_SELECTED) & LVIS_SELECTED))
        {
            // clear any currently slected items
            ListView_SetItemState(_hwndListview, -1, 0, LVIS_SELECTED);

            // select the guy that was just right-clicked on
            ListView_SetItemState(_hwndListview, plvn->iItem, LVIS_SELECTED, LVIS_SELECTED);
        }
        break;

    case LVN_ENDSCROLL:
        {
            // This means we're scrolling.  Ignore requests for LVIF_COLUMNS while we're
            // scrolling to speed things up.

            // We don't want to ignore requests for LVIF_COLUMNS when we're owner data, because
            // owner data listviews always callback for info on what to display.  (The result would
            // be already-present tileinfo vanishing while scrolling, since we'd be ignoring requests
            // for what to display)
            if ((_fs.ViewMode == FVM_TILE) && !_IsOwnerData())
            {
                SetTimer(_hwndView, DV_IDTIMER_SCROLL_TIMEOUT, 250, NULL);

                if (!_fScrolling)
                {
                    _fScrolling = TRUE;

                    // We don't reset this on every LVN_ENDSCROLL - only if this is the first time
                    // we've scrolled since a stable (non-scrolling) state
                    _fRequestedTileDuringScroll = FALSE;
                }
            }
        }
        break;

    case LVN_GETINFOTIP:
        _OnGetInfoTip((NMLVGETINFOTIP *)plvn);
        break;

    case LVN_ITEMACTIVATE:
        if (!_fDisabled)
        {
            //in win95 if user left clicks on one click activate icon and then right
            //clicks on it (within double click time interval), the icon is launched
            //and context menu appears on top of it -- it does not disappear.
            //furthermore the context menu cannot be destroyed but stays on top of
            //any window and items on it are not accessible. to avoid this
            //send cancel mode to itself to destroy context before the icon is
            //launched
            if (_hwndView)
                SendMessage(_hwndView, WM_CANCELMODE, 0, 0);

            _InvokeContextMenuVerbOnSelection(NULL, ((NMITEMACTIVATE *)plvn)->uKeyFlags, CMIC_MASK_FLAG_LOG_USAGE);
        }
        break;

    case NM_CUSTOMDRAW:
        {
            LPNMLVCUSTOMDRAW pcd = (LPNMLVCUSTOMDRAW)plvn;

            switch (pcd->nmcd.dwDrawStage)
            {
            case CDDS_PREPAINT:
                {
                    return _fShowCompColor ? CDRF_NOTIFYITEMDRAW : CDRF_DODEFAULT;
                }
                
            case CDDS_ITEMPREPAINT:
                {
                    LRESULT lres = CDRF_DODEFAULT;
                    LPCITEMIDLIST pidl = _GetPIDLParam(pcd->nmcd.lItemlParam, (int)pcd->nmcd.dwItemSpec);
                    if (pidl)
                    {
                        DWORD dwAttribs = _Attributes(pidl, SFGAO_COMPRESSED | SFGAO_ENCRYPTED);

                        // only one or the other, can never be both
                        if (dwAttribs & SFGAO_COMPRESSED)
                        {
                            // default value of Blue
                            pcd->clrText = GetRegColor(RGB(0, 0, 255), TEXT("AltColor"), &g_crAltColor);
                        }
                        else if (dwAttribs & SFGAO_ENCRYPTED)
                        {
                            // default value Luna Mid Green
                            pcd->clrText = GetRegColor(RGB(19, 146, 13), TEXT("AltEncryptionColor"), &g_crAltEncryptedColor);
                        }
                    }
                    if (_IsImageMode() && pcd->nmcd.hdc && (_dwRecClrDepth <= 8))
                    {
                        HPALETTE hpal = NULL;
                        if (SUCCEEDED(_GetBrowserPalette(&hpal)))
                        {
                            // Since we are a child of the browser, we should always take a back seat to thier palette selection
                            _hpalOld = SelectPalette(pcd->nmcd.hdc, hpal, TRUE);
                            RealizePalette(pcd->nmcd.hdc);
                            lres |= CDRF_NOTIFYPOSTPAINT;
                        }
                    }
                    return lres;
                }

            case CDDS_ITEMPOSTPAINT:
                if (_IsImageMode() && _hpalOld && pcd->nmcd.hdc)
                {
                    SelectPalette(pcd->nmcd.hdc, _hpalOld, TRUE);
                    _hpalOld = NULL;
                }
                break;
            }
        }
        return CDRF_DODEFAULT;

    case LVN_BEGINDRAG:
    case LVN_BEGINRDRAG:
        if (_fDisabled)
            return FALSE;   /* commdlg doesn't want user dragging */
        return _OnBeginDrag(plvn);

    case LVN_ITEMCHANGING:
        if (_fDisabled)
            return TRUE;
        break;

    // Something changed in the listview.  Delete any data that
    // we might have cached away.

    case LVN_ITEMCHANGED:
        if (plvn->uChanged & LVIF_STATE)
        {
            if (!_fIgnoreItemChanged)
            {
                // The rest only cares about SELCHANGE messages (avoid LVIS_DRAGSELECT, etc)
                if ((plvn->uNewState ^ plvn->uOldState) & (LVIS_SELECTED | LVIS_FOCUSED))
                {
                    //if we are the drag source then dont send selection change message
                    if (!_bDragSource)
                    {
                        _OnStateChange(CDBOSC_SELCHANGE);
                    }

                    OnLVSelectionChange(plvn);
                }
                else if ((plvn->uNewState ^ plvn->uOldState) & (LVIS_STATEIMAGEMASK))
                {
                    if (!_bDragSource)
                    {
                        _OnStateChange(CDBOSC_STATECHANGE);
                    }
                }
            }
        }
        break;


    // owner data state changed: e.g. search results
    case LVN_ODSTATECHANGED:
        {
            NM_ODSTATECHANGE *pnm = (NM_ODSTATECHANGE *)plvn;

            // for now handle only selection changes
            if ((pnm->uOldState ^ pnm->uNewState) & (LVIS_SELECTED | LVIS_FOCUSED))
            {
                _OnLVSelectionChange(-1, pnm->uOldState, pnm->uNewState, 0);
            }
        }
        break;

    case LVN_DELETEITEM:
        OnListViewDelete(plvn->iItem, (LPITEMIDLIST)plvn->lParam, TRUE);
        break;

    case LVN_COLUMNCLICK:
        // allow clicking on columns to set the sort order
        if (_fGroupView)
        {
            BOOL fAllowArrange = TRUE;
            UINT iRealColumn = _VisibleToRealCol(plvn->iSubItem);
            SHCOLUMNID scid;
            if (SUCCEEDED(_pshf2->MapColumnToSCID(iRealColumn, &scid)))
            {
                ICategoryProvider* pcp = NULL;
                if (SUCCEEDED(_pshf->CreateViewObject(NULL, IID_PPV_ARG(ICategoryProvider, &pcp))))
                {
                    // returns S_FALSE to remove.
                    if (S_FALSE == pcp->CanCategorizeOnSCID(&scid))
                    {
                        fAllowArrange = FALSE;
                    }
                }
            }

            if (fAllowArrange)
                _ArrangeBy(iRealColumn + SFVIDM_GROUPSFIRST);
        }
        else if (_pshf2 || _psd || HasCB())
        {
            LPARAM lParamSort       = _vs._lParamSort;
            LONG iLastColumnClick   = _vs._iLastColumnClick,
                 iLastSortDirection = _vs._iDirection;  // push sort state

            // Folder doesn't know which columns are on or off, so communication with folder uses real col #s
            UINT iRealColumn = _VisibleToRealCol(plvn->iSubItem);

            // seeral ways to do this... each can defer to the
            // ultimate default that is defview calling itself.
            HRESULT hr = S_FALSE;
            if (_psd)
                hr = _psd->ColumnClick(iRealColumn);

            if (hr != S_OK)
                hr = CallCB(SFVM_COLUMNCLICK, iRealColumn, 0);

            if (hr != S_OK)
                hr = Rearrange(iRealColumn);

            // Allows iLastColumnClick to stay valid during the above calls
            if (SUCCEEDED(hr))
                _vs._iLastColumnClick = iRealColumn;
            else
            {
                //  We failed somewhere so pop the sort state.
                _vs._iDirection = iLastSortDirection;
                _vs._iLastColumnClick = (int)_vs._lParamSort;
                _vs._lParamSort = lParamSort ;
                _SetSortFeedback();
                _vs._iLastColumnClick = iLastColumnClick;
            }
        }
        break;

    case LVN_KEYDOWN:
        HandleKeyDown(((LV_KEYDOWN *)plvn));
        break;

#define plvdi ((LV_DISPINFO *)plvn)

    case LVN_BEGINLABELEDIT:
        {
            LPCITEMIDLIST pidl = _GetPIDLParam(plvdi->item.lParam, plvdi->item.iItem);

            if (!pidl || !_Attributes(pidl, SFGAO_CANRENAME))
            {
                MessageBeep(0);
                return TRUE;        // Don't allow label edit
            }

            _fInLabelEdit = TRUE;

            HWND hwndEdit = ListView_GetEditControl(_hwndListview);
            if (hwndEdit)
            {
                int cchMax = 0;

                CallCB(SFVM_GETCCHMAX, (WPARAM)pidl, (LPARAM)&cchMax);

                if (cchMax)
                {
                    ASSERT(cchMax < 1024);
                    SendMessage(hwndEdit, EM_LIMITTEXT, cchMax, 0);
                }

                TCHAR szName[MAX_PATH];
                if (SUCCEEDED(DisplayNameOf(_pshf, pidl, SHGDN_INFOLDER | SHGDN_FOREDITING, szName, ARRAYSIZE(szName))))
                {
                    SetWindowText(hwndEdit, szName);
                }

                SHLimitInputEdit(hwndEdit, _pshf);
            }
        }
        break;

    case LVN_ENDLABELEDIT:

        _fInLabelEdit = FALSE;
        if (plvdi->item.pszText)
        {
            LPCITEMIDLIST pidl = _GetPIDLParam(plvdi->item.lParam, plvdi->item.iItem);
            if (pidl)
            {
                // this set site is questionable as folder should not have any state
                // associated with the view. but this is needed for FTP so it can
                // do an EnableModless for it's UI
                IUnknown_SetSite(_pshf, SAFECAST(this, IOleCommandTarget *));

                // Clone the pidl since isf->SetNameOf can result in a synchronous update item that
                // will free the listview owned pidl.
                LPITEMIDLIST pidlOldName = ILClone(pidl);
                if (pidlOldName)
                {
                    LPITEMIDLIST pidlNewName = NULL;    // paranoid about bad SetNameOf() impls
                    if (SUCCEEDED(_pshf->SetNameOf(_hwndMain, pidlOldName, plvdi->item.pszText, SHGDN_INFOLDER, &pidlNewName)))
                    {
                        ASSERT(NULL != pidlNewName);    // folders need to implement this
                        if (pidlNewName)
                        {
                            _DoBulkRename(pidlNewName);
                            ILFree(pidlNewName);
                        }

                        SHChangeNotifyHandleEvents();
                        _OnStateChange(CDBOSC_RENAME);
                    }
                    else
                    {
                        SendMessage(_hwndListview, LVM_EDITLABEL, plvdi->item.iItem, (LPARAM)plvdi->item.pszText);
                    }

                    ILFree(pidlOldName);
                }

                IUnknown_SetSite(_pshf, NULL);
            }
        }
        else
        {
            // The user canceled. so return TRUE to let things like the mouse
            // click be processed.
            return TRUE;
        }
        break;

    case LVN_GETDISPINFO:
        return _GetDisplayInfo(plvdi);

    case LVN_ODFINDITEM:
        // We are owner data so we need to find the item for the user...
        {
            int iItem = -1;
            if (SUCCEEDED(CallCB(SFVM_ODFINDITEM, (WPARAM)&iItem, (LPARAM)plvn)))
                return iItem;
            return -1;  // Not Found
        }

    case LVN_ODCACHEHINT:
        // Just a hint we don't care about return values
        CallCB(SFVM_ODCACHEHINT, 0, (LPARAM)plvn);
        break;

    case LVN_GETEMPTYTEXT:
        if (HasCB())
        {
            if ((plvdi->item.mask & LVIF_TEXT) &&
                SUCCEEDED(CallCB(SFVM_GETEMPTYTEXT, (WPARAM)(plvdi->item.cchTextMax), (LPARAM)(plvdi->item.pszText))))
                return TRUE;
        }
        break;

    }
#undef lpdi
#undef plvdi
    return 0;
}

// FEATURE -- implement enabling/disabling of other toolbar buttons.  We can enable/disable
// based on the current selection, but the problem is that some of the buttons work
// for other guys when defview doesn't have focus.  Specifically, cut/copy/paste work
// for the folders pane.  If we're going to enable/disable these buttons based on the
// selection, then we'll need to have a mechanism that lets the active band (such as
// folders) also have a say about the button state.  That is too much work right now.

static const UINT c_BtnCmds[] =
{
    SFVIDM_EDIT_COPYTO,
    SFVIDM_EDIT_MOVETO,
#ifdef ENABLEDISABLEBUTTONS
    SFVIDM_EDIT_COPY,
    SFVIDM_EDIT_CUT,
#endif
};

static const DWORD c_BtnAttr[] =
{
    SFGAO_CANCOPY,
    SFGAO_CANMOVE,
#ifdef ENABLEDISABLEBUTTONS
    SFGAO_CANCOPY,
    SFGAO_CANMOVE,
#endif
};

#define SFGAO_RELEVANT      (SFGAO_CANCOPY | SFGAO_CANMOVE)

// Description:
//  Called by toolbar infrastructure to determine whether to display a given
//  toolbar button in the "enabled" or "disabled" state.
//
// Return:
//  TRUE    display toolbar button in enabled state
//  FALSE   display toolbar button in disabled state
//
BOOL CDefView::_ShouldEnableToolbarButton(UINT uiCmd, DWORD dwAttr, int iIndex)
{
    COMPILETIME_ASSERT(sizeof(c_BtnCmds) == sizeof(c_BtnAttr));

    BOOL bEnable;

    switch (uiCmd)
    {
        case SFVIDM_VIEW_VIEWMENU:
            bEnable = !_fBarrierDisplayed;
            break;

        default:
        {
            DWORD dwBtnAttr;

            if (iIndex != -1)
            {
                // Caller was nice and figured out dest index for us
                dwBtnAttr = c_BtnAttr[iIndex];
            }
            else
            {
                // Look for the command ourselves
                dwBtnAttr = SHSearchMapInt((int*)c_BtnCmds, (int*)c_BtnAttr, ARRAYSIZE(c_BtnCmds), uiCmd);
                if (dwBtnAttr == -1)
                {
                    // We don't care about this button, just enable it.
                    return TRUE;
                }
            }

            // Disable any button we care about while listview is inactive.
            bEnable = BOOLIFY(dwAttr & dwBtnAttr) && _fHasListViewFocus;
            break;
        }
    }

    return bEnable;
}

// As a perf enhancement, we cache the attributes of the currently selected
// files/folders in a FS view only.  This is to avoid n^2 traversals of the
// selected items as we select/unselect them.  These cached attributes
// should not be used for anything other than determining toolbar button
// states and should be revisited if we add toolbar buttons that care about
// much more than the attributes used by Move to & Copy to.

BOOL CDefView::_GetCachedToolbarSelectionAttrs(ULONG *pdwAttr)
{
    BOOL fResult = FALSE;
    CLSID clsid;
    HRESULT hr = IUnknown_GetClassID(_pshf, &clsid);
    if (SUCCEEDED(hr) && IsEqualGUID(CLSID_ShellFSFolder, clsid))
    {
        UINT iCount;
        if (SUCCEEDED(GetSelectedCount(&iCount)) &&
            (iCount > 0) && (_uCachedSelCount > 0))
        {
            *pdwAttr = _uCachedSelAttrs;
            fResult = TRUE;
        }
    }
    return fResult;
}

void CDefView::_SetCachedToolbarSelectionAttrs(ULONG dwAttrs)
{
    if (SUCCEEDED(GetSelectedCount(&_uCachedSelCount)))
        _uCachedSelAttrs = dwAttrs;
    else
        _uCachedSelCount = 0;
}

void CDefView::_EnableDisableTBButtons()
{
    if (!IsEqualGUID(_clsid, GUID_NULL))
    {
        IExplorerToolbar *piet;
        if (SUCCEEDED(IUnknown_QueryService(_psb, SID_SExplorerToolbar, IID_PPV_ARG(IExplorerToolbar, &piet))))
        {
            ULONG dwAttr;

            if (!_GetCachedToolbarSelectionAttrs(&dwAttr))
                dwAttr = _AttributesFromSel(SFGAO_RELEVANT);

            for (int i = 0; i < ARRAYSIZE(c_BtnCmds); i++)
                _EnableToolbarButton(piet, c_BtnCmds[i], _ShouldEnableToolbarButton(c_BtnCmds[i], dwAttr, i));

            _SetCachedToolbarSelectionAttrs(dwAttr);

            piet->Release();
        }
    }
}


// Description:
//  Enables or disables a specified button on the toolbar.
//
void CDefView::EnableToolbarButton(UINT uiCmd, BOOL bEnable)
{
    if (!IsEqualGUID(_clsid, GUID_NULL))
    {
        IExplorerToolbar *piet;

        if (SUCCEEDED(IUnknown_QueryService(_psb, SID_SExplorerToolbar, IID_PPV_ARG(IExplorerToolbar, &piet))))
        {
            _EnableToolbarButton(piet, uiCmd, bEnable);
            piet->Release();
        }
    }
}


// Description:
//  Enables or disables a specified button on the toolbar.
//
// Note:
//  This is an _internal_ method only.
//  External calls should use EnableToolbarButton().
//  Caller is responsible for ensuring this object uses IExplorerToolbar mechanism.
//
void CDefView::_EnableToolbarButton(IExplorerToolbar *piet, UINT uiCmd, BOOL bEnable)
{
    ASSERT(!IsEqualGUID(_clsid, GUID_NULL));    // Required or piet cannot be valid.
    ASSERT(piet);                               // Required or we're not using IExplorerToolbar mechanism.

    UINT uiState;

    if (SUCCEEDED(piet->GetState(&_clsid, uiCmd, &uiState)))
    {
        if (bEnable)
            uiState |= TBSTATE_ENABLED;
        else
            uiState &= ~TBSTATE_ENABLED;

        piet->SetState(&_clsid, uiCmd, uiState);
    }
}


void CDefView::_OnContentsChanged()
{
    // use a timer to delay sending a gazillion content change messages to automation.
    // todo: see what duiview has to do with this stuff.

    // only fire event if someone is listening
    if (_pauto || _pDUIView)
    {
        // delay for 100ms
        SetTimer(_hwndView, DV_IDTIMER_NOTIFY_AUTOMATION_CONTENTSCHANGED, 100, NULL);
    }
    if (!_pDUIView)
    {
        _fRcvdContentsChangeBeforeDuiViewCreated = TRUE;
    }
}

void CDefView::_OnDelayedContentsChanged()
{
    KillTimer(_hwndView, DV_IDTIMER_NOTIFY_AUTOMATION_CONTENTSCHANGED);

    // update dui, would be better if there were different handlers in CDUIView
    // but go through selection changed for now.
    ATOMICRELEASE(_pSelectionShellItemArray);

    _pSelectionShellItemArray = _CreateSelectionShellItemArray();

    if (_pDUIView)
    {
        if (_fBarrierDisplayed != _QueryBarricadeState())
        {
            //
            // Yet another DUI special-case.
            // If the barrier state has changed, we need to 
            // tell DUIView about it so that the DUI right-pane
            // content is reconstructed.  This is required to make
            // Control Panel update it's right-pane content when
            // webview is turned on/off.
            //
            _fBarrierDisplayed = !_fBarrierDisplayed;
            _pDUIView->EnableBarrier (_fBarrierDisplayed);
        }
        _pDUIView->OnContentsChange(_pSelectionShellItemArray);
    }

    _FireEvent(DISPID_CONTENTSCHANGED);
}

// WARNING: don't add any code here that is expensive in anyway!
// we get many many of these notifies and if we slow this routine down
// we mess select all and large selection perf.
//
// you can add expensive code to the WM_DSV_SENDSELECTIONCHANGED handler _OnSelectionChanged,
// that happens after all of the sel change notifies go through.
//
// or you can add really expensive code to the double-click-timeout delayed _OnDelayedSelectionChange.
//
void CDefView::OnLVSelectionChange(NM_LISTVIEW *plvn)
{
    _OnLVSelectionChange(plvn->iItem, plvn->uOldState, plvn->uNewState, plvn->lParam);
}

void CDefView::_OnLVSelectionChange(int iItem, UINT uOldState, UINT uNewState, LPARAM lParam)
{
    // Do selection changed stuff on a selection change only
    if ((uOldState ^ uNewState) & LVIS_SELECTED)
    {
        // Tell the defview client that the selection may have changed
        SFVM_SELCHANGE_DATA dvsci;

        dvsci.uNewState = uNewState;
        dvsci.uOldState = uOldState;
        dvsci.lParamItem = lParam;

        CallCB(SFVM_SELCHANGE, MAKEWPARAM(SFVIDM_CLIENT_FIRST, iItem), (LPARAM)&dvsci);
    }

    // Notify the dispach that the focus changed..
    _PostSelectionChangedMessage(uOldState ^ uNewState);
}

void CDefView::_PostSelectionChangedMessage(UINT uSelectionStateChanged)
{
    if (!_fSelectionChangePending)
    {
        _uSelectionStateChanged = uSelectionStateChanged;

        // RACE CONDITION FIX (edwardp & buzzr)
        //  It is imperative to set _fSelectionChangePending _before_ posting
        //  WM_DSV_SENDSELECTIONCHANGED.  Otherwise, a race condition ensues
        //  whereby we could handle the message via _OnSelectionChanged()
        //  whose first line sets _fSelectionChangePending = FALSE before we
        //  have set it to TRUE here.  This means _fSelectionChangePending
        //  will never again be set to FALSE (since the this thread will be
        //  rescheduled, set it to TRUE, and the action of clearing it will
        //  already be past).  This was happening with 100% reproducability
        //  with our background CGetCommandStateTask for WIA devices.  The
        //  symptom most noticeable was that the DUI pane (task lists and
        //  details) no longer updated with each selection change.
        _fSelectionChangePending = TRUE;
        PostMessage(_hwndView, WM_DSV_SENDSELECTIONCHANGED, 0, 0);
    }
    else
    {
        _uSelectionStateChanged |= uSelectionStateChanged;
    }
}

void CDefView::_OnSelectionChanged() // handles WM_DSV_SENDSELECTIONCHANGED
{
    _fSelectionChangePending = FALSE; // release this first so code we call doesn't think we're "pending" any more

    if (_uSelectionStateChanged & LVIS_SELECTED)
    {
        // Get and cache the data object for the current selection
        ATOMICRELEASE(_pSelectionShellItemArray);
        _pSelectionShellItemArray = _CreateSelectionShellItemArray();

        // Update DUIView
        if (_pDUIView)
            _pDUIView->OnSelectionChange(_pSelectionShellItemArray);

        _UpdateStatusBar(FALSE);
        _EnableDisableTBButtons();
    }

    // Only fire selection change events if someone is listening
    // and if the selection changed event was not caused by going into Edit mode (why?)
    if (_pauto && !_fInLabelEdit)
    {
        // Send out the selection changed notification to the automation after a delay.
        if (!_bAutoSelChangeTimerSet)
        {
            _bAutoSelChangeTimerSet = TRUE;
            _uAutoSelChangeState = _uSelectionStateChanged;
        }
        else
        {
            _uAutoSelChangeState |= _uSelectionStateChanged;
        }

        // But not too long, since parts of our UI update when they receive this event.
        // (Update the timer every time to keep delaying it during rapid selection change events)
        SetTimer(_hwndView, DV_IDTIMER_NOTIFY_AUTOMATION_SELCHANGE, GetDoubleClickTime()/2, NULL);
    }
}

void CDefView::_OnDelayedSelectionChange() // handles DV_IDTIMER_NOTIFY_AUTOMATION_SELCHANGE
{
    if (_bAutoSelChangeTimerSet)
    {
        KillTimer(_hwndView, DV_IDTIMER_NOTIFY_AUTOMATION_SELCHANGE);

        if (_uAutoSelChangeState & LVIS_SELECTED)
            _FireEvent(DISPID_SELECTIONCHANGED);

        if (_uAutoSelChangeState & LVIS_FOCUSED)
            _FireEvent(DISPID_FOCUSCHANGED);

        _bAutoSelChangeTimerSet = FALSE;
    }
}

void CDefView::_PostNoItemStateChangedMessage()
{
    if (_pauto && !_fNoItemStateChangePending)
    {
        PostMessage(_hwndView, WM_DSV_SENDNOITEMSTATECHANGED, 0, 0);
        _fNoItemStateChangePending = TRUE;
    }
}

void CDefView::_OnNoItemStateChanged()
{
    _FireEvent(DISPID_NOITEMSTATE_CHANGED);
    _fNoItemStateChangePending = FALSE;
}

void CDefView::_PostEnumDoneMessage()
{
    PostMessage(_hwndView, WM_DSV_FILELISTENUMDONE, 0, 0);
}

void CDefView::_PostFillDoneMessage()
{
    _ShowSearchUI(TRUE);
    PostMessage(_hwndView, WM_DSV_FILELISTFILLDONE, 0, 0);
}

void CDefView::_OnEnumDoneMessage()
{
    if (_pauto)
        _FireEvent(DISPID_FILELISTENUMDONE);

    if (_pfnEnumReadyCallback)
        _pfnEnumReadyCallback(_pvEnumCallbackData);
}



#define IN_VIEW_BMP     0x8000
#define EXT_VIEW_GOES_HERE 0x4000
#define PRIVATE_TB_FLAGS (IN_VIEW_BMP | EXT_VIEW_GOES_HERE)
#define IN_STD_BMP      0x0000


LRESULT CDefView::_OnNotify(NMHDR *pnm)
{
    switch (pnm->idFrom)
    {
    case ID_LISTVIEW:
        return _OnLVNotify((NM_LISTVIEW *)pnm);

    case FCIDM_TOOLBAR:
        return _TBNotify(pnm);

    default:

        switch (pnm->code)
        {
        case TTN_NEEDTEXT:
            #define ptt ((LPTOOLTIPTEXT)pnm)
            _GetToolTipText(ptt->hdr.idFrom, ptt->szText, ARRAYSIZE(ptt->szText));
            #undef ptt
            break;

        case NM_RCLICK:
            if (GetParent(pnm->hwndFrom) == _hwndListview)
            {
                POINT p;
                GetMsgPos(&p);
                _DoColumnsMenu(p.x, p.y);
                return 1;                           // To keep normal context menu from appearing
            }
        }
    }

    return 0;
}

// ask the folder for the default column state
DWORD CDefView::_DefaultColumnState(UINT iCol)
{
    DWORD dwState;
    if (_pshf2)
    {
        if (FAILED(_pshf2->GetDefaultColumnState(iCol, &dwState)))
        {
            dwState = SHCOLSTATE_ONBYDEFAULT;   // deal with E_NOTIMPL GetDefaultColumState implementations
        }
    }
    else
    {
        dwState = SHCOLSTATE_ONBYDEFAULT;
    }
    return dwState;
}

// SHCOLSTATE_ONBYDEFAULT
//
// columns that are turn on for this view (are displayed in the UI)

BOOL CDefView::_IsDetailsColumn(UINT iCol)
{
    return (_vs.GetColumnState(iCol) & SHCOLSTATE_ONBYDEFAULT) ? TRUE : FALSE;
}

BOOL CDefView::_IsColumnInListView(UINT iCol)
{
    return ((_vs.GetColumnState(iCol) & SHCOLSTATE_ONBYDEFAULT) ||
            (_vs.GetTransientColumnState(iCol) & SHTRANSCOLSTATE_TILEVIEWCOLUMN)) ? TRUE : FALSE;
}

BOOL CDefView::_IsTileViewColumn(UINT iCol)
{
    return (_vs.GetTransientColumnState(iCol) & SHTRANSCOLSTATE_TILEVIEWCOLUMN) ? TRUE : FALSE;
}



// SHCOLSTATE_HIDDEN
//
// columns that should not be displayed in the UI, but are exposed from
// the psf2->GetDetailsEx(). this is a way to have programtic access to properties
// that don't show up in details view

BOOL CDefView::_IsColumnHidden(UINT uCol)
{
    return (_vs.GetColumnState(uCol) & SHCOLSTATE_HIDDEN) ? TRUE : FALSE;
}

#define COL_CM_MAXITEMS     25    // how many item show up in context menu before more ... is inserted

HRESULT CDefView::AddColumnsToMenu(HMENU hm, DWORD dwBase)
{
    BOOL bNeedMoreMenu = FALSE;
    HRESULT hr = E_FAIL;

    if (_vs._hdsaColumns)
    {
        AppendMenu(hm, MF_STRING | MF_CHECKED | MF_GRAYED, dwBase, _vs.GetColumnName(0));
        for (UINT i = 1; i < min(COL_CM_MAXITEMS, _vs.GetColumnCount()); i++)
        {
            DWORD dwFlags = _vs.GetColumnState(i);
            if (!(dwFlags & SHCOLSTATE_HIDDEN))
            {
                if (dwFlags & SHCOLSTATE_SECONDARYUI)
                    bNeedMoreMenu = TRUE;
                else
                    AppendMenu(hm, MF_STRING | (dwFlags & SHCOLSTATE_ONBYDEFAULT) ? MF_CHECKED : 0,
                        dwBase + i, _vs.GetColumnName(i));
            }
        }

        if (bNeedMoreMenu || (_vs.GetColumnCount() > COL_CM_MAXITEMS))
        {
            TCHAR szMore[MAX_COLUMN_NAME_LEN];
            LoadString(HINST_THISDLL, IDS_COL_CM_MORE, szMore, ARRAYSIZE(szMore));
            AppendMenu(hm, MF_SEPARATOR, 0, NULL);
            AppendMenu(hm, MF_STRING, SFVIDM_VIEW_COLSETTINGS, szMore);
        }
        hr = S_OK;
    }

    return hr;
}

UINT CDefView::_RealToVisibleCol(UINT iReal)
{
    ASSERT(_bLoadedColumns && _vs.GetColumnCount());

    int iVisible = -1;  // start here to get zero based result
    int cMax = min(_vs.GetColumnCount() - 1, iReal);

    for (int i = 0; i <= cMax; i++)
    {
        if (_IsColumnInListView(i))
        {
            iVisible++;
        }
    }
    ASSERT(-1 != iVisible);
    return iVisible;
}

// map listview (zero based) column indexes
// indexs (zero based)

UINT CDefView::_VisibleToRealCol(UINT iVisible)
{
    ASSERT(_bLoadedColumns && _vs.GetColumnCount());

    for (UINT i = 0, cVisibleSeen = 0; i < _vs.GetColumnCount(); i++)
    {
        if (_IsColumnInListView(i))
        {
            if (cVisibleSeen == iVisible)
            {
                return i;
            }
            cVisibleSeen++;
        }
    }
     ASSERT(0);  // should never get a vis col not in the real
    return 0;
}

void CDefView::_AddTileColumn(UINT uCol)
{
    if (_IsColumnInListView(uCol))
    {
        // All we need to do is make sure it's marked as a tile column
        _vs.SetTransientColumnState(uCol, SHTRANSCOLSTATE_TILEVIEWCOLUMN, SHTRANSCOLSTATE_TILEVIEWCOLUMN);
        return;
    }

    _vs.SetTransientColumnState(uCol, SHTRANSCOLSTATE_TILEVIEWCOLUMN, SHTRANSCOLSTATE_TILEVIEWCOLUMN);

    // Now that we set the transient state, we can get the new visible column index
    // for this guy, and add it to the listview.
    UINT uColVis = _RealToVisibleCol(uCol);
    _AddColumnToListView(uCol, uColVis);

    // We now need to reset the tile info for each item. We can make an optimization:
    // if this column was added at the end (i.e. biggest visible column), it won't affect
    // any of the current tiles, so we don't need to do this. Passing -1 gives us the
    // largest visible index.
    if (_RealToVisibleCol(-1) != uColVis)
    {
        _ResetTileInfo(uColVis, TRUE);
    }
}

// Remove all columns that were added because of tileview (unless they were also
// added for other reasons).
// Note: This should only be called when leaving tileview, since we do not reset the
// items' tileinfo.
void CDefView::_RemoveTileColumns()
{
    for (UINT uCol = 0; uCol < _vs.GetColumnCount(); uCol++)
    {
        if (_IsTileViewColumn(uCol))
        {
            // First nuke the tile bit.
            UINT uColVis = _RealToVisibleCol(uCol);
            _vs.SetTransientColumnState(uCol, SHTRANSCOLSTATE_TILEVIEWCOLUMN, 0);

            // Then go ahead and remove it from listview if it wasn't a details column
            if (!_IsDetailsColumn(uCol))
            {
                ListView_DeleteColumn(_hwndListview, uColVis);
            }
        }
    }
}

// This method resets the tileinfo for each item in the listview, based on which
// visible column we just added or removed.
// uColVis = the visible column that was added or removed.
// Note: This must be called prior to there being any tileinfo in the listview containing
// a reference to this new column.
void CDefView::_ResetTileInfo(UINT uColVis, BOOL bAdded)
{
    if (!_IsOwnerData())
    {
        UINT rguColumns[TILEVIEWLINES];

        for (int i = 0; i < ListView_GetItemCount(_hwndListview); i++)
        {
            UINT uColBoundary = uColVis;
            LVITEM lvi;
            lvi.mask = LVIF_COLUMNS | LVIF_NORECOMPUTE;
            lvi.iSubItem = 0;
            lvi.iItem = i;
            lvi.cColumns = ARRAYSIZE(rguColumns);
            lvi.puColumns = rguColumns;

            if (!ListView_GetItem(_hwndListview, &lvi))
                continue;

            if ((lvi.cColumns == 0) || (lvi.cColumns == I_COLUMNSCALLBACK))
            {
                continue;
            }

            ASSERT(lvi.cColumns <= ARRAYSIZE(rguColumns)); // If for some reason listview has more, there's a problem
            // guard just in case
            if (lvi.cColumns > ARRAYSIZE(rguColumns))
            {
                lvi.cColumns = ARRAYSIZE(rguColumns);
            }

            UINT *puColumn = lvi.puColumns;
            BOOL bChange = FALSE;

            // Adjust the column numbers as needed: up for added, down for removed.
            int iIncDec = bAdded ? 1 : -1;
            if (!bAdded)
            {
                // What is this doing? If we've added a column X, we need to adjust columns
                // from X on up. If we've removed a column X, we need to adjust columns from
                // X+1 on up. So basically, instead of doing (*puColumn > uColBoundary), we're
                // doing (*puColumn >= (uColBoundary+1)). So we can do the same ">=" expression
                // whether or not bAdded, avoiding an if check in the loop.
                uColBoundary++;
            }

            for (UINT uCol = 0; uCol < lvi.cColumns; uCol++, puColumn++)
            {
                if (*puColumn >= uColBoundary)
                {
                    (*puColumn) = (UINT)(iIncDec + (int)(*puColumn)); // Inc or dec.
                    bChange = TRUE;
                }
            }

            if (bChange) // If there were any changes, set the ti back.
            {
                LVTILEINFO ti;
                ti.cbSize = sizeof(ti);
                ti.iItem = lvi.iItem;
                ti.cColumns = lvi.cColumns;
                ti.puColumns = lvi.puColumns;
                ListView_SetTileInfo(_hwndListview, &ti);
            }
        }
    }
}

// Called when leaving tileview, this "cleans the slate" so that we reload the
// columns properly when re-entering tileview at a later time.
void CDefView::_RemoveTileInfo()
{
    if (!_IsOwnerData())
    {
        for (int i = 0; i < ListView_GetItemCount(_hwndListview); i++)
        {
            LVTILEINFO ti = {0};
            ti.cbSize = sizeof(ti);
            ti.iItem = i;
            ti.cColumns = I_COLUMNSCALLBACK;

            ListView_SetTileInfo(_hwndListview, &ti);
        }
    }
}


// uCol is a real column number, not visible column number
// This method toggles the SHCOLSTATE_ONBYDEFAULT bit of the column,
// and adds or removes the column as necessary.
BOOL CDefView::_HandleColumnToggle(UINT uCol, BOOL bRefresh)
{
    BOOL fWasOn = _IsColumnInListView(uCol); // if its off now, we are adding it
    BOOL fWasDetailsColumn = _IsDetailsColumn(uCol);

    UINT uColVisOld = _RealToVisibleCol(uCol);

    _vs.SetColumnState(uCol, SHCOLSTATE_ONBYDEFAULT, fWasDetailsColumn ? 0 : SHCOLSTATE_ONBYDEFAULT);

    BOOL fIsOn = _IsColumnInListView(uCol); // This could == fWasOn if it's a tileview column

    UINT uColVis = _RealToVisibleCol(uCol);

    if (fIsOn != fWasOn)
    {
        if (!fWasOn)
        {
            _AddColumnToListView(uCol, uColVis);

            if (_fs.ViewMode == FVM_TILE)
            {
                _ResetTileInfo(uColVis, TRUE);
            }
        }
        else
        {
            _vs.RemoveColumn(uColVisOld);
            ListView_DeleteColumn(_hwndListview, uColVisOld);

            if (_fs.ViewMode == FVM_TILE)
            {
                _ResetTileInfo(uColVisOld, FALSE);
            }

            if (_vs._lParamSort == (int) uCol)
            {
                UINT iNewVis = _VisibleToRealCol(0);
                Rearrange(iNewVis);
            }

            if (ListView_GetSelectedColumn(_hwndListview) == (UINT)uCol)
                ListView_SetSelectedColumn(_hwndListview, -1);
        }
    }

    if (bRefresh)
    {
        ListView_RedrawItems(_hwndListview, 0, 0x7fff);
        InvalidateRect(_hwndListview, NULL, TRUE);
        UpdateWindow(_hwndListview);
    }
    return TRUE;
}

// uCol = Real column number.   uColVis = add it as this visible column.
void CDefView::_AddColumnToListView(UINT uCol, UINT uColVis)
{
    LV_COLUMN col = {0};

    // Adding a column

    col.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    col.fmt = _vs.GetColumnFormat(uCol);
    col.cx = _vs.GetColumnCharCount(uCol) * _cxChar;  // Use default width
    col.pszText = _vs.GetColumnName(uCol);
    col.cchTextMax = MAX_COLUMN_NAME_LEN;
    col.iSubItem = uCol;                // not vis

    // This is all odd... Find Files uses this, but i think it should be LVCFMT_COL_IMAGE
    if (col.fmt & LVCFMT_COL_HAS_IMAGES)
    {
        ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_SUBITEMIMAGES, LVS_EX_SUBITEMIMAGES);
        col.fmt &= ~LVCFMT_COL_HAS_IMAGES;
    }

    if (-1 != ListView_InsertColumn(_hwndListview, uColVis, &col))
    {
        // now add it to our DSA
        _vs.AppendColumn(uColVis, (USHORT) col.cx, uColVis);

        if (!_fGroupView && (_vs._lParamSort == (int)uCol))
        {
            ListView_SetSelectedColumn(_hwndListview, uColVis);
        }
    }
}



void SetHeaderSort(HWND hwndHead, int iCol, UINT sortFlags)
{
    HDITEM hdi = {HDI_FORMAT};
    Header_GetItem(hwndHead, iCol, &hdi);
    hdi.fmt &= ~(HDF_SORTUP | HDF_SORTDOWN);
    hdi.fmt |= sortFlags;
    Header_SetItem(hwndHead, iCol, &hdi);
}

void CDefView::_SetSortFeedback()
{
    HWND hwndHead = ListView_GetHeader(_hwndListview);

    // the _IsOwnerData() is bad. this keeps search from getting sort UI feedback.
    // to fix this implement a mode where the sort has not been determined and thus we don't
    // display any sort feedback. regular folders could use this too as after items have
    // been added the view is not really sorted

    if (!hwndHead || _IsOwnerData())
        return;

    BOOL fRemoveBitmapFromLastHeader = TRUE;
    int iColLast = _RealToVisibleCol(_vs._iLastColumnClick);
    int iCol = _RealToVisibleCol((UINT)_vs._lParamSort);

    if (_fGroupView)
    {
        SetHeaderSort(hwndHead, iCol, 0);
    }
    else
    {
        ListView_SetSelectedColumn(_hwndListview, iCol);

        SetHeaderSort(hwndHead, iCol, _vs._iDirection > 0 ? HDF_SORTUP : HDF_SORTDOWN);

        // Only remove the bitmap if the last header is not the one we are currently sorting by
        if (iColLast == iCol)
            fRemoveBitmapFromLastHeader = FALSE;
    }

    if (fRemoveBitmapFromLastHeader && iColLast != -1)
    {
        SetHeaderSort(hwndHead, iColLast, 0);
    }
}

// use the folder to compare two items, falling back if the lParam is not understood by
// that folder.
// 99/05/18 #341468 vtan: If the first comparison fails it may be because
// lParamSort is not understood by IShellFolder::CompareIDs (perhaps it's
// an extended column that might not be installed any more)
// In this case get the default comparison method
// and use that. If that fails use 0 which should hopefully not fail. If
// the 0 case fails we are toast with an assert.

HRESULT CDefView::_CompareIDsFallback(LPARAM lParam, LPCITEMIDLIST p1, LPCITEMIDLIST p2)
{
    HRESULT hr = _pshf->CompareIDs(lParam, p1, p2);
    if (FAILED(hr))
    {
        LPARAM lParamSort;
        _vs.GetDefaults(this, &lParamSort, NULL, NULL);

        hr = _pshf->CompareIDs(lParamSort | (SHCIDS_ALLFIELDS & lParam), p1, p2);
        if (FAILED(hr))
        {
            // even that did not work, fall back to zero based compare (pluse the all fields flag)
            hr = _pshf->CompareIDs((SHCIDS_ALLFIELDS & lParam), p1, p2);
        }
    }
    return hr;
}

// compare two items, taking into account the sort direction
int CDefView::_CompareIDsDirection(LPARAM lParam, LPCITEMIDLIST p1, LPCITEMIDLIST p2)
{
    ASSERT(_vs._iDirection != 0);
    HRESULT hr = _CompareIDsFallback(lParam, (LPITEMIDLIST)p1, (LPITEMIDLIST)p2);
    return ShortFromResult(hr) * _vs._iDirection;
}

// p1 and p2 are pointers to the lv_item's LPARAM, which is currently the pidl
int CALLBACK CDefView::_Compare(void *p1, void *p2, LPARAM lParam)
{
    CDefView *pdv = (CDefView *)lParam;
    return pdv->_CompareIDsDirection(pdv->_vs._lParamSort, (LPITEMIDLIST)p1, (LPITEMIDLIST)p2);
}

typedef struct
{
    VARIANT var;
    BOOL    fIsFolder;
} VARIANT_AND_FOLDER;

typedef struct
{
    VARIANT_AND_FOLDER *pvars;
    SHCOLUMNID scid;
    CDefView *pdv;
} VARIANT_SORT_INFO;

int CALLBACK _CompareVariantCallback(LPARAM dw1, LPARAM dw2, LPARAM lParam)
{
    VARIANT_SORT_INFO *psi = (VARIANT_SORT_INFO *)lParam;

    int iRet = 0;

    // Always put the folders first
    if (psi->pvars[dw1].fIsFolder)
    {
        if (!psi->pvars[dw2].fIsFolder)
            iRet = -1;
    }
    else if (psi->pvars[dw2].fIsFolder)
    {
        iRet = 1;
    }

    if (0 == iRet)
    {
        iRet = CompareVariants(psi->pvars[dw1].var, psi->pvars[dw2].var);
    }

    return iRet * psi->pdv->_vs._iDirection;
}

#define LV_NOFROZENITEM         -1

HRESULT CDefView::_Sort(void)
{
    HRESULT hr = CallCB(SFVM_ARRANGE, 0, _vs._lParamSort);
    if (FAILED(hr))
    {
        hr = HRESULT_FROM_WIN32(ERROR_CAN_NOT_COMPLETE);

        int iIndexRecycleBin = LV_NOFROZENITEM;
        POINT ptRecycleBin;

        _SetSortFeedback();

        // For desktop, we need to freeze the recycle bin position before we arrage other icons.
        if (_fPositionRecycleBin)
        {
            iIndexRecycleBin = _FreezeRecycleBin(&ptRecycleBin);
            _fPositionRecycleBin = FALSE;
        }

        // This is semi-bogus for defview to care whether the column is extended or not.
        // We could have modified the ISF::CompareIDs() to handle extended columns, but
        // then it would only have the pidls, and would have to re-extract any data, so
        // its much faster if we separate out the extended columns, and take advantage
        // of listview's caching abilities.
        DWORD dwState = _DefaultColumnState((UINT)_vs._lParamSort);
        SHCOLUMNID scid;
        HRESULT hrMapColumn = E_FAIL;
        if (_pshf2)
            hrMapColumn = _pshf2->MapColumnToSCID((UINT)_vs._lParamSort, &scid);

        // SHCOLSTATE_PREFER_VARCMP tells us that the folder's CompareIDs()
        // produces the same result as comparing the variants. this is an optimization
        // for folders who's CompareIDs() are slow (bit bucket)

        if (_IsOwnerData() || (dwState & (SHCOLSTATE_EXTENDED | SHCOLSTATE_PREFER_VARCMP)))
        {
            if (_GetBackgroundTaskCount(TOID_DVBackgroundEnum) == 0)
            {
                int cItems = ListView_GetItemCount(_hwndListview);
                if (cItems)
                {
                    VARIANT_SORT_INFO vsi;
                    BOOL fOkToProceed = TRUE;
                    if ((UINT)_vs._lParamSort == 0)
                    {
                        vsi.scid = SCID_NAME;
                    }
                    else if (SUCCEEDED(hrMapColumn))
                    {
                        vsi.scid = scid;
                    }
                    else
                    {
                        fOkToProceed = FALSE;
                        hr = hrMapColumn;
                    }

                    if (fOkToProceed)
                    {
                        vsi.pvars = new VARIANT_AND_FOLDER[cItems];
                        if (vsi.pvars)
                        {
                            vsi.pdv = this;

                            for (int i = 0; i < cItems; i++)
                            {
                                LPCITEMIDLIST pidl = _GetPIDL(i);
                                if (pidl)
                                {
                                    DWORD dwAttrib = SHGetAttributes(_pshf, pidl, SFGAO_FOLDER);
                                    vsi.pvars[i].fIsFolder = dwAttrib & SFGAO_FOLDER;
                                    if ((UINT)_vs._lParamSort == 0)  // This is the NAME column
                                    {
                                        WCHAR szName[MAX_PATH];
                                        if (SUCCEEDED(DisplayNameOf(_pshf, pidl, SHGDN_INFOLDER | SHGDN_NORMAL, szName, ARRAYSIZE(szName))))
                                        {
                                            InitVariantFromStr(&vsi.pvars[i].var, szName);
                                        }
                                    }
                                    else
                                    {
                                        _pshf2->GetDetailsEx(pidl, &vsi.scid, &vsi.pvars[i].var);
                                    }
                                }
                            }

                            hr = CallCB(SFVM_SORTLISTDATA, (LPARAM)_CompareVariantCallback, (LPARAM)&vsi);

                            // dont send a LVM_SORTITEMS to an ownerdraw or comctl32 will rip
                            if (FAILED(hr) && !_IsOwnerData() && ListView_SortItemsEx(_hwndListview, _CompareVariantCallback, (LPARAM)&vsi))
                                hr = S_OK;

                            for (int i = 0; i < cItems; i++)
                            {
                                VariantClear(&vsi.pvars[i].var);
                            }

                            delete [] vsi.pvars;
                        }
                    }
                }
            }
        }
        else
        {
            ASSERT(!_IsOwnerData()) // dont send a LVM_SORTITEMS to an ownerdraw or comctl32 will rip

            if (ListView_SortItems(_hwndListview, _Compare, (LPARAM)this))
                hr = S_OK;
        }

        //If we froze recycle-bin earlier, now is the time to put it in it's default position.
        if (iIndexRecycleBin != LV_NOFROZENITEM)
            _SetRecycleBinInDefaultPosition(&ptRecycleBin);
    }
    return hr;
}

// this should NOT check for whether the item is already in the listview
// if it does, we'll have some serious performance problems

int CDefView::_AddObject(LPITEMIDLIST pidl)  // takes ownership of pidl.
{
    int iItem = -1;

    // Check the commdlg hook to see if we should include this
    // object.
    if ((S_OK == _IncludeObject(pidl)) &&
        (S_FALSE != CallCB(SFVM_INSERTITEM, 0, (LPARAM)pidl)))
    {
        LV_ITEM item = {0};

        item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_COLUMNS;
        item.iItem = INT_MAX;     // add at end
        item.iImage = I_IMAGECALLBACK;
        item.pszText = LPSTR_TEXTCALLBACK;
        item.lParam = (LPARAM)pidl;        // Takes pidl ownership.
        item.cColumns = I_COLUMNSCALLBACK; // REVIEW: why not fill this in like the _UpdateObject call?  That would fix the problem where GroupBy doesn't keep the "Searching UI" going...

        iItem = ListView_InsertItem(_hwndListview, &item);

        if (iItem < 0)
        {
            ILFree(pidl);
        }
        else if (_bBkFilling)
        {
            _pEnumTask->_AddToPending(pidl);
        }

        _OnContentsChanged();
        if (iItem == 0)
        {
            _PostNoItemStateChangedMessage();
        }
    }
    else
    {
        ILFree(pidl);
    }

    return iItem;
}

// Find an item in the view

int CDefView::_FindItem(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlFound, BOOL fSamePtr, BOOL fForwards)
{
    RIP(ILFindLastID(pidl) == pidl);

    int cItems = ListView_GetItemCount(_hwndListview);
    if (_iLastFind >= cItems)
        _iLastFind = 0;

    int iItem = _iLastFind;
    if (SUCCEEDED(CallCB(SFVM_INDEXOFITEMIDLIST, (WPARAM)&iItem, (LPARAM)pidl)))
    {
        if (ppidlFound)
            *ppidlFound = (LPITEMIDLIST)_GetPIDL(iItem);    // cast as caller knows how to free this
    }
    else
    {
        iItem = -1;     // assume failure
        for (int cCounter = 0, i = _iLastFind; cCounter < cItems; cCounter++)
        {
            LPCITEMIDLIST pidlT = _GetPIDL(i);
            ASSERT(pidlT);
            if (pidlT)
            {
                if ((pidlT == pidl) ||
                    (!fSamePtr && (0 == ResultFromShort(_pshf->CompareIDs(0, pidl, pidlT)))))
                {
                    if (ppidlFound)
                        *ppidlFound = (LPITEMIDLIST)pidlT;  // cast as callers know how to free

                    _iLastFind = iItem = i;     // success
                    // TraceMsg(TF_DEFVIEW, "####FIND CACHE RESULT --- %s by %d", cCounter < iItem ? TEXT("WIN") : TEXT("LOSE"), iItem - cCounter);
                    break;
                }
            }

            if (fForwards)
            {
                i = (i+1)%cItems;
            }
            else
            {
                i = (i > 0)?(i - 1):(cItems-1);
            }
        }

        if (-1 == iItem)
        {
            _iLastFind = 0;     // didn't find it, reset this for next time
        }
    }
    return iItem;
}

int CDefView::_FindItemHint(LPCITEMIDLIST pidl, int iItem)
{
    _iLastFind = iItem;
    return _FindItem(pidl, NULL, FALSE, FALSE);
}

// Function to process the SFVM_REMOVEOBJECT message, by searching
// through the list for a match of the pidl.  If a match is found, the
// item is removed from the list and the index number is returned, else
// -1 is returned.

int CDefView::_RemoveObject(LPCITEMIDLIST pidl, BOOL fSamePtr)
{
    int i = 0;

    // Docfind will pass in a null pointer to tell us that it wants
    // to refresh the window by deleting all of the items from it.
    if (pidl == NULL)
    {
        CallCB(SFVM_DELETEITEM, 0, 0);  // view callback notify
        ListView_DeleteAllItems(_hwndListview);

        _PostNoItemStateChangedMessage();
        _OnContentsChanged();
    }
    else
    {
        // Non null go look for item.
        i = _FindItem(pidl, NULL, fSamePtr);
        if (i >= 0)
        {
            RECT rc;
            UINT uState = ListView_GetItemState(_hwndListview, i, LVIS_ALL);

            if (uState & LVIS_FOCUSED)
                ListView_GetItemRect(_hwndListview, i, &rc, LVIR_ICON);

            if (_bBkFilling)
                _pEnumTask->_DeleteFromPending(pidl);   // removes the pointer from  the pending list.

            ListView_DeleteItem(_hwndListview, i);

            // we deleted the focused item.. replace the focus to the nearest item.
            if (uState & LVIS_FOCUSED)
            {
                int iFocus = i;
                if (_IsPositionedView() || _fGroupView)
                {
                    LV_FINDINFO lvfi = {0};

                    lvfi.flags = LVFI_NEARESTXY;
                    lvfi.pt.x = rc.left;
                    lvfi.pt.y = rc.top;
                    iFocus = ListView_FindItem(_hwndListview, -1, &lvfi);
                }
                else
                {
                    if (ListView_GetItemCount(_hwndListview) >= iFocus)
                        iFocus--;
                }

                if (iFocus != -1)
                {
                    ListView_SetItemState(_hwndListview, iFocus, LVIS_FOCUSED, LVIS_FOCUSED);
                    ListView_EnsureVisible(_hwndListview, iFocus, FALSE);
                }
                else
                {
                    // RAID 372130
                    //  Notify image preview control to update its image (to
                    //  nothing).  The image preview control uses focus change
                    //  events to track when it should update the image it is
                    //  displaying.  When it receives a focus change event, it
                    //  queries the listview to see which item has focus, then
                    //  displays that item in the image preview window.  When
                    //  the last item in the listview is deleted, we need to
                    //  fire a focus change event to the image preview control
                    //  even though the focus has not changed to another item.
                    //  This way, the image preview control realizes there is
                    //  nothing with focus, and correctly displays as empty.
                    if (_fs.ViewMode == FVM_THUMBSTRIP)
                        _ThumbstripSendImagePreviewFocusChangeEvent();
                }
            }

            // Notify automation if the listview is now empty
            UINT uCount = 0;
            GetObjectCount(&uCount);
            if (!uCount)
            {
                _PostNoItemStateChangedMessage();
            }
            _OnContentsChanged();
        }
    }
    return i;
}

// search the list for a match of the first pidl.  If a match is found,
// the item is updated to the second pidl...

int CDefView::_UpdateObject(LPCITEMIDLIST pidlOld, LPCITEMIDLIST pidlNew)
{
    LPITEMIDLIST pidlOldToFree;
    int i = _FindItem(pidlOld, &pidlOldToFree, FALSE);
    if (i >= 0)
    {
        if (_IsOwnerData())
        {
            if (SUCCEEDED(CallCB(SFVM_SETITEMIDLIST, i, (LPARAM)pidlNew)))
            {
                // Invalidate the rectangle so we update the item...
                RECT rc;
                ListView_GetItemRect(_hwndListview, i, &rc, LVIR_BOUNDS);
                InvalidateRect(_hwndListview, &rc, FALSE);

                ListView_Update(_hwndListview, i);
                _OnContentsChanged();
            }
            else
            {
                i = -1;  // we failed, try to cleanup and bail.
            }
        }
        else
        {
            LPITEMIDLIST pidlNewClone = ILClone(pidlNew);
            if (pidlNewClone)
            {
                LV_ITEM item = {0};

                // We found the item so lets now update it in the
                // the view.

                item.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
                item.iItem = i;
                item.pszText = LPSTR_TEXTCALLBACK;
                item.iImage = I_IMAGECALLBACK;
                item.lParam = (LPARAM)pidlNewClone;

                // if selected, deselect it
                UINT uState = ListView_GetItemState(_hwndListview, i, LVIS_FOCUSED|LVIS_SELECTED);
                if (uState & (LVIS_FOCUSED|LVIS_SELECTED))
                {
                    _OnLVSelectionChange(i, uState, 0, (LPARAM)pidlOldToFree);
                }

                // remove the item.
                CallCB(SFVM_DELETEITEM, 0, (LPARAM)pidlOldToFree);

                // now insert it with a new pidl
                CallCB(SFVM_INSERTITEM, 0, (LPARAM)pidlNewClone);

                // if it was selected, select it again
                if (uState & (LVIS_FOCUSED|LVIS_SELECTED))
                {
                    _OnLVSelectionChange(i, 0, uState, (LPARAM)pidlNewClone);
                }

                if (_fGroupView)
                {
                    item.mask |= LVIF_GROUPID;
                    item.iGroupId = (int)_GetGroupForItem(item.iItem, pidlNewClone);
                }

                ListView_SetItem(_hwndListview, &item);

                if (_bBkFilling)
                {
                    _pEnumTask->_DeleteFromPending(pidlOld);
                    _pEnumTask->_AddToPending(pidlNewClone);
                }


                int cCols = _GetHeaderCount();
                for (item.iSubItem++; item.iSubItem < cCols; item.iSubItem++)
                {
                    ListView_SetItemText(_hwndListview, item.iItem, item.iSubItem,
                                          LPSTR_TEXTCALLBACK);
                }

                //
                // Warning!!! Only free pidlOldToFree *after* calling ListView_SetItem.  ListView_SetItem
                // can call back asking for image info on the old pidl!
                //
                // Now delete the item but don't call the callback since we did that already.
                OnListViewDelete(i, pidlOldToFree, FALSE);

                _OnContentsChanged();
            }
            else
            {
                i = -1;
            }
        }
    }
    return i;
}

//
//  invalidates all items with the given image index.
//
//  or update all items if iImage == -1
//
void CDefView::_UpdateImage(int iImage)
{
    //  -1 means update all
    //  reset the imagelists incase the size has changed, and do
    //  a full update.

    if (iImage == -1)
    {
        if (_IsImageMode())
        {
            _RemoveThumbviewTasks();
            _pImageCache->Flush(TRUE);
            _SetThumbview();
        }
        else if (_IsTileMode())
        {
            _SetTileview();
        }
        else
        {
            _SetSysImageList();
        }

        _ReloadContent();
    }
    else
    {
        // get a dc so we can optimize for visible/not visible cases
        HDC hdcLV = GetDC(_hwndListview);

        // scan the listview updating any items which match
        LV_ITEM item = {0};
        int cItems = ListView_GetItemCount(_hwndListview);
        for (item.iItem = 0; item.iItem < cItems; item.iItem++)
        {
            item.mask = LVIF_IMAGE | LVIF_PARAM | LVIF_NORECOMPUTE;

            ListView_GetItem(_hwndListview, &item);
            int iImageOld = item.iImage;

            if (item.iImage == iImage)  // this filters I_IMAGECALLBACK for us
            {
                RECT rc;
                LPCITEMIDLIST pidl = _GetPIDLParam(item.lParam, item.iItem);

                CFSFolder_UpdateIcon(_pshf, pidl);

                //
                // if the item is visible then we don't want to flicker so just
                // kick off an async extract.  if the item is not visible then
                // leave it for later by slamming in I_IMAGECALLBACK.
                //
                item.iImage = I_IMAGECALLBACK;

                if (!_IsImageMode() && ListView_GetItemRect(_hwndListview, item.iItem, &rc, LVIR_ICON) &&
                    RectVisible(hdcLV, &rc))
                {
                    int iImageNew;
                    HRESULT hr = _GetIconAsync(pidl, &iImageNew, FALSE);

                    if (hr == S_FALSE)
                        continue;

                    if (SUCCEEDED(hr))
                    {
                        if (iImageNew == iImageOld)
                        {
                            ListView_RedrawItems(_hwndListview, item.iItem, item.iItem);
                            continue;
                        }

                        item.iImage = iImageNew;
                    }
                }

                item.mask = LVIF_IMAGE;
                item.iSubItem = 0;
                ListView_SetItem(_hwndListview, &item);
            }
        }

        ReleaseDC(_hwndListview, hdcLV);
    }
}

// Function to process the SFVM_REFRESHOBJECT message, by searching
// through the list for a match of the first pidl.  If a match is found,
// the item is redrawn.

int CDefView::_RefreshObject(LPITEMIDLIST *ppidl)
{
    int i = _FindItem(ppidl[0], NULL, FALSE);
    if (i >= 0)
        ListView_RedrawItems(_hwndListview, i, i);
    return i;
}

HRESULT CDefView::_GetItemObjects(LPCITEMIDLIST **ppidl, UINT uWhat, UINT *pcItems)
{
    *pcItems = _GetItemArray(NULL, 0, uWhat);
    if (ppidl)
    {
        *ppidl = NULL;
        if (*pcItems)
        {
            *ppidl = (LPCITEMIDLIST *)LocalAlloc(LPTR, sizeof(*ppidl) * (*pcItems));
            if (*ppidl)
                _GetItemArray(*ppidl, *pcItems, uWhat);
            else
                return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

void CDefView::_SetItemPosition(int i, int x, int y)
{
    ListView_SetItemPosition32(_hwndListview, i, x, y);
    _fUserPositionedItems = TRUE;
}

void CDefView::_SetItemPos(LPSFV_SETITEMPOS psip)
{
    int i = _FindItem(psip->pidl, NULL, FALSE);
    if (i >= 0)
    {
        _SetItemPosition(i, psip->pt.x, psip->pt.y);
    }
}

// "View State" here refers to column information and icon positions
BOOL CDefView::GetViewState()
{
    BOOL bRet = FALSE;

    IPropertyBag* ppb;
    if (SUCCEEDED(IUnknown_QueryServicePropertyBag(_psb, SHGVSPB_FOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
    {
        DWORD dw;
        // Check if we've saved state before (first check) or if we may want to
        // try upgrading some settings if we haven't saved state before (second check)
        if (SUCCEEDED(SHPropertyBag_ReadDWORD(ppb, VS_PROPSTR_MODE, &dw)) ||
            SUCCEEDED(SHPropertyBag_ReadDWORD(ppb, VS_PROPSTR_FFLAGS, &dw)))
        {
            bRet = SUCCEEDED(_vs.LoadFromPropertyBag(this, ppb));
        }
        else
        {
            IStream* pstm;
            if (SUCCEEDED(_LoadGlobalViewState(&pstm)))
            {
                _vs.LoadFromStream(this, pstm);
                bRet = TRUE;
                pstm->Release();
            }
        }
        ppb->Release();
    }
    else
    {

        //  99/02/05 #226140 vtan: Try to get the view state stream
        //  from ShellBrowser. If that fails then look for a global
        //  view state stream that is stored when the user clicks on
        //  the "Like Current Folder" in the View tab of folder settings.

        //  IShellBrowser::GetViewStateStream() match the dwDefRevCount
        //  of the cabinet state to make sure that it's valid.

        IStream *pstm;
        if (SUCCEEDED(_psb->GetViewStateStream(STGM_READ, &pstm)) ||
            SUCCEEDED(_LoadGlobalViewState(&pstm)))
        {
            _vs.LoadFromStream(this, pstm);

            pstm->Release();
            bRet = TRUE;
        }
    }

    return bRet;
}

void CDefView::_UpdateEnumerationFlags()
{
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS | SSF_SHOWCOMPCOLOR, FALSE);
    _fShowAllObjects = ss.fShowAllObjects;

    // Don't allow compression coloring on the desktop proper
    _fShowCompColor  = _IsDesktop() ? FALSE : ss.fShowCompColor;
}

// starts and stops the spinning Globe animation
// indicating that we are in the process of navigating to
// a directory
void CDefView::_GlobeAnimation(BOOL fStartSpinning, BOOL fForceStop)
{
    if (_fGlobeCanSpin)
    {
        DWORD dwCmdID = 0;

        if (fStartSpinning)
        {
            if (_crefGlobeSpin++ == 0)
            {
                dwCmdID = CBRANDIDM_STARTGLOBEANIMATION;
            }
        }
        else
        {
            ASSERT(_crefGlobeSpin > 0);

            if (fForceStop || (--_crefGlobeSpin == 0))
            {
                dwCmdID = CBRANDIDM_STOPGLOBEANIMATION;

                // our navigation is over, never spin again
                _fGlobeCanSpin = FALSE;
            }
        }

        if (dwCmdID)
        {
            IUnknown_QueryServiceExec(_psb, SID_SBrandBand, &CGID_BrandCmdGroup, dwCmdID, 0, NULL, NULL);
        }
    }
}

LRESULT SearchingUIWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case GET_WM_CTLCOLOR_MSG(CTLCOLOR_STATIC):
            SetBkColor(GET_WM_CTLCOLOR_HDC(wParam, lParam, uMsg),
                    GetSysColor(COLOR_WINDOW));
            return (LRESULT)GetSysColorBrush(COLOR_WINDOW);

        default:
            return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return 0;
}

void CDefView::_ShowSearchUI(BOOL fStartSearchWindow)
{
    if (_fAllowSearchingWindow || _crefSearchWindow) // once started, make sure our refcount finishes
    {
        if (fStartSearchWindow)
        {
            if (_crefSearchWindow++ == 0)
            {
                // The static window could already exist during a refresh
                if (!_hwndStatic)
                {
                    _hwndStatic = SHCreateWorkerWindowW((WNDPROC)SearchingUIWndProc, _hwndView, 0,
                                                        WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
                                                        NULL, NULL);

                    if (_hwndStatic)
                    {
                        HWND hAnimate = CreateWindowEx(0, ANIMATE_CLASS, c_szNULL,
                                WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | ACS_TRANSPARENT | ACS_AUTOPLAY | ACS_CENTER,
                                0, 0, 0, 0, _hwndStatic, (HMENU)ID_STATIC, HINST_THISDLL, NULL);
                        if (hAnimate)
                        {
                            RECT rc;
                            GetClientRect(_hwndView, &rc);
                            // Move this window to the top so the user sees the "looking" icon
                            // We are in a "normal" view.  We need to do this always or the
                            // Flashlight doesn't appear.  It tested safe with WebView on.
                            SetWindowPos(_hwndStatic, HWND_TOP, 0, 0, rc.right, rc.bottom, 0);
                            SetWindowPos(hAnimate, HWND_TOP, 0, 0, rc.right, rc.bottom, SWP_NOZORDER);
                            _OnMoveWindowToTop(_hwndStatic);

                            SetTimer(_hwndView, DV_IDTIMER_START_ANI, 2000, NULL);    // 2 second timer
                        }
                    }
                }

                ShowHideListView();
            }
        }
        else
        {
            if (0 == _crefSearchWindow)  // if _ShowSearchUI(FALSE) gets called before _ShowSearchUI(TRUE)
            {
                _fAllowSearchingWindow = FALSE;
            }
            else if (--_crefSearchWindow == 0)
            {
                _fAllowSearchingWindow = FALSE;

                ShowHideListView();
            }
        }
    }
}


// this is only called from within SHCNE_*  don't put up ui on the enum error.
void CDefView::_FullViewUpdate(BOOL fUpdateItem)
{
    if (fUpdateItem)
        _ReloadContent(); // the folder we're looking at has changed
    else
        FillObjectsShowHide(FALSE); // our contents have changed
}

void CDefView::_ShowControl(UINT idControl, int idCmd)
{
    IBrowserService *pbs;
    if (SUCCEEDED(_psb->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
    {
        pbs->ShowControlWindow(idControl, idCmd);
        pbs->Release();
    }
}

// This function does three things:
// 1 - Alter the size of the parent to best fit around the items we have.
// 2 - Set the default icon view mode
// 3 - Make sure the correct toolbars are showing
//
void CDefView::_BestFit()
{
    // Only bestfit once
    if (_fs.fFlags & FWF_BESTFITWINDOW)
    {
        _fs.fFlags &= ~FWF_BESTFITWINDOW;

        // Make sure the correct toolbars are showing the first time this folder is displayed
        //
        int iITbar = SBSC_HIDE;
        int iStdBar = SBSC_HIDE;
        switch (_uDefToolbar)
        {
        case HIWORD(TBIF_INTERNETBAR):
            iITbar = SBSC_SHOW;
            goto ShowToolbar;

        case HIWORD(TBIF_STANDARDTOOLBAR):
            iStdBar = SBSC_SHOW;
            goto ShowToolbar;

        case HIWORD(TBIF_NOTOOLBAR):
ShowToolbar:
            _ShowControl(FCW_INTERNETBAR, iITbar);
            _ShowControl(FCW_TOOLBAR, iStdBar);
            break;
        }

    }
}

void CDefView::_ClearPostedMsgs(HWND hwnd)
{
    MSG msg;

    while (PeekMessage(&msg, hwnd, WM_DSV_UPDATEICON, WM_DSV_UPDATEICON, PM_REMOVE))
    {
        // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
        // Verify that the message was really for us.
        //
        if (msg.hwnd == hwnd)
        {
            TraceMsg(TF_DEFVIEW, "DefView: WM_DSV_UPDATEICON after WM_DESTROY!!!");
            LPITEMIDLIST pidl = (LPITEMIDLIST) msg.wParam;
            ILFree(pidl);
        }
    }

    while (PeekMessage(&msg, hwnd, WM_DSV_UPDATECOLDATA, WM_DSV_UPDATECOLDATA, PM_REMOVE))
    {
        // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
        // Verify that the message was really for us.
        //
        if (msg.hwnd == hwnd)
        {
            TraceMsg(TF_DEFVIEW, "DefView: WM_DSV_UPDATECOLDATA after WM_DESTROY!!!");
            delete (CBackgroundColInfo*)msg.lParam;
        }
    }
    while (PeekMessage(&msg, hwnd, WM_DSV_DELAYSTATUSBARUPDATE, WM_DSV_DELAYSTATUSBARUPDATE, PM_REMOVE))
    {
        if (msg.hwnd == hwnd)
        {
            LocalFree((void *)msg.lParam);
        }
    }

    while (PeekMessage(&msg, hwnd, WM_DSV_SETIMPORTANTCOLUMNS, WM_DSV_SETIMPORTANTCOLUMNS, PM_REMOVE))
    {
        // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
        // Verify that the message was really for us.
        //
        if (msg.hwnd == hwnd)
        {
            TraceMsg(TF_DEFVIEW, "DefView: WM_DSV_SETIMPORTANTCOLUMNS after WM_DESTROY!!!");
            delete (CBackgroundTileInfo*)msg.lParam;
        }
    }

    while (PeekMessage(&msg, hwnd, WM_DSV_SETITEMGROUP, WM_DSV_SETITEMGROUP, PM_REMOVE))
    {
        // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
        // Verify that the message was really for us.
        //
        if (msg.hwnd == hwnd)
        {
            TraceMsg(TF_DEFVIEW, "DefView: WM_DSV_SETITEMGROUP after WM_DESTROY!!!");
            delete (CBackgroundGroupInfo*)msg.lParam;
        }
    }

    while (PeekMessage(&msg, hwnd, WM_DSV_UPDATETHUMBNAIL, WM_DSV_UPDATETHUMBNAIL, PM_REMOVE))
    {
        // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
        // Verify that the message was really for us.
        //
        if (msg.hwnd == hwnd)
        {
            TraceMsg(TF_DEFVIEW, "DefView: WM_DSV_UPDATETHUMBNAIL after WM_DESTROY!!!");
            _CleanupUpdateThumbnail((DSV_UPDATETHUMBNAIL*)msg.lParam);
        }
    }

    while (PeekMessage(&msg, hwnd, WM_DSV_POSTCREATEINFOTIP, WM_DSV_POSTCREATEINFOTIP, PM_REMOVE))
    {
        // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
        // Verify that the message was really for us.
        //
        if (msg.hwnd == hwnd)
        {
            TraceMsg(TF_DEFVIEW, "DefView: WM_DSV_POSTCREATEINFOTIP after WM_DESTROY!!!");
            _OnPostCreateInfotipCleanup((TOOLINFO *)msg.wParam);
        }
    }
}

void CDefView::_CallRefresh(BOOL fPreRefresh)
{
    if (fPreRefresh)
    {
        IUnknown_Exec(_pshf, NULL, OLECMDID_REFRESH, 0, NULL, NULL);
    }

    CallCB(SFVM_REFRESH, fPreRefresh, 0);
}

void CDefView::FillDone()
{
    SendMessage(_hwndListview, WM_SETREDRAW, (WPARAM)FALSE, 0);
    _fListviewRedraw = TRUE;

    AddRef(); // hold a ref to ourself while in this function.

    _fAllowSearchingWindow = FALSE;

    _PostFillDoneMessage();

    if (_bBkFilling)
        _OnStopBackgroundEnum();

    HRESULT hr = _pEnumTask->FillObjectsDoneToView();
    _pEnumTask->Release();
    _pEnumTask = NULL;

    if (SUCCEEDED(hr))
    {
        // Clear our error state, if we were in one
        _fEnumFailed = FALSE;

        if (_fSyncOnFillDone)
        {
            _vs.Sync(this, TRUE);
            _fSyncOnFillDone = FALSE;
        }

        ShowHideListView();

        // set the focus on the first item.
        _FocusOnSomething();

        _DoThumbnailReadAhead();
    }
    else
    {
        // The fill objects failed for some reason, go into error mode
        TraceMsg(TF_WARNING, "::FillObjects failed to enumerate for some reason");
        _fEnumFailed = TRUE;
        ShowHideListView();
    }

    // Tell the defview client that this window has been refreshed
    _CallRefresh(FALSE);
    _OnContentsChanged();

    _UpdateStatusBar(TRUE);
    _PostEnumDoneMessage();

    Release();

    SendMessage(_hwndListview, WM_SETREDRAW, (WPARAM)TRUE, 0);
    _fListviewRedraw = FALSE;
}

HRESULT CDefView::_OnStartBackgroundEnum()
{
    _GlobeAnimation(TRUE);
    _ShowSearchUI(TRUE);
    _bBkFilling = TRUE;

    return S_OK;
}

HRESULT CDefView::_OnStopBackgroundEnum()
{
    _bBkFilling = FALSE;
    _GlobeAnimation(FALSE);
    _ShowSearchUI(FALSE);

    return S_OK;
}

HRESULT CDefView::_OnBackgroundEnumDone()
{
    FillDone();

    _UpdateStatusBar(FALSE);

    CallCB(SFVM_BACKGROUNDENUMDONE, 0, 0);

    return S_OK;
}

HRESULT EmptyBkgrndThread(IShellTaskScheduler *pScheduler)
{
    HRESULT hr = S_OK;

    if (pScheduler)
    {
        // empty the queue and wait until it is empty.....
        hr = pScheduler->RemoveTasks(TOID_NULL, ITSAT_DEFAULT_LPARAM, TRUE);
    }
    return hr;
}

DWORD CDefView::_GetEnumFlags()
{
    // Setup the enum flags.
    DWORD grfEnumFlags = SHCONTF_NONFOLDERS;
    if (_fShowAllObjects)
        grfEnumFlags |= SHCONTF_INCLUDEHIDDEN;

    //Is this View in Common Dialog
    if (!(grfEnumFlags & SHCONTF_INCLUDEHIDDEN))
    {
        // Ask Common dialog if its wants to show all files
        ICommDlgBrowser2 *pcdb2;
        if (SUCCEEDED(_psb->QueryInterface(IID_PPV_ARG(ICommDlgBrowser2, &pcdb2))))
        {
            DWORD dwFlags = 0;
            pcdb2->GetViewFlags(&dwFlags);
            if (dwFlags & CDB2GVF_SHOWALLFILES)
                grfEnumFlags |= SHCONTF_INCLUDEHIDDEN;
            pcdb2->Release();
        }
    }

    if (!(_fs.fFlags & FWF_NOSUBFOLDERS))
        grfEnumFlags |= SHCONTF_FOLDERS;

    return grfEnumFlags;
}

HRESULT CDefView::FillObjectsShowHide(BOOL fInteractive)
{
    HRESULT hr = S_OK;

    DECLAREWAITCURSOR;
    SetWaitCursor();            // This is a potentially long operation

    // To get here we're either not enumerating at all,
    // or we are enumerating on the background thread,
    // or we got re-entered
    ASSERT((!_pEnumTask&&!_bBkFilling) || (_pEnumTask));
    if (_pEnumTask)
    {
        if (fInteractive)
        {
            // This is in response to the user pressing F5,
            // assume the current enumeration will be valid
            hr = S_FALSE;
        }
        else if (!_bBkFilling)
        {
            // We're not on the background but we have a _pEnumTask, this means
            // that we got re-entered during the below call to FillObjectsToDPA.
            // Assume the current enumeration attempt will be valid
            hr = S_FALSE;
        }
        else
        {
            if (_pScheduler)
            {
                // An UPDATEDIR or equivalent happened, anything already enumerated could be bad.
                // Tell the current enumeration task to give up
                _pScheduler->RemoveTasks(TOID_DVBackgroundEnum, ITSAT_DEFAULT_LPARAM, FALSE);
                _pScheduler->RemoveTasks(TOID_DVBackgroundGroup, ITSAT_DEFAULT_LPARAM, TRUE);
            }

            ASSERT(_bBkFilling);
            _OnStopBackgroundEnum();

            _pEnumTask->Release();
            _pEnumTask = NULL;
        }
    }

    if (S_OK==hr)
    {
        _pEnumTask = new CDefviewEnumTask(this, ++_dwEnumId);
        if (_pEnumTask)
        {
            // Note: It is possible for us to get re-entered during FillObjectsToDPA,
            // since we pass our HWND to the enumerator.
            _pEnumTask->FillObjectsToDPA(fInteractive);
            hr = _pEnumTask->FillObjectsDPAToDone();
        }
        else
        {
            _fEnumFailed = TRUE;
            ShowHideListView();

            hr = E_OUTOFMEMORY;
        }
    }

    ResetWaitCursor();
    return hr;
}


//  This implementation uses following assumptions.
//  (1) The IShellFolder uses CDefFolderMenu.
//  (2) The CDefFolderMenu always add the folder at the top.

#define EC_SELECTION  0
#define EC_BACKGROUND 1
#define EC_EITHER     3

HRESULT CDefView::_ExplorerCommand(UINT idFCIDM)
{
    HRESULT hr = E_FAIL;

    static struct {
        UINT    idmFC;
        UINT    fBackground;
        LPCTSTR pszVerb;
    } const c_idMap[] = {
        { SFVIDM_FILE_RENAME,      EC_SELECTION,  c_szRename },
        { SFVIDM_FILE_DELETE,      EC_SELECTION,  c_szDelete },
        { SFVIDM_FILE_PROPERTIES,  EC_EITHER,     c_szProperties },
        { SFVIDM_EDIT_COPY,        EC_SELECTION,  c_szCopy },
        { SFVIDM_EDIT_CUT,         EC_SELECTION,  c_szCut },
        { SFVIDM_FILE_LINK,        EC_SELECTION,  c_szLink },
        { SFVIDM_EDIT_PASTE,       EC_BACKGROUND, c_szPaste },
        { SFVIDM_EDIT_PASTELINK,   EC_BACKGROUND, c_szPasteLink },
    };

    for (int i = 0; i < ARRAYSIZE(c_idMap); i++)
    {
        if (c_idMap[i].idmFC == idFCIDM)
        {
            IContextMenu *pcm;

            if (c_idMap[i].fBackground == EC_BACKGROUND)
            {
                hr = _pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IContextMenu, &pcm));
            }
            else
            {
                hr = _CreateSelectionContextMenu(IID_PPV_ARG(IContextMenu, &pcm));
                if (FAILED(hr) && (c_idMap[i].fBackground == EC_EITHER) && !ListView_GetSelectedCount(_hwndListview))
                {
                    hr = _pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IContextMenu, &pcm));
                }
            }

            if (SUCCEEDED(hr))
            {
                CMINVOKECOMMANDINFOEX ici = {0};

                ici.cbSize = sizeof(ici);
                ici.hwnd = _hwndMain;
                ici.nShow = SW_NORMAL;

                // record if shift or control was being held down
                SetICIKeyModifiers(&ici.fMask);

                // Fill in both the ansi verb and the unicode verb since we
                // don't know who is going to be processing this thing.
                CHAR szVerbAnsi[40];
                SHUnicodeToAnsi(c_idMap[i].pszVerb, szVerbAnsi, ARRAYSIZE(szVerbAnsi));
                ici.lpVerb = szVerbAnsi;
                ici.lpVerbW = c_idMap[i].pszVerb;
                ici.fMask |= CMIC_MASK_UNICODE;

                HMENU hmenu = CreatePopupMenu();
                if (hmenu)
                {
                    IUnknown_SetSite(pcm, SAFECAST(this, IOleCommandTarget *));

                    pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, 0);

                    _bContextMenuMode = TRUE;

                    hr = _InvokeContextMenu(pcm, &ici);

                    _bContextMenuMode = FALSE;

                    DestroyMenu(hmenu);

                    IUnknown_SetSite(pcm, NULL);
                }

                pcm->Release();
            }
            else
            {
                // keys are pressed when there is no selection.
                MessageBeep(0);
            }
            break;
        }
        ASSERT(i < ARRAYSIZE(c_idMap));
    }

    return hr;
}

STDAPI_(BOOL) Def_IsPasteAvailable(IDropTarget *pdtgt, DWORD *pdwEffect);

BOOL CDefView::_AllowCommand(UINT uID)
{
    DWORD dwAttribsIn;
    DWORD dwEffect;

    switch (uID)
    {
    case SFVIDM_EDIT_PASTE:
        return Def_IsPasteAvailable(_pdtgtBack, &dwEffect);

    case SFVIDM_EDIT_PASTELINK:
        Def_IsPasteAvailable(_pdtgtBack, &dwEffect);
        return dwEffect & DROPEFFECT_LINK;

    case SFVIDM_EDIT_COPY:
        dwAttribsIn = SFGAO_CANCOPY;
        break;

    case SFVIDM_EDIT_CUT:
        dwAttribsIn = SFGAO_CANMOVE;
        break;

    case SFVIDM_FILE_DELETE:
        dwAttribsIn = SFGAO_CANDELETE;
        break;

    case SFVIDM_FILE_LINK:
        dwAttribsIn = SFGAO_CANLINK;
        break;

    case SFVIDM_FILE_PROPERTIES:
        dwAttribsIn = SFGAO_HASPROPSHEET;
        break;

    default:
        ASSERT(FALSE);
        return FALSE;
    }
    return _AttributesFromSel(dwAttribsIn) & dwAttribsIn;
}


// return copy of pidl of folder we're viewing
LPITEMIDLIST CDefView::_GetViewPidl()
{
    LPITEMIDLIST pidl;
    if (SHGetIDListFromUnk(_pshf, &pidl) != S_OK)    // S_FALSE is success by empty
    {
        if (SUCCEEDED(CallCB(SFVM_THISIDLIST, 0, (LPARAM)&pidl)))
        {
            ASSERT(pidl);
        }
        else if (_SetupNotifyData() && _pidlMonitor)
        {
            pidl = ILClone(_pidlMonitor);
        }
    }
    return pidl;
}

inline BOOL CDefView::_ItemsDeferred()
{
    return _hdsaSelect != NULL;
}

BOOL CDefView::_IsListviewVisible()
{
    return _fListViewShown;
}

inline BOOL CDefView::_IsOwnerData()
{
    return _fs.fFlags & FWF_OWNERDATA;
}

inline BOOL CDefView::_IsCommonDialog()
{
    return NULL != _pcdb;
}

BOOL CDefView::_IsDesktop()
{
    return _fs.fFlags & FWF_DESKTOP;
}

BOOL CDefView::_IsViewDesktop()
{
    BOOL bDesktop = FALSE;
    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        bDesktop = ILIsEmpty(pidl);
        ILFree(pidl);
    }
    return bDesktop;
}

// access to the current views name ala IShellFolder::GetDisplayNameOf()

HRESULT CDefView::_GetNameAndFlags(UINT gdnFlags, LPTSTR pszPath, UINT cch, DWORD *pdwFlags)
{
    *pszPath = 0;

    HRESULT hr;
    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        hr = SHGetNameAndFlags(pidl, gdnFlags, pszPath, cch, pdwFlags);
        ILFree(pidl);
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

// returns TRUE if the current view is a file system folder, returns the path

BOOL CDefView::_GetPath(LPTSTR pszPath)
{
    *pszPath = 0;

    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        SHGetPathFromIDList(pidl, pszPath);
        ILFree(pidl);
    }
    return *pszPath != 0;
}

EXTERN_C TCHAR const c_szHtmlWindowsHlp[] = TEXT("windows.chm");


// web view background colors, click mode, etc have changed
//
void CDefView::_UpdateListviewColors()
{
    // First clear out our state
    for (int i = 0; i < ARRAYSIZE(_crCustomColors); i++)
        _crCustomColors[i] = CLR_MYINVALID;

    // Then read the registry/desktop.ini
    LPCTSTR pszLegacyWatermark = NULL;
    SFVM_CUSTOMVIEWINFO_DATA cvi = {0};
    if (SUCCEEDED(CallCB(SFVM_GETCUSTOMVIEWINFO, (WPARAM)0, (LPARAM)&cvi)))
    {
        if (!_IsCommonDialog() && !_IsDesktop())
        {
            // Set up the listview image, if any
            if (*cvi.szIconAreaImage)
            {
                pszLegacyWatermark = cvi.szIconAreaImage;
            }

            // change the differing stuff
            //
            if (!_fClassic)
            {
                for (i = 0; i < ARRAYSIZE(_crCustomColors); i++)
                {
                    COLORREF cr = cvi.crCustomColors[i];
                    if (ISVALIDCOLOR(cr))
                    {
                        _crCustomColors[i] = PALETTERGB(0, 0, 0) | cr;
                    }
                }

                // if there was an image specified but no custom text background,
                // set to CLR_NONE so the listview text is transparent
                // get combined view custom colors
                if (!ISVALIDCOLOR(_crCustomColors[CRID_CUSTOMTEXTBACKGROUND]) && cvi.szIconAreaImage[0])
                {
                    _crCustomColors[CRID_CUSTOMTEXTBACKGROUND] = CLR_NONE;
                }
            }
        }
    }

    _SetLegacyWatermark(pszLegacyWatermark);

    _SetFolderColors();

    _UpdateSelectionMode();
}

BOOL CDefView::HasCurrentViewWindowFocus()
{
    BOOL fRet = false;
    HWND hwndCurrentFocus = GetFocus();
    if (hwndCurrentFocus)
    {
        fRet = (SHIsChildOrSelf(_hwndListview, hwndCurrentFocus) == S_OK);
    }
    return fRet;
}

HWND CDefView::ViewWindowSetFocus()
{
    SetFocus(_hwndListview);
    if (!_IsDesktop())
    {
        _cFrame._uState = SVUIA_ACTIVATE_FOCUS;
    }
    return _hwndListview;
}

HRESULT CDefView::_GetSFVMViewState(UINT uViewMode, SFVM_VIEW_DATA* pvi)
{
    HRESULT hr = CallCB(SFVM_GETVIEWDATA, (WPARAM)uViewMode, (LPARAM)pvi);
    if (FAILED(hr))
    {
        pvi->dwOptions = SFVMQVI_NORMAL;
    }
    return hr;
}
HRESULT CDefView::_GetSFVMViewInfoTemplate(UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    return CallCB(SFVM_GETWEBVIEW_TEMPLATE, (WPARAM)uViewMode, (LPARAM)pvit);
}


HRESULT CDefView::_GetWebViewMoniker(LPWSTR pszMoniker, DWORD cchMoniker)
{
    SFVM_WEBVIEW_TEMPLATE_DATA vit;
    if (SUCCEEDED(_GetSFVMViewInfoTemplate(_fs.ViewMode, &vit)))
    {
        StrCpyN(pszMoniker, vit.szWebView, cchMoniker);
    }
    else
    {
        pszMoniker[0] = L'\0';
    }
    return *pszMoniker ? S_OK : E_FAIL;
}

// Show or hide Web View content
//
// This does not affect the View Mode of the listview (it does tweak desktop listview for _fCombinedView stuff)
//
// fShow==TRUE -> hr is success/fail of showing web view
// fShow==FALSE -> hr is E_FAIL (nobody looks at return code of turning web view off)
//
HRESULT CDefView::_SwitchToWebView(BOOL fShow)
{
    HRESULT hr = E_FAIL;

    // Cache the focus/select state across this transition
    BOOL bSetFocusRequired = HasCurrentViewWindowFocus();

    if (fShow)
    {
        // For now, the desktop is always a combined view...
        if (_IsDesktop())
        {
            BOOL fCombinedViewOld = (BOOL)_fCombinedView;
            SHELLSTATE ss;
            SHGetSetSettings(&ss, SSF_HIDEICONS | SSF_DESKTOPHTML | SSF_STARTPANELON, FALSE);

            // Does the user want desktop in HyperText view?
            if (ss.fDesktopHTML)
                _fCombinedView = TRUE;

            if (ss.fHideIcons)
                _fs.fFlags |= FWF_NOICONS;
            else
                _fs.fFlags &= ~FWF_NOICONS;

            if (_fCombinedView && !fCombinedViewOld)
            {
                EnableCombinedView(this, TRUE);
                ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_REGIONAL, LVS_EX_REGIONAL);
                _SetFolderColors();
            }
        }

        WCHAR wszMoniker[MAX_PATH];
        hr = _GetWebViewMoniker(wszMoniker, ARRAYSIZE(wszMoniker));
        if (SUCCEEDED(hr))
        {
            if (_IsDesktop())
            {
                IActiveDesktopP *piadp;
                if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_ActiveDesktop, NULL, IID_PPV_ARG(IActiveDesktopP, &piadp))))
                {
                    piadp->EnsureUpdateHTML();
                    piadp->Release();
                }
                hr = _cFrame.ShowWebView(wszMoniker);
            }
            else if (SHRestricted(REST_REVERTWEBVIEWSECURITY))
            {
                hr = _cFrame.ShowWebView(wszMoniker);
            }
            else if (!_fUserRejectedWebViewTemplate)
            {
                WCHAR szTemplate[MAX_PATH];
                DWORD cchTemplate = ARRAYSIZE(szTemplate);

                if (PathIsURL(wszMoniker))
                {
                    hr = PathCreateFromUrl(wszMoniker, szTemplate, &cchTemplate, 0);
                }
                else
                {
                    StringCchCopy(szTemplate, ARRAYSIZE(szTemplate), wszMoniker);
                }

                if (SUCCEEDED(hr))
                {
                    DWORD dwFlags = SHRVT_VALIDATE | SHRVT_ALLOW_INTRANET;
                    if (SHRestricted(REST_ALLOWUNHASHEDWEBVIEW))
                    {
                        dwFlags |= SHRVT_PROMPTUSER | SHRVT_REGISTERIFPROMPTOK;
                    }
                    hr = SHRegisterValidateTemplate(szTemplate, dwFlags);
                    if (SUCCEEDED(hr))
                    {
                        hr = _cFrame.ShowWebView(wszMoniker);
                    }
                    else
                    {
                        _fUserRejectedWebViewTemplate = TRUE;
                    }
                }
            }
        }

        if (FAILED(hr))
        {
            fShow = FALSE;
        }
        else
        {
            RECT rcClient;

            // Make sure the new view is the correct size
            GetClientRect(_hwndView, &rcClient);
            _cFrame.SetRect(&rcClient);

            ShowHideListView();
        }
    }

    if (!fShow)
    {
        _cFrame.HideWebView();

        // If we were combined, then get the listview out of region mode and
        // reset the color scheme.  Also, turn off the combined bit.
        if (_fCombinedView)
        {
            _fCombinedView = FALSE;
            ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_REGIONAL, 0);
            EnableCombinedView(this, FALSE);
            _SetFolderColors();
        }
    }

    // restore focus/select state -- if we switched to web view it will put much of
    // this into a "pending" state until the listview is re-shown inside the web content
    //
    if (bSetFocusRequired)
    {
        CallCB(SFVM_SETFOCUS, 0, 0);
        ViewWindowSetFocus();
    }

    CheckToolbar();
    _EnableDisableTBButtons();

    // make sure that the listview settings get refreshed anyway (back image)
    _UpdateListviewColors();

    return hr;
}

void CDefView::_RemoveThumbviewTasks()
{
    if (_pScheduler)
    {
        _pScheduler->RemoveTasks(TOID_ExtractImageTask, ITSAT_DEFAULT_LPARAM, FALSE);
        _pScheduler->RemoveTasks(TOID_CheckCacheTask, ITSAT_DEFAULT_LPARAM, FALSE);
        _pScheduler->RemoveTasks(TOID_ReadAheadHandler, ITSAT_DEFAULT_LPARAM, FALSE);
        _fReadAhead = FALSE;
    }
}

//
// This function checkes to see if the list view needs to be shown; then shows it.
// If it needs to be hidden, hides it!  You must call this function every time
// you change a bit of state that could change the show/hide state of listview.
//
// Let me repeat that: call this function EVERY TIME you change state that
// affects our show/hide.
//
HRESULT CDefView::ShowHideListView()
{
    // NOTE: this is where most of the flicker bugs come from -- showing the
    // listview too early.  This is touchy code, so be careful when you change it.
    // And plese document all changes for future generations.  Thanks.
    //
    // Standard "is listview shown" check
    //
    // If our view hasn't been UIActivate()d yet, then we are waiting until
    // the IShellBrowser selects us as the active view.
    //
    // App compat for above UIActivate() change:
    //    Adaptec Easy CD Creator never calls IShellView::UIActivate.
    // They got away with it because UIActivate didn't used to do much,
    // but now we use UIActivate to decide when to show our icons. They forget
    // to call it and the icons never show up.
    //    So if we are in Win95 Defview compatibility mode, then
    // go ahead and show the icons now.  The app gets flicker, but at least
    // the icons show up at all.
    //
    // Don't show the listview if we're told to not show it, or we see an error during enum.
    //
    // If we're enumerating in the background, don't show
    //
    // Potential problem: We used to defer SelectPendingSelectedItems until:
    // "_fListViewShown && (_cFrame._dwConnectionCookie /*&& !_cFrame._fReadyStateInteractiveProcessed*/)"
    // Selecting before readystatedone may pose a problem, but I don't see how it could
    // be a problem unless showing the view early is a problem as well, which this code didn't check.
    //

    if ((!_cFrame.IsWebView() || _fGetWindowLV || _fCombinedView) // we think icons should be visible
     && (_uState != SVUIA_DEACTIVATE || (SHGetAppCompatFlags(ACF_WIN95DEFVIEW) & ACF_WIN95DEFVIEW)) // async defview means we don't show before we transition out of DEACTIVE
     && !(BOOLIFY(_fs.fFlags & FWF_NOICONS)) // check if we've been told to not show icons
     && !_fEnumFailed // failed enumeration wants _hwndView to show through, not _hwndListview
     && !(_crefSearchWindow && _hwndStatic) // keep the listview hidden while we show the "searching" window
       )
    {
        // Make sure we do each transition only once - we do more than just show the window
        if (!_fListViewShown)
        {
            _fListViewShown = TRUE;

            // Bring this to the top while showing it to avoid a second paint when
            // _hwndStatic is destroyed (listview has optimizations when hidden,
            // and it will repaint when once shown even if though it may be obscured)
            //
            SetWindowPos(_hwndListview, HWND_TOP, 0, 0, 0, 0,
                SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);
            _OnMoveWindowToTop(_hwndListview);

            // Remove _hwndStatic after listview is moved to top to avoid a re-paint
            if (_hwndStatic)
            {
                DestroyWindow(_hwndStatic);
                _hwndStatic = NULL;
            }

            // if we need to select items, do it now that the window is shown
            SelectPendingSelectedItems();
        }
    }
    else
    {
        if (_fListViewShown)
        {
            _fListViewShown = FALSE;
            ShowWindow(_hwndListview, SW_HIDE);
        }

        // If FWF_NOICONS is set and the enumertion went to the background thread we need
        // to make sure that we turn of the searchui.
        if (BOOLIFY(_fs.fFlags & FWF_NOICONS) && _hwndStatic && 0 == _crefSearchWindow)
        {
            DestroyWindow(_hwndStatic);
            _hwndStatic = NULL;
        }
    }

    return S_OK;
}

IShellItemArray* CDefView::_GetFolderAsShellItemArray()
{
    if (!_pFolderShellItemArray && _pshfParent && _pidlRelative)
    {
        SHCreateShellItemArray(NULL, _pshfParent, 1, (LPCITEMIDLIST *)&_pidlRelative, &_pFolderShellItemArray);
    }
    return _pFolderShellItemArray;
}

// if the attributes dwAttribMask for pdo exactly match dwAttribValue, this item should be enabled
HRESULT CDefView::_CheckAttribs(IShellItemArray *psiItemArray, DWORD dwAttribMask, DWORD dwAttribValue, UISTATE* puisState)
{
    DWORD dwAttrib = 0;
    HRESULT hr;

    if (NULL == psiItemArray)
    {
        psiItemArray = _GetFolderAsShellItemArray();
    }

    if (psiItemArray)
    {
        hr = psiItemArray->GetAttributes(SIATTRIBFLAGS_APPCOMPAT, dwAttribMask, &dwAttrib);
        if (FAILED(hr))
            dwAttrib = 0;
    }
    else
        hr = S_OK;

    *puisState = (dwAttribValue == dwAttrib) ? UIS_ENABLED : UIS_HIDDEN;

    return hr;
}

HRESULT CDefView::_CanWrite(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_CheckAttribs(psiItemArray, SFGAO_READONLY|SFGAO_STORAGE, SFGAO_STORAGE, puisState);
}
HRESULT CDefView::_CanRename(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_CheckAttribs(psiItemArray, SFGAO_CANRENAME, SFGAO_CANRENAME, puisState);
}
HRESULT CDefView::_CanMove(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_CheckAttribs(psiItemArray, SFGAO_CANMOVE, SFGAO_CANMOVE, puisState);
}
HRESULT CDefView::_CanCopy(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_CheckAttribs(psiItemArray,SFGAO_CANCOPY, SFGAO_CANCOPY, puisState);
}

HRESULT CDefView::_CanPublish(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    *puisState = UIS_HIDDEN;

    if ((pThis->_wvLayout.dwLayout & SFVMWVL_NOPUBLISH) || SHRestricted(REST_NOPUBLISHWIZARD))
    {
        // bail out early with UIS_HIDDEN, we dont show the verb
        return S_OK;
    }

    // Iterate first 10 items because that is what old code did before
    // switching to IShellItemArray. Since the attribs that are
    // being requested for are already being cached in the ShellItemArray
    // may as well always ask for all.

    if (psiItemArray)
    {
        IEnumShellItems *pEnumShellItems;
        if (SUCCEEDED(psiItemArray->EnumItems(&pEnumShellItems)))
        {
            IShellItem *pShellItem;
            DWORD dwIterationCount = 0;
            BOOL fHide = FALSE, fHasStreams = FALSE, fHasStorages = FALSE;

            while (!fHide && (dwIterationCount < 10) && (S_OK == pEnumShellItems->Next(1, &pShellItem, NULL)))
            {
                SFGAOF dwAttribs = SFGAO_STORAGE | SFGAO_STREAM;
                HRESULT hrAttribs = pShellItem->GetAttributes(dwAttribs, &dwAttribs);

                pShellItem->Release();
                pShellItem = NULL; // null to catch if we use it again.

                if (SUCCEEDED(hrAttribs))
                {
                    if (!(dwAttribs & (SFGAO_STORAGE | SFGAO_STREAM)))
                    {
                        // if this item doesn't have either storage or stream, hide the task.
                        fHide = TRUE;
                    }
                    else if (dwAttribs & SFGAO_STREAM)
                    {
                        // if we have a folder and files, hide the task.
                        fHide = fHasStorages;
                        fHasStreams = TRUE;
                    }
                    else if (dwAttribs & SFGAO_STORAGE)
                    {
                        // if we have multiple folders or a folder and files, hide the task.
                        fHide = fHasStorages || fHasStreams;
                        fHasStorages = TRUE;
                    }
                }

                ++dwIterationCount;
            }

            if (!fHide)
                *puisState = UIS_ENABLED;

            pEnumShellItems->Release();
        }
    }
    else
    {
        // if nothing is selected, enable the task if the current folder is a storage.
        LPITEMIDLIST pidl = pThis->_GetViewPidl();
        if (pidl)
        {
            if (SHGetAttributes(NULL, pidl, SFGAO_STORAGE))
            {
                *puisState = UIS_ENABLED;
            }
            ILFree(pidl);
        }
    }

    return S_OK;
}


// Note - _DoesStaticMenuHaveVerb only checks the first pidl in the data object for now
// So only use it for single-selections
// -DSheldon
BOOL CDefView::_DoesStaticMenuHaveVerb(IShellItemArray *psiItemArray, LPCWSTR pszVerb)
{
    BOOL fHasVerb = FALSE;
    IShellItem *pshItem;

    // get first shellItem in the array.
    if (SUCCEEDED(psiItemArray->GetItemAt(0,&pshItem)))
    {
        IQueryAssociations* pqa;
        if (SUCCEEDED(pshItem->BindToHandler(NULL, BHID_SFUIObject, IID_PPV_ARG(IQueryAssociations, &pqa))))
        {
            DWORD cch = 0;
            fHasVerb = SUCCEEDED(pqa->GetString(0, ASSOCSTR_COMMAND, pszVerb, NULL, &cch));
            pqa->Release();
        }
        pshItem->Release();
    }
    return fHasVerb;
}

HRESULT CDefView::_GetFullPathNameAt(IShellItemArray *psiItemArray,DWORD dwIndex,LPOLESTR *ppszPath)
{
    HRESULT hr = E_FAIL;
    IShellItem *pShellItem;

    if (NULL == psiItemArray || NULL == ppszPath)
    {
        ASSERT(psiItemArray);
        ASSERT(ppszPath);

        return E_INVALIDARG;
    }
    // get the path of the first item in the ShellArray.
    hr = psiItemArray->GetItemAt(dwIndex,&pShellItem);

    if (SUCCEEDED(hr))
    {
        hr = pShellItem->GetDisplayName(SIGDN_FILESYSPATH,ppszPath);
        pShellItem->Release();
    }

    return hr;
}

HRESULT CDefView::_CanShare(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    HRESULT hr = E_FAIL;

    CDefView* pThis = (CDefView*)(void*)pv;
    *puisState = UIS_DISABLED;

    if (!psiItemArray)
    {
        psiItemArray = pThis->_GetFolderAsShellItemArray();
    }

    if (psiItemArray)
    {
#ifdef DEBUG
        // Sanity check.
        DWORD dwNumItems;
        ASSERT(S_OK == psiItemArray->GetCount(&dwNumItems));
        ASSERT(1 == dwNumItems);
#endif

        IShellItem *psi;
        hr = psiItemArray->GetItemAt(0, &psi);
        if (SUCCEEDED(hr))
        {
            // Retrieve pidl.
            LPITEMIDLIST pidl;
            hr = SHGetIDListFromUnk(psi, &pidl);
            if (SUCCEEDED(hr))
            {
                // Retrieve path and attributes.
                WCHAR szPath[MAX_PATH];
                DWORD dwAttributes = SFGAO_LINK;
                hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), &dwAttributes);
                if (SUCCEEDED(hr) &&  !(dwAttributes & SFGAO_LINK) && !PathIsRemote(szPath))
                {
                    if (!g_hmodNTSHRUI)
                    {
                        g_hmodNTSHRUI = LoadLibrary(L"ntshrui.dll");
                    }

                    if (g_hmodNTSHRUI)
                    {
                        PFNCANSHAREFOLDERW pfnCanShareFolder = (PFNCANSHAREFOLDERW)GetProcAddress(g_hmodNTSHRUI, "CanShareFolderW");
                        if (pfnCanShareFolder)
                        {
                            *puisState = (S_OK == pfnCanShareFolder(szPath)) ? UIS_ENABLED : UIS_DISABLED;
                        }
                    }
                }
                ILFree(pidl);
            }
            psi->Release();
        }
    }

    return hr;
}

HRESULT CDefView::_CanEmail(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    DWORD dwAttributes = 0;

    // Prevent people from attempting to e-mail non-filesystem objects.
    // Attempting to attach such objects to an e-mail message fails.
    // An example of this type of failure is attempting to e-mail
    // connectoids in the "Network Connections" folder.

    if (psiItemArray)
    {
        psiItemArray->GetAttributes(SIATTRIBFLAGS_APPCOMPAT, SFGAO_FILESYSTEM, &dwAttributes);
    }

    *puisState = dwAttributes & SFGAO_FILESYSTEM ? UIS_ENABLED : UIS_DISABLED;

    return S_OK;
}

HRESULT CDefView::_CanPrint(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    if (!(((CDefView*)(void*)pv)->_wvLayout.dwLayout & SFVMWVL_NOPRINT))
        return _HasPrintVerb(pv, psiItemArray, fOkToBeSlow, puisState);

    *puisState = UIS_HIDDEN;
    return S_OK;
}

HRESULT CDefView::_HasPrintVerb(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{

    CDefView* pThis = (CDefView*)(void*)pv;

    if (!psiItemArray)
    {
        psiItemArray = pThis->_GetFolderAsShellItemArray();
    }

    BOOL fHasPrint = _DoesStaticMenuHaveVerb(psiItemArray,c_szPrintW);

    *puisState = (fHasPrint) ? UIS_ENABLED : UIS_HIDDEN;

    return S_OK;
}
HRESULT CDefView::_CanDelete(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_CheckAttribs(psiItemArray, SFGAO_CANDELETE, SFGAO_CANDELETE, puisState);
}
// determines if defview is hosted over the system drive root or not
BOOL CDefView::_IsSystemDrive(void)
{
    TCHAR szPath[MAX_PATH];
    TCHAR szSystemDrive[4];
    BOOL bResult = FALSE;

    if (SUCCEEDED(_GetPath(szPath)))
    {
        SHExpandEnvironmentStrings (TEXT("%SystemDrive%\\"), szSystemDrive, ARRAYSIZE(szSystemDrive));

        if (!lstrcmpi(szPath, szSystemDrive))
        {
            bResult = TRUE;
        }
    }

    return bResult;
}
HRESULT CDefView::_CanViewDrives(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    *puisState = UIS_DISABLED;

    if (pThis->_wvContent.dwFlags & SFVMWVF_BARRICADE)
    {
        if (pThis->_fBarrierDisplayed)
        {
            if (pThis->_IsSystemDrive())
            {
                *puisState = UIS_ENABLED;
            }
        }
    }

    return S_OK;
}
HRESULT CDefView::_CanHideDrives(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    *puisState = UIS_DISABLED;

    if (pThis->_wvContent.dwFlags & SFVMWVF_BARRICADE)
    {
        if (!pThis->_fBarrierDisplayed)
        {
            if (pThis->_IsSystemDrive())
            {
                *puisState = UIS_ENABLED;
            }
        }
    }

    return S_OK;
}
HRESULT CDefView::_CanViewFolder(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    *puisState = UIS_DISABLED;

    if (pThis->_wvContent.dwFlags & SFVMWVF_BARRICADE)
    {
        if (pThis->_fBarrierDisplayed)
        {
            if (!pThis->_IsSystemDrive())
            {
                *puisState = UIS_ENABLED;
            }
        }
    }

    return S_OK;
}
HRESULT CDefView::_CanHideFolder(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    *puisState = UIS_DISABLED;

    if (pThis->_wvContent.dwFlags & SFVMWVF_BARRICADE)
    {
        if (!pThis->_fBarrierDisplayed)
        {
            if (!pThis->_IsSystemDrive())
            {
                *puisState = UIS_ENABLED;
            }
        }
    }

    return S_OK;
}
HRESULT CDefView::_HasPreviousVersions(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    HRESULT hr = S_OK;

    *puisState = UIS_HIDDEN;

    if (!psiItemArray)
    {
        CDefView* pThis = (CDefView*)(void*)pv;
        psiItemArray = pThis->_GetFolderAsShellItemArray();
    }
    if (NULL != psiItemArray)
    {
#ifdef DEBUG
        // Sanity check.
        DWORD dwNumItems;
        ASSERT(S_OK == psiItemArray->GetCount(&dwNumItems));
        ASSERT(1 == dwNumItems);
#endif
        BOOL bHasShadowCopy = FALSE;

        // This returns E_PENDING if the answer is unknown
        // and fOkToBeSlow is FALSE
        hr = HavePreviousVersionsAt(psiItemArray, 0, fOkToBeSlow, &bHasShadowCopy);
        if (S_OK == hr && bHasShadowCopy)
        {
            *puisState = UIS_ENABLED;
        }
    }
    return hr;
}

HRESULT CDefView::_DoVerb(IShellItemArray *psiItemArray, LPCSTR pszVerbA)
{
    HRESULT hr = E_FAIL;

    if (NULL== psiItemArray)
    {
        IContextMenu* pcm;
        hr = GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARG(IContextMenu, &pcm));
        if (SUCCEEDED(hr))
        {
            hr = _InvokeContextMenuVerb(pcm, pszVerbA, 0, CMIC_MASK_FLAG_LOG_USAGE);
            pcm->Release();
        }
    }
    else
    {
        ASSERT(psiItemArray == _pSelectionShellItemArray);
        hr = _InvokeContextMenuVerbOnSelection(pszVerbA, 0, CMIC_MASK_FLAG_LOG_USAGE);
    }

    return hr;
}

HRESULT CDefView::_DoDropOnClsid(REFCLSID clsidDrop, IDataObject* pdo)
{
    HRESULT hr = E_FAIL;
    IDataObject *pdoFree = NULL;

    if (!pdo)
    {
        IShellItemArray *pFolder = _GetFolderAsShellItemArray();
        if (pFolder)
        {
            hr = pFolder->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdoFree));
            if (SUCCEEDED(hr))
            {
                pdo = pdoFree;
            }
            else
            {
                pdoFree = NULL;
            }
        }
    }

    if (pdo)
    {
        hr = SHSimulateDropOnClsid(clsidDrop, SAFECAST(this, IOleCommandTarget *), pdo);
    }

    ATOMICRELEASE(pdoFree); // may be NULL

    return hr;
}

HRESULT CDefView::_OnNewFolder(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_DoVerb(psiItemArray,c_szNewFolderA);
}

HRESULT CDefView::_OnRename(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->DoRename();
}

HRESULT CDefView::_OnMove(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_DoMoveOrCopyTo(CLSID_MoveToMenu, psiItemArray);
}

HRESULT CDefView::_OnCopy(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_DoMoveOrCopyTo(CLSID_CopyToMenu, psiItemArray);
}

HRESULT CDefView::_OnPublish(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    HRESULT hr = S_OK;
    IDataObject *pdo = NULL;

    CDefView* pThis = (CDefView*)(void*)pv;

    if (psiItemArray)
    {
        hr = psiItemArray->BindToHandler(NULL, BHID_DataObject, IID_PPV_ARG(IDataObject, &pdo));
    }

    if (SUCCEEDED(hr))
    {
        hr = pThis->_DoDropOnClsid(CLSID_PublishDropTarget, pdo);
    }

    ATOMICRELEASE(pdo); // may be NULL

    return hr;
}

HRESULT CDefView::_OnShare(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    HRESULT hr = E_FAIL;

    CDefView* pThis = (CDefView*)(void*)pv;

    if (!psiItemArray)
    {
        psiItemArray = pThis->_GetFolderAsShellItemArray();
    }

    if (NULL != psiItemArray)
    {
        LPOLESTR pszPath;

        hr = pThis->_GetFullPathNameAt(psiItemArray, 0, &pszPath);

        if (SUCCEEDED(hr))
        {
            if (!g_hmodNTSHRUI)
            {
                g_hmodNTSHRUI = LoadLibrary(L"ntshrui.dll");
            }

            if (g_hmodNTSHRUI)
            {
                PFNSHOWSHAREFOLDERUIW pfnShowShareFolderUI = (PFNSHOWSHAREFOLDERUIW) GetProcAddress(g_hmodNTSHRUI, "ShowShareFolderUIW");
                if (pfnShowShareFolderUI)
                {
                    pfnShowShareFolderUI(pThis->_hwndMain, pszPath);
                }
            }

            CoTaskMemFree(pszPath);
        }
    }

    return hr;
}

HRESULT CDefView::_OnEmail(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    HRESULT hr = E_FAIL;
    IDataObject *pdo = NULL;

    if (psiItemArray)
    {
        hr = psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdo));
    }

    if (SUCCEEDED(hr))
    {
        CDefView* pThis = (CDefView*)(void*)pv;
        BOOL bNoFilesFoundToEmail = TRUE;

        INamespaceWalk *pnsw;
        hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(INamespaceWalk, &pnsw));
        if (SUCCEEDED(hr))
        {
            // Note:
            //  To mirror the behaviour of the selection context menu's "Send To->
            //  Mail Recipient", don't traverse links, mail the link file itself.

            hr = pnsw->Walk(pdo, NSWF_DONT_TRAVERSE_LINKS, 0, NULL);
            if (SUCCEEDED(hr))
            {
                UINT cItems;
                LPITEMIDLIST *ppidls;
                hr = pnsw->GetIDArrayResult(&cItems, &ppidls);
                if (SUCCEEDED(hr))
                {
                    if (cItems)
                    {
                        IDataObject* pdoWalk;
                        hr = SHCreateFileDataObject(&c_idlDesktop, cItems, (LPCITEMIDLIST *)ppidls, NULL, (IDataObject **)&pdoWalk);
                        if (SUCCEEDED(hr))
                        {
                            hr = pThis->_DoDropOnClsid(CLSID_MailRecipient, pdoWalk);
                            bNoFilesFoundToEmail = FALSE;
                            pdoWalk->Release();
                        }
                    }
                    FreeIDListArray(ppidls, cItems);
                }
            }
            pnsw->Release();
        }

        if (bNoFilesFoundToEmail)
        {
            // No items found to e-mail (selected folders contained no files).
            ShellMessageBox(
                HINST_THISDLL,
                pThis->_hwndMain,
                MAKEINTRESOURCE(IDS_NOFILESTOEMAIL),
                NULL,
                MB_OK | MB_ICONERROR);
        }

        pdo->Release();
    }
    return hr;
}

HRESULT CDefView::_OnPrint(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_DoVerb(psiItemArray,c_szPrintA);
}

HRESULT CDefView::_OnDelete(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    return pThis->_DoVerb(psiItemArray,c_szDeleteA);
}

HRESULT CDefView::RemoveBarricade (void)
{
    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        TCHAR szValueName[MAX_PATH];
        if (GetBarricadeValueNameFromPidl(pidl, szValueName, ARRAYSIZE(szValueName)))
        {
            SetBarricadeStatus (szValueName, VARIANT_FALSE);
        }
        ILFree(pidl);
    }

    // Restore "View" menu commands which were stripped.
    RecreateMenus();
    // Enable "View Menu" button on the toolbar.
    EnableToolbarButton(SFVIDM_VIEW_VIEWMENU, TRUE);

    _fBarrierDisplayed = FALSE;

    return _pDUIView->EnableBarrier(FALSE);
}

HRESULT CDefView::_OnView(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    return pThis->RemoveBarricade();
}

HRESULT CDefView::_OnHide(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    LPITEMIDLIST pidl = pThis->_GetViewPidl();
    if (pidl)
    {
        TCHAR szValueName[MAX_PATH];
        if (GetBarricadeValueNameFromPidl(pidl, szValueName, ARRAYSIZE(szValueName)))
        {
            SetBarricadeStatus(szValueName, VARIANT_TRUE);
        }
        ILFree(pidl);
    }

    // Disable "View Menu" button on the toolbar.
    pThis->EnableToolbarButton(SFVIDM_VIEW_VIEWMENU, FALSE);

    pThis->_fBarrierDisplayed = TRUE;

    return pThis->_pDUIView->EnableBarrier(TRUE);
}

HRESULT CDefView::_OnAddRemovePrograms(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    HCURSOR hcOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    SHRunControlPanel(L"appwiz.cpl", NULL);

    SetCursor(hcOld);

    return S_OK;
}

HRESULT CDefView::_OnSearchFiles(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;

    return IUnknown_ShowBrowserBar (pThis->_psb, CLSID_FileSearchBand, TRUE);
}

HRESULT CDefView::_OnPreviousVersions(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDefView* pThis = (CDefView*)(void*)pv;
    if (!psiItemArray)
    {
        psiItemArray = pThis->_GetFolderAsShellItemArray();
    }
    ShowPreviousVersionsAt(psiItemArray, 0, pThis->_hwndMain);
    return S_OK;
}

const WVTASKITEM c_DefviewBlockadeTaskHeader = WVTI_HEADER_ENTRY(L"shell32.dll", IDS_HEADER_DEFVIEW_BLOCKADE, IDS_HEADER_DEFVIEW_BLOCKADE, IDS_HEADER_DEFVIEW_BLOCKADE, IDS_HEADER_DEFVIEW_BLOCKADE, IDS_HEADER_DEFVIEW_BLOCKADE_TT);
const WVTASKITEM c_DefviewBlockadeTasks[] =
{
    WVTI_ENTRY_ALL(UICID_ViewContents,      L"shell32.dll", IDS_TASK_DEFVIEW_VIEWCONTENTS_DRIVE,    IDS_TASK_DEFVIEW_VIEWCONTENTS_DRIVE_TT, IDI_STSPROGS,   CDefView::_CanViewDrives, CDefView::_OnView),
    WVTI_ENTRY_ALL(UICID_HideContents,      L"shell32.dll", IDS_TASK_DEFVIEW_HIDECONTENTS_DRIVE,    IDS_TASK_DEFVIEW_HIDECONTENTS_DRIVE_TT, IDI_STSPROGS,   CDefView::_CanHideDrives, CDefView::_OnHide),
    WVTI_ENTRY_ALL(UICID_ViewContents,      L"shell32.dll", IDS_TASK_DEFVIEW_VIEWCONTENTS_FOLDER,   IDS_TASK_DEFVIEW_VIEWCONTENTS_FOLDER_TT,IDI_STSPROGS,   CDefView::_CanViewFolder, CDefView::_OnView),
    WVTI_ENTRY_ALL(UICID_HideContents,      L"shell32.dll", IDS_TASK_DEFVIEW_HIDECONTENTS_FOLDER,   IDS_TASK_DEFVIEW_HIDECONTENTS_FOLDER_TT,IDI_STSPROGS,   CDefView::_CanHideFolder, CDefView::_OnHide),
    WVTI_ENTRY_ALL(UICID_AddRemovePrograms, L"shell32.dll", IDS_TASK_ARP,                           IDS_TASK_ARP_TT,                        IDI_CPCAT_ARP,  NULL,                     CDefView::_OnAddRemovePrograms),
    WVTI_ENTRY_ALL(UICID_SearchFiles,       L"shell32.dll", IDS_TASK_SEARCHFORFILES,                IDS_TASK_SEARCHFORFILES_TT,             IDI_STFIND,     NULL,                     CDefView::_OnSearchFiles),
};


const WVTASKITEM c_DefviewFileFolderTasksHeaders = WVTI_HEADER(L"shell32.dll", IDS_HEADER_FILEFOLDER, IDS_HEADER_FILEFOLDER_TT);
const WVTASKITEM c_DefviewItemFolderTasksHeaders = WVTI_HEADER(L"shell32.dll", IDS_HEADER_ITEMFOLDER, IDS_HEADER_ITEMFOLDER_TT);

const WVTASKITEM c_DefviewFileFolderTasks[] =
{
    WVTI_ENTRY_NOSELECTION(UICID_NewFolder, L"shell32.dll", IDS_TASK_CURFOLDER_NEWFOLDER,                                                                           IDS_TASK_CURFOLDER_NEWFOLDER_TT, IDI_TASK_NEWFOLDER, CDefView::_CanWrite,
        CDefView::_OnNewFolder),
    WVTI_ENTRY_TITLE(UICID_Rename,          L"shell32.dll",                             IDS_TASK_RENAME_FILE, IDS_TASK_RENAME_FOLDER,       0,                      IDS_TASK_RENAME_FILE_TT,         IDI_TASK_RENAME,    CDefView::_CanRename,
        CDefView::_OnRename),
    WVTI_ENTRY_TITLE(UICID_Move,            L"shell32.dll",                             IDS_TASK_MOVE_FILE,   IDS_TASK_MOVE_FOLDER,         IDS_TASK_MOVE_ITEMS,    IDS_TASK_MOVE_TT,                IDI_TASK_MOVE,      CDefView::_CanMove,
        CDefView::_OnMove),
    WVTI_ENTRY_ALL_TITLE(UICID_Copy,        L"shell32.dll", 0,                          IDS_TASK_COPY_FILE,   IDS_TASK_COPY_FOLDER,         IDS_TASK_COPY_ITEMS,    IDS_TASK_COPY_TT,                IDI_TASK_COPY,      CDefView::_CanCopy,
        CDefView::_OnCopy),
    WVTI_ENTRY_ALL_TITLE(UICID_Publish,     L"shell32.dll", IDS_TASK_PUBLISH_FOLDER,    IDS_TASK_PUBLISH_FILE,IDS_TASK_PUBLISH_FOLDER,      IDS_TASK_PUBLISH_ITEMS, IDS_TASK_PUBLISH_TT,             IDI_TASK_PUBLISH,   CDefView::_CanPublish,
        CDefView::_OnPublish),
    WVTI_ENTRY_ALL_TITLE(UICID_Share,       L"shell32.dll", IDS_TASK_SHARE_FOLDER,      0,                    IDS_TASK_SHARE_FOLDER,        0,                      IDS_TASK_SHARE_TT,               IDI_TASK_SHARE,     CDefView::_CanShare,
        CDefView::_OnShare),
    WVTI_ENTRY_TITLE(UICID_Email,           L"shell32.dll",                             IDS_TASK_EMAIL_FILE,  IDS_TASK_EMAIL_FOLDER,        IDS_TASK_EMAIL_ITEMS,   IDS_TASK_EMAIL_TT,               IDI_TASK_EMAILFILE, CDefView::_CanEmail,
        CDefView::_OnEmail),
    WVTI_ENTRY_TITLE(UICID_Print,           L"shell32.dll",                             IDS_TASK_PRINT_FILE,  0,                            0,                      IDS_TASK_PRINT_TT,               IDI_TASK_PRINT,     CDefView::_CanPrint,
        CDefView::_OnPrint),
    WVTI_ENTRY_TITLE(UICID_Delete,          L"shell32.dll",                             IDS_TASK_DELETE_FILE, IDS_TASK_DELETE_FOLDER,       IDS_TASK_DELETE_ITEMS,  IDS_TASK_DELETE_TT,              IDI_TASK_DELETE,    CDefView::_CanDelete,
        CDefView::_OnDelete),
    WVTI_ENTRY_ALL_TITLE(UICID_PreviousVersions, L"shell32.dll", IDS_TASK_SHADOW,       IDS_TASK_SHADOW,      IDS_TASK_SHADOW,              0,                      IDS_TASK_SHADOW_TT,              IDI_TASK_SHADOW,    CDefView::_HasPreviousVersions,
        CDefView::_OnPreviousVersions),
};
const size_t c_cDefviewFileFolderTasks = ARRAYSIZE(c_DefviewFileFolderTasks);

const WVTASKITEM c_DefviewItemFolderTasks[] =
{
    WVTI_ENTRY_NOSELECTION(UICID_NewFolder, L"shell32.dll", IDS_TASK_CURFOLDER_NEWFOLDER,                                                                           IDS_TASK_CURFOLDER_NEWFOLDER_TT, IDI_TASK_NEWFOLDER, CDefView::_CanWrite,
        CDefView::_OnNewFolder),
    WVTI_ENTRY_TITLE(UICID_Rename,          L"shell32.dll",                             IDS_TASK_RENAME_ITEM, IDS_TASK_RENAME_FOLDER,       0,                      IDS_TASK_RENAME_ITEM_TT,         IDI_TASK_RENAME,    CDefView::_CanRename,
        CDefView::_OnRename),
    WVTI_ENTRY_TITLE(UICID_Move,            L"shell32.dll",                             IDS_TASK_MOVE_ITEM,   IDS_TASK_MOVE_FOLDER,         IDS_TASK_MOVE_ITEMS,    IDS_TASK_MOVE_TT,                IDI_TASK_MOVE,      CDefView::_CanMove,
        CDefView::_OnMove),
    WVTI_ENTRY_ALL_TITLE(UICID_Copy,        L"shell32.dll", 0,                          IDS_TASK_COPY_ITEM,   IDS_TASK_COPY_FOLDER,         IDS_TASK_COPY_ITEMS,    IDS_TASK_COPY_TT,                IDI_TASK_COPY,      CDefView::_CanCopy,
        CDefView::_OnCopy),
    WVTI_ENTRY_ALL_TITLE(UICID_Share,       L"shell32.dll", IDS_TASK_SHARE_FOLDER,      0,                    IDS_TASK_SHARE_FOLDER,        0,                      IDS_TASK_SHARE_TT,               IDI_TASK_SHARE,     CDefView::_CanShare,
        CDefView::_OnShare),
    WVTI_ENTRY_TITLE(UICID_Delete,          L"shell32.dll",                             IDS_TASK_DELETE_ITEM, IDS_TASK_DELETE_FOLDER,       IDS_TASK_DELETE_ITEMS,  IDS_TASK_DELETE_TT,              IDI_TASK_DELETE,    CDefView::_CanDelete,
        CDefView::_OnDelete),
};
const size_t c_cDefviewItemFolderTasks = ARRAYSIZE(c_DefviewItemFolderTasks);

const WVTASKITEM c_DefviewOtherPlaces = WVTI_HEADER_ENTRY(L"shell32.dll", IDS_HEADER_OTHER_PLACES, IDS_HEADER_OTHER_PLACES, IDS_HEADER_OTHER_PLACES, IDS_HEADER_OTHER_PLACES, IDS_HEADER_OTHER_PLACES_TT);
const WVTASKITEM c_DefviewDetails = WVTI_HEADER_ENTRY(L"shell32.dll", IDS_HEADER_DETAILS, IDS_HEADER_DETAILS, IDS_HEADER_DETAILS, IDS_HEADER_DETAILS, IDS_HEADER_DETAILS_TT);


const WVTASKITEM* CDefView::_FindTaskItem(REFGUID guidCanonicalName)
{
    const BOOL bFileFolderTasks = _wvLayout.dwLayout & SFVMWVL_FILES;
    const WVTASKITEM *paTasks = bFileFolderTasks ? c_DefviewFileFolderTasks  : c_DefviewItemFolderTasks;
    const size_t cTasks =       bFileFolderTasks ? c_cDefviewFileFolderTasks : c_cDefviewItemFolderTasks;

    for (size_t i = 0; i < cTasks; i++)
        if (IsEqualGUID(*(paTasks[i].pguidCanonicalName), guidCanonicalName))
            return &paTasks[i];

    return NULL;
}

HRESULT CDefView::get_Name(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, LPWSTR *ppszName)
{
    const WVTASKITEM* pTask = _FindTaskItem(guidCanonicalName);
    if (pTask)
        return CWVTASKITEM::get_Name(pTask, psiItemArray, ppszName);
    return E_FAIL;
}

HRESULT CDefView::get_Icon(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, LPWSTR *ppszIcon)
{
    const WVTASKITEM* pTask = _FindTaskItem(guidCanonicalName);
    if (pTask)
        return CWVTASKITEM::get_Icon(pTask, psiItemArray, ppszIcon);
    return E_FAIL;
}

HRESULT CDefView::get_Tooltip(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, LPWSTR *ppszInfotip)
{
    const WVTASKITEM* pTask = _FindTaskItem(guidCanonicalName);
    if (pTask)
        return CWVTASKITEM::get_Tooltip(pTask, psiItemArray, ppszInfotip);
    return E_FAIL;
}

HRESULT CDefView::get_State(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, UISTATE* puisState)
{
    const WVTASKITEM* pTask = _FindTaskItem(guidCanonicalName);
    if (pTask)
        return CWVTASKITEM::get_State(pTask, SAFECAST(this, IShellView2*), psiItemArray, TRUE, puisState);
    return E_FAIL;
}

HRESULT CDefView::Invoke(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    const WVTASKITEM* pTask = _FindTaskItem(guidCanonicalName);
    if (pTask)
        return CWVTASKITEM::Invoke(pTask, SAFECAST(this, IShellView2*), psiItemArray, pbc);
    return E_FAIL;
}

HRESULT CDefView::_GetDefaultWebviewContent(BOOL bFileFolderTasks)
{
    if (!_wvTasks.penumSpecialTasks)
    {
        if (_wvContent.dwFlags & SFVMWVF_BARRICADE)
        {
           // defview provides a default penumSpecialTasks for barricaded folders
           Create_IUIElement(&c_DefviewBlockadeTaskHeader, &(_wvContent.pSpecialTaskHeader));

           Create_IEnumUICommand((IUnknown*)(void*)this, c_DefviewBlockadeTasks, ARRAYSIZE(c_DefviewBlockadeTasks), &(_wvTasks.penumSpecialTasks));
        }
    }

    if (!_wvTasks.penumFolderTasks)
    {
        if (_wvContent.pFolderTaskHeader)
            _wvContent.pFolderTaskHeader->Release();
        Create_IUIElement(bFileFolderTasks ? &c_DefviewFileFolderTasksHeaders : &c_DefviewItemFolderTasksHeaders, &(_wvContent.pFolderTaskHeader));

        Create_IEnumUICommand(
            (IUnknown*)(void*)this,
            bFileFolderTasks ? c_DefviewFileFolderTasks  : c_DefviewItemFolderTasks,
            bFileFolderTasks ? c_cDefviewFileFolderTasks : c_cDefviewItemFolderTasks,
            &(_wvTasks.penumFolderTasks));
    }

    if (!_wvContent.penumOtherPlaces)
    {
        LPCTSTR rgCSIDLs[] = { MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_COMMON_DOCUMENTS), MAKEINTRESOURCE(CSIDL_NETWORK) };

        LPITEMIDLIST pidl = _GetViewPidl();

        CreateIEnumIDListOnCSIDLs(pidl, rgCSIDLs, ARRAYSIZE(rgCSIDLs), &_wvContent.penumOtherPlaces);

        if (pidl)
            ILFree(pidl);
    }

    ASSERT(NULL==_pOtherPlacesHeader);
    Create_IUIElement(&c_DefviewOtherPlaces, &_pOtherPlacesHeader);

    ASSERT(NULL==_pDetailsHeader);
    Create_IUIElement(&c_DefviewDetails, &_pDetailsHeader);

    return S_OK;
}

void CDefView::_FreeWebViewContentData()
{
    ATOMICRELEASE(_wvContent.pSpecialTaskHeader);
    ATOMICRELEASE(_wvContent.pFolderTaskHeader);
    ATOMICRELEASE(_wvContent.penumOtherPlaces);
    ATOMICRELEASE(_wvTasks.penumSpecialTasks);
    ATOMICRELEASE(_wvTasks.penumFolderTasks);

    ATOMICRELEASE(_pOtherPlacesHeader);
    ATOMICRELEASE(_pDetailsHeader);

    _fQueryWebViewData = FALSE;
    _wvLayout.dwLayout = -1; // an invalid value
}

BOOL CDefView::_QueryBarricadeState()
{
    BOOL bResult = FALSE;
    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        //
        // Control panel is a special case.
        // The barricade is used to represent 'category view' which can
        // be turned on/off by the user.  We must always ask control panel
        // if it's barricade is on or off.
        //
        BOOL bIsControlPanel = FALSE;
        LPITEMIDLIST pidlControlPanel;
        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_CONTROLS, &pidlControlPanel)))
        {
            bIsControlPanel = ILIsEqual(pidl, pidlControlPanel);
            ILFree (pidlControlPanel);
        }
        if (bIsControlPanel)
        {
            SFVM_WEBVIEW_CONTENT_DATA wvc;
            if (SUCCEEDED(CallCB(SFVM_GETWEBVIEWCONTENT, 0, (LPARAM)&wvc)))
            {
                //
                // Control Panel doesn't provide all the standard
                // webview content so it's doing nothing more than setting
                // the dwFlags member.  Assert to ensure this doesn't
                // change in the future without us knowing about it.
                //
                ASSERT(NULL == wvc.pIntroText);
                ASSERT(NULL == wvc.pSpecialTaskHeader);
                ASSERT(NULL == wvc.pFolderTaskHeader);
                ASSERT(NULL == wvc.penumOtherPlaces);
                bResult = (0 != (SFVMWVF_BARRICADE & wvc.dwFlags));
            }
        }
        else if (_wvContent.dwFlags & SFVMWVF_BARRICADE)
        {
            if (!IsBarricadeGloballyOff())
            {
                TCHAR szValueName[MAX_PATH];
                if (GetBarricadeValueNameFromPidl(pidl, szValueName, ARRAYSIZE(szValueName)))
                {
                    if (VARIANT_TRUE == GetBarricadeStatus(szValueName))
                    {
                        bResult = TRUE;
                    }
                }
            }
        }
        ILFree(pidl);
    }
    return bResult;
}

void CDefView::_ShowLegacyWatermark()
{
    BOOL fShowLegacyWatermark = TRUE;
    LVBKIMAGE lvbki = {0};

    if (_pszLegacyWatermark)
    {
        lvbki.ulFlags = LVBKIF_SOURCE_URL | LVBKIF_STYLE_TILE;
        lvbki.pszImage = _pszLegacyWatermark;
    }
    else
    {
        // this code path is used to clear the watermark
        lvbki.ulFlags = LVBKIF_TYPE_WATERMARK;

        // if we're turning off the legacy watermark, we may have to turn on the theme one
        if (_idThemeWatermark && _pDUIView)
        {
            fShowLegacyWatermark = FALSE;
        }
    }

    if (fShowLegacyWatermark)
        ListView_SetBkImage(_hwndListview, &lvbki);
    else
        _ShowThemeWatermark();
}

void CDefView::_ShowThemeWatermark()
{
    BOOL fShowLegacyWatermark = TRUE;

    if (_idThemeWatermark && _pDUIView)
    {
        HINSTANCE hinstTheme = _pDUIView->_GetThemeHinst();

        LVBKIMAGE lvbki = {0};
        lvbki.ulFlags = LVBKIF_TYPE_WATERMARK;
        lvbki.hbm = DUILoadBitmap(hinstTheme, _idThemeWatermark, LR_DEFAULTCOLOR);
        if (lvbki.hbm)
        {
            // If the window color doesn't match the background color of the watermark,
            // then we'll hide the watermark.
            HDC hDC = CreateCompatibleDC(NULL);

            if (hDC)
            {
                HBITMAP hOldBitmap;

                hOldBitmap = (HBITMAP)SelectObject (hDC, lvbki.hbm);

                if (GetPixel(hDC, 0, 0) != GetSysColor(COLOR_WINDOW))
                {
                    _idThemeWatermark = 0;
                }

                SelectObject (hDC, hOldBitmap);
                DeleteDC (hDC);
            }

            if (_idThemeWatermark && ListView_SetBkImage(_hwndListview, &lvbki))
            {
                fShowLegacyWatermark = FALSE;
            }
            else
            {
                DeleteObject(lvbki.hbm);
            }
        }

        if (fShowLegacyWatermark)
            _idThemeWatermark = 0; // something failed, pretend we don't have one
    }

    // usually this will just hide the previous watermark
    if (fShowLegacyWatermark)
    {
        _ShowLegacyWatermark();
    }
}

void CDefView::_SetThemeWatermark()
{
    UINT idThemeWatermark = 0;

    if (_pDUIView)
    {
        const WVTHEME* pwvTheme = _pDUIView->GetThemeInfo();
        if (pwvTheme && pwvTheme->idListviewWatermark)
        {
            HINSTANCE hinstTheme = _pDUIView->_GetThemeHinst();
            if (HINST_THISDLL != hinstTheme)
            {
                // Only add the watermark if the machine is fast enough...
                if (SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("ListviewWatermark"),
                        FALSE, // Don't ignore HKCU
                        FALSE)) // Assume not fast enough
                {
                    idThemeWatermark = pwvTheme->idListviewWatermark;
                }
            }
        }
    }

    if (idThemeWatermark != _idThemeWatermark)
    {
        _idThemeWatermark = idThemeWatermark;

        // Since DUI Document view isn't themed, legacy watermarks have precedence there.
        // Might as well have them take precedence for My Pictures too...
        if (!_pszLegacyWatermark)
        {
            _ShowThemeWatermark();
        }
    }
}

void CDefView::_SetLegacyWatermark(LPCTSTR pszLegacyWatermark)
{
    Str_SetPtr(&_pszLegacyWatermark, pszLegacyWatermark);

    _ShowLegacyWatermark();
}

HRESULT CDefView::_TryShowWebView(UINT fvmNew, UINT fvmOld)
{
    SFVM_WEBVIEW_LAYOUT_DATA sfvmwvld = {0};

    HRESULT hr = E_FAIL;
    BOOL fShowDUI = FALSE;

    // The desktop IShellFolder doesn't know if it's in-frame or in the real desktop,
    // so only ask it for new DUIView if we're not the actual desktop.
    if (!_IsDesktop())
    {
        // Supporting SFVM_GETWEBVIEWLAYOUT means the folder wants our new
        // DUI View and they support SFVM_GETWEBVIEWCONTENT
        //
        hr = CallCB(SFVM_GETWEBVIEWLAYOUT, (WPARAM)fvmNew, (LPARAM)&sfvmwvld);

        fShowDUI = SUCCEEDED(hr);
    }

    // This folder doesn't specify the new DUIView, try the old WebView stuff
    if (!fShowDUI)
    {
        WCHAR wszMoniker[MAX_PATH];
        hr = _GetWebViewMoniker(wszMoniker, ARRAYSIZE(wszMoniker));
        if (SUCCEEDED(hr))
        {
            if(_pDUIView)  //Hide it only if we are switching from DUI
                _TryHideWebView(); // just in case we're switching from DUI to Web View (can happen when customizing)

            if (wszMoniker[0])
            {
                hr = _SwitchToWebView(TRUE);
            }
        }

        // Okay, we don't have Web View, use the default DUI View
        if (FAILED(hr))
        {
            sfvmwvld.dwLayout = SFVMWVL_NORMAL;
            fShowDUI = TRUE;
        }
    }

    if (fShowDUI)
    {
        hr = S_OK;

        _cFrame.HideWebView(); // just in case we're switching from Web View to DUI View (can happen when customizing)

        if (sfvmwvld.dwLayout != _wvLayout.dwLayout)
        {
            if (!_fQueryWebViewData) // instead of this we could allow per-layout tasks...
            {
                CallCB(SFVM_GETWEBVIEWTHEME, 0, (LPARAM)&_wvTheme);

                // _FreeWebViewContentData(); if we have per-layout tasks...
                if (FAILED(CallCB(SFVM_GETWEBVIEWCONTENT, 0, (LPARAM)&_wvContent)))
                {
                    ZeroMemory(&_wvContent, sizeof(_wvContent));
                }

                if (0 == (SFVMWVF_ENUMTASKS & _wvContent.dwFlags))
                {
                    //
                    // View wants standard task sections.
                    // Non-standard task sections are enumerated in duiview.
                    //
                    if (FAILED(CallCB(SFVM_GETWEBVIEWTASKS, 0, (LPARAM)&_wvTasks)))
                    {
                        ZeroMemory(&_wvTasks, sizeof(_wvTasks));
                    }
                    _GetDefaultWebviewContent(sfvmwvld.dwLayout & SFVMWVL_FILES);
                }

                _fQueryWebViewData = TRUE;
            }

            CopyMemory(&_wvLayout, &sfvmwvld, sizeof(_wvLayout));
            _wvLayout.punkPreview = NULL;

            if (_pDUIView)
            {
                _pDUIView->EnablePreview(sfvmwvld.punkPreview);
            }
            else
            {
                _pDUIView = Create_CDUIView(this);
                if (_pDUIView)
                {
                    _fBarrierDisplayed = _QueryBarricadeState();

                    if (SUCCEEDED(_pDUIView->Initialize(_fBarrierDisplayed, 
                                                        sfvmwvld.punkPreview)))
                    {
                        if (((SFVMWVF_ENUMTASKS | SFVMWVF_CONTENTSCHANGE) & _wvContent.dwFlags) &&
                             _fRcvdContentsChangeBeforeDuiViewCreated)
                        {
                            //
                            // If the webview provider dynamically enumerates
                            // tasks or wants to be refreshed when contents change,
                            // (i.e. Control Panel), AND we received a 'contents change'
                            // before DUI View was created, initiate a 'contents change' now.
                            // Otherwise, such providers will not receive a 'contents change'
                            // and thus will not display their dynamic webview content.
                            //
                            _OnContentsChanged();
                        }
                    }
                    else
                    {
                        _pDUIView->Release();
                        _pDUIView = NULL;
                    }
                }
            }
        }
        else
        {
            // except potentially refresh if we need to add/remove our DUI Details minipreview
            if (_pDUIView && (_IsImageMode(fvmNew) != _IsImageMode(fvmOld)))
                _pDUIView->OnSelectionChange(_pSelectionShellItemArray);
        }

        ATOMICRELEASE(sfvmwvld.punkPreview);
    }

    _SetThemeWatermark();

    return hr;
}

HRESULT CDefView::_TryHideWebView()
{
    if (_pDUIView)
    {
        _pDUIView->DetachListview(); // so we detach and re-parent the listview synchronously
        //
        // Ensure DUser has shut down and handled all DUser messages
        // before we release our ref on CDUIView.
        //
        _pDUIView->UnInitializeDirectUI();
        _pDUIView->Release();
        _pDUIView = NULL;        // * necessary * because this is used internally as a state (must be BEFORE WndSize() below)
        _wvLayout.dwLayout = -1; // an invalid value
        _fListViewShown = FALSE; // CDUIView::DetachListview() does a SW_HIDE on the listview
        WndSize(_hwndView);      // resize _hwndView to account for DUI disappearing (otherwise
                                 // it will still be the smaller size expecting DUI to be drawn
                                 // next to it)
        ShowHideListView();
    }
    else
    {
        _SwitchToWebView(FALSE);
    }

    return S_OK;
}

// we are switching the listview view mode in this function, not dorking with web view content.
//
HRESULT CDefView::_SwitchToViewFVM(UINT fvmNew, UINT uiType)
{
    HRESULT hr = S_OK;
    UINT fvmOld = _fs.ViewMode;

    ASSERT(_hwndListview);

    HWND hwndCurrentFocus = GetFocus();
    BOOL bSetFocusRequired = HasCurrentViewWindowFocus();

    if (SWITCHTOVIEW_WEBVIEWONLY != uiType)
    {
        // if we haven't loaded the columns yet, do that now
        // Don't pre-load the columns for TileView, we are delaying the load on purpose for perf reasons.
        if (fvmNew == FVM_DETAILS)
        {
            AddColumns();
            _SetSortFeedback();
        }
        else if (fvmNew == FVM_THUMBSTRIP)
        {
            // Thumbstrip makes no sense in non-webview, fall back to thumbnail
            if (!_ShouldShowWebView())
            {
                fvmNew = FVM_THUMBNAIL;
            }
        }

        // Combined view only applies to large icon view
        if (_fCombinedView && fvmNew != FVM_ICON)
        {
            _fCombinedView = FALSE;
            ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_REGIONAL, 0);
            _SetFolderColors();
        }

        // First we turn OFF view specific stuff that is no longer needed
        switch (fvmOld)
        {
        case FVM_THUMBSTRIP:
            if (FVM_THUMBSTRIP != fvmNew)
            {
                ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_SINGLEROW, 0);

                // we may have forced thumbstrip to auto-arrange, undo that if so
                if (!(_fs.fFlags & FWF_AUTOARRANGE))
                {
                    SHSetWindowBits(_hwndListview, GWL_STYLE, LVS_AUTOARRANGE, 0);
                }
            }
            // fall through
        case FVM_THUMBNAIL:
            if (!_IsImageMode(fvmNew))
            {
                _ResetThumbview();

                // Since we are switching from thumbnail view, remove any thumbnail extraction tasks
                _RemoveThumbviewTasks();

                if (_fs.fFlags & FWF_OWNERDATA)
                {
                    InvalidateRect(_hwndListview, NULL, TRUE);
                }
                else
                {
                    ListView_InvalidateImageIndexes(_hwndListview);
                }
            }
            break;

        case FVM_TILE:
            if (!_IsTileMode(fvmNew))
            {
                if (_pScheduler)
                    _pScheduler->RemoveTasks(TOID_DVFileTypeProperties, ITSAT_DEFAULT_LPARAM, TRUE);

                // Remove the columns that
                // were pulled in because of tileview.
                _RemoveTileColumns();
            }
            break;
        }

        _SetView(fvmNew);   // we can now switch the listview around

        // Now that'we no longer in tileview, we can reset the tileinfo. If we were to do it
        // prior to changing the view, then listview would start asking us for the tileinformation
        // for each item again, and we'd pull in the tile columns again.
        if (fvmOld == FVM_TILE)
        {
            _RemoveTileInfo();
        }

        // Third, turn ON view specific stuff
        //
        switch (fvmNew)
        {
        case FVM_THUMBSTRIP:
            if (FVM_THUMBSTRIP!=fvmOld)
            {
                ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_SINGLEROW, LVS_EX_SINGLEROW);

                // thumbstrip can not be in group view
                if (_fGroupView)
                    _ToggleGrouping();

                // thumbstrip is always in auto-arrange
                if (!(_fs.fFlags & FWF_AUTOARRANGE))
                {
                    _ClearItemPositions();
                    SHSetWindowBits(_hwndListview, GWL_STYLE, LVS_AUTOARRANGE, LVS_AUTOARRANGE);
                }
            }
            // fall through
        case FVM_THUMBNAIL:
            if (!_IsImageMode(fvmOld))
            {
                if (GetKeyState(VK_SHIFT) < 0)
                {
                    _fs.fFlags ^= FWF_HIDEFILENAMES;    // toggle
                }
                _SetThumbview();
                _DoThumbnailReadAhead();

                RECT rc = {1, 3, 4, 4};
                ListView_SetViewMargins(_hwndListview, &rc);
            }
            break;

        case FVM_TILE:
            if (!_IsTileMode(fvmOld))
            {
                _SetTileview();

                RECT rc = {3, 4, 4, 1};
                ListView_SetViewMargins(_hwndListview, &rc);
            }
            break;

        default:
            _SetSysImageList();

            {
                RECT rc = {1, 3, 4, 0};
                ListView_SetViewMargins(_hwndListview, &rc);
            }
            break;
        }
    }

    if (SWITCHTOVIEW_NOWEBVIEW != uiType)
    {
        // New to Whistler: a view mode transition may also entail a web view template change
        if (_ShouldShowWebView())
        {
            _TryShowWebView(fvmNew, fvmOld);
            _AutoAutoArrange(0);

            hr = S_OK; // we don't care about failure since we still get icons
        }
        else
        {
            _TryHideWebView();
        }
    }

    if (SWITCHTOVIEW_WEBVIEWONLY != uiType)
    {
        ShowHideListView();
        _AutoAutoArrange(0);
        if (bSetFocusRequired)
        {
            // _hwndListview is the current view window. Let's set focus to it.
            CallCB(SFVM_SETFOCUS, 0, 0);
            ViewWindowSetFocus();

            // notify image preview control to update its image
            if (fvmNew == FVM_THUMBSTRIP)
                _ThumbstripSendImagePreviewFocusChangeEvent();
        }
        else
        {
            SetFocus(hwndCurrentFocus);
        }
        CheckToolbar();
        // update menus, i.e. add Choose Columns to the view menu if Details view is selected
        // or remove it otherwise
        RecreateMenus();
        _EnableDisableTBButtons();
    }
    return hr;
}

// Description:
//  Notify image preview control to update its image.  The image preview
//  control uses focus change events to track when it should update the image
//  it is displaying.  When it receives a focus change event, it queries the
//  listview to see which item has focus, then displays that item in the
//  image preview window.  When nothing in the listview has focus (such as
//  when it has no items), the image preview window displays as empty.
//
//  This method fires the "focus changed" event which is picked up by the
//  image preview control, and causes it to update the image it's displaying.
//
void CDefView::_ThumbstripSendImagePreviewFocusChangeEvent()
{
    ASSERT(_fs.ViewMode == FVM_THUMBSTRIP);
    _FireEvent(DISPID_FOCUSCHANGED);
}

int CDefView::CheckCurrentViewMenuItem(HMENU hmenu)
{
    int iCurViewMenuItem = _GetMenuIDFromViewMode(_fs.ViewMode);

    CheckMenuRadioItem(hmenu, SFVIDM_VIEW_FIRSTVIEW, SFVIDM_VIEW_LASTVIEW,
                       iCurViewMenuItem, MF_BYCOMMAND | MF_CHECKED);

    return iCurViewMenuItem;
}

const UINT c_aiNonCustomizableFolders[] = {
    CSIDL_WINDOWS,
    CSIDL_SYSTEM,
    CSIDL_SYSTEMX86,
    CSIDL_PROGRAM_FILES,
    CSIDL_PROGRAM_FILESX86,
    CSIDL_PERSONAL,
    CSIDL_MYDOCUMENTS,
    CSIDL_MYMUSIC,
    CSIDL_MYPICTURES,
    CSIDL_MYVIDEO,
    CSIDL_COMMON_DOCUMENTS,
    CSIDL_COMMON_MUSIC,
    CSIDL_COMMON_PICTURES,
    CSIDL_COMMON_VIDEO
};

// since we moved to the property bag this check is fast; we don't probe to see if we can create desktop.ini
// or anything.
BOOL IsCustomizable(LPCITEMIDLIST pidlFolder)
{
    BOOL fCustomizable = FALSE;

    if (!SHRestricted(REST_NOCUSTOMIZETHISFOLDER) && !SHRestricted(REST_CLASSICSHELL))
    {
        // Check if this is a file system folder.
        // customization requires the folder being a regular file system
        // folder. FILESYSTEMANCESTOR is the key bit here

        #define SFGAO_CUST_BITS (SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_FILESYSANCESTOR)
        ULONG rgfFolderAttr = SFGAO_CUST_BITS;
        TCHAR szPath[MAX_PATH];
        if (SUCCEEDED(SHGetNameAndFlags(pidlFolder, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), &rgfFolderAttr)) &&
            (SFGAO_CUST_BITS == (rgfFolderAttr & SFGAO_CUST_BITS)))
        {
            if (!PathIsOneOf(szPath, c_aiNonCustomizableFolders, ARRAYSIZE(c_aiNonCustomizableFolders)) &&
                (!PathIsRoot(szPath) || PathIsUNCServerShare(szPath)) &&
                !SHRestricted(REST_NOCUSTOMIZEWEBVIEW))
            {
                IPropertyBag *ppb;
                if (SUCCEEDED(SHGetViewStatePropertyBag(pidlFolder, VS_BAGSTR_EXPLORER, SHGVSPB_PERUSER | SHGVSPB_PERFOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
                {
                    fCustomizable = TRUE;
                    ppb->Release();
                }
            }
        }
    }

    return fCustomizable;
}

// wrapper around IsCustomizable to save some state, plus some defview-specific logic.
BOOL CDefView::_CachedIsCustomizable()
{
    if (_IsDesktop() || _IsViewDesktop() || _IsCommonDialog())
    {
        _iCustomizable = NOT_CUSTOMIZABLE;
    }

    if (_iCustomizable == DONTKNOW_IF_CUSTOMIZABLE)
    {
        LPITEMIDLIST pidl = _GetViewPidl();
        if (pidl)
        {
            _iCustomizable = IsCustomizable(pidl) ? YES_CUSTOMIZABLE : NOT_CUSTOMIZABLE;
            ILFree(pidl);
        }
    }

    return (_iCustomizable != NOT_CUSTOMIZABLE);
}

BOOL CDefView::_InvokeCustomization()
{
    BOOL fRet = FALSE;

    if (!_CachedIsCustomizable())
    {
        //If not customizable, put up this error message!
        ShellMessageBox(HINST_THISDLL, _hwndMain, MAKEINTRESOURCE(IDS_NOTCUSTOMIZABLE), NULL,
                       MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
        return FALSE;  // ...and bail out!
    }

    //Save the view state first.
    SaveViewState();

    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        TCHAR szSheetName[25];
        LoadString(HINST_THISDLL, IDS_CUSTOMIZE, szSheetName, ARRAYSIZE(szSheetName));
        SHELLEXECUTEINFO sei =
        {
            SIZEOF(sei),
            SEE_MASK_INVOKEIDLIST,      // fMask
            _hwndMain,                  // hwnd
            c_szProperties,             // lpVerb
            NULL,                       // lpFile
            szSheetName,                // lpParameters
            NULL,                       // lpDirectory
            SW_SHOWNORMAL,              // nShow
            NULL,                       // hInstApp
            pidl,                       // lpIDList
            NULL,                       // lpClass
            0,                          // hkeyClass
            0,                          // dwHotKey
            NULL                        // hIcon
        };

        // only invoking properties verb
        fRet = ShellExecuteEx(&sei);

        ILFree(pidl);
    }
    return fRet;
}

struct {
    UINT uiSfvidm;
    DWORD dwOlecmdid;
} const c_CmdTable[] = {
    { SFVIDM_EDIT_CUT,          OLECMDID_CUT        },
    { SFVIDM_EDIT_COPY,         OLECMDID_COPY       },
    { SFVIDM_EDIT_PASTE,        OLECMDID_PASTE      },
    { SFVIDM_FILE_DELETE,       OLECMDID_DELETE     },
    { SFVIDM_FILE_PROPERTIES,   OLECMDID_PROPERTIES },
};

DWORD OlecmdidFromSfvidm(UINT uiSfvidm)
{
    DWORD dwOlecmdid = 0;

    for (int i = 0; i < ARRAYSIZE(c_CmdTable); i++)
    {
        if (c_CmdTable[i].uiSfvidm == uiSfvidm)
        {
            dwOlecmdid = c_CmdTable[i].dwOlecmdid;
            break;
        }
    }

    return dwOlecmdid;
}

void HideIE4DesktopChannelBar()
{
    HWND hwndChannelBar;
    //Check if the channel bar is currently running. If so, turn it off!
    if ((hwndChannelBar = FindWindowEx(GetShellWindow(), NULL, TEXT("BaseBar"), TEXT("ChanApp"))) ||
        (hwndChannelBar = FindWindowEx(NULL, NULL, TEXT("BaseBar"), TEXT("ChanApp")))) // can be a toplevel window
    {
        //Close the channel bar.
        PostMessage(hwndChannelBar, WM_CLOSE, 0, 0);
    }
 }

// Wrapper around _SwitchToWebView to do desktop-specific stuff
LRESULT CDefView::_SwitchDesktopHTML(BOOL fShow)
{
    LRESULT lRes;

    if (fShow)
    {
        // Do this early to give the desktop a chance to regenerate it's webview template
        _CallRefresh(TRUE);

        lRes = SUCCEEDED(_SwitchToWebView(TRUE));

        if (lRes)
        {
            HideIE4DesktopChannelBar();
        }
    }
    else
    {
        _SwitchToWebView(FALSE);
        CoFreeUnusedLibraries();
        lRes = TRUE;
    }

    return lRes;
}
void CDefView::_DoColumnsMenu(int x, int y) // X and Y are screen coordinates
{
    HMENU hmenu = CreatePopupMenu();
    if (hmenu)
    {
        AddColumnsToMenu(hmenu, SFVIDM_COLUMN_FIRST);

        int item = TrackPopupMenu(hmenu, TPM_TOPALIGN | TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD,
                                  x, y, 0, _hwndListview, NULL);
        DestroyMenu(hmenu);

        // validate item first
        if (item == SFVIDM_VIEW_COLSETTINGS)
        {
            CColumnDlg ccd(this);

            AddColumns();

            ccd.ShowDialog(_hwndMain);
        }
        else if (item > SFVIDM_COLUMN_FIRST)
        {
            _HandleColumnToggle(item - SFVIDM_COLUMN_FIRST, TRUE);
        }
    }
}

BOOL CDefView::_ArrangeBy(UINT idCmd)
{
    int iColumn = idCmd - SFVIDM_GROUPSFIRST;
    BOOL fAllowToggle = TRUE;

    // We want to enter group by if We already have a group, or if this is an extended grouping
    if ((_fGroupView || InRange(idCmd, SFVIDM_GROUPSEXTENDEDFIRST, SFVIDM_GROUPSEXTENDEDLAST)) &&
        !(_fs.ViewMode == FVM_LIST))
    {
        _GroupBy(idCmd);
        iColumn = 0;        // Arrange by name, when grouping
        fAllowToggle = FALSE; // Always arrange in ascending order
    }
    return S_OK == _OnRearrange(iColumn, fAllowToggle);
}

BOOL CDefView::_InitArrangeMenu(HMENU hmInit)
{
    MENUITEMINFO mii = {0};

    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;
    GetMenuItemInfo(hmInit, SFVIDM_MENU_ARRANGE, MF_BYCOMMAND, &mii);
    HMENU hmenuCtx = mii.hSubMenu;

    if (hmenuCtx)
    {
        int idToCheck = -1;
        AddColumns();
        UINT cVisible = _RealToVisibleCol(-1) + 1;   // count
        ICategoryProvider* pcp = NULL;
        _pshf->CreateViewObject(NULL, IID_PPV_ARG(ICategoryProvider, &pcp));

        while (1)
        {
            MENUITEMINFO miiSep = {0};
            miiSep.cbSize = sizeof(mii);
            miiSep.fMask = MIIM_ID | MIIM_TYPE;
            miiSep.wID = -1;

            if (!GetMenuItemInfo(hmenuCtx, 0, MF_BYPOSITION, &miiSep) ||
                miiSep.wID == SFVIDM_GROUPSEP)
            {
                break;
            }

            DeleteMenu(hmenuCtx, 0, MF_BYPOSITION);
        }

        UINT iInsert = 0;
        for (UINT i = 0; i < cVisible; i++)
        {
            BOOL fAddItem = TRUE;
            UINT iReal = _VisibleToRealCol(i);
            if (_IsDetailsColumn(iReal))
            {

                // See if the category Provider wants to exclude this column when groupview is enabled
                if (pcp && _fGroupView)
                {
                    SHCOLUMNID scid;
                    if (SUCCEEDED(_pshf2->MapColumnToSCID(iReal, &scid)))
                    {
                        // returns S_FALSE to remove.
                        fAddItem = (S_OK == pcp->CanCategorizeOnSCID(&scid));
                    }
                }

                if (fAddItem)
                {
                    WCHAR wszName[MAX_COLUMN_NAME_LEN];
                    BOOL bpuiName = FALSE;
                    IPropertyUI *ppui;

                    // Attempt to retrieve mnemonic name from IPropertyUI interface.
                    if (_pshf2 && SUCCEEDED(_GetPropertyUI(&ppui)))
                    {
                        SHCOLUMNID scid;

                        if (SUCCEEDED(_pshf2->MapColumnToSCID(iReal, &scid)))
                        {
                            bpuiName = SUCCEEDED(ppui->GetDisplayName(scid.fmtid, scid.pid, PUIFNF_MNEMONIC, wszName, ARRAYSIZE(wszName)));
                        }

                        ppui->Release();
                    }

                    MENUITEMINFO miiItem = {0};
                    miiItem.cbSize = sizeof(mii);
                    miiItem.fMask = MIIM_ID | MIIM_TYPE;
                    miiItem.fType = MFT_STRING;
                    miiItem.wID = iReal + SFVIDM_GROUPSFIRST;
                    miiItem.dwTypeData = bpuiName ? wszName : _vs.GetColumnName(iReal);
                    InsertMenuItem(hmenuCtx, iInsert++, TRUE, &miiItem);
                }
            }
        }

        _InitExtendedGroups(pcp, hmenuCtx, iInsert, &idToCheck);

        // Only do the Bullets if we're in auto arrange mode or if we are in details.
        if (_IsAutoArrange() || _fGroupView || _fs.ViewMode == FVM_DETAILS)
        {
            if (idToCheck == -1)
            {
                // Since we're not going to have more than 4million columns, this case should suffice
                idToCheck = (int)_vs._lParamSort + SFVIDM_GROUPSFIRST;
                if (_fGroupView &&
                    !(_fs.ViewMode == FVM_LIST))
                {
                    idToCheck = MapSCIDToColumn(_pshf2, &_vs._scidDetails) + SFVIDM_GROUPSFIRST;
                }
            }

            CheckMenuRadioItem(hmenuCtx, SFVIDM_GROUPSFIRST, SFVIDM_GROUPSEXTENDEDLAST, idToCheck, MF_BYCOMMAND | MF_CHECKED);
        }

        if (pcp)
            pcp->Release();
    }

    DWORD dwGroupEnableFlags = MF_GRAYED;
    if (_pshf2 &&                           // Needs to implement IShellFolder2
        !_IsViewDesktop() &&                // Doesn't work on the desktop
        !(_fs.ViewMode == FVM_LIST) &&      // Doesn't work in 'List' View
        !(_fs.ViewMode == FVM_THUMBSTRIP) &&// Doesn't work in 'ThumbStrip' View
        !(_fs.fFlags & FWF_OWNERDATA))      // Doesn't work for ownerdata lists (search)
    {
        dwGroupEnableFlags = MF_ENABLED;
        CheckMenuItem(hmenuCtx, SFVIDM_GROUPBY, MF_BYCOMMAND | (_fGroupView?MF_CHECKED:0));
    }

    EnableMenuItem(hmenuCtx, SFVIDM_GROUPBY, MF_BYCOMMAND | dwGroupEnableFlags);

    _SHPrettyMenu(hmenuCtx);

    return TRUE;
}

BOOL CDefView::_InitExtendedGroups(ICategoryProvider* pcp, HMENU hmenuCtx, int iIndex, int* piIdToCheck)
{
    if (!pcp)
        return FALSE;

    *piIdToCheck = -1;
    if (_hdaCategories == NULL)
    {
        _hdaCategories = DSA_Create(sizeof(GUID), 5);
        if (_hdaCategories)
        {
            IEnumGUID* penum;
            if (SUCCEEDED(pcp->EnumCategories(&penum)))
            {
                GUID guidCat;
                while (S_OK == penum->Next(1, &guidCat, NULL))
                {
                    DSA_AppendItem(_hdaCategories, (void*)&guidCat);
                }

                penum->Release();
            }
        }
    }

    if (_hdaCategories)
    {
        int id = SFVIDM_GROUPSEXTENDEDFIRST;
        TCHAR szName[MAX_PATH];
        TCHAR szCurrentName[MAX_PATH];
        WCHAR wszName[MAX_PATH];
        GUID* pguidCat;

        szCurrentName[0] = 0;

        if (_pcat)
        {
            _pcat->GetDescription(szCurrentName, ARRAYSIZE(szCurrentName));
        }

        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_SEPARATOR;
        mii.wID = -1;

        InsertMenuItem(hmenuCtx, iIndex, TRUE, &mii);

        iIndex++;

        int cCategories = DSA_GetItemCount(_hdaCategories);
        for (int i = 0; i < cCategories; i++)
        {
            pguidCat = (GUID*)DSA_GetItemPtr(_hdaCategories, i);

            if (SUCCEEDED(pcp->GetCategoryName(pguidCat, wszName, ARRAYSIZE(wszName))))
            {
                SHUnicodeToTChar(wszName, szName, ARRAYSIZE(szName));

                MENUITEMINFO mii = {0};
                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID;
                mii.fType = MFT_STRING;
                mii.dwItemData = (DWORD_PTR)pguidCat;
                mii.wID = id;
                mii.dwTypeData = szName;
                mii.cch = ARRAYSIZE(szName);

                InsertMenuItem(hmenuCtx, iIndex, TRUE, &mii);

                if (lstrcmpi(szCurrentName, szName) == 0)
                {
                    *piIdToCheck = id;
                }

                id++;
                iIndex++;
            }
        }
    }

    return TRUE;
}

BOOL CDefView::_CategorizeOnSCID(const SHCOLUMNID* pscid)
{
    BOOL fRet = FALSE;

    _fSlowGroup = FALSE;
    if (IsEqualSCID(*pscid, SCID_NAME))
    {
        if (SUCCEEDED(CAlphaCategorizer_Create(_pshf2, IID_PPV_ARG(ICategorizer, &_pcat))))
        {
            _vs._guidGroupID = CLSID_AlphabeticalCategorizer;
            fRet = TRUE;
        }
    }
    else if (IsEqualSCID(*pscid, SCID_SIZE))
    {
        if (SUCCEEDED(CSizeCategorizer_Create(_pshf2, IID_PPV_ARG(ICategorizer, &_pcat))))
        {
            _vs._guidGroupID = CLSID_SizeCategorizer;
            fRet = TRUE;
        }
    }
    else if (IsEqualSCID(*pscid, SCID_WRITETIME) ||
             IsEqualSCID(*pscid, SCID_CREATETIME) ||
             IsEqualSCID(*pscid, SCID_ACCESSTIME) ||
             IsEqualSCID(*pscid, SCID_DATEDELETED))
    {
        if (SUCCEEDED(CTimeCategorizer_Create(_pshf2, pscid, IID_PPV_ARG(ICategorizer, &_pcat))))
        {
            _vs._guidGroupID = CLSID_TimeCategorizer;
            fRet = TRUE;
        }
    }
    else
    {
        _fSlowGroup = TRUE;
        if (SUCCEEDED(CDetailCategorizer_Create(*pscid, _pshf2, IID_PPV_ARG(ICategorizer, &_pcat))))
        {
            _vs._guidGroupID = CLSID_DetailCategorizer;
            fRet = TRUE;
        }
    }

    if (fRet)
    {
        _vs._scidDetails = *pscid;
    }

    return fRet;
}

// slow groups have an architecture problem, after 5000 items in the view
// the message queue overflows from groupdone messages and its all bad.
// this ends up hanging the static flashlight window around because of resulting
// refcount issues.
// the only view that both defaults to a slow group and could have 5000 items is the
// cd burning folder.  lou says its too late to change the interface now to let the
// categorizer decide if its slow or not, so just special case it here.
// everything works if its a fast group (and its actually fast anyway).
BOOL CDefView::_IsSlowGroup(const GUID *pguid)
{
    BOOL fSlow = TRUE;
    if (IsEqualGUID(*pguid, CLSID_MergedCategorizer))
    {
        fSlow = FALSE;
    }
    // room to grow if we need to special case others
    return fSlow;
}

BOOL CDefView::_CategorizeOnGUID(const GUID* pguid, const SHCOLUMNID* pscid)
{
    BOOL fRet = FALSE;
    if (_pshf2)
    {
        _fGroupView = FALSE;    // Just in case the create fails
        if (_pScheduler)
            _pScheduler->RemoveTasks(TOID_DVBackgroundGroup, ITSAT_DEFAULT_LPARAM, TRUE);

        ATOMICRELEASE(_pcat);

        ListView_RemoveAllGroups(_hwndListview);

        ICategoryProvider* pcp;
        if (SUCCEEDED(_pshf->CreateViewObject(NULL, IID_PPV_ARG(ICategoryProvider, &pcp))))
        {
            GUID guidGroup = *pguid;
            if (pscid && S_OK != pcp->GetCategoryForSCID(const_cast<SHCOLUMNID*>(pscid), &guidGroup))
            {
                fRet = _CategorizeOnSCID(pscid);
            }
            else
            {
                _fSlowGroup = _IsSlowGroup(&guidGroup);
                if (SUCCEEDED(pcp->CreateCategory(&guidGroup, IID_PPV_ARG(ICategorizer, &_pcat))))
                {
                    _vs._guidGroupID = guidGroup;
                    if (pscid)
                    {
                        _vs._scidDetails = *pscid;
                    }
                    else
                    {
                        ZeroMemory(&_vs._scidDetails, sizeof(_vs._scidDetails));
                    }

                    fRet = TRUE;
                }
            }
            pcp->Release();
        }
        else
        {
            if (pscid)
                fRet = _CategorizeOnSCID(pscid);
        }
    }

    if (fRet)
    {
        _ClearItemPositions();
        _fGroupView = TRUE;
        SHSetWindowBits(_hwndListview, GWL_STYLE, LVS_AUTOARRANGE, LVS_AUTOARRANGE);

        // We're enabling groupview, so turn off the selected column
        // (this will make it so tiles do not show the selected column as their first column)
        ListView_SetSelectedColumn(_hwndListview, -1);

        if (_fSlowGroup)
            _fAllowSearchingWindow = TRUE;

        ListView_EnableGroupView(_hwndListview, TRUE);
    }

    return fRet;
}

void CDefView::_GroupBy(int iColumn)
{
    _fGroupView = FALSE;    // Just in case the create fails

    if (_pshf2)
    {
        if (InRange(iColumn, SFVIDM_GROUPSEXTENDEDFIRST, SFVIDM_GROUPSEXTENDEDLAST))
        {
            int iIndex = iColumn - SFVIDM_GROUPSEXTENDEDFIRST;
            GUID* pguid = (GUID*)DSA_GetItemPtr(_hdaCategories, iIndex);
            if (pguid)
            {
                _CategorizeOnGUID(pguid, NULL);
            }
        }
        else
        {
            SHCOLUMNID scid;
            iColumn -= SFVIDM_GROUPSFIRST;

            if (SUCCEEDED(_pshf2->MapColumnToSCID(iColumn, &scid)))
            {
                _CategorizeOnGUID(&CLSID_DetailCategorizer, &scid);
            }
        }

        // Make sure the arrows on details view look right...
        _SetSortFeedback();
    }
}

void CDefView::_ToggleGrouping()
{
    if (_fGroupView)
    {
        _fGroupView = FALSE;
        if (_pScheduler)
            _pScheduler->RemoveTasks(TOID_DVBackgroundGroup, ITSAT_DEFAULT_LPARAM, TRUE);

        ListView_EnableGroupView(_hwndListview, FALSE);
        ListView_RemoveAllGroups(_hwndListview);
        ListView_SetSelectedColumn(_hwndListview, _vs._lParamSort);
        _SetSortFeedback();
        _OnRearrange(_vs._lParamSort, FALSE);
    }
    else if (FVM_THUMBSTRIP != _fs.ViewMode) // Thumbstrip can never go into groupby mode
    {
        // If we have a categorizer, then we can just reenable grouping.
        if (_pcat)
        {
            _fGroupView = TRUE;

            ListView_EnableGroupView(_hwndListview, TRUE);
            ListView_SetSelectedColumn(_hwndListview, -1);
            _SetSortFeedback();
        }
        else
        {
            // If we don't, then we need to go get one.
            _GroupBy((int)_vs._lParamSort + SFVIDM_GROUPSFIRST);
        }
    }
}

LRESULT CDefView::_OnDefviewEditCommand(UINT uID)
{
    // if we are in label edit mode, don't allowany of the buttons......
    if (_fInLabelEdit)
    {
        MessageBeep(0);
        return 1;
    }

    if (_AllowCommand(uID))
    {
        HRESULT hr = _ExplorerCommand(uID);
        if (FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_CANCELLED)))
        {
            MessageBeep(0);
        }
        return 1;
    }
    else
    {
        return 0;
    }
}

HRESULT CDefView::_DoMoveOrCopyTo(REFCLSID clsid, IShellItemArray *psiItemArray)
{

    IDataObject *pdo = NULL;
    IContextMenu *pcm;
    HRESULT hr = E_FAIL;

    if (!psiItemArray)
    {
        psiItemArray = _GetFolderAsShellItemArray();
    }

    if (psiItemArray)
    {
        hr = psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject, &pdo));
    }

    if (SUCCEEDED(hr))
    {

        hr = SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IContextMenu, &pcm));
        if (SUCCEEDED(hr))
        {
            IUnknown_SetSite(pcm, SAFECAST(this, IDropTarget *)); // Needed to go modal during UI

            IShellExtInit* psei;
            hr = pcm->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei));
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlFolder = _GetViewPidl();
                if (pidlFolder)
                {
                    psei->Initialize(pidlFolder, pdo, NULL);
                    ILFree(pidlFolder);
                }

                CMINVOKECOMMANDINFO ici = {0};

                ici.hwnd = _hwndMain;
                hr = pcm->InvokeCommand(&ici);

                psei->Release();
            }

            IUnknown_SetSite(pcm, NULL);
            pcm->Release();
        }

        pdo->Release();
    }

    return hr;
}

LRESULT CDefView::_OnCommand(IContextMenu *pcmToInvoke, WPARAM wParam, LPARAM lParam)
{
    UINT uID = GET_WM_COMMAND_ID(wParam, lParam);

    if (InRange(uID, SFVIDM_GROUPSFIRST, SFVIDM_GROUPSEXTENDEDLAST))
    {
        _ArrangeBy(uID);
        return 1;
    }
    else if (InRange(uID, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST))
    {
        UINT uCMBias = SFVIDM_CONTEXT_FIRST;

        if (_pcmFile)
        {
            IContextMenu* pcmToInvoke = _pcmFile;
            pcmToInvoke->AddRef();

            // We need to special case the rename command
            TCHAR szCommandString[64];
            ContextMenu_GetCommandStringVerb(pcmToInvoke, uID - SFVIDM_CONTEXT_FIRST, szCommandString, ARRAYSIZE(szCommandString));
            if (lstrcmpi(szCommandString, c_szRename) == 0)
            {
                DoRename();
            }
            else
            {
                CMINVOKECOMMANDINFOEX ici = { 0 };

                ici.cbSize = sizeof(CMINVOKECOMMANDINFOEX);
                ici.hwnd = _hwndMain;
                ici.lpVerb = (LPSTR)MAKEINTRESOURCE(uID - SFVIDM_CONTEXT_FIRST);
                ici.nShow = SW_NORMAL;
                ici.fMask = CMIC_MASK_FLAG_LOG_USAGE;

                int iItemSelect = ListView_GetNextItem(_hwndListview, -1, LVNI_SELECTED);
                if (iItemSelect != -1)
                {
                    RECT rcItem;
                    ListView_GetItemRect(_hwndListview, iItemSelect, &rcItem, LVIR_BOUNDS);
                    MapWindowPoints(_hwndListview, HWND_DESKTOP, (POINT *)&rcItem, 2);
                    ici.ptInvoke.x = (rcItem.left + rcItem.right) / 2;
                    ici.ptInvoke.y = (rcItem.top + rcItem.bottom) / 2;
                    ici.fMask |= CMIC_MASK_PTINVOKE;
                }

                // record if shift or control was being held down
                SetICIKeyModifiers(&ici.fMask);

                _InvokeContextMenu(pcmToInvoke, &ici);
            }

            //Since we are releaseing our only hold on the context menu, release the site.
            IUnknown_SetSite(pcmToInvoke, NULL);

            pcmToInvoke->Release();  // undo our gaurd ref
            ATOMICRELEASE(_pcmFile); // once used, it can't be used again
        }

        return 0;
    }
#ifdef DEBUG
    else if (InRange(uID, SFVIDM_BACK_CONTEXT_FIRST, SFVIDM_BACK_CONTEXT_LAST))
    {
        RIPMSG(FALSE, "_OnCommand should not get this context menu invoke...");
    }
#endif
    else if (InRange(uID, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST) && HasCB())
    {
        // view callback range
        CallCB(SFVM_INVOKECOMMAND, uID - SFVIDM_CLIENT_FIRST, 0);
        return 0;
    }

    // First check for commands that always go to this defview
    switch (uID)
    {
    case SFVIDM_GROUPBY:
        _ToggleGrouping();
        break;

    case SFVIDM_EDIT_UNDO:
        // if we are in label edit mode, don't allowany of the buttons......
        if (_fInLabelEdit)
        {
            MessageBeep(0);
            return 0;
        }

        Undo(_hwndMain);
        break;

    case SFVIDM_VIEW_COLSETTINGS:
        {
            CColumnDlg ccd(this);

            AddColumns();

            ccd.ShowDialog(_hwndMain);
            break;
        }

    case SFVIDM_VIEW_VIEWMENU:
        {
            // if we are in label edit mode, don't allow any of the buttons......
            if (_fInLabelEdit)
            {
                MessageBeep(0);
                return 0;
            }

            LPCDFVCMDDATA pcd = (LPCDFVCMDDATA)lParam;
            if (pcd && pcd->pva && pcd->pva->byref)
            {
                LPRECT prect = (LPRECT)pcd->pva->byref;

                IContextMenu* pcm;
                if (SUCCEEDED(_Create_BackgrndHMENU(TRUE, IID_PPV_ARG(IContextMenu, &pcm))))
                {
                    POINT pt = { prect->left, prect->bottom};

                    DoContextMenuPopup(pcm, 0, pt);

                    pcm->Release();
                }
            }
        }
        break;

    case SFVIDM_VIEW_TILE:
        //
        // AppCompat:  Pre WinXP 0x702E used to be SFVIDM_VIEW_VIEWMENU, now it's SFVIDM_VIEW_TILE.
        // Corel apps send 0x702E to get the ViewMenu on the SaveAs dialogs.  Of course that no
        // longer works since 0x702E switches them to TileMode.  Luckily SFVIDM_VIEW_VIEWMENU has
        // a non-NULL lParam while SFVIDM_VIEW_TILE always has a NULL lParam so we can tell the
        // two apart.  So when Corel sends a 0x702E with a non-NULL lParam they mean SFVIDM_VIEW_VIEWMENU
        // and when they send a 0x702E with a NULL lParam they mean SFVIDM_VIEW_TILE.
        //
        COMPILETIME_ASSERT(SFVIDM_VIEW_TILE == 0x702E);  //see above app compat comments.
        if (lParam && (SHGetAppCompatFlags(ACF_WIN95DEFVIEW) & ACF_WIN95DEFVIEW))
        {
            return _OnCommand(pcmToInvoke, SFVIDM_VIEW_VIEWMENU, lParam);  // change this into a SFVIDM_VIEW_VIEWMENU
        }
        // Fall through ...
    case SFVIDM_VIEW_ICON:
    case SFVIDM_VIEW_SMALLICON:
    case SFVIDM_VIEW_THUMBNAIL:
    case SFVIDM_VIEW_THUMBSTRIP:
    case SFVIDM_VIEW_LIST:
    case SFVIDM_VIEW_DETAILS:
        COMPILETIME_ASSERT(FVM_ICON == (SFVIDM_VIEW_ICON-SFVIDM_VIEW_FIRST));
        COMPILETIME_ASSERT(FVM_SMALLICON == (SFVIDM_VIEW_SMALLICON-SFVIDM_VIEW_FIRST));
        COMPILETIME_ASSERT(FVM_THUMBNAIL == (SFVIDM_VIEW_THUMBNAIL-SFVIDM_VIEW_FIRST));
        COMPILETIME_ASSERT(FVM_THUMBSTRIP == (SFVIDM_VIEW_THUMBSTRIP-SFVIDM_VIEW_FIRST));
        COMPILETIME_ASSERT(FVM_LIST == (SFVIDM_VIEW_LIST-SFVIDM_VIEW_FIRST));
        COMPILETIME_ASSERT(FVM_TILE == (SFVIDM_VIEW_TILE-SFVIDM_VIEW_FIRST));
        COMPILETIME_ASSERT(FVM_DETAILS == (SFVIDM_VIEW_DETAILS-SFVIDM_VIEW_FIRST));

        SetCurrentViewMode(uID - SFVIDM_VIEW_FIRST);
        break;

    case SFVIDM_DESKTOPHTML_WEBCONTENT:
        {
            // we have removed this button, but we need to keep this for message for other things
            BOOL bHasVisibleNonLocalPicture = FALSE;
            SHELLSTATE ss;

            SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE); // Get the setting
            ss.fDesktopHTML  = !ss.fDesktopHTML;           // Toggle the state
            if (ss.fDesktopHTML && !IsICWCompleted())
            {
                IActiveDesktop *pIAD;
                if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_ActiveDesktop, NULL, IID_PPV_ARG(IActiveDesktop, &pIAD))))
                {
                    bHasVisibleNonLocalPicture = (DisableUndisplayableComponents(pIAD) != 0);
                    pIAD->Release();
                }
            }
            if (!bHasVisibleNonLocalPicture)
            {
                SHELLSTATE ss2;

                SHGetSetSettings(&ss, SSF_DESKTOPHTML, TRUE);  // Write back the new

                // Now read back the current setting - only call _SwitchDesktopHTML if the current
                // setting and the one we just set agree.  If they don't that means someone changed
                // the setting during the above call and we shouldn't do any more work or our state
                // will get messed up.
                SHGetSetSettings(&ss2, SSF_DESKTOPHTML, FALSE);
                if (ss.fDesktopHTML == ss2.fDesktopHTML)
                {
                    _SwitchDesktopHTML(BOOLIFY(ss.fDesktopHTML));
                }
            }
        }
        break;


    case SFVIDM_DESKTOPHTML_ICONS:
    case SFVIDM_ARRANGE_DISPLAYICONS:   // (buzzr) I'm leaving SFVIDM_ARRANGE_DISPLAYICONS
        {                               //         for backwards compat.  It used to be a
            SHELLSTATE ss;              //         menu entry on POPUP_SFV_BACKGROUND.
            DWORD dwValue;

            // Toggle the cached state
            _fs.fFlags ^= FWF_NOICONS;

            ss.fHideIcons = ((_fs.fFlags & FWF_NOICONS) != 0);
            dwValue = ss.fHideIcons ? 1 : 0;

            // Since this value is currrently stored under the "advanced" reg tree we need
            // to explicitly write to the registry or the value won't persist properly via
            // SHGetSetSettings.
            SHSetValue(HKEY_CURRENT_USER,
                    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                    TEXT("HideIcons"), REG_DWORD, &dwValue, sizeof(dwValue));

            // Finally set the ShellState and perform the action!
            SHGetSetSettings(&ss, SSF_HIDEICONS, TRUE);
            // Since this SFVIDM_ comes from the menu, we better already be active (or
            // this SW_SHOW could make us visible before we want to be seen).
            ASSERT(_uState != SVUIA_DEACTIVATE);
            ActiveDesktop_ApplyChanges();
            ShowHideListView();
        }
        break;

    case SFVIDM_DESKTOPHTML_LOCK:
        {
            DWORD dwFlags = GetDesktopFlags();
            dwFlags ^= COMPONENTS_LOCKED;
            SetDesktopFlags(COMPONENTS_LOCKED, dwFlags);
            ActiveDesktop_ApplyChanges();
        }
        break;

    case SFVIDM_DESKTOPHTML_WIZARD:
        {
            // launch desktop cleanup wizard
            SHRunDLLThread(NULL, TEXT("fldrclnr.dll,Wizard_RunDLL all"), SW_SHOWNORMAL);
        }
        break;

    case SFVIDM_EDIT_COPYTO:
    case SFVIDM_EDIT_MOVETO:
        {
            // if we are in label edit mode, don't allowany of the buttons......
            if (_fInLabelEdit)
            {
                MessageBeep(0);
                return 0;
            }

            if (_pSelectionShellItemArray)
            {
                _DoMoveOrCopyTo(((uID == SFVIDM_EDIT_COPYTO) ? CLSID_CopyToMenu : CLSID_MoveToMenu), _pSelectionShellItemArray);
            }
        }
        break;

    case SFVIDM_FILE_PROPERTIES:

        if (SHRestricted(REST_NOVIEWCONTEXTMENU))
            break;

         // else fall through...

    case SFVIDM_EDIT_PASTE:
    case SFVIDM_EDIT_PASTELINK:
    case SFVIDM_EDIT_COPY:
    case SFVIDM_EDIT_CUT:
    case SFVIDM_FILE_LINK:
    case SFVIDM_FILE_DELETE:
        if (!_OnDefviewEditCommand(uID))
        {
            // REVIEW: this looks like a hack.
            // there's got to be a cleaner way of doing this...
            //
            LPDFVCMDDATA pcd = (LPDFVCMDDATA)lParam;
            // Try translating the SFVIDM value into a standard
            // OLECMDID value, so that the caller can try applying
            // it to a different object.
            // doh
            if (!IsBadWritePtr(pcd, sizeof(*pcd)))
            {
                pcd->nCmdIDTranslated = OlecmdidFromSfvidm(uID);
            }
        }
        break;

    case SFVIDM_TOOL_OPTIONS:
        if (!SHRestricted(REST_NOFOLDEROPTIONS))
        {
            IUnknown_Exec(_psb, &CGID_Explorer, SBCMDID_OPTIONS, 0, NULL, NULL);
        }
        break;

#ifdef DEBUG
    case SFVIDM_DEBUG_WEBVIEW:
        _cFrame._ShowWebViewContent();
        break;
#endif // DEBUG

    case SFVIDM_HELP_TOPIC:
        // Don't call WinHelp when we are in the common dialog.
        if (!_IsCommonDialog())
        {
            // Use a callback to see if the namespace has requested a different help file name and/or topic
            SFVM_HELPTOPIC_DATA htd;
            HWND hwndDesktop = GetDesktopWindow();
            SHTCharToUnicode(c_szHtmlWindowsHlp, htd.wszHelpFile, ARRAYSIZE(htd.wszHelpFile));
            htd.wszHelpTopic[0] = 0;
            if (SUCCEEDED(CallCB(SFVM_GETHELPTOPIC, 0, (LPARAM)&htd)))
            {
                if (URL_SCHEME_MSHELP == GetUrlSchemeW(htd.wszHelpTopic))
                {
                    //
                    // Callback specified an HSS help URL.
                    //
                    SHELLEXECUTEINFOW sei = {0};
                    sei.cbSize = sizeof(sei);
                    sei.lpFile = htd.wszHelpTopic;
                    sei.hwnd   = hwndDesktop;
                    sei.nShow  = SW_NORMAL;
                    // executing help topic
                    ShellExecuteExW(&sei);
                }
                else
                {
                    HtmlHelp(hwndDesktop, htd.wszHelpFile, HH_HELP_FINDER, htd.wszHelpTopic[0] ? (DWORD_PTR)htd.wszHelpTopic : 0);
                }
            }
            else
            {
                // ask the shell dispatch object to display Help for us
                IShellDispatch *psd;
                if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_Shell, NULL, IID_PPV_ARG(IShellDispatch, &psd))))
                {
                    psd->Help();
                    psd->Release();
                }
            }
        }
        break;

    case SFVIDM_VIEW_CUSTOMWIZARD:
        _InvokeCustomization();
        break;

    case SFVIDM_MISC_HARDREFRESH:
        _fAllowSearchingWindow = TRUE;
        _FreeWebViewContentData();

        _ReloadContent(TRUE); // have to enumerate before _GetDefaultViewMode() will be accurate
        SetCurrentViewMode(_GetDefaultViewMode()); // even if fvm is the same, it will update webview if it changed
        Refresh();
        break;

    case SFVIDM_MISC_SETWEBVIEW:
        SetCurrentViewMode(_fs.ViewMode); // re-setting the fvm updates everything (turning web view off can switch from Thumbstrip to Thumbnail!)
        Refresh(); // we want to refresh when we switch turn webview on/off, since some icons appear/disappear on the transition
        break;

    case SFVIDM_MISC_REFRESH:
        _fAllowSearchingWindow = TRUE;
        Refresh();
        break;

    default:
        // check for commands that need to be sent to the active object
        switch (uID)
        {
        case SFVIDM_ARRANGE_AUTO:
            _fs.fFlags ^= FWF_AUTOARRANGE;      // toggle
            _ClearItemPositions();
            SHSetWindowBits(_hwndListview, GWL_STYLE, LVS_AUTOARRANGE, _IsAutoArrange() ? LVS_AUTOARRANGE : 0);
            break;

        case SFVIDM_ARRANGE_GRID:
            ListView_Arrange(_hwndListview, LVA_SNAPTOGRID);
            break;

        case SFVIDM_ARRANGE_AUTOGRID:
            {
                _fs.fFlags ^= FWF_SNAPTOGRID;
                DWORD dwLVFlags = ListView_GetExtendedListViewStyle(_hwndListview);
                dwLVFlags ^= LVS_EX_SNAPTOGRID;
                ListView_SetExtendedListViewStyle(_hwndListview, dwLVFlags);

                //if this is desktop, we need to change the icon spacing.
                UpdateGridSizes(_IsDesktop(), _hwndListview, 0, NULL, BOOLIFY(dwLVFlags & LVS_EX_SNAPTOGRID));

                // if ActiveDesktop on, need to refresh, otherwise, can just arrange
                SHELLSTATE ss = {0};
                SHGetSetSettings( &ss, SSF_DESKTOPHTML, FALSE);
                if (ss.fDesktopHTML)
                {
                    Refresh();
                }
                else
                {
                    if ((dwLVFlags & LVS_EX_SNAPTOGRID))
                    {
                        ListView_Arrange(_hwndListview, LVA_SNAPTOGRID);
                    }
                }
            }
            break;

        default:
            // Normal view, we know what to do
            switch (uID)
            {
            case SFVIDM_SELECT_ALL:
            {
                DECLAREWAITCURSOR;

                if (CallCB(SFVM_SELECTALL, 0, 0) != S_FALSE)
                {
                    SetWaitCursor();
                    SetFocus(_hwndListview);
                    ListView_SetItemState(_hwndListview, -1, LVIS_SELECTED, LVIS_SELECTED);
                    // make the first item in the view the focused guy
                    ListView_SetItemState(_hwndListview, 0, LVIS_FOCUSED, LVIS_FOCUSED);
                    ResetWaitCursor();
                }
                break;
            }

            case SFVIDM_DESELECT_ALL:
                ListView_SetItemState(_hwndListview, -1, 0, LVIS_SELECTED);
                break;

            case SFVIDM_SELECT_INVERT:
            {
                DECLAREWAITCURSOR;
                SetWaitCursor();
                SetFocus(_hwndListview);
                int iItem = -1;
                while ((iItem = ListView_GetNextItem(_hwndListview, iItem, 0)) != -1)
                {
                    // flip the selection bit on each item
                    UINT flag = ListView_GetItemState(_hwndListview, iItem, LVIS_SELECTED);
                    flag ^= LVNI_SELECTED;
                    ListView_SetItemState(_hwndListview, iItem, flag, LVIS_SELECTED);
                }
                ResetWaitCursor();
                break;
            }

            case SFVIDM_FILE_RENAME:
                DoRename();
                break;

            default:
                return 1;
            }
        }
    }

    return 0;
}

LPITEMIDLIST CDefView::_ObjectExists(LPCITEMIDLIST pidl, BOOL fGlobal)
{
    LPITEMIDLIST pidlReal = NULL;
    //  365069 - global events also come through here - ZekeL - 16-APR-2001
    //  this means that that the pidl may not be one level.  if its deeper
    //  then for us this item doesnt exist.  this enforces our assert
    if (pidl && !ILIsEmpty(pidl) && (!fGlobal || ILIsEmpty(_ILNext(pidl))))
    {
        ASSERTMSG(ILFindLastID(pidl) == pidl, "defview doesnt expect recursive notification");
        SHGetRealIDL(_pshf, pidl, &pidlReal);
    }
    return pidlReal;
}

void CDefView::_OnRename(LPCITEMIDLIST* ppidl)
{
    if (_pidlMonitor)
    {
        if (!ILIsParent(_pidlMonitor, ppidl[0], TRUE))
        {
            // move to this folder
            _OnFSNotify(SHCNE_CREATE, &ppidl[1]);
        }
        else if (!ILIsParent(_pidlMonitor, ppidl[1], TRUE))
        {
            // move from this folder
            _OnFSNotify(SHCNE_DELETE, &ppidl[0]);
        }
        else
        {
            // rename within this folder
            // _pidlMonitor is guaranteed to be immediate parent of both pidls so ILFindLastID is okay.
            LPCITEMIDLIST pidlOld = ILFindLastID(ppidl[0]);
            LPITEMIDLIST pidlNew = _ObjectExists(ILFindLastID(ppidl[1]), FALSE);
            if (pidlNew)
            {
                _UpdateObject(pidlOld, pidlNew);
                ILFree(pidlNew);
            }
        }
    }
}

//
//  SFVM_UPDATESTATUSBAR return values:
//
//  failure code = Callback did not do anything, we must do it all
//
//  Otherwise, the GetScode(hr) is a bitmask describing what the app
//  wants us to do.
//
//  0 - App wants us to do nothing (S_OK) - message handled completely
//  1 - App wants us to set the default text (but not initialize)
//
//  <other bits reserved for future use>

void CDefView::_UpdateStatusBar(BOOL fInitialize)
{
    HRESULT hr;

    // We have to clear the contents here since some clients (like the ftp client) return S_OK from
    // the callback but do not set the text of the bar
    HWND hwndStatus;
    if (_psb && SUCCEEDED(_psb->GetControlWindow(FCW_STATUS, &hwndStatus)) && hwndStatus)
    {
        _fBackgroundStatusTextValid = FALSE;
        SendMessage(hwndStatus, SB_SETTEXT, (WPARAM)0, (LPARAM)_TEXT(""));
    }

    if (_bBkFilling || FAILED(hr = CallCB(SFVM_UPDATESTATUSBAR, fInitialize, 0)))
    {
        // Client wants us to do everything
        _DoStatusBar(fInitialize);
    }
    else if (hr & SFVUSB_INITED)
    {
        // Client wants us to do text but not initialize
        _DoStatusBar(FALSE);
    }
}


// Returns TRUE iff we are supposed to show Web View content on this view.
// For the most part it follows SSF_WEBVIEW for normal folders and SSF_DESKTOPHTML for the desktop
//
BOOL CDefView::_ShouldShowWebView()
{
    // No webview for common dialogs
    if (_IsCommonDialog())
    {
        return FALSE;
    }

    // No webview in cleanboot mode
    if (GetSystemMetrics(SM_CLEANBOOT))
        return FALSE;

    BOOL bForceWebViewOn;
    if (SUCCEEDED(CallCB(SFVM_FORCEWEBVIEW, (WPARAM)&bForceWebViewOn, 0)))
    {
        return bForceWebViewOn;
    }

    // Quattro Pro (QPW) doesn't know how SHChangeNotify works,
    // so when they want to refresh My Computer, they create an IShellView,
    // invoke its CreateViewWindow(), invoke its Refresh(), then DestroyWindow
    // the window and release the view.  The IShellBrowser they pass
    // to CreateViewWindow is allocated on the stack (!), and they expect
    // that their Release() be the last one.  Creating an async view keeps
    // the object alive, so when the view is complete, we try to talk to the
    // IShellBrowser and fault because it's already gone.
    //
    // The Zip Archives (from Aeco Systems) is another messed up App.
    // They neither implement IPersistFolder2 (so we can't get their pidl) nor
    // set the pidl to the shellfolderviewcb object. They don't implement
    // IShellFolder2 either. Webview is practically useless for them.
    //
    // Adaptec Easy CD Creator 3.5 is in the same boat.
    //
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_WIN95CLASSIC | SSF_DESKTOPHTML | SSF_WEBVIEW, FALSE);

    // If the "no web view" flag is set (potential WebOC case) then return false;
    if (_fs.fFlags & FWF_NOWEBVIEW)
        return FALSE;

    if (_IsDesktop())
    {
        return ss.fDesktopHTML;
    }
    else
    {
        return ss.fWebView &&
               !(SHGetAppCompatFlags(ACF_OLDCREATEVIEWWND) & ACF_OLDCREATEVIEWWND) &&
               !(SHGetObjectCompatFlags(_pshf, NULL) & OBJCOMPATF_NO_WEBVIEW);
    }
}

// takes ownership of pidlNew since _AddObject takes ownership.
void CDefView::_AddOrUpdateItem(LPCITEMIDLIST pidlOld, LPITEMIDLIST pidlNew)
{
    if (_FindItem(pidlOld, NULL, FALSE) != -1)
    {
        _UpdateObject(pidlOld, pidlNew);
        ILFree(pidlNew);
    }
    else
    {
        // check if the shellfolder says this new guy shouldn't be enumerated.
        if (!_Attributes(pidlNew, SFGAO_NONENUMERATED))
        {
            _AddObject(pidlNew);  // takes pidl ownership.
        }
        else
        {
            ILFree(pidlNew);
        }
    }
}

#define FSNDEBUG

// WM_DSV_FSNOTIFY message

LRESULT CDefView::_OnFSNotify(LONG lNotification, LPCITEMIDLIST* ppidl)
{
    LPITEMIDLIST pidl;
    LPCITEMIDLIST pidlItem;

    //
    //  Note that renames between directories are changed to
    //  create/delete pairs by SHChangeNotify.
    //
#ifdef DEBUG
#ifdef FSNDEBUG
    TCHAR szPath[MAX_PATH];
    TraceMsg(TF_DEFVIEW, "CDefView::_OnFSNotify, hwnd = %d  lEvent = %d", _hwndView, lNotification);

    switch (lNotification)
    {
    case SHCNE_RENAMEITEM:
    case SHCNE_RENAMEFOLDER:
        // two pidls
        SHGetPathFromIDList(ppidl[0], szPath);
        TraceMsg(TF_DEFVIEW, "CDefView::_OnFSNotify: hwnd %d, %s", _hwndView, szPath);
        SHGetPathFromIDList(ppidl[1], szPath);
        TraceMsg(TF_DEFVIEW, "CDefView::_OnFSNotify: hwnd %d, %s", _hwndView, szPath);
        break;

    case SHCNE_CREATE:
    case SHCNE_DELETE:
    case SHCNE_MKDIR:
    case SHCNE_RMDIR:
    case SHCNE_MEDIAINSERTED:
    case SHCNE_MEDIAREMOVED:
    case SHCNE_DRIVEREMOVED:
    case SHCNE_DRIVEADD:
    case SHCNE_NETSHARE:
    case SHCNE_NETUNSHARE:
    case SHCNE_ATTRIBUTES:
    case SHCNE_UPDATEDIR:
    case SHCNE_UPDATEITEM:
    case SHCNE_SERVERDISCONNECT:
    case SHCNE_DRIVEADDGUI:
    case SHCNE_EXTENDED_EVENT:
        // one pidl
        SHGetPathFromIDList(ppidl[0], szPath);
        TraceMsg(TF_DEFVIEW, "CDefView::_OnFSNotify: hwnd %d, %s", _hwndView, szPath);
        break;

    case SHCNE_UPDATEIMAGE:
        // DWORD wrapped inside a pidl
        TraceMsg(TF_DEFVIEW, "CDefView::_OnFSNotify: hwnd %d, %08x", _hwndView,
            ((LPSHChangeDWORDAsIDList)ppidl[0])->dwItem1);
        break;

    case SHCNE_ASSOCCHANGED:
        // No parameters
        break;
    }
#endif
#endif

    // we may be registered for notifications on pidls that are different from
    // the one returned by _GetViewPidl (ftp folder).
    switch (lNotification)
    {
    case SHCNE_DRIVEADD:
    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        pidlItem = _pidlMonitor ? ILFindChild(_pidlMonitor, ppidl[0]) : NULL;
        pidl = _ObjectExists(pidlItem, FALSE);
        if (pidl)
        {
            _AddOrUpdateItem(pidlItem, pidl);
        }
        break;

    case SHCNE_DRIVEREMOVED:
    case SHCNE_DELETE:
    case SHCNE_RMDIR:
        pidlItem = _pidlMonitor ? ILFindChild(_pidlMonitor, ppidl[0]) : NULL;
        if (pidlItem)
        {
            ASSERTMSG(ILFindLastID(pidlItem) == pidlItem, "defview doesnt expect recursive notification");
            _RemoveObject((LPITEMIDLIST)pidlItem, FALSE);
        }
        break;

    case SHCNE_RENAMEITEM:
    case SHCNE_RENAMEFOLDER:
        _OnRename(ppidl);
        break;

    case SHCNE_UPDATEIMAGE:
        // the system image cache is changing
        // ppidl[0] is a IDLIST of image indexs that have changed

        if (ppidl && ppidl[1])
        {
            // this event is generated instead of a normal UPDATEIMAGE so that we can handle the
            // cross process case....
            // handle the notification
            int iImage = SHHandleUpdateImage(ppidl[1]);
            if (iImage != -1)
            {
                _UpdateImage(iImage);
            }
        }
        else if (ppidl && ppidl[0])
        {
            int iImage = *(int UNALIGNED *)((BYTE *)ppidl[0] + 2);
            _UpdateImage(iImage);
        }
        break;

    case SHCNE_ASSOCCHANGED:
        // For this one we will call refresh as we may need to reextract
        // the icons and the like.  Later we can optimize this somewhat if
        // we can detect which ones changed and only update those.
        _ReloadContent();
        break;

    case SHCNE_ATTRIBUTES:      // these all mean the same thing
    case SHCNE_MEDIAINSERTED:
    case SHCNE_MEDIAREMOVED:
    case SHCNE_NETUNSHARE:
    case SHCNE_NETSHARE:
    case SHCNE_UPDATEITEM:
        if (ppidl)
        {
            LPCITEMIDLIST pidlOld = _pidlMonitor ? ILFindChild(_pidlMonitor, ppidl[0]) : NULL;
            LPITEMIDLIST pidlNew = _ObjectExists(pidlOld, SHCNE_GLOBALEVENTS & lNotification);
            if (pidlNew)
            {
                _AddOrUpdateItem(pidlOld, pidlNew);
            }
            else
            {
                // If we do not have any subobjects and the passed in pidl is the same as
                // this views pidl then refresh all the items.
                LPITEMIDLIST pidlView = _GetViewPidl();
                if (pidlView)
                {
                    if (ILIsEqual(ppidl[0], pidlView))
                    {
                        _FullViewUpdate(SHCNE_UPDATEITEM == lNotification);
                    }
                    ILFree(pidlView); 
                }
            }
        }
        else    // ppidl == NULL means update all items (re-enum them)
        {
            _FullViewUpdate(SHCNE_UPDATEITEM == lNotification);
        }
        break;


    case SHCNE_FREESPACE:
        TCHAR szPath[MAX_PATH];
        if (_GetPath(szPath))
        {
            int idDrive = PathGetDriveNumber(szPath);
            if (idDrive != -1)
            {
                DWORD dwChangedDrives = *(DWORD UNALIGNED *)((BYTE *)ppidl[0] + 2);
                if (((1 << idDrive) & dwChangedDrives))
                {
                    _UpdateStatusBar(TRUE);
                }
            }
        }
        break;

    default:
        TraceMsg(TF_DEFVIEW, "DefView: unknown FSNotify %08lX, doing full update", lNotification);
        _FullViewUpdate(FALSE);
        break;
    }

    _UpdateStatusBar(FALSE);
    return 0;
}

// called when some of our objects get put on the clipboard
LRESULT CDefView::_OnSetClipboard(BOOL bMove)
{
    if (bMove)  // move
    {
        //  mark all selected items as being "cut"
        int i = -1;
        while ((i = ListView_GetNextItem(_hwndListview, i, LVIS_SELECTED)) != -1)
        {
            ListView_SetItemState(_hwndListview, i, LVIS_CUT, LVIS_CUT);
            _bHaveCutStuff = TRUE;
        }

        // join the clipboard viewer chain so we will know when to
        // "uncut" our selected items.
        if (_bHaveCutStuff)
        {
            ASSERT(!_bClipViewer);
            ASSERT(_hwndNextViewer == NULL);

            _hwndNextViewer = SetClipboardViewer(_hwndView);
            _bClipViewer = TRUE;
        }
    }
    return 0;
}

// called when the clipboard get changed, clear any items in the "cut" state
//
LRESULT CDefView::_OnClipboardChange()
{
    //
    //  if we dont have any cut stuff we dont care.
    //
    if (!_bHaveCutStuff)
        return 0;

    ASSERT(_bClipViewer);

    _RestoreAllGhostedFileView();
    _bHaveCutStuff = FALSE;

    //
    // unhook from the clipboard viewer chain.
    //
    ChangeClipboardChain(_hwndView, _hwndNextViewer);
    _bClipViewer = FALSE;
    _hwndNextViewer = NULL;

    return 0;
}

//
// Note: this function returns the point in Listview Coordinate
// space.  So any hit testing done with this needs to be converted
// back to Client coordinate space...
BOOL CDefView::_GetDropPoint(POINT *ppt)
{
    // Check whether we already have gotten the drop anchor (before any
    // menu processing)
    if (_bDropAnchor)
    {
        // We'll use the insert mark rect (if available) to determine a drop point
        if (!_GetInsertPoint(ppt))
        {
            *ppt = _ptDrop; // Otherwise use _ptDrop
            LVUtil_ClientToLV(_hwndListview, ppt);
        }
    }
    else if (_bMouseMenu)
    {
        *ppt = _ptDragAnchor;
        return TRUE;
    }
    else
    {
        // We need the most up-to-date cursor information, since this
        // may be called during a drop, and the last time the current
        // thread called GetMessage was about 10 minutes ago
        GetCursorPos(ppt);
        LVUtil_ScreenToLV(_hwndListview, ppt);
    }

    return _bDropAnchor;
}


// This uses the listview's insertmark to determinie an insert point
// Returns FALSE if a point could not be determined, TRUE otherwise
// The coordinates returned are in listview coordinate space.
BOOL CDefView::_GetInsertPoint(POINT *ppt)
{
    if (_IsAutoArrange() || (_fs.fFlags & FWF_SNAPTOGRID))
    {
        RECT rcInsert;
        if (ListView_GetInsertMarkRect(_hwndListview, &rcInsert))
        {
            LONG dwStyle = GetWindowLong(_hwndListview, GWL_STYLE);
            BOOL fHorizontal = (_fs.fFlags & FWF_ALIGNLEFT);
            if (fHorizontal)
            {
                ppt->x = (rcInsert.right + rcInsert.left) / 2; // Drop in middle of insertmark rect
                ppt->y = rcInsert.top;
            }
            else
            {
                ppt->x = rcInsert.left;
                ppt->y = (rcInsert.bottom + rcInsert.top) / 2; // Drop in middle of insertmark rect
            }
            return TRUE;
        }
    }

    return FALSE;
}


BOOL CDefView::_GetDragPoint(POINT *ppt)
{
    BOOL fSource = _bDragSource || _bMouseMenu;
    if (fSource)
    {
        // if anchor from mouse activity
        *ppt = _ptDragAnchor;
    }
    else
    {
        // if anchor from keyboard activity...  use the focused item
        int i = ListView_GetNextItem(_hwndListview, -1, LVNI_FOCUSED);
        if (i != -1)
        {
            ListView_GetItemPosition(_hwndListview, i, ppt);
        }
        else
        {
            ppt->x = ppt->y = 0;
        }
    }
    return fSource;
}

void CDefView::_PaintErrMsg(HWND hWnd)
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hWnd, &ps);

    // if we're in an error state, make sure we're not in webview
    if (_cFrame.IsWebView())
    {
        _SwitchToWebView(FALSE);
    }

    RECT rc;
    GetClientRect(hWnd, &rc);

    DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_SOFT | BF_ADJUST | BF_MIDDLE);

    EndPaint(hWnd, &ps);
}

//
//  The default status bar looks like this:
//
//  No items selected:  "nn object(s)"              nn = total objects in folder
//  One item selected:  <InfoTip for selected item> if item supports InfoTip
//  Else:               "nn object(s) selected"     nn = num selected objects
//
//
void CDefView::_DoStatusBar(BOOL fInitialize)
{
    HWND hwndStatus;
    if (_psb && SUCCEEDED(_psb->GetControlWindow(FCW_STATUS, &hwndStatus)) && hwndStatus)
    {
        // Some of the failure cases do not null hwnd...
        UINT uMsg = IDS_FSSTATUSSELECTED;

        if (fInitialize)
        {
            int ciParts[] = {-1};
            SendMessage(hwndStatus, SB_SETPARTS, ARRAYSIZE(ciParts), (LPARAM)ciParts);
        }

        if (_bBkFilling && ListView_GetSelectedCount(_hwndListview) == 0)
        {
            _fBackgroundStatusTextValid = FALSE;
            LPWSTR pszStatus = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_FSSTATUSSEARCHING));
            // We are not checking if the alloc succeeded in ShellConstructMessageString since both
            // SendMessage and LocalFree can take NULL as inputs.
            SendMessage(hwndStatus, SB_SETTEXT, (WPARAM)0, (LPARAM)pszStatus);
            LocalFree((void *)pszStatus);
        }
        else
        {

            LPCITEMIDLIST *apidl = NULL;

            int nMsgParam = ListView_GetSelectedCount(_hwndListview);
            switch (nMsgParam)
            {
            case 0:
                // No objects selected; show total item count
                nMsgParam = ListView_GetItemCount(_hwndListview);
                uMsg = IDS_FSSTATUSBASE;
                break;

            case 1:
                UINT cItems;
                GetSelectedObjects(&apidl, &cItems);
                break;
            }

            LPITEMIDLIST pidlFolder = _GetViewPidl();
            if (pidlFolder)
            {
                CStatusBarAndInfoTipTask *pTask;
                if (SUCCEEDED(CStatusBarAndInfoTipTask_CreateInstance(pidlFolder, apidl ? *apidl : NULL, uMsg, nMsgParam, NULL, _hwndView, _pScheduler, &pTask)))
                {
                    if (_pScheduler)
                    {
                        // make sure there are no other status bar background tasks going on...
                        _pScheduler->RemoveTasks(TOID_DVBackgroundStatusBar, ITSAT_DEFAULT_LPARAM, FALSE);
                    }

                    _fBackgroundStatusTextValid = TRUE;
                    _AddTask(pTask, TOID_DVBackgroundStatusBar, 0, TASK_PRIORITY_INFOTIP, ADDTASK_ATEND);
                    pTask->Release();
                }

                ILFree(pidlFolder);
            }

            if (apidl)
                LocalFree(apidl);
        }
    }
}

void CDefView::_OnWinIniChangeDesktop(WPARAM wParam, LPCTSTR pszSection)
{
    if (pszSection)
    {
        if (!lstrcmpi(pszSection, TEXT("ToggleDesktop")))
        {
            _OnCommand(NULL, SFVIDM_DESKTOPHTML_WEBCONTENT, 0);
        }
        else if (!lstrcmpi(pszSection, TEXT("RefreshDesktop")))
        {
            if (FAILED(Refresh()))
            {
                SHELLSTATE ss;

                //Refresh failed because the new template didn't exist
                //Toggle the Registry settings back to Icons-only mode!
                ss.fDesktopHTML = FALSE;
                SHGetSetSettings(&ss, SSF_DESKTOPHTML, TRUE);  // Write back the new
            }
        }
        else if (!lstrcmpi(pszSection, TEXT("BufferedRefresh")))
        {
            //See if we have already started a timer to refresh
            if (!_fRefreshBuffered)
            {
                TraceMsg(TF_DEFVIEW, "A Buffered refresh starts the timer");
                SetTimer(_hwndView, DV_IDTIMER_BUFFERED_REFRESH, 5000, NULL);   // 5 sec
                _fRefreshBuffered = TRUE;
            }
            else //If refresh is already buffered, don't do anything!
            {
                TraceMsg(TF_DEFVIEW, "A buffered refresh occured while another is pending");
            }
        }
        else
        {
            if (wParam == SPI_SETDESKWALLPAPER || wParam == SPI_SETDESKPATTERN)
            {
                _SetFolderColors();
            }
        }
    }
    else
    {
        switch(wParam)
        {
            case SPI_SETDESKWALLPAPER:
            case SPI_SETDESKPATTERN:

                _SetFolderColors();
                break;

            case SPI_ICONHORIZONTALSPACING:
            case SPI_ICONVERTICALSPACING:

                if (_IsDesktop())
                {
                    DWORD dwLVExStyle = ListView_GetExtendedListViewStyle(_hwndListview);
                    UpdateGridSizes(TRUE, _hwndListview, 0, NULL, BOOLIFY(dwLVExStyle & LVS_EX_SNAPTOGRID));
                }
                break;
        }
    }
}

void CDefView::_OnWinIniChange(WPARAM wParam, LPCTSTR pszSection)
{
    if ((wParam == SPI_GETICONTITLELOGFONT) ||
        ((wParam == 0) && pszSection && !lstrcmpi(pszSection, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\IconUnderline"))))
    {
        _UpdateUnderlines();
    }

    if (pszSection && !lstrcmpi(pszSection, TEXT("VisualEffects")))
    {
        Refresh();
    }

    // Why all this code? It's a rare event -- just kick off a refresh...
    if (!wParam || (pszSection && !lstrcmpi(pszSection, TEXT("intl"))))
    {
        // has the time format changed while we're in details mode?
        if (ViewRequiresColumns(_fs.ViewMode) && !_IsOwnerData())
        {
            InvalidateRect(_hwndListview, NULL, TRUE);

            // 99/04/13 #320903 vtan: If the date format has changed then iterate
            // the entire list looking for extended columns of type date and
            // resetting them to LPSTR_TEXTCALLBACK effectively dumping the cache.

            // For performance improvement it's possible to collect an array of
            // visible columns and reset that array. It will still involve TWO
            // for loops.

            int iItemCount = ListView_GetItemCount(_hwndListview);
            for (int iItem = 0; iItem < iItemCount; ++iItem)
            {
                for (UINT uiRealColumn = 0; uiRealColumn < _vs.GetColumnCount(); ++uiRealColumn)
                {
                    DWORD dwFlags = _vs.GetColumnState(uiRealColumn);
                    if (((dwFlags & SHCOLSTATE_EXTENDED) != 0) &&
                        ((dwFlags & SHCOLSTATE_TYPEMASK) == SHCOLSTATE_TYPE_DATE))
                    {
                        UINT uiVisibleColumn = _RealToVisibleCol(uiRealColumn);

                        ListView_SetItemText(_hwndListview, iItem, uiVisibleColumn, LPSTR_TEXTCALLBACK);
                    }
                }
            }
        }
    }

    //
    // we may need to rebuild the icon cache.
    //
    if (wParam == SPI_SETICONMETRICS ||
        wParam == SPI_SETNONCLIENTMETRICS)
    {
        if (_IsImageMode())
        {
            _SetThumbview();
        }
        else if (_IsTileMode())
        {
            _SetTileview();
        }
        else
        {
            _SetSysImageList();
        }
    }

    //
    // we need to invalidate the cursor cache
    //
    if (wParam == SPI_SETCURSORS)
    {
        DAD_InvalidateCursors();
    }

    if ((wParam == SPI_SETMENUANIMATION) && _pDUIView)
    {
        _pDUIView->ManageAnimations(FALSE);
    }

    if (!wParam && !pszSection && _pDUIView)
    {
        if (_fBarrierDisplayed != _QueryBarricadeState())
        {
            _fBarrierDisplayed = !_fBarrierDisplayed;
            _pDUIView->EnableBarrier (_fBarrierDisplayed);
        }
    }

    if (_IsDesktop())
    {
        _OnWinIniChangeDesktop(wParam, pszSection);
    }
}

void CDefView::_SetDefaultViewSettings()
{
    // only do this if we've actually shown the view...
    // (ie, there's no _hwndStatic)
    // and we're not the desktop
    // and we're not an exstended view
    // and we are not in an explorer (tree pane on)
    if (!_hwndStatic && !_IsDesktop() && !IsExplorerBrowser(_psb))
    {
        SHELLSTATE ss;

        ss.lParamSort = (LONG)_vs._lParamSort;
        ss.iSortDirection = _vs._iDirection;
        SHGetSetSettings(&ss, SSF_SORTCOLUMNS, TRUE);
    }
}

HWND CDefView::GetChildViewWindow()
{
    if (_cFrame.IsWebView())
        return _cFrame.GetExtendedViewWindow();

    return _hwndListview;
}

void CDefView::_SetFocus()
{
    // if it's a combined view then we need to give focus to listview
    if (!_fCombinedView && _cFrame.IsWebView() && !_fActivateLV)
    {
        _OnViewWindowActive();

        if (_cFrame._pOleObj)
        {
            MSG msg = {_hwndView, WM_KEYDOWN, VK_TAB, 0xf0001};

            // HACKHACK!!! MUST set state here! idealy shbrowse should call
            // UIActivate on the view but that breaks dochost stuff.
            // if we did not set the state here, trident would call
            // CSFVSite::ActivateMe that would not forward the call to obj::UIActivate
            // and therefore nothing would get focus (actually trident would have it
            // but it would not be visible). Note that this behavior happens only
            // second time around, i.e. on init UIActivate is called and everything
            // works fine, but if we tab from address bar onto the view, that's when
            // the stuff gets broken.
            OnActivate(SVUIA_ACTIVATE_FOCUS);
            _cFrame._UIActivateIO(TRUE, &msg);
        }
    }
    else
    {
        CallCB(SFVM_SETFOCUS, 0, 0);
        if (_hwndListview)
            SetFocus(_hwndListview);
        if (!_IsDesktop())
        {
            _cFrame._uState = SVUIA_ACTIVATE_FOCUS;
        }
    }
}

LRESULT CALLBACK CDefView::s_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    CDefView * pThis;
    ULONG_PTR cookie = 0;

    if (WM_NCCREATE == uMsg)
    {
        pThis = (CDefView*)((LPCREATESTRUCT)lParam)->lpCreateParams;
        if (pThis)
        {
            pThis->AddRef();
            SetWindowLongPtr(hWnd, 0, (LONG_PTR)pThis);
        }
    }
    else
    {
        pThis = (CDefView*)GetWindowLongPtr(hWnd, 0);
    }

    // FUSION: When defview calls out to 3rd party code we want it to use 
    // the process default context. This means that the 3rd party code will get
    // v5 in the explorer process. However, if shell32 is hosted in a v6 process,
    // then the 3rd party code will still get v6. 
    // Future enhancements to this codepath may include using the fusion manifest
    // tab <noinherit> which basically surplants the activat(null) in the following
    // codepath. This disables the automatic activation from user32 for the duration
    // of this wndproc, essentially doing this null push.
    ActivateActCtx(NULL, &cookie);

    // we need to use a __try{}__finally{} block here to make sure that we de-activate
    // the activation context. Fusion pushes and pops these off a stack and if we leave one
    // around we will basically infect this thread with the wrong context.
    __try
    {
        if (pThis)
        {
            lres = pThis->WndProc(hWnd, uMsg, wParam, lParam);
        }
        else
        {
            lres = DefWindowProc(hWnd, uMsg, wParam, lParam);
        }
    }
    __finally
    {
        if (cookie != 0)
        {
            DeactivateActCtx(0, cookie);
        }
    }
    return lres;
}

BOOL CDefView::_OnAppCommand(UINT cmd, UINT uDevice, DWORD dwKeys)
{
    BOOL bHandled = FALSE;
    switch (cmd)
    {
    case APPCOMMAND_MEDIA_PLAY_PAUSE:
        if (S_OK == _InvokeContextMenuVerbOnSelection("play", 0, 0))
            bHandled = TRUE;
        break;

    }
    return bHandled;
}

HRESULT CDefView::_ForwardMenuMessages(DWORD dwID, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult, BOOL* pfHandled)
{
    if (InRange(dwID, SFVIDM_BACK_CONTEXT_FIRST, SFVIDM_BACK_CONTEXT_LAST))
    {
        if (pfHandled)
            *pfHandled = TRUE;

        return SHForwardContextMenuMsg(_pcmContextMenuPopup, uMsg, wParam, lParam, plResult, TRUE);
    }
    else if (InRange(dwID, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST))
    {
        if (pfHandled)
            *pfHandled = TRUE;

        return SHForwardContextMenuMsg(_pcmFile, uMsg, wParam, lParam, plResult, TRUE);
    }

    if (pfHandled)
        *pfHandled = FALSE;

    return E_FAIL;
}

LRESULT CDefView::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT l;
    DWORD dwID;

    switch (uMsg)
    {
    // IShellBrowser forwards these to the IShellView.
    // Dochost also forwards them down to the IOleObject, so we should do it too...
    case WM_SYSCOLORCHANGE:
        {
            HDITEM hdi = {HDI_FORMAT, 0, NULL, NULL, 0, 0, 0, 0, 0};
            HWND hwndHead = ListView_GetHeader(_hwndListview);

            // We only want to update the sort arrows if they are already present.
            if (hwndHead)
            {
                Header_GetItem(hwndHead, _vs._lParamSort, &hdi);
                if (hdi.fmt & HDF_BITMAP)
                    _SetSortFeedback();
            }

            // fall through
        }

    case WM_WININICHANGE:
        _sizeThumbnail.cx = -1;

        // fall through

    case WM_ENTERSIZEMOVE:
    case WM_EXITSIZEMOVE:
    case WM_FONTCHANGE:
        if (_cFrame.IsWebView())
        {
            HWND hwndExt = _cFrame.GetExtendedViewWindow();
            if (hwndExt)
            {
                SendMessage(hwndExt, uMsg, wParam, lParam);
            }
        }
        break;
    }

    switch (uMsg)
    {
        case WM_DESTROY:
        if (GetKeyState(VK_CONTROL) < 0)
            _SetDefaultViewSettings();

        // Dont need our web view data any more
        _FreeWebViewContentData();

        // We don't flush these on WM_EXITMENULOOP any more, so do it here
        IUnknown_SetSite(_pcmFile, NULL);
        ATOMICRELEASE(_pcmFile);

        EmptyBkgrndThread(_pScheduler);
        ATOMICRELEASE(_pScheduler);

        // do this after our task scheduler is gone, since one of it's
        // items may be on the background task scheduler (or DUI may be
        // talking to it on the background) and it may need it's site chain.
        IUnknown_SetSite(_cCallback.GetSFVCB(), NULL);

        if (_pDiskCache)
        {
            // at this point we assume that we have no lock,
            _pDiskCache->Close(NULL);
            ATOMICRELEASE(_pDiskCache);
        }

        // Depending on when it is closed we may have an outstanding post
        // to us about the rest of the fill data which we should try to
        // process in order to keep from leaking stuff...

        // logically hWnd == _hwndView, but we already zeroed
        // _hwndView so use hWnd

        _ClearPostedMsgs(hWnd);

        //
        //  remove ourself as a clipboard viewer
        //
        if (_bClipViewer)
        {
            ChangeClipboardChain(hWnd, _hwndNextViewer);
            _bClipViewer = FALSE;
            _hwndNextViewer = NULL;
        }

        if (_uRegister)
        {
            ULONG uRegister = _uRegister;
            _uRegister = 0;
            SHChangeNotifyDeregister(uRegister);
        }

        ATOMICRELEASE(_psd);
        ATOMICRELEASE(_pdtgtBack);

        if (_hwndListview)
        {
            if (_IsDesktop()) // only the desktop can have a combined view (e.g. Active Desktop)
            {
                EnableCombinedView(this, FALSE);
            }

            if (_bRegisteredDragDrop)
                RevokeDragDrop(_hwndListview);
        }

        SetAutomationObject(NULL);    // cleanup refs we may be holding

        if (IsWindow(_hwndInfotip))
        {
            DestroyWindow(_hwndInfotip);
            _hwndInfotip = NULL;
        }

        break;

    case WM_CREATE:
        return _OnCreate(hWnd);

    case WM_DSV_DELAYED_DESTROYWND:
        DestroyWindow(hWnd);
        break;

    case WM_NCDESTROY:
        _hwndView = NULL;

        SetWindowLongPtr(hWnd, 0, 0);

        // get rid of extra junk in the icon cache
        IconCacheFlush(FALSE);

        if (_pDUIView)
        {
            //
            // We must uninitialize DUser prior to releasing
            // _pDUIView so that all DUser gadgets are properly destroyed.
            // We used to call DirectUI::UnInitThread() in the CDUIView dtor.  
            // However, since both CDefView and the various 'task' DUI 
            // elements maintain a ref to CDUIView, we got into scenarios where 
            // one of the 'task' elements held the final ref to CDUIView.  That 
            // resulted in the destruction of that 'task' element causing 
            // uninitialization of DUser in the middle of a DUser call stack.  
            // That's bad.
            // Uninitializing DUser here causes DUser to handle all pending
            // messages and destroy all it's gadgets on it's own terms.
            //
            _pDUIView->UnInitializeDirectUI();
            _pDUIView->Release();
            _pDUIView = NULL;
        }

        // release our reference generated during WM_NCCREATE in static wndproc
        Release();

        break;

    case WM_ENABLE:
        _fDisabled = !wParam;
        break;

    case WM_ERASEBKGND:
        {
            COLORREF cr = ListView_GetBkColor(_hwndListview);
            if (cr == CLR_NONE)
                return SendMessage(_hwndMain, uMsg, wParam, lParam);

            //Turning On EraseBkgnd. This is required so as to avoid the
            //painting issue - when the listview is not visible and
            //invalidation occurs.

            HBRUSH hbr = CreateSolidBrush(cr);
            RECT rc;
            GetClientRect(hWnd, &rc);
            FillRect((HDC)wParam, &rc, hbr);
            DeleteObject(hbr);
        }
        // We want to reduce flash
        return 1;

    case WM_PAINT:
        if (_fEnumFailed)
            _PaintErrMsg(hWnd);
        else
            goto DoDefWndProc;
        break;

    case WM_LBUTTONUP:
        if (_fEnumFailed)
            PostMessage(hWnd, WM_KEYDOWN, (WPARAM)VK_F5, 0);
        else
            goto DoDefWndProc;
        break;

    case WM_SETFOCUS:
        if (!_fDestroying)    // Ignore if we are destroying _hwndView.
        {
            _SetFocus();
        }
        break;

    case WM_MOUSEACTIVATE:
        //
        // this keeps our window from coming to the front on button down
        // instead, we activate the window on the up click
        //
        if (LOWORD(lParam) != HTCLIENT)
            goto DoDefWndProc;
        LV_HITTESTINFO lvhti;

        GetCursorPos(&lvhti.pt);
        ScreenToClient(_hwndListview, &lvhti.pt);
        ListView_HitTest(_hwndListview, &lvhti);
        if (lvhti.iItem != -1 && lvhti.flags & LVHT_ONITEM)
            return MA_NOACTIVATE;
        else
            return MA_ACTIVATE;

    case WM_ACTIVATE:
        // force update on inactive to not ruin save bits
        if (wParam == WA_INACTIVE)
            UpdateWindow(_hwndListview);
        // if active view created, call active object to allow it to visualize activation.
        if (_cFrame._pActive)
            _cFrame._pActive->OnFrameWindowActivate((BOOL)wParam);
        break;

    case WM_SIZE:
        return WndSize(hWnd);

    case WM_NOTIFY:
    {
#ifdef DEBUG
        // DefView_OnNotify sometimes destroys the pnm, so we need to save
        // the code while we can.  (E.g., common dialog single-click activate.
        // LVN_ITEMACTIVATE causes us to dismiss the common dialog, which
        // does a DestroyViewWindow, which destroys the ListView
        // which destroys the NMHDR!)
        UINT code = ((NMHDR *)lParam)->code;
#endif
        AddRef();             // just in case
        l = _OnNotify((NMHDR *)lParam);
        Release();            // release
        return l;
    }

    case WM_CONTEXTMENU:
        if (!_fDisabled)
        {
            if (lParam != (LPARAM) -1)
            {
                _bMouseMenu = TRUE;
                _ptDragAnchor.x = GET_X_LPARAM(lParam);
                _ptDragAnchor.y = GET_Y_LPARAM(lParam);
                LVUtil_ScreenToLV(_hwndListview, &_ptDragAnchor);
            }
            // Note: in deview inside a defview we can have problems of the
            // parent destroying us when we change views, so we better addref/release
            // around this...
            AddRef();
            _bContextMenuMode = TRUE;

            ContextMenu((DWORD) lParam);

            _bContextMenuMode = FALSE;
            _bMouseMenu = FALSE;
            Release();
        }
        break;

    case WM_COMMAND:
        return _OnCommand(NULL, wParam, lParam);

    case WM_APPCOMMAND:
        if (!_OnAppCommand(GET_APPCOMMAND_LPARAM(lParam), GET_DEVICE_LPARAM(lParam), GET_KEYSTATE_LPARAM(lParam)))
            goto DoDefWndProc;
        break;

    case WM_DSV_DISABLEACTIVEDESKTOP:
        DisableActiveDesktop();
        break;

    case WM_DSV_DELAYWINDOWCREATE:
        CallCB(SFVM_DELAYWINDOWCREATE, (WPARAM)_hwndView, 0);
        break;

    case WM_DSV_BACKGROUNDENUMDONE:
        // Make sure this notify is from our enumeration task (it could be from a previous one)
        if (lParam == _dwEnumId)
            _OnBackgroundEnumDone();
        break;

    case WM_DSV_GROUPINGDONE:
        _OnCategoryTaskDone();
        break;

    case WM_DSV_FILELISTENUMDONE:
        _OnEnumDoneMessage();
        break;

    case WM_DSV_FILELISTFILLDONE:
        _ShowSearchUI(FALSE);
        break;

    case WM_DSV_UPDATETHUMBNAIL:
        {
            DSV_UPDATETHUMBNAIL* putn = (DSV_UPDATETHUMBNAIL*)lParam;
            if (_IsImageMode())  // some messages may come in after the view mode is changed.
            {
                _UpdateThumbnail(putn->iItem, putn->iImage, putn->pidl);
            }
            _CleanupUpdateThumbnail(putn);
        }
        break;
    case WM_DSV_POSTCREATEINFOTIP:
        _OnPostCreateInfotip((TOOLINFO *)wParam, lParam);
        break;

    case WM_DSV_FSNOTIFY:
        {
            LPITEMIDLIST *ppidl;
            LONG lEvent;

            LPSHChangeNotificationLock pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);
            if (pshcnl)
            {
                if (_fDisabled ||
                    (CallCB(SFVM_FSNOTIFY, (WPARAM)ppidl, (LPARAM)lEvent) == S_FALSE))
                {
                    lParam = 0;
                }
                else
                {
                    lParam = _OnFSNotify(lEvent, (LPCITEMIDLIST*)ppidl);
                }
                SHChangeNotification_Unlock(pshcnl);
            }
        }
        return lParam;

    //  the background thread's callback will post this message to us
    //  when it has finished extracting a icon in the background.
    //
    //      wParam is PIDL
    //      lParam is iIconIndex

    case WM_DSV_UPDATEICON:
        _UpdateIcon((LPITEMIDLIST)wParam, (UINT)lParam);
        break;

    case WM_DSV_UPDATECOLDATA:
        _UpdateColData((CBackgroundColInfo*)lParam);
        break;

    case WM_DSV_UPDATEOVERLAY:
        _UpdateOverlay((int)wParam, (int)lParam);
        break;

    case WM_DSV_SETIMPORTANTCOLUMNS:
        _SetImportantColumns((CBackgroundTileInfo*)lParam);
        break;

    case WM_DSV_SHOWDRAGIMAGE:
        return DAD_ShowDragImage((BOOL)lParam);

    case WM_DSV_DELAYSTATUSBARUPDATE:
        {
            HWND hwndStatus;
            LPWSTR pszStatus = (LPWSTR)lParam;
            if (_fBackgroundStatusTextValid)
            {
                _fBackgroundStatusTextValid = FALSE;
                // Now prepare the text and post it to the status bar window.
                _psb->GetControlWindow(FCW_STATUS, &hwndStatus);
                if (hwndStatus)
                {
                    SendMessage(hwndStatus, SB_SETTEXT, (WPARAM)0, (LPARAM)pszStatus);
                }
            }
            LocalFree((void *)pszStatus);
        }
        break;

    case WM_DSV_DELAYINFOTIP:
        if ((CBackgroundInfoTip *)wParam == _pBackgroundInfoTip && _pBackgroundInfoTip->_fReady)
        {
            LRESULT lRet = SendMessage(_hwndListview, LVM_SETINFOTIP, NULL, (LPARAM)&_pBackgroundInfoTip->_lvSetInfoTip);
            ATOMICRELEASE(_pBackgroundInfoTip);
            return lRet;
        }
        break;

    case WM_DSV_ENSURE_COLUMNS_LOADED:
        if (!_fDestroying)
        {
            AddColumns();
            return 1;
        }
        break;

    case GET_WM_CTLCOLOR_MSG(CTLCOLOR_STATIC):
        SetBkColor(GET_WM_CTLCOLOR_HDC(wParam, lParam, uMsg),
                GetSysColor(COLOR_WINDOW));
        return (LRESULT)GetSysColorBrush(COLOR_WINDOW);

    case WM_DRAWCLIPBOARD:
        if (_hwndNextViewer != NULL)
            SendMessage(_hwndNextViewer, uMsg, wParam, lParam);

        if (_bClipViewer)
            return _OnClipboardChange();

        break;

    case WM_CHANGECBCHAIN:
        if ((HWND)wParam == _hwndNextViewer)
        {
            _hwndNextViewer = (HWND)lParam;
            return TRUE;
        }

        if (_hwndNextViewer != NULL)
            return SendMessage(_hwndNextViewer, uMsg, wParam, lParam);
        break;

    case WM_WININICHANGE:
        _OnWinIniChange(wParam, (LPCTSTR)lParam);
        SendMessage(_hwndListview, uMsg, wParam, lParam);
        break;

    case WM_THEMECHANGED:
        PostMessage(_hwndView, WM_COMMAND, (WPARAM)SFVIDM_MISC_REFRESH, 0);
        break;

    case WM_SHELLNOTIFY:
#define SHELLNOTIFY_SETDESKWALLPAPER 0x0004
        if (wParam == SHELLNOTIFY_SETDESKWALLPAPER)
        {
            if (_IsDesktop())
            {
                _fHasDeskWallPaper = (lParam != 0);
                _SetFolderColors();
            }
        }
        break;


    // What we would like out of these menu messages:
    //   WM_ENTERMENULOOP
    //   WM_INITMENUPOPUP
    //      for File.Edit.View...: handle ourselves (merge in _pcmFile etc) and forward to IShellFolderViewCB for init
    //      for submenus or context menus: forward to whatever IContextMenu owns the popup
    //   WM_INITMENUPOPUP for next menu, etc
    //   WM_EXITMENULOOP
    //      PostMessage(WM_DSV_MENUTERM)
    //   WM_COMMAND comes in, if a menu item was selected
    //      Forward to the correct object to handle
    //   WM_DSV_MENUTERM
    //      clean up File.Edit.View... (release _pcmFile etc), and forward to IShellFolderViewCB for cleanup
    //
    // From previous comments here, it sounds like we don't get proper WM_ENTERMENULOOP / WM_EXITMENULOOP.
    // I suspect this is a behavior change since Win95.  (This probably happened when we changed
    // the browser's HMENU to our own custom menu bar implementation way back in IE4...)
    //
    // Previous code also posted WM_DSV_MENUTERM *twice* -- another relic from the Edit menu days...
    //
    // If we try to clean up on WM_EXITMENULOOP, then we'll free _pcmFile etc when
    // the File menu closes. This caused us problems when we tried to merge _pcmFile
    // into the Edit menu.  (We should have used _pcmEdit and cleaned up on WM_UNINITMENUPOPUP.)
    // This is no longer a problem for defview, but it is a problem for the IShellFolderViewCB
    // which can merge into any of File.Edit.View... menus.  (In fact, no code in the source tree
    // does anything on SFVM_EXITMENULOOP.)
    //
    // We could free up _pcmFile early (when the File menu goes away) if we want,
    // but there doesn't seem to be any harm in letting it sit around.
    // So rip out this unused WM_EXITMENULOOP/WM_DSVMENUTERM/_OnMenuTermination code.
    //
    case WM_INITMENU:
        _OnInitMenu();
        break;

    case WM_INITMENUPOPUP:
        _OnInitMenuPopup((HMENU)wParam, LOWORD(lParam), HIWORD(lParam));
        break;

    case WM_TIMER:
        KillTimer(hWnd, (UINT) wParam);

        // Ignore if we're in the middle of destroying the window
        if (_fDestroying)
            break;

        if (DV_IDTIMER_START_ANI == wParam)
        {
            if (_hwndStatic)
            {
                WCHAR szName[128];
                HINSTANCE hinst;

                // used only by camera namespace; they have a const string < 128 ch
                if (S_OK != CallCB(SFVM_GETANIMATION, (WPARAM)&hinst, (LPARAM)szName))
                {
                    hinst = g_hinst;
                    StrCpyNW(szName, L"#150", ARRAYSIZE(szName));
                }

                HWND hAnimate = ::GetWindow (_hwndStatic, GW_CHILD);

                if (hAnimate)
                {
                    // Animate_OpenEx() except we want the W version always
                    SendMessage(hAnimate, ACM_OPENW, (WPARAM)hinst, (LPARAM)szName);
                }
            }
        }
        else if (DV_IDTIMER_BUFFERED_REFRESH == wParam)
        {
            if (_fRefreshBuffered)
            {
                _fRefreshBuffered = FALSE;
                PostMessage(_hwndView, WM_KEYDOWN, (WPARAM)VK_F5, 0);
                TraceMsg(TF_DEFVIEW, "Buffered Refresh timer causes actual refresh");
            }
        }
        else if (DV_IDTIMER_NOTIFY_AUTOMATION_SELCHANGE == wParam)
        {
            _OnDelayedSelectionChange();
        }
        else if (DV_IDTIMER_NOTIFY_AUTOMATION_CONTENTSCHANGED == wParam)
        {
            _OnDelayedContentsChanged();
        }
        else if (DV_IDTIMER_DISKCACHE == wParam)
        {
            DWORD dwMode;
            if (_pDiskCache->GetMode(&dwMode) == S_OK && _pDiskCache->IsLocked() == S_FALSE)
            {
                // two seconds since last access, close the cache.
                _pDiskCache->Close(NULL);
            }

            if (_GetBackgroundTaskCount(TOID_NULL) == 0)
            {
                // there is nothing in the queue pending, so quit listening...
                KillTimer(hWnd, DV_IDTIMER_DISKCACHE);
            }
            break;

        }
        else if (DV_IDTIMER_SCROLL_TIMEOUT == wParam)
        {
            // Scroll timer expired.
            TraceMsg(TF_DEFVIEW, "SCROLL TIMEOUT");

            _fScrolling = FALSE;

            // Now we send a paint to listview, so it will send us more requests for tileinformation
            // that we ignored during scrolling.
            if (_fRequestedTileDuringScroll)
            {
                InvalidateRect(_hwndListview, NULL, FALSE);
            }
        }
        else
        {
            ASSERT(FALSE); // nobody is handling this timer id!
        }
        break;

    case WM_SETCURSOR:
        if (_hwndStatic)
        {
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            return TRUE;
        }
        goto DoDefWndProc;

    case WM_DRAWITEM:
        #define lpdis ((LPDRAWITEMSTRUCT)lParam)
        dwID = lpdis->itemID;

        if (lpdis->CtlType != ODT_MENU)
            return 0;
        if (InRange(lpdis->itemID, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST) && HasCB())
        {
            CallCB(SFVM_DRAWITEM, SFVIDM_CLIENT_FIRST, lParam);
            return 1;
        }
        else
        {
            LRESULT lResult = 0;
            _ForwardMenuMessages(dwID, uMsg, wParam, lParam, &lResult, NULL);
            return lResult;
        }
        #undef lpdis

    case WM_MEASUREITEM:
        #define lpmis ((LPMEASUREITEMSTRUCT)lParam)
        dwID = lpmis->itemID;

        if (lpmis->CtlType != ODT_MENU)
            return 0;

        if (InRange(lpmis->itemID, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST) && HasCB())
        {
            CallCB(SFVM_MEASUREITEM, SFVIDM_CLIENT_FIRST, lParam);
            return 1;
        }
        else
        {
            LRESULT lResult = 0;
            _ForwardMenuMessages(dwID, uMsg, wParam, lParam, &lResult, NULL);
            return lResult;
        }

    case WM_MENUCHAR:

        if (_pcmFile)
        {
            LRESULT lResult;
            HRESULT hr = SHForwardContextMenuMsg(_pcmFile, uMsg, wParam, lParam, &lResult, FALSE);
            if (hr == S_OK)
                return lResult;
        }

        if (_pcmContextMenuPopup)
        {
            LRESULT lResult;
            HRESULT hr = SHForwardContextMenuMsg(_pcmContextMenuPopup, uMsg, wParam, lParam, &lResult, FALSE);
            if (hr == S_OK)
                return lResult;
        }

        return MAKELONG(0, MNC_IGNORE);

    // there are two possible ways to put help texts in the
    // status bar, (1) processing WM_MENUSELECT or (2) handling MenuHelp
    // messages. (1) is compatible with OLE, but (2) is required anyway
    // for tooltips.
    //
    case WM_MENUSELECT:
        _OnMenuSelect(GET_WM_MENUSELECT_CMD(wParam, lParam), GET_WM_MENUSELECT_FLAGS(wParam, lParam), GET_WM_MENUSELECT_HMENU(wParam, lParam));
        break;

    case WM_SYSCOLORCHANGE:
        _SetFolderColors();
        SendMessage(_hwndListview, uMsg, wParam, lParam);
        _rgbBackColor = CLR_INVALID;
        break;

    case SVM_SELECTITEM:
        SelectItem((LPCITEMIDLIST)lParam, (int) wParam);
        break;

    case SVM_SELECTANDPOSITIONITEM:
    {
        SFM_SAP * psap = (SFM_SAP*)lParam;
        for (UINT i = 0; i < wParam; psap++, i++)
            SelectAndPositionItem(psap->pidl, psap->uSelectFlags, psap->fMove ? &psap->pt : NULL);
        break;
    }

    case WM_PALETTECHANGED:
        if (_IsImageMode())
        {
            InvalidateRect(_hwndListview, NULL, FALSE);
            return TRUE;
        }
        // else Fall Through
    case WM_QUERYNEWPALETTE:
        if (_IsImageMode())
        {
            return FALSE; // Let Browser handle palette management
        }
        else
        {
            HWND hwndT = GetChildViewWindow();
            if (!hwndT)
                goto DoDefWndProc;

            return SendMessage(hwndT, uMsg, wParam, lParam);
        }

    case WM_DSV_REARRANGELISTVIEW:
        _ShowAndActivate();
        break;

    case WM_DSV_SENDSELECTIONCHANGED:
        _OnSelectionChanged();
        break;

    case WM_DSV_SENDNOITEMSTATECHANGED:
        _OnNoItemStateChanged();
        break;

    case WM_DSV_DESKHTML_CHANGES:
        if (_IsDesktop())
        {
            IADesktopP2 *piadp2;
            if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_ActiveDesktop, NULL, IID_PPV_ARG(IADesktopP2, &piadp2))))
            {
                IActiveDesktopP *piadpp;

                //  98/11/23 #254482 vtan: When making changes using dynamic
                //  HTML don't forget to update the "desktop.htt" file so
                //  that it's in sync with the registry BEFORE using DHTML.
                if (SUCCEEDED(piadp2->QueryInterface(IID_PPV_ARG(IActiveDesktopP, &piadpp))))
                {
                    piadpp->EnsureUpdateHTML();     // ignore result
                    piadpp->Release();
                }
                piadp2->MakeDynamicChanges(_cFrame._pOleObj);
                piadp2->Release();
            }
        }
        break;

    // Toggling the New Start Menu on/off causes My Computer, etc.
    // desktop icons to dynamically hide/show themselves.
    case WM_DSV_STARTPAGE_TURNONOFF:
        _ReloadContent(FALSE);
        break;

    case WM_DSV_ADJUSTRECYCLEBINPOSITION:
        {
            // We need to move the recycle bin to it's default position.
            POINT ptRecycleBin;
            int iIndexRecycleBin = _FreezeRecycleBin(&ptRecycleBin);
            if (iIndexRecycleBin != LV_NOFROZENITEM)
                _SetRecycleBinInDefaultPosition(&ptRecycleBin);
        }
        break;

    default:
DoDefWndProc:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return 0;
}

// don't test the result as this will fail on the second call
void CDefView::_RegisterWindow(void)
{
    WNDCLASS wc = {0};

    // don't want vredraw and hredraw because that causes horrible
    // flicker expecially with full drag
    wc.style         = CS_PARENTDC;
    wc.lpfnWndProc   = CDefView::s_WndProc;
    wc.cbWndExtra    = sizeof(CDefView *);
    wc.hInstance     = HINST_THISDLL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wc.lpszClassName = TEXT("SHELLDLL_DefView");

    RegisterClass(&wc);
}

CDefView::~CDefView()
{
    _uState = SVUIA_DEACTIVATE;

    // Sanity check.
    ASSERT(_tlistPendingInfotips.GetHeadPosition() == NULL);

    DebugMsg(TF_LIFE, TEXT("dtor CDefView %x"), this);

    //
    // Just in case, there is a left over.
    //
    _dvdt.LeaveAndReleaseData();

    //
    // We need to give it a chance to clean up.
    //
    CallCB(SFVM_PRERELEASE, 0, 0);

    DestroyViewWindow();

    ATOMICRELEASE(_pSelectionShellItemArray);
    ATOMICRELEASE(_pFolderShellItemArray);

    ATOMICRELEASE(_pScheduler);
    //
    // We should release _psb after _pshf (for docfindx)
    //
    ATOMICRELEASE(_pshf);
    ATOMICRELEASE(_pshf2);
    ATOMICRELEASE(_pshfParent);
    ATOMICRELEASE(_pshf2Parent);
    ILFree(_pidlRelative);
    ATOMICRELEASE(_psi);
    ATOMICRELEASE(_psio);
    ATOMICRELEASE(_pcdb);
    ATOMICRELEASE(_psb);
    ATOMICRELEASE(_psd);

    IUnknown_SetSite(_pcmFile, NULL);
    ATOMICRELEASE(_pcmFile);

    ATOMICRELEASE(_pcat);
    ATOMICRELEASE(_pImageCache);
    ATOMICRELEASE(_pDiskCache);

    DSA_Destroy(_hdaCategories);
    DSA_Destroy(_hdsaSCIDCache);

    //  NOTE we dont release psvOuter
    //  it has a ref on us

    if (_pbtn)
        LocalFree(_pbtn);

    //
    // Cleanup _dvdt
    //
    _dvdt.ReleaseDataObject();
    _dvdt.ReleaseCurrentDropTarget();

    _ClearPendingSelectedItems();

    ATOMICRELEASE(_pauto);
    ATOMICRELEASE(_padvise);

    if (_hmenuCur)
    {
        DestroyMenu(_hmenuCur);
    }

    ATOMICRELEASE(_pBackgroundInfoTip);
    ATOMICRELEASE(_ppui);

    if (_pidlSelectAndPosition)
        ILFree(_pidlSelectAndPosition);

    Str_SetPtr(&_pszLegacyWatermark, NULL);

    if (_hdpaGroupingListActive)
        DPA_Destroy(_hdpaGroupingListActive);

    if (_hdpaGroupingListBackup)
        DPA_Destroy(_hdpaGroupingListBackup);
}




HRESULT CDefView::_AddTask(IRunnableTask *pTask, REFTASKOWNERID rTID, DWORD_PTR lParam, DWORD dwPriority, DWORD grfFlags)
{
    HRESULT hr = E_FAIL;

    if (_pScheduler)
    {
        if (grfFlags & ADDTASK_ONLYONCE)
        {
            hr = _pScheduler->MoveTask(rTID, lParam, dwPriority, (grfFlags & ADDTASK_ATFRONT ? ITSSFLAG_TASK_PLACEINFRONT : ITSSFLAG_TASK_PLACEINBACK));
        }

        if (hr != S_OK)  // If we didn't move it, add it
        {
            hr = _pScheduler->AddTask2(pTask, rTID, lParam, dwPriority, (grfFlags & ADDTASK_ATFRONT ? ITSSFLAG_TASK_PLACEINFRONT : ITSSFLAG_TASK_PLACEINBACK));
        }
    }

    return hr;
}

//  Get the number of running tasks of the indicated task ID.
UINT CDefView::_GetBackgroundTaskCount(REFTASKOWNERID rtid)
{
    return _pScheduler ? _pScheduler->CountTasks(rtid) : 0;
}


const TBBUTTON c_tbDefView[] = {
    { VIEW_MOVETO | IN_VIEW_BMP,    SFVIDM_EDIT_MOVETO,     TBSTATE_ENABLED,    BTNS_BUTTON,   {0,0}, 0, -1},
    { VIEW_COPYTO | IN_VIEW_BMP,    SFVIDM_EDIT_COPYTO,     TBSTATE_ENABLED,    BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_DELETE | IN_STD_BMP,      SFVIDM_FILE_DELETE,     TBSTATE_ENABLED,    BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_UNDO | IN_STD_BMP,        SFVIDM_EDIT_UNDO,       TBSTATE_ENABLED,    BTNS_BUTTON,   {0,0}, 0, -1},
    { 0,    0,      TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
    { VIEW_VIEWMENU | IN_VIEW_BMP,  SFVIDM_VIEW_VIEWMENU,   TBSTATE_ENABLED,    BTNS_WHOLEDROPDOWN, {0,0}, 0, -1},
    // hidden buttons (off by default, available only via customize dialog)
    { STD_PROPERTIES | IN_STD_BMP,  SFVIDM_FILE_PROPERTIES, TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_CUT | IN_STD_BMP,         SFVIDM_EDIT_CUT,        TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_COPY | IN_STD_BMP,        SFVIDM_EDIT_COPY,       TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_PASTE | IN_STD_BMP,       SFVIDM_EDIT_PASTE,      TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { VIEW_OPTIONS | IN_VIEW_BMP,   SFVIDM_TOOL_OPTIONS,    TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
};

const TBBUTTON c_tbDefViewWebView[] = {
    //{ 0,    0,      TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
    { VIEW_VIEWMENU | IN_VIEW_BMP,  SFVIDM_VIEW_VIEWMENU,   TBSTATE_ENABLED,    BTNS_WHOLEDROPDOWN, {0,0}, 0, -1},
    // hidden buttons (off by default, available only via customize dialog)
    { VIEW_MOVETO | IN_VIEW_BMP,    SFVIDM_EDIT_MOVETO,     TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { VIEW_COPYTO | IN_VIEW_BMP,    SFVIDM_EDIT_COPYTO,     TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_DELETE | IN_STD_BMP,      SFVIDM_FILE_DELETE,     TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_UNDO | IN_STD_BMP,        SFVIDM_EDIT_UNDO,       TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_PROPERTIES | IN_STD_BMP,  SFVIDM_FILE_PROPERTIES, TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_CUT | IN_STD_BMP,         SFVIDM_EDIT_CUT,        TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_COPY | IN_STD_BMP,        SFVIDM_EDIT_COPY,       TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { STD_PASTE | IN_STD_BMP,       SFVIDM_EDIT_PASTE,      TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
    { VIEW_OPTIONS | IN_VIEW_BMP,   SFVIDM_TOOL_OPTIONS,    TBSTATE_HIDDEN | TBSTATE_ENABLED,   BTNS_BUTTON,   {0,0}, 0, -1},
};

// win95 defview toolbar, used for corel apphack
const TBBUTTON c_tbDefView95[] = {
    { STD_CUT | IN_STD_BMP,         SFVIDM_EDIT_CUT,        TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1},
    { STD_COPY | IN_STD_BMP,        SFVIDM_EDIT_COPY,       TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1},
    { STD_PASTE | IN_STD_BMP,       SFVIDM_EDIT_PASTE,      TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1},
    { 0,    0,      TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
    { STD_UNDO | IN_STD_BMP,        SFVIDM_EDIT_UNDO,       TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1},
    { 0,    0,      TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
    { STD_DELETE | IN_STD_BMP,      SFVIDM_FILE_DELETE,     TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1},
    { STD_PROPERTIES | IN_STD_BMP,  SFVIDM_FILE_PROPERTIES, TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1},
    { 0,    0,      TBSTATE_ENABLED, BTNS_SEP, {0,0}, 0, -1 },
    // the bitmap indexes here are relative to the view bitmap
    { VIEW_LARGEICONS | IN_VIEW_BMP, SFVIDM_VIEW_ICON,      TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1 },
    { VIEW_SMALLICONS | IN_VIEW_BMP, SFVIDM_VIEW_SMALLICON, TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1 },
    { VIEW_LIST       | IN_VIEW_BMP, SFVIDM_VIEW_LIST,      TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1 },
    { VIEW_DETAILS    | IN_VIEW_BMP, SFVIDM_VIEW_DETAILS,   TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, -1 },
};


LRESULT CDefView::_TBNotify(NMHDR *pnm)
{
    LPTBNOTIFY ptbn = (LPTBNOTIFY)pnm;

    switch (pnm->code)
    {
    case TBN_BEGINDRAG:
        _OnMenuSelect(ptbn->iItem, 0, 0);
        break;
    }
    return 0;
}

BOOL CDefView::_MergeIExplorerToolbar(UINT cExtButtons)
{
    BOOL fRet = FALSE;
    IExplorerToolbar *piet;
    if (SUCCEEDED(IUnknown_QueryService(_psb, SID_SExplorerToolbar, IID_PPV_ARG(IExplorerToolbar, &piet))))
    {
        BOOL fGotClsid = TRUE;

        DWORD dwFlags = 0;

        if (cExtButtons == 0)
        {
            // This shf has no buttons to merge in; use the standard defview
            // clsid so that the shf shares standard toolbar customization.
            _clsid = CGID_DefViewFrame;

        }
        else if (SUCCEEDED(IUnknown_GetClassID(_pshf, &_clsid)))
        {
            // This shf has buttons to merge in; use its clsid
            // so that this shf gets separate customization persistence.

            // The shf might expect us to provide room for two lines of
            // text (since that was the default in IE4).
            dwFlags |= VBF_TWOLINESTEXT;
        }
        else
        {
            // This shf has buttons to merge in but doesn't implement
            // IPersist::GetClassID; so we can't use IExplorerToolbar mechanism.
            fGotClsid = FALSE;
        }

        if (fGotClsid)
        {
            HRESULT hr = piet->SetCommandTarget((IUnknown *)SAFECAST(this, IOleCommandTarget *), &_clsid, dwFlags);
            if (SUCCEEDED(hr))
            {
                // If hr == S_FALSE, another defview merged in its buttons under the
                // same clsid, and they're still there.  So no need to call AddButtons.

                if (hr != S_FALSE)
                    hr = piet->AddButtons(&_clsid, _cButtons, _pbtn);

                if (SUCCEEDED(hr))
                {
                    fRet = TRUE;
                }
            }
        }
        piet->Release();
    }
    return fRet;
}

int _FirstHiddenButton(TBBUTTON* ptbn, int cButtons)
{
    for (int i = 0; i < cButtons; i++)
    {
        if (ptbn[i].fsState & TBSTATE_HIDDEN)
            break;
    }

    return i;
}

void CDefView::_CopyDefViewButton(PTBBUTTON ptbbDest, PTBBUTTON ptbbSrc)
{
    *ptbbDest = *ptbbSrc;

    if (!(ptbbDest->fsStyle & BTNS_SEP))
    {
        // Fix up bitmap offset depending on whether this is a "view" bitmap or a "standard" bitmap
        if (ptbbDest->iBitmap & IN_VIEW_BMP)
            ptbbDest->iBitmap = (int)((ptbbDest->iBitmap & ~PRIVATE_TB_FLAGS) + _iViewBMOffset);
        else
            ptbbDest->iBitmap = (int)(ptbbDest->iBitmap + _iStdBMOffset);
    }
}

//
// Here's the deal with _GetButtons
//
// DefView has some buttons, and its callback client may have some buttons.
//
// Some of defview's buttons are visible on the toolbar by default, and some only show
// up if you customize the toolbar.
//
// We specify which buttons are hidden by default by marking them with TBSTATE_HIDDEN in
// the declaration of c_tbDefView.  We assume all such buttons are in a continuous block at
// the end of c_tbDefView.
//
// We return in ppbtn a pointer to an array of all the buttons, including those not shown
// by default.  We put the buttons not shown by default at the end of this array.  We pass
// back in pcButtons the count of visible buttons, and in pcTotalButtons the count of visible
// and hidden buttons.
//
// The int return value is the number of client buttons in the array.
//
int CDefView::_GetButtons(PTBBUTTON* ppbtn, LPINT pcButtons, LPINT pcTotalButtons)
{
    int cVisibleBtns = 0;   // count of visible defview + client buttons

    TBINFO tbinfo;
    tbinfo.uFlags = TBIF_APPEND;
    tbinfo.cbuttons = 0;

    // Does the client want to prepend/append a toolbar?
    CallCB(SFVM_GETBUTTONINFO, 0, (LPARAM)&tbinfo);

    _uDefToolbar = HIWORD(tbinfo.uFlags);
    tbinfo.uFlags &= 0xffff;


    // tbDefView needs to be big enough to hold either c_tbDefView or c_tbDefView95
    COMPILETIME_ASSERT(ARRAYSIZE(c_tbDefView95) >= ARRAYSIZE(c_tbDefView));
    COMPILETIME_ASSERT(ARRAYSIZE(c_tbDefView95) >= ARRAYSIZE(c_tbDefViewWebView));


    TBBUTTON tbDefView[ARRAYSIZE(c_tbDefView95)];
    int cDefViewBtns;   // total count of defview buttons

    if (SHGetAppCompatFlags(ACF_WIN95DEFVIEW) & ACF_WIN95DEFVIEW)
    {
        memcpy(tbDefView, c_tbDefView95, sizeof(TBBUTTON) * ARRAYSIZE(c_tbDefView95));
        cDefViewBtns = ARRAYSIZE(c_tbDefView95);
    }
    else if (_cFrame.IsWebView() || _pDUIView)
    {
        memcpy(tbDefView, c_tbDefViewWebView, sizeof(TBBUTTON) * ARRAYSIZE(c_tbDefViewWebView));
        cDefViewBtns = ARRAYSIZE(c_tbDefViewWebView);
    }
    else
    {
        memcpy(tbDefView, c_tbDefView, sizeof(TBBUTTON) * ARRAYSIZE(c_tbDefView));
        cDefViewBtns = ARRAYSIZE(c_tbDefView);
    }

    int cVisibleDefViewBtns = _FirstHiddenButton(tbDefView, cDefViewBtns);  // count of visible defview buttons

    TBBUTTON *pbtn = (TBBUTTON *)LocalAlloc(LPTR, (cDefViewBtns + tbinfo.cbuttons) * sizeof(*pbtn));
    if (pbtn)
    {
        int iStart = 0;
        cVisibleBtns = tbinfo.cbuttons + cVisibleDefViewBtns;

        // Have the client fill in its buttons
        switch (tbinfo.uFlags)
        {
        case TBIF_PREPEND:
            CallCB(SFVM_GETBUTTONS,
                         MAKEWPARAM(SFVIDM_CLIENT_FIRST, tbinfo.cbuttons),
                         (LPARAM)pbtn);
            iStart = tbinfo.cbuttons;
            break;

        case TBIF_APPEND:
            CallCB(SFVM_GETBUTTONS,
                         MAKEWPARAM(SFVIDM_CLIENT_FIRST, tbinfo.cbuttons),
                         (LPARAM)&pbtn[cVisibleDefViewBtns]);
            iStart = 0;
            break;

        case TBIF_REPLACE:
            CallCB(SFVM_GETBUTTONS,
                         MAKEWPARAM(SFVIDM_CLIENT_FIRST, tbinfo.cbuttons),
                         (LPARAM)pbtn);

            cVisibleBtns = tbinfo.cbuttons;
            cVisibleDefViewBtns = 0;
            break;

        default:
            RIPMSG(0, "View callback passed an invalid TBINFO flag");
            break;
        }

        // Fill in visible defview buttons
        for (int i = 0; i < cVisibleDefViewBtns; i++)
        {
            // Visible defview button block gets added at iStart
            _CopyDefViewButton(&pbtn[i + iStart], &tbDefView[i]);
        }

        // Fill in hidden defview buttons
        for (i = cVisibleDefViewBtns; i < cDefViewBtns; i++)
        {
            // Hidden defview button block gets added after visible & client buttons
            _CopyDefViewButton(&pbtn[i + tbinfo.cbuttons], &tbDefView[i]);

            // If this rips a visible button got mixed in with the hidden block
            ASSERT(pbtn[i + tbinfo.cbuttons].fsState & TBSTATE_HIDDEN);

            // Rip off the hidden bit
            pbtn[i + tbinfo.cbuttons].fsState &= ~TBSTATE_HIDDEN;
        }
    }

    ASSERT(ppbtn);
    ASSERT(pcButtons);
    ASSERT(pcTotalButtons);

    *ppbtn = pbtn;
    *pcButtons = cVisibleBtns;
    *pcTotalButtons = tbinfo.cbuttons + cDefViewBtns;

    return tbinfo.cbuttons;
}


void CDefView::MergeToolBar(BOOL bCanRestore)
{
    TBADDBITMAP ab;

    ab.hInst = HINST_COMMCTRL;          // hinstCommctrl
    ab.nID   = IDB_STD_SMALL_COLOR;     // std bitmaps
    _psb->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, 8, (LPARAM)&ab, &_iStdBMOffset);

    ab.nID   = IDB_VIEW_SMALL_COLOR;    // std view bitmaps
    _psb->SendControlMsg(FCW_TOOLBAR, TB_ADDBITMAP, 8, (LPARAM)&ab, &_iViewBMOffset);

    if (_pbtn)
        LocalFree(_pbtn);

    int cExtButtons = _GetButtons(&_pbtn, &_cButtons, &_cTotalButtons);

    if (_pbtn && !_MergeIExplorerToolbar(cExtButtons))
    {
        // if we're able to do the new IExplorerToolbar merge method, great...
        // if not, we use the old style
        _psb->SetToolbarItems(_pbtn, _cButtons, FCT_MERGE);
        CDefView::CheckToolbar();
    }
}

STDMETHODIMP CDefView::GetWindow(HWND *phwnd)
{
    *phwnd = _hwndView;
    return S_OK;
}

STDMETHODIMP CDefView::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDefView::EnableModeless(BOOL fEnable)
{
    // We have no modeless window to be enabled/disabled
    return S_OK;
}

HRESULT CDefView::_ReloadListviewContent()
{
    // HACK: We always call IsShared with fUpdateCache=FALSE for performance.
    //  However, we need to update the cache when the user explicitly tell
    //  us to "Refresh". This is not the ideal place to put this code, but
    //  we have no other choice.

    TCHAR szPathAny[MAX_PATH];

    _UpdateSelectionMode();

    // finish any pending edits
    SendMessage(_hwndListview, LVM_EDITLABEL, (WPARAM)-1, 0);

    GetWindowsDirectory(szPathAny, ARRAYSIZE(szPathAny));
    IsShared(szPathAny, TRUE);

    // HACK: strange way to notify folder that we're refreshing
    ULONG rgf = SFGAO_VALIDATE;
    _pshf->GetAttributesOf(0, NULL, &rgf);

    //
    // if a item is selected, make sure it gets nuked from the icon
    // cache, this is a last resort type thing, select a item and
    // hit F5 to fix all your problems.
    //
    int iItem = ListView_GetNextItem(_hwndListview, -1, LVNI_SELECTED);
    if (iItem != -1)
        CFSFolder_UpdateIcon(_pshf, _GetPIDL(iItem));

    // We should not save the selection if doing refresh.
    _ClearPendingSelectedItems();

    // 01/05/21 #399284: Don't save/restore the state and nuke objects if there's a background process using them
    if(!_bBkFilling)
    {
        // First we have to save all the icon positions, so they will be restored
        // properly during the FillObjectsShowHide
        SaveViewState();

        // 99/04/07 #309965 vtan: Persist the view state (above). Make sure
        // our internal representation is the same as the one on the disk
        // by dumping our cache and reloading the information.
        GetViewState();

        // To make it look like the refesh is doing something, clear
        // all the icons from the view before we start enumerating.
        _RemoveObject(NULL, FALSE);
        _fSyncOnFillDone = TRUE; // apply the just-saved view state when we finish enumeration

    }

    return FillObjectsShowHide(TRUE);
}

HRESULT CDefView::_ReloadContent(BOOL fForce)
{
    if (_bReEntrantReload)
    {
        return S_FALSE;
    }
    _bReEntrantReload = TRUE;

    HRESULT hrExtView = S_OK;
    HRESULT hrNormalView = S_OK;
    SHELLSTATE ss;

    // Tell the defview client that this window is about to be refreshed
    _CallRefresh(TRUE);

    // make sure that the CommandIds and the Uids match by recreating the menus
    RecreateMenus();

    // If the global SSF_WIN95CLASSIC state changed, we need to muck with the UI.
    SHGetSetSettings(&ss, SSF_WIN95CLASSIC, FALSE);
    // Show webview and pane again if we are forced OR the view has changed.
    if (fForce || (BOOLIFY(ss.fWin95Classic) != BOOLIFY(_fClassic)))
    {
        _fClassic = ss.fWin95Classic;
        _UpdateListviewColors();
    }

    if (_ShouldShowWebView())
    {
        // We need to save the icon positions before we refresh the view.
        SaveViewState();

        if (_pDUIView)
        {
            hrExtView = _pDUIView->Refresh();
        }
        else
        {
            _TryShowWebView(_fs.ViewMode, _fs.ViewMode);
        }
    }
    else
    {
        _TryHideWebView(); // make sure it's off
    }

    // We want to preserve the earlier error if any
    hrNormalView = _ReloadListviewContent();

    _bReEntrantReload = FALSE;
    return FAILED(hrExtView) ? hrExtView : hrNormalView;
}

STDMETHODIMP CDefView::Refresh()
{
    // See if some refreshes were buffered
    if (_fRefreshBuffered)
    {
        //Since we are refreshing it right now. Kill the timer.
        TraceMsg(TF_DEFVIEW, "Buffered Refresh Timer Killed by regular Refresh");
        KillTimer(_hwndView, DV_IDTIMER_BUFFERED_REFRESH);
        _fRefreshBuffered = FALSE;
    }

    // If desktop is in modal state, do not attempt to refresh.
    // If we do, we endup destroying Trident object when it is in modal state.
    if (_IsDesktop() && _fDesktopModal)
    {
        // Remember that we could not refresh the desktop because it was in
        // a modal state.
        _fDesktopRefreshPending = TRUE;
        return S_OK;
    }

    // make sure we have the latest
    SHRefreshSettings();

    _UpdateRegFlags();

    if (_IsDesktop())
    {
        SHELLSTATE ss = {0};
        SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE);

        // The following code is not needed because _ReloadContent() takes care of switching to 
        // web-view.
        // _SwitchDesktopHTML(BOOLIFY(ss.fDesktopHTML));
        
        if (ss.fDesktopHTML)
        {
            // For backward compatibility, hide the desktop channel bar.
            HideIE4DesktopChannelBar();
            
            // ActiveDesktop is not part of shdocvw's browser session count
            // so when we refresh, we must tell wininet to reset the session
            // count otherwise we will not hit the net.
            MyInternetSetOption(NULL, INTERNET_OPTION_RESET_URLCACHE_SESSION, NULL, 0);
        }
    }

    return _ReloadContent(TRUE);
}

STDMETHODIMP CDefView::CreateViewWindow(IShellView *psvPrevious,
        LPCFOLDERSETTINGS pfs, IShellBrowser *psb, RECT *prc, HWND *phWnd)
{
    SV2CVW2_PARAMS cParams = {0};

    cParams.cbSize   = sizeof(SV2CVW2_PARAMS);
    cParams.psvPrev  = psvPrevious;
    cParams.pfs      = pfs;
    cParams.psbOwner = psb;
    cParams.prcView  = prc;

    HRESULT hr = CreateViewWindow2(&cParams);

    *phWnd = cParams.hwndView;

    if (SUCCEEDED(hr) &&
        (SHGetAppCompatFlags(ACF_OLDCREATEVIEWWND) & ACF_OLDCREATEVIEWWND))
    {
        //
        //  CreateViewWindow was documented as returning S_OK on success,
        //  but IE4 changed the function to return S_FALSE if the defview
        //  was created async.
        //
        //  PowerDesk relies on the old behavior.
        //  So does Quattro Pro.
        //
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CDefView::HandleRename(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_FAIL;

    // Gross, but if no PIDL passed in use the GetObject(-2) hack to get the selected object...
    // Don't need to free as it wsa not cloned...
    if (!pidl)
    {
        GetObject((LPITEMIDLIST*)&pidl, (UINT)-2);
    }
    else
    {
        RIP(ILFindLastID(pidl) == pidl);
        if (ILFindLastID(pidl) != pidl)
        {
            return E_INVALIDARG;
        }
    }

    hr = SelectAndPositionItem(pidl, SVSI_SELECT, NULL);
    if (SUCCEEDED(hr))
        hr = SelectAndPositionItem(pidl, SVSI_EDIT, NULL);

    return hr;
}



// IViewObject
HRESULT CDefView::GetColorSet(DWORD dwAspect, LONG lindex, void *pvAspect,
    DVTARGETDEVICE *ptd, HDC hicTargetDev, LOGPALETTE **ppColorSet)
{
    if (_cFrame.IsWebView() && _cFrame._pvoActive)
    {
        return _cFrame._pvoActive->GetColorSet(dwAspect, lindex, pvAspect,
            ptd, hicTargetDev, ppColorSet);
    }

    if (ppColorSet)
        *ppColorSet = NULL;

    return E_FAIL;
}

HRESULT CDefView::Freeze(DWORD, LONG, void *, DWORD *pdwFreeze)
{
    return E_NOTIMPL;
}

HRESULT CDefView::Unfreeze(DWORD)
{
    return E_NOTIMPL;
}

HRESULT CDefView::SetAdvise(DWORD dwAspect, DWORD advf, IAdviseSink *pSink)
{
    if (dwAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    if (advf & ~(ADVF_PRIMEFIRST | ADVF_ONLYONCE))
        return E_INVALIDARG;

    if (pSink != _padvise)
    {
        ATOMICRELEASE(_padvise);

        _padvise = pSink;

        if (_padvise)
            _padvise->AddRef();
    }

    if (_padvise)
    {
        _advise_aspect = dwAspect;
        _advise_advf = advf;

        if (advf & ADVF_PRIMEFIRST)
            PropagateOnViewChange(dwAspect, -1);
    }
    else
        _advise_aspect = _advise_advf = 0;

    return S_OK;
}

HRESULT CDefView::GetAdvise(DWORD *pdwAspect, DWORD *padvf,
    IAdviseSink **ppSink)
{
    if (pdwAspect)
        *pdwAspect = _advise_aspect;

    if (padvf)
        *padvf = _advise_advf;

    if (ppSink)
    {
        if (_padvise)
            _padvise->AddRef();

        *ppSink = _padvise;
    }

    return S_OK;
}

HRESULT CDefView::Draw(DWORD, LONG, void *, DVTARGETDEVICE *, HDC, HDC,
    const RECTL *, const RECTL *, BOOL (*)(ULONG_PTR), ULONG_PTR)
{
    return E_NOTIMPL;
}

void CDefView::PropagateOnViewChange(DWORD dwAspect, LONG lindex)
{
    dwAspect &= _advise_aspect;

    if (dwAspect && _padvise)
    {
        IAdviseSink *pSink = _padvise;
        IUnknown *punkRelease;

        if (_advise_advf & ADVF_ONLYONCE)
        {
            punkRelease = pSink;
            _padvise = NULL;
            _advise_aspect = _advise_advf = 0;
        }
        else
            punkRelease = NULL;

        pSink->OnViewChange(dwAspect, lindex);

        ATOMICRELEASE(punkRelease);
    }
}

void CDefView::PropagateOnClose()
{
    //
    // we aren't closing ourselves, just somebody under us...
    // ...reflect this up the chain as a view change.
    //
    if (_padvise)
        PropagateOnViewChange(_advise_aspect, -1);
}

UINT CDefView::_ValidateViewMode(UINT uViewMode)
{
    UINT uViewModeDefault = FVM_ICON;

    if (uViewMode >= FVM_FIRST && uViewMode <= FVM_LAST)
    {
        uViewModeDefault = uViewMode;
#ifdef DEBUG
        if (!_ViewSupported(uViewMode))
        {
            // Whoa! the default is excluded?  Ignore it.
            TraceMsg(TF_WARNING, "Bug in IShellFolderViewCB client: returned a default viewmode that is excluded");
        }
#endif
    }
    else
    {
        TraceMsg(TF_WARNING, "Bug in IShellFolderViewCB client: returned invalid viewmode");
    }

    return uViewModeDefault;
}


UINT CDefView::_GetDefaultViewMode()
{
    UINT uViewMode = (_IsDesktop() || !IsOS(OS_SERVERADMINUI)) ? FVM_ICON : FVM_DETAILS;
    CallCB(SFVM_DEFVIEWMODE, 0, (LPARAM)&uViewMode);

    return _ValidateViewMode(uViewMode);
}

void CDefView::_GetDeferredViewSettings(UINT* puViewMode)
{
    SFVM_DEFERRED_VIEW_SETTINGS sdvsSettings;

    ZeroMemory(&sdvsSettings, sizeof(sdvsSettings));

    if (SUCCEEDED(CallCB(SFVM_GETDEFERREDVIEWSETTINGS, 0, (LPARAM)&sdvsSettings)))
    {
        _vs._lParamSort = sdvsSettings.uSortCol;
        _vs._iDirection = sdvsSettings.iSortDirection >= 0 ? 1 : -1;
        *puViewMode     = _ValidateViewMode(sdvsSettings.fvm);

        _fs.fFlags = (_fs.fFlags & ~FWF_AUTOARRANGE) | (sdvsSettings.fFlags & FWF_AUTOARRANGE);
        SHSetWindowBits(_hwndListview, GWL_STYLE, LVS_AUTOARRANGE, _IsAutoArrange() ? LVS_AUTOARRANGE : 0);

        if (sdvsSettings.fGroupView && (*puViewMode != FVM_THUMBSTRIP))
        {
            SHCOLUMNID scid;
            if SUCCEEDED(_pshf2->MapColumnToSCID(sdvsSettings.uSortCol, &scid))
            {
                _CategorizeOnGUID(&CLSID_DetailCategorizer, &scid);
            }
        }
    }
    else
    {
        *puViewMode = _GetDefaultViewMode();
    }
}

BOOL CDefView::_ViewSupported(UINT uView)
{
    SFVM_VIEW_DATA vi;
    _GetSFVMViewState(uView, &vi);

    BOOL fIncludeView;
    if (vi.dwOptions == SFVMQVI_INCLUDE)
        fIncludeView = TRUE;
    else if (vi.dwOptions == SFVMQVI_EXCLUDE)
        fIncludeView = FALSE;
    else
        fIncludeView = uView != FVM_THUMBSTRIP; // by default, everything is included except FVM_THUMBSTRIP

    return fIncludeView;
}

STDMETHODIMP CDefView::GetView(SHELLVIEWID* pvid, ULONG uView)
{
    HRESULT hr;

    if ((int)uView >= 0)
    {
        // start with the first supported view
        UINT fvm = FVM_FIRST;
        while (fvm <= FVM_LAST && !_ViewSupported(fvm))
            fvm++;

        // find fvm associated with index uView
        for (ULONG i = 0; fvm <= FVM_LAST && i < uView; fvm++, i++)
        {
            // skip unsupported views
            while (fvm <= FVM_LAST && !_ViewSupported(fvm))
                fvm++;
        }

        if (fvm <= FVM_LAST)
        {
            hr = SVIDFromViewMode((FOLDERVIEWMODE)fvm, pvid);
        }
        else if (i == uView)
        {
            // enumerate the "default view" so the browser doesn't throw it out later
            *pvid = VID_DefaultView;
            hr = S_OK;
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        // We're being asked about specific view info:

        switch (uView)
        {
        case SV2GV_CURRENTVIEW:
            hr = SVIDFromViewMode((FOLDERVIEWMODE)_fs.ViewMode, pvid);
            break;

        case SV2GV_DEFAULTVIEW:
            // tell the browser "default" so we can pick the right one later on
            *pvid = VID_DefaultView;
            hr = S_OK;
            break;

        default:
            hr = E_INVALIDARG;
            break;
        }
    }

    return hr;
}

// For Folder Advanced Options flags that we check often, it's better
// to cache the values as flags. Update them here.
void CDefView::_UpdateRegFlags()
{
    DWORD dwValue, cbSize = sizeof(dwValue);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
            TEXT("ClassicViewState"), NULL, &dwValue, &cbSize)
        && dwValue)
    {
        _fWin95ViewState = TRUE;
    }
    else
    {
        _fWin95ViewState = FALSE;
    }
}

BOOL CDefView::_SetupNotifyData()
{
    if (!_pidlMonitor && !_lFSEvents)
    {
        LPCITEMIDLIST pidl = NULL;
        LONG lEvents = 0;

        if (SUCCEEDED(CallCB(SFVM_GETNOTIFY, (WPARAM)&pidl, (LPARAM)&lEvents)))
        {
            _pidlMonitor = pidl;
            _lFSEvents = lEvents;
        }
    }
    return _pidlMonitor || _lFSEvents;
}

void CDefView::_ShowViewEarly()
{
    // Show the window early (what old code did)
    SetWindowPos(_hwndView, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);
    _OnMoveWindowToTop(_hwndView);
    UpdateWindow(_hwndView);
}

BOOL LV_FindWorkArea(RECT rcWorkAreas[], int nWorkAreas, POINT *ppt, int *piWorkArea)
{
    for (int iWork = 0; iWork < nWorkAreas; iWork++)
    {
        if (PtInRect(&rcWorkAreas[iWork], *ppt))
        {
            *piWorkArea = iWork;
            return TRUE;
        }
    }

    *piWorkArea = 0;    // default case is the primary work area
    return FALSE;
}

void CDefView::_ClearItemPositions()
{
    _fUserPositionedItems = FALSE;
    _vs.ClearPositionData();
}

//
// This function finds the Recycle bin icon and freezes it. It also freezes the bottom right corner
// slot sothat no icon can occupy it.
//

int CDefView::_FreezeRecycleBin(POINT *ppt)
{
    int iIndexRecycleBin = -1;

    if (_IsDesktop())
    {
        LPITEMIDLIST pidlRecycleBin;
        if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_BITBUCKET, NULL, 0, &pidlRecycleBin)))
        {
            //Find the index of the recycle bin in the listview.
            iIndexRecycleBin = _FindItem(pidlRecycleBin, NULL, FALSE);
            if (iIndexRecycleBin >= 0) //If we don't find recycle bin, we don't have anything to do!
            {
                //Freeze the recycle item (prevent it from moving)
                ListView_SetFrozenItem(_hwndListview, TRUE, iIndexRecycleBin);

                RECT rcItem;
                ListView_GetItemRect(_hwndListview, iIndexRecycleBin, &rcItem, LVIR_SELECTBOUNDS);

                //Get the ViewRect.
                RECT    rcViewRect;
                int     nWorkAreas = 0;
                //Get the number of work-areas
                ListView_GetNumberOfWorkAreas(_hwndListview, &nWorkAreas);
                if (nWorkAreas > 1)
                {
                    ASSERT(nWorkAreas <= LV_MAX_WORKAREAS);
                    if (nWorkAreas <= LV_MAX_WORKAREAS) // just make sure in retail
                    {
                        RECT rcWorkAreas[LV_MAX_WORKAREAS];
                        int iCurWorkArea = 0;
                        //Get all the work areas!
                        ListView_GetWorkAreas(_hwndListview, nWorkAreas, rcWorkAreas);
                        //Find which work area the Recycle-bin currently lies.
                        LV_FindWorkArea(rcWorkAreas, nWorkAreas, (LPPOINT)(&rcItem.left), &iCurWorkArea);
                        CopyRect(&rcViewRect, &rcWorkAreas[iCurWorkArea]);
                    }
                }
                else
                {
                    ListView_GetViewRect(_hwndListview, &rcViewRect);
                }

                //Calculate the bottom-right corner of this slot
                POINT ptRecycleBin;
                ptRecycleBin.x = rcViewRect.right;
                ptRecycleBin.y = rcViewRect.bottom;

                //Freeze this slot sothat no other icon can occupy this.
                ListView_SetFrozenSlot(_hwndListview, TRUE, &ptRecycleBin);

                RECT rcIcon;
                ListView_GetItemRect(_hwndListview, iIndexRecycleBin, &rcIcon, LVIR_ICON);

                ppt->x = rcViewRect.right  - RECTWIDTH(rcIcon)  - (RECTWIDTH(rcItem)  - RECTWIDTH(rcIcon))/2;
                ppt->y = rcViewRect.bottom - RECTHEIGHT(rcItem);
            }
            ILFree(pidlRecycleBin);
        }
    }

    return iIndexRecycleBin;
}

//
// This function moves the RecycleBin item to the given location and then unfreezes the item and
// the frozen slot.
//
void CDefView::_SetRecycleBinInDefaultPosition(POINT *ppt)
{
    // If a sorting has happened since an item was frozen, the index of that item would have changed.
    // So, get the index of the recycle bin here.
    int iIndexRecycleBin = ListView_GetFrozenItem(_hwndListview);

    if (iIndexRecycleBin != LV_NOFROZENITEM)
    {
        //Move the recycle-bin icon to it's default position
        _SetItemPosition(iIndexRecycleBin, ppt->x, ppt->y);
        //Unfreeze the slot
        ListView_SetFrozenSlot(_hwndListview, FALSE, NULL); //FALSE ==> Unfreeze!
        //Unfreeze the recycle bin
        ListView_SetFrozenItem(_hwndListview, FALSE, 0); //FALSE ==> Unfreeze!
        //Since we repositioned recyclebin earlier, we need to save it in the registry.
        //Do we need this?
        // SaveViewState();
    }
}

STDMETHODIMP CDefView::CreateViewWindow2(LPSV2CVW2_PARAMS pParams)
{
    if (g_dwProfileCAP & 0x00000001)
        StopCAP();

    if (pParams->cbSize < sizeof(SV2CVW2_PARAMS))
        return E_INVALIDARG;

    pParams->hwndView = NULL;

    _RegisterWindow();

    if (_hwndView || !pParams->psbOwner)
        return E_UNEXPECTED;

    DECLAREWAITCURSOR;
    SetWaitCursor();

    // Need to leave this code as is. Previously, we had changed it to
    // pParams->psbOwner->QueryInterface(IID_PPV_ARG(IShellBrowser, &_psb));
    // However, this breaks Corel Quattro Pro 8 in their filesave dialog.
    // They pass in some sort of dummy "stub" IShellBrowser. QI'ing it for IShellBrowser
    // will do nothing, and thus _psb will remain null, and we crash. Restoring it to
    // the old way, _psb will be their "stub", but still valid, IShellBrowser.
    // Look for other comments for "Quattro Pro" in this file to see why they pass
    // in this stub.
    // (do this before doing the GetWindowRect)
    _psb = pParams->psbOwner;
    _psb->AddRef();
    ASSERT(_psb); // much of our code assumes this to be valid w/o checking

#ifdef _X86_
    // Verify that the CHijaakObjectWithSite is properly laid out
    COMPILETIME_ASSERT(FIELD_OFFSET(CDefView, _psfHijaak) + sizeof(_psfHijaak) ==
                       FIELD_OFFSET(CDefView, _psb));
#endif

    _fGlobeCanSpin = TRUE;
    _GlobeAnimation(TRUE);

    HRESULT hr;

    SHELLSTATE ss; // we will need these bits later on
    SHGetSetSettings(&ss, SSF_WIN95CLASSIC | SSF_DESKTOPHTML | SSF_WEBVIEW | SSF_STARTPANELON, FALSE);

    _pshf->QueryInterface(IID_PPV_ARG(IShellIcon, &_psi));
    _pshf->QueryInterface(IID_PPV_ARG(IShellIconOverlay, &_psio));

    pParams->psbOwner->QueryInterface(IID_PPV_ARG(ICommDlgBrowser, &_pcdb));

    // listview starts out in large icon mode, we will switch to the proper view shortly
    _fs.ViewMode = FVM_ICON;

    // refetch FWF_ after browser supplied versions stomped our copy
    _fs.fFlags = pParams->pfs->fFlags & ~FWF_OWNERDATA;
    CallCB(SFVM_FOLDERSETTINGSFLAGS, 0, (LPARAM)&_fs.fFlags);

    // pvid takes precedence over pfs->ViewMode
    UINT fvm = pParams->pfs->ViewMode;
    if (pParams->pvid)
    {
        if (IsEqualIID(*pParams->pvid, VID_DefaultView))
            fvm = FVM_LAST + 1; // not a real view -- we will pick after enumeration
        else
            ViewModeFromSVID(pParams->pvid, (FOLDERVIEWMODE *)&fvm);
    }

    // This should never fail
    _psb->GetWindow(&_hwndMain);
    ASSERT(IsWindow(_hwndMain));
    CallCB(SFVM_HWNDMAIN, 0, (LPARAM)_hwndMain);

    // We need to restore the column widths and icon positions before showing the window
    if (!GetViewState())
    {
        // Icon positions are not available; Therefore, it is a clean install
        // and we need to position recycle bin if this is Desktop.
        _fPositionRecycleBin = BOOLIFY(_IsDesktop());
    }
    _fSyncOnFillDone = TRUE; // apply the just-loaded view state when we finish enumeration

    // if there was a previous view that we know about, update our column state
    if (_fWin95ViewState && pParams->psvPrev)
    {
        _vs.InitFromPreviousView(pParams->psvPrev);
    }

    _pEnumTask = new CDefviewEnumTask(this, ++_dwEnumId);
    if (_pEnumTask &&
        CreateWindowEx(IS_WINDOW_RTL_MIRRORED(_hwndMain) ? dwExStyleRTLMirrorWnd : 0, 
            TEXT("SHELLDLL_DefView"), NULL,
            WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_TABSTOP,
            pParams->prcView->left, pParams->prcView->top, 
            pParams->prcView->right - pParams->prcView->left, 
            pParams->prcView->bottom - pParams->prcView->top,
            _hwndMain, NULL, HINST_THISDLL, this))
    {
        // See if they want to overwrite the selection object
        if (_fs.fFlags & FWF_OWNERDATA)
        {
            // Only used in owner data.
            ILVRange *plvr = NULL;
            CallCB(SFVM_GETODRANGEOBJECT, LVSR_SELECTION, (LPARAM)&plvr);
            if (plvr)
            {
                ListView_SetLVRangeObject(_hwndListview, LVSR_SELECTION, plvr);
                plvr->Release();    // We assume the lv will hold onto it...
            }

            plvr = NULL;
            CallCB(SFVM_GETODRANGEOBJECT, LVSR_CUT, (LPARAM)&plvr);
            if (plvr)
            {
                ListView_SetLVRangeObject(_hwndListview, LVSR_CUT, plvr);
                plvr->Release();    // We assume the lv will hold onto it...
            }
        }

        // This needs to be done before calling _BestFit (used to be in _FillObjects)
        // so that the parent can handle size changes effectively.
        pParams->hwndView = _hwndView;

        // Since ::FillObjects can take a while we force a paint now
        // before any items are added so we don't see the gray background of
        // the explorer window for a long time.
        //
        // We used to do this after determining "async-ness" of the view, which
        // required us to pick the webview template.  We want to postpone that
        // decision so force the repaint in the same scenarios that we otherwise
        // would have (non-webview or desktop).
        //
        // Make an educated guess here, if we get it wrong, we fix it up below.
        //
        if (!_ShouldShowWebView() || _IsDesktop())
        {
            _ShowViewEarly();
        }

        // Try and fill the listview synchronously with view creation.
        //
        _fAllowSearchingWindow = TRUE;
        hr = _pEnumTask->FillObjectsToDPA(TRUE);
        if (SUCCEEDED(hr))
        {
            // Setting the view mode has to happen after SFVM_ENUMERATEDITEMS
            // NOTE: this also AddColumns() if the new view requires them
            if (FVM_LAST + 1 == fvm)
                _GetDeferredViewSettings(&fvm);

            // Don't call SetCurrentViewMode since it clears position data and we may have read in
            // position data via GetViewState but haven't used it yet.  Call _SwitchToViewFVM directly.
            hr = _SwitchToViewFVM(fvm, SWITCHTOVIEW_NOWEBVIEW);


            // The following bits depend on the result of _SwitchToViewFVM.
            // It returns the value from turning on web view,
            // this is used to determine async defview behavior (so we have
            // an answer to the SHDVID_CANACTIVATENOW question the browser
            // will soon ask us).
            //
            // Note: Desktop synchronous, even for web view
            //
            if (SUCCEEDED(hr) && _IsDesktop())
                hr = S_OK;
            _fCanActivateNow = (S_OK == hr); // S_FALSE implies async waiting for ReadyStateInteractive
            _fIsAsyncDefView = !BOOLIFY(_fCanActivateNow); // needed in a separate bit since _fCanActivateNow changes

            // This has to happen after _SwitchToViewFVM so it can calculate
            // the correct size of the window
            _BestFit();

            // Tell the defview client that this windows has been initialized
            // Note that this must come before _pEnumTask->FillObjectsDPAToDone() so that the status bar displays
            // (Disk Free space xxGB) correctly in explorer view.
            CallCB(SFVM_WINDOWCREATED, (WPARAM)_hwndView, 0);

            //
            // If this is desktop, we need to calc and upgrade the grid sizes.
            // (This is needed because the SnapToGrid may be ON and the default grid size
            // will result in large gutter space on the edges).
            //
            if (_IsDesktop())
            {
                DWORD dwLVExStyle = ListView_GetExtendedListViewStyle(_hwndListview);
                //
                //Since the work areas are NOT yet set for the desktop's listview (because this is too early
                //in it's creation, we pass just one work area and the view rect as work area here.)
                //
                UpdateGridSizes(TRUE, _hwndListview, 1, pParams->prcView, BOOLIFY(dwLVExStyle & LVS_EX_SNAPTOGRID));
            }
            
            // Doing this after _BestFit means we dont need to auto-auto arrange
            _pEnumTask->FillObjectsDPAToDone();

            // splitting this function call in half means that we won't call WebView with contents changed for initial population
            _SwitchToViewFVM(fvm, SWITCHTOVIEW_WEBVIEWONLY);

            // If we're activating now, make sure we did the synchronous thing up above...
            // (If not, do it now -- otherwise defview may never be shown)
            if (_fCanActivateNow && !(!_ShouldShowWebView() || _IsDesktop()))
            {
                _ShowViewEarly();
            }
        
            if (_IsDesktop())
            {
                HideIE4DesktopChannelBar();
            }

            // turn on proper background and colors
            _fClassic = ss.fWin95Classic;
            _UpdateListviewColors();

            // this needs to be done after the enumeration
            if (_SetupNotifyData())
            {
                SHChangeNotifyEntry fsne = {0};

                if (FAILED(CallCB(SFVM_QUERYFSNOTIFY, 0, (LPARAM)&fsne)))
                {
                    // Reset entry
                    fsne.pidl = _pidlMonitor;
                    fsne.fRecursive = FALSE;
                }

                int iSources = (_lFSEvents & SHCNE_DISKEVENTS) ? SHCNRF_ShellLevel | SHCNRF_InterruptLevel : SHCNRF_ShellLevel;
                LONG lEvents = _lFSEvents | SHCNE_UPDATEIMAGE | SHCNE_UPDATEDIR;
                _uRegister = SHChangeNotifyRegister(_hwndView, SHCNRF_NewDelivery | iSources,
                    lEvents, WM_DSV_FSNOTIFY, 1, &fsne);
            }

            // We do the toolbar before the menu bar to avoid flash
            if (!_IsDesktop())
                MergeToolBar(TRUE);

            // Note: it's okay for the CreateViewObject(&_pdtgtBack) to fail
            ASSERT(_pdtgtBack == NULL);
            _pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IDropTarget, &_pdtgtBack));

            // we don't really need to register drag drop when in the shell because
            // our frame does it for us.   we still need it here for comdlg and other
            // hosts.. but for the desktop, let the desktpo frame take care of this
            // so that they can do webbar d/d creation
            if (!_IsDesktop())
            {
                THR(RegisterDragDrop(_hwndListview, SAFECAST(this, IDropTarget*)));
                _bRegisteredDragDrop = TRUE;
            }

            ASSERT(SUCCEEDED(hr))

            PostMessage(_hwndView, WM_DSV_DELAYWINDOWCREATE, 0, 0);

            if (SUCCEEDED(CallCB(SFVM_QUERYCOPYHOOK, 0, 0)))
                AddCopyHook();

            if (SUCCEEDED(_GetIPersistHistoryObject(NULL)))
            {
                IBrowserService *pbs;
                if (SUCCEEDED(_psb->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs))))
                {
                    IOleObject *pole;
                    IStream *pstm;
                    IBindCtx *pbc;
                    pbs->GetHistoryObject(&pole, &pstm, &pbc);
                    if (pole)
                    {
                        IUnknown_SetSite(pole, SAFECAST(this, IShellView2*));      // Set the back pointer.
                        if (pstm)
                        {
                            IPersistHistory *pph;
                            if (SUCCEEDED(pole->QueryInterface(IID_PPV_ARG(IPersistHistory, &pph))))
                            {
                                pph->LoadHistory(pstm, pbc);
                                pph->Release();
                            }
                            pstm->Release();
                        }
                        IUnknown_SetSite(pole, NULL);  // just to be safe...
                        if (pbc)
                            pbc->Release();
                        pole->Release();
                    }
                    pbs->Release();
                }
            }

            if (_psb && !_dwProffered)
            {
                // Proffer DVGetEnum service: this connects CDefView with the tree control for
                // optimized navigation.
                IUnknown_ProfferService(_psb, SID_SFolderView, SAFECAST(this, IServiceProvider *), &_dwProffered);
                // Failure here does not require special handling
            }
        }
        else
        {
            // Cleanup - enum failed.
            DestroyViewWindow();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    _GlobeAnimation(FALSE);

    ResetWaitCursor();

    return hr;
}

struct SCHEDULER_AND_HWND {
    IShellTaskScheduler *pScheduler;
    HWND hwnd;
};

STDMETHODIMP CDefView::DestroyViewWindow()
{
    if (_fDestroying)
        return S_OK;

    if (_psb && _dwProffered)
    {
        // Revoke DVGetEnum service
        IUnknown_ProfferService(_psb, SID_SFolderView, NULL, &_dwProffered);
        // Failure here does not require special handling
    }

    // Make sure that we stop the spinning globe before going away.
    _GlobeAnimation(FALSE, TRUE);

    _fDestroying = TRUE;

    // 99/04/16 #326158 vtan: Loop thru the headers looking for
    // stray HBITMAPs which need to be DeleteObject'd. Don't bother
    // setting it back the header is about to be dumped.
    // NOTE: Make sure this gets executed BEFORE the view gets
    // dumped below in DestoryViewWindow().
    if (IsWindow(_hwndListview))
    {
        HWND hwndHeader = ListView_GetHeader(_hwndListview);
        if (IsWindow(hwndHeader))
        {
            int iHeaderCount = Header_GetItemCount(hwndHeader);
            for (int i = 0; i < iHeaderCount; ++i)
            {
                HDITEM hdi = {0};
                hdi.mask = HDI_BITMAP;
                Header_GetItem(hwndHeader, i, &hdi);
                if (hdi.hbm != NULL)
                    TBOOL(DeleteObject(hdi.hbm));
            }
        }
    }

    _cFrame.HideWebView();

    //
    // Just in case...
    //
    OnDeactivate();

    if (IsWindow(_hwndView))
    {
        //
        // This is a bit lazy implementation, but minimum code.
        //
        RemoveCopyHook();

        // Tell the defview client that this window will be destroyed
        CallCB(SFVM_WINDOWDESTROY, (WPARAM)_hwndView, 0);
    }

    if (IsWindow(_hwndView))
    {
        if (_pScheduler)
        {
            // empty the queue but do NOT wait until it is empty.....
            _pScheduler->RemoveTasks(TOID_NULL, ITSAT_DEFAULT_LPARAM, FALSE);

            // If there is still a task going, then kill our window later, as to not
            // block the UI thread.
#ifdef DEBUG
            // Stress the feature in debug mode
            if (1)
#else
            if (_GetBackgroundTaskCount(TOID_NULL) > 0)
#endif
            {
                ShowWindow(_hwndView, SW_HIDE);

                // We are NOT passing 'this' defview pointer to the background thread
                // because we do not want the destructor of defview to be called on any
                // thread other than the one it was created on.
                SCHEDULER_AND_HWND *pData = (SCHEDULER_AND_HWND *)LocalAlloc(LPTR, sizeof(*pData));
                if (pData)
                {
                    _pScheduler->AddRef();
                    pData->pScheduler = _pScheduler;
                    pData->hwnd = _hwndView;
                    // We need to keep Browseui loaded because we depend on the CShellTaskScheduler
                    // to be still around when our background task executes. Browseui can be unloaded by COM when
                    // we CoUninit from this thread.
                    if (SHQueueUserWorkItem(CDefView::BackgroundDestroyWindow, pData, 0, NULL, NULL, "browseui.dll", 0))
                        goto exit;
                    else
                    {
                        LocalFree(pData);
                        _pScheduler->Release();
                    }
                }
            }
        }
        DestroyWindow(_hwndView);
    }

exit:
    return S_OK;
}

DWORD CDefView::BackgroundDestroyWindow(void *pvData)
{
    SCHEDULER_AND_HWND *pData = (SCHEDULER_AND_HWND *)pvData;

    // Note: the window coud have been already destroyed before we get here
    // in the case where the frame gets closed down.
    if (IsWindow(pData->hwnd))
    {
        // Remove all tasks
        EmptyBkgrndThread(pData->pScheduler);

        // We need to release before we post to ensure that browseui doesn't get unloaded from under us (pScheduler is
        // in browseui.dll). Browseui can get unloaded when we uninitialize OLE's MTA, even if there are still refs on the DLL.
        pData->pScheduler->Release();
        PostMessage(pData->hwnd, WM_DSV_DELAYED_DESTROYWND, 0, 0);
    }
    else
    {
        pData->pScheduler->Release();
    }

    LocalFree(pData);
    return 0;
}

void CDefView::_MergeViewMenu(HMENU hmenuViewParent, HMENU hmenuMerge)
{
    HMENU hmenuView = _GetMenuFromID(hmenuViewParent, FCIDM_MENU_VIEW);
    if (hmenuView)
    {
#ifdef DEBUG
        DWORD dwValue;
        DWORD cbSize = sizeof(dwValue);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER,
                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                TEXT("DebugWebView"), NULL, &dwValue, &cbSize)
            && dwValue)
        {
            MENUITEMINFO mi = {0};
            mi.cbSize       = sizeof(mi);
            mi.fMask        = MIIM_TYPE|MIIM_ID;
            mi.fType        = MFT_STRING;
            mi.dwTypeData   = TEXT("Show WebView Content");
            mi.wID          = SFVIDM_DEBUG_WEBVIEW;
            InsertMenuItem(hmenuMerge, -1, MF_BYPOSITION, &mi);
        }
#endif

        //
        // Find the "options" separator in the view menu.
        //
        int index = MenuIndexFromID(hmenuView, FCIDM_MENU_VIEW_SEP_OPTIONS);

        //
        // Here, index is the index of he "optoins" separator if it has;
        // otherwise, it is -1.
        //

        // Add the separator above (in addition to existing one if any).
        InsertMenu(hmenuView, index, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);

        // Then merge our menu between two separators (or right below if only one).
        if (index != -1)
        {
            index++;
        }

        Shell_MergeMenus(hmenuView, hmenuMerge, (UINT)index, 0, (UINT)-1, MM_SUBMENUSHAVEIDS);
    }
}

void CDefView::_SetUpMenus(UINT uState)
{
    //
    // If this is desktop, don't bother creating menu
    //
    if (!_IsDesktop())
    {
        OnDeactivate();

        ASSERT(_hmenuCur == NULL);

        HMENU hMenu = CreateMenu();
        if (hMenu)
        {
            HMENU hMergeMenu;
            OLEMENUGROUPWIDTHS mwidth = { { 0, 0, 0, 0, 0, 0 } };

            _hmenuCur = hMenu;
            _psb->InsertMenusSB(hMenu, &mwidth);

            if (uState == SVUIA_ACTIVATE_FOCUS)
            {
                hMergeMenu = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(POPUP_SFV_MAINMERGE));
                if (hMergeMenu)
                {
                    // NOTE: hard coded references to offsets in this menu

                    Shell_MergeMenus(_GetMenuFromID(hMenu, FCIDM_MENU_FILE),
                            GetSubMenu(hMergeMenu, 0), (UINT)0, 0, (UINT)-1,
                            MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS | MM_DONTREMOVESEPS);

                    Shell_MergeMenus(_GetMenuFromID(hMenu, FCIDM_MENU_EDIT),
                            GetSubMenu(hMergeMenu, 1), (UINT)-1, 0, (UINT)-1,
                            MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS | MM_DONTREMOVESEPS);

                    _MergeViewMenu(hMenu, GetSubMenu(hMergeMenu, 2));

                    Shell_MergeMenus(_GetMenuFromID(hMenu, FCIDM_MENU_HELP),
                            GetSubMenu(hMergeMenu, 3), (UINT)0, 0, (UINT)-1,
                            MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);

                    DestroyMenu(hMergeMenu);
                }

            }
            else
            {
                hMergeMenu = LoadMenu(HINST_THISDLL, MAKEINTRESOURCE(POPUP_SFV_MAINMERGENF));
                if (hMergeMenu)
                {
                    // NOTE: hard coded references to offsets in this menu

                    // top half of edit menu
                    Shell_MergeMenus(_GetMenuFromID(hMenu, FCIDM_MENU_EDIT),
                            GetSubMenu(hMergeMenu, 0), (UINT)0, 0, (UINT)-1,
                            MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);

                    // bottom half of edit menu
                    Shell_MergeMenus(_GetMenuFromID(hMenu, FCIDM_MENU_EDIT),
                            GetSubMenu(hMergeMenu, 1), (UINT)-1, 0, (UINT)-1,
                            MM_SUBMENUSHAVEIDS);

                    // view menu
                    _MergeViewMenu(hMenu, GetSubMenu(hMergeMenu, 2));

                    Shell_MergeMenus(_GetMenuFromID(hMenu, FCIDM_MENU_HELP),
                            GetSubMenu(hMergeMenu, 3), (UINT)0, 0, (UINT)-1,
                            MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);

                    DestroyMenu(hMergeMenu);
                }
            }

            // Allow the client to merge its own menus
            UINT indexClient = GetMenuItemCount(hMenu)-1;
            QCMINFO info = { hMenu, indexClient, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST };
            CallCB(SFVM_MERGEMENU, 0, (LPARAM)&info);

            _psb->SetMenuSB(hMenu, NULL, _hwndView);
        }
    }
}

// set up the menus based on our activation state
//
BOOL CDefView::OnActivate(UINT uState)
{
    if (_uState != uState)
    {
        _SetUpMenus(uState);
        _uState = uState;
    }

    return TRUE;
}

BOOL CDefView::OnDeactivate()
{
    if (_hmenuCur || (_uState != SVUIA_DEACTIVATE))
    {
        if (!_IsDesktop())
        {
            ASSERT(_hmenuCur);

            CallCB(SFVM_UNMERGEMENU, 0, (LPARAM)_hmenuCur);

            _psb->SetMenuSB(NULL, NULL, NULL);
            _psb->RemoveMenusSB(_hmenuCur);
            DestroyMenu(_hmenuCur);
            _hmenuCur = NULL;
        }
        _uState = SVUIA_DEACTIVATE;
    }
    return TRUE;
}

void CDefView::_OnMoveWindowToTop(HWND hwnd)
{
    //
    // Let the browser know that this has happened
    //
    VARIANT var;
    var.vt = VT_INT_PTR;
    var.byref = hwnd;

    IUnknown_Exec(_psb, &CGID_Explorer, SBCMDID_ONVIEWMOVETOTOP, 0, &var, NULL);
}

//
// This function activates the view window. Note that activating it
// will not change the focus (while setting the focus will activate it).
//
STDMETHODIMP CDefView::UIActivate(UINT uState)
{
    if (SVUIA_DEACTIVATE == uState)
    {
        OnDeactivate();
        ASSERT(_hmenuCur==NULL);
    }
    else
    {
        if (_fIsAsyncDefView)
        {
            // Need to show the defview window for the Async Case only. Showing
            // it earlier causes repaint problems(Bug 275266). Showing the window
            // here for the Sync case also causes problems - when the client
            // creates a Synchronous Defview and then hides it later which gets
            // lost with this SetWindowPos (Bug 355392).

           SetWindowPos(_hwndView, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);
           UpdateWindow(_hwndView);
           _OnMoveWindowToTop(_hwndView);
        }

        if (uState == SVUIA_ACTIVATE_NOFOCUS)
        {
            // we lost focus
            // if in web view and we have valid ole obj (just being paranoid)
            if (!_fCombinedView && _cFrame.IsWebView() && _cFrame._pOleObj)
            {
                _cFrame._UIActivateIO(FALSE, NULL);
            }
        }

        // We may be waiting for ReadyState_Interactive. If requested,
        // we should activate before then...
        //
        // When we boot, the desktop paints ugly white screen for several
        // seconds before it shows the HTML content. This is because: the
        // following code switches the oleobj even before it reaches readystate
        // interactive. For desktop, we skip this here. When the new object
        // reaches readystate interactive, we will show it!
        if (!_IsDesktop())
        {
            _cFrame._SwitchToNewOleObj();

            // NOTE: The browser IP/UI-activates us when we become the
            // current active view!  We want to resize and show windows
            // at that time.  But if we're still waiting for _fCanActivateNow
            // (ie, ReadyStateInteractive), then we need to cache this request
            // and do it later.  NOTE: if Trident caches the focus (done w/ TAB)
            // then we don't need to do anything here...
            //
            if (uState == SVUIA_ACTIVATE_FOCUS)
            {
                _SetFocus();
                // _SetFocus can set _uState without causing our menu to
                // get created and merged.  Clear it here so that OnActivate does the
                // right thing.
                if (!_hmenuCur)
                    _uState = SVUIA_DEACTIVATE;
            }

        }
        // else we are the desktop; do we also need to steal focus?
        else if (uState == SVUIA_ACTIVATE_FOCUS)
        {
            HWND hwnd = GetFocus();
            if (SHIsChildOrSelf(_hwndView, hwnd) != S_OK)
                _SetFocus();
        }

        // OnActivate must follow _SetFocus
        OnActivate(uState);

        ShowHideListView();

        ASSERT(_IsDesktop() || _hmenuCur);

        _cFrame._UpdateZonesStatusPane(NULL);
    }

    return S_OK;
}

STDMETHODIMP CDefView::GetCurrentInfo(LPFOLDERSETTINGS pfs)
{
    *pfs = _fs;
    return S_OK;
}

BOOL IsBackSpace(const MSG *pMsg)
{
    return pMsg && (pMsg->message == WM_KEYDOWN) && (pMsg->wParam == VK_BACK);
}

extern int IsVK_TABCycler(MSG *pMsg);

//***
// NOTES
//  try ListView->TA first
//  then if that fails try WebView->TA iff it has focus.
//  then if that fails and it's a TAB we do WebView->UIAct
STDMETHODIMP CDefView::TranslateAccelerator(LPMSG pmsg)
{
    // 1st, try ListView
    if (_fInLabelEdit)
    {
        // the second clause stops us passing mouse key clicks to the toolbar if we are in label edit mode...
        if (WM_KEYDOWN == pmsg->message || WM_KEYUP == pmsg->message)
        {
            // process this msg so the exploer does not get to translate
            TranslateMessage(pmsg);
            DispatchMessage(pmsg);
            return S_OK;            // we handled it
        }
        else
            return S_FALSE;
    }
    // If we are in classic mode and if it's a tab and the listview doesn't have focus already, receive the tab.
    else if (IsVK_TABCycler(pmsg) && !(_cFrame.IsWebView() || _pDUIView) && (GetFocus() != _hwndListview))
    {
        _SetFocus();
        return S_OK;
    }

    if (GetFocus() == _hwndListview)
    {
        if (::TranslateAccelerator(_hwndView, _hAccel, pmsg))
        {
            // we know we have a normal view, therefore this is
            // the right translate accelerator to use, otherwise the
            // common dialogs will fail to get any accelerated keys.
            return S_OK;
        }
        else if (WM_KEYDOWN == pmsg->message || WM_SYSKEYDOWN == pmsg->message)
        {
            // MSHTML eats these keys for frameset scrolling, but we
            // want to get them to our wndproc . . . translate 'em ourself
            //
            switch (pmsg->wParam)
            {
            case VK_LEFT:
            case VK_RIGHT:
                // only go through here if alt is not down.
                // don't intercept all alt combinations because
                // alt-enter means something
                // this is for alt-left/right compat with IE
                if (GetAsyncKeyState(VK_MENU) < 0)
                    break;
                // fall through

            case VK_UP:
            case VK_DOWN:
            case VK_HOME:
            case VK_END:
            case VK_PRIOR:
            case VK_NEXT:
            case VK_RETURN:
            case VK_F10:
                TranslateMessage(pmsg);
                DispatchMessage(pmsg);
                return S_OK;
            }
        }
    }

    // 1.5th, before we pass it down, see whether shell browser handles it.
    // we do this to make sure that webview has the same accelerator semantics
    // no matter what view(s) are active.
    // note that this is arguably inconsistent w/ the 'pass it to whoever has
    // focus'.
    //
    // however *don't* do this if:
    //   - we're in a dialog (in which case the buttons should come 1st)
    //   (comdlg's shellbrowser xxx::TA impl is broken it always does S_OK)
    //   - it's a TAB (which is always checked last)
    //   - it's a BACKSPACE (we should give the currently active object the first chance).
    //    However, in this case, we should call TranslateAcceleratorSB() AFTER we've tried
    //    calling TranslateAccelerator() on the currently active control (_pActive) in
    //    _cFrame->OnTranslateAccelerator().
    //
    // note: if you muck w/ this code careful not to regress the following:
    //  - ie41:62140: mnemonics broken after folder selected in organize favs
    //  - ie41:62419: TAB activates addr and menu if folder selected in explorer
    if (!_IsCommonDialog() && !IsVK_TABCycler(pmsg) && !IsBackSpace(pmsg))
        if (S_OK == _psb->TranslateAcceleratorSB(pmsg, 0))
            return S_OK;

    BOOL bTabOffLastTridentStop = FALSE;
    BOOL bHadIOFocus = (_cFrame._HasFocusIO() == S_OK);  // Cache this here before the _cFrame.OnTA() call below
    // 2nd, try WebView if it's active
    if (IsVK_TABCycler(pmsg) && _pDUIView)
    {
        if (_pDUIView->Navigate(GetAsyncKeyState(VK_SHIFT) >= 0))
            return S_OK;
    }

    if (_cFrame.IsWebView() && (S_OK == _cFrame.OnTranslateAccelerator(pmsg, &bTabOffLastTridentStop)))
    {
        return S_OK;
    }

    // We've given _pActive->TranslateAccelerator() the first shot in
    // _cFrame.OnTranslateAccelerator, but it failed. Let's try the shell browser.
    if (IsBackSpace(pmsg) && (S_OK == _psb->TranslateAcceleratorSB(pmsg, 0)))
        return S_OK;

    // 3rd, ???
    if (::TranslateAccelerator(_hwndView, _hAccel, pmsg))
        return S_OK;

    // 4th, if it's a TAB, cycle to next guy
    // hack: we fake a bunch of the TAB-activation handshaking
    if (IsVK_TABCycler(pmsg) && _cFrame.IsWebView())
    {
        HRESULT hr;
        BOOL fBack = (GetAsyncKeyState(VK_SHIFT) < 0);

        if (!bHadIOFocus && bTabOffLastTridentStop)
        {
            // We were at the last tab stop in trident when the browser called defview->TA().
            // When we called TA() on trident above, it must've told us that we are tabbing
            // off the last tab stop (bTabOffLastTridentStop). This will leave us not setting focus
            // on anything. But, we have to set focus to something. We can do this by calling TA()
            // on trident again, which will set focus on the first tab stop again.
            return _cFrame.OnTranslateAccelerator(pmsg, &bTabOffLastTridentStop);
        }
        else if (_cFrame._HasFocusIO() == S_OK)
        {
            // ExtView has focus, and doesn't want the TAB.
            // this means we're TABing off of it.
            // no matter what, deactivate it (since we're TABing off).
            // if the view is next in the TAB order, (pseudo-)activate it,
            // and return S_OK since we've handled it.
            // o.w. return S_OK so our parent will activate whoever's next
            // in the TAB order.
            hr = _cFrame._UIActivateIO(FALSE, NULL);
            ASSERT(hr == S_OK);

            // in web view listview already has focus so don't give it again
            // that's not the case with desktop
            if (fBack && _IsDesktop())
            {
                SetFocus(_hwndListview);
                return S_OK;
            }

            return S_FALSE;
        }
        else
        {
            if (!fBack)
            {
                hr = _cFrame._UIActivateIO(TRUE, pmsg);
                ASSERT(hr == S_OK || hr == S_FALSE);
                return hr;
            }
        }
    }

    return S_FALSE;
}

// Description:
//  Regenerates the CDefView's menus.  Used for regaining any menu items
//  which may have been stripped via DeleteMenu(), as occurs for various
//  particular view states.
//
//  Example:  Transitioning to a barricaded view automatically strips out
//  a number of commands from the "View" menu which are not appropriate
//  for the barricaded view.  Thus, on the transition back out of the
//  barricaded view, the menus must be recreated in order to regain
//  any/all the menu items stripped (this is not to say a number of
//  them may not be stripped again if we're just transitioning to
//  another view which doesn't want them in there!).
//
void CDefView::RecreateMenus()
{
    UINT uState = _uState;
    _SetUpMenus(uState);    // Note _SetupMenus() calls OnDeactivate()
    _uState = uState;       // which sets _uState to SVUIA_DEACTIVATE.
}

void CDefView::InitViewMenu(HMENU hmInit)
{
    // Initialize view menu accordingly...
    if (_fBarrierDisplayed)
        _InitViewMenuWhenBarrierDisplayed(hmInit);
    else
        _InitViewMenuWhenBarrierNotDisplayed(hmInit);

    // Remove any extraneous menu separators arising from initialization.
    _SHPrettyMenu(hmInit);
}


// Description:
//  Used to initialize the entries of the "View" menu and its associated
//  submenus whenever a soft barrier is being displayed.
//
// Note:
//  This method is also employed when "Category View" is being used in
//  browsing the Control Panel.
//
void CDefView::_InitViewMenuWhenBarrierDisplayed(HMENU hmenuView)
{
    // If "list view" is not visible (i.e. we're in Category View in the
    // Control Panel, or we're looking at a barricaded folder), we strip
    // out the following stuff from the View menu:
    //
    // Filmstrip
    // Thumbnails
    // Tiles
    // Icons
    // List
    // Details
    // -------------------
    // Arrange Icons By ->
    // -------------------
    // Choose Details...
    // Customize This Folder...

    // Remove menu entries.
    DeleteMenu(hmenuView, SFVIDM_VIEW_THUMBSTRIP,   MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_THUMBNAIL,    MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_TILE,         MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_ICON,         MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_LIST,         MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_DETAILS,      MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_MENU_ARRANGE,      MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_COLSETTINGS,  MF_BYCOMMAND);
    DeleteMenu(hmenuView, SFVIDM_VIEW_CUSTOMWIZARD, MF_BYCOMMAND);
}

// Description:
//  Used to initialize the entries of the "View" menu and its associated
//  submenus whenever a soft barrier is not being displayed.
//
void CDefView::_InitViewMenuWhenBarrierNotDisplayed(HMENU hmenuView)
{
    DWORD dwListViewFlags = ListView_GetExtendedListViewStyle(_hwndListview);

    UINT uEnabled   = (MF_ENABLED | MF_BYCOMMAND);
    UINT uDisabled  = (MF_GRAYED | MF_BYCOMMAND);
    UINT uChecked   = (MF_CHECKED | MF_BYCOMMAND);
    UINT uUnchecked = (MF_UNCHECKED | MF_BYCOMMAND);

    UINT uAAEnable;     // Auto Arrange
    UINT uAACheck;
    UINT uAGrEnable;    // Align to Grid
    UINT uAGrCheck;

    // Initialize "view" menu entries.
    _InitViewMenuViewsWhenBarrierNotDisplayed(hmenuView);

    // Initialize "Arrange Icons By ->" submenu.
    _InitArrangeMenu(hmenuView);

    // Determine and set appropriate enable state for "Auto Arrange" and "Align to Grid".
    if (_IsPositionedView() && _IsListviewVisible() && !(_fs.ViewMode == FVM_THUMBSTRIP))
        uAAEnable = uAGrEnable = uEnabled;
    else
        uAAEnable = uAGrEnable = uDisabled;
    EnableMenuItem(hmenuView, SFVIDM_ARRANGE_AUTO,      uAAEnable);
    EnableMenuItem(hmenuView, SFVIDM_ARRANGE_AUTOGRID,  uAGrEnable);

    // Determine and set appropriate check state for "Auto Arrange" and "Align to Grid".
    uAACheck = (((uAAEnable == uEnabled) || _fGroupView || (_fs.ViewMode == FVM_THUMBSTRIP)) && _IsAutoArrange())
        ? uChecked
        : uUnchecked;
    uAGrCheck = (((uAGrEnable == uEnabled) || _fGroupView) && (dwListViewFlags & LVS_EX_SNAPTOGRID))
        ? uChecked
        : uUnchecked;
    CheckMenuItem(hmenuView, SFVIDM_ARRANGE_AUTO,       uAACheck);
    CheckMenuItem(hmenuView, SFVIDM_ARRANGE_AUTOGRID,   uAGrCheck);

    // If icons are not being shown (such as can be set on the
    // desktop), disable ALL icon-arrangement related commands.
    if (!_IsListviewVisible())
    {
        HMENU hArrangeSubMenu;
        UINT uID;
        int i = 0;

        // Retrieve "Arrange Icons By ->" submenu.
        hArrangeSubMenu = GetSubMenu(hmenuView, 2);

        // Iterate and disable until we get to "Show Icons".
        while (1)
        {
            uID = GetMenuItemID(hArrangeSubMenu, i);

            if ((uID == SFVIDM_DESKTOPHTML_ICONS) || (uID == (UINT)-1))
                break;
            else
                EnableMenuItem(hArrangeSubMenu, i, MF_GRAYED | MF_BYPOSITION);

            i++;
        }
    }
    else if (!_ShouldShowWebView())
    {
        // If Web View is off, then thumbstrip will never work...
        DeleteMenu(hmenuView, SFVIDM_VIEW_THUMBSTRIP, MF_BYCOMMAND);
    }

    // Remove "Customize This Folder..." if folder is not customizable.
    if (!_CachedIsCustomizable())
    {
        // The Folder Option "Classic style" and the shell restriction WIN95CLASSIC
        // should be the same. (Per ChristoB, otherwise admin's never understand what
        // the restriction means.) Since we want this to change DEFAULTs, and still
        // allow the user to turn on Web View, we don't remove the customize wizard here.
        int iIndex = MenuIndexFromID(hmenuView, SFVIDM_VIEW_CUSTOMWIZARD);
        if (iIndex != -1)
        {
            DeleteMenu(hmenuView, iIndex + 1, MF_BYPOSITION); // Remove Menu seperator
            DeleteMenu(hmenuView, iIndex,     MF_BYPOSITION); // Remove Customize
        }
    }
}

// Description:
//  Initializes the "view" entries on a view menu.  This involves stripping
//  out any "view" entries for unsupported views, and additionally checking
//  of the appropriate "view" entry for the current view.
//
// Note:
//  This method should not be called if a soft barrier is being displayed.
//  Remember that in this case there is no concept of a view, so why
//  would someone be attempting to initialize "view" menu entries.
//
void CDefView::_InitViewMenuViewsWhenBarrierNotDisplayed(HMENU hmenuView)
{
    ASSERT(!_fBarrierDisplayed);

    // Remove menu entries for unsupported views.
    for (UINT fvm = FVM_FIRST; fvm <= FVM_LAST; fvm++)
        if (!_ViewSupported(fvm))
            DeleteMenu(hmenuView, SFVIDM_VIEW_FIRSTVIEW + fvm - FVM_FIRST, MF_BYCOMMAND);

    // "Check" menu entry for current view.
    CheckCurrentViewMenuItem(hmenuView);
}

void CDefView::_GetCBText(UINT_PTR id, UINT uMsgT, UINT uMsgA, UINT uMsgW, LPTSTR psz, UINT cch)
{
    *psz = 0;

    WCHAR szW[MAX_PATH];
    if (SUCCEEDED(CallCB(uMsgW, MAKEWPARAM(id - SFVIDM_CLIENT_FIRST, ARRAYSIZE(szW)), (LPARAM)szW)))
        SHUnicodeToTChar(szW, psz, cch);
    else
    {
        char szA[MAX_PATH];
        if (SUCCEEDED(CallCB(uMsgA, MAKEWPARAM(id - SFVIDM_CLIENT_FIRST, ARRAYSIZE(szA)), (LPARAM)szA)))
            SHAnsiToTChar(szA, psz, cch);
        else
            CallCB(uMsgT, MAKEWPARAM(id - SFVIDM_CLIENT_FIRST, cch), (LPARAM)psz);
    }
}

void CDefView::_GetMenuHelpText(UINT_PTR id, LPTSTR pszText, UINT cchText)
{
    *pszText = 0;

    if ((InRange(id, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST) && _pcmFile) ||
        (InRange(id, SFVIDM_BACK_CONTEXT_FIRST, SFVIDM_BACK_CONTEXT_LAST) && _pcmContextMenuPopup))
    {
        UINT uCMBias = SFVIDM_CONTEXT_FIRST;
        IContextMenu *pcmSel = NULL;

        if (InRange(id, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST))
        {
            pcmSel = _pcmFile;
            uCMBias = SFVIDM_CONTEXT_FIRST;
        }
        else if (InRange(id, SFVIDM_BACK_CONTEXT_FIRST, SFVIDM_BACK_CONTEXT_LAST))
        {
            pcmSel = _pcmContextMenuPopup;
            uCMBias = SFVIDM_BACK_CONTEXT_FIRST;
        }

        // First try to get the stardard help string
        pcmSel->GetCommandString(id - uCMBias, GCS_HELPTEXT, NULL,
                        (LPSTR)pszText, cchText);
        if (*pszText == 0)
        {
            // If we didn't get anything, try to grab the ansi version
            CHAR szText[MAX_PATH];
            szText[0] = 0;   // Don't start with garbage in case of failure...
            pcmSel->GetCommandString(id - uCMBias, GCS_HELPTEXTA, NULL,
                        szText, ARRAYSIZE(szText));
            SHAnsiToUnicode(szText, pszText, cchText);
        }
    }
    else if (InRange(id, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST) && HasCB())
    {
        _GetCBText(id, SFVM_GETHELPTEXT, SFVM_GETHELPTEXTA, SFVM_GETHELPTEXTW, pszText, cchText);
    }
    else if (InRange(id, SFVIDM_GROUPSFIRST, SFVIDM_GROUPSLAST))
    {
        TCHAR sz[MAX_PATH];
        int idHelp = _fGroupView?IDS_GROUPBY_HELPTEXT:IDS_ARRANGEBY_HELPTEXT;

        LoadString(HINST_THISDLL, idHelp, sz, ARRAYSIZE(sz));
        wnsprintf(pszText, cchText, sz, _vs.GetColumnName((UINT)id - SFVIDM_GROUPSFIRST));
    }
    else if (InRange(id, SFVIDM_GROUPSEXTENDEDFIRST, SFVIDM_GROUPSEXTENDEDLAST))
    {
        // Can't think of anything descriptive
    }
    else if (InRange(id, SFVIDM_FIRST, SFVIDM_LAST))
    {
        if ((id == SFVIDM_EDIT_UNDO) && IsUndoAvailable())
        {
            GetUndoText(pszText, cchText, UNDO_STATUSTEXT);
        }
        else
        {
            UINT idHelp = (UINT)id + SFVIDS_MH_FIRST;
            // Unfortunatly, this starts to hit other ranges, so I'm just hard coding this one instead of
            // using the table. If you add more, we need another table method of associating ids and help strings
            if (id == SFVIDM_GROUPBY)
                idHelp = IDS_GROUPBYITEM_HELPTEXT;
            LoadString(HINST_THISDLL, idHelp, pszText, cchText);
        }
    }
}

void CDefView::_GetToolTipText(UINT_PTR id, LPTSTR pszText, UINT cchText)
{
    *pszText = 0;

    if (InRange(id, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST) && HasCB())
    {
        _GetCBText(id, SFVM_GETTOOLTIPTEXT, SFVM_GETTOOLTIPTEXTA, SFVM_GETTOOLTIPTEXTW, pszText, cchText);
    }
    else if (InRange(id, SFVIDM_FIRST, SFVIDM_LAST))
    {
        if (id == SFVIDM_EDIT_UNDO)
        {
            if (IsUndoAvailable())
            {
                GetUndoText(pszText, cchText, UNDO_MENUTEXT);
                return;
            }
        }
        LoadString(HINST_THISDLL, (UINT)(IDS_TT_SFVIDM_FIRST + id), pszText, cchText);
    }
    else
    {
        // REVIEW: This might be an assert situation: missing tooltip info...
        TraceMsg(TF_WARNING, "_GetToolTipText: tip request for unknown object");
    }
}

LRESULT CDefView::_OnMenuSelect(UINT id, UINT mf, HMENU hmenu)
{
    TCHAR szHelpText[80 + 2*MAX_PATH];   // Lots of stack!

    // If we dismissed the edit restore our status bar...
    if (!hmenu && LOWORD(mf)==0xffff)
    {
        _psb->SendControlMsg(FCW_STATUS, SB_SIMPLE, 0, 0, NULL);
        return 0;
    }

    if (mf & (MF_SYSMENU | MF_SEPARATOR))
        return 0;

    szHelpText[0] = 0;   // in case of failures below

    if (mf & MF_POPUP)
    {
        MENUITEMINFO miiSubMenu;

        miiSubMenu.cbSize = sizeof(MENUITEMINFO);
        miiSubMenu.fMask = MIIM_ID;
        miiSubMenu.cch = 0;     // just in case

        if (!GetMenuItemInfo(hmenu, id, TRUE, &miiSubMenu))
            return 0;

        // Change the parameters to simulate a "normal" menu item
        id = miiSubMenu.wID;
        mf &= ~MF_POPUP;
    }

    _GetMenuHelpText(id, szHelpText, ARRAYSIZE(szHelpText));
    _fBackgroundStatusTextValid = FALSE;
    _psb->SendControlMsg(FCW_STATUS, SB_SETTEXT, SBT_NOBORDERS | 255, (LPARAM)szHelpText, NULL);
    _psb->SendControlMsg(FCW_STATUS, SB_SIMPLE, 1, 0, NULL);

    return 0;
}

//
// This function dismisses the name edit mode if there is any.
//
// REVIEW: Moving the focus away from the edit window will
//  dismiss the name edit mode. Should we introduce
//  a LV_DISMISSEDIT instead?
//
void CDefView::_DismissEdit()
{
    if (_uState == SVUIA_ACTIVATE_FOCUS)
    {
        ListView_CancelEditLabel(_hwndListview);
    }
}

void CDefView::_OnInitMenu()
{
    // We need to dismiss the edit mode if it is any.
    _DismissEdit();
}

void _RemoveContextMenuItems(HMENU hmInit)
{
    int i;

    for (i = GetMenuItemCount(hmInit) - 1; i >= 0; --i)
    {
        MENUITEMINFO mii;
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID | MIIM_ID;
        mii.cch = 0;     // just in case

        if (GetMenuItemInfo(hmInit, i, TRUE, &mii))
        {
            if (InRange(mii.wID, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST))
            {
                TraceMsg(TF_DEFVIEW, "_RemoveContextMenuItems: setting bDeleteItems at %d, %d", i, mii.wID);
                //bDeleteItems = TRUE;
                DeleteMenu(hmInit, i, MF_BYPOSITION);
            }
        }
    }
}

BOOL HasClientItems(HMENU hmenu)
{
    int cItems = GetMenuItemCount(hmenu);
    for (int i = 0; i < cItems; i++)
    {
        UINT id = GetMenuItemID(hmenu, i);

        if (InRange(id, SFVIDM_CLIENT_FIRST, SFVIDM_CLIENT_LAST))
            return TRUE;
    }
    return FALSE;
}

LRESULT CDefView::_OnInitMenuPopup(HMENU hmInit, int nIndex, BOOL fSystemMenu)
{
    if (_hmenuCur)
    {
        // This old code makes sure we only switch on the wID for one of our top-level windows
        // The id shouldn't be re-used, so this probably isn't needed.  But it doesn't hurt...
        //
        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_SUBMENU | MIIM_ID;
        if (GetMenuItemInfo(_hmenuCur, nIndex, TRUE, &mii) &&  mii.hSubMenu == hmInit)
        {
            switch (mii.wID)
            {
            case FCIDM_MENU_FILE:
                // PERF note: we could avoid the rip-down-and-re-build our File menu
                // if we have a _pcmFile and the _uState is the same as last
                // time and the selection is identical to last time.

                // First of all, clean up our last _pcmFile usage:
                //  remove all the menu items we've added
                //  remove the named separators for defcm
                _RemoveContextMenuItems(hmInit);
                SHUnprepareMenuForDefcm(hmInit, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST);
                IUnknown_SetSite(_pcmFile, NULL);
                ATOMICRELEASE(_pcmFile);

                // Second, handle the focus/nofocus menus
                if (_uState == SVUIA_ACTIVATE_FOCUS)
                {
                    // Enable/disable our menuitems in the "File" pulldown.
                    Def_InitFileCommands(_AttributesFromSel(SFGAO_CANRENAME | SFGAO_CANDELETE | SFGAO_CANLINK | SFGAO_HASPROPSHEET),
                        hmInit, SFVIDM_FIRST, FALSE);

                    // Collect our new _pcmFile context menu
                    IContextMenu* pcmSel = NULL;
                    _CreateSelectionContextMenu(IID_PPV_ARG(IContextMenu, &pcmSel));

                    IContextMenu* pcmBack = NULL;
                    _pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IContextMenu, &pcmBack));

                    IContextMenu* rgpcm[] = { pcmSel, pcmBack };
                    Create_ContextMenuOnContextMenuArray(rgpcm, ARRAYSIZE(rgpcm), IID_PPV_ARG(IContextMenu, &_pcmFile));

                    if (pcmSel)
                        pcmSel->Release();

                    if (pcmBack)
                        pcmBack->Release();
                }
                else if (_uState == SVUIA_ACTIVATE_NOFOCUS)
                {
                    _pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IContextMenu, &_pcmFile));
                }

                // Third, merge in the context menu items
                {
                    HRESULT hrPrepare = SHPrepareMenuForDefcm(hmInit, 0, 0, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST);
                    if (_pcmFile)
                    {
                        IUnknown_SetSite(_pcmFile, SAFECAST(this, IShellView2*));
                        _pcmFile->QueryContextMenu(hmInit, 0, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST, CMF_DVFILE | CMF_NODEFAULT);
                    }
                    SHPrettyMenuForDefcm(hmInit, 0, SFVIDM_CONTEXT_FIRST, SFVIDM_CONTEXT_LAST, hrPrepare);
                }
                break;

            case FCIDM_MENU_EDIT:
                // Enable/disable menuitems in the "Edit" pulldown.
                Def_InitEditCommands(_AttributesFromSel(SFGAO_CANCOPY | SFGAO_CANMOVE), hmInit, SFVIDM_FIRST, _pdtgtBack, 0);
                _SHPrettyMenu(hmInit);
                break;

            case FCIDM_MENU_VIEW:
                InitViewMenu(hmInit);
                break;
            }
        }
    }

    // Check for a context menu's popup:
    //   assume the first item in the menu identifies the range
    BOOL fHandled;
    _ForwardMenuMessages(GetMenuItemID(hmInit, 0), WM_INITMENUPOPUP, (WPARAM)hmInit, MAKELPARAM(nIndex, fSystemMenu), NULL, &fHandled);

    // Maybe this is the callback's menu then?
    if (!fHandled && _hmenuCur && HasCB() && HasClientItems(hmInit))
    {
        CallCB(SFVM_INITMENUPOPUP, MAKEWPARAM(SFVIDM_CLIENT_FIRST, nIndex), (LPARAM)hmInit);
    }

    return 0;
}

// IShellView::AddPropertySheetPages
STDMETHODIMP CDefView::AddPropertySheetPages(DWORD dwRes, LPFNADDPROPSHEETPAGE lpfn, LPARAM lParam)
{
    SFVM_PROPPAGE_DATA data;

    ASSERT(IS_VALID_CODE_PTR(lpfn, FNADDPROPSHEETPAGE));

    data.dwReserved = dwRes;
    data.pfn        = lpfn;
    data.lParam     = lParam;

    // Call the callback to add pages
    CallCB(SFVM_ADDPROPERTYPAGES, 0, (LPARAM)&data);

    return S_OK;
}

STDMETHODIMP CDefView::SaveViewState()
{
    HRESULT hr;

    IPropertyBag* ppb;
    hr = IUnknown_QueryServicePropertyBag(_psb, SHGVSPB_FOLDER, IID_PPV_ARG(IPropertyBag, &ppb));

    if (SUCCEEDED(hr))
    {
        hr = _vs.SaveToPropertyBag(this, ppb);
        ppb->Release();
    }
    else
    {
        IStream *pstm;
        hr = _psb->GetViewStateStream(STGM_WRITE, &pstm);
        if (SUCCEEDED(hr))
        {
            hr = _vs.SaveToStream(this, pstm);
            pstm->Release();
        }
        else
        {
            // There are cases where we may not save out the complete view state
            // but we do want to save out the column information (like Docfind...)
            if (SUCCEEDED(CallCB(SFVM_GETCOLSAVESTREAM, STGM_READ, (LPARAM)&pstm)))
            {
                hr = _vs.SaveColumns(this, pstm);
                pstm->Release();
            }
        }
    }
    return hr;
}

//  99/02/05 #226140 vtan: Function used to get the storage
//  stream for the default view state of the current DefView.
//  Typically this will be CLSID_ShellFSFolder but can be
//  others.
HRESULT CDefView::_GetStorageStream (DWORD grfMode, IStream* *ppIStream)
{
    *ppIStream = NULL;

    CLSID clsid;
    HRESULT hr = IUnknown_GetClassID(_pshf, &clsid);
    if (SUCCEEDED(hr))
    {
        TCHAR szCLSID[64];      // enough for the CLSID

        if (IsEqualGUID(CLSID_MyDocuments, clsid))
            clsid = CLSID_ShellFSFolder;

        TINT(SHStringFromGUID(clsid, szCLSID, ARRAYSIZE(szCLSID)));
        *ppIStream = OpenRegStream(HKEY_CURRENT_USER,
                                   REGSTR_PATH_EXPLORER TEXT("\\Streams\\Defaults"), szCLSID, grfMode);
        if (*ppIStream == NULL)
            hr = E_FAIL;
    }
    return hr;
}

//  99/02/05 #226140 vtan: Function called from DefView's
//  implementation of IOleCommandTarget::Exec() which is
//  invoked from CShellBrowser2::SetAsDefFolderSettings().
HRESULT CDefView::_SaveGlobalViewState(void)
{
    IStream *pstm;
    HRESULT hr = _GetStorageStream(STGM_WRITE, &pstm);
    if (SUCCEEDED(hr))
    {
        hr = _vs.SaveToStream(this, pstm);
        if (SUCCEEDED(hr))
        {
            hr = (ERROR_SUCCESS == SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\ShellNoRoam\\Bags"))) ? S_OK : E_FAIL;
        }
        pstm->Release();
    }
    return hr;
}

//  99/02/05 #226140 vtan: Function called from
//  GetViewState to get the default view state
//  for this class.
HRESULT CDefView::_LoadGlobalViewState(IStream* *ppIStream)
{
    return _GetStorageStream(STGM_READ, ppIStream);
}

//  99/02/09 #226140 vtan: Function used to reset the
//  global view states stored by deleting the key
//  that stores all of them.
HRESULT CDefView::_ResetGlobalViewState(void)
{
    SHDeleteKey(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\Streams\\Defaults"));

    LONG lRetVal = SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\ShellNoRoam\\Bags"));
    return (ERROR_SUCCESS == lRetVal) ? S_OK : E_FAIL;
}

void CDefView::_RestoreAllGhostedFileView()
{
   ListView_SetItemState(_hwndListview, -1, 0, LVIS_CUT);

   UINT c = ListView_GetItemCount(_hwndListview);
   for (UINT i = 0; i < c; i++)
   {
       if (_Attributes(_GetPIDL(i), SFGAO_GHOSTED))
           ListView_SetItemState(_hwndListview, i, LVIS_CUT, LVIS_CUT);
   }
}

HRESULT CDefView::SelectAndPositionItem(LPCITEMIDLIST pidlItem, UINT uFlags, POINT *ppt)
{
    HRESULT hr;

    if (NULL == pidlItem)
        hr = _SelectAndPosition(-1, uFlags, ppt);
    else if (ILFindLastID(pidlItem) == pidlItem)
    {
        if (_fInBackgroundGrouping)
        {
            Pidl_Set(&_pidlSelectAndPosition, pidlItem);
            _uSelectAndPositionFlags = uFlags;
            hr = S_OK;
        }
        else
        {
            int iItem = _FindItem(pidlItem, NULL, FALSE);
            if (iItem != -1)
                hr = _SelectAndPosition(iItem, uFlags, ppt);
            else
                hr = S_OK;
        }
    }
    else
    {
        RIP(ILFindLastID(pidlItem) == pidlItem);
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CDefView::_SelectAndPosition(int iItem, UINT uFlags, POINT *ppt)
{
    HRESULT hr = S_OK;  // assume all is good

    // See if we should first deselect everything else
    if (-1 == iItem)
    {
        if (uFlags == SVSI_DESELECTOTHERS)
        {
            ListView_SetItemState(_hwndListview, -1, 0, LVIS_SELECTED);
            _RestoreAllGhostedFileView();
        }
        else
        {
            hr = E_INVALIDARG;  // I only know how to deselect everything
        }
    }
    else
    {
        if (_pDUIView)
        {
            _fBarrierDisplayed = FALSE;
            _pDUIView->EnableBarrier(FALSE);
        }

        if (uFlags & SVSI_TRANSLATEPT)
        {
            //The caller is asking us to take this point and convert it from screen Coords
            // to the Client of the Listview.

            LVUtil_ScreenToLV(_hwndListview, ppt);
        }

        // set the position first so that the ensure visible scrolls to
        // the new position
        if (ppt)
        {
            _SetItemPosition(iItem, ppt->x, ppt->y);
        }
        else if ((SVSI_POSITIONITEM & uFlags) && _bMouseMenu && _IsPositionedView())
        {
            _SetItemPosition(iItem, _ptDragAnchor.x, _ptDragAnchor.y);
        }

        if ((uFlags & SVSI_EDIT) == SVSI_EDIT)
        {
            // Grab focus if the listview (or any of it's children) don't already have focus
            HWND hwndFocus = GetFocus();
            if (SHIsChildOrSelf(_hwndListview, hwndFocus) != S_OK)
                SetFocus(_hwndListview);

            ListView_EditLabel(_hwndListview, iItem);
        }
        else
        {
            // change the item state
            if (!(uFlags & SVSI_NOSTATECHANGE))
            {
                UINT stateMask = LVIS_SELECTED;
                UINT state = (uFlags & SVSI_SELECT) ? LVIS_SELECTED : 0;
                if (uFlags & SVSI_FOCUSED)
                {
                    state |= LVIS_FOCUSED;
                    stateMask |= LVIS_FOCUSED;
                }

                // See if we should first deselect everything else
                if (uFlags & SVSI_DESELECTOTHERS)
                {
                    ListView_SetItemState(_hwndListview, -1, 0, LVIS_SELECTED);
                    _RestoreAllGhostedFileView();
                }

                ListView_SetItemState(_hwndListview, iItem, state, stateMask);
            }

            if (uFlags & SVSI_ENSUREVISIBLE)
                ListView_EnsureVisible(_hwndListview, iItem, FALSE);

            // we should only set focus when SVUIA_ACTIVATE_FOCUS
            // bug fixing that might break find target code
            if (uFlags & SVSI_FOCUSED)
                SetFocus(_hwndListview);

            if (uFlags & SVSI_SELECTIONMARK)
                ListView_SetSelectionMark(_hwndListview, iItem);

            // if this is a check select view then set the state of that item accordingly
            if (_fs.fFlags & FWF_CHECKSELECT)
                ListView_SetCheckState(_hwndListview, iItem, (uFlags & SVSI_CHECK));
        }
    }
    return hr;
}

STDMETHODIMP CDefView::SelectItem(int iItem, DWORD uFlags)
{
    return _SelectAndPosition(iItem, uFlags, NULL);
}

typedef struct {
    LPITEMIDLIST    pidl;
    UINT            uFlagsSelect;
} DELAY_SEL_ITEM;

STDMETHODIMP CDefView::SelectItem(LPCITEMIDLIST pidlItem, UINT uFlags)
{
    // if the listview isn't shown, there's nothing to select yet.
    // Likewise if we are in the process of being created we should defer.
    if (!_IsListviewVisible())
    {
        if (!_hdsaSelect)
        {
            _hdsaSelect = DSA_Create(sizeof(DELAY_SEL_ITEM), 4);
            if (!_hdsaSelect)
                return E_OUTOFMEMORY;
        }

        HRESULT hr = E_OUTOFMEMORY;
        DELAY_SEL_ITEM dvdsi;
        dvdsi.pidl = ILClone(pidlItem);
        if (dvdsi.pidl)
        {
            dvdsi.uFlagsSelect = uFlags;
            if (DSA_AppendItem(_hdsaSelect, &dvdsi) == DSA_ERR)
                ILFree(dvdsi.pidl);
            else
                hr = S_OK;
        }
        return hr;
    }

    return SelectAndPositionItem(pidlItem, uFlags, NULL);
}

// IFolderView

STDMETHODIMP CDefView::GetCurrentViewMode(UINT *pViewMode)
{
    *pViewMode = _fs.ViewMode;
    return S_OK;
}

STDMETHODIMP CDefView::SetCurrentViewMode(UINT uViewMode)
{
    ASSERT(FVM_FIRST <= uViewMode && uViewMode <= FVM_LAST);

    if (uViewMode != _vs._ViewMode)
        _ClearItemPositions();

    return _SwitchToViewFVM(uViewMode);
}

STDMETHODIMP CDefView::GetFolder(REFIID riid, void **ppv)
{
    if (_pshf)
        return _pshf->QueryInterface(riid, ppv);

    *ppv = NULL;
    return  E_NOINTERFACE;
}

STDMETHODIMP CDefView::Item(int iItemIndex, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_FAIL;
    LPCITEMIDLIST pidl = _GetPIDL(iItemIndex);
    if (pidl)
    {
        hr = SHILClone(pidl, ppidl);
    }
    return hr;
}

STDMETHODIMP CDefView::ItemCount(UINT uFlags, int *pcItems)
{
    *pcItems = _GetItemArray(NULL, NULL, uFlags);
    return S_OK;
}

HRESULT CDefView::_EnumThings(UINT uWhat, IEnumIDList **ppenum)
{
    *ppenum = NULL;

    LPCITEMIDLIST *apidl;
    UINT cItems;
    HRESULT hr = _GetItemObjects(&apidl, uWhat, &cItems);
    if (SUCCEEDED(hr))
    {
        hr = CreateIEnumIDListOnIDLists(apidl, cItems, ppenum);
        LocalFree(apidl);
    }
    return hr;
}

STDMETHODIMP CDefView::Items(UINT uWhat, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    if (IID_IEnumIDList == riid)
    {
        hr = _EnumThings(uWhat, (IEnumIDList**)ppv); 
    }
    else if (IID_IDataObject == riid)
    {
        if ((uWhat & SVGIO_TYPE_MASK) == SVGIO_SELECTION)
        {
            if (_pSelectionShellItemArray)
            {
                hr = _pSelectionShellItemArray->BindToHandler(NULL, BHID_DataObject, riid, ppv);
            }
        }
        else
        {
            hr = _GetUIObjectFromItem(riid, ppv, uWhat, FALSE);
        }
    }
    return hr;        
}


// inverse of ::SelectItem(..., SVSI_SELECTIONMARK)

STDMETHODIMP CDefView::GetSelectionMarkedItem(int *piItem)
{
    *piItem = ListView_GetSelectionMark(_hwndListview);
    return (-1 == *piItem) ? S_FALSE : S_OK;
}

STDMETHODIMP CDefView::GetFocusedItem(int *piItem)
{
    *piItem = ListView_GetNextItem(_hwndListview, -1, LVNI_FOCUSED);
    return (-1 == *piItem) ? S_FALSE : S_OK;
}

BOOL CDefView::_GetItemPosition(LPCITEMIDLIST pidl, POINT *ppt)
{
    int i = _FindItem(pidl, NULL, FALSE);
    if (i != -1)
        return ListView_GetItemPosition(_hwndListview, i, ppt);
    return FALSE;
}

STDMETHODIMP CDefView::GetItemPosition(LPCITEMIDLIST pidl, POINT *ppt)
{
    return _GetItemPosition(pidl, ppt) ? S_OK : E_FAIL;
}

STDMETHODIMP CDefView::GetSpacing(POINT* ppt)
{
    if (ppt)
    {
        if (_fs.ViewMode != FVM_TILE)
        {
            BOOL fSmall;

            switch (_fs.ViewMode)
            {
            case FVM_SMALLICON:
            case FVM_LIST:
            case FVM_DETAILS:
                fSmall = TRUE;
                break;

            case FVM_ICON:
            case FVM_THUMBNAIL:
            case FVM_THUMBSTRIP:
            default:
                fSmall = FALSE;
                break;
            }

            DWORD dwSize = ListView_GetItemSpacing(_hwndListview, fSmall);
            ppt->x = GET_X_LPARAM(dwSize);
            ppt->y = GET_Y_LPARAM(dwSize);
        }
        else
        {
            LVTILEVIEWINFO tvi;
            tvi.cbSize = sizeof(tvi);
            tvi.dwMask = LVTVIM_TILESIZE;

            if (ListView_GetTileViewInfo(_hwndListview, &tvi))
            {
                ppt->x = tvi.sizeTile.cx;
                ppt->y = tvi.sizeTile.cy;
            }
            else
            {
                // guess.
                ppt->x = 216;
                ppt->y = 56;
            }
        }
    }

    return _IsPositionedView() ? S_OK : S_FALSE;
}

STDMETHODIMP CDefView::GetDefaultSpacing(POINT* ppt)
{
    ASSERT(ppt);

    if (_fs.ViewMode != FVM_THUMBNAIL && _fs.ViewMode != FVM_THUMBSTRIP && _fs.ViewMode != FVM_TILE)
    {
        DWORD dwSize = ListView_GetItemSpacing(_hwndListview, FALSE);
        ppt->x = GET_X_LPARAM(dwSize);
        ppt->y = GET_Y_LPARAM(dwSize);
    }
    else
    {
        // Bug #163528 (edwardp 8/15/00) Should get this data from comctl.
        ppt->x = GetSystemMetrics(SM_CXICONSPACING);
        ppt->y = GetSystemMetrics(SM_CYICONSPACING);
    }

    return S_OK;
}

// IShellFolderView
STDMETHODIMP CDefView::GetAutoArrange()
{
    return _IsAutoArrange() ? S_OK : S_FALSE;
}

void CDefView::_ClearPendingSelectedItems()
{
    if (_hdsaSelect)
    {
        HDSA hdsa = _hdsaSelect;
        _hdsaSelect = NULL;
        int cItems = DSA_GetItemCount(hdsa);
        for (int i = 0; i < cItems; i++)
        {
            DELAY_SEL_ITEM *pdvdsi = (DELAY_SEL_ITEM*)DSA_GetItemPtr(hdsa, i);
            if (pdvdsi)
                ILFree(pdvdsi->pidl);
        }
        DSA_Destroy(hdsa);
    }
}

// Call this whenever the state changes such that SelectItem (above)
void CDefView::SelectPendingSelectedItems()
{
    ASSERT(_IsListviewVisible());
    if (_hdsaSelect)
    {

        //
        //  Listview quirk:  If the following conditions are met..
        //
        //      1. WM_SETREDRAW(FALSE) or ShowWindow(SW_HIDE)
        //      2. Listview has never painted yet
        //      3. LVS_LIST
        //
        //  then ListView_LGetRects doesn't work.  And consequently,
        //  everything that relies on known item rectangles (e.g.,
        //  LVM_ENSUREVISIBLE, sent by below SelectItem call) doesn't work.
        //
        //  (1) ShowHideListView did a ShowWindow(SW_SHOW), but
        //  FillDone does a WM_SETREDRAW(FALSE).
        //  check _fListviewRedraw to see if condition (1) is met
        //
        //  (2) We just showed the listview, if it's the first time,
        //  then Condition (2) has been met
        //
        //  But wait, there's also a listview bug where SetWindowPos
        //  doesn't trigger it into thinking that the window is visible.
        //  So you have to send a manual WM_SHOWWINDOW, too.
        //
        //  So if we detect that condition (3) is also met, we temporarily
        //  enable redraw (thereby cancelling condition 1), tell listview
        //  "No really, you're visible" -- this tickles it into computing
        //  column stuff -- then turn redraw back off.
        //

        if (_fListviewRedraw &&
            (GetWindowStyle(_hwndListview) & LVS_TYPEMASK) == LVS_LIST)
        {
            // Evil hack (fix comctl32.dll v6.0 someday NTRAID#182448)
            SendMessage(_hwndListview, WM_SETREDRAW, (WPARAM)TRUE, 0);
            SendMessage(_hwndListview, WM_SHOWWINDOW, TRUE, 0);
            SendMessage(_hwndListview, WM_SETREDRAW, (WPARAM)FALSE, 0);
        }

        // End of listview hack workaround


        HDSA hdsa = _hdsaSelect;
        _hdsaSelect = NULL;
        int cItems = DSA_GetItemCount(hdsa);
        for (int i = 0; i < cItems; i++)
        {
            DELAY_SEL_ITEM *pdvdsi = (DELAY_SEL_ITEM*)DSA_GetItemPtr(hdsa, i);
            if (pdvdsi)
            {
                SelectItem(pdvdsi->pidl, pdvdsi->uFlagsSelect);
                ILFree(pdvdsi->pidl);
            }
        }
        DSA_Destroy(hdsa);
    }
}

HRESULT CDefView::_GetIPersistHistoryObject(IPersistHistory **ppph)
{
    // See to see if specific folder wants to handle it...
    HRESULT hr = CallCB(SFVM_GETIPERSISTHISTORY, 0, (LPARAM)ppph);
    if (FAILED(hr))
    {
        // Here we can decide if we want to default should be to always save
        // the default defview stuff or not.  For now we will assume that we do
        if (ppph)
        {
            CDefViewPersistHistory *pdvph = new CDefViewPersistHistory();
            if (pdvph)
            {
                hr = pdvph->QueryInterface(IID_PPV_ARG(IPersistHistory, ppph));
                pdvph->Release();
            }
            else
            {
                *ppph = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
        else
            hr = S_FALSE;   // still succeeds but can detect on other side if desired...
    }
    return hr;
}

STDMETHODIMP CDefView::GetItemObject(UINT uWhat, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    switch (uWhat & SVGIO_TYPE_MASK)
    {
    case SVGIO_BACKGROUND:
        if (IsEqualIID(riid, IID_IContextMenu) ||
            IsEqualIID(riid, IID_IContextMenu2) ||
            IsEqualIID(riid, IID_IContextMenu3))
        {
            hr = _CBackgrndMenu_CreateInstance(riid, ppv);
        }
        else if (IsEqualIID(riid, IID_IDispatch) ||
                 IsEqualIID(riid, IID_IDefViewScript))
        {
            if (!_pauto)
            {
                // try to create an Instance of the Shell dispatch for folder views...
                IDispatch *pdisp;
                if (SUCCEEDED(SHExtCoCreateInstance(NULL, &CLSID_ShellFolderView, NULL,
                                                  IID_PPV_ARG(IDispatch, &pdisp))))
                {
                    SetAutomationObject(pdisp); // we hold a ref here
                    ASSERT(_pauto);    // the above grabbed this
                    pdisp->Release();
                }
            }

            // return the IDispath interface.
            if (_pauto)
                hr = _pauto->QueryInterface(riid, ppv);
        }
        else if (IsEqualIID(riid, IID_IPersistHistory))
        {
            // See if the folder wants a chance at this.  The main
            // case for this is the search results windows.
            hr = _GetIPersistHistoryObject((IPersistHistory**)ppv);
            if (SUCCEEDED(hr))
            {
                IUnknown_SetSite((IUnknown*)*ppv, SAFECAST(this, IShellView2*));
            }
        }
        else if (_cFrame.IsWebView() && _cFrame._pOleObj)
        {
            hr = _cFrame._pOleObj->QueryInterface(riid, ppv);
        }
        break;

    case SVGIO_ALLVIEW:
        if (_hwndStatic)
        {
            DECLAREWAITCURSOR;

            SetWaitCursor();

            do
            {
                // If _hwndStatic is around, we must be filling the
                // view in a background thread, so we will peek for
                // messages to it (so SendMessages will get through)
                // and dispatch only _hwndStatic messages so we get the
                // animation effect.
                // Note there is no timeout, so this could take
                // a while on a slow link, but there really isn't
                // much else I can do

                MSG msg;

                // Since _hwndStatic can only be destroyed on a WM_DSV_BACKGROUNDENUMDONE
                // message, we should never get a RIP
                // We also need to allow WM_DSV_FILELISTFILLDONE since it can destroy _hwndStatic
                if (PeekMessage(&msg, _hwndView, WM_DSV_BACKGROUNDENUMDONE,
                                WM_DSV_BACKGROUNDENUMDONE, PM_REMOVE) ||
                    PeekMessage(&msg, _hwndView, WM_DSV_FILELISTFILLDONE,
                                WM_DSV_FILELISTFILLDONE, PM_REMOVE)   ||
                    PeekMessage(&msg, _hwndView, WM_DSV_GROUPINGDONE,
                                WM_DSV_GROUPINGDONE, PM_REMOVE)       ||
                    PeekMessage(&msg, _hwndStatic, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            } while (_hwndStatic);

            ResetWaitCursor();
        }

        // Fall through

    case SVGIO_SELECTION:
        hr = _GetUIObjectFromItem(riid, ppv, uWhat, TRUE);
        break;
    }

    return hr;
}

HRESULT CDefView::PreCreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool)
{
    ASSERT(hwndContaining != NULL);
    ASSERT(_FindPendingInfotip(hwndContaining, uToolID, NULL, FALSE) == S_FALSE);

    PENDING_INFOTIP *ppi = new PENDING_INFOTIP;
    HRESULT hr;
    if (ppi)
    {
        ppi->hwndContaining = hwndContaining;
        ppi->uToolID = uToolID;
        ppi->rectTool = *prectTool;

        if (_tlistPendingInfotips.AddTail(ppi))
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            delete ppi;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CDefView::PostCreateInfotip(HWND hwndContaining, UINT_PTR uToolID, HINSTANCE hinst, UINT_PTR uInfotipID, LPARAM lParam)
{
    ASSERT(hwndContaining != NULL);

    TOOLINFO *pti = new TOOLINFO;
    HRESULT hr;
    if (pti)
    {
        pti->cbSize = sizeof(TOOLINFO);
        pti->uFlags = 0;
        pti->hwnd = hwndContaining;
        pti->uId = uToolID;
      //pti->rect = initialized in _OnPostCreateInfotip()
        pti->hinst = hinst;
        pti->lpszText = (LPWSTR)uInfotipID;
        pti->lParam = lParam;

        hr = PostMessage(_hwndView, WM_DSV_POSTCREATEINFOTIP, (WPARAM)pti, lParam) ? S_OK : E_FAIL;

        if (FAILED(hr))
        {
            delete pti;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CDefView::PostCreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPCWSTR pwszInfotip, LPARAM lParam)
{
    HRESULT hr = SHStrDup(pwszInfotip, (LPWSTR *)&pwszInfotip);
    if (SUCCEEDED(hr))
    {
        hr = PostCreateInfotip(hwndContaining, uToolID, NULL, (UINT_PTR)pwszInfotip, lParam);
        if (FAILED(hr))
        {
            CoTaskMemFree((LPVOID)pwszInfotip);
        }
    }
    return hr;
}

HRESULT CDefView::_OnPostCreateInfotip(TOOLINFO *pti, LPARAM lParam)
{
    HRESULT hr = _FindPendingInfotip(pti->hwnd, pti->uId, &pti->rect, TRUE);
    if (hr == S_OK)
    {
        hr = SendMessage(_hwndInfotip, TTM_ADDTOOL, 0, (LPARAM)pti) ? S_OK : E_FAIL;
    }
    _OnPostCreateInfotipCleanup(pti);
    return hr;
}

HRESULT CDefView::_OnPostCreateInfotipCleanup(TOOLINFO *pti)
{
    if (!pti->hinst)
        CoTaskMemFree(pti->lpszText);
    delete pti;
    return S_OK;
}

HRESULT CDefView::_FindPendingInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool, BOOL bRemoveAndDestroy)
{
    CLISTPOS posNext = _tlistPendingInfotips.GetHeadPosition();
    CLISTPOS posCurrent;
    PENDING_INFOTIP *ppi;
    HRESULT hr = S_FALSE;

    while (posNext)
    {
        posCurrent = posNext;
        ppi = _tlistPendingInfotips.GetNext(posNext);
    
        if (ppi->hwndContaining == hwndContaining && ppi->uToolID == uToolID)
        {
            if (bRemoveAndDestroy)
            {
                if (prectTool)
                {
                    // Use prectTool as out param.
                    *prectTool = ppi->rectTool;
                }
                _tlistPendingInfotips.RemoveAt(posCurrent);
                delete ppi;
            }
            else
            {
                if (prectTool)
                {
                    // Use prectTool as in param.
                    ppi->rectTool = *prectTool;
                }
            }
            hr = S_OK;
            break;
        }
    }

    // Post Contition -- callers expect only S_OK or S_FALSE.
    ASSERT(hr == S_OK || hr == S_FALSE);

    return hr;
}

HRESULT CDefView::CreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool, HINSTANCE hinst, UINT_PTR uInfotipID, LPARAM lParam)
{
    ASSERT(hwndContaining != NULL);

    // CreateInfotip() is not for use with PreCreateInfotip()/PostCreateInfotip().
    ASSERT(_FindPendingInfotip(hwndContaining, uToolID, NULL, FALSE) == S_FALSE);

    TOOLINFO ti;

    ti.cbSize = sizeof(TOOLINFO);
    ti.uFlags = 0;
    ti.hwnd = hwndContaining;
    ti.uId = uToolID;
    ti.rect = *prectTool;
    ti.hinst = hinst;
    ti.lpszText = (LPWSTR)uInfotipID;
    ti.lParam = lParam;

    return SendMessage(_hwndInfotip, TTM_ADDTOOL, 0, (LPARAM)&ti) ? S_OK : E_FAIL;
}

HRESULT CDefView::CreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool, LPCWSTR pwszInfotip, LPARAM lParam)
{
    return CreateInfotip(hwndContaining, uToolID, prectTool, NULL, (UINT_PTR)pwszInfotip, lParam);
}

HRESULT CDefView::DestroyInfotip(HWND hwndContaining, UINT_PTR uToolID)
{
    ASSERT(hwndContaining != NULL);

    if (_FindPendingInfotip(hwndContaining, uToolID, NULL, TRUE) == S_FALSE)
    {
        TOOLINFO ti = { 0 };

        ti.cbSize = sizeof(ti);
        ti.hwnd = hwndContaining;
        ti.uId = uToolID;

        SendMessage(_hwndInfotip, TTM_DELTOOL, 0, (LPARAM)&ti);
    }

    return S_OK;
}

// Note:
//  Coordinates in prectTool must be relative to the hwnd in hwndContaining.
//
HRESULT CDefView::RepositionInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool)
{
    if (_FindPendingInfotip(hwndContaining, uToolID, prectTool, FALSE) == S_FALSE)
    {
        TOOLINFO ti = { 0 };

        ti.cbSize = sizeof(ti);
        ti.hwnd = hwndContaining;
        ti.uId = uToolID;
        ti.rect = *prectTool;

        SendMessage(_hwndInfotip, TTM_NEWTOOLRECT, 0, (LPARAM)&ti);
    }

    return S_OK;
}

HRESULT CDefView::RelayInfotipMessage(HWND hwndFrom, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;

    if (_hwndInfotip)
    {
        MSG msg;
        msg.hwnd    = hwndFrom;
        msg.message = uMsg;
        msg.wParam  = wParam;
        msg.lParam  = lParam;
        SendMessage(_hwndInfotip, TTM_RELAYEVENT, 0, (LPARAM)&msg);
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CDefView::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDefView, IShellView2),                    // IID_IShellView2
        QITABENTMULTI(CDefView, IShellView, IShellView2),   // IID_IShellView
        QITABENT(CDefView, IViewObject),                    // IID_IViewObject
        QITABENT(CDefView, IDropTarget),                    // IID_IDropTarget
        QITABENT(CDefView, IShellFolderView),               // IID_IShellFolderView
        QITABENT(CDefView, IFolderView),                    // IID_IFolderView
        QITABENT(CDefView, IOleCommandTarget),              // IID_IOleCommandTarget
        QITABENT(CDefView, IServiceProvider),               // IID_IServiceProvider
        QITABENT(CDefView, IDefViewFrame3),                 // IID_IDefViewFrame
        QITABENT(CDefView, IDefViewFrame),                  // IID_IDefViewFrame
        QITABENT(CDefView, IDocViewSite),                   // IID_IDocViewSite
        QITABENT(CDefView, IInternetSecurityMgrSite),       // IID_IInternetSecurityMgrSite
        QITABENT(CDefView, IObjectWithSite),                // IID_IObjectWithSite
        QITABENT(CDefView, IPersistIDList),                 // IID_IPersistIDList
        QITABENT(CDefView, IDVGetEnum),                     // IID_IDVGetEnum
        QITABENT(CDefView, IContextMenuSite),               // IID_IContextMenuSite
        QITABENT(CDefView, IDefViewSafety),                 // IID_IDefViewSafety
        QITABENT(CDefView, IUICommandTarget),               // IID_IUICommandTarget
        { 0 }
    };

    HRESULT hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr))
    {
        // special case this one as it simply casts this...
        if (IsEqualIID(riid, IID_CDefView))
        {
            *ppvObj = (void *)this;
            AddRef();
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP_(ULONG) CDefView::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDefView::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

//===========================================================================
// Constructor of CDefView class
//===========================================================================

CDefView::CDefView(IShellFolder *psf, IShellFolderViewCB *psfvcb,
                   IShellView *psvOuter) : _cRef(1), _cCallback(psfvcb)
{
    psf->QueryInterface(IID_PPV_ARG(IShellFolder, &_pshf));
    psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &_pshf2));

    LPITEMIDLIST pidlFull = _GetViewPidl();
    if (pidlFull)
    {
        LPCITEMIDLIST pidlRelative;
        if (SUCCEEDED(SHBindToFolderIDListParent(NULL, pidlFull, IID_PPV_ARG(IShellFolder, &_pshfParent), &pidlRelative)))
        {
            _pidlRelative = ILClone(pidlRelative);
            _pshfParent->QueryInterface(IID_PPV_ARG(IShellFolder2, &_pshf2Parent));
        }
        ILFree(pidlFull);
    }

    CallCB(SFVM_FOLDERSETTINGSFLAGS, 0, (LPARAM)&_fs.fFlags);

    _vs.InitWithDefaults(this);

    _rgbBackColor = CLR_INVALID;

    _sizeThumbnail.cx = -1; // non init state

    _iIncrementCat = 1;

    _wvLayout.dwLayout = -1; // an invalid value

    //  NOTE we dont AddRef() psvOuter
    //  it has a ref on us
    _psvOuter = psvOuter;

    // the client needs this info to be able to do anything with us,
    // so set it REALLY early on in the creation process
    IUnknown_SetSite(_cCallback.GetSFVCB(), SAFECAST(this, IShellFolderView*));

    for (int i = 0; i < ARRAYSIZE(_crCustomColors); i++)
        _crCustomColors[i] = CLR_MYINVALID;

    _UpdateRegFlags();

    IDLData_InitializeClipboardFormats();

    if (SUCCEEDED(CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellTaskScheduler2, &_pScheduler))))
    {
        // init a set a 60 second timeout
        _pScheduler->Status(ITSSFLAG_KILL_ON_DESTROY, DEFVIEW_THREAD_IDLE_TIMEOUT);
    }

    // Catch unexpected STACK allocations which would break us.
    ASSERT(_hwndInfotip == NULL);
}

STDMETHODIMP CDefView::Init()
{
    HRESULT hr;

    _hdpaGroupingListActive = DPA_Create(16);
    _hdpaGroupingListBackup = DPA_Create(16);

    if (_hdpaGroupingListActive && _hdpaGroupingListBackup)
    {
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

STDAPI SHCreateShellFolderView(const SFV_CREATE* pcsfv, IShellView ** ppsv)
{
    *ppsv = NULL;
    HRESULT hr = E_INVALIDARG;

    if (pcsfv && sizeof(*pcsfv) == pcsfv->cbSize)
    {
        CDefView *pdsv = new CDefView(pcsfv->pshf, pcsfv->psfvcb, pcsfv->psvOuter);
        if (pdsv)
        {
            hr = pdsv->Init();
            if (SUCCEEDED(hr))
            {
                *ppsv = pdsv;
            }
            else
            {
                pdsv->Release();
            }
        }
    }
    return hr;
}

void CDVDropTarget::LeaveAndReleaseData()
{
    DragLeave();
}

void CDVDropTarget::ReleaseDataObject()
{
    ATOMICRELEASE(_pdtobj);
}

void CDVDropTarget::ReleaseCurrentDropTarget()
{
    CDefView *pdv = IToClass(CDefView, _dvdt, this);
    if (_pdtgtCur)
    {
        _pdtgtCur->DragLeave();
        ATOMICRELEASE(_pdtgtCur);
    }
    pdv->_itemCur = -2;
    // WARNING: Never touch pdv->itemOver in this function.
}

HRESULT CDVDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    CDefView *pdv = IToClass(CDefView, _dvdt, this);

    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);

    // Don't allow a drop from our webview content to ourself!
    _fIgnoreSource = FALSE;
    IOleCommandTarget* pct;
    if (pdv->_cFrame.IsWebView() && SUCCEEDED(pdv->_cFrame.GetCommandTarget(&pct)))
    {
        VARIANTARG v = {0};

        if (SUCCEEDED(pct->Exec(&CGID_ShellDocView, SHDVID_ISDRAGSOURCE, 0, NULL, &v)))
        {
            pct->Release();
            if (v.lVal)
            {
                *pdwEffect = DROPEFFECT_NONE;
                _fIgnoreSource = TRUE;
                return S_OK;
            }
        }
    }

    g_fDraggingOverSource = FALSE;

    _grfKeyState = grfKeyState;

    ASSERT(_pdtgtCur == NULL);
    // don't really need to do this, but this sets the target state
    ReleaseCurrentDropTarget();
    _itemOver = -2;

    //
    // In case of Desktop, we should not lock the enter screen.
    //
    HWND hwndLock = pdv->_IsDesktop() ? pdv->_hwndView : pdv->_hwndMain;
    GetWindowRect(hwndLock, &_rcLockWindow);

    DAD_DragEnterEx3(hwndLock, ptl, pdtobj);

    DAD_InitScrollData(&_asd);

    _ptLast.x = _ptLast.y = 0x7fffffff; // put bogus value to force redraw

    return S_OK;
}

#define DVAE_BEFORE 0x01
#define DVAE_AFTER  0x02

// this MUST set pdwEffect to 0 or DROPEFFECT_MOVE if it's a default drag drop
// in the same window

void CDefView::_AlterEffect(DWORD grfKeyState, DWORD *pdwEffect, UINT uFlags)
{
    g_fDraggingOverSource = FALSE;

    if (_IsDropOnSource(NULL))
    {
        if (_IsPositionedView())
        {
            // If this is default drag & drop, enable move.
            if (uFlags & DVAE_AFTER)
            {
                if ((grfKeyState & (MK_LBUTTON | MK_CONTROL | MK_SHIFT | MK_ALT)) == MK_LBUTTON)
                {
                    *pdwEffect = DROPEFFECT_MOVE;
                    g_fDraggingOverSource = TRUE;
                }
                else if (grfKeyState & MK_RBUTTON)
                {
                    *pdwEffect |= DROPEFFECT_MOVE;
                }
            }
        }
        else
        {
            if (uFlags & DVAE_BEFORE)
            {
                // No. Disable move.
                *pdwEffect &= ~DROPEFFECT_MOVE;

                // default drag & drop, disable all.
                if ((grfKeyState & (MK_LBUTTON | MK_CONTROL | MK_SHIFT | MK_ALT)) == MK_LBUTTON)
                {
                    *pdwEffect = 0;
                }
            }
        }
    }
}

HRESULT CDVDropTarget::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    CDefView *pdv = IToClass(CDefView, _dvdt, this);
    HRESULT hr = S_OK;
    DWORD dwEffectScroll = 0;
    DWORD dwEffectOut = 0;
    DWORD dwEffectOutToCache;
    BOOL fSameImage = FALSE;

    if (_fIgnoreSource)
    {
        // for parity with win2k behavior, we need to bail out from DragOver
        // if we hit the SHDVID_ISDRAGSOURCE in DragEnter.
        // this is so when you have a stretched background in active desktop and
        // show desktop icons is off, when you drag the background image around
        // you'll get DROPEFFECT_NONE instead of a bad DROPEFFECT_COPY.
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    POINT pt = {ptl.x, ptl.y};       // in screen coords

    RECT rc;
    GetWindowRect(pdv->_hwndListview, &rc);
    BOOL fInRect = PtInRect(&rc, pt);

    ScreenToClient(pdv->_hwndListview, &pt);    // now in client

    // assume coords of our window match listview
    if (DAD_AutoScroll(pdv->_hwndListview, &_asd, &pt))
        dwEffectScroll = DROPEFFECT_SCROLL;

    // hilight an item, or unhilight all items (DropTarget returns -1)
    int itemNew = fInRect ? pdv->_HitTest(&pt, TRUE) : -1;

    // If we are dragging over on a different item, get its IDropTarget
    // interface or adjust itemNew to -1.
    if (_itemOver != itemNew)
    {
        IDropTarget *pdtgtNew = NULL;

        _dwLastTime = GetTickCount();     // keep track for auto-expanding the tree

        _itemOver = itemNew;

        // Avoid dropping onto drag source objects.
        if ((itemNew != -1) && pdv->_bDragSource)
        {
            UINT uState = ListView_GetItemState(pdv->_hwndListview, itemNew, LVIS_SELECTED);
            if (uState & LVIS_SELECTED)
                itemNew = -1;
        }

        // If we are dragging over an item, try to get its IDropTarget.
        if (itemNew != -1)
        {
            // We are dragging over an item.
            LPCITEMIDLIST apidl[1] = { pdv->_GetPIDL(itemNew) };
            if (apidl[0])
            {
                pdv->_pshf->GetUIObjectOf(pdv->_hwndMain, 1, apidl, IID_PPV_ARG_NULL(IDropTarget, &pdtgtNew));
                ASSERT(itemNew != pdv->_itemCur);    // MUST not be the same
            }

            if (pdtgtNew == NULL)
            {
                // If the item is not a drop target, don't hightlight it
                // treat it as transparent.
                itemNew = -1;
            }
        }

        // If the new target is different from the current one, switch it.
        if (pdv->_itemCur != itemNew)
        {
            // Release previous drop target, if any.
            ReleaseCurrentDropTarget();
            ASSERT(_pdtgtCur==NULL);

            // Update pdv->_itemCur which indicates the current target.
            //  (Note that it might be different from _itemOver).
            pdv->_itemCur = itemNew;

            // If we are dragging over the background or over non-sink item,
            // get the drop target for the folder.
            if (itemNew == -1)
            {
                // We are dragging over the background, this can be NULL
                ASSERT(pdtgtNew == NULL);
                _pdtgtCur = pdv->_pdtgtBack;
                if (_pdtgtCur)
                    _pdtgtCur->AddRef();
            }
            else
            {
                ASSERT(pdtgtNew);
                _pdtgtCur = pdtgtNew;
            }

            // Hilight the sink item (itemNew != -1) or unhilight all (-1).
            LVUtil_DragSelectItem(pdv->_hwndListview, itemNew);

            // Call IDropTarget::DragEnter of the target object.
            if (_pdtgtCur)
            {
                // pdwEffect is in/out parameter.
                dwEffectOut = *pdwEffect;       // pdwEffect in

                // Special case if we are dragging within a source window
                pdv->_AlterEffect(grfKeyState, &dwEffectOut, DVAE_BEFORE);
                hr = _pdtgtCur->DragEnter(_pdtobj, grfKeyState, ptl, &dwEffectOut);
                pdv->_AlterEffect(grfKeyState, &dwEffectOut, DVAE_AFTER);
            }
            else
            {
                ASSERT(dwEffectOut==0);
                pdv->_AlterEffect(grfKeyState, &dwEffectOut, DVAE_BEFORE | DVAE_AFTER);
            }

            TraceMsg(TF_DEFVIEW, "CDV::DragOver dwEIn=%x, dwEOut=%x", *pdwEffect, dwEffectOut);
        }
        else
        {
            ASSERT(pdtgtNew == NULL);   // It must be NULL
            goto NoChange;
        }

        // Every time we're over a new item, record this information so we can handle the insertmark.
        _fItemOverNotADropTarget = (itemNew == -1);
    }
    else
    {
NoChange:
        if (_itemOver != -1)
        {
            DWORD dwNow = GetTickCount();

            if ((dwNow - _dwLastTime) >= 1000)
            {
                _dwLastTime = dwNow;
                // DAD_ShowDragImage(FALSE);
                // OpenItem(pdv, _itemOver);
                // DAD_ShowDragImage(TRUE);
            }
        }

        //
        // No change in the selection. We assume that *pdwEffect stays
        // the same during the same drag-loop as long as the key state doesn't change.
        //
        if ((_grfKeyState != grfKeyState) && _pdtgtCur)
        {
            // Note that pdwEffect is in/out parameter.
            dwEffectOut = *pdwEffect;   // pdwEffect in
            // Special case if we are dragging within a source window
            pdv->_AlterEffect(grfKeyState, &dwEffectOut, DVAE_BEFORE);
            hr = _pdtgtCur->DragOver(grfKeyState, ptl, &dwEffectOut);
            pdv->_AlterEffect(grfKeyState, &dwEffectOut, DVAE_AFTER);
        }
        else
        {
            // Same item and same key state. Use the previous dwEffectOut.
            dwEffectOut = _dwEffectOut;
            fSameImage = TRUE;
            hr = S_OK;
        }
    }

    // Cache the calculated dwEffectOut (BEFORE making local modifications below).
    dwEffectOutToCache = dwEffectOut;

    // Activate/deactivate insertmark, if appropriate.
    LVINSERTMARK lvim = { sizeof(LVINSERTMARK), 0, -1, 0 };
    if (_fItemOverNotADropTarget)
    {
        // Only do the insertion mark stuff if we're in a view mode that makes sense for these:
        if (pdv->_IsAutoArrange() || (pdv->_fs.fFlags & FWF_SNAPTOGRID))
        {
            ListView_InsertMarkHitTest(pdv->_hwndListview, &pt, &lvim);

            if (pdv->_bDragSource && pdv->_IsAutoArrange() && (lvim.iItem == -1))
            {
                // a "move" drop here won't do anything so set the effect appropriately
                if (dwEffectOut & DROPEFFECT_MOVE)
                {
                    // fall back to "copy" drop effect (if supported)
                    if (*pdwEffect & DROPEFFECT_COPY)
                    {
                        dwEffectOut |= DROPEFFECT_COPY;
                    }
                    // fall back to "link" drop effect (if supported)
                    else if (*pdwEffect & DROPEFFECT_LINK)
                    {
                        dwEffectOut |= DROPEFFECT_LINK;
                    }
                    // fall back to no drop effect

                    dwEffectOut &= ~DROPEFFECT_MOVE;
                }

                // NOTE: a DROPEFFECT_MOVE still comes through the ::Drop for a left-drop...
                // we might want to remember that we're exclududing move (_bDragSourceDropOnDragItem)
            }
        }
    }
    ListView_SetInsertMark(pdv->_hwndListview, &lvim);

    _grfKeyState = grfKeyState;         // store these for the next Drop
    _dwEffectOut = dwEffectOutToCache;  // and DragOver

    //  OLE does not call IDropTarget::Drop if we return something
    //  valid. We force OLE call it by returning DROPEFFECT_SCROLL.
    if (g_fDraggingOverSource)
        dwEffectScroll = DROPEFFECT_SCROLL;

    *pdwEffect = dwEffectOut | dwEffectScroll;  // pdwEffect out

    if (!(fSameImage && pt.x == _ptLast.x && pt.y == _ptLast.y))
    {
        HWND hwndLock = pdv->_IsDesktop() ? pdv->_hwndView : pdv->_hwndMain;
        DAD_DragMoveEx(hwndLock, ptl);
        _ptLast.x = ptl.x;
        _ptLast.y = ptl.y;
    }

    return hr;
}

HRESULT CDVDropTarget::DragLeave()
{
    CDefView *pdv = IToClass(CDefView, _dvdt, this);

    //
    // Make it possible to call it more than necessary.
    //
    if (_pdtobj)
    {
        TraceMsg(TF_DEFVIEW, "CDVDropTarget::DragLeave");

        ReleaseCurrentDropTarget();
        _itemOver = -2;
        ReleaseDataObject();

        DAD_DragLeave();
        LVUtil_DragSelectItem(pdv->_hwndListview, -1);
    }

    g_fDraggingOverSource = FALSE;

    ASSERT(_pdtgtCur == NULL);
    ASSERT(_pdtobj == NULL);

    LVINSERTMARK lvim = { sizeof(LVINSERTMARK), 0, -1, 0 }; // clear insert mark (-1)
    ListView_SetInsertMark(pdv->_hwndListview, &lvim);

    return S_OK;
}

HRESULT CDVDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    CDefView *pdv = IToClass(CDefView, _dvdt, this);

    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);

    pdv->_ptDrop.x = pt.x;
    pdv->_ptDrop.y = pt.y;

    ScreenToClient(pdv->_hwndListview, &pdv->_ptDrop);

    //
    // handle moves within the same window here.
    // depend on _AlterEffect forcing in DROPEFFECT_MOVE and only
    // dropeffect move when drag in same window
    //
    // Notes: We need to use _grfKeyState instead of grfKeyState
    //  to see if the left mouse was used or not during dragging.
    //
    pdv->_AlterEffect(_grfKeyState, pdwEffect, DVAE_BEFORE | DVAE_AFTER);

    if ((_grfKeyState & MK_LBUTTON) && (*pdwEffect == DROPEFFECT_MOVE) &&
        (pdv->_IsDropOnSource(NULL)))
    {
        // This means we are left-dropping on ourselves, so we just move
        // the icons.
        DAD_DragLeave();

        pdv->_SameViewMoveIcons();

        SetForegroundWindow(pdv->_hwndMain);

        ASSERT(pdv->_bDropAnchor == FALSE);

        *pdwEffect = 0;  // the underlying objects didn't 'move' anywhere

        ReleaseCurrentDropTarget();
    }
    else if (_pdtgtCur)
    {
        // use this local because if pdtgtCur::Drop does a UnlockWindow
        // then hits an error and needs to put up a dialog,
        // we could get re-entered and clobber the defview's pdtgtCur
        IDropTarget *pdtgtCur = _pdtgtCur;
        _pdtgtCur = NULL;

        //
        // HACK ALERT!!!!
        //
        //  If we don't call LVUtil_DragEnd here, we'll be able to leave
        // dragged icons visible when the menu is displayed. However, because
        // we are calling IDropTarget::Drop() which may create some modeless
        // dialog box or something, we can not ensure the locked state of
        // the list view -- LockWindowUpdate() can lock only one window at
        // a time. Therefore, we skip this call only if the pdtgtCur
        // is a subclass of CIDLDropTarget, assuming its Drop calls
        // CDefView::DragEnd (or CIDLDropTarget_DragDropMenu) appropriately.
        //
        pdv->_bDropAnchor = TRUE;

        if (!DoesDropTargetSupportDAD(pdtgtCur))
        {
            // This will hide the dragged image.
            DAD_DragLeave();

            // reset the drag image list so that the user
            // can start another drag&drop while we are in this
            // Drop() member function call.
            DAD_SetDragImage(NULL, NULL);
        }

        // Special case if we are dragging within a source window
        pdv->_AlterEffect(grfKeyState, pdwEffect, DVAE_BEFORE | DVAE_AFTER);

        IUnknown_SetSite(pdtgtCur, SAFECAST(pdv, IShellView2*));

        pdtgtCur->Drop(pdtobj, grfKeyState, pt, pdwEffect);

        IUnknown_SetSite(pdtgtCur, NULL);

        pdtgtCur->Release();

        DAD_DragLeave();

        pdv->_bDropAnchor = FALSE;
    }
    else
    {
        // We come here if Drop is called without DragMove (with DragEnter).
        *pdwEffect = 0;
    }

    DragLeave();    // DoDragDrop does not call DragLeave() after Drop()

    return S_OK;
}

BOOL CDefView::_IsBkDropTarget(IDropTarget *pdtg)
{
    BOOL fRet = FALSE;

    if (_bContextMenuMode)
    {
        if (ListView_GetSelectedCount(_hwndListview) == 0)
        {
            fRet = TRUE;
        }
    }

    POINT pt;
    if (!fRet)
    {
        if (_GetInsertPoint(&pt)) // If there is an insert point, then the background is the drop target.
            return TRUE;

        if (_GetDropPoint(&pt))
        {
            // The Drop point is returned in internal listview coordinates
            // space, so we need to convert it back to client space
            // before we call this function...

            LVUtil_LVToClient(_hwndListview, &pt);
            if (_HitTest(&pt) == -1)
            {
                fRet = TRUE;
            }
        }
    }
    return fRet;
}

// IShellFolderView::Rearrange

STDMETHODIMP CDefView::Rearrange(LPARAM lParamSort)
{
    return _OnRearrange(lParamSort, TRUE);
}

// end user initiated arrange (click on col header, etc)

HRESULT CDefView::_OnRearrange(LPARAM lParamSort, BOOL fAllowToggle)
{
    DECLAREWAITCURSOR;

    _vs._iLastColumnClick = (int) _vs._lParamSort;
    _vs._lParamSort = lParamSort;

    // toggle the direction of the sort if on the same column
    if (fAllowToggle && !_IsPositionedView() && _vs._iLastColumnClick == (int) lParamSort)
        _vs._iDirection = -_vs._iDirection;
    else
        _vs._iDirection = 1;

    SetWaitCursor();

    HRESULT hr = _Sort();

    // reset to the state that no items have been moved if currently in a positioned mode
    // so auto-arraning works.

    if (_IsPositionedView())
    {
        _ClearItemPositions();
    }

    ResetWaitCursor();

    return hr;
}

STDMETHODIMP CDefView::ArrangeGrid()
{
    _OnCommand(NULL, GET_WM_COMMAND_MPS(SFVIDM_ARRANGE_GRID, 0, 0));
    return S_OK;
}

STDMETHODIMP CDefView::AutoArrange()
{
    _OnCommand(NULL, GET_WM_COMMAND_MPS(SFVIDM_ARRANGE_AUTO, 0, 0));
    return S_OK;
}

STDMETHODIMP CDefView::GetArrangeParam(LPARAM *plParamSort)
{
    *plParamSort = _vs._lParamSort;
    return S_OK;
}

STDMETHODIMP CDefView::AddObject(LPITEMIDLIST pidl, UINT *puItem)
{
    LPITEMIDLIST pidlCopy = ILClone(pidl);

    if (pidlCopy)
    {
        *puItem = _AddObject(pidlCopy);  // takes pidl ownership.
    }
    else
    {
        *puItem = (UINT)-1;
    }
    // must cast to "int" because UINTs are never negative so we would
    // otherwise never be able to detect failure
    return (int)*puItem >= 0 ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CDefView::GetObjectCount(UINT *puCount)
{
    *puCount = ListView_GetItemCount(_hwndListview);
    return S_OK;
}

STDMETHODIMP CDefView::SetObjectCount(UINT uCount, UINT dwFlags)
{
    // Mask over to the flags that map directly accross
    DWORD dw = dwFlags & SFVSOC_NOSCROLL;
    UINT uCountOld = 0;

    GetObjectCount(&uCountOld);

    if ((dwFlags & SFVSOC_INVALIDATE_ALL) == 0)
        dw |= LVSICF_NOINVALIDATEALL; // gross transform

    HRESULT hr = (HRESULT)SendMessage(_hwndListview, LVM_SETITEMCOUNT, (WPARAM)uCount, (LPARAM)dw);

    // Notify automation if we're going from 0 to 1 or more items
    if (!uCountOld && uCount)
    {
        _PostNoItemStateChangedMessage();
    }

    return hr;
}

STDMETHODIMP CDefView::GetObject(LPITEMIDLIST *ppidl, UINT uItem)
{
    // Worse hack, if -42 then return our own pidl...
    if (uItem == (UINT)-42)
    {
        *ppidl = (LPITEMIDLIST)_pidlMonitor;
        return *ppidl ? S_OK : E_UNEXPECTED;
    }

    // Hack, if item is -2, this implies return the focused item
    if (uItem == (UINT)-2)
        uItem = ListView_GetNextItem(_hwndListview, -1, LVNI_FOCUSED);

    *ppidl = (LPITEMIDLIST)_GetPIDL(uItem); // cast due to bad interface def
    return *ppidl ? S_OK : E_UNEXPECTED;
}

STDMETHODIMP CDefView::RemoveObject(LPITEMIDLIST pidl, UINT *puItem)
{
    *puItem = _RemoveObject(pidl, FALSE);

    // must cast to "int" because UINTs are never negative so we would
    // otherwise never be able to detect failure
    return (int)*puItem >= 0 ? S_OK : E_INVALIDARG;
}

STDMETHODIMP CDefView::UpdateObject(LPITEMIDLIST pidlOld, LPITEMIDLIST pidlNew, UINT *puItem)
{
    *puItem = _UpdateObject(pidlOld, pidlNew);
    return (int)(*puItem) >= 0 ? S_OK : E_INVALIDARG;
}

STDMETHODIMP CDefView::RefreshObject(LPITEMIDLIST pidl, UINT *puItem)
{
    *puItem = _RefreshObject(&pidl);
    // must cast to "int" because UINTs are never negative so we would
    // otherwise never be able to detect failure
    return (int)*puItem >= 0 ? S_OK : E_INVALIDARG;
}

STDMETHODIMP CDefView::SetRedraw(BOOL bRedraw)
{
    SendMessage(_hwndListview, WM_SETREDRAW, (WPARAM)bRedraw, 0);
    return S_OK;
}

STDMETHODIMP CDefView::GetSelectedObjects(LPCITEMIDLIST **pppidl, UINT *puItems)
{
    return _GetItemObjects(pppidl, SVGIO_SELECTION, puItems);
}

STDMETHODIMP CDefView::GetSelectedCount(UINT *puSelected)
{
    *puSelected = ListView_GetSelectedCount(_hwndListview);
    return S_OK;
}

BOOL CDefView::_IsDropOnSource(IDropTarget *pdtgt)
{
    // context menu paste (_bMouseMenu shows context menu, cut stuff shows source)
    if (_bMouseMenu && _bHaveCutStuff)
    {
        int iItem = ListView_GetNextItem(_hwndListview, -1, LVNI_SELECTED);
        if (iItem == -1)
            return TRUE;
    }

    if (_itemCur != -1 || !_bDragSource)
    {
        // We did not drag onto the background of the source
        return FALSE;
    }

    return TRUE;
}

STDMETHODIMP CDefView::IsDropOnSource(IDropTarget *pDropTarget)
{
    return _IsDropOnSource(pDropTarget) ? S_OK : S_FALSE;
}

STDMETHODIMP CDefView::MoveIcons(IDataObject *pdtobj)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDefView::GetDropPoint(POINT *ppt)
{
    return _GetDropPoint(ppt) ? S_OK : S_FALSE;
}


STDMETHODIMP CDefView::GetDragPoint(POINT *ppt)
{
    return _GetDragPoint(ppt) ? S_OK : S_FALSE;
}


STDMETHODIMP CDefView::SetItemPos(LPCITEMIDLIST pidl, POINT *ppt)
{
    SFV_SETITEMPOS sip;
    sip.pidl = pidl;
    sip.pt = *ppt;

    _SetItemPos(&sip);
    return S_OK;
}

STDMETHODIMP CDefView::IsBkDropTarget(IDropTarget *pDropTarget)
{
    return _IsBkDropTarget(pDropTarget) ? S_OK : S_FALSE;
}

STDMETHODIMP CDefView::SetClipboard(BOOL bMove)
{
    _OnSetClipboard(bMove);   // do this always, even if not current active view

    return S_OK;
}

// defcm.cpp asks us to setup the points of the currently selected objects
// into the data object on Copy/Cut commands
STDMETHODIMP CDefView::SetPoints(IDataObject *pdtobj)
{
    LPCITEMIDLIST *apidl;
    UINT cItems;
    HRESULT hr = GetSelectedObjects(&apidl, &cItems);
    if (SUCCEEDED(hr) && cItems)
    {
        _SetPoints(cItems, apidl, pdtobj);
        LocalFree((HLOCAL)apidl);
    }
    return hr;
}

STDMETHODIMP CDefView::GetItemSpacing(ITEMSPACING *pSpacing)
{
    return _GetItemSpacing(pSpacing) ? S_OK : S_FALSE;
}

STDMETHODIMP CDefView::SetCallback(IShellFolderViewCB* pNewCB, IShellFolderViewCB** ppOldCB)
{
    *ppOldCB = NULL;

    return _cCallback.SetCallback(pNewCB, ppOldCB);
}

const UINT c_rgiSelectFlags[][2] =
{
    { SFVS_SELECT_ALLITEMS, SFVIDM_SELECT_ALL },
    { SFVS_SELECT_NONE,     SFVIDM_DESELECT_ALL },
    { SFVS_SELECT_INVERT,   SFVIDM_SELECT_INVERT }
};

STDMETHODIMP CDefView::Select(UINT dwFlags)
{
    // translate the flag into the menu ID
    for (int i = 0; i < ARRAYSIZE(c_rgiSelectFlags); i++)
    {
        if (c_rgiSelectFlags[i][0] == dwFlags)
        {
            return (HRESULT)_OnCommand(NULL, c_rgiSelectFlags[i][1], 0);
        }
    }

    return E_INVALIDARG;
}

STDMETHODIMP CDefView::QuerySupport(UINT * pdwSupport)
{
    // *pdwSupport is an in/out param, we leave the out == in
    return S_OK;    // DefView supports all the operations...
}

STDMETHODIMP CDefView::SetAutomationObject(IDispatch *pdisp)
{
    // release back pointers
    IUnknown_SetOwner(_pauto, NULL);
    IUnknown_SetSite(_pauto, NULL);

    IUnknown_Set((IUnknown **)&_pauto, pdisp); // hold or free _pauto

    // this connects the automation object to our view, so it can implement
    // stuff like "SelectedItems"
    IUnknown_SetOwner(_pauto, SAFECAST(this, IShellFolderView *));

    // use the browser as the site so OM related QueryService calls will find
    // the browser above us as the place to do security checks instead of defivew
    // this is stuff that depends on the zone of the caller as the security check
    IUnknown_SetSite(_pauto, _psb);

    return S_OK;
}

STDMETHODIMP CDefView::SelectAndPositionItems(UINT cidl, LPCITEMIDLIST* apidl, POINT* apt, DWORD dwFlags)
{
    for (UINT i = 0; i < cidl; i++)
        SelectAndPositionItem(apidl[i], dwFlags, apt ? &apt[i] : NULL);

    return S_OK;
}



// -------------- auto scroll stuff --------------

BOOL _AddTimeSample(AUTO_SCROLL_DATA *pad, const POINT *ppt, DWORD dwTime)
{
    pad->pts[pad->iNextSample] = *ppt;
    pad->dwTimes[pad->iNextSample] = dwTime;

    pad->iNextSample++;

    if (pad->iNextSample == ARRAYSIZE(pad->pts))
        pad->bFull = TRUE;

    pad->iNextSample = pad->iNextSample % ARRAYSIZE(pad->pts);

    return pad->bFull;
}

#ifdef DEBUG
// for debugging, verify we have good averages
DWORD g_time = 0;
int g_distance = 0;
#endif

int _CurrentVelocity(AUTO_SCROLL_DATA *pad)
{
    int i, iStart, iNext;
    int dx, dy, distance;
    DWORD time;

    ASSERT(pad->bFull);

    distance = 0;
    time = 1;   // avoid div by zero

    i = iStart = pad->iNextSample % ARRAYSIZE(pad->pts);

    do {
        iNext = (i + 1) % ARRAYSIZE(pad->pts);

        dx = abs(pad->pts[i].x - pad->pts[iNext].x);
        dy = abs(pad->pts[i].y - pad->pts[iNext].y);
        distance += (dx + dy);
        time += abs(pad->dwTimes[i] - pad->dwTimes[iNext]);

        i = iNext;

    } while (i != iStart);

#ifdef DEBUG
    g_time = time;
    g_distance = distance;
#endif

    // scale this so we don't loose accuracy
    return (distance * 1024) / time;
}



// NOTE: this is duplicated in shell32.dll
//
// checks to see if we are at the end position of a scroll bar
// to avoid scrolling when not needed (avoid flashing)
//
// in:
//      code        SB_VERT or SB_HORZ
//      bDown       FALSE is up or left
//                  TRUE  is down or right

BOOL CanScroll(HWND hwnd, int code, BOOL bDown)
{
    SCROLLINFO si;

    si.cbSize = sizeof(si);
    si.fMask = (SIF_RANGE | SIF_PAGE | SIF_POS);
    GetScrollInfo(hwnd, code, &si);

    if (bDown)
    {
        if (si.nPage)
            si.nMax -= si.nPage - 1;
        return si.nPos < si.nMax;
    }
    else
    {
        return si.nPos > si.nMin;
    }
}

#define DSD_NONE                0x0000
#define DSD_UP                  0x0001
#define DSD_DOWN                0x0002
#define DSD_LEFT                0x0004
#define DSD_RIGHT               0x0008

DWORD DAD_DragScrollDirection(HWND hwnd, const POINT *ppt)
{
    RECT rcOuter, rc;
    DWORD dwDSD = DSD_NONE;
    DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);

#define g_cxVScroll GetSystemMetrics(SM_CXVSCROLL)
#define g_cyHScroll GetSystemMetrics(SM_CYHSCROLL)

    GetClientRect(hwnd, &rc);

    if (dwStyle & WS_HSCROLL)
        rc.bottom -= g_cyHScroll;

    if (dwStyle & WS_VSCROLL)
        rc.right -= g_cxVScroll;

    // the explorer forwards us drag/drop things outside of our client area
    // so we need to explictly test for that before we do things
    //
    rcOuter = rc;
    InflateRect(&rcOuter, g_cxSmIcon, g_cySmIcon);

    InflateRect(&rc, -g_cxIcon, -g_cyIcon);

    if (!PtInRect(&rc, *ppt) && PtInRect(&rcOuter, *ppt))
    {
        // Yep - can we scroll?
        if (dwStyle & WS_HSCROLL)
        {
            if (ppt->x < rc.left)
            {
                if (CanScroll(hwnd, SB_HORZ, FALSE))
                    dwDSD |= DSD_LEFT;
            }
            else if (ppt->x > rc.right)
            {
                if (CanScroll(hwnd, SB_HORZ, TRUE))
                    dwDSD |= DSD_RIGHT;
            }
        }
        if (dwStyle & WS_VSCROLL)
        {
            if (ppt->y < rc.top)
            {
                if (CanScroll(hwnd, SB_VERT, FALSE))
                    dwDSD |= DSD_UP;
            }
            else if (ppt->y > rc.bottom)
            {
                if (CanScroll(hwnd, SB_VERT, TRUE))
                    dwDSD |= DSD_DOWN;
            }
        }
    }
    return dwDSD;
}


#define SCROLL_FREQUENCY        (GetDoubleClickTime()/2)        // 1 line scroll every 1/4 second
#define MIN_SCROLL_VELOCITY     20      // scaled mouse velocity

BOOL WINAPI DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow)
{
    // first time we've been called, init our state
    int v;
    DWORD dwTimeNow = GetTickCount();
    DWORD dwDSD = DAD_DragScrollDirection(hwnd, pptNow);

    if (!_AddTimeSample(pad, pptNow, dwTimeNow))
        return dwDSD;

    v = _CurrentVelocity(pad);

    if (v <= MIN_SCROLL_VELOCITY)
    {
        // Nope, do some scrolling.
        if ((dwTimeNow - pad->dwLastScroll) < SCROLL_FREQUENCY)
            dwDSD = 0;

        if (dwDSD & DSD_UP)
        {
            DAD_ShowDragImage(FALSE);
            FORWARD_WM_VSCROLL(hwnd, NULL, SB_LINEUP, 1, SendMessage);
        }
        else if (dwDSD & DSD_DOWN)
        {
            DAD_ShowDragImage(FALSE);
            FORWARD_WM_VSCROLL(hwnd, NULL, SB_LINEDOWN, 1, SendMessage);
        }
        if (dwDSD & DSD_LEFT)
        {
            DAD_ShowDragImage(FALSE);
            FORWARD_WM_HSCROLL(hwnd, NULL, SB_LINEUP, 1, SendMessage);
        }
        else if (dwDSD & DSD_RIGHT)
        {
            DAD_ShowDragImage(FALSE);
            FORWARD_WM_HSCROLL(hwnd, NULL, SB_LINEDOWN, 1, SendMessage);
        }

        DAD_ShowDragImage(TRUE);

        if (dwDSD)
        {
            TraceMsg(TF_DEFVIEW, "v=%d", v);
            pad->dwLastScroll = dwTimeNow;
        }
    }
    return dwDSD;       // bits set if in scroll region
}

// warning: global data holding COM objects that may span apartment boundaries
// be very careful

HDSA g_hdsaDefViewCopyHook = NULL;

typedef struct {
    HWND hwndView;
    CDefView *pdv;
} DVCOPYHOOK;

void CDefView::AddCopyHook()
{
    ENTERCRITICAL;
    if (!g_hdsaDefViewCopyHook)
    {
        g_hdsaDefViewCopyHook = DSA_Create(sizeof(DVCOPYHOOK), 4);
        TraceMsg(TF_DEFVIEW, "AddCopyHook creating the dsa");
    }

    if (g_hdsaDefViewCopyHook)
    {
        DVCOPYHOOK dvch = { _hwndView, this };
        ASSERT(dvch.hwndView);
        if (DSA_AppendItem(g_hdsaDefViewCopyHook, &dvch)!=-1)
        {
            AddRef();
            TraceMsg(TF_DEFVIEW, "AddCopyHook successfully added (total=%d)",
                     DSA_GetItemCount(g_hdsaDefViewCopyHook));
        }
    }
    LEAVECRITICAL;
}

int CDefView::FindCopyHook(BOOL fRemoveInvalid)
{
    ASSERTCRITICAL;

    if (g_hdsaDefViewCopyHook)
    {
        int item = DSA_GetItemCount(g_hdsaDefViewCopyHook);
        while (--item >= 0)
        {
            const DVCOPYHOOK *pdvch = (const DVCOPYHOOK *)DSA_GetItemPtr(g_hdsaDefViewCopyHook, item);
            if (pdvch)
            {
                if (fRemoveInvalid)
                {
                    if (!IsWindow(pdvch->hwndView))
                    {
                        TraceMsg(TF_WARNING, "FindCopyHook: found a invalid element, removing...");
                        DSA_DeleteItem(g_hdsaDefViewCopyHook, item);
                        continue;
                    }
                }

                if ((pdvch->hwndView == _hwndView) && (pdvch->pdv == this))
                {
                    return item;
                }
            }
            else
            {
                ASSERT(0);
            }
        }

    }
    return -1;  // not found
}

void CDefView::RemoveCopyHook()
{
    IShellView *psv = NULL;
    ENTERCRITICAL;
    if (g_hdsaDefViewCopyHook)
    {
        int item = FindCopyHook(TRUE);
        if (item != -1)
        {
            DVCOPYHOOK *pdvch = (DVCOPYHOOK *)DSA_GetItemPtr(g_hdsaDefViewCopyHook, item);
            psv = pdvch->pdv;
            TraceMsg(TF_DEFVIEW, "RemoveCopyHook removing an element");
            DSA_DeleteItem(g_hdsaDefViewCopyHook, item);

            //
            // If this is the last guy, destroy it.
            //
            if (DSA_GetItemCount(g_hdsaDefViewCopyHook) == 0)
            {
                TraceMsg(TF_DEFVIEW, "RemoveCopyHook destroying hdsa (no element)");
                DSA_Destroy(g_hdsaDefViewCopyHook);
                g_hdsaDefViewCopyHook = NULL;
            }
        }
    }
    LEAVECRITICAL;

    //
    // Release it outside the critical section.
    //
    ATOMICRELEASE(psv);
}

STDAPI_(UINT) DefView_CopyHook(const COPYHOOKINFO *pchi)
{
    UINT idRet = IDYES;

    if (g_hdsaDefViewCopyHook==NULL)
    {
        return idRet;
    }

    for (int item = 0; ; item++)
    {
        DVCOPYHOOK dvch = { NULL, NULL };

        // We should minimize this critical section (and must not
        // call pfnCallBack which may popup UI!).

        ENTERCRITICAL;
        if (g_hdsaDefViewCopyHook && DSA_GetItem(g_hdsaDefViewCopyHook, item, &dvch))
        {
            dvch.pdv->AddRef();
        }
        LEAVECRITICAL;

        if (dvch.pdv)
        {
            if (IsWindow(dvch.hwndView))
            {
                HRESULT hr = dvch.pdv->CallCB(SFVM_NOTIFYCOPYHOOK, 0, (LPARAM)pchi);

                ATOMICRELEASE(dvch.pdv);
                if (SUCCEEDED(hr) && (hr != S_OK))
                {
                    idRet = HRESULT_CODE(hr);
                    ASSERT(idRet==IDYES || idRet==IDCANCEL || idRet==IDNO);
                    break;
                }
                item++;
            }
            else
            {
                TraceMsg(TF_DEFVIEW, "DefView_CopyHook list has an invalid element");
                ATOMICRELEASE(dvch.pdv);
            }
        }
        else
        {
            break;      // no more item.
        }
    }

    return idRet;
}

// IOleCommandTarget stuff - just forward to the webview
STDMETHODIMP CDefView::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;
    BOOL fQSCalled = FALSE;

    if (_cFrame.IsWebView())
    {
        IOleCommandTarget* pct;

        if (SUCCEEDED(_cFrame.GetCommandTarget(&pct)))
        {
            hr = pct->QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
            fQSCalled = SUCCEEDED(hr);
            pct->Release();
        }
    }

    if (pguidCmdGroup == NULL)
    {
        if (rgCmds == NULL)
            return E_INVALIDARG;

        for (UINT i = 0; i < cCmds; i++)
        {
            // ONLY say that we support the stuff we support in ::OnExec
            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_REFRESH:
                rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            default:
                // don't disable if the webview has already answered
                if (!fQSCalled)
                {
                    rgCmds[i].cmdf = 0;
                }
                break;
            }
        }
    }
    else if (IsEqualGUID(_clsid, *pguidCmdGroup))
    {
        if (pcmdtext)
        {
            switch (pcmdtext->cmdtextf)
            {
            case OLECMDTEXTF_NAME:
                // It's a query for the button tooltip text.
                ASSERT(cCmds == 1);
                _GetToolTipText(rgCmds[0].cmdID, pcmdtext->rgwz, pcmdtext->cwBuf);

                // ensure NULL termination
                pcmdtext->rgwz[pcmdtext->cwBuf - 1] = 0;
                pcmdtext->cwActual = lstrlenW(pcmdtext->rgwz);

                hr = S_OK;
                break;

            default:
                hr = E_FAIL;
                break;
            }
        }
        else
        {
            DWORD dwAttr = _AttributesFromSel(SFGAO_RELEVANT);

            for (UINT i = 0; i < cCmds; i++)
            {
                if (_ShouldEnableToolbarButton(rgCmds[i].cmdID, dwAttr, -1))
                    rgCmds[i].cmdf = OLECMDF_ENABLED;
                else
                    rgCmds[i].cmdf = 0;
            }

            hr = S_OK;
        }
    }

    return hr;
}
STDMETHODIMP CDefView::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr; 

    //  Hold a ref to ourselves on Exec.  In the camera name space if the view context menu is up when the camera
    //  is unplugged, explorer faults because the view is torn down and the context menu exec tries to unwind
    //  after defview is gone.  This holds a ref on defview while in exec so defview doesn't dissappear.
    //
    AddRef();
    hr = _Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    Release();

    return hr;
}

HRESULT CDefView::_Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup == NULL)
    {
        switch (nCmdID)
        {
        case OLECMDID_REFRESH:
            _fAllowSearchingWindow = TRUE; // this exec typically comes from a user action (F5, Refresh)
            if (FAILED(_ReloadContent()))
            {
               //This invalidation deletes the WebView and also avoid
               //unpainted areas in ListView  areas whose paint messages
               //are eaten by the visible WebView
               InvalidateRect(_hwndView, NULL, TRUE);
            }
            hr = S_OK;
            break;
        }
    }
    else if (IsEqualGUID(CGID_DefView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
            case DVID_SETASDEFAULT:

//  99/02/05 #226140 vtan: Exec command issued from
//  CShellBrowser2::_SaveDefViewDefaultFolderSettings()
//  when user clicks "Like Current Folder" in folder
//  options "View" tab.

                ASSERTMSG(nCmdexecopt == OLECMDEXECOPT_DODEFAULT, "nCmdexecopt must be OLECMDEXECOPT_DODEFAULT");
                ASSERTMSG(pvarargIn == NULL, "pvarargIn must be NULL");
                ASSERTMSG(pvarargOut == NULL, "pvarargOut must be NULL");
                hr = _SaveGlobalViewState();
                break;
            case DVID_RESETDEFAULT:

//  99/02/05 #226140 vtan: Exec command issued from
//  CShellBrowser2::_ResetDefViewDefaultFolderSettings()
//  when user clicks "Reset All Folders" in folder
//  options "View" tab.

                ASSERTMSG(nCmdexecopt == OLECMDEXECOPT_DODEFAULT, "nCmdexecopt must be OLECMDEXECOPT_DODEFAULT");
                ASSERTMSG(pvarargIn == NULL, "pvarargIn must be NULL");
                ASSERTMSG(pvarargOut == NULL, "pvarargOut must be NULL");
                hr = _ResetGlobalViewState();
                break;
            default:
                break;
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SHDVID_CANACTIVATENOW:
            return _fCanActivateNow ? S_OK : S_FALSE;

        // NOTE: for a long time IOleCommandTarget was implemented
        // BUT it wasn't in the QI! At this late stage of the game
        // I'll be paranoid and not forward everything down to the
        // webview. We'll just pick off CANACTIVATENOW...
        //
        default:
            return OLECMDERR_E_UNKNOWNGROUP;
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SBCMDID_GETPANE:
            V_I4(pvarargOut) = PANE_NONE;
            CallCB(SFVM_GETPANE, nCmdexecopt, (LPARAM)&V_I4(pvarargOut));
            return S_OK;

        case SBCMDID_MIXEDZONE:
            if (pvarargOut)
                return _cFrame._GetCurrentZone(NULL, pvarargOut);
            break;

        default:
            break;
        }
    }
    else if (IsEqualGUID(IID_IExplorerToolbar, *pguidCmdGroup))
    {
        // handle the ones coming FROM itbar:
        switch (nCmdID)
        {
        case ETCMDID_GETBUTTONS:
            pvarargOut->vt = VT_BYREF;
            pvarargOut->byref = (void *)_pbtn;
            *pvarargIn->plVal = _cTotalButtons;
            return S_OK;

        case ETCMDID_RELOADBUTTONS:
            MergeToolBar(TRUE);
            return S_OK;
        }
    }
    else if (IsEqualGUID(_clsid, *pguidCmdGroup))
    {
        UEMFireEvent(&UEMIID_BROWSER, UEME_UITOOLBAR, UEMF_XEVENT, UIG_OTHER, nCmdID);

        DFVCMDDATA cd;
        cd.pva = pvarargIn;
        cd.hwnd = _hwndMain;
        cd.nCmdIDTranslated = 0;
        _OnCommand(NULL, nCmdID, (LPARAM)&cd);
    }

    // no need to pass OLECMDID_REFRESH on to the webview, as we
    // just nuked and replaced the webview above -- a super refresh of sorts.

    if (_cFrame.IsWebView() && hr != S_OK)
    {
        //  Do not pass IDM_PARSECOMPLETE back to MSHTML.  This will cause them to load mshtmled.dll
        //  unecessarily for webview which is a significant performance hit.
        if (!(pguidCmdGroup && IsEqualGUID(CGID_MSHTML, *pguidCmdGroup) && (nCmdID == IDM_PARSECOMPLETE)))
        {
            IOleCommandTarget* pct;
            if (SUCCEEDED(_cFrame.GetCommandTarget(&pct)))
            {
                hr = pct->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                pct->Release();
            }
        }
    }

    return hr;
}


void CDefView::_ShowAndActivate()
{
    // Can't call SetFocus because it rips focus away from such nice
    // UI elements like the TREE pane...
    // UIActivate will steal focus only if _uState is SVUIA_ACTIVATE_FOCUS
    UIActivate(_uState);
}

// IDefViewFrame (available only through QueryService from sfvext!)
//
HRESULT CDefView::GetShellFolder(IShellFolder **ppsf)
{
    *ppsf = _pshf;
    if (*ppsf)
        _pshf->AddRef();

    return *ppsf ? S_OK : E_FAIL;
}


// IDefViewFrame3
//
HRESULT CDefView::GetWindowLV(HWND * phwnd)
{
    if (!_IsDesktop())
    {
        if (!_fGetWindowLV)
        {
            _fGetWindowLV = TRUE;
            // Caller will call ShowHideListView for us

            *phwnd = _hwndListview;
        }
        TraceMsg(TF_DEFVIEW, "GetWindowLV - TAKEN");
        return S_OK;
    }
    else
    {
        *phwnd = NULL;
        return E_FAIL;
    }
}

HRESULT CDefView::OnResizeListView()
{
    _AutoAutoArrange(0);
    return S_OK;
}

HRESULT CDefView::ReleaseWindowLV()
{
    _fGetWindowLV = FALSE;
    WndSize(_hwndView);             // Make sure we resize _hwndListview
    ShowHideListView();
    return S_OK;
}

HRESULT CDefView::DoRename()
{
    return HandleRename(NULL);
}

// IServiceProvider

STDMETHODIMP CDefView::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;

    if (guidService == SID_DefView) // private service ID
    {
        // DefViewOCs request this interface
        if (riid != IID_IDefViewFrame || !_IsDesktop())
            hr = QueryInterface(riid, ppv);
    }
    else if (guidService == SID_ShellTaskScheduler)
    {
        if (_pScheduler)
        {
            hr = _pScheduler->QueryInterface(riid, ppv);
        }
    }
    else if ((guidService == SID_SContextMenuSite) ||
             (guidService == SID_SFolderView))      // documented service ID
    {
       hr = QueryInterface(riid, ppv);
    }
    else if (guidService == SID_ShellFolderViewCB)  // access to the view callback object
    {
        IShellFolderViewCB * psfvcb = _cCallback.GetSFVCB();
        if (psfvcb)
            hr = psfvcb->QueryInterface(riid, ppv);
    }
    else if (guidService == SID_WebViewObject)
    {
        if (_cFrame.IsWebView())
        {
            if (_cFrame._pOleObj)
            {
                //
                // We hit this codepath while navigating away (while saving history),
                // so there should not be any pending _cFrame._pOleObjNew as this
                // view is going to be destroyed.
                //
                ASSERTMSG(!_cFrame._pOleObjNew, "Ambiguous Oleobj while peristing trident history in webview");
                hr = _cFrame._pOleObj->QueryInterface(riid, ppv);
            }
            else if (_cFrame._pOleObjNew)
            {
                //
                // We hit this codepath if we are navigating to the view (while loading history),
                // we have not yet called _cFrame._SwitchToNewOleObj(), so we'll use
                // the pending oleobj as CDefViewPersistHistory::LoadHistory()
                // expects to get the right IPersistHistory interface from it.
                //
                hr = _cFrame._pOleObjNew->QueryInterface(riid, ppv);
            }
        }
    }
    else if (guidService == SID_SProgressUI)
    {
        // return a new instance of the progress dialog to the caller
        hr = CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, riid, ppv);
    }
    else if (_psb)
    {
        hr = IUnknown_QueryService(_psb, guidService, riid, ppv);   // send up the to the browser
    }
    else
    {
        hr = IUnknown_QueryService(_punkSite, guidService, riid, ppv);  // or our site
    }
    return hr;
}

STDMETHODIMP CDefView::OnSetTitle(VARIANTARG *pvTitle)
{
    return E_NOTIMPL;
}

BOOL CDefView::_LoadCategory(GUID *pguidGroupID)
{
    BOOL fRet = FALSE;
    LPITEMIDLIST pidl = _GetViewPidl();
    if (pidl)
    {
        IPropertyBag *ppb;
        if (SUCCEEDED(IUnknown_QueryServicePropertyBag(_psb, SHGVSPB_FOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
        {
            fRet = SUCCEEDED(SHPropertyBag_ReadGUID(ppb, TEXT("Categorize"), pguidGroupID));
            ppb->Release();
        }
        ILFree(pidl);
    }
    return fRet;
}

void SHGetThumbnailSize(SIZE *psize)
{
    psize->cx = psize->cy = 96;

    DWORD dw = 0, cb = sizeof(dw);
    SHRegGetUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
                    TEXT("ThumbnailSize"), NULL, &dw, &cb, FALSE, NULL, 0);

    if (dw >= 32 && dw <= 256)    // constrain to reason
    {
        psize->cx = psize->cy = (int)dw;
    }
}

void SHGetThumbnailSizeForThumbsDB(SIZE *psize)
{
    SHGetThumbnailSize(psize);

    // Due to tnail.cpp restriction buffer sizes, we can only go to 120 (since that's all we've tested at)
    if (psize->cx > 120)
        psize->cx = psize->cy = 120;
}

void CDefView::_GetThumbnailSize(SIZE *psize)
{
    if (-1 == _sizeThumbnail.cx)
    {
        SHGetThumbnailSize(&_sizeThumbnail);
    }
    *psize = _sizeThumbnail;
}

#ifdef _X86_
//************
//
//  More of the Hijaak Hack
//

//  We return no attributes (specifically, Hijaak looks for
//  SFGAO_FILESYSTEM) and Hijaak will say, "Whoa, I don't know
//  how to patch this guy; I'll leave it alone."

STDAPI FakeHijaak_GetAttributesOf(void *_this, UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfInOut)
{
    *rgfInOut = 0; // Move along, nothing to see here
    return S_OK;
}

const struct FakeHijaakFolderVtbl
{
    FARPROC Dummy[9];
    FARPROC GetAttributesOf;
} c_FakeHijaakFolderVtbl = { { 0 }, (FARPROC)FakeHijaak_GetAttributesOf };

const LPVOID c_FakeHijaakFolder = (const LPVOID)&c_FakeHijaakFolderVtbl;

//
//  End of the Hijaak Hack
//
//************

#endif // _X86_

CBackgroundDefviewInfo::CBackgroundDefviewInfo(LPCITEMIDLIST pidl, UINT uId) :
    _pidl(pidl), _uId(uId)
{

}
CBackgroundDefviewInfo::~CBackgroundDefviewInfo (void)
{
    ILFree(const_cast<LPITEMIDLIST>(_pidl));
}

CBackgroundColInfo::CBackgroundColInfo(LPCITEMIDLIST pidl, UINT uId, UINT uiCol, STRRET& strRet) :
    CBackgroundDefviewInfo(pidl, uId),
    _uiCol(uiCol)
{
    StrRetToBuf(&strRet, NULL, const_cast<TCHAR*>(_szText), ARRAYSIZE(_szText));
}

CBackgroundColInfo::~CBackgroundColInfo(void)
{
}

// Takes ownership of pidl, copies rguColumns.
CBackgroundTileInfo::CBackgroundTileInfo(LPCITEMIDLIST pidl, UINT uId, UINT rguColumns[], UINT cColumns) :
    CBackgroundDefviewInfo(pidl, uId),
    _cColumns(cColumns)
{
    ASSERT(cColumns <= ARRAYSIZE(_rguColumns));

    for (UINT i = 0; (i < cColumns) && (i < ARRAYSIZE(_rguColumns)); i++)
        _rguColumns[i] = rguColumns[i];
}

CBackgroundTileInfo::~CBackgroundTileInfo(void)
{
}

// Helper function that scales the given size by some percentage where the percentage
// is defined in the resources for the localizers to adjust as approp.  Range is 0 to 30% larger
INT ScaleSizeBasedUponLocalization (INT iSize)
{
    TCHAR szPercentageIncrease[3];
    INT iReturnValue = iSize;
    INT iPercentageIncrease;


    if (iSize > 0)
    {
        if (LoadString(HINST_THISDLL, IDS_SIZE_INCREASE_PERCENTAGE, szPercentageIncrease, ARRAYSIZE(szPercentageIncrease)))
        {
            iPercentageIncrease = StrToInt(szPercentageIncrease);

            if (iPercentageIncrease > 0)
            {
                if (iPercentageIncrease > 30)
                {
                    iPercentageIncrease = 30;
                }

                iReturnValue += ((iPercentageIncrease * iSize) / 100);
            }
        }
    }

    return iReturnValue;
}

CBackgroundGroupInfo::CBackgroundGroupInfo (LPCITEMIDLIST pidl, UINT uId, DWORD dwGroupId):
    CBackgroundDefviewInfo(pidl, uId), _dwGroupId(dwGroupId)
{

}

BOOL CBackgroundGroupInfo::VerifyGroupExists(HWND hwnd, ICategorizer* pcat)
{
    if (!pcat)
        return FALSE;

    if (!ListView_HasGroup(hwnd, _dwGroupId))
    {
        CATEGORY_INFO ci;
        pcat->GetCategoryInfo(_dwGroupId, &ci);

        LVINSERTGROUPSORTED igrp;
        igrp.pfnGroupCompare = GroupCompare;
        igrp.pvData = (void *)pcat;
        igrp.lvGroup.cbSize = sizeof(LVGROUP);
        igrp.lvGroup.mask = LVGF_HEADER | LVGF_GROUPID;
        igrp.lvGroup.pszHeader= ci.wszName;
        igrp.lvGroup.iGroupId = (int)_dwGroupId;

        ListView_InsertGroupSorted(hwnd, &igrp);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\defview.h ===
#ifndef _DEFVIEW_H
#define _DEFVIEW_H


// Private window messages
#define WM_DSV_FSNOTIFY                 (WM_USER+0xA0)
#define WM_DSV_BACKGROUNDENUMDONE       (WM_USER+0xA2)
#define WM_DSV_UPDATEICON               (WM_USER+0xA3)
#define WM_DSV_SHOWDRAGIMAGE            (WM_USER+0xA4)
#define WM_DSV_DISABLEACTIVEDESKTOP     (WM_USER+0xA6)
#define WM_DSV_REARRANGELISTVIEW        (WM_USER+0xA7)
#define WM_DSV_SENDSELECTIONCHANGED     (WM_USER+0xA8)
#define WM_DSV_UPDATECOLDATA            (WM_USER+0xA9)
#define WM_DSV_UPDATEOVERLAY            (WM_USER+0xAB)
#define WM_DSV_DESKHTML_CHANGES         (WM_USER+0xAC)
#define WM_DSV_FILELISTENUMDONE         (WM_USER+0xAD)
#define WM_DSV_DELAYWINDOWCREATE        (WM_USER+0xAE)
#define WM_DSV_DELAYSTATUSBARUPDATE     (WM_USER+0xAF)
#define WM_DSV_STARTPAGE_TURNONOFF      (WM_USER+0xB0)
#define WM_DSV_UPDATETHUMBNAIL          (WM_USER+0xB1)
#define WM_DSV_DELAYED_DESTROYWND       (WM_USER+0xB2)
#define WM_DSV_DELAYINFOTIP             (WM_USER+0xB3)
#define WM_DSV_GROUPINGDONE             (WM_USER+0xB4)
#define WM_DSV_SENDNOITEMSTATECHANGED   (WM_USER+0xB5)
#define WM_DSV_ADJUSTRECYCLEBINPOSITION (WM_USER+0xB6)
#define WM_DSV_ENSURE_COLUMNS_LOADED    (WM_USER+0xB7)
#define WM_DSV_SETIMPORTANTCOLUMNS      (WM_USER+0xB8)
// reuse                                (WM_USER+0xB9)
#define WM_DSV_SETITEMGROUP             (WM_USER+0xBA)
#define WM_DSV_FILELISTFILLDONE         (WM_USER+0xBB)
#define WM_DSV_POSTCREATEINFOTIP        (WM_USER+0xBC)

typedef struct
{
    int          iImage;
    int          iItem;
    LPITEMIDLIST pidl;
}DSV_UPDATETHUMBNAIL; 

#define MAX_EXT_VIEWS                   (SFVIDM_VIEW_EXTLAST - SFVIDM_VIEW_EXTFIRST + 1)



///// help string ids

#define SFVIDS_MH_FIRST                 (IDS_MH_SFVIDM_FIRST - SFVIDM_FIRST)

#define SFVIDS_MH_FILE_LINK             (SFVIDS_MH_FIRST + SFVIDM_FILE_LINK)
#define SFVIDS_MH_FILE_DELETE           (SFVIDS_MH_FIRST + SFVIDM_FILE_DELETE)
#define SFVIDS_MH_FILE_RENAME           (SFVIDS_MH_FIRST + SFVIDM_FILE_RENAME)
#define SFVIDS_MH_FILE_PROPERTIES       (SFVIDS_MH_FIRST + SFVIDM_FILE_PROPERTIES)

#define SFVIDS_MH_EDIT_UNDO             (SFVIDS_MH_FIRST + SFVIDM_EDIT_UNDO)
#define SFVIDS_MH_EDIT_CUT              (SFVIDS_MH_FIRST + SFVIDM_EDIT_CUT)
#define SFVIDS_MH_EDIT_COPY             (SFVIDS_MH_FIRST + SFVIDM_EDIT_COPY)
#define SFVIDS_MH_EDIT_PASTE            (SFVIDS_MH_FIRST + SFVIDM_EDIT_PASTE)
#define SFVIDS_MH_EDIT_PASTELINK        (SFVIDS_MH_FIRST + SFVIDM_EDIT_PASTELINK)
#define SFVIDS_MH_EDIT_PASTESPECIAL     (SFVIDS_MH_FIRST + SFVIDM_EDIT_PASTESPECIAL)
#define SFVIDS_MH_EDIT_COPYTO           (SFVIDS_MH_FIRST + SFVIDM_EDIT_COPYTO)
#define SFVIDS_MH_EDIT_MOVETO           (SFVIDS_MH_FIRST + SFVIDM_EDIT_MOVETO)

#define SFVIDS_MH_MENU_SELECT           (SFVIDS_MH_FIRST + SFVIDM_MENU_SELECT)
#define SFVIDS_MH_SELECT_ALL            (SFVIDS_MH_FIRST + SFVIDM_SELECT_ALL)
#define SFVIDS_MH_SELECT_INVERT         (SFVIDS_MH_FIRST + SFVIDM_SELECT_INVERT)

#define SFVIDS_MH_MENU_VIEW             (SFVIDS_MH_FIRST + SFVIDM_MENU_VIEW)
#define SFVIDS_MH_VIEW_ICON             (SFVIDS_MH_FIRST + SFVIDM_VIEW_ICON)
#define SFVIDS_MH_VIEW_TILE             (SFVIDS_MH_FIRST + SFVIDM_VIEW_TILE)
#define SFVIDS_MH_VIEW_THUMBNAILS       (SFVIDS_MH_FIRST + SFVIDM_VIEW_THUMBNAIL)
#define SFVIDS_MH_VIEW_THUMBSTRIP       (SFVIDS_MH_FIRST + SFVIDM_VIEW_THUMBSTRIP)
#define SFVIDS_MH_VIEW_SMALLICON        (SFVIDS_MH_FIRST + SFVIDM_VIEW_SMALLICON)
#define SFVIDS_MH_VIEW_LIST             (SFVIDS_MH_FIRST + SFVIDM_VIEW_LIST)
#define SFVIDS_MH_VIEW_DETAILS          (SFVIDS_MH_FIRST + SFVIDM_VIEW_DETAILS)
#define SFVIDS_MH_VIEW_PAGE             (SFVIDS_MH_FIRST + SFVIDM_VIEW_PAGE)
#define SFVIDS_MH_VIEW_OPTIONS          (SFVIDS_MH_FIRST + SFVIDM_VIEW_OPTIONS)
#define SFVIDS_MH_VIEW_CUSTOMWIZARD     (SFVIDS_MH_FIRST + SFVIDM_VIEW_CUSTOMWIZARD)
#define SFVIDS_MH_VIEW_COLUMNSETTINGS   (SFVIDS_MH_FIRST + SFVIDM_VIEW_COLSETTINGS)

#define SFVIDS_MH_MENU_ARRANGE          (SFVIDS_MH_FIRST + SFVIDM_MENU_ARRANGE)
#define SFVIDS_MH_ARRANGE_AUTO          (SFVIDS_MH_FIRST + SFVIDM_ARRANGE_AUTO)
#define SFVIDS_MH_ARRANGE_AUTOGRID      (SFVIDS_MH_FIRST + SFVIDM_ARRANGE_AUTOGRID)

#define SFVIDS_MH_TOOL_CONNECT          (SFVIDS_MH_FIRST + SFVIDM_TOOL_CONNECT)
#define SFVIDS_MH_TOOL_DISCONNECT       (SFVIDS_MH_FIRST + SFVIDM_TOOL_DISCONNECT)
#define SFVIDS_MH_HELP_TOPIC            (SFVIDS_MH_FIRST + SFVIDM_HELP_TOPIC)
#define SFVIDS_MH_GROUPBY               (SFVIDS_MH_FIRST + SFVIDM_GROUPBY)


//tool tips
#define IDS_TT_VIEW_ICON                (IDS_TT_SFVIDM_FIRST + SFVIDM_VIEW_ICON)
#define IDS_TT_VIEW_SMALLICON           (IDS_TT_SFVIDM_FIRST + SFVIDM_VIEW_SMALLICON)
#define IDS_TT_VIEW_LIST                (IDS_TT_SFVIDM_FIRST + SFVIDM_VIEW_LIST)
#define IDS_TT_VIEW_DETAILS             (IDS_TT_SFVIDM_FIRST + SFVIDM_VIEW_DETAILS)
#define IDS_TT_VIEW_PAGE                (IDS_TT_SFVIDM_FIRST + SFVIDM_VIEW_PAGE)
#define IDS_TT_VIEW_VIEWMENU            (IDS_TT_SFVIDM_FIRST + SFVIDM_VIEW_VIEWMENU)

#define IDS_TT_TOOL_CONNECT             (IDS_TT_SFVIDM_FIRST + SFVIDM_TOOL_CONNECT)
#define IDS_TT_TOOL_DISCONNECT          (IDS_TT_SFVIDM_FIRST + SFVIDM_TOOL_DISCONNECT)

#define IDS_TT_EDIT_CUT                 (IDS_TT_SFVIDM_FIRST + SFVIDM_EDIT_CUT)
#define IDS_TT_EDIT_COPY                (IDS_TT_SFVIDM_FIRST + SFVIDM_EDIT_COPY)
#define IDS_TT_EDIT_PASTE               (IDS_TT_SFVIDM_FIRST + SFVIDM_EDIT_PASTE)
#define IDS_TT_EDIT_UNDO                (IDS_TT_SFVIDM_FIRST + SFVIDM_EDIT_UNDO)
#define IDS_TT_FILE_DELETE              (IDS_TT_SFVIDM_FIRST + SFVIDM_FILE_DELETE)
#define IDS_TT_FILE_PROPERTIES          (IDS_TT_SFVIDM_FIRST + SFVIDM_FILE_PROPERTIES)


#define DIEC_BACKGROUNDCONTEXT   1
#define DIEC_SELECTIONCONTEXT    2

#endif // _DEFVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\defviewlegacy.cpp ===
#include "shellprv.h"
#include <sfview.h>
#include "defviewp.h"

int CGenList::Add(LPVOID pv, int nInsert)
{
    if (!_hList)
    {
        _hList = DSA_Create(_cbItem, 8);
        if (!_hList)
        {
            return -1;
        }
    }
    return DSA_InsertItem(_hList, nInsert, pv);
}


int CViewsList::Add(const SFVVIEWSDATA*pView, int nInsert, BOOL bCopy)
{
    if (bCopy)
    {
        pView = CopyData(pView);
        if (!pView)
        {
            return -1;
        }
    }

    int iIndex = CGenList::Add((LPVOID)(&pView), nInsert);

    if (bCopy && iIndex<0)
    {
        SHFree((LPVOID)pView);
    }

    return iIndex;
}


void CViewsList::Empty()
{
    _bGotDef = FALSE;

    for (int i=GetItemCount()-1; i>=0; --i)
    {
        SFVVIEWSDATA  *sfvData = GetPtr(i);
        
        ASSERT(sfvData);
        if (sfvData->dwFlags & SFVF_CUSTOMIZEDVIEW)
        {
            CUSTOMVIEWSDATA  *pCustomPtr = sfvData->pCustomData;
            if (pCustomPtr)
            {
                if (pCustomPtr->lpDataBlock)
                    SHFree(pCustomPtr->lpDataBlock);
                SHFree(pCustomPtr);
            }
        }
        SHFree(sfvData);
    }

    CGenList::Empty();
}


SFVVIEWSDATA* CViewsList::CopyData(const SFVVIEWSDATA* pData)
{
    SFVVIEWSDATA* pCopy = (SFVVIEWSDATA*)SHAlloc(sizeof(SFVVIEWSDATA));
    if (pCopy)
    {
        memcpy(pCopy, pData, sizeof(SFVVIEWSDATA));
        if ((pData->dwFlags & SFVF_CUSTOMIZEDVIEW) && pData->pCustomData)
        {
            CUSTOMVIEWSDATA *pCustomData = (CUSTOMVIEWSDATA *)SHAlloc(sizeof(CUSTOMVIEWSDATA));
            if (pCustomData)
            {
                memcpy(pCustomData, pData->pCustomData, sizeof(CUSTOMVIEWSDATA));
                pCopy->pCustomData = pCustomData;

                if (pCustomData->lpDataBlock)
                {
                    // NOTE: DataBlock size is in WCHARs
                    LPWSTR lpDataBlock = (LPWSTR)SHAlloc(pCustomData->cchSizeOfBlock * sizeof(WCHAR));
                    if (lpDataBlock)
                    {
                        // NOTE: DataBlock size is in WCHARs
                        memcpy(lpDataBlock, pCustomData->lpDataBlock, pCustomData->cchSizeOfBlock * sizeof(WCHAR));
                        pCustomData->lpDataBlock = lpDataBlock;
                    }
                    else
                    {
                        SHFree(pCustomData);
                        goto Failed;
                    }
                }
            }
            else
            {
Failed:
                SHFree(pCopy);
                pCopy = NULL;
            }
        }
    }

    return pCopy;
}


int CViewsList::NextUnique(int nLast)
{
    for (int nNext = nLast + 1; ; ++nNext)
    {
        SFVVIEWSDATA* pItem = GetPtr(nNext);
        if (!pItem)
        {
            break;
        }

        for (int nPrev=nNext-1; nPrev>=0; --nPrev)
        {
            SFVVIEWSDATA*pPrev = GetPtr(nPrev);
            if (pItem->idView == pPrev->idView)
            {
                break;
            }
        }

        if (nPrev < 0)
        {
            return nNext;
        }
    }

    return -1;
}


void CCallback::_GetExtViews(BOOL bForce)
{
    CDefView* pView = IToClass(CDefView, _cCallback, this);

    IEnumSFVViews *pev = NULL;

    if (bForce)
    {
        _bGotViews = FALSE;
    }

    if (_bGotViews)
    {
        return;
    }

    _lViews.Empty();

    SHELLVIEWID vid = VID_LargeIcons;
    if (FAILED(pView->CallCB(SFVM_GETVIEWS, (WPARAM)&vid, (LPARAM)&pev)) ||
        !pev)
    {
        return;
    }

    _lViews.SetDef(&vid);

    SFVVIEWSDATA *pData;
    ULONG uFetched;

    while ((pev->Next(1, &pData, &uFetched) == S_OK) && (uFetched == 1))
    {
        // The list comes to us in general to specific order, but we want
        // to search it in specific->general order. Inverting the list
        // is easiest here, even though it causes a bunch of memcpy calls.
        //
        _lViews.Prepend(pData, FALSE);
    }

    ATOMICRELEASE(pev);

    _bGotViews = TRUE;
}


HRESULT CCallback::TryLegacyGetViews(SFVM_WEBVIEW_TEMPLATE_DATA* pvit)
{
    CDefView* pView = IToClass(CDefView, _cCallback, this);
    HRESULT hr = E_FAIL;

    CLSID clsid;
    HRESULT hr2 = IUnknown_GetClassID(pView->_pshf, &clsid);
    if (FAILED(hr2) || !(SHGetObjectCompatFlags(NULL, &clsid) & OBJCOMPATF_NOLEGACYWEBVIEW))
    {
        _GetExtViews(FALSE);
        if (_bGotViews)
        {
            SFVVIEWSDATA* pItem;
            GetViewIdFromGUID(&VID_WebView, &pItem);
            if (pItem)
            {
                hr = StringCchCopyW(pvit->szWebView, ARRAYSIZE(pvit->szWebView), pItem->wszMoniker);
            }
        }
        else if (SUCCEEDED(hr2))
        {
            // check for PersistMoniker under isf's coclass (Web Folders used this in W2K to get .htt Web View)
            WCHAR szCLSID[GUIDSTR_MAX];
            if (SHStringFromGUID(clsid, szCLSID, ARRAYSIZE(szCLSID)))
            {
                WCHAR wszSubKey[MAX_PATH];
                hr = StringCchPrintf(wszSubKey, ARRAYSIZE(wszSubKey), L"CLSID\\%s\\shellex\\ExtShellFolderViews\\{5984FFE0-28D4-11CF-AE66-08002B2E1262}", szCLSID);
                if (SUCCEEDED(hr))
                {
                    DWORD cbSize = sizeof(pvit->szWebView);
                    hr = ResultFromWin32(SHRegGetValueW(HKEY_CLASSES_ROOT, wszSubKey, L"PersistMoniker", SRRF_RT_REG_SZ, NULL, pvit->szWebView, &cbSize));
                }
            }
        }
    }

    return hr;
}

HRESULT CCallback::OnRefreshLegacy(void* pv, BOOL fPrePost)
{
    // If we're using the SFVM_GETVIEWS layer, invalidate it
    if (_bGotViews)
    {
        _lViews.Empty();
        _bGotViews = FALSE;
    }

    return S_OK;
}

int CCallback::GetViewIdFromGUID(SHELLVIEWID const *pvid, SFVVIEWSDATA** ppItem)
{
    int iView = -1;
    for (UINT uView=0; uView<MAX_EXT_VIEWS; ++uView)
    {
        iView = _lViews.NextUnique(iView);

        SFVVIEWSDATA* pItem = _lViews.GetPtr(iView);
        if (!pItem)
        {
            break;
        }

        if (*pvid == pItem->idView)
        {
            if (ppItem)
                *ppItem = pItem;

            return (int)uView;
        }
    }

    if (ppItem)
        *ppItem = NULL;
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\defviewcoldlg.cpp ===
#include "shellprv.h"
#include "defviewp.h"
#include "ids.h"

CColumnDlg::CColumnDlg(CDefView *pdsv) : 
    _pdsv(pdsv), _bChanged(FALSE), _pdwOrder(NULL), _pWidths(NULL), _bLoaded(FALSE), _bUpdating(FALSE), _ppui(NULL)
{
    _cColumns = _pdsv->_vs.GetColumnCount();
}

CColumnDlg::~CColumnDlg()
{
    if (_pdwOrder)
        LocalFree(_pdwOrder);
    if (_pWidths)
        LocalFree(_pWidths);

    if (_ppui)
        _ppui->Release();
}

HRESULT CColumnDlg::ShowDialog(HWND hwnd)
{
    _bChanged = FALSE;      // We are on the stack, so no zero allocator

    _pdwOrder = (UINT *) LocalAlloc(LPTR, sizeof(*_pdwOrder) * _cColumns);   // total columns
    _pWidths = (int *) LocalAlloc(LPTR, sizeof(*_pWidths) * _cColumns);      // total columns
    if (_pdwOrder && _pWidths)
    {
        DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_COLUMN_SETTINGS), hwnd, s_DlgProc, (LPARAM)this);
        return S_OK;
    } 
    return E_OUTOFMEMORY;
}

// Remember, each column is identified in 3 ways...
//   1. A 'real' column number, the ordinal out of all possible columns
//   2. A 'visible' column number, the index to this column in the listview
//   3. A 'column order #', the position in the header's columnorderarray

void CColumnDlg::_OnInitDlg()
{
    // Fill in order array with visible columns, and set up inverse table
    UINT cVisible = _pdsv->_RealToVisibleCol(-1) + 1;  // count

    ListView_GetColumnOrderArray(_pdsv->_hwndListview, cVisible, _pdwOrder);
    UINT *pOrderInverse = (UINT *)LocalAlloc(LPTR, sizeof(*pOrderInverse) * cVisible);
    if (pOrderInverse)
    {
        for (UINT i = 0; i < cVisible; i++)
            pOrderInverse[_pdwOrder[i]] = i;

        _hwndLVAll = GetDlgItem(_hdlg, IDC_COL_LVALL);
   
        ListView_SetExtendedListViewStyle(_hwndLVAll, LVS_EX_CHECKBOXES);

        LV_COLUMN lvc = {0};
        lvc.mask = (LVCF_FMT | LVCF_SUBITEM);
        lvc.fmt = LVCFMT_LEFT;
        ListView_InsertColumn(_hwndLVAll, 0, &lvc);

        LV_ITEM lvi = {0};
        lvi.mask = LVIF_TEXT;
    
        // Add entry for each column (except non-UI columns)
        for (i = 0; i < (int)_cColumns; i++)
        {
            if (!_pdsv->_IsColumnHidden(i))  // Don't put in entries for hidden columns
            {
                lvi.iItem = i;
                lvi.pszText = LPSTR_TEXTCALLBACK;
                ListView_InsertItem(_hwndLVAll, &lvi);
            }        
        }

        lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
        // set the visible columns
        for (i = 0; i < (int) cVisible; i++)
        {
            UINT iReal = _pdsv->_VisibleToRealCol(i);

            lvi.pszText = _pdsv->_vs.GetColumnName(iReal);
            lvi.state = INDEXTOSTATEIMAGEMASK(_pdsv->_IsDetailsColumn(iReal) ? 2 : 1);  // on check mark (or off for tileview columns)
            lvi.stateMask = LVIS_STATEIMAGEMASK;
            lvi.lParam = iReal;                         // store the real col index in the lParam
            lvi.iItem = pOrderInverse[i];
            ListView_SetItem(_hwndLVAll, &lvi);

            // Get the column width from the view's listview
            _pWidths[iReal] = ListView_GetColumnWidth(_pdsv->_hwndListview, i);
        }

        UINT iItem = cVisible;
        for (i = 0; i < (int)_cColumns; i++)
        {
            if (!_pdsv->_IsColumnInListView(i) && !_pdsv->_IsColumnHidden(i))
            {
                lvi.pszText = _pdsv->_vs.GetColumnName(i);
                lvi.state = INDEXTOSTATEIMAGEMASK(1);   // off check mark
                lvi.stateMask = LVIS_STATEIMAGEMASK;
                lvi.lParam = i;
                lvi.iItem = iItem;
                ListView_SetItem(_hwndLVAll, &lvi);

                iItem++;

                // get the default width we've got saved away
                _pWidths[i] = _pdsv->_vs.GetColumnCharCount(i) * _pdsv->_cxChar;
            }
        }

        // set the size properly
        ListView_SetColumnWidth(_hwndLVAll, 0, LVSCW_AUTOSIZE);

        ListView_SetItemState(_hwndLVAll, 0, LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
        LocalFree(pOrderInverse);

        _bLoaded = TRUE;
    }
    SendDlgItemMessage(_hdlg, IDC_COL_WIDTH, EM_LIMITTEXT, 3, 0); // 3 digits
}

#define SWAP(x,y) {(x) ^= (y); (y) ^= (x); (x) ^= (y);}

void CColumnDlg::_MoveItem(int iDelta)
{
    int i = ListView_GetSelectionMark(_hwndLVAll);
    if (i != -1)
    {
        int iNew = i + iDelta;
        if (iNew >= 0  && iNew <= (ListView_GetItemCount(_hwndLVAll) - 1))
        {
            LV_ITEM lvi = {0}, lvi2 = {0};
            TCHAR szTmp1[MAX_COLUMN_NAME_LEN], szTmp2[MAX_COLUMN_NAME_LEN];

            _bChanged = TRUE;
            _bUpdating = TRUE;

            lvi.iItem = i;
            lvi.pszText = szTmp1;
            lvi.cchTextMax = ARRAYSIZE(szTmp1);
            lvi.stateMask = LVIS_STATEIMAGEMASK;
            lvi.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
            
            lvi2.iItem = iNew;
            lvi2.pszText = szTmp2;
            lvi2.cchTextMax = ARRAYSIZE(szTmp2);
            lvi2.stateMask = LVIS_STATEIMAGEMASK;
            lvi2.mask = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;

            ListView_GetItem(_hwndLVAll, &lvi);
            ListView_GetItem(_hwndLVAll, &lvi2);

            SWAP(lvi.iItem, lvi2.iItem);

            ListView_SetItem(_hwndLVAll, &lvi);
            ListView_SetItem(_hwndLVAll, &lvi2);

            _bUpdating = FALSE;

            // update selection
            ListView_SetSelectionMark(_hwndLVAll, iNew);
            ListView_SetItemState(_hwndLVAll, iNew , LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);
            // HACK: SetItemState sends notifications for i, iNew, then i again.
            // we need to call it twice in a row, so _UpdateDlgButtons will get the right item
            ListView_SetItemState(_hwndLVAll, iNew , LVIS_FOCUSED|LVIS_SELECTED, LVIS_FOCUSED|LVIS_SELECTED);

            return;
        }
    }
    TraceMsg(TF_WARNING, "ccd.mi couldn't move %d to %d",i, i+iDelta);
    MessageBeep(MB_ICONEXCLAMATION);
}

BOOL CColumnDlg::_SaveState()
{
    // Check order
    if (_bChanged)
    {
        int iOrderIndex = 0;
        LV_ITEM lvi = {0};
        lvi.stateMask = LVIS_STATEIMAGEMASK;
        lvi.mask = LVIF_PARAM | LVIF_STATE;

        int cItems = ListView_GetItemCount(_hwndLVAll); 
        for (int i = 0; i < cItems; i++)
        {
            lvi.iItem = i;
            ListView_GetItem(_hwndLVAll, &lvi);
        
            // toggle it, if the state in the dialog doesn't match the listview state
            if (BOOLIFY(ListView_GetCheckState(_hwndLVAll, i)) != BOOLIFY(_pdsv->_IsDetailsColumn((UINT)lvi.lParam)))
            {
                _pdsv->_HandleColumnToggle((UINT)lvi.lParam, FALSE);
            }
        
            if (_pdsv->_IsColumnInListView((UINT)lvi.lParam))
                _pdwOrder[iOrderIndex++] = (UINT)lvi.lParam; // incorrectly store real (not vis) col #, fix up below
        }
    
        // must be in a separate loop. (can't map real to visible, if we aren't done setting visible)
        for (i = 0; i < iOrderIndex; i++)
        {
            UINT iReal = _pdwOrder[i];
            _pdwOrder[i] = _pdsv->_RealToVisibleCol(iReal);
        
            if (_pWidths[iReal] < 0) // negative width means they edited it
                ListView_SetColumnWidth(_pdsv->_hwndListview, _pdwOrder[i], -_pWidths[iReal]);
        }

        ListView_SetColumnOrderArray(_pdsv->_hwndListview, iOrderIndex, _pdwOrder);

        // kick the listview into repainting everything
        InvalidateRect(_pdsv->_hwndListview, NULL, TRUE);

        _bChanged = FALSE;
    }
    return !_bChanged;
}

BOOL EnableDlgItem(HWND hdlg, UINT idc, BOOL f)
{
    return EnableWindow(GetDlgItem(hdlg, idc), f);
}

void CColumnDlg::_UpdateDlgButtons(NMLISTVIEW *pnmlv)
{
    BOOL bChecked, bOldUpdateState = _bUpdating;
    int iItem = ListView_GetSelectionMark(_hwndLVAll);

    // to disable checking
    _bUpdating = TRUE;
    if (pnmlv->uNewState & LVIS_STATEIMAGEMASK)
        bChecked = (pnmlv->uNewState & LVIS_STATEIMAGEMASK) == (UINT)INDEXTOSTATEIMAGEMASK(2);
    else 
        bChecked = ListView_GetCheckState(_hwndLVAll, pnmlv->iItem);

    EnableDlgItem(_hdlg, IDC_COL_UP, pnmlv->iItem > 0);
    EnableDlgItem(_hdlg, IDC_COL_DOWN, pnmlv->iItem < (int)_cColumns - 1);
    EnableDlgItem(_hdlg, IDC_COL_SHOW, !bChecked && (pnmlv->lParam != 0));
    EnableDlgItem(_hdlg, IDC_COL_HIDE, bChecked && (pnmlv->lParam != 0));

    // update the width edit box
    int iWidth = _pWidths[pnmlv->lParam];
    if (iWidth < 0) 
        iWidth = -iWidth;   // we store negative values to track if it changed or not
    SetDlgItemInt(_hdlg, IDC_COL_WIDTH, iWidth, TRUE);

    _bUpdating = bOldUpdateState;
}

BOOL_PTR CALLBACK CColumnDlg::s_DlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CColumnDlg *pcd = (CColumnDlg*) GetWindowLongPtr(hdlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        pcd = (CColumnDlg *) lParam;
        pcd->_hdlg = hdlg;
        SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR) pcd);
    }

    return pcd ? pcd->DlgProc(uMsg, wParam, lParam) : FALSE;
}

HRESULT CColumnDlg::_GetPropertyUI(IPropertyUI **pppui)
{
    if (!_ppui)
        SHCoCreateInstance(NULL, &CLSID_PropertiesUI, NULL, IID_PPV_ARG(IPropertyUI, &_ppui));

    return _ppui ? _ppui->QueryInterface(IID_PPV_ARG(IPropertyUI, pppui)) : E_NOTIMPL;
}

UINT CColumnDlg::_HelpIDForItem(int iItem, LPTSTR pszHelpFile, UINT cch)
{
    UINT uHelpID = 0;
    *pszHelpFile = 0;

    LV_ITEM lvi = {0};
    lvi.iItem = iItem;
    lvi.mask = LVIF_PARAM;
    if (ListView_GetItem(_hwndLVAll, &lvi))
    {
        IShellFolder2 *psf;
        if (SUCCEEDED(_pdsv->GetFolder(IID_PPV_ARG(IShellFolder2, &psf))))
        {
            SHCOLUMNID scid;
            if (SUCCEEDED(psf->MapColumnToSCID(lvi.lParam, &scid)))
            {
                IPropertyUI *ppui;
                if (SUCCEEDED(_GetPropertyUI(&ppui)))
                {
                    ppui->GetHelpInfo(scid.fmtid, scid.pid, pszHelpFile, cch, &uHelpID);
                    ppui->Release();
                }
            }
            psf->Release();
        }
    }
    return uHelpID;  // IDH_ values
}

 
const static DWORD c_rgColumnDlgHelpIDs[] = 
{
    IDC_COL_UP,         1,
    IDC_COL_DOWN,       1,
    IDC_COL_SHOW,       1,
    IDC_COL_HIDE,       1,
    IDC_COL_WIDTH,      10055,
    IDC_COL_WIDTH_TEXT, 10055,
    0, 0
};
       
BOOL_PTR CColumnDlg::DlgProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        _OnInitDlg();
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDC_COL_UP:
            _MoveItem(- 1);
            SetFocus(_hwndLVAll);
            break;

        case IDC_COL_DOWN:
            _MoveItem(+ 1);
            SetFocus(_hwndLVAll);
            break;

        case IDC_COL_SHOW:
        case IDC_COL_HIDE:
        {
            UINT iItem = ListView_GetSelectionMark(_hwndLVAll);
            ListView_SetCheckState(_hwndLVAll, iItem, LOWORD(wParam) == IDC_COL_SHOW);
            SetFocus(_hwndLVAll);
            break;
        }

        case IDC_COL_WIDTH:
            if (HIWORD(wParam) == EN_CHANGE && !_bUpdating)
            {
                LV_ITEM lvi = {0};
                lvi.iItem = ListView_GetSelectionMark(_hwndLVAll);
                lvi.mask = LVIF_PARAM;
                ListView_GetItem(_hwndLVAll, &lvi);

                _pWidths[lvi.lParam] = - (int)GetDlgItemInt(_hdlg, IDC_COL_WIDTH, NULL, FALSE);
                _bChanged = TRUE;
            }
            break;

        case IDOK:
            _SaveState(); 

            // fall through

        case IDCANCEL:
            return EndDialog(_hdlg, TRUE);
        }
        break;

    case WM_NOTIFY:
        if (_bLoaded && !_bUpdating)
        {
            NMLISTVIEW * pnmlv = (NMLISTVIEW *)lParam;
            switch (((NMHDR *)lParam)->code)
            {
            case LVN_ITEMCHANGING:

                // fix up the buttons & such here
                if (pnmlv->uChanged & LVIF_STATE)
                    _UpdateDlgButtons(pnmlv);

                // We want to reject turning off the name column
                // it both doesn't make sense to have no name column, and defview assumes there will be one
                if (pnmlv->lParam == 0 &&
                    (pnmlv->uNewState & LVIS_STATEIMAGEMASK) == INDEXTOSTATEIMAGEMASK(1))
                {
                    MessageBeep(MB_ICONEXCLAMATION);
                    SetWindowLongPtr(_hdlg, DWLP_MSGRESULT, TRUE);
                    return TRUE;
                }
                else
                {
                    // if something besides focus changed
                    if ((pnmlv->uChanged & ~LVIF_STATE) ||
                        ((pnmlv->uNewState & LVIS_STATEIMAGEMASK) != (pnmlv->uOldState & LVIS_STATEIMAGEMASK)))
                    _bChanged = TRUE;
                }
                break;

            case NM_DBLCLK:
                {
                    BOOL bCheck = ListView_GetCheckState(_hwndLVAll, pnmlv->iItem);
                    ListView_SetCheckState(_hwndLVAll, pnmlv->iItem, !bCheck);
                }
                break;
            }
        }
        break;

    case WM_SYSCOLORCHANGE:
        SendMessage(_hwndLVAll, uMsg, wParam, lParam);
        break;

    case WM_HELP:                   // F1
        {
            HELPINFO *phi = (HELPINFO *)lParam;

            //if the help is for one of the command buttons then call winhelp 
            if (phi->iCtrlId == IDC_COL_LVALL)
            {
                //Help is for the tree item so we need to do some special processing
                
                int iItem;

                // Is this help invoked throught F1 key
                if (GetAsyncKeyState(VK_F1) < 0)                
                {
                    iItem = ListView_GetSelectionMark(_hwndLVAll);
                }
                else 
                {
                    LV_HITTESTINFO info;
                    info.pt = phi->MousePos;
                    ScreenToClient(_hwndLVAll, &info.pt);
                    iItem = ListView_HitTest(_hwndLVAll, &info);
                }

                if (iItem >= 0)
                {
                    DWORD mapIDCToIDH[4] = {0};
                    TCHAR szFile[MAX_PATH];
        
                    mapIDCToIDH[0] = phi->iCtrlId;
                    mapIDCToIDH[1] = _HelpIDForItem(iItem, szFile, ARRAYSIZE(szFile));

                    WinHelp((HWND)((HELPINFO *)lParam)->hItemHandle, szFile[0] ? szFile : NULL,
                                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCToIDH);
                }
            }
            else
            {
                WinHelp((HWND)((HELPINFO *)lParam)->hItemHandle, TEXT(SHELL_HLP),
                             HELP_WM_HELP, (DWORD_PTR)(LPSTR)c_rgColumnDlgHelpIDs);
            }
            break; 
        }

    case WM_CONTEXTMENU:
        {
            int iItem;

            if ((LPARAM)-1 == lParam)
            {
                iItem = ListView_GetSelectionMark(_hwndLVAll);
            }
            else
            {
                LV_HITTESTINFO info;
                info.pt.x = GET_X_LPARAM(lParam);
                info.pt.y = GET_Y_LPARAM(lParam);
                ScreenToClient(_hwndLVAll, &info.pt);
                iItem = ListView_HitTest(_hwndLVAll, &info);
            }

            if (iItem >= 0)
            {
                DWORD mapIDCToIDH[4] = {0};
    
                TCHAR szFile[MAX_PATH];
                mapIDCToIDH[0] = IDC_COL_LVALL;
                mapIDCToIDH[1] = _HelpIDForItem(iItem, szFile, ARRAYSIZE(szFile)); // IDH_ values

                WinHelp((HWND)wParam, szFile[0] ? szFile : NULL, HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCToIDH);
            }
            break; 
        }

    default:
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\defvphst.h ===
#include <perhist.h>
#include "cowsite.h"

//----------------------------------------------------------------------
// Class to save and restore find state on the travel log 
class CDefViewPersistHistory : public IPersistHistory,
                               public CObjectWithSite, 
                               public IOleObject

{
public:
    CDefViewPersistHistory();
    ~CDefViewPersistHistory();

    // *** IUnknown Methhods ***
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // Support added to allow search results to serialize 
    // *** IPersist methods ***
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // *** IPersistHistory methods ***
    STDMETHOD(LoadHistory)(IStream *pStream, IBindCtx *pbc);
    STDMETHOD(SaveHistory)(IStream *pStream);
    STDMETHOD(SetPositionCookie)(DWORD dwPositioncookie);
    STDMETHOD(GetPositionCookie)(DWORD *pdwPositioncookie);

    // *** IOleObject methods ***
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);
    STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite);
    STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    STDMETHOD(Close)(DWORD dwSaveOption);
    STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker *pmk);
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
    STDMETHOD(InitFromData)(IDataObject *pDataObject,BOOL fCreation,DWORD dwReserved);
    STDMETHOD(GetClipboardData)(DWORD dwReserved,IDataObject **ppDataObject);
    STDMETHOD(DoVerb)(LONG iVerb,LPMSG lpmsg,IOleClientSite *pActiveSite,LONG lindex,HWND hwndParent,LPCRECT lprcPosRect);
    STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb);
    STDMETHOD(Update)(void);
    STDMETHOD(IsUpToDate)(void);
    STDMETHOD(GetUserClassID)(CLSID *pClsid);
    STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType);
    STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection);
    STDMETHOD(Unadvise)(DWORD dwConnection);
    STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise);
    STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus);
    STDMETHOD(SetColorScheme)(LOGPALETTE *pLogpal);

protected:

    LONG                m_cRef;                   // reference count
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\defviewp.h ===
#ifndef _DEFVIEWP_H_
#define _DEFVIEWP_H_

#include "defview.h"
#include <mshtmhst.h>
#include "urlmon.h"
#include <perhist.h>
#include "inetsmgr.h"
#include <cowsite.h>
#include "ViewState.h"
#include "webvw.h"
#include "runtask.h"
#include "enumuicommand.h"
#include "tlist.h"

// not used in any of our ISF implementations, but needed for legacy ISF implementations
#include "defviewlegacy.h"

class CBackgroundInfoTip;   // Used for the background processing of InfoTips
class CDefview;

class CDVDropTarget // dvdt
{        
public:
    HRESULT DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);
    HRESULT DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);
    HRESULT DragLeave();
    HRESULT Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    void LeaveAndReleaseData();
    void ReleaseDataObject();
    void ReleaseCurrentDropTarget();

    IDataObject *       _pdtobj;         // from DragEnter()/Drop()
    RECT                _rcLockWindow;   // WindowRect of hwnd for DAD_ENTER
    int                 _itemOver;       // item we are visually dragging over
    BOOL                _fItemOverNotADropTarget; // the item we are currently dragging over was found not to be a drop target
    BOOL                _fIgnoreSource;  // drag is coming from webview / active desktop
    IDropTarget *       _pdtgtCur;       // current drop target, derived from hit testing
    DWORD               _dwEffectOut;    // last *pdwEffect out
    DWORD               _grfKeyState;    // cached key state
    POINT               _ptLast;         // last dragged position
    AUTO_SCROLL_DATA    _asd;            // for auto scrolling
    DWORD               _dwLastTime;     // for auto-opening folders
};

//
//  This is a proxy IDropTarget object, which wraps Trident's droptarget.
//
class CHostDropTarget : public IDropTarget
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    IDropTarget* _pdtFrame; // Drop target of the frame
};


class CSFVSite : public IOleInPlaceSite,
                 public IOleClientSite,
                 public IOleDocumentSite,
                 public IServiceProvider,
                 public IOleCommandTarget,
                 public IDocHostUIHandler,
                 public IOleControlSite,
                 public IInternetSecurityManager,
                 public IDispatch       //For ambient properties.
{
    friend CHostDropTarget;
public:
    CSFVSite()  { ASSERT(_peds == NULL); }
    ~CSFVSite() {
                    if (_peds) {
                        _peds->Release();
                        _peds = NULL;
                    }
                }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND *phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // IOleInPlaceSite
    STDMETHODIMP CanInPlaceActivate(void);
    STDMETHODIMP OnInPlaceActivate(void);
    STDMETHODIMP OnUIActivate(void);
    STDMETHODIMP GetWindowContext(
        IOleInPlaceFrame **ppFrame,
        IOleInPlaceUIWindow **ppDoc,
        LPRECT lprcPosRect,
        LPRECT lprcClipRect,
        LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHODIMP Scroll(SIZE scrollExtant);
    STDMETHODIMP OnUIDeactivate(BOOL fUndoable);
    STDMETHODIMP OnInPlaceDeactivate(void);
    STDMETHODIMP DiscardUndoState(void);
    STDMETHODIMP DeactivateAndUndo(void);
    STDMETHODIMP OnPosRectChange(LPCRECT lprcPosRect);

    // IOleClientSite
    STDMETHODIMP SaveObject(void);

    STDMETHODIMP GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);

    STDMETHODIMP GetContainer(IOleContainer **ppContainer);
    STDMETHODIMP ShowObject(void);
    STDMETHODIMP OnShowWindow(BOOL fShow);
    STDMETHODIMP RequestNewObjectLayout(void);

    // IOleDocumentSite
    STDMETHODIMP ActivateMe(IOleDocumentView *pviewToActivate);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IOleControlSite
    STDMETHODIMP OnControlInfoChanged() { return E_NOTIMPL; };
    STDMETHODIMP LockInPlaceActive(BOOL fLock) { return E_NOTIMPL; };
    STDMETHODIMP GetExtendedControl(IDispatch **ppDisp) { *ppDisp = NULL; return E_NOTIMPL; };
    STDMETHODIMP TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer,DWORD dwFlags) { return E_NOTIMPL; };
    STDMETHODIMP TranslateAccelerator(MSG *pMsg,DWORD grfModifiers);

    STDMETHODIMP OnFocus(BOOL fGotFocus) { return E_NOTIMPL; };
    STDMETHODIMP ShowPropertyFrame(void) { return E_NOTIMPL; };

    // IDocHostUIHandler
    STDMETHODIMP ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
    STDMETHODIMP GetHostInfo(DOCHOSTUIINFO *pInfo);
    STDMETHODIMP ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject,
        IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame,
        IOleInPlaceUIWindow *pDoc);
    STDMETHODIMP HideUI(void);
    STDMETHODIMP UpdateUI(void);
    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP OnDocWindowActivate(BOOL fActivate);
    STDMETHODIMP OnFrameWindowActivate(BOOL fActivate);
    STDMETHODIMP ResizeBorder(
        LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
    STDMETHODIMP TranslateAccelerator(
        LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
    STDMETHODIMP GetOptionKeyPath(BSTR *pbstrKey, DWORD dw);
    STDMETHODIMP GetDropTarget(
        IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
    STDMETHODIMP GetExternal(IDispatch **ppDisp);
    STDMETHODIMP TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    STDMETHODIMP FilterDataObject(IDataObject *pDO, IDataObject **ppDORet);

    // IInternetSecurityManager
    STDMETHODIMP SetSecuritySite(IInternetSecurityMgrSite *pSite) { return INET_E_DEFAULT_ACTION; };
    STDMETHODIMP GetSecuritySite(IInternetSecurityMgrSite **ppSite) { return INET_E_DEFAULT_ACTION; };
    STDMETHODIMP MapUrlToZone(LPCWSTR pwszUrl, DWORD * pdwZone, DWORD dwFlags) { return INET_E_DEFAULT_ACTION; };
    STDMETHODIMP GetSecurityId(LPCWSTR pwszUrl, BYTE * pbSecurityId, DWORD * pcbSecurityId, DWORD_PTR dwReserved) { return INET_E_DEFAULT_ACTION; };
    STDMETHODIMP ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE * pPolicy, DWORD cbPolicy, BYTE * pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);
    STDMETHODIMP QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE ** ppPolicy, DWORD * pcbPolicy, BYTE * pContext, DWORD cbContext, DWORD dwReserved) { return INET_E_DEFAULT_ACTION; };
    STDMETHODIMP SetZoneMapping(DWORD dwZone, LPCWSTR pszPattern, DWORD dwFlags) { return INET_E_DEFAULT_ACTION; };
    STDMETHODIMP GetZoneMappings(DWORD dwZone, IEnumString ** ppenumString, DWORD dwFlags) { return INET_E_DEFAULT_ACTION; };

    // IDispatch
    STDMETHODIMP GetTypeInfoCount(unsigned int *pctinfo)
        { return E_NOTIMPL; };
    STDMETHODIMP GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
        { return E_NOTIMPL; };
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, unsigned int cNames, LCID lcid, DISPID *rgdispid)
        { return E_NOTIMPL; };
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams,
                        VARIANT *pvarResult, EXCEPINFO *pexcepinfo,UINT *puArgErr);

    CHostDropTarget _dt;
    IExpDispSupport * _peds;
};

class CSFVFrame : public IOleInPlaceFrame, 
                  public IAdviseSink, 
                  public IPropertyNotifySink  //for READYSTATE
{
public:
    enum
    {
        UNDEFINEDVIEW = -3,
        NOEXTVIEW = -2,
        HIDEEXTVIEW = -1,
    } ;

    CSFVFrame() : _fReadyStateComplete(TRUE), _pOleObj(NULL), _bgColor(CLR_INVALID)
    {
    }
    ~CSFVFrame();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND *phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // IOleInPlaceUIWindow
    STDMETHODIMP GetBorder(LPRECT lprectBorder);
    STDMETHODIMP RequestBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetBorderSpace(LPCBORDERWIDTHS pborderwidths);
    STDMETHODIMP SetActiveObject(IOleInPlaceActiveObject *pActiveObject, LPCOLESTR pszObjName);

    // IOleInPlaceFrame
    STDMETHODIMP InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHODIMP SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHODIMP RemoveMenus(HMENU hmenuShared);
    STDMETHODIMP SetStatusText(LPCOLESTR pszStatusText);
    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP TranslateAccelerator(LPMSG lpmsg, WORD wID);

    // IAdviseSink
    STDMETHODIMP_(void) OnDataChange(FORMATETC *, STGMEDIUM *);
    STDMETHODIMP_(void) OnViewChange(DWORD dwAspect, LONG lindex);
    STDMETHODIMP_(void) OnRename(IMoniker *);
    STDMETHODIMP_(void) OnSave();
    STDMETHODIMP_(void) OnClose();

    // IPropertyNotifySink
    STDMETHODIMP OnChanged(DISPID dispid);
    STDMETHODIMP OnRequestEdit(DISPID dispid);

private:
    friend class CSFVSite;
    CSFVSite _cSite;

    friend class CDefView;

    class CBindStatusCallback : public IBindStatusCallback
                              , public IServiceProvider
    {
        friend CSFVFrame;
    protected:
        // IUnknown
        STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
        STDMETHODIMP_(ULONG) AddRef(void) ;
        STDMETHODIMP_(ULONG) Release(void);
    
        // IServiceProvider
        STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);
    
        // IBindStatusCallback
        STDMETHODIMP OnStartBinding(
            DWORD grfBSCOption,
            IBinding *pib);
        STDMETHODIMP GetPriority(
            LONG *pnPriority);
        STDMETHODIMP OnLowResource(
            DWORD reserved);
        STDMETHODIMP OnProgress(
            ULONG ulProgress,
            ULONG ulProgressMax,
            ULONG ulStatusCode,
            LPCWSTR szStatusText);
        STDMETHODIMP OnStopBinding(
            HRESULT hresult,
            LPCWSTR szError);
        STDMETHODIMP GetBindInfo(
            DWORD *grfBINDINFOF,
            BINDINFO *pbindinfo);
        STDMETHODIMP OnDataAvailable(
            DWORD grfBSCF,
            DWORD dwSize,
            FORMATETC *pformatetc,
            STGMEDIUM *pstgmed);
        STDMETHODIMP OnObjectAvailable(
            REFIID riid,
            IUnknown *punk);
    };
    
    friend class CBindStatusCallback;
    CBindStatusCallback _bsc;


//
// External views stuff
//
// We have DocObject extensions and IShellView extensions
// A (DocObject) extension can
public:
    HRESULT InitObj(IUnknown* pObj, LPCITEMIDLIST pidlHere, int iView);

    // If we have a moniker, then we are either currently showing it or we are trying to show it.
    // (Old code explicitly checked current view and pending view -- this is easier.)
    BOOL IsWebView(void) { return _szCurrentWebViewMoniker[0]!=L'\0'; }
    HRESULT _HasFocusIO();
    HRESULT _UIActivateIO(BOOL fActivate, MSG *pMsg);

    HWND GetExtendedViewWindow();

    HRESULT SetRect(LPRECT prc);

    HRESULT GetCommandTarget(IOleCommandTarget** ppct);

    // allow the frame to handle the choice on delegation on translate accelerator...
    HRESULT OnTranslateAccelerator(LPMSG pmsg, BOOL* pbTabOffLastTridentStop);

    HRESULT _GetHTMLBackgroundColor(COLORREF *pclr);    // used in defview.cpp
#ifdef DEBUG
    void _ShowWebViewContent();
#endif

private:

    COLORREF _bgColor;  //Icon text background color for active desktop

    UINT _uState:2;                // SVUIA_* for _pOleObj (extended view)
    IOleObject* _pOleObj;
    IOleDocumentView* _pDocView;
    IOleInPlaceActiveObject* _pActive;
    IViewObject *_pvoActive;

    void _CleanUpOleObj(IOleObject* pOleObj);
    void _CleanUpOleObjAndDt(IOleObject* pOleObj);
    void _CleanupNewOleObj();
    void _CleanupOldDocObject(void);

    WCHAR _szCurrentWebViewMoniker[MAX_PATH];
    HRESULT _GetCurrentWebViewMoniker(LPWSTR wszCurrentMoniker, DWORD cchCurrentMoniker);
    HRESULT ShowWebView(LPCWSTR pszMoniker);
    HRESULT HideWebView();
    HRESULT _CreateNewOleObjFromMoniker(LPCWSTR wszMoniker, IOleObject **ppOleObj);
    HRESULT _ShowExtView_Helper(IOleObject* pOleObj);
    HRESULT _SwitchToNewOleObj();
    HRESULT _GetCurrentZone(IOleObject *pOleObj, VARIANT *pvar);
    HRESULT _UpdateZonesStatusPane(IOleObject *pOleObj);

    //Fields that store details about the new OLE object while we wait for
    //it to reach a READYSTATE_INTERACTIVE.
    IOleObject* _pOleObjNew;
    BOOL _fSwitchedToNewOleObj;

    BOOL _SetupReadyStateNotifyCapability();
    BOOL _RemoveReadyStateNotifyCapability();

    DWORD    _dwConnectionCookie;
    BOOL     _fReadyStateInteractiveProcessed;
    BOOL     _fReadyStateComplete;
    IOleObject* _pOleObjReadyState;
};

class CCallback
{
public:
    CCallback(IShellFolderViewCB* psfvcb) : _psfvcb(psfvcb)
    {
        if (_psfvcb)
        {
            _psfvcb->AddRef();
            _psfvcb->QueryInterface(IID_PPV_ARG(IFolderFilter, &_psff));
        }
    }

    ~CCallback()
    {
        ATOMICRELEASE(_psfvcb);
        ATOMICRELEASE(_psff);
    }

    IShellFolderViewCB *GetSFVCB() 
    { 
        return _psfvcb; 
    }

    IFolderFilter *GetISFF()
    {
        return _psff;
    }

    HRESULT SetCallback(IShellFolderViewCB* pNewCB, IShellFolderViewCB** ppOldCB)
    {
        // We Release the callback for us, and then AddRef it for the caller who now
        // owns the object, which does nothing
        *ppOldCB = _psfvcb;
        ATOMICRELEASE(_psff);
        
        _psfvcb = pNewCB;
        if (pNewCB)
        {
            pNewCB->AddRef();
            pNewCB->QueryInterface(IID_PPV_ARG(IFolderFilter, &_psff));
        }
        return S_OK;
    }

    // Default implementation of SFVM_GETVIEWS replacement SFVM_GETVIEWINFOTEMPLATE
    HRESULT OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit);

    // For legacy SFVM_GETVIEWS implementation:
    HRESULT TryLegacyGetViews(SFVM_WEBVIEW_TEMPLATE_DATA* pvit);
    HRESULT OnRefreshLegacy(void* pv, BOOL fPrePost);
    void _GetExtViews(BOOL bForce);
    int GetViewIdFromGUID(SHELLVIEWID const *pvid, SFVVIEWSDATA** ppItem);
    CViewsList _lViews;
    BOOL _bGotViews;

    HRESULT CallCB(UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        HRESULT hr;
        
        if (_psfvcb)
        {
            hr = _psfvcb->MessageSFVCB(uMsg, wParam, lParam);

            // NOTE: if SFVM_GETVIEWDATA is no longer needed, we can nuke this
            switch (uMsg)
            {
                HANDLE_MSG(0, SFVM_REFRESH, OnRefreshLegacy);
            }
            if (FAILED(hr))
            {
                switch (uMsg)
                {
                    HANDLE_MSG(0, SFVM_GETWEBVIEW_TEMPLATE, OnGetWebViewTemplate);
                }
            }
        }
        else
        {
            hr = E_NOTIMPL;
        }

        return hr;
    }

    BOOL HasCB() 
    {
        return _psfvcb != NULL; 
    }

private:
    IShellFolderViewCB* _psfvcb;
    IFolderFilter* _psff;
};

// Variable Column stuff

typedef struct
{
    TCHAR szName[MAX_COLUMN_NAME_LEN];
    DWORD cChars;   // number of characters wide for default
    DWORD fmt;
    DWORD csFlags;  // SHCOLSTATE flags
    DWORD tsFlags;  // SHTRANSCOLSTATE flags
} COL_INFO;

#define SHTRANSCOLSTATE_TILEVIEWCOLUMN      0x00000001

//Possible values for _iCustomizable
#define YES_CUSTOMIZABLE                1
#define DONTKNOW_IF_CUSTOMIZABLE        0
#define NOT_CUSTOMIZABLE               -2

// For communicating with the background property extractor

class CBackgroundDefviewInfo
{
public:
        CBackgroundDefviewInfo (LPCITEMIDLIST pidl, UINT uId);
        virtual ~CBackgroundDefviewInfo (void);

        LPCITEMIDLIST   GetPIDL (void)      const   {   return(_pidl);          }
        UINT            GetId()             const   {   return(_uId);           }    

private:
        const LPCITEMIDLIST     _pidl;
              UINT              _uId;
};

class CBackgroundColInfo : public CBackgroundDefviewInfo
{
private:
    CBackgroundColInfo (void);
public:
    CBackgroundColInfo (LPCITEMIDLIST pidl, UINT uId, UINT uiCol, STRRET& strRet);
    ~CBackgroundColInfo (void);

    UINT            GetColumn (void)    const   {   return(_uiCol);         }
    LPCTSTR         GetText (void)      const   {   return(&_szText[0]);    }
private:
    const UINT              _uiCol;
          TCHAR             _szText[MAX_COLUMN_NAME_LEN];
};

// The number of "columns" shown in tileview.
// FEATURE:
// We may want to allow this as a registry setting. Or perhaps
// in the desktop.ini. Or perhaps pesisted as per-folder view state?
// Currently, we'll set this two 2 subitems, per spec.
#define TILEVIEWLINES 2

// For communicating with the background file type properties task (for tileview)
class CBackgroundTileInfo : public CBackgroundDefviewInfo
{
private:
    CBackgroundTileInfo (void);
public:
    CBackgroundTileInfo (LPCITEMIDLIST pidl, UINT uId, UINT rguColumns[], UINT cColumns);
    ~CBackgroundTileInfo (void);

    UINT*           GetColumns (void)            {   return(_rguColumns); }
    UINT            GetColumnCount (void)const   {   return(_cColumns);   }
private:
          UINT              _rguColumns[TILEVIEWLINES];
    const UINT              _cColumns;
};

class CBackgroundGroupInfo : public CBackgroundDefviewInfo
{
public:
    CBackgroundGroupInfo (LPCITEMIDLIST pidl, UINT uId, DWORD dwGroupId);

    BOOL        VerifyGroupExists(HWND hwnd, ICategorizer* pcat);
    DWORD       GetGroupId()                  {   return(_dwGroupId);  }
private:
          DWORD             _dwGroupId;
};



// CDefviewEnumTask is defview's IEnumIDList manager.
// This object is used on the UI thread from defview
// and on the task scheduler when it is doing background work.
// All the UI-thread functions are called out as public methods
// during which this object often calls back into CDefView.
//
class CDefviewEnumTask : public CRunnableTask
{
public:
    CDefviewEnumTask(CDefView *pdsv, DWORD dwId);

    // IRunnableTask
    STDMETHODIMP RunInitRT(void);
    STDMETHODIMP InternalResumeRT(void);

    // Called from defview from UI thread:
    HRESULT FillObjectsToDPA(BOOL fInteractive);
    HRESULT FillObjectsDPAToDone();
    HRESULT FillObjectsDoneToView();

    UINT DPACount() { return _hdpaEnum ? DPA_GetPtrCount(_hdpaEnum) : 0; }
    LPCITEMIDLIST* DPAArray() { return _hdpaEnum ? (LPCITEMIDLIST*)DPA_GetPtrPtr(_hdpaEnum) : NULL; }

    BOOL _DeleteFromPending(LPCITEMIDLIST pidl);
    void _AddToPending(LPCITEMIDLIST pidl);

private:
    ~CDefviewEnumTask();

    static int CALLBACK _CompareExactCanonical(void *p1, void *p2, LPARAM lParam);
    PFNDPACOMPARE _GetCanonicalCompareFunction(void);
    LPARAM _GetCanonicalCompareBits();

    void _SortForFilter(HDPA hdpa);
    void _FilterDPAs(HDPA hdpa, HDPA hdpaOld);

    CDefView *_pdsv;

    IEnumIDList *_peunk;
    HDPA _hdpaEnum;
    BOOL _fEnumSorted;
    BOOL _fBackground;
    HRESULT _hrRet;
    HDPA _hdpaPending; // list of refs to SHCNE_CREATEd items while we were enumerating
    DWORD _dwId;
};


class CDUIView;

#ifdef _X86_
//
//  App compat bug 90885.
//
//  Hijaak 5.0 grovels through the CDefView class looking for the
//  IShellBrowser (whose value it learned from CWM_GETISHELLBROWSER).
//  It then assumes that the field right in front of the IShellBrowser
//  is the IShellFolder.  Unfortunately, since we derive from
//  CObjectWithSite and the browser is our site, they accidentally
//  find the copy inside CObjectWithSite and then treat CObjectWithSite's
//  vtbl as if were an IShellFolder.  They then crash, taking the process
//  with it.  Said process anybody who instantiates a DefView, like Explorer.
//  Or anybody who uses a common dialog, which is pretty much everybody.
//
//  Here's the dummy IShellFolder-like object we give them.
//
extern const LPVOID c_FakeHijaakFolder;

//
//  And here's the class that ensures that the dummy IShellFolder
//  comes right before the IShellBrowser.  This replaces the
//  problematic CObjectWithSite.
//
class CHijaakObjectWithSite : public IObjectWithSite {
public:
    //*** IObjectWithSite ***
    STDMETHOD(SetSite)(IUnknown *punkSite) {
        IUnknown_Set(&_punkSite, punkSite);
        return S_OK;
    }
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite) {
        if (_punkSite)
            return _punkSite->QueryInterface(riid, ppvSite);
        *ppvSite = NULL;
        return E_FAIL;
    }

    CHijaakObjectWithSite() : _psfHijaak(&c_FakeHijaakFolder) { }
    ~CHijaakObjectWithSite() {ATOMICRELEASE(_punkSite);}

    const LPVOID *_psfHijaak;
    IShellBrowser *_psb;
    IUnknown *_punkSite;
};

#endif

#define SWITCHTOVIEW_BOTH        0x0
#define SWITCHTOVIEW_NOWEBVIEW   0x1
#define SWITCHTOVIEW_WEBVIEWONLY 0x2

//
// Class definition of CDefView
//
class CDefView : // dsv
    public IShellView2,
    public IFolderView,
    public IShellFolderView,
    public IOleCommandTarget, // so psb can talk to extended views
    public IDropTarget,
    public IViewObject,
    public IDefViewFrame,   // TODO: remove - currently only used by shell\ext\ftp
    public IDefViewFrame3,
    public IServiceProvider,
    public IDocViewSite,
    public IInternetSecurityMgrSite,
    public IPersistIDList,
    public IDVGetEnum,
#ifdef _X86_
    public CHijaakObjectWithSite,
#else
    public CObjectWithSite,
#endif
    public IContextMenuSite,
    public IDefViewSafety,
    public IUICommandTarget,
    public CWVTASKITEM // webview implementation helper class
{
public:
    CDefView(IShellFolder *pshf, IShellFolderViewCB* psfvcb, IShellView* psvOuter);
    STDMETHODIMP Init();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IShellView
    STDMETHODIMP GetWindow(HWND *phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);
    STDMETHODIMP EnableModeless(BOOL fEnable);
    STDMETHODIMP Refresh();
    STDMETHODIMP CreateViewWindow(IShellView *pPrev, LPCFOLDERSETTINGS pfs, IShellBrowser *psb, RECT *prc, HWND *phWnd);
    STDMETHODIMP DestroyViewWindow();
    STDMETHODIMP UIActivate(UINT uState);
    STDMETHODIMP GetCurrentInfo(LPFOLDERSETTINGS lpfs);
    STDMETHODIMP TranslateAccelerator(LPMSG pmsg);
    STDMETHODIMP AddPropertySheetPages(DWORD dwReserved, LPFNADDPROPSHEETPAGE lpfn, LPARAM lparam);
    STDMETHODIMP SaveViewState();
    STDMETHODIMP SelectItem(LPCITEMIDLIST pidlItem, UINT uFlags);
    STDMETHODIMP GetItemObject(UINT uItem, REFIID riid, void **ppv);

    // IShellView2
    STDMETHODIMP GetView(SHELLVIEWID* pvid, ULONG uView);
    STDMETHODIMP CreateViewWindow2(LPSV2CVW2_PARAMS pParams);
    STDMETHODIMP HandleRename(LPCITEMIDLIST pidl);
    STDMETHODIMP SelectAndPositionItem(LPCITEMIDLIST pidlItem, UINT uFlags, POINT *ppt);

    // IFolderView
    STDMETHODIMP GetCurrentViewMode(UINT *pViewMode);
    STDMETHODIMP SetCurrentViewMode(UINT ViewMode);
    STDMETHODIMP GetFolder(REFIID ridd, void **ppv);
    STDMETHODIMP Item(int iItemIndex, LPITEMIDLIST *ppidl);
    STDMETHODIMP ItemCount(UINT uFlags, int *pcItems);
    STDMETHODIMP Items(UINT uFlags, REFIID riid, void **ppv);
    STDMETHODIMP GetSelectionMarkedItem(int *piItem);
    STDMETHODIMP GetFocusedItem(int *piItem);
    STDMETHODIMP GetItemPosition(LPCITEMIDLIST pidl, POINT* ppt);
    STDMETHODIMP GetSpacing(POINT* ppt);
    STDMETHODIMP GetDefaultSpacing(POINT* ppt);
    STDMETHODIMP GetAutoArrange();
    STDMETHODIMP SelectItem(int iItem, DWORD dwFlags);
    STDMETHODIMP SelectAndPositionItems(UINT cidl, LPCITEMIDLIST* apidl, POINT* apt, DWORD dwFlags);

    // IShellFolderView
    STDMETHODIMP Rearrange(LPARAM lParamSort);
    STDMETHODIMP GetArrangeParam(LPARAM *plParamSort);
    STDMETHODIMP ArrangeGrid();
    STDMETHODIMP AutoArrange();
    STDMETHODIMP AddObject(LPITEMIDLIST pidl, UINT *puItem);
    STDMETHODIMP GetObject(LPITEMIDLIST *ppidl, UINT uItem);
    STDMETHODIMP RemoveObject(LPITEMIDLIST pidl, UINT *puItem);
    STDMETHODIMP GetObjectCount(UINT *puCount);
    STDMETHODIMP SetObjectCount(UINT uCount, UINT dwFlags);
    STDMETHODIMP UpdateObject(LPITEMIDLIST pidlOld, LPITEMIDLIST pidlNew, UINT *puItem);
    STDMETHODIMP RefreshObject(LPITEMIDLIST pidl, UINT *puItem);
    STDMETHODIMP SetRedraw(BOOL bRedraw);
    STDMETHODIMP GetSelectedCount(UINT *puSelected);
    STDMETHODIMP GetSelectedObjects(LPCITEMIDLIST **pppidl, UINT *puItems);
    STDMETHODIMP IsDropOnSource(IDropTarget *pDropTarget);
    STDMETHODIMP GetDragPoint(POINT *ppt);
    STDMETHODIMP GetDropPoint(POINT *ppt);
    STDMETHODIMP MoveIcons(IDataObject *pDataObject);
    STDMETHODIMP SetItemPos(LPCITEMIDLIST pidl, POINT *ppt);
    STDMETHODIMP IsBkDropTarget(IDropTarget *pDropTarget);
    STDMETHODIMP SetClipboard(BOOL bMove);
    STDMETHODIMP SetPoints(IDataObject *pDataObject);
    STDMETHODIMP GetItemSpacing(ITEMSPACING *pSpacing);
    STDMETHODIMP SetCallback(IShellFolderViewCB* pNewCB, IShellFolderViewCB** ppOldCB);
    STDMETHODIMP Select(UINT dwFlags);
    STDMETHODIMP QuerySupport(UINT * pdwSupport);
    STDMETHODIMP SetAutomationObject(IDispatch *pdisp);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
        { return _dvdt.DragEnter(pdtobj, grfKeyState, ptl, pdwEffect); }
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
        { return _dvdt.DragOver(grfKeyState, ptl, pdwEffect); }
    STDMETHODIMP DragLeave()
        { return _dvdt.DragLeave(); }
    STDMETHODIMP Drop(IDataObject *pdtobj,
                    DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
        { return _dvdt.Drop(pdtobj, grfKeyState, pt, pdwEffect); }

    // IViewObject
    STDMETHODIMP Draw(DWORD, LONG, void *, DVTARGETDEVICE *, HDC, HDC,
        const RECTL *, const RECTL *, int (*)(ULONG_PTR), ULONG_PTR);
    STDMETHODIMP GetColorSet(DWORD, LONG, void *, DVTARGETDEVICE *, HDC,
        LOGPALETTE **);
    STDMETHODIMP Freeze(DWORD, LONG, void *, DWORD *);
    STDMETHODIMP Unfreeze(DWORD);
    STDMETHODIMP SetAdvise(DWORD, DWORD, IAdviseSink *);
    STDMETHODIMP GetAdvise(DWORD *, DWORD *, IAdviseSink **);

    // IDefViewFrame
    STDMETHODIMP GetShellFolder(IShellFolder **ppsf);

    // IDefViewFrame3
    STDMETHODIMP GetWindowLV(HWND * phwnd);
    STDMETHODIMP OnResizeListView();
    STDMETHODIMP ShowHideListView();
    STDMETHODIMP ReleaseWindowLV(void);
    STDMETHODIMP DoRename();

    // IContextMenuSite
    STDMETHODIMP DoContextMenuPopup(IUnknown* punkCM, UINT fFlags, POINT pt);

    // IPersist
    STDMETHODIMP GetClassID(LPCLSID lpClassID) {return E_NOTIMPL;}

    // IPersistIDList
    STDMETHODIMP SetIDList(LPCITEMIDLIST pidl) {return E_NOTIMPL;}
    STDMETHODIMP GetIDList(LPITEMIDLIST *ppidl) { *ppidl = _GetViewPidl(); return *ppidl ? S_OK : E_FAIL;}
    
    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // IDocViewSite
    STDMETHODIMP OnSetTitle(VARIANTARG *pvTitle);

    // IDVGetEnum
    STDMETHODIMP SetEnumReadyCallback(PFDVENUMREADYBALLBACK pfn, void *pvData);
    STDMETHODIMP CreateEnumIDListFromContents(LPCITEMIDLIST pidlFolder, DWORD dwEnumFlags, IEnumIDList **ppenum);

    // IDefViewSafety
    STDMETHODIMP IsSafePage();

    // IUICommandTarget
    STDMETHODIMP get_Name(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, LPWSTR *ppszName);
    STDMETHODIMP get_Icon(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, LPWSTR *ppszIcon);
    STDMETHODIMP get_Tooltip(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, LPWSTR *ppszInfotip);
    STDMETHODIMP get_State(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, UISTATE* puisState);
    STDMETHODIMP Invoke(REFGUID guidCanonicalName, IShellItemArray *psiItemArray, IBindCtx *pbc);

    // Helper functions for IUICommandTarget implementation:
    IShellItemArray *_CreateSelectionShellItemArray(void);
    IShellItemArray* _GetFolderAsShellItemArray();
    HRESULT _CheckAttribs(IShellItemArray *psiItemArray, DWORD dwAttribMask, DWORD dwAttribValue, UISTATE* puisState);
    HRESULT _GetFullPathNameAt(IShellItemArray *psiItemArray,DWORD dwIndex,LPOLESTR *ppszPath);
    static HRESULT _CanWrite(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanRename(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanMove(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanCopy(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanPublish(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanShare(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanEmail(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static BOOL    _DoesStaticMenuHaveVerb(IShellItemArray *psiItemArray, LPCWSTR pszVerb);
    static HRESULT _CanPrint(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _HasPrintVerb(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanDelete(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    BOOL _IsSystemDrive(void);
    static HRESULT _CanViewDrives(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanHideDrives(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanViewFolder(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanHideFolder(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _HasPreviousVersions(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    HRESULT _DoVerb(IShellItemArray *psiItemArray, LPCSTR pszVerbA);
    HRESULT _DoDropOnClsid(REFCLSID clsidDrop,IDataObject* pdo);
    static HRESULT _OnNewFolder(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnRename(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnMove(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnCopy(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnPublish(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnShare(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnEmail(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnPrint(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnDelete(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    HRESULT RemoveBarricade (void);
    static HRESULT _OnView(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnHide(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnAddRemovePrograms(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnSearchFiles(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    const WVTASKITEM* _FindTaskItem(REFGUID guidCanonicalName);
    static HRESULT _OnPreviousVersions(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);

    DWORD _DefaultColumnState(UINT iCol);
    BOOL _IsColumnHidden(UINT iCol);
    BOOL _IsColumnInListView(UINT iCol);
    BOOL _IsDetailsColumn(UINT iCol);
    BOOL _IsTileViewColumn(UINT iCol);
    HRESULT AddColumnsToMenu(HMENU hm, DWORD dwBase);
    UINT _RealToVisibleCol(UINT uRealCol);
    UINT _VisibleToRealCol(UINT uVisCol);

    // handle messages
    LRESULT _OnCreate(HWND hWnd);
    LRESULT _OnNotify(NMHDR *pnm);
    LRESULT _TBNotify(NMHDR *pnm);
    LRESULT _OnLVNotify(NM_LISTVIEW *plvn);
    LRESULT _OnBeginDrag(NM_LISTVIEW *pnm);

    int _FindItem(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlFound, BOOL fSamePtr, BOOL fForwards = TRUE);
    int _FindItemHint(LPCITEMIDLIST pidl, int iItem);
    int _UpdateObject(LPCITEMIDLIST pidlOld, LPCITEMIDLIST pidlNew);
    void _AddOrUpdateItem(LPCITEMIDLIST pidlOld, LPITEMIDLIST pidlNew);
    int _RefreshObject(LPITEMIDLIST *ppidl);
    int _RemoveObject(LPCITEMIDLIST pidl, BOOL fSamePtr);
    BOOL _GetItemPosition(LPCITEMIDLIST pidl, POINT *ppt);
    BOOL _IsPositionedView();

    void _OnGetInfoTip(NMLVGETINFOTIP *plvn);

    void _OnRename(LPCITEMIDLIST* ppidl);
    LPITEMIDLIST _ObjectExists(LPCITEMIDLIST pidl, BOOL fGlobal);
    UINT _GetExplorerFlag();

    // private stuff
    void PropagateOnViewChange(DWORD dwAspect, LONG lindex);
    void PropagateOnClose();
    BOOL OnActivate(UINT uState);
    BOOL OnDeactivate();
    BOOL HasCurrentViewWindowFocus();
    HWND ViewWindowSetFocus();
    void _OnWinIniChange(WPARAM wParam, LPCTSTR pszSection);
    void _OnWinIniChangeDesktop(WPARAM wParam, LPCTSTR pszSection);
    void _SetFolderColors();
    DWORD _LVStyleFromView();
    DWORD _LVExStyleFromView();
    BOOL _GetColorsFromHTMLdoc(COLORREF *clrTextBk, COLORREF *clrHotlight);
    void _SetFocus();
    void _UpdateUnderlines();
    void _SetSysImageList();
    void _SetTileview();
    void _BestFit();
    UINT _ValidateViewMode(UINT uViewMode);
    UINT _GetDefaultViewMode();
    void _GetDeferredViewSettings(UINT* puViewMode);
    HRESULT _SelectAndPosition(int iItem, UINT uFlags, POINT *ppt);
    HRESULT _Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    
    inline BOOL _IsOwnerData();
    BOOL _IsDesktop();
    inline BOOL _IsCommonDialog();
    BOOL _IsListviewVisible();
    HRESULT _IncludeObject(LPCITEMIDLIST pidl);
    HRESULT _OnDefaultCommand();
    HRESULT _OnStateChange(UINT code);

    int _AddObject(LPITEMIDLIST pidl);
    void _UpdateImage(int iImage);
    void _DismissEdit();
    void _OnInitMenu();
    HRESULT _ForwardMenuMessages(DWORD dwID, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult, BOOL* pfHandled);
    void _RemoveThumbviewTasks();
    HRESULT _AddTask(IRunnableTask *pTask, REFTASKOWNERID rTID, DWORD_PTR lParam, DWORD dwPriority, DWORD grfFlags);
    HRESULT _ExplorerCommand(UINT idFCIDM);
    LRESULT _OnMenuSelect(UINT id, UINT mf, HMENU hmenu);
    HRESULT _AutoAutoArrange(DWORD dwReserved);


    // Infotip Methods (public)
    //
    HRESULT PreCreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool);                                          // ui thread
    HRESULT PostCreateInfotip(HWND hwndContaining, UINT_PTR uToolID, HINSTANCE hinst, UINT_PTR uInfotipID, LPARAM lParam);      // bg thread
    HRESULT PostCreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPCWSTR pwszInfotip, LPARAM lParam);                       // bg thread
    HRESULT CreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool, HINSTANCE hinst, UINT_PTR uInfotipID, LPARAM lParam);// ui thread
    HRESULT CreateInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool, LPCWSTR pwszInfotip, LPARAM lParam);         // ui thread
    HRESULT DestroyInfotip(HWND hwndContaining, UINT_PTR uToolID);                                                              // ui thread
    HRESULT RepositionInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool);                                         // ui thread
    HRESULT RelayInfotipMessage(HWND hwndFrom, UINT uMsg, WPARAM wParam, LPARAM lParam);                                        // ui thread

    // Menu Methods (public)
    //
    void RecreateMenus();
    void InitViewMenu(HMENU hmInit);

    // Toolbar Methods (public)
    //
    void EnableToolbarButton(UINT uiCmd, BOOL bEnable);
    HRESULT _GetPropertyUI(IPropertyUI **pppui);

    int CheckCurrentViewMenuItem(HMENU hmenu);
    void CheckToolbar();
    void OnListViewDelete(int iItem, LPITEMIDLIST pidl, BOOL fCallCB);
    void HandleKeyDown(LV_KEYDOWN *lpnmhdr);
    void AddColumns();
    void _ShowControl(UINT uControl, int idCmd);
    LRESULT _OnInitMenuPopup(HMENU hmInit, int nIndex, BOOL fSystemMenu);
    void _SetUpMenus(UINT uState);
    void SelectPendingSelectedItems();
    inline BOOL _ItemsDeferred();
    void _ClearPendingSelectedItems();
    void AddCopyHook();
    int FindCopyHook(BOOL fRemoveInvalid);
    void RemoveCopyHook();
private:
    HRESULT _DoContextMenuPopup(IUnknown* punkCM, UINT fFlags, POINT pt, BOOL fListviewItem);
public:
    void ContextMenu(DWORD dwPos);
    LPITEMIDLIST _GetViewPidl(); // return copy of pidl of folder we're viewing
    BOOL _IsViewDesktop();
    BOOL _GetPath(LPTSTR pszPath);
    HRESULT _GetNameAndFlags(UINT gdnFlags, LPTSTR psz, UINT cch, DWORD *pdwFlags);
    BOOL _CachedIsCustomizable();

    LRESULT _OnDefviewEditCommand(UINT uID);
    HRESULT _DoMoveOrCopyTo(REFCLSID clsid,IShellItemArray *psiItemArray);
    LRESULT _OnCommand(IContextMenu *pcmSel, WPARAM wParam, LPARAM lParam);
    BOOL _OnAppCommand(UINT cmd, UINT uDevice, DWORD dwKeys);
    LRESULT WndSize(HWND hWnd);
    void FillDone();
    void OnLVSelectionChange(NM_LISTVIEW *plvn);
    void _OnLVSelectionChange(int iItem, UINT uOldState, UINT uNewState, LPARAM lParam);

    HRESULT FillObjectsShowHide(BOOL fInteractive);

    HRESULT _GetDetailsHelper(int i, DETAILSINFO *pdi);
    HRESULT CallCB(UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL HasCB() 
    {
        return _cCallback.HasCB(); 
    }
    HRESULT _FireEvent(DISPID dispid);
    void _CallRefresh(BOOL fPreRefresh);

    void _PostSelectionChangedMessage(UINT);
    void _OnSelectionChanged();
    void _OnDelayedSelectionChange();
    
    void _PostNoItemStateChangedMessage();
    void _OnNoItemStateChanged();

    void _PostEnumDoneMessage();
    void _PostFillDoneMessage();
    void _OnEnumDoneMessage();

    void _OnContentsChanged();
    void _OnDelayedContentsChanged();

    void _FixupColumnsForTileview(UINT *rguColumns, UINT cColumns);
    HRESULT _PeekColumnsCache(PTSTR pszPath, UINT cchPath, LPCITEMIDLIST pidl, UINT rguColumns[], UINT *pcColumns);
    HRESULT _GetImportantColumns(LPCITEMIDLIST pidl, UINT rguColumns[], UINT *pcColumns);
    void _SetImportantColumns(CBackgroundTileInfo *pDVTileInfo);
    
    void _SetView(UINT fvm);
    
    HRESULT _ReloadListviewContent();
    HRESULT _ReloadContent(BOOL fForce = FALSE);

    BOOL _IsImageMode(UINT fvm)
        {return (fvm == FVM_THUMBNAIL) || (fvm == FVM_THUMBSTRIP); }
    BOOL _IsImageMode()
        {return (_fs.ViewMode == FVM_THUMBNAIL) || (_fs.ViewMode == FVM_THUMBSTRIP); }
    BOOL _IsTileMode(UINT fvm)
        { return (fvm == FVM_TILE); }
    inline BOOL _IsTileMode()
        { return (_fs.ViewMode == FVM_TILE); }
    BOOL _IsAutoArrange()
        { return ((_fs.fFlags & FWF_AUTOARRANGE) || (_fs.ViewMode == FVM_THUMBSTRIP)); }

    HRESULT _GetWebViewMoniker(LPWSTR pszMoniker, DWORD cchMoniker);
    HRESULT _SwitchToWebView(BOOL bShow);
    HRESULT _GetDefaultWebviewContent(BOOL bForFileFolderTasks);
    void _FreeWebViewContentData();
    BOOL _QueryBarricadeState();
    HRESULT _TryShowWebView(UINT fvmNew, UINT fvmOld);
    HRESULT _TryHideWebView();
    HRESULT _SwitchToViewFVM(UINT fvmNew, UINT uiType = SWITCHTOVIEW_BOTH);
    void _ShowThemeWatermark();
    void _ShowLegacyWatermark();
    void _SetThemeWatermark();
    void _SetLegacyWatermark(LPCTSTR pszLegacyWatermark);
    void _UpdateListviewColors();
    LRESULT _SwitchDesktopHTML(BOOL fShow);
    void InitSelectionMode();
    void _UpdateSelectionMode();

    void _OnMoveWindowToTop(HWND hwnd);

    HWND GetChildViewWindow();
    BOOL _InvokeCustomization();

    HRESULT _OnViewWindowActive();
    void _UpdateRegFlags();

    void _DoColumnsMenu(int x, int y);
    BOOL _HandleColumnToggle(UINT uCol, BOOL bRefresh);
    void _AddColumnToListView(UINT uCol, UINT uColVis);

    void _SameViewMoveIcons();
    void _MoveSelectedItems(int dx, int dy, BOOL fAbsolute);

    void _AddTileColumn(UINT uCol);
    void _RemoveTileColumns();
    void _ResetTileInfo(UINT uColVis, BOOL bAdded);
    void _RemoveTileInfo();

    HRESULT _GetIPersistHistoryObject(IPersistHistory **ppph);

    HRESULT _GetStorageStream(DWORD grfMode, IStream* *ppIStream);
    HRESULT _SaveGlobalViewState(void);
    HRESULT _LoadGlobalViewState(IStream* *ppIStream);
    HRESULT _ResetGlobalViewState(void);
    LPCITEMIDLIST _GetPIDL(int i);
    LPCITEMIDLIST _GetPIDLParam(LPARAM lParam, int i);
    int _HitTest(const POINT *ppt, BOOL fIgnoreEdge = FALSE);
    void _AlterEffect(DWORD grfKeyState, DWORD *pdwEffect, UINT uFlags);
    BOOL _IsDropOnSource(IDropTarget *pdtgt);
    BOOL _IsBkDropTarget(IDropTarget *pdtgt);
    BOOL _GetDropPoint(POINT *ppt);
    BOOL _GetInsertPoint(POINT *ppt);
    BOOL _GetDragPoint(POINT *ppt);
    void _GetToolTipText(UINT_PTR id, LPTSTR pszText, UINT cchText);
    void _GetCBText(UINT_PTR id, UINT uMsgT, UINT uMsgA, UINT uMsgW, LPTSTR psz, UINT cch);
    void _GetMenuHelpText(UINT_PTR id, LPTSTR pszText, UINT cchText);
    void _SetItemPos(LPSFV_SETITEMPOS psip);
    void _FullViewUpdate(BOOL fUpdateItem);
    void _UpdateEnumerationFlags();
    void _SetItemPosition(int i, int x, int y);


    void _GlobeAnimation(BOOL fStartSpinning, BOOL fForceStop = FALSE);

    void _PaintErrMsg(HWND hWnd);
    void _SetPoints(UINT cidl, LPCITEMIDLIST *apidl, IDataObject *pdtobj);
    BOOL _GetItemSpacing(ITEMSPACING *pis);
    LRESULT _OnSetClipboard(BOOL bMove);
    LRESULT _OnClipboardChange();

    void _RestoreAllGhostedFileView();
    BOOL _ShouldShowWebView();
    void _ShowViewEarly();
    BOOL _SetupNotifyData();

    DWORD _GetEnumFlags();

    // Arrange
    BOOL _InitArrangeMenu(HMENU hmenuCtx);
    BOOL _ArrangeBy(UINT idCmd);
    BOOL _InitExtendedGroups(ICategoryProvider* pcp, HMENU hmenuCtx, int iIndex, int* piIdToCheck);

    // Grouping
    void _ToggleGrouping();
    void _GroupBy(int iColumn);
    BOOL _IsSlowGroup(const GUID *pguid);
    BOOL _CategorizeOnGUID(const GUID* pguid, const SHCOLUMNID* pscid);
    BOOL _CategorizeOnSCID(const SHCOLUMNID* pscid);
    void _OnCategoryTaskAdd();
    void _OnCategoryTaskDone();
    DWORD _GetGroupForItem(int iItem, LPCITEMIDLIST pidl);
    BOOL _LoadCategory(GUID *pguidGroupID);

    HRESULT _OnRearrange(LPARAM lParamSort, BOOL fAllowToggle);

    // Thumbnail Support
    HRESULT ExtractItem(UINT *puIndex, int iItem, LPCITEMIDLIST pidl, BOOL fBackground, BOOL fForce, DWORD dwMaxPriority);
    DWORD _GetOverlayMask(LPCITEMIDLIST pidl);
    HRESULT UpdateImageForItem(DWORD dwTaskID, HBITMAP hImage, int iItem, LPCITEMIDLIST pidl,
                               LPCWSTR pszPath, FILETIME ftDateStamp, BOOL fCache, DWORD dwPriority);
    HRESULT _SafeAddImage(BOOL fQuick, IMAGECACHEINFO* prgInfo, UINT* piImageIndex, int iListID);
    HRESULT TaskUpdateItem(LPCITEMIDLIST pidl, int iItem, DWORD dwMask, LPCWSTR pszPath,
                           FILETIME ftDateStamp, int iThumbnail, HBITMAP hBmp, DWORD dwItemID);

    void _UpdateThumbnail(int iItem, int iImage, LPCITEMIDLIST pidl);
    void _CleanupUpdateThumbnail(DSV_UPDATETHUMBNAIL* putn);
    COLORREF _GetBackColor();
    void _CacheDefaultThumbnail(LPCITEMIDLIST pidl, int* piIcon);
    HRESULT _CreateOverlayThumbnail(int iIndex, HBITMAP* phbmOverlay, HBITMAP* phbmMask);
    int _MapIndexPIDLToID(int iIndex, LPCITEMIDLIST pidl);
    int _MapIDToIndex(int iID);
    void _ThumbnailMapInit();
    void _ThumbnailMapClear();

    void _SetThumbview();
    void _ResetThumbview();
    void _GetThumbnailSize(SIZE *psize);

    HRESULT CreateDefaultThumbnail(int iIndex, HBITMAP * phBmpThumbnail, BOOL fCorner);
    int ViewGetIconIndex(LPCITEMIDLIST pidl);
    ULONG _ApproxItemsPerView();
    void _DoThumbnailReadAhead();
    HRESULT _GetDefaultTypeExtractor(LPCITEMIDLIST pidl, IExtractImage **ppExt);
    DWORD _Attributes(LPCITEMIDLIST pidl, DWORD dwAttribs);
    HRESULT _EnumThings(UINT uWhat, IEnumIDList **ppenum);
    void _ClearPostedMsgs(HWND hwnd);

    HDPA _dpaThumbnailMap;
    IShellImageStore* _pDiskCache;
    IImageCache3* _pImageCache;
    DWORD _dwRecClrDepth;
    int _iMaxCacheSize;
    int _iWriteTaskCount;
    SIZE _sizeThumbnail;
    HPALETTE _hpalOld;
    COLORREF _rgbBackColor;
    ULONG_PTR _tokenGdiplus;
    
    HRESULT _GetBrowserPalette(HPALETTE* phpal);
    
    LONG _cRef;
    CDVDropTarget           _dvdt;
    CViewState              _vs;
    IShellView              *_psvOuter;          // May be NULL
    IShellFolder            *_pshf;
    IShellFolder2           *_pshf2;
    IShellFolder            *_pshfParent;
    IShellFolder2           *_pshf2Parent;
    LPITEMIDLIST            _pidlRelative;
    LPITEMIDLIST            _pidlSelectAndPosition;
    UINT                    _uSelectAndPositionFlags;
#ifndef _X86_
    // In the _X86_ case, the _psb is inside the CHijaakObjectWithSite
    IShellBrowser           *_psb;
#endif
    ICommDlgBrowser         *_pcdb;             // extended ICommDlgBrowser
    FOLDERSETTINGS          _fs;
    IContextMenu            *_pcmSel;           // pcm for selected objects.
    IContextMenu            *_pcmFile;          // this is for the File menu only (you can't re-use a contextmenu once QueryContextMenu has been called)
    IContextMenu            *_pcmContextMenuPopup; // pcm for TrackPopupMenu usage
    IShellItemArray         *_pSelectionShellItemArray;        // selection object for the current selection
    IShellItemArray         *_pFolderShellItemArray;       // shellItemArray for this folder.
    IShellIcon              *_psi;               // for getting icon fast
    IShellIconOverlay       *_psio;              // For getting iconOverlay fast
    CLSID                   _clsid;             // the clsid of this pshf;

    ICategorizer*           _pcat;
    HDSA                    _hdaCategories;
    int                     _iLastFoundCat;
    int                     _iIncrementCat;

    HWND                    _hwndMain;
    HWND                    _hwndView;
    HWND                    _hwndListview;
    HWND                    _hwndInfotip;    // infotip control
    HWND                    _hwndStatic;
    HACCEL                  _hAccel;
    int                     _fmt;

    UINT                    _uState;         // SVUIA_*
    HMENU                   _hmenuCur;

    ULONG                   _uRegister;

    POINT                   _ptDrop;

    POINT                   _ptDragAnchor;   // start of the drag
    int                     _itemCur;        // The current item in the drop target

    IDropTarget             *_pdtgtBack;     // of the background (shell folder)

    IShellDetails           *_psd;
    UINT                    _cxChar;

    LPCITEMIDLIST           _pidlMonitor;
    LONG                    _lFSEvents;

    TBBUTTON*               _pbtn;
    int                     _cButtons;          // count of buttons that are showing by default
    int                     _cTotalButtons;     // count of buttons including those hidden by default

    IShellTaskScheduler2    *_pScheduler;

    CDUIView                *_pDUIView;

    BITBOOL     _fSlowGroup:1;
    BITBOOL     _fInBackgroundGrouping: 1;
    
    BITBOOL     _bDragSource:1;
    BITBOOL     _bDropAnchor:1;

    BITBOOL     _fUserPositionedItems:1;

    BITBOOL     _bHaveCutStuff:1;
    BITBOOL     _bClipViewer:1;

    BITBOOL     _fShowAllObjects:1;
    BITBOOL     _fInLabelEdit:1;
    BITBOOL     _fDisabled:1;

    BITBOOL     _bBkFilling:1;

    BITBOOL     _bContextMenuMode:1;
    BITBOOL     _bMouseMenu:1;
    BITBOOL     _fHasDeskWallPaper:1;

    BITBOOL     _fShowCompColor:1;

    BITBOOL     _bRegisteredDragDrop:1;

    BITBOOL     _fEnumFailed:1;    // TRUE if enum failed.

    BITBOOL     _fGetWindowLV:1;    // DVOC has grabbed the listview (it set the owner, repositioned it)

    BITBOOL     _fClassic:1; // SSF_WIN95CLASSIC setting/restriction

    BITBOOL     _fCombinedView:1;   // Implies a regional listview layered on top of an extended view (the desktop with AD on)
    BITBOOL     _fCycleFocus:1;     // 1=got callback to do CycleFocus

    BITBOOL     _fSelectionChangePending:1;
    BITBOOL     _fNoItemStateChangePending:1;
    BITBOOL     _fCanActivateNow:1; // FALSE from creation until we can be activated, TRUE implies we can SHDVID_CANACTIVATENOW
    BITBOOL     _fWin95ViewState:1;         // TRUE iff Advanced option set to Win95 behavior
    BITBOOL     _fDesktopModal:1;           // TRUE iff desktop is in modal state.
    BITBOOL     _fDesktopRefreshPending:1;  // TRUE iff a refresh of desktop was prevented because of modal state.
    BITBOOL     _fRefreshBuffered:1;        // TRUE iff a buffered refresh is pending!
    BITBOOL     _fHasListViewFocus:1;
    BITBOOL     _bLoadedColumns:1;          // TRUE after we've loaded cols from the savestream. (after we're switched to details)
    BITBOOL     _fIsAsyncDefView:1;         // TRUE if Defview is Asynchronous
    // Combined view colors that can be specified via registry or desktop.ini

    BITBOOL     _bAutoSelChangeTimerSet:1;  // indicates if the timer to send the sel change notification to the automation obj is set

    BITBOOL     _fDestroying:1; // DestroyViewWindow was called
    BITBOOL     _fIgnoreItemChanged: 1;
    BITBOOL     _fReadAhead: 1;
    BITBOOL     _fGroupView: 1;
    BITBOOL     _fActivateLV: 1;    // Indicates that we have to activate the
                                    // listview rather than defview (the webview case)
    BITBOOL     _fAllowSearchingWindow: 1;   // use "searching" window, used for user-initiated enum (and first enum)
    BITBOOL     _fSyncOnFillDone: 1;    // set when _vs is valid for us to re-sync position information
    BITBOOL     _fListViewShown: 1; // TRUE iff _hwndListview is shown
    BITBOOL     _fListviewRedraw: 1; // TRUE iff WM_REDRAW(FALSE) on _hwndListview, for listview hack work-around
    BITBOOL     _fQueryWebViewData: 1; // TRUE iff SFVM_WEBVIEW_CONTENT_DATA has been queried

    BITBOOL     _fGlobeCanSpin:1; // Spinning globe implies navigation, only allow it to spin when the view is first created
    BITBOOL     _fPositionRecycleBin:1; // TRUE iff desktop AND clean install.

    BITBOOL     _fScrolling:1;  // We are currently scrolling
    BITBOOL     _fRequestedTileDuringScroll:1; // Indicates we request tile column information while scrolling
    BITBOOL     _fSetTileViewSortedCol:1; // Indicates we have set the tileview sorted column
    BITBOOL     _fBackgroundStatusTextValid:1;  // Is the background statusbar text still valid.
    BITBOOL     _fUserRejectedWebViewTemplate:1;

    DWORD       _crefGlobeSpin; // so the different components that want to keep the globe spinning can reference count it
    DWORD       _crefSearchWindow; // so the different components that want to keep the "searching" window up can reference count it

    COLORREF    _crCustomColors[CRID_COLORCOUNT];
    UINT        _idThemeWatermark;
    LPTSTR      _pszLegacyWatermark;

    // for single click activation
    DWORD       _dwSelectionMode;

    HWND        _hwndNextViewer;

    LRESULT     _iStdBMOffset;
    LRESULT     _iViewBMOffset;

    CCallback   _cCallback;    // Optional client callback

    HDSA        _hdsaSelect;    // List of items that are selected.

    HDSA        _hdsaSCIDCache; // Cache the SCIDs so we can map SCID to column# (tileview)

    int         _iLastFind;

    UINT        _uDefToolbar;
    CSFVFrame   _cFrame;

    ULONG       _uCachedSelAttrs;
    UINT        _uCachedSelCount;

    UINT        _uSelectionStateChanged; // selection/focus change bits for _fSelectionChangePending
    UINT        _uAutoSelChangeState;    // selection/focus change bits for _bAutoSelChangeTimerSet

    DWORD       _dwConnectionCookie;

    CBackgroundInfoTip *  _pBackgroundInfoTip;          // Used for the background InfoTip
    CDefviewEnumTask *    _pEnumTask;
    DWORD                 _dwEnumId;

    DWORD                   _dwProffered;               // Cookie for the SID_SFolderView service proffered
    PFDVENUMREADYBALLBACK   _pfnEnumReadyCallback;      // Callback indicating that our enum is done and that the client
                                                        // can now get the IEnumIDList
    void *                  _pvEnumCallbackData;

    IUIElement*                   _pOtherPlacesHeader;
    IUIElement*                   _pDetailsHeader;
    SFVM_WEBVIEW_LAYOUT_DATA      _wvLayout;  // layout can change on view mode changes
    SFVM_WEBVIEW_CONTENT_DATA     _wvContent; // content that is static per folder
    SFVM_WEBVIEW_TASKSECTION_DATA _wvTasks;   // content that can change when selection changes
    SFVM_WEBVIEW_THEME_DATA       _wvTheme;   // HACK: theme info
    BOOL                          _fBarrierDisplayed; // TRUE if the soft barrier is currently being displayed
    BOOL                          _fRcvdContentsChangeBeforeDuiViewCreated;

    HDPA                          _hdpaGroupingListActive;
    HDPA                          _hdpaGroupingListBackup;
    BOOL                          _fGroupingMsgInFlight;
    LONG                          _cTasksOutstanding;
    LONG                          _cTasksCompleted;


#ifdef DEBUG
    TIMEVAR(_Update);
    TIMEVAR(_Fill);
    TIMEVAR(_GetIcon);
    TIMEVAR(_GetName);
    TIMEVAR(_FSNotify);
    TIMEVAR(_AddObject);
    TIMEVAR(_EnumNext);
    TIMEVAR(_RestoreState);
    TIMEVAR(_WMNotify);
    TIMEVAR(_LVChanging);
    TIMEVAR(_LVChanged);
    TIMEVAR(_LVDelete);
    TIMEVAR(_LVGetDispInfo);
#endif

public:     // TODO: Make this protected after we have finished converting the entire file.
    BOOL IsSafeToDefaultVerb(void);
    HRESULT _InvokeContextMenuVerb(IContextMenu* pcm, LPCSTR pszVerb, UINT uKeyFlags, DWORD dwCMMask);
    HRESULT _InvokeContextMenuVerbOnSelection(LPCSTR pszVerb, UINT uKeyFlags, DWORD dwCMMask);
    HRESULT _InvokeContextMenu(IContextMenu *pcm, CMINVOKECOMMANDINFOEX *pici);
    void _LogDesktopLinksAndRegitems();
    void _FocusOnSomething(void);
    void _UpdateIcon(LPITEMIDLIST pidl, UINT iIcon);
    void _UpdateColData(CBackgroundColInfo *pbgci);
    void _UpdateOverlay(int iList, int iOverlay);
    HRESULT _GetIconAsync(LPCITEMIDLIST pidl, int *piIcon, BOOL fCanWait);
    HRESULT _GetOverlayIndexAsync(LPCITEMIDLIST pidl, int iList);
    DWORD _GetNeededSecurityAction(void);
    HRESULT _ZoneCheck(DWORD dwFlags, DWORD dwAllowAction);
    void _ShowAndActivate();
    void _RegisterWindow();
    static LRESULT CALLBACK s_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    LRESULT WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static DWORD WINAPI BackgroundDestroyWindow(void *pvData);

private:
    ~CDefView();

    // View Mode Methods (private)
    //
    BOOL _ViewSupported(UINT uView);
    void _ThumbstripSendImagePreviewFocusChangeEvent();

    // Infotip Methods (private)
    //
    typedef struct {
        HWND hwndContaining;
        UINT_PTR uToolID;
        RECT rectTool;
    } PENDING_INFOTIP;
    CList<PENDING_INFOTIP> _tlistPendingInfotips;
    HRESULT _FindPendingInfotip(HWND hwndContaining, UINT_PTR uToolID, LPRECT prectTool, BOOL bRemoveAndDestroy); // ui thread
    HRESULT _OnPostCreateInfotip(TOOLINFO *pti, LPARAM lParam);                                                   // ui thread
    HRESULT _OnPostCreateInfotipCleanup(TOOLINFO *pti);                                                           // ui thread or bg thread
    HWND    _CreateInfotipControl(HWND hwndParent);
    void    _InitInfotipControl(HWND hwndInfotip);

    // Menu Methods (private)
    //
    void _InitViewMenuWhenBarrierDisplayed(HMENU hmenuView);        // Initializes entire view menu (for barricaded view).
    void _InitViewMenuWhenBarrierNotDisplayed(HMENU hmenuView);     // Initializes entire view menu (for non-barricaded view).
    void _InitViewMenuViewsWhenBarrierNotDisplayed(HMENU hmenuView);// Initializes "view" subsection of view menu (for non-barricated view).
    void _MergeViewMenu(HMENU hmenuViewParent, HMENU hmenuMerge);   // Merges hmenuMerge into the view menu @ FCIDM_MENU_VIEW_SEP_OPTIONS

    // Toolbar Methods (private)
    //
    BOOL _ShouldEnableToolbarButton(UINT uiCmd, DWORD dwAttr, int iIndex);
    void _EnableToolbarButton(IExplorerToolbar *piet, UINT uiCmd, BOOL bEnable);
    void _EnableDisableTBButtons();

    void MergeToolBar(BOOL bCanRestore);
    BOOL _MergeIExplorerToolbar(UINT cExtButtons);
    void _CopyDefViewButton(PTBBUTTON ptbbDest, PTBBUTTON ptbbSrc);
    int _GetButtons(PTBBUTTON* ppbtn, LPINT pcButtons, LPINT pcTotalButtons);

    void _SetCachedToolbarSelectionAttrs(ULONG dwAttrs);
    BOOL _GetCachedToolbarSelectionAttrs(ULONG *pdwAttr);

    LRESULT _OnFSNotify(LONG lNotification, LPCITEMIDLIST* ppidl);

    static int CALLBACK _Compare(void *p1, void *p2, LPARAM lParam);
    HRESULT _Sort(void);
    UINT _GetBackgroundTaskCount(REFTASKOWNERID rtid);
    void _SetSortFeedback();
    BOOL GetViewState();
    DWORD _AttributesFromSel(DWORD dwAttrMask);
    HRESULT _GetSelectionDataObject(IDataObject **pdobjSelect);
    HRESULT _GetUIObjectFromItem(REFIID riid, void **ppv, UINT uItem, BOOL fSetPoints);
    HRESULT _GetItemObjects(LPCITEMIDLIST **ppidl, UINT uItem, UINT *pcItems);
    UINT _GetItemArray(LPCITEMIDLIST apidl[], UINT capidl, UINT uWhat);

    BOOL _AllowCommand(UINT uID);
    void _DoStatusBar(BOOL fInitialize);
    void _UpdateStatusBar(BOOL fInitialize);
    void _ShowSearchUI(BOOL fStartSearchWindow);
    HRESULT _OnStartBackgroundEnum();
    HRESULT _OnStopBackgroundEnum();
    HRESULT _OnBackgroundEnumDone();
    LRESULT _GetDisplayInfo(LV_DISPINFO *plvdi);
    UINT _GetHeaderCount();

    BOOL _EnsureSCIDCache();

    BOOL _MapSCIDToColumn(const SHCOLUMNID *pscid, UINT *pnColumn);

    HRESULT _GetSFVMViewState(UINT uViewMode, SFVM_VIEW_DATA* pvi);
    HRESULT _GetSFVMViewInfoTemplate(UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit);

    int _CompareIDsDirection(LPARAM lParam, LPCITEMIDLIST p1, LPCITEMIDLIST p2);
    HRESULT _CompareIDsFallback(LPARAM lParam, LPCITEMIDLIST p1, LPCITEMIDLIST p2);
    int     _FreezeRecycleBin(LPPOINT ppt);
    void    _SetRecycleBinInDefaultPosition(POINT *ppt);
    void    _ClearItemPositions();

    static void CALLBACK _AsyncIconTaskCallback(LPCITEMIDLIST pidl, void *pvData, void *pvHint, INT iIconIndex, INT iOpenIconIndex);
    void _SetDefaultViewSettings();

    HRESULT _Create_BackgrndHMENU(BOOL fViewMenuOnly, REFIID riid, void **ppv);
    HRESULT _CBackgrndMenu_CreateInstance(REFIID riid, void **ppv);
    
    friend class CSFVSite;
    friend class CSFVFrame;
    friend class CBkgrndEnumTask;
    friend class CViewState;
    friend class CDefviewEnumTask;
    friend class CCategoryTask;
    
    IDispatch *_pauto;                  // folder view automation object
    IAdviseSink *_padvise;              // advisory connection
    DWORD _advise_aspect;
    DWORD _advise_advf;

    // Is this folder customizable using a desktop.ini?
    // In other words, is this folder in a write-able media AND either it 
    // not have a desktop.ini OR if it is there, it is writeable!
    int   _iCustomizable;

    HRESULT _CreateSelectionContextMenu(REFIID riid, void** ppv);
    HRESULT _DoBulkRename(LPCITEMIDLIST pidlNewName);

    BOOL                    _bReEntrantReload;

    IPropertyUI *_ppui;

};

int CALLBACK GroupCompare(int iGroup1, int iGroup2, void *pvData);

class CColumnDlg
{
public:
    CColumnDlg(CDefView *pdsv);
    ~CColumnDlg();

    HRESULT ShowDialog(HWND hwnd);

private:
    void _OnInitDlg();
    BOOL _SaveState();
    void _MoveItem(int iDelta);
    void _UpdateDlgButtons(NMLISTVIEW *pnmlv);
    UINT _HelpIDForItem(int iItem, LPTSTR pszHelpFile, UINT cch);
    HRESULT _GetPropertyUI(IPropertyUI **pppui);

    CDefView *_pdsv;

    IPropertyUI *_ppui;

    HWND _hdlg;
    HWND _hwndLVAll;
    UINT _cColumns;
    UINT *_pdwOrder;
    int *_pWidths;
    BOOL _bChanged;
    BOOL _bLoaded;
    BOOL _bUpdating;    // used to block notification processing while we're updating

    static BOOL_PTR CALLBACK s_DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL_PTR DlgProc(UINT uMsg, WPARAM wParam, LPARAM lParam);
};


// Thumbnail helpers
void ListView_InvalidateImageIndexes(HWND hwndList);

#define DEFVIEW_LISTCALLBACK_FLAGS (LVIF_TEXT | LVIF_IMAGE | LVIF_GROUPID | LVIF_COLUMNS)

#define PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY

#define PRIORITY_M5         (PRIORITY_NORMAL - 5 * 0x1000)
#define PRIORITY_M4         (PRIORITY_NORMAL - 4 * 0x1000)
#define PRIORITY_M3         (PRIORITY_NORMAL - 3 * 0x1000)
#define PRIORITY_M2         (PRIORITY_NORMAL - 2 * 0x1000)
#define PRIORITY_M1         (PRIORITY_NORMAL - 1 * 0x1000)
#define PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY
#define PRIORITY_P1         (PRIORITY_NORMAL + 1 * 0x1000)
#define PRIORITY_P2         (PRIORITY_NORMAL + 2 * 0x1000)
#define PRIORITY_P3         (PRIORITY_NORMAL + 3 * 0x1000)
#define PRIORITY_P4         (PRIORITY_NORMAL + 4 * 0x1000)
#define PRIORITY_P5         (PRIORITY_NORMAL + 5 * 0x1000)

// The following should be used as returns from GetLocation
#define PRIORITY_EXTRACT_FAST       PRIORITY_P1
#define PRIORITY_EXTRACT_NORMAL     PRIORITY_NORMAL
#define PRIORITY_EXTRACT_SLOW       PRIORITY_M1

// The following are some basis for background tasks
#define PRIORITY_IMAGEEXTRACT       PRIORITY_EXTRACT_NORMAL
#define PRIORITY_READAHEAD_EXTRACT  PRIORITY_M2
#define PRIORITY_READAHEAD          PRIORITY_M3
#define PRIORITY_UPDATEDIR          PRIORITY_M3
#define PRIORITY_CACHETIDY          PRIORITY_M4

// The following are some increments used for subtasks in image extraction
// They are used to alter the priorities above as in these examples, such that
// disk cache hits are faster than extracts which are faster than cache writes:
//     A fast image extract (3 tasks):
//         PRIORITY_IMAGEEXTRACT + PRIORITY_DELTA_FAST - PRIORITY_DELTA_DISKCACHE == 0x10000010
//         PRIORITY_IMAGEEXTRACT + PRIORITY_DELTA_FAST - PRIORITY_DELTA_EXTRACT   == 0x0FFFFF10
//         PRIORITY_IMAGEEXTRACT + PRIORITY_DELTA_FAST - PRIORITY_DELTA_WRITE     == 0x0FFFFED0
//     A slow folder extract (2 tasks):
//         PRIORITY_IMAGEEXTRACT - PRIORITY_DELTA_SLOW - PRIORITY_DELTA_DISKCACHE == 0x0FFFFFB0
//         PRIORITY_IMAGEEXTRACT - PRIORITY_DELTA_SLOW - PRIORITY_DELTA_EXTRACT   == 0x0FFFFEB0
//     Notice that tasks are done in correct priority order
#define PRIORITY_DELTA_DISKCACHE    0x00000000  // This has to be the fastest task...
#define PRIORITY_DELTA_EXTRACT      0x00000100  // We want Extract to be second for most cases
#define PRIORITY_DELTA_WRITE        0x00000140  // Write tasks should be after all but the slowest extract tasks
#define PRIORITY_DELTA_FAST         0x00000010
#define PRIORITY_DELTA_SLOW         0x00000050

// Flags for _AddTask
#define ADDTASK_ATFRONT             0x00000001
#define ADDTASK_ATEND               0x00000002
#define ADDTASK_ONLYONCE            0x00000004

//
// define MAX_ICON_WAIT to be the most (in ms) we will ever wait for a
// icon to be extracted.

// define MIN_ICON_WAIT to be amount of time that has to go by
// before we start waiting again.

#define MAX_ICON_WAIT       500
#define MIN_ICON_WAIT       2500
// PRIORITIES for tasks added to the DefView background task scheduler
#define TASK_PRIORITY_BKGRND_FILL   ITSAT_DEFAULT_PRIORITY
#define TASK_PRIORITY_GET_ICON      ITSAT_DEFAULT_PRIORITY
#define TASK_PRIORITY_FILE_PROPS    PRIORITY_M3             // This is for TileView columns, we don't want to hold icon extraction for this.
#define TASK_PRIORITY_INFOTIP       ITSAT_DEFAULT_PRIORITY
#define TASK_PRIORITY_GETSTATE      PRIORITY_M5             // This is not hi-pri: figuring out the task list.
#define TASK_PRIORITY_GROUP         PRIORITY_P1             // Needs to be higher than icon extraction. Happens after background fill

#define DEFVIEW_THREAD_IDLE_TIMEOUT     (1000 * 60 * 2)

#define DV_IDTIMER_START_ANI                     1   // start the animation (after we started bk enum)
#define DV_IDTIMER_BUFFERED_REFRESH              3
#define DV_IDTIMER_NOTIFY_AUTOMATION_SELCHANGE   4
#define DV_IDTIMER_NOTIFY_AUTOMATION_NOSELCHANGE 5
#define DV_IDTIMER_DISKCACHE                     6
#define DV_IDTIMER_NOTIFY_AUTOMATION_CONTENTSCHANGED 7
#define DV_IDTIMER_SCROLL_TIMEOUT                8

#define DEFSIZE_BORDER          10
#define DEFSIZE_VERTBDR         30
#define MAX_WRITECACHE_TASKS    256

#define WM_USER_DELAY_NAVIGATION    (WM_USER + 0x1BA)   // random - can be moved - used by DUI and CPL

INT ScaleSizeBasedUponLocalization (INT iSize);

#endif // _DEFVIEWP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\defviewlegacy.h ===
class CGenList
{
public:
    CGenList(UINT cbItem) : _hList(NULL), _cbItem(cbItem) {}
    ~CGenList() {Empty();}

    void *GetPtr(UINT i)
        {return(i<GetItemCount() ? DSA_GetItemPtr(_hList, i) : NULL);}

    UINT GetItemCount() {return(_hList ? DSA_GetItemCount(_hList) : 0);}

    int Add(void *pv, int nInsert);

    void Empty() {if (_hList) DSA_Destroy(_hList); _hList=NULL;}

protected:
    void Steal(CGenList* pList)
    {
        Empty();
        _cbItem = pList->_cbItem;
        _hList = pList->_hList;
        pList->_hList = NULL;
    }

private:
    UINT _cbItem;
    HDSA _hList;
} ;

class CViewsList : public CGenList
{
public:
    CViewsList() : CGenList(SIZEOF(SFVVIEWSDATA*)), _bGotDef(FALSE) {}
    ~CViewsList() {Empty();}

    SFVVIEWSDATA* GetPtr(UINT i)
    {
        SFVVIEWSDATA** ppViewsData = (SFVVIEWSDATA**)CGenList::GetPtr(i);
        return(ppViewsData ? *ppViewsData : NULL);
    }


    int Add(const SFVVIEWSDATA*pView, int nInsert, BOOL bCopy);
    int Add(const SFVVIEWSDATA*pView, BOOL bCopy=TRUE) {return Add(pView, DA_LAST, bCopy);}
    int Prepend(const SFVVIEWSDATA*pView, BOOL bCopy=TRUE) {return Add(pView, 0, bCopy);}

    void SetDef(SHELLVIEWID const *pvid) { _bGotDef=TRUE; _vidDef=*pvid; }
    BOOL GetDef(SHELLVIEWID *pvid) { if (_bGotDef) *pvid=_vidDef; return(_bGotDef); }

    void Empty();

    static SFVVIEWSDATA* CopyData(const SFVVIEWSDATA* pData);

    int NextUnique(int nLast);

private:
    BOOL _bGotDef;
    SHELLVIEWID _vidDef;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\defvphst.cpp ===
#include "shellprv.h"
#include <regstr.h>
#include <shellp.h>
#include "ole2dup.h"
#include "ids.h"
#include "defview.h"
#include <perhist.h>
#include "defvphst.h"

// Docfind Persistent history implemention.
STDMETHODIMP CDefViewPersistHistory::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDefViewPersistHistory, IPersistHistory),             //IID_IPersistHistory
        QITABENTMULTI(CDefViewPersistHistory, IPersist, IPersistHistory), //IID_IPersist
        QITABENT(CDefViewPersistHistory, IObjectWithSite),              //IID_IOBjectWithSite
        QITABENT(CDefViewPersistHistory, IOleObject),                  // IID_IOleObject
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CDefViewPersistHistory::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CDefViewPersistHistory::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


CDefViewPersistHistory::CDefViewPersistHistory() :
        m_cRef(1)       
{
}

CDefViewPersistHistory::~CDefViewPersistHistory()
{   
}


STDAPI CDefViewPersistHistory_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT   hr;

    CDefViewPersistHistory *pdfph = new CDefViewPersistHistory();
    if (!pdfph)
    {
        *ppv = NULL;
        return E_OUTOFMEMORY;
    }

    hr = pdfph->QueryInterface(riid, ppv);
    pdfph->Release();
    return hr;    
}


// Functions to support persisting the document into the history stream...
STDMETHODIMP CDefViewPersistHistory::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_DefViewPersistHistory;
    return S_OK;
}


STDMETHODIMP CDefViewPersistHistory::LoadHistory(IStream *pstm, IBindCtx *pbc)
{
    IShellView *psv;
    if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IShellView, &psv))))
    {           
        UINT cItems = 0;
        LPITEMIDLIST pidl = NULL;    // don't free previous one
        UINT uFlags = SVSI_FOCUSED | SVSI_SELECT | SVSI_DESELECTOTHERS | SVSI_ENSUREVISIBLE;

        // read how many pidls we stored
        pstm->Read(&cItems, sizeof(cItems), NULL);

        // now read the pidls
        for (UINT i=0; i < cItems ; i++)
        {
            if (FAILED(ILLoadFromStream(pstm, &pidl)) || (pidl == NULL))
                break;
            if (SUCCEEDED(psv->SelectItem(pidl, uFlags)))
                uFlags = SVSI_SELECT;
        }
        if (pidl)
            ILFree(pidl);       // Free the last one read in

        //
        // If we are in webview mode, we need to load the Trident persist history too
        // 
        IPersistHistory * piph;
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_WebViewObject, IID_PPV_ARG(IPersistHistory, &piph))))
        {
            piph->LoadHistory(pstm, pbc);
            piph->Release();
        }                 
        psv->Release();
    }

    return S_OK;
}


STDMETHODIMP CDefViewPersistHistory::SaveHistory(IStream *pstm)
{
    IShellFolderView *psfv;
    if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IShellFolderView, &psfv))))
    {   
        LPCITEMIDLIST *apidl;
        UINT cItems;
      
        // FEATURE: Currently this assumes the first item is focused. There are cases
        // where we may have unslected the focused item and we are not saving this out here.
        //
        // Need to add GetFocusedObject() to IShellFolderView interface to query this
        //
        //
        if (SUCCEEDED(psfv->GetSelectedObjects(&apidl, &cItems)) && cItems)
        {

            // write out how many pidls we have
            pstm->Write(&cItems, sizeof(cItems), NULL);

            // now write the pidls
            for (UINT i = 0; i < cItems; i++)
            {
                if (apidl[i])
                    ILSaveToStream(pstm, apidl[i]);
            }
            LocalFree((HLOCAL)apidl);
        }
        else
        {   
            cItems = 0;
            pstm->Write(&cItems, sizeof(cItems), NULL);
        }
        
        //
        // If we are in webview mode, we need to save the Trident persist history too
        // 
        IPersistHistory * piph;
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_WebViewObject, IID_PPV_ARG(IPersistHistory, &piph))))
        {
            piph->SaveHistory(pstm);
            piph->Release();
        }               
                
        psfv->Release();
    }
    return S_OK;
}


STDMETHODIMP CDefViewPersistHistory::SetPositionCookie(DWORD dwPositioncookie)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::SetPositionCookie - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::GetPositionCookie(DWORD *pdwPositioncookie)
{
    *pdwPositioncookie = 0;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::GetPositionCookie - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::SetClientSite(IOleClientSite *pClientSite)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::SetClientSite - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::GetClientSite(IOleClientSite **ppClientSite)
{
    *ppClientSite = NULL;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::GetClientSite - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::SetHostNames - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::Close(DWORD dwSaveOption)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::Close - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::SetMoniker(DWORD dwWhichMoniker, IMoniker *pmk)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::SetMoniker - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
    *ppmk = NULL;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::GetMoniker - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::InitFromData(IDataObject *pDataObject,BOOL fCreation,DWORD dwReserved)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::InitFromData - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::GetClipboardData(DWORD dwReserved,IDataObject **ppDataObject)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::GetClipboardData - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::DoVerb(LONG iVerb,LPMSG lpmsg,IOleClientSite *pActiveSite,LONG lindex,HWND hwndParent,LPCRECT lprcPosRect)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::DoVerb - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::EnumVerbs(IEnumOLEVERB **ppEnumOleVerb)
{
    *ppEnumOleVerb = NULL;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::EnumVerbs - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::Update(void)
{
    // Always up to date.
    return S_OK;
}

STDMETHODIMP CDefViewPersistHistory::IsUpToDate(void)
{
    return S_OK;    // say we are alwayes up to date.
}

STDMETHODIMP CDefViewPersistHistory::GetUserClassID(CLSID *pClsid)
{
    return GetClassID(pClsid);
}

STDMETHODIMP CDefViewPersistHistory::GetUserType(DWORD dwFormOfType, LPOLESTR *pszUserType)
{
    *pszUserType = NULL;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::GetUserType - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::SetExtent - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::GetExtent - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection)
{
    *pdwConnection = 0;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::Advise - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::Unadvise(DWORD dwConnection)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::Unadvise - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::EnumAdvise(IEnumSTATDATA **ppenumAdvise)
{
    *ppenumAdvise = NULL;
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::EnumAdvises - not implemented"));
    return E_NOTIMPL;
}

STDMETHODIMP CDefViewPersistHistory::GetMiscStatus(DWORD dwAspect, DWORD *pdwStatus)
{
    *pdwStatus = 0;
    if (dwAspect == DVASPECT_CONTENT)
        *pdwStatus = OLEMISC_SETCLIENTSITEFIRST;
    return S_OK;
}

STDMETHODIMP CDefViewPersistHistory::SetColorScheme(LOGPALETTE *pLogpal)
{
    DebugMsg(DM_ERROR, TEXT("CDefViewPersistHistory::SetColorScheme - not implemented"));
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\defxicon.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "xiconwrap.h"

class CExtractIcon : public CExtractIconBase
{
public:
    HRESULT _GetIconLocationW(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int *piIndex, UINT *pwFlags);
    HRESULT _ExtractW(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);
    HRESULT _Init(LPCWSTR pszModule, LPCWSTR pszModuleOpen);

    CExtractIcon(int iIcon, int iIconOpen, int iDefIcon, int iShortcutIcon, UINT uFlags);

private:
    ~CExtractIcon();

private:
    int    _iIcon;
    int    _iIconOpen;
    int    _iDefIcon;
    int    _iShortcutIcon;
    UINT   _uFlags; // GIL_SIMULATEDOC/PERINSTANCE/PERCLASS
    LPWSTR _pszModule;
    LPWSTR _pszModuleOpen;
};

CExtractIcon::CExtractIcon(int iIcon, int iIconOpen, int iDefIcon, int iShortcutIcon, UINT uFlags) :
    CExtractIconBase(), 
    _iIcon(iIcon), _iIconOpen(iIconOpen),_iDefIcon(iDefIcon), _iShortcutIcon(iShortcutIcon),
    _uFlags(uFlags), _pszModule(NULL), _pszModuleOpen(NULL)
{
}

CExtractIcon::~CExtractIcon()
{
    LocalFree((HLOCAL)_pszModule);      // accpets NULL
    if (_pszModuleOpen != _pszModule)
        LocalFree((HLOCAL)_pszModuleOpen);  // accpets NULL
}

HRESULT CExtractIcon::_Init(LPCWSTR pszModule, LPCWSTR pszModuleOpen)
{
    HRESULT hr = S_OK;

    _pszModule = StrDup(pszModule);
    if (_pszModule)
    {
        if (pszModuleOpen)
        {
            _pszModuleOpen = StrDup(pszModuleOpen);

            if (!_pszModuleOpen)
            {
                LocalFree((HLOCAL)_pszModule);
                _pszModule = NULL;

                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            _pszModuleOpen = _pszModule;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDAPI SHCreateDefExtIcon(LPCWSTR pszModule, int iIcon, int iIconOpen, UINT uFlags, int iDefIcon, REFIID riid, void** ppv)
{
    return SHCreateDefExtIconKey(NULL, pszModule, iIcon, iIconOpen, iDefIcon, iIcon, uFlags, riid, ppv);
}

// returns S_FALSE to mean "The hkey didn't have an icon so I created a default one"

STDAPI SHCreateDefExtIconKey(HKEY hkey, LPCWSTR pszModule, int iIcon, int iIconOpen, int iDefIcon, int iShortcutIcon, UINT uFlags, REFIID riid, void **ppv)
{
    WCHAR szModule[MAX_PATH];
    WCHAR szModuleOpen[MAX_PATH];
    HRESULT hr;

    HRESULT hrSuccess = S_OK;
    LPWSTR pszModuleOpen = NULL;

    if (hkey)
    {
        HKEY hkChild;

        if (RegOpenKeyEx(hkey, c_szDefaultIcon, 0, KEY_QUERY_VALUE,
            &hkChild) == ERROR_SUCCESS)
        {
            DWORD cb = sizeof(szModule);

            if (SHQueryValueEx(hkChild, NULL, NULL, NULL, szModule, &cb) ==
                ERROR_SUCCESS && szModule[0])
            {
                iIcon = PathParseIconLocation(szModule);
                iIconOpen = iIcon;
                pszModule = szModule;

                cb = sizeof(szModuleOpen);
                if (SHQueryValueEx(hkChild, TEXT("OpenIcon"), NULL, NULL,
                    szModuleOpen, &cb) == ERROR_SUCCESS && szModuleOpen[0])
                {
                    iIconOpen = PathParseIconLocation(szModuleOpen);
                    pszModuleOpen = szModuleOpen;
                }
            }
            else
            {
                hrSuccess = S_FALSE;
            }

            RegCloseKey(hkChild);
        }
        else
        {
            hrSuccess = S_FALSE;
        }
    }

    if ((NULL == pszModule) || (0 == *pszModule))
    {
        // REVIEW: We should be able to make it faster!
        GetModuleFileName(HINST_THISDLL, szModule, ARRAYSIZE(szModule));
        pszModule = szModule;
    }

    CExtractIcon* pdeib = new CExtractIcon(iIcon, iIconOpen, iDefIcon, iShortcutIcon, uFlags);
    if (pdeib)
    {
        hr = pdeib->_Init(pszModule, pszModuleOpen);
        if (SUCCEEDED(hr))
        {
            hr = pdeib->QueryInterface(riid, ppv);
        }
        pdeib->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        hr = hrSuccess;
    }

    return hr;
}

HRESULT CExtractIcon::_GetIconLocationW(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int *piIndex, UINT *pwFlags)
{
    HRESULT hr = S_FALSE;
    pszIconFile[0] = 0;


    if (uFlags & GIL_DEFAULTICON)
    {
        if (-1 != _iDefIcon)
        {
            hr = StringCchCopy(pszIconFile, cchMax, c_szShell32Dll);
            if (SUCCEEDED(hr))
            {

                *piIndex = _iDefIcon;
                *pwFlags = _uFlags;

                // Make sure our default icon makes it to the cache
                Shell_GetCachedImageIndex(pszIconFile, *piIndex, *pwFlags);
            }
        }
    }
    else
    {
        int iIcon;

        if ((uFlags & GIL_FORSHORTCUT) && (-1 != _iShortcutIcon))
        {
            iIcon = _iShortcutIcon;
        }
        else if (uFlags & GIL_OPENICON)
        {
            iIcon = _iIconOpen;
        }
        else
        {
            iIcon = _iIcon;
        }

        if ((UINT)-1 != iIcon)
        {
            hr = StringCchCopy(pszIconFile, cchMax, (uFlags & GIL_OPENICON) ? _pszModuleOpen : _pszModule);
            if (SUCCEEDED(hr))
            {
                *piIndex = iIcon;
                *pwFlags = _uFlags;
            }
        }
    }

    return hr;
}

HRESULT CExtractIcon::_ExtractW(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    HRESULT hr = S_FALSE;

    if (_uFlags & GIL_NOTFILENAME)
    {
        //  "*" as the file name means iIndex is already a system
        //  icon index, we are done.
        //
        //  defview never calls us in this case, but external people will.
        if ((L'*' == pszFile[0]) && (0 == pszFile[1]))
        {
            DebugMsg(DM_TRACE, TEXT("DefExtIcon::_Extract handling '*' for backup"));

            HIMAGELIST himlLarge, himlSmall;
            Shell_GetImageLists(&himlLarge, &himlSmall);
        
            if (phiconLarge)
                *phiconLarge = ImageList_GetIcon(himlLarge, nIconIndex, 0);

            if (phiconSmall)
                *phiconSmall = ImageList_GetIcon(himlSmall, nIconIndex,
                0);

            hr = S_OK;
        }

        //  this is the case where nIconIndex is a unique id for the
        //  file.  always get the first icon.

        nIconIndex = 0;
    }

    if (S_FALSE == hr)
    {
        hr = SHDefExtractIcon(pszFile, nIconIndex, _uFlags, phiconLarge, phiconSmall, nIconSize);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\deskfldr.cpp ===
#include "shellprv.h"
#include "deskfldr.h"
#include "fstreex.h"
#include "datautil.h"
#include "views.h"
#include "ids.h"
#include "caggunk.h"
#include "shitemid.h"
#include "basefvcb.h"
#include "filefldr.h"
#include "drives.h"
#include "infotip.h"
#include "prop.h"
#include <idhidden.h>
#include "cowsite.h"
#include "unicpp\deskhtm.h"
#include "sfstorage.h"
#include <cfgmgr32.h>          // MAX_GUID_STRING_LEN

#include "defcm.h"

#define  EXCLUDE_COMPPROPSHEET
#include "unicpp\dcomp.h"
#undef   EXCLUDE_COMPPROPSHEET

//  TODO - maybe we should add rooted folders to the AnyAlias's - ZekeL - 27-JAN-2000
class CDesktopRootedStub : public IShellFolder2, public IContextMenuCB
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return E_UNEXPECTED;}
    STDMETHODIMP_(ULONG) AddRef(void)  { return 3; }
    STDMETHODIMP_(ULONG) Release(void) { return 2; }
    
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return ILRootedBindToObject(pidl, riid, ppv);}
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {
            LPCITEMIDLIST pidlChild;
            IShellFolder *psf;
            HRESULT hr = ILRootedBindToParentFolder(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
            if (SUCCEEDED(hr))
            {
                hr = psf->BindToStorage(pidlChild, pbc, riid, ppv);
                psf->Release();
            }
            return hr;
        }
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
        {
            if (ILIsEqualRoot(pidl1, pidl2))
            {
                return ILCompareRelIDs(SAFECAST(this, IShellFolder *), pidl1, pidl2, lParam);
            }
            else
            {
                UINT cb1 = ILGetSize(pidl1);
                UINT cb2 = ILGetSize(pidl2); 
                short i = (short) memcmp(pidl1, pidl2, min(cb1, cb2));

                if (i == 0)
                    i = cb1 - cb2;
                return ResultFromShort(i);
            }
            return ResultFromShort(-1);
        }
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut)
        {
            HRESULT hr = E_INVALIDARG;
            if (cidl == 1)
            {
                LPCITEMIDLIST pidlChild;
                IShellFolder *psf;
                hr = ILRootedBindToParentFolder(apidl[0], IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
                if (SUCCEEDED(hr))
                {
                    hr = psf->GetAttributesOf(1, &pidlChild, rgfInOut);
                    psf->Release();
                }
            }
            return hr;
        }
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
        {
            LPCITEMIDLIST pidlChild;
            IShellFolder *psf;
            HRESULT hr = ILRootedBindToParentFolder(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
            if (SUCCEEDED(hr))
            {
                hr = psf->GetDisplayNameOf(pidlChild, uFlags, lpName);
                psf->Release();
            }
            return hr;
        }
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut)
        {return E_NOTIMPL;}

    // IShellFolder2 methods
    STDMETHODIMP GetDefaultSearchGUID(LPGUID lpGuid)
        {return E_NOTIMPL;}
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
        {
            LPCITEMIDLIST pidlChild;
            IShellFolder2 *psf;
            HRESULT hr = ILRootedBindToParentFolder(pidl, IID_PPV_ARG(IShellFolder2, &psf), &pidlChild);
            if (SUCCEEDED(hr))
            {
                hr = psf->GetDetailsEx(pidlChild, pscid, pv);
                psf->Release();
            }
            return hr;
        }
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
        {
            LPCITEMIDLIST pidlChild;
            IShellFolder2 *psf;
            HRESULT hr = ILRootedBindToParentFolder(pidl, IID_PPV_ARG(IShellFolder2, &psf), &pidlChild);
            if (SUCCEEDED(hr))
            {
                hr = psf->GetDetailsOf(pidlChild, iColumn, pDetails);
                psf->Release();
            }
            return hr;
        }
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
        {return E_NOTIMPL;}

    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, 
                     UINT uMsg, WPARAM wParam, LPARAM lParam)
        {return (uMsg == DFM_MERGECONTEXTMENU) ? S_OK : E_NOTIMPL;}
                     
};


class CShellUrlStub : public IShellFolder
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return E_UNEXPECTED;}
    STDMETHODIMP_(ULONG) AddRef(void)  { return 3; }
    STDMETHODIMP_(ULONG) Release(void) { return 2; }
    
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
        {return E_NOTIMPL;}
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut)
        {return E_NOTIMPL;}
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
        {return E_NOTIMPL;}
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut)
        {return E_NOTIMPL;}
};

class CIDListUrlStub : public IShellFolder
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return E_UNEXPECTED;}
    STDMETHODIMP_(ULONG) AddRef(void)  { return 3; }
    STDMETHODIMP_(ULONG) Release(void) { return 2; }
    
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
        {return E_NOTIMPL;}
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut)
        {return E_NOTIMPL;}
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
        {return E_NOTIMPL;}
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut)
        {return E_NOTIMPL;}
};

class CFileUrlStub : public IShellFolder
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return E_UNEXPECTED;}
    STDMETHODIMP_(ULONG) AddRef(void)  { return 3; }
    STDMETHODIMP_(ULONG) Release(void) { return 2; }
    
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
        {return E_NOTIMPL;}
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut)
        {return E_NOTIMPL;}
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
        {return E_NOTIMPL;}
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut)
        {return E_NOTIMPL;}
};

class CHttpUrlStub : public IShellFolder
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return E_UNEXPECTED;}
    STDMETHODIMP_(ULONG) AddRef(void)  { return 3; }
    STDMETHODIMP_(ULONG) Release(void) { return 2; }
    
    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
        {return E_NOTIMPL;}
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut)
        {return E_NOTIMPL;}
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv)
        {return E_NOTIMPL;}
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName)
        {return E_NOTIMPL;}
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut)
        {return E_NOTIMPL;}
};

class CDesktopFolderEnum;
class CDesktopViewCallBack;
class CDesktopFolderDropTarget;

class CDesktopFolder : CObjectWithSite
                     , CSFStorage
                     , public IPersistFolder2
                     , public IShellIcon
                     , public IShellIconOverlay
                     , public IContextMenuCB
                     , public ITranslateShellChangeNotify
                     , public IItemNameLimits
                     , public IOleCommandTarget
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void)  { return 3; };
    STDMETHODIMP_(ULONG) Release(void) { return 2; };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwnd, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut);

    // IShellFolder2 methods
    STDMETHODIMP GetDefaultSearchGUID(LPGUID lpGuid);
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid);

    // IPersist
    STDMETHODIMP GetClassID(LPCLSID lpClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IShellIcon methods
    STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, int *piIndex);

    // IShellIconOverlay methods
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int * pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int * pIndex);
  
    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // ITranslateShellChangeNotify
    STDMETHODIMP TranslateIDs(LONG *plEvent, 
                                LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, 
                                LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
                                LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
                                LPITEMIDLIST *ppidlOut2Event2);
    STDMETHODIMP IsChildID(LPCITEMIDLIST pidlKid, BOOL fImmediate) { return E_NOTIMPL; }
    STDMETHODIMP IsEqualID(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) { return E_NOTIMPL; }
    STDMETHODIMP Register(HWND hwnd, UINT uMsg, long lEvents) { return E_NOTIMPL; }
    STDMETHODIMP Unregister() { return E_NOTIMPL; }

    // IItemNameLimits
    STDMETHODIMP GetValidCharacters(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars);
    STDMETHODIMP GetMaxLength(LPCWSTR pszName, int *piMaxNameLen);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    CDesktopFolder(IUnknown *punkOuter);
    HRESULT _Init();
    HRESULT _Init2();
    void _Destroy();

private:
    ~CDesktopFolder();

    friend CDesktopFolderEnum;
    friend CDesktopViewCallBack;

    // IStorage virtuals
    STDMETHOD(_DeleteItemByIDList)(LPCITEMIDLIST pidl);
    STDMETHOD(_StgCreate)(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv);                

    HRESULT _BGCommand(HWND hwnd, WPARAM wparam, BOOL bExecute);
    IShellFolder2 *_GetItemFolder(LPCITEMIDLIST pidl);
    HRESULT _GetItemUIObject(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, REFIID riid, UINT *prgfInOut, void **ppv);
    HRESULT _QueryInterfaceItem(LPCITEMIDLIST pidl, REFIID riid, void **ppv);
    HRESULT _ChildParseDisplayName(IShellFolder *psfRight, LPCITEMIDLIST pidlLeft, HWND hwnd, IBindCtx *pbc, 
                LPWSTR pwzDisplayName, ULONG *pchEaten, LPITEMIDLIST *ppidl, DWORD *pdwAttributes);
    BOOL _TryUrlJunctions(LPCTSTR pszName, IBindCtx *pbc, IShellFolder **ppsf, LPITEMIDLIST *ppidlLeft);
    BOOL _GetFolderForParsing(LPCTSTR pszName, LPBC pbc, IShellFolder **ppsf, LPITEMIDLIST *ppidlLeft);
    HRESULT _SelfAssocCreate(REFIID riid, void **ppv);
    HRESULT _SelfCreateContextMenu(HWND hwnd, void **ppv);

    IShellFolder2 *_psfDesktop;         // "Desktop" shell folder (real files live here)
    IShellFolder2 *_psfAltDesktop;      // "Common Desktop" shell folder
    IUnknown *_punkReg;                 // regitem inner folder (agregate)
    CDesktopRootedStub _sfRooted;       // rooted folder stub object
    CShellUrlStub _sfShellUrl;          // handles parsing shell: Urls
    CIDListUrlStub _sfIDListUrl;        // handles parsing ms-shell-idlist: Urls
    CFileUrlStub _sfFileUrl;            // handles parsing file: Urls
    CHttpUrlStub _sfHttpUrl;            // handles parsing http: and https: Urls
};

class CDesktopFolderEnum : public IEnumIDList
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv); 
    STDMETHODIMP_(ULONG) AddRef(void); 
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList
    STDMETHOD(Next)(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumIDList **ppenum);
    
    CDesktopFolderEnum(CDesktopFolder *pdf, HWND hwnd, DWORD grfFlags);

private:
    ~CDesktopFolderEnum();

    LONG _cRef;
    BOOL _bUseAltEnum;
    IEnumIDList *_penumFolder;
    IEnumIDList *_penumAltFolder;
};

class CDesktopViewCallBack : public CBaseShellFolderViewCB, public IFolderFilter
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) { return CBaseShellFolderViewCB::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) { return CBaseShellFolderViewCB::Release(); };

    // IFolderFilter
    STDMETHODIMP ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem);
    STDMETHODIMP GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags);
    
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    CDesktopViewCallBack(CDesktopFolder* pdf);
    friend HRESULT Create_CDesktopViewCallback(CDesktopFolder* pdf, IShellFolderViewCB** ppv);

    HRESULT OnSupportsIdentity(DWORD pv);
    HRESULT OnGETCCHMAX(DWORD pv, LPCITEMIDLIST pidlItem, UINT *lP);
    HRESULT OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvit);
    HRESULT OnGetWorkingDir(DWORD pv, UINT wP, LPTSTR pszDir);
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);

    CDesktopFolder* _pdf;
    BOOL    _fCheckedIfRealDesktop;
    BOOL    _fRealDesktop;

};
HRESULT Create_CDesktopViewCallback(CDesktopFolder* pdf, IShellFolderViewCB** ppv);

class CDesktopFolderDropTarget : public IDropTarget, CObjectWithSite
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject* pDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    STDMETHODIMP Drop(IDataObject* pDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect);
    STDMETHODIMP DragLeave(void);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown* punkSite);

    CDesktopFolderDropTarget(IDropTarget* pdt);
private:
    ~CDesktopFolderDropTarget();
    STDMETHODIMP_(BOOL) _IsSpecialCaseDrop(IDataObject* pDataObject, DWORD grfKeyState, BOOL* pfIsPIDA, UINT* pcItems);
    STDMETHODIMP        _ShowIEIcon();

    IDropTarget* _pdt;
    LONG _cRef;
};


// some fields are modified so this can't be const
REQREGITEM g_asDesktopReqItems[] =
{
    { 
        &CLSID_MyComputer,  IDS_DRIVEROOT,  
        TEXT("explorer.exe"), 0, SORT_ORDER_DRIVES, 
        SFGAO_HASSUBFOLDER | SFGAO_HASPROPSHEET | SFGAO_FILESYSANCESTOR | SFGAO_DROPTARGET | SFGAO_FOLDER | SFGAO_CANRENAME | SFGAO_CANDELETE,
        TEXT("SYSDM.CPL")
    },
    { 
        &CLSID_NetworkPlaces, IDS_NETWORKROOT, 
        TEXT("shell32.dll"), -IDI_MYNETWORK, SORT_ORDER_NETWORK, 
        SFGAO_HASSUBFOLDER | SFGAO_HASPROPSHEET | SFGAO_FILESYSANCESTOR | SFGAO_DROPTARGET | SFGAO_FOLDER | SFGAO_CANRENAME | SFGAO_CANDELETE,
        TEXT("NCPA.CPL"),
    },
    { 
        &CLSID_Internet, IDS_INETROOT, 
        TEXT("mshtml.dll"),   0, SORT_ORDER_INETROOT, 
        SFGAO_BROWSABLE  | SFGAO_HASPROPSHEET | SFGAO_CANRENAME, 
        TEXT("INETCPL.CPL")
    },
};

const ITEMIDLIST c_idlDesktop = { { 0, 0 } };

#define DESKTOP_PIDL  ((LPITEMIDLIST)&c_idlDesktop)

// single global instance of this CDesktopFolder object
CDesktopFolder *g_pDesktopFolder = NULL;

REGITEMSINFO g_riiDesktop =
{
    REGSTR_PATH_EXPLORER TEXT("\\Desktop\\NameSpace"),
    NULL,
    TEXT(':'),
    SHID_ROOT_REGITEM,
    1,
    SFGAO_CANLINK,
    ARRAYSIZE(g_asDesktopReqItems),
    g_asDesktopReqItems,
    RIISA_ORIGINAL,
    NULL,
    0,
    0,
};


void Desktop_InitRequiredItems(void)
{
    //  "NoNetHood" restriction -> always hide the hood.
    //  Otherwise, show the hood if either MPR says so or we have RNA.
    if (SHRestricted(REST_NONETHOOD))
    {
        // Don't enumerate the "Net Hood" thing.
        g_asDesktopReqItems[CDESKTOP_REGITEM_NETWORK].dwAttributes |= SFGAO_NONENUMERATED;
    }
    else
    {
        // Do enumerate the "My Network" thing.
        g_asDesktopReqItems[CDESKTOP_REGITEM_NETWORK].dwAttributes &= ~SFGAO_NONENUMERATED;
    }
    
    //  "MyComp_NoProp" restriction -> hide Properties context menu entry on My Computer 
    if (SHRestricted(REST_MYCOMPNOPROP))
    {
        g_asDesktopReqItems[CDESKTOP_REGITEM_DRIVES].dwAttributes &= ~SFGAO_HASPROPSHEET;
    }

    //
    // "NoInternetIcon" restriction or AppCompat -> hide The Internet on the desktop
    //
    //  Word Perfect 7 faults when it enumerates the Internet item
    // in their background thread.  For now App hack specific to this app
    // later may need to extend...  Note: This app does not install on
    // NT so only do for W95...
    // it repros with Word Perfect Suite 8, too, this time on both NT and 95
    // so removing the #ifndef... -- reljai 11/20/97, bug#842 in ie5 db
    //
    //  we used to remove the SFGAO_BROWSABLE flag for both of these cases - ZekeL - 19-Dec-2000
    //  but ShellExec() needs SFGAO_BROWSABLE so that parsing URLs succeeds
    //  if it turns out that we need to exclude the BROWSABLE, then we should
    //  change regfldr to look at a value like "WantsToParseDisplayName" under
    //  the CLSID.  or we could add routing code in deskfldr (like we have for
    //  MyComputer and NetHood) to pass it to the internet folder directly
    //
    if (SHRestricted(REST_NOINTERNETICON) || (SHGetAppCompatFlags(ACF_CORELINTERNETENUM) & ACF_CORELINTERNETENUM))
    {
        //  g_asDesktopReqItems[CDESKTOP_REGITEM_INTERNET].dwAttributes &=  ~(SFGAO_BROWSABLE);
        g_asDesktopReqItems[CDESKTOP_REGITEM_INTERNET].dwAttributes |= SFGAO_NONENUMERATED;
    }
}

CDesktopFolder::CDesktopFolder(IUnknown *punkOuter)
{
    DllAddRef();
}

CDesktopFolder::~CDesktopFolder()
{
    DllRelease();
}

// first phase of init (does not need to be seralized)

HRESULT CDesktopFolder::_Init()
{
    Desktop_InitRequiredItems();
    return CRegFolder_CreateInstance(&g_riiDesktop, SAFECAST(this, IShellFolder2 *), IID_PPV_ARG(IUnknown, &_punkReg));
}

// second phase of init (needs to be seralized)

HRESULT CDesktopFolder::_Init2()
{
    HRESULT hr = SHCacheTrackingFolder(DESKTOP_PIDL, CSIDL_DESKTOPDIRECTORY | CSIDL_FLAG_CREATE, &_psfDesktop);
    if (FAILED(hr))
    {
        DebugMsg(DM_TRACE, TEXT("Failed to create desktop IShellFolder!"));
        return hr;
    }

    if (!SHRestricted(REST_NOCOMMONGROUPS))
    {
        hr = SHCacheTrackingFolder(DESKTOP_PIDL, CSIDL_COMMON_DESKTOPDIRECTORY, &_psfAltDesktop);
    }

    return hr;
}

// CLSID_ShellDesktop constructor

STDAPI CDesktop_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;

    if (g_pDesktopFolder)
    {
        hr = g_pDesktopFolder->QueryInterface(riid, ppv);
    }
    else
    {
        *ppv = NULL;

        // WARNING: the order of init of the desktop folder state is very important.
        // the creation of the sub folders, in particular _psfAltDesktop will
        // recurse on this function. we protect ourself from that here. the creation
        // of that also requires the above members to be inited.

        CDesktopFolder *pdf = new CDesktopFolder(punkOuter);
        if (pdf)
        {
            hr = pdf->_Init();
            if (SUCCEEDED(hr))
            {
                // NOTE: there is a race condition here where we have stored g_pDesktopFolder but
                // not initialized _psfDesktop & _psfAltDesktop. the main line code deals with
                // this by testing for NULL on these members.
                if (SHInterlockedCompareExchange((void **)&g_pDesktopFolder, pdf, 0))
                {
                    // Someone else beat us to creating the object.
                    // get rid of our copy, global already set (the race case)
                    pdf->_Destroy();    
                }
                else
                {
                    g_pDesktopFolder->_Init2();
                }
                hr = g_pDesktopFolder->QueryInterface(riid, ppv);
            }
            else
                pdf->_Destroy();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }            
    }
    return hr;
}


STDAPI SHGetDesktopFolder(IShellFolder **ppshf)
{
    return CDesktop_CreateInstance(NULL, IID_PPV_ARG(IShellFolder, ppshf));
}

IShellFolder2 *CDesktopFolder::_GetItemFolder(LPCITEMIDLIST pidl)
{
    IShellFolder2 *psf = NULL;
    if (ILIsRooted(pidl))
        psf = SAFECAST(&_sfRooted, IShellFolder2 *);
    else if (_psfAltDesktop && CFSFolder_IsCommonItem(pidl))
        psf = _psfAltDesktop;
    else 
        psf = _psfDesktop;

    return psf;
}

HRESULT CDesktopFolder::_QueryInterfaceItem(LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    HRESULT hr;
    IShellFolder2 *psf = _GetItemFolder(pidl);
    if (psf)
        hr = psf->QueryInterface(riid, ppv);
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDAPI_(BOOL) RegGetsFirstShot(REFIID riid)
{
    return (IsEqualIID(riid, IID_IShellFolder) ||
            IsEqualIID(riid, IID_IShellFolder2) ||
            IsEqualIID(riid, IID_IShellIconOverlay));
}

HRESULT CDesktopFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDesktopFolder, IShellFolder2),                      
        QITABENTMULTI(CDesktopFolder, IShellFolder, IShellFolder2),   
        QITABENT(CDesktopFolder, IShellIcon),                         
        QITABENT(CDesktopFolder, IPersistFolder2),                    
        QITABENTMULTI(CDesktopFolder, IPersistFolder, IPersistFolder2),
        QITABENTMULTI(CDesktopFolder, IPersist, IPersistFolder2),     
        QITABENT(CDesktopFolder, IShellIconOverlay),                  
        QITABENT(CDesktopFolder, IStorage),
        QITABENT(CDesktopFolder, IContextMenuCB),
        QITABENT(CDesktopFolder, IObjectWithSite),
        QITABENT(CDesktopFolder, ITranslateShellChangeNotify),
        QITABENT(CDesktopFolder, IItemNameLimits),
        QITABENT(CDesktopFolder, IOleCommandTarget),
        { 0 },
    };

    if (IsEqualIID(riid, CLSID_ShellDesktop))
    {
        *ppv = this;     // class pointer (unrefed!)
        return S_OK;
    }

    HRESULT hr;
    if (_punkReg && RegGetsFirstShot(riid))
    {
        hr = _punkReg->QueryInterface(riid, ppv);
    }
    else
    {
        hr = QISearch(this, qit, riid, ppv);
        if ((E_NOINTERFACE == hr) && _punkReg)
        {
            hr = _punkReg->QueryInterface(riid, ppv);
        }
    }
    return hr;
}


// During shell32.dll process detach, we will call here to do the final
// release of the IShellFolder ptrs which used to be left around for the
// life of the process.  This quiets things such as OLE's debug allocator,
// which detected the leak.


void CDesktopFolder::_Destroy()
{
    ATOMICRELEASE(_psfDesktop);
    ATOMICRELEASE(_psfAltDesktop);
    SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), &_punkReg);
    delete this;
}

LPITEMIDLIST CreateMyComputerIDList()
{
    return ILCreateFromPath(TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}")); // CLSID_MyComputer
}

LPITEMIDLIST CreateWebFoldersIDList()
{
    return ILCreateFromPath(TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{BDEADF00-C265-11D0-BCED-00A0C90AB50F}")); // CLSID_MyComputer\CLSID_WebFolders
}

LPITEMIDLIST CreateMyNetPlacesIDList()
{
    return ILCreateFromPath(TEXT("::{208D2C60-3AEA-1069-A2D7-08002B30309D}")); // CLSID_NetworkPlaces
}

HRESULT CDesktopFolder::_ChildParseDisplayName(IShellFolder *psfRight, LPCITEMIDLIST pidlLeft, HWND hwnd, IBindCtx *pbc, 
                LPWSTR pwzDisplayName, ULONG *pchEaten, LPITEMIDLIST *ppidl, DWORD *pdwAttributes)
{
    LPITEMIDLIST pidlRight;
    HRESULT hr = psfRight->ParseDisplayName(hwnd, pbc, pwzDisplayName, pchEaten, &pidlRight, pdwAttributes);
    if (SUCCEEDED(hr))
    {
        if (pidlLeft)
        {
            hr = SHILCombine(pidlLeft, pidlRight, ppidl);
            ILFree(pidlRight);
        }
        else 
        {
            *ppidl = pidlRight;
        }            
    }
    return hr;
}

STDMETHODIMP CDesktopRootedStub::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl,
                                               REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    if (cidl == 1)
    {
        if (IsEqualIID(riid, IID_IDataObject))
        {
            hr = CIDLData_CreateFromIDArray(&c_idlDesktop, cidl, apidl, (IDataObject **)ppv);
        }
        else if (IsEqualIID(riid, IID_IContextMenu))
        {
            IQueryAssociations *pqa;
            if (SUCCEEDED(SHGetAssociations(apidl[0], (void **)&pqa)))
            {
                HKEY keys[5];
                DWORD cKeys = SHGetAssocKeys(pqa, keys, ARRAYSIZE(keys));

                hr = CDefFolderMenu_Create2Ex(&c_idlDesktop, hwnd,
                                              cidl, apidl, this, this,
                                              cKeys, keys,  (IContextMenu **)ppv);

                SHRegCloseKeys(keys, cKeys);
            }
        }
        else
        {
            LPCITEMIDLIST pidlChild;
            IShellFolder *psf;
            hr = ILRootedBindToParentFolder(apidl[0], IID_PPV_ARG(IShellFolder, &psf), &pidlChild);
            if (SUCCEEDED(hr))
            {
                hr = psf->GetUIObjectOf(hwnd, 1, &pidlChild, riid, prgfInOut, ppv);
                psf->Release();
            }
        }
    }
    return hr;
}

// Check the registry for a shell root under this CLSID.
BOOL GetRootFromRootClass(CLSID *pclsid, LPWSTR pszPath, int cchPath)
{
    WCHAR szClsid[GUIDSTR_MAX];
    WCHAR szClass[MAX_PATH];

    SHStringFromGUIDW(*pclsid, szClsid, ARRAYSIZE(szClsid));
    wnsprintfW(szClass, ARRAYSIZE(szClass), L"CLSID\\%s\\ShellExplorerRoot", szClsid);

    DWORD cbPath = cchPath * sizeof(WCHAR);

    return SHGetValueGoodBootW(HKEY_CLASSES_ROOT, szClass, NULL, NULL, (BYTE *)pszPath, &cbPath) == ERROR_SUCCESS;
}

//
//  General form for Rooted URLs:
//      ms-shell-root:{clsid}?URL
//          {CLSID} is not required, defaults to CLSID_ShellDesktop
//          URL is also not required.  if there is a CLSID defaults to 
//              what is specified under "CLSID\{CLSID}\ShellExplorerRoot
//              or default to CSIDL_DESKTOP
//          but one of them at least must be specified
//  rooted:{clsid}?idlist
//

STDMETHODIMP CDesktopRootedStub::ParseDisplayName(HWND hwnd, 
                                       LPBC pbc, WCHAR *pwzDisplayName, ULONG *pchEaten,
                                       LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    //  Need to keep the internet SF from getting a chance to parse
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
    PARSEDURLW pu = {0};
    pu.cbSize = sizeof(pu);
    ParseURLW(pwzDisplayName, &pu);
    ASSERT(pu.nScheme == URL_SCHEME_MSSHELLROOTED);

    LPCWSTR pszUrl = StrChrW(pu.pszSuffix, L':');
    
    if (pszUrl++)
    {
        WCHAR szField[MAX_PATH];
        CLSID clsid;
        CLSID *pclsidRoot = GUIDFromStringW(pu.pszSuffix, &clsid) ? &clsid : NULL;

        // path might come from the registry
        // if nothing was passed in.
        if (!*pszUrl && GetRootFromRootClass(pclsidRoot, szField, ARRAYSIZE(szField)))
        {
            pszUrl = szField;
        }

        if (pclsidRoot || *pszUrl)
        {
            LPITEMIDLIST pidlRoot = ILCreateFromPathW(pszUrl);

            // fix up bad cmd line "explorer.exe /root," case
            if (!pidlRoot)
                SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP, &pidlRoot);

            if (pidlRoot)
            {
                *ppidl = ILRootedCreateIDList(pclsidRoot, pidlRoot);
                if (*ppidl)
                {
                    hr = S_OK;
                }
                ILFree(pidlRoot);
            }
        }
    }

    return hr;
}

STDMETHODIMP CIDListUrlStub::ParseDisplayName(HWND hwnd, LPBC pbc, WCHAR *pwzDisplayName, 
                                        ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    //  Need to keep the internet SF from getting a chance to parse
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
    PARSEDURLW pu = {0};
    pu.cbSize = sizeof(pu);
    ParseURLW(pwzDisplayName, &pu);
    ASSERT(pu.nScheme == URL_SCHEME_MSSHELLIDLIST);

    LPCWSTR psz = pu.pszSuffix;
    if (psz)
    {
        HANDLE hMem = LongToHandle(StrToIntW(psz));
        psz = StrChrW(psz, TEXT(':'));
        if (psz++)
        {
            DWORD dwProcId = (DWORD)StrToIntW(psz);
            LPITEMIDLIST pidlGlobal = (LPITEMIDLIST)SHLockShared(hMem, dwProcId);
            if (pidlGlobal)
            {
                hr = SHILClone(pidlGlobal, ppidl);
                SHUnlockShared(pidlGlobal);
                SHFreeShared(hMem, dwProcId);
            }
        }
    }
    return hr;
}

STDMETHODIMP CFileUrlStub::ParseDisplayName(HWND hwnd, LPBC pbc, WCHAR *pwzDisplayName, 
                                            ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    LPCWSTR pszFragment = UrlGetLocationW(pwzDisplayName);
    WCHAR szPath[MAX_URL_STRING];
    DWORD cchPath = ARRAYSIZE(szPath);
    WCHAR szQuery[MAX_URL_STRING];
    DWORD cchQuery = ARRAYSIZE(szQuery) - 1;

    //  We want to remove QUERY and FRAGMENT sections of
    //  FILE URLs because they need to be added in "Hidden" pidls.
    //  Also, URLs need to be escaped all the time except for paths
    //  to facility parsing and because we already removed all other
    //  parts of the URL (Query and Fragment).
    ASSERT(UrlIsW(pwzDisplayName, URLIS_FILEURL));
    
    if (SUCCEEDED(UrlGetPartW(pwzDisplayName, szQuery+1, &cchQuery, URL_PART_QUERY, 0)) && cchQuery)
        szQuery[0] = TEXT('?');
    else
        szQuery[0] = 0;

    if (SUCCEEDED(PathCreateFromUrlW(pwzDisplayName, szPath, &cchPath, 0))) 
    {
        //  WARNING - we skip supporting simple ids here
        ILCreateFromPathEx(szPath, NULL, ILCFP_FLAG_NORMAL, ppidl, pdwAttributes);
        
        if (*ppidl && pszFragment)
        {
            *ppidl = ILAppendHiddenStringW(*ppidl, IDLHID_URLFRAGMENT, pszFragment);
        }

        if (*ppidl && szQuery[0] == TEXT('?'))
        {
            *ppidl = ILAppendHiddenStringW(*ppidl, IDLHID_URLQUERY, szQuery);
        }

        E_OUTOFMEMORY;
    }

    //  Need to keep the internet SF from getting a chance to parse
    return *ppidl ? S_OK : HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
}

STDAPI_(int) SHGetSpecialFolderID(LPCWSTR pszName);

//
//  Given a string of the form
//
//      programs\My Pictures\Vacation
//
//
//  return CSIDL_PROGRAMS and set ppwszUnparsed to "My Pictures\Vacation".
//
//  If there is no backslash, then ppwszUnparsed = NULL.
//
//  This function is broken out of CShellUrlStub::ParseDisplayName() to conserve stack space,
//  since ParseDisplayName is used by 16-bit ShellExecute.

STDAPI_(int) _ParseSpecialFolder(LPCWSTR pszName, LPWSTR *ppwszUnparsed, ULONG *pcchEaten)
{
    LPCWSTR pwszKey;
    WCHAR wszKey[MAX_PATH];

    LPWSTR pwszBS = StrChrW(pszName, L'\\');
    if (pwszBS)
    {
        *ppwszUnparsed = pwszBS + 1;
        *pcchEaten = (ULONG)(pwszBS + 1 - pszName);
        StrCpyNW(wszKey, pszName, min(*pcchEaten, MAX_PATH));
        pwszKey = wszKey;
    }
    else
    {
        *ppwszUnparsed = NULL;
        pwszKey = pszName;
        *pcchEaten = lstrlenW(pwszKey);
    }

    return SHGetSpecialFolderID(pwszKey);
}

        
STDMETHODIMP CShellUrlStub::ParseDisplayName(HWND hwnd, 
                                       LPBC pbc, WCHAR *pwzDisplayName, ULONG *pchEaten,
                                       LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    PARSEDURLW pu = {0};
    pu.cbSize = sizeof(pu);
    EVAL(SUCCEEDED(ParseURLW(pwzDisplayName, &pu)));
    //  Need to keep the internet SF from getting a chance to parse
    //  the shell: URLs even if we fail to parse it
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);

    ASSERT(pu.nScheme == URL_SCHEME_SHELL);

    // shell:::{guid}
    if (pu.pszSuffix[0] == L':' && pu.pszSuffix[1] == L':')
    {
        IShellFolder *psfDesktop;

        hr = SHGetDesktopFolder(&psfDesktop);
        if (SUCCEEDED(hr))
        {
            IBindCtx *pbcCreate = NULL;
            hr = CreateBindCtx(0, &pbcCreate);
            if (SUCCEEDED(hr))
            {
                BIND_OPTS bo = {sizeof(bo)};  // Requires size filled in.
                bo.grfMode = STGM_CREATE;
                pbcCreate->SetBindOptions(&bo);

                hr = psfDesktop->ParseDisplayName(hwnd, pbcCreate, (LPWSTR)pu.pszSuffix, pchEaten, ppidl, pdwAttributes);
                pbcCreate->Release();
            }
            psfDesktop->Release();
        }
    }
    else
    {   // shell:personal\My Pictures
        LPWSTR pwszUnparsed = NULL;
        ULONG cchEaten;

        int csidl = _ParseSpecialFolder(pu.pszSuffix, &pwszUnparsed, &cchEaten);

        if (-1 != csidl)
        {
            LPITEMIDLIST pidlCSIDL;
            hr = SHGetFolderLocation(hwnd, csidl | CSIDL_FLAG_CREATE, NULL, 0, &pidlCSIDL);
            if (SUCCEEDED(hr))
            {
                if (pwszUnparsed && *pwszUnparsed)
                {
                    IShellFolder *psf;
                    hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlCSIDL, &psf));
                    if (SUCCEEDED(hr))
                    {
                        LPITEMIDLIST pidlChild;
                        hr = psf->ParseDisplayName(hwnd, pbc, pwszUnparsed, pchEaten, &pidlChild, pdwAttributes);
                        if (SUCCEEDED(hr))
                        {
                            hr = SHILCombine(pidlCSIDL, pidlChild, ppidl);
                            ILFree(pidlChild);
                            if (pchEaten) 
                            {
                                *pchEaten += cchEaten;
                            }                                
                        }
                        psf->Release();
                    }
                    ILFree(pidlCSIDL);
                }
                else
                {
                    if (pdwAttributes && *pdwAttributes)
                    {
                        hr = SHGetNameAndFlags(pidlCSIDL, 0, NULL, 0, pdwAttributes);
                    }
                    if (SUCCEEDED(hr))
                    {
                        if (pchEaten) *pchEaten = cchEaten;
                        *ppidl = pidlCSIDL;
                    }
                    else
                    {
                        ILFree(pidlCSIDL);
                    }                        
                }
            }
        }
    }
    return hr;
}

// key for the DAVRDR so that we can read the localised provider name.
#define DAVRDR_KEY TEXT("SYSTEM\\CurrentControlSet\\Services\\WebClient\\NetworkProvider")

STDMETHODIMP CHttpUrlStub::ParseDisplayName(HWND hwnd, 
                                       LPBC pbc, WCHAR *pwzDisplayName, ULONG *pchEaten,
                                       LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    HRESULT hr = E_INVALIDARG;
 
    PARSEDURLW pu = {0};
    pu.cbSize = sizeof(pu);
    ParseURLW(pwzDisplayName, &pu);
 
    //  we cant handle anything but simple URLs here, and only HTTP (not HTTPS).
    
    if (!UrlGetLocationW(pwzDisplayName) 
            && !StrChrW(pu.pszSuffix, L'?')
            && (lstrlen(pu.pszSuffix) < MAX_PATH)
            && (pu.nScheme == URL_SCHEME_HTTP))
    {
        // convert from wacky http: to something that the RDR will pick up as a UNC,
        // given that this is being forwarded directly to the DAV RDR.
        //
        //  http://server/share -> \\server\share

        WCHAR sz[MAX_PATH];
        StrCpyN(sz, pu.pszSuffix, ARRAYSIZE(sz));

        for (LPWSTR psz = sz; *psz; psz++)
        {
            if (*psz == L'/')
            {
                *psz = L'\\';
            }
        }

        //  this forces the use of the DavRedir as the provider
        //  thus avoiding any confusion...
        IPropertyBag *ppb;
        hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &ppb));
        if (SUCCEEDED(hr))
        {
            TCHAR szProvider[MAX_PATH];
            DWORD cbProvider = sizeof (szProvider);

            if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, DAVRDR_KEY, TEXT("Name"), NULL, szProvider, &cbProvider))
            {
                hr = SHPropertyBag_WriteStr(ppb, STR_PARSE_NETFOLDER_PROVIDERNAME, szProvider);
                if (SUCCEEDED(hr))
                {
                    hr = pbc->RegisterObjectParam(STR_PARSE_NETFOLDER_INFO, ppb);
                    if (SUCCEEDED(hr))
                    {
                        //  add a UI bindctx if necessary
                        IBindCtx *pbcRelease = NULL;
                        if (hwnd && !BindCtx_GetUIWindow(pbc))
                        {
                            //  returns a reference to our pbc in pbcRelease
                            BindCtx_RegisterUIWindow(pbc, hwnd, &pbcRelease);
                        }

                        hr = SHParseDisplayName(sz, pbc, ppidl, pdwAttributes ? *pdwAttributes : 0, pdwAttributes);

                        if (pbcRelease)
                            pbc->Release();
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }
            ppb->Release();
        }
    }

    if (FAILED(hr) && !BindCtx_ContainsObject(pbc, L"BUT NOT WEBFOLDERS"))
    {
        //  fall back to webfolders
        LPITEMIDLIST pidlParent = CreateWebFoldersIDList();
        if (pidlParent)
        {
            IShellFolder *psf;
            hr = SHBindToObjectEx(NULL, pidlParent, NULL, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                //  always pass NULL for the HWND.  webfolders shows really bad UI
                LPITEMIDLIST pidlRight;
                hr = psf->ParseDisplayName(NULL, pbc, pwzDisplayName, pchEaten, &pidlRight, pdwAttributes);
                if (SUCCEEDED(hr))
                {
                    hr = SHILCombine(pidlParent, pidlRight, ppidl);
                    ILFree(pidlRight);
                }
                psf->Release();
            }
            ILFree(pidlParent);
        }
    }
    
    return hr;
}
    
BOOL CDesktopFolder::_TryUrlJunctions(LPCTSTR pszName, IBindCtx *pbc, IShellFolder **ppsf, LPITEMIDLIST *ppidlLeft)
{
    PARSEDURL pu = {0};
    pu.cbSize = sizeof(pu);
    EVAL(SUCCEEDED(ParseURL(pszName, &pu)));

    ASSERT(!*ppsf);
    ASSERT(!*ppidlLeft);
    switch (pu.nScheme)
    {
    case URL_SCHEME_SHELL:
        *ppsf = SAFECAST(&_sfShellUrl, IShellFolder *);
        break;
        
    case URL_SCHEME_FILE:
        *ppsf = SAFECAST(&_sfFileUrl, IShellFolder *);
        break;

    case URL_SCHEME_MSSHELLROOTED:
        *ppsf = SAFECAST(&_sfRooted, IShellFolder *);
        break;

    case URL_SCHEME_MSSHELLIDLIST:
        *ppsf = SAFECAST(&_sfIDListUrl, IShellFolder *);
        break;

    case URL_SCHEME_HTTP:
    case URL_SCHEME_HTTPS:
        if (BindCtx_ContainsObject(pbc, STR_PARSE_PREFER_FOLDER_BROWSING))
            *ppsf = SAFECAST(&_sfHttpUrl, IShellFolder *);
        break;
    
    default:
        // _TryRegisteredUrlJunction(pu.pszProtocol, pu.cchProtocol, ppsf, ppidlLeft)
        break;
    }
    
    return (*ppsf || *ppidlLeft);
}

BOOL _FailForceReturn(HRESULT hr);

BOOL CDesktopFolder::_GetFolderForParsing(LPCTSTR pszName, LPBC pbc, IShellFolder **ppsf, LPITEMIDLIST *ppidlLeft)
{
    ASSERT(!*ppidlLeft);
    ASSERT(!*ppsf);
    
    if ((InRange(pszName[0], TEXT('A'), TEXT('Z')) || 
         InRange(pszName[0], TEXT('a'), TEXT('z'))) && 
        pszName[1] == TEXT(':'))
    {
        // The string contains a path, let "My Computer" figire it out.
        *ppidlLeft = CreateMyComputerIDList();
    }
    else if (PathIsUNC(pszName))
    {
        // The path is UNC, let "World" figure it out.
        *ppidlLeft = CreateMyNetPlacesIDList();
    }
    else if (UrlIs(pszName, URLIS_URL) && !SHSkipJunctionBinding(pbc, NULL))
    {
        _TryUrlJunctions(pszName, pbc, ppsf, ppidlLeft);
    }

    if (!*ppsf && *ppidlLeft)
        SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, *ppidlLeft, ppsf));
        
    return (*ppsf != NULL);
}    

STDMETHODIMP CDesktopFolder::ParseDisplayName(HWND hwnd, 
                                       LPBC pbc, WCHAR *pwzDisplayName, ULONG *pchEaten,
                                       LPITEMIDLIST *ppidl, ULONG *pdwAttributes)
{
    HRESULT hr = E_INVALIDARG;

    if (ppidl)
    {
        *ppidl = NULL;      // assume error

        if (pwzDisplayName && *pwzDisplayName)
        {
            LPITEMIDLIST pidlLeft = NULL;
            IShellFolder *psfRight = NULL;

            ASSERT(hr == E_INVALIDARG);

            if (_GetFolderForParsing(pwzDisplayName, pbc, &psfRight, &pidlLeft))
            {
                if (pchEaten)
                    *pchEaten = 0;
                hr = _ChildParseDisplayName(psfRight, pidlLeft, hwnd, pbc, pwzDisplayName, pchEaten, ppidl, pdwAttributes);
                ILFree(pidlLeft);
                psfRight->Release();
            }

            if (SUCCEEDED(hr))
            {
                //  translate aliases here for goodness sake
                if (BindCtx_ContainsObject(pbc, STR_PARSE_TRANSLATE_ALIASES))
                {
                    LPITEMIDLIST pidlAlias;
                    if (SUCCEEDED(SHILAliasTranslate(*ppidl, &pidlAlias, XLATEALIAS_ALL)))
                    {
                        ILFree(*ppidl);
                        *ppidl = pidlAlias;
                    }
                }
            }
            else if (FAILED(hr) && !_FailForceReturn(hr))
            {
                //
                //  MIL 131297 - desktop did not support relative simple parses - ZekeL - 3-FEB-2000
                //  it was only the roots (drives/net) that would create simple IDs
                //  so for some apps we need to still not do it.
                //
                if (BindCtx_ContainsObject(pbc, STR_DONT_PARSE_RELATIVE))
                {
                    // we're told not to parse relative paths and _GetFolderForParsing failed
                    // so act like we don't think the path exists.
                    hr = E_INVALIDARG;
                }
                else if (S_OK != SHIsFileSysBindCtx(pbc, NULL))
                {
                    //  when we request that something be created, we need to
                    //  check both folders and make sure that it doesnt exist in 
                    //  either one.  and then try and create it in the user folder
                    BIND_OPTS bo = {sizeof(bo)};
                    BOOL fCreate = FALSE;

                    if (pbc && SUCCEEDED(pbc->GetBindOptions(&bo)) && 
                        (bo.grfMode & STGM_CREATE))
                    {
                        fCreate = TRUE;
                        bo.grfMode &= ~STGM_CREATE;
                        pbc->SetBindOptions(&bo);
                    }

                    //  give the users desktop first shot.
                    // This must be a desktop item, _psfDesktop may not be inited in
                    // the case where we are called from ILCreateFromPath()
                    if (_psfDesktop)
                        hr = _psfDesktop->ParseDisplayName(hwnd, pbc, pwzDisplayName, pchEaten, ppidl, pdwAttributes);

                    //  if the normal desktop folder didnt pick it off, 
                    //  it could be in the allusers folder.  give psfAlt a chance.
                    if (FAILED(hr) && _psfAltDesktop)
                    {
                        hr = _psfAltDesktop->ParseDisplayName(hwnd, pbc, pwzDisplayName, pchEaten, ppidl, pdwAttributes);
                    }

                    //  neither of the folders can identify an existing item
                    //  so we should pass the create flag to the real desktop
                    if (FAILED(hr) && fCreate && _psfDesktop)
                    {
                        bo.grfMode |= STGM_CREATE;
                        pbc->SetBindOptions(&bo);
                        hr = _psfDesktop->ParseDisplayName(hwnd, pbc, pwzDisplayName, pchEaten, ppidl, pdwAttributes);
                        //  when this succeeds, we know we got a magical ghost pidl...
                    }
                }
            }

        } 
        else if (pwzDisplayName)
        {
            // we used to return this pidl when passed an empty string
            // some apps (such as Wright Design) depend on this behavior
            hr = SHILClone((LPCITEMIDLIST)&c_idlDrives, ppidl);
        }
    }

    return hr;
}

STDAPI_(void) UltRoot_Term()
{
    if (g_pDesktopFolder)
    {
        g_pDesktopFolder->_Destroy();
        g_pDesktopFolder = NULL;
    }
}

HRESULT CDesktopFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    *ppenum = new CDesktopFolderEnum(this, hwnd, grfFlags);
    return *ppenum ? S_OK : E_OUTOFMEMORY;
}


STDMETHODIMP CDesktopFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    // note: using IsSelf() here will cause a problem with WinZip. they expect
    // failure when they pass an empty pidl. SHBindToOjbect() has the special
    // case for the desktop, so it is not needed here.

    IShellFolder2 *psf = _GetItemFolder(pidl);
    if (psf)
        return psf->BindToObject(pidl, pbc, riid, ppv);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

STDMETHODIMP CDesktopFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (pidl1 == NULL || pidl2 == NULL)
        return E_INVALIDARG;

    if (pidl1->mkid.cb == 0 && pidl2->mkid.cb == 0)
        return ResultFromShort(0);      // 2 empty IDLists, they are the same

    if (ILIsRooted(pidl1) || ILIsRooted(pidl2))
    {
        return _sfRooted.CompareIDs(lParam, pidl1, pidl2);
    }
    // If both objects aren't from the same directory, they won't match.
    else if (_psfAltDesktop) 
    {
        if (CFSFolder_IsCommonItem(pidl1)) 
        {
            if (CFSFolder_IsCommonItem(pidl2)) 
                return _psfAltDesktop->CompareIDs(lParam, pidl1, pidl2);
            else 
                return ResultFromShort(-1);
        } 
        else 
        {
            if (CFSFolder_IsCommonItem(pidl2)) 
                return ResultFromShort(1);
            else if (_psfDesktop)
                return _psfDesktop->CompareIDs(lParam, pidl1, pidl2);
        }
    } 
    else if (_psfDesktop)
    {
        return _psfDesktop->CompareIDs(lParam, pidl1, pidl2);
    }

    // If we have no _psfDesktop, we get here...
    return ResultFromShort(-1);
}

HRESULT CDesktopFolder::_BGCommand(HWND hwnd, WPARAM wparam, BOOL bExecute)
{
    HRESULT hr = S_OK;

    switch (wparam) 
    {
    case DFM_CMD_PROPERTIES:
    case FSIDM_PROPERTIESBG:
        if (bExecute)
        {
            // run the default applet in desk.cpl
            if (SHRunControlPanel( TEXT("desk.cpl"), hwnd ))
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
        break;

    case DFM_CMD_MOVE:
    case DFM_CMD_COPY:
        hr = E_FAIL;
        break;

    default:
        // This is common menu items, use the default code.
        hr = S_FALSE;
        break;
    }

    return hr;
}


// IContextMenuCB::CallBack for the background context menu
//
// Returns:
//      S_OK, if successfully processed.
//      S_FALSE, if default code should be used.

STDMETHODIMP CDesktopFolder::CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU_BOTTOM:
        if (!(wParam & (CMF_VERBSONLY | CMF_DVFILE)))
        {
            // Only add the desktop background Properties iff we're the real desktop browser
            // (i.e., we don't want it when in explorer)
            //
            if (IsDesktopBrowser(_punkSite))
            {
                LPQCMINFO pqcm = (LPQCMINFO)lParam;
                UINT idCmdFirst = pqcm->idCmdFirst;

                CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_PROPERTIES_BG, 0, pqcm);
            }
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_INVOKECOMMAND:
    case DFM_VALIDATECMD:
        hr = _BGCommand(hwnd, wParam, uMsg == DFM_INVOKECOMMAND);
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

// IItemNameLimits

STDMETHODIMP CDesktopFolder::GetValidCharacters(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars)
{
    IItemNameLimits *pinl;
    HRESULT hr = _QueryInterfaceItem(NULL, IID_PPV_ARG(IItemNameLimits, &pinl));
    if (SUCCEEDED(hr))
    {
        hr = pinl->GetValidCharacters(ppwszValidChars, ppwszInvalidChars);
        pinl->Release();
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::GetMaxLength(LPCWSTR pszName, int *piMaxNameLen)
{
    // delegate to per user or common based on which name space
    // pszName is from (we have to search for that)
    IItemNameLimits *pinl;
    HRESULT hr = _QueryInterfaceItem(NULL, IID_PPV_ARG(IItemNameLimits, &pinl));
    if (SUCCEEDED(hr))
    {
        hr = pinl->GetMaxLength(pszName, piMaxNameLen);
        pinl->Release();
    }
    return hr;
}

// IOleCommandTarget stuff 
STDMETHODIMP CDesktopFolder::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return IUnknown_QueryStatus(_psfDesktop, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

STDMETHODIMP CDesktopFolder::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    //  invalidate our cache
    //  which we dont really have right now.
    //  but CFSFolder does
    IUnknown_Exec(_psfAltDesktop, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    return IUnknown_Exec(_psfDesktop, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

STDMETHODIMP CDesktopFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellView))
    {
        IShellFolderViewCB* psfvcb;
        if (SUCCEEDED(Create_CDesktopViewCallback(this, &psfvcb)))
        {
            SFV_CREATE sfvc = {0};
            sfvc.cbSize = sizeof(sfvc);
            sfvc.psfvcb = psfvcb;

            hr = QueryInterface(IID_PPV_ARG(IShellFolder, &sfvc.pshf));   // in case we are agregated
            if (SUCCEEDED(hr))
            {
                hr = SHCreateShellFolderView(&sfvc, (IShellView**)ppv);
                sfvc.pshf->Release();
            }

            psfvcb->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IDropTarget) && _psfDesktop)
    {
        IDropTarget* pdt;
        if (SUCCEEDED(_psfDesktop->CreateViewObject(hwnd, riid, (void**)&pdt)))
        {
            CDesktopFolderDropTarget* pdfdt = new CDesktopFolderDropTarget(pdt);
            if (pdfdt)
            {
                hr = pdfdt->QueryInterface(IID_PPV_ARG(IDropTarget, (IDropTarget**)ppv));
                pdfdt->Release();
            }
            pdt->Release();
        }
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        IShellFolder *psfTemp;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfTemp));
        if (SUCCEEDED(hr))
        {
            HKEY hkNoFiles = NULL;
            RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("Directory\\Background"), 0, KEY_READ, &hkNoFiles);

            hr = CDefFolderMenu_Create2Ex(&c_idlDesktop, hwnd, 0, NULL,
                    psfTemp, this, 1, &hkNoFiles, (IContextMenu **)ppv);

            psfTemp->Release();
            RegCloseKey(hkNoFiles);
        }
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *rgfOut)
{
    if (IsSelf(cidl, apidl))
    {
        *rgfOut &= SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_HASSUBFOLDER | SFGAO_HASPROPSHEET | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_STORAGE;
        return S_OK;
    }

    IShellFolder2 *psf = _GetItemFolder(apidl[0]);
    if (psf)
        return psf->GetAttributesOf(cidl, apidl, rgfOut);
    return E_UNEXPECTED;
}

HRESULT CDesktopFolder::_SelfAssocCreate(REFIID riid, void **ppv)
{
    *ppv = NULL;

    IQueryAssociations *pqa;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        hr = pqa->Init(ASSOCF_INIT_DEFAULTTOFOLDER, L"{00021400-0000-0000-C000-000000000046}", // CLSID_ShellDesktop
                       NULL, NULL);
        if (SUCCEEDED(hr))
        {
            hr = pqa->QueryInterface(riid, ppv);
        }
        pqa->Release();
    }

    return hr;
}

STDAPI _DeskContextMenuCB(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // The "safe" thing to return is usually E_NOTIMPL, but some messages
    // have special return values.

    HRESULT hr;

    switch (uMsg) 
    {
    case DFM_VALIDATECMD:
        hr = S_FALSE;
        break;

    case DFM_INVOKECOMMAND:
        if (wParam == DFM_CMD_PROPERTIES)
        {
            // Properties should act like Properties on the background
            SHRunControlPanel(TEXT("desk.cpl"), hwnd);
            hr = S_OK;
        }
        else
            hr = S_FALSE;
        break;

    case DFM_MERGECONTEXTMENU:
        hr = S_OK;
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}

HRESULT CDesktopFolder::_SelfCreateContextMenu(HWND hwnd, void **ppv)
{
    *ppv = NULL;

    IQueryAssociations *pqa;
    HRESULT hr = _SelfAssocCreate(IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        HKEY ahkeys[2] = { NULL, NULL };
        DWORD cKeys = SHGetAssocKeys(pqa, ahkeys, ARRAYSIZE(ahkeys));
        pqa->Release();

        // We must pass cidl=1 apidl=&pidlDesktop to ensure that an
        // IDataObject is created,
        // or Symantec Internet FastFind ALERTEX.DLL will fault.

        LPCITEMIDLIST pidlDesktop = DESKTOP_PIDL;
        hr = CDefFolderMenu_Create2(&c_idlDesktop, hwnd, 1, &pidlDesktop, this, _DeskContextMenuCB,
                ARRAYSIZE(ahkeys), ahkeys, (IContextMenu **)ppv);

        SHRegCloseKeys(ahkeys, ARRAYSIZE(ahkeys));
    }

    return hr;
}

HRESULT CDesktopFolder::_GetItemUIObject(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                         REFIID riid, UINT *prgfInOut, void **ppv)
{
    IShellFolder2 *psf = _GetItemFolder(apidl[0]);
    if (psf)
        return psf->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl,
                                           REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    
    *ppv = NULL;

    if (IsSelf(cidl, apidl))
    {
        // for the desktop itself
        if (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW)) 
        {
            hr = SHCreateDefExtIcon(NULL, II_DESKTOP, II_DESKTOP, GIL_PERCLASS, II_DESKTOP, riid, ppv);
        }
        else if (IsEqualIID(riid, IID_IQueryInfo))
        {
            hr = CreateInfoTipFromText(MAKEINTRESOURCE(IDS_FOLDER_DESKTOP_TT), riid, ppv);
        }
        else if (IsEqualIID(riid, IID_IContextMenu))
        {
            hr = _SelfCreateContextMenu(hwnd, ppv);
        }
        else if (IsEqualIID(riid, IID_IDropTarget))
        {
            hr = _psfDesktop->CreateViewObject(hwnd, riid, ppv);
        }
        else if (IsEqualIID(riid, IID_IDataObject))
        {
            // Must create with 1 pidl inside that maps to the desktop.
            // Otherwise, CShellExecMenu::InvokeCommand will punt.
            LPCITEMIDLIST pidlDesktop = DESKTOP_PIDL;
            hr = SHCreateFileDataObject(&c_idlDesktop, 1, &pidlDesktop, NULL, (IDataObject **)ppv);
        }
        // Nobody seems to mind if we don't provide this
        // so don't give one out because AssocCreate is slow.
        // else if (IsEqualIID(riid, IID_IQueryAssociations))
        // {
        //     hr = _SelfAssocCreate(riid, ppv);
        // }
    }
    else
    {
        hr = _GetItemUIObject(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET *pStrRet)
{
    HRESULT hr;

    if (IsSelf(1, &pidl))
    {
        if ((dwFlags & (SHGDN_FORPARSING | SHGDN_INFOLDER | SHGDN_FORADDRESSBAR)) == SHGDN_FORPARSING)
        {
            // note some ISV apps puke if we return a full name here but the
            // rest of the shell depends on this...
            TCHAR szPath[MAX_PATH];
            SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, szPath);
            hr = StringToStrRet(szPath, pStrRet);
        }
        else
            hr = ResToStrRet(IDS_DESKTOP, pStrRet);   // display name, "Desktop"
    }
    else
    {
        IShellFolder2 *psf = _GetItemFolder(pidl);
        if (psf)
            hr = psf->GetDisplayNameOf(pidl, dwFlags, pStrRet);
        else
            hr = E_UNEXPECTED;
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, 
                                       LPCOLESTR pszName, DWORD dwRes, LPITEMIDLIST *ppidlOut)
{
    IShellFolder2 *psf = _GetItemFolder(pidl);
    if (psf)
        return psf->SetNameOf(hwnd, pidl, pszName, dwRes, ppidlOut);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::GetDefaultSearchGUID(GUID *pGuid)
{
    return E_NOTIMPL;
}   

STDMETHODIMP CDesktopFolder::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CDesktopFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    if (_psfDesktop)
        return _psfDesktop->GetDefaultColumn(dwRes, pSort, pDisplay);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::GetDefaultColumnState(UINT iColumn, DWORD *pdwState)
{
    if (_psfDesktop)
        return _psfDesktop->GetDefaultColumnState(iColumn, pdwState);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = E_UNEXPECTED;
    if (IsSelf(1, &pidl))
    {
        if (IsEqualSCID(*pscid, SCID_NAME))
        {
            STRRET strRet;
            hr = GetDisplayNameOf(pidl, SHGDN_NORMAL, &strRet);
            if (SUCCEEDED(hr))
            {
                hr = InitVariantFromStrRet(&strRet, pidl, pv);
            }
        }
    }
    else
    {
        IShellFolder2 *psf = _GetItemFolder(pidl);
        if (psf)
        {
            hr = psf->GetDetailsEx(pidl, pscid, pv);
        }
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
{
    IShellFolder2 *psf = _GetItemFolder(pidl);
    if (psf)
        return psf->GetDetailsOf(pidl, iColumn, pDetails);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    if (_psfDesktop)
        return _psfDesktop->MapColumnToSCID(iColumn, pscid);
    return E_UNEXPECTED;
}

STDMETHODIMP CDesktopFolder::GetClassID(CLSID *pCLSID)
{
    *pCLSID = CLSID_ShellDesktop;
    return S_OK;
}

STDMETHODIMP CDesktopFolder::Initialize(LPCITEMIDLIST pidl)
{
    return ILIsEmpty(pidl) ? S_OK : E_INVALIDARG;
}

STDMETHODIMP CDesktopFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    return GetCurFolderImpl(&c_idlDesktop, ppidl);
}

STDMETHODIMP CDesktopFolder::TranslateIDs(LONG *plEvent, 
                                LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, 
                                LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
                                LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
                                LPITEMIDLIST *ppidlOut2Event2)
{
    *ppidlOut1 = NULL;
    *ppidlOut2 = NULL;
    *plEvent2 = -1;
    *ppidlOut1Event2 = NULL;
    *ppidlOut2Event2 = NULL;

    if (pidl1)
        SHILAliasTranslate(pidl1, ppidlOut1, XLATEALIAS_DESKTOP);
    if (pidl2)
        SHILAliasTranslate(pidl2, ppidlOut2, XLATEALIAS_DESKTOP);

    if (*ppidlOut1 || *ppidlOut2)
    {
        if (!*ppidlOut1)
            *ppidlOut1 = ILClone(pidl1);

        if (!*ppidlOut2)
            *ppidlOut2 = ILClone(pidl2);

        if (*ppidlOut1 || *ppidlOut2)
        {
            return S_OK;
        }
        ILFree(*ppidlOut1);
        ILFree(*ppidlOut2);
        *ppidlOut1 = NULL;
        *ppidlOut2 = NULL;
    }
    
    return E_FAIL;
}

STDMETHODIMP CDesktopFolder::GetIconOf(LPCITEMIDLIST pidl, UINT flags, int *piIndex)
{
    IShellIcon *psi;
    HRESULT hr = _QueryInterfaceItem(pidl, IID_PPV_ARG(IShellIcon, &psi));
    if (SUCCEEDED(hr))
    {
        hr = psi->GetIconOf(pidl, flags, piIndex);
        psi->Release();
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    IShellIconOverlay *psio;
    HRESULT hr = _QueryInterfaceItem(pidl, IID_PPV_ARG(IShellIconOverlay, &psio));
    if (SUCCEEDED(hr))
    {
        hr = psio->GetOverlayIndex(pidl, pIndex);
        psio->Release();
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex)
{
    IShellIconOverlay *psio;
    HRESULT hr = _QueryInterfaceItem(pidl, IID_PPV_ARG(IShellIconOverlay, &psio));
    if (SUCCEEDED(hr))
    {
        hr = psio->GetOverlayIconIndex(pidl, pIconIndex);
        psio->Release();
    }
    return hr;
}

// IStorage

STDMETHODIMP CDesktopFolder::_DeleteItemByIDList(LPCITEMIDLIST pidl)
{
    IStorage *pstg;
    HRESULT hr = _QueryInterfaceItem(pidl, IID_PPV_ARG(IStorage, &pstg));
    if (SUCCEEDED(hr))
    {
        TCHAR szName[MAX_PATH];
        hr = DisplayNameOf(this, pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
        {
            hr = pstg->DestroyElement(szName);
        }
        pstg->Release();
    }
    return hr;
}

STDMETHODIMP CDesktopFolder::_StgCreate(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv)
{
    IStorage *pstg;
    HRESULT hr = _QueryInterfaceItem(pidl, IID_PPV_ARG(IStorage, &pstg));
    if (SUCCEEDED(hr))
    {
        TCHAR szName[MAX_PATH];
        hr = DisplayNameOf(this, pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
        {
            if (IsEqualIID(riid, IID_IStorage))
            {
                hr = pstg->CreateStorage(szName, grfMode, 0, 0, (IStorage **) ppv);
            }
            else if (IsEqualIID(riid, IID_IStream))
            {
                hr = pstg->CreateStream(szName, grfMode, 0, 0, (IStream **) ppv);
            }
            else
            {
                hr = E_INVALIDARG;
            }
        }
        pstg->Release();
    }
    return hr;
}

#define DESKTOP_EVENTS \
    SHCNE_DISKEVENTS | \
    SHCNE_ASSOCCHANGED | \
    SHCNE_NETSHARE | \
    SHCNE_NETUNSHARE

HRESULT CDesktopViewCallBack::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = CBaseShellFolderViewCB::QueryInterface(riid, ppv);
    if (FAILED(hr))
    {
        static const QITAB qit[] = {
            QITABENT(CDesktopViewCallBack, IFolderFilter),
            { 0 },
        };
        hr = QISearch(this, qit, riid, ppv);
    }
    return hr;
}

//
// Copied to shell\applets\cleanup\fldrclnr\cleanupwiz.cpp :CCleanupWiz::_ShouldShow
// If you modify this, modify that as well
//
STDMETHODIMP CDesktopViewCallBack::ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem)
{
    HRESULT hr = S_OK;  //Assume that this item should be shown!
    
    if (!_fCheckedIfRealDesktop)  //Have we done this check before?
    {
        _fRealDesktop = IsDesktopBrowser(_punkSite);
        _fCheckedIfRealDesktop = TRUE;  //Remember this fact!
    }

    if (!_fRealDesktop)
        return S_OK;    //Not a real desktop! So, let's show everything!
    
    IShellFolder2 *psf2;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
    {
        // Get the GUID in the pidl, which requires IShellFolder2.
        CLSID guidItem;
        if (SUCCEEDED(GetItemCLSID(psf2, pidlItem, &guidItem)))
        {
            SHELLSTATE  ss = {0};
            SHGetSetSettings(&ss, SSF_STARTPANELON, FALSE);  //See if the StartPanel is on!
            
            //Get the proper registry path based on if StartPanel is ON/OFF
            TCHAR szRegPath[MAX_PATH];
            wnsprintf(szRegPath, ARRAYSIZE(szRegPath), REGSTR_PATH_HIDDEN_DESKTOP_ICONS, (ss.fStartPanelOn ? REGSTR_VALUE_STARTPANEL : REGSTR_VALUE_CLASSICMENU));

            //Convert the guid to a string
            TCHAR szGuidValue[MAX_GUID_STRING_LEN];            
            SHStringFromGUID(guidItem, szGuidValue, ARRAYSIZE(szGuidValue));

            //See if this item is turned off in the registry.
            if (SHRegGetBoolUSValue(szRegPath, szGuidValue, FALSE, /* default */FALSE))
                hr = S_FALSE; //They want to hide it; So, return S_FALSE.
        }
        psf2->Release();
    }
    
    return hr;
}

STDMETHODIMP CDesktopViewCallBack::GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags)
{
    return E_NOTIMPL;
}


CDesktopViewCallBack::CDesktopViewCallBack(CDesktopFolder* pdf) : 
    CBaseShellFolderViewCB((LPCITEMIDLIST)&c_idlDesktop, DESKTOP_EVENTS),
    _pdf(pdf)
{
    ASSERT(_fCheckedIfRealDesktop == FALSE);
    ASSERT(_fRealDesktop == FALSE);
}

HRESULT Create_CDesktopViewCallback(CDesktopFolder* pdf, IShellFolderViewCB** ppv)
{
    HRESULT hr;

    CDesktopViewCallBack* p = new CDesktopViewCallBack(pdf);
    if (p)
    {
        *ppv = SAFECAST(p, IShellFolderViewCB*);
        hr = S_OK;
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CDesktopViewCallBack::OnGETCCHMAX(DWORD pv, LPCITEMIDLIST pidlItem, UINT *pcch)
{
    HRESULT hr = S_OK;
    if (SIL_GetType(pidlItem) == SHID_ROOT_REGITEM) 
    {
        // evil, we should not have to know this
        // make regfldr implement IItemNameLimits and this code won't be needed
        *pcch = MAX_REGITEMCCH;
    }
    else
    {
        TCHAR szName[MAX_PATH];
        if (SUCCEEDED(DisplayNameOf(_pdf, pidlItem, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName))))
        {
            hr = _pdf->GetMaxLength(szName, (int *)pcch);
        }
    }
    return hr;
}

HRESULT CDesktopViewCallBack::OnGetWorkingDir(DWORD pv, UINT wP, LPTSTR pszDir)
{
    return SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, 0, pszDir);
}

HRESULT CDesktopViewCallBack::OnGetWebViewTemplate(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_TEMPLATE_DATA* pvi)
{
    HRESULT hr = E_FAIL;
    if (IsDesktopBrowser(_punkSite))
    {
        // It's the actual desktop, use desstop.htt (from the desktop CLSID)
        //
        hr = DefaultGetWebViewTemplateFromClsid(CLSID_ShellDesktop, pvi);
    }
    return hr;
}

HRESULT CDesktopViewCallBack::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_NORMAL | SFVMWVL_FILES;
    return S_OK;
}

STDMETHODIMP CDesktopViewCallBack::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_GETCCHMAX, OnGETCCHMAX);
    HANDLE_MSG(0, SFVM_GETWEBVIEW_TEMPLATE, OnGetWebViewTemplate);
    HANDLE_MSG(0, SFVM_GETWORKINGDIR, OnGetWorkingDir);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);

    default:
        return E_FAIL;
    }

    return S_OK;
}

CDesktopFolderDropTarget::CDesktopFolderDropTarget(IDropTarget* pdt) : _cRef(1)
{
    pdt->QueryInterface(IID_PPV_ARG(IDropTarget, &_pdt));
}

CDesktopFolderDropTarget::~CDesktopFolderDropTarget()
{
    _pdt->Release();
}

STDMETHODIMP CDesktopFolderDropTarget::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDesktopFolderDropTarget, IDropTarget),
        QITABENT(CDesktopFolderDropTarget, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CDesktopFolderDropTarget::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDesktopFolderDropTarget::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IDropTarget
HRESULT CDesktopFolderDropTarget::DragEnter(IDataObject* pDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    return _pdt->DragEnter(pDataObject, grfKeyState, pt, pdwEffect);
}

HRESULT CDesktopFolderDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    return _pdt->DragOver(grfKeyState, pt, pdwEffect);
}

HRESULT CDesktopFolderDropTarget::DragLeave(void)
{
    return _pdt->DragLeave();
}
        
HRESULT CDesktopFolderDropTarget::SetSite(IN IUnknown * punkSite)
{
    IUnknown_SetSite(_pdt, punkSite);
    return S_OK;
}


BOOL CDesktopFolderDropTarget::_IsSpecialCaseDrop(IDataObject* pDataObject, DWORD dwEffect, BOOL* pfIsPIDA, UINT* pcItems)
{
    BOOL fIEDropped = FALSE;
    *pfIsPIDA = FALSE;

    // when we drag a fake IE item (filename.CLSID_Internet) back to the desktop, we delete it and unhide the real IE icon
    STGMEDIUM medium = {0};
    LPIDA pida = DataObj_GetHIDA(pDataObject, &medium);
    if (pida)
    {
        for (UINT i = 0; (i < pida->cidl); i++)
        {
            LPITEMIDLIST pidlFull = HIDA_ILClone(pida, i);
            if (pidlFull)
            {
                LPCITEMIDLIST pidlRelative;
                IShellFolder2* psf2;
                if (SUCCEEDED(SHBindToParent(pidlFull, IID_PPV_ARG(IShellFolder2, &psf2), &pidlRelative)))
                {
                    CLSID guidItem;
                    if (SUCCEEDED(GetItemCLSID(psf2, pidlRelative, &guidItem)) &&
                        IsEqualCLSID(CLSID_Internet, guidItem))
                    {
                        fIEDropped = TRUE;
                        TCHAR szFakeIEItem[MAX_PATH];
                        if (SHGetPathFromIDList(pidlFull, szFakeIEItem))
                        {
                            TCHAR szFakeIEItemDesktop[MAX_PATH];
                            if (SHGetSpecialFolderPath(NULL, szFakeIEItemDesktop, CSIDL_DESKTOP, 0))
                            {
                                // delete the original if this is a move or if we're on the same volume and we're neither explicitly copying nor linking
                                if (((dwEffect & DROPEFFECT_MOVE) == DROPEFFECT_MOVE) ||
                                    (((dwEffect & DROPEFFECT_COPY) != DROPEFFECT_COPY) &&
                                     ((dwEffect & DROPEFFECT_LINK) != DROPEFFECT_LINK) &&
                                      (PathIsSameRoot(szFakeIEItemDesktop, szFakeIEItem))))
                                {
                                    DeleteFile(szFakeIEItem);
                                }
                            }
                        }
                        pida->cidl--;
                        pida->aoffset[i] = pida->aoffset[pida->cidl];
                        i--; // stall the for loop
                    }
                    psf2->Release();
                }
                ILFree(pidlFull);
            }                    
        }
        *pfIsPIDA = TRUE;
        *pcItems = pida->cidl;

        HIDA_ReleaseStgMedium(pida, &medium);
    }

    return fIEDropped;
}

HRESULT CDesktopFolderDropTarget::_ShowIEIcon()
{
    // reset desktop cleanup wizard's legacy location of "don't show IE" information
    HKEY hkey;            
    if(SUCCEEDED(SHRegGetCLSIDKey(CLSID_Internet, TEXT("ShellFolder"), FALSE, TRUE, &hkey)))
    {
        DWORD dwAttr, dwType = 0;
        DWORD cbSize = sizeof(dwAttr);
    
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("Attributes"), NULL, &dwType, (BYTE *) &dwAttr, &cbSize) && (dwType == REG_DWORD))
        {
            dwAttr &= ~SFGAO_NONENUMERATED;
            RegSetValueEx(hkey, TEXT("Attributes"), NULL, dwType, (BYTE *) &dwAttr, cbSize);
        }
        RegCloseKey(hkey);
    }

    // reset start menu's location of "don't show IE" information
    DWORD dwData = 0;
    TCHAR szCLSID[MAX_GUID_STRING_LEN];
    TCHAR szBuffer[MAX_PATH];
    if (SUCCEEDED(SHStringFromGUID(CLSID_Internet, szCLSID, ARRAYSIZE(szCLSID))))
    {
        for (int i = 0; i < 2; i ++)
        {
            wnsprintf(szBuffer, ARRAYSIZE(szBuffer), REGSTR_PATH_HIDDEN_DESKTOP_ICONS, (i == 0) ? REGSTR_VALUE_STARTPANEL : REGSTR_VALUE_CLASSICMENU);
            SHRegSetUSValue(szBuffer, szCLSID, REG_DWORD, &dwData, sizeof(DWORD), SHREGSET_FORCE_HKCU);
        }
    }

    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, DESKTOP_PIDL, NULL);

    return S_OK;
}

HRESULT CDesktopFolderDropTarget::Drop(IDataObject* pDataObject, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    BOOL fIsPIDA;
    UINT cidl;
    if (_IsSpecialCaseDrop(pDataObject, *pdwEffect, &fIsPIDA, &cidl))
    {
        _ShowIEIcon();
    }

    HRESULT hr;
    if (fIsPIDA && 0 == cidl)
    {
        hr = _pdt->DragLeave();
    }
    else
    {
        hr = _pdt->Drop(pDataObject, grfKeyState, pt, pdwEffect);        
    }

    return hr;        
}



CDesktopFolderEnum::CDesktopFolderEnum(CDesktopFolder *pdf, HWND hwnd, DWORD grfFlags) : 
    _cRef(1), _bUseAltEnum(FALSE)
{
    if (pdf->_psfDesktop)
        pdf->_psfDesktop->EnumObjects(hwnd, grfFlags, &_penumFolder);

    if (pdf->_psfAltDesktop) 
        pdf->_psfAltDesktop->EnumObjects(NULL, grfFlags, &_penumAltFolder);
}

CDesktopFolderEnum::~CDesktopFolderEnum()
{
    if (_penumFolder)
        _penumFolder->Release();

    if (_penumAltFolder)
        _penumAltFolder->Release();
}

STDMETHODIMP CDesktopFolderEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDesktopFolderEnum, IEnumIDList),                        // IID_IEnumIDList
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CDesktopFolderEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDesktopFolderEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CDesktopFolderEnum::Next(ULONG celt, LPITEMIDLIST *ppidl, ULONG *pceltFetched)
{
    HRESULT hr;

    if (_bUseAltEnum)
    {
       if (_penumAltFolder) 
       {
           hr = _penumAltFolder->Next(celt, ppidl, pceltFetched);
       }
       else
           hr = S_FALSE;
    } 
    else if (_penumFolder)
    {
       hr = _penumFolder->Next(celt, ppidl, pceltFetched);
       if (S_OK != hr) 
       {
           _bUseAltEnum = TRUE;
           hr = Next(celt, ppidl, pceltFetched);  // recurse
       }
    }
    else
    {
        hr = S_FALSE;
    }

    if (hr == S_FALSE)
    {
        *ppidl = NULL;
        if (pceltFetched)
            *pceltFetched = 0;
    }

    return hr;
}


STDMETHODIMP CDesktopFolderEnum::Skip(ULONG celt) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CDesktopFolderEnum::Reset() 
{
    if (_penumFolder)
        _penumFolder->Reset();

    if (_penumAltFolder)
        _penumAltFolder->Reset();

    _bUseAltEnum = FALSE;
    return S_OK;
}

STDMETHODIMP CDesktopFolderEnum::Clone(IEnumIDList **ppenum) 
{
    *ppenum = NULL;
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\deskfldr.h ===
//
// the lowest sort order number goes at the top left of the desktop
//
#include "views.h"

// array indexes into g_asDesktopReqItems

#define CDESKTOP_REGITEM_DRIVES         0
#define CDESKTOP_REGITEM_NETWORK        1
#define CDESKTOP_REGITEM_INTERNET       2

EXTERN_C REQREGITEM g_asDesktopReqItems[];

//
// CAUTION: _CompareIDsOriginal() function in RegFldr.cpp has code that assumes that all 
// the "old" sort order values were <= 0x40. So, when it comes across a bOrder <= 0x40,
// it calls _GetOrder() function to get the "new" bOrder value. The following values have
// been bumped up to be above 0x40 sothat for all "new" values, we don't have to make that call. 
//
#define SORT_ORDER_MYDOCS       0x48    // coded in shell\ext\mydocs2\selfreg.inf
#define SORT_ORDER_DRIVES       0x50
#define SORT_ORDER_NETWORK      0x58
#define SORT_ORDER_RECYCLEBIN   0x60    // coded in shell32\selfreg.inx
#define SORT_ORDER_INETROOT     0x68



enum enumTSPerfFlag
{
    TSPerFlag_NoADWallpaper = 0,
    TSPerFlag_NoWallpaper,
    TSPerFlag_NoVisualStyles,
    TSPerFlag_NoWindowDrag,
    TSPerFlag_NoAnimation,
};


BOOL IsTSPerfFlagEnabled(enumTSPerfFlag eTSFlag);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\dlglogic.cpp ===
#include "shellprv.h"
#include "ids.h"

#include "dlglogic.h"

extern DWORD _DbgLocalAllocCount = 0;

CDataImpl::CDataImpl()
{}

CDataImpl::~CDataImpl()
{}

void CDataImpl::_SetDirty(BOOL fDirty)
{
    _fDirty = fDirty;
}

BOOL CDataImpl::IsDirty()
{
    return _fDirty;
}

BOOL CDataImpl::IsDeleted()
{
    return _fDeleted;
}

BOOL CDataImpl::IsNew()
{
    return _fNew;
}

HRESULT CDataImpl::CommitChangesToStorage()
{
    return S_FALSE;
}

HRESULT CDataImpl::AddToStorage()
{
    return S_FALSE;
}

HRESULT CDataImpl::DeleteFromStorage()
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\dlglogic.h ===
#ifndef DLGLOGIC_H
#define DLGLOGIC_H

#include "hwcmmn.h"

#include <dpa.h>

// DL: Data Logic

class CDataImpl : public CRefCounted
{
public:
    CDataImpl();
    virtual ~CDataImpl();

    void _SetDirty(BOOL fDirty);
    BOOL IsDirty();

    BOOL IsDeleted();
    BOOL IsNew();

    // This will be called by clients just before "IsDirty" is called.  The
    // implementation should call _SetDirty with the appropriate dirty status.
    virtual void UpdateDirty() PURE;

    // This should also reset the state of the object to a non-dirty state
    virtual HRESULT CommitChangesToStorage();

    virtual HRESULT AddToStorage();
    virtual HRESULT DeleteFromStorage();

private:
    BOOL                _fDirty;
    BOOL                _fDeleted;
    BOOL                _fNew;
};

// TData is usually derived from CDataImpl
template<typename TData>
class CDLUIData
{
public:
    HRESULT InitData(TData* pdata);
    TData* GetData();

    CDLUIData();
    virtual ~CDLUIData();

private:
    TData*              _pdata;
};

template<typename TData>
class CDLManager
{
public:
    ~CDLManager();
    
    HRESULT AddDataObject(TData* pdata);

    virtual HRESULT Commit();

    BOOL IsDirty();

protected:
    CDPA<TData>*        _pdpaData;
};

// Implementations

template<typename TData>
HRESULT CDLUIData<TData>::InitData(TData* pdata)
{
    ASSERT(pdata);

    pdata->AddRef();

    _pdata = pdata;

    return S_OK;
}

template<typename TData>
TData* CDLUIData<TData>::GetData()
{
    ASSERT(_pdata);

    _pdata->AddRef();

    return _pdata;
}

template<typename TData>
CDLManager<TData>::~CDLManager()
{
    if (_pdpaData)
    {
        _pdpaData->Destroy();

        delete _pdpaData;
    }
}

template<typename TData>
HRESULT CDLManager<TData>::AddDataObject(TData* pdata)
{
    HRESULT hr = S_OK;

    if (!_pdpaData)
    {
        _pdpaData = new CDPA<TData>(DPA_Create(4));

        if (!_pdpaData)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        if (-1 == _pdpaData->AppendPtr(pdata))
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

template<typename TData>
CDLUIData<TData>::CDLUIData()
{}

template<typename TData>
CDLUIData<TData>::~CDLUIData()
{
    if (_pdata)
    {
        _pdata->Release();
    }
}

template<typename TData>
HRESULT CDLManager<TData>::Commit()
{
    HRESULT hr = S_FALSE;

    if (_pdpaData)
    {
        int c = _pdpaData->GetPtrCount();

        for (int i = 0; SUCCEEDED(hr) && (i < c); ++i)
        {
            TData* pdata = _pdpaData->GetPtr(i);

            if (pdata)
            {
                pdata->UpdateDirty();

                if (pdata->IsDeleted())
                {
                    hr = pdata->DeleteFromStorage();
                }
                else
                {
                    if (pdata->IsNew())
                    {
                        hr = pdata->AddToStorage();
                    }
                    else
                    {
                        if (pdata->IsDirty())
                        {
                            hr = pdata->CommitChangesToStorage();
                        }
                    }
                }
            }
        }
    }

    return hr;
}


template<typename TData>
BOOL CDLManager<TData>::IsDirty()
{
    BOOL fDirty = FALSE;

    if (_pdpaData)
    {
        int c = _pdpaData->GetPtrCount();

        for (int i = 0; !fDirty && (i < c); ++i)
        {
            TData* pdata = _pdpaData->GetPtr(i);

            if (pdata)
            {
                pdata->UpdateDirty();

                if (pdata->IsDirty())
                {
                    fDirty = TRUE;
                }
            }
        }
    }

    return fDirty;
}

#endif //DLGLOGIC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\drawpie.h ===
int IntSqrt(unsigned long dwNum);

#define DP_USEDCOLOR  0
#define DP_FREECOLOR  1
#define DP_USEDSHADOW 2
#define DP_FREESHADOW 3

STDAPI_(VOID) DrawPie(HDC hDC, LPCRECT prcItem, UINT uPctX10, BOOL TrueZr100,
                  UINT uOffset, const COLORREF *lpColors);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\dragdrop.cpp ===
#include "shellprv.h"
#include "defview.h"
#include "lvutil.h"
#include "ids.h"
#include "idlcomm.h"
#pragma hdrstop

#include "datautil.h"
#include "apithk.h"

BOOL DAD_IsDraggingImage(void);
void DAD_SetDragCursor(int idCursor);
BOOL DAD_IsDragging();

#define MONITORS_MAX    16  // Is this really the max?

#define DCID_NULL       0
#define DCID_NO         1
#define DCID_MOVE       2
#define DCID_COPY       3
#define DCID_LINK       4
#define DCID_MAX        5

#define TF_DRAGIMAGES       0x02000000
#define DRAGDROP_ALPHA      120
#define MAX_WIDTH_ALPHA     200
#define MAX_HEIGHT_ALPHA    200

#define CIRCULAR_ALPHA   // Circular Alpha Blending Centered on Center of image

class CDragImages : public IDragSourceHelper, IDropTargetHelper
{
public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef() { return 2; };      // One global Com object per process
    STDMETHODIMP_(ULONG) Release() { return 1; };     // One global Com object per process

    // IDragSourceHelper methods
    STDMETHODIMP InitializeFromBitmap(LPSHDRAGIMAGE pshdi, IDataObject* pdtobj);
    STDMETHODIMP InitializeFromWindow(HWND hwnd, POINT* ppt, IDataObject* pdtobj);

    // IDropTargetHelper methods
    STDMETHODIMP DragEnter(HWND hwndTarget, IDataObject* pdtobj, POINT* ppt, DWORD dwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP DragOver(POINT* ppt, DWORD dwEffect);
    STDMETHODIMP Drop(IDataObject* pdtobj, POINT* ppt, DWORD dwEffect);
    STDMETHODIMP Show(BOOL fShow);

    // These are public so the DAD_* routines can access.
    BOOL IsDragging()           { return (Initialized() && _Single.bDragging);              };
    BOOL IsDraggingImage()      { return (Initialized() && _fImage && _Single.bDragging);   };
    BOOL IsDraggingLayeredWindow() { return _shdi.hbmpDragImage != NULL; };
    BOOL SetDragImage(HIMAGELIST himl, int index, POINT * pptOffset);
    void SetDragCursor(int idCursor);
    HWND GetTarget() { return _hwndTarget; }
    BOOL Initialized();
    DWORD GetThread() { return _idThread; };
    void FreeDragData();

    void ThreadDetach();
    void ProcessDetach();

    // for drag source feedback communication
    void SetDropEffectCursor(int idCur);

    CDragImages() {};

private:
    ~CDragImages();

    void _InitDragData();
    BOOL _IsLayeredSupported();

    HRESULT _SaveToDataObject(IDataObject* pdtobj);
    HRESULT _LoadFromDataObject(IDataObject* pdtobj);

    HRESULT _LoadLayeredBitmapBits(HGLOBAL hGlobal);
    HRESULT _SaveLayeredBitmapBits(HGLOBAL* phGlobal);

    BOOL _ShowDragImageInterThread(HWND hwndLock, BOOL * pfShow);

    // MultiRectDragging
    void _MultipleDragShow(BOOL bShow);
    void _MultipleDragStart(HWND hwndLock, LPRECT aRect, int nRects, POINT ptStart, POINT ptOffset);
    void _MultipleDragMove(POINT ptNew);
    HRESULT _SetLayeredDragging(LPSHDRAGIMAGE pshdi);
    HRESULT _SetMultiItemDragging(HWND hwndLV, int cItems, POINT *pptOffset);
    HRESULT _SetMultiRectDragging(int cItems, LPRECT prect, POINT *pptOffset);

    // Merged Cursors
    HBITMAP CreateColorBitmap(int cx, int cy);
    void _DestroyCachedCursors();
    HRESULT _GetCursorLowerRight(HCURSOR hcursor, int * px, int * py, POINT *pptHotSpot);
    int _MapCursorIDToImageListIndex(int idCur);
    int _AddCursorToImageList(HCURSOR hcur, LPCTSTR idMerge, POINT *pptHotSpot);
    BOOL _MergeIcons(HCURSOR hcursor, LPCTSTR idMerge, HBITMAP *phbmImage, HBITMAP *phbmMask, POINT* pptHotSpot);
    HCURSOR _SetCursorHotspot(HCURSOR hcur, POINT *ptHot);

    // Helper Routines
    BOOL _CreateDragWindow();
    BOOL _PreProcessDragBitmap(void** ppvBits);

    // Member Variables
    SHDRAGIMAGE  _shdi;
    HWND         _hwndTarget;
    HWND         _hwnd;          // The HWND of the Layered Window
    HDC          _hdcDragImage;
    HBITMAP      _hbmpOld;

    BOOL         _fLayeredSupported;
    BOOL         _fCursorDataInited;

    POINT       _ptDebounce;

    // Legacy drag support
    BOOL        _fImage;
    POINT       _ptOffset;
    DWORD       _idThread;
    HIMAGELIST  _himlCursors;
    UINT        _cRev;
    int         _aindex[DCID_MAX]; // will be initialized.
    HCURSOR     _ahcur[DCID_MAX];
    POINT       _aptHotSpot[DCID_MAX];
    int         _idCursor;

    // _Single struct is used between DAD_Enter and DAD_Leave
    struct
    {
        // Common part
        BOOL    bDragging;
        BOOL    bLocked;
        HWND    hwndLock;
        BOOL    bSingle;    // Single imagelist dragging.
        DWORD   idThreadEntered;

        // Multi-rect dragging specific part
        struct 
        {
            BOOL bShown;
            LPRECT pRect;
            int nRects;
            POINT ptOffset;
            POINT ptNow;
        } _Multi;
    } _Single;

    // following fields are used only when fImage==FALSE
    RECT*       _parc;         // cItems
    UINT        _cItems;         // This is a sentinal. Needs to be the last item.
};

CDragImages::~CDragImages()
{
    FreeDragData();
}
//
// Read 'Notes' in CDropSource_GiveFeedback for detail about this
// g_fDraggingOverSource flag, which is TRUE only if we are dragging
// over the source window itself with left mouse button
// (background and large/small icon mode only).
//
UINT g_cRev = 0;
CDragImages* g_pdiDragImages = NULL;
BOOL g_fDraggingOverSource = FALSE;

STDAPI CDragImages_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvOut)
{
    ASSERT(pUnkOuter == NULL);  //Who's trying to aggregate us?
    if (!g_pdiDragImages)
        g_pdiDragImages = new CDragImages();

    if (g_pdiDragImages && ppvOut)  // ppvOut test for internal create usage
        return g_pdiDragImages->QueryInterface(riid, ppvOut);

    return E_OUTOFMEMORY;
}

STDMETHODIMP CDragImages::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDragImages, IDragSourceHelper),
        QITABENT(CDragImages, IDropTargetHelper),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

#define UM_KILLYOURSELF WM_USER

LRESULT CALLBACK DragWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == UM_KILLYOURSELF)
    {
        DestroyWindow(hwnd);

        return 0;
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}


BOOL CDragImages::_CreateDragWindow()
{
    if (_hwnd == NULL)
    {
        WNDCLASS wc = {0};

        wc.hInstance       = g_hinst;
        wc.lpfnWndProc     = DragWndProc;
        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.lpszClassName   = TEXT("SysDragImage");
        wc.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1); // NULL;
        SHRegisterClass(&wc);

        _hwnd = CreateWindowEx(WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TOOLWINDOW, 
            TEXT("SysDragImage"), TEXT("Drag"), WS_POPUPWINDOW,
            0, 0, 50, 50, NULL, NULL, g_hinst, NULL);

        if (!_hwnd)
            return FALSE;

        //
        // This window should not be mirrored so that the image contents won't be flipped. [samera]
        //
        SetWindowBits(_hwnd, GWL_EXSTYLE, RTL_MIRRORED_WINDOW, 0);
    }

    return TRUE;
}

BOOL CDragImages::Initialized()
{ 
    return _fCursorDataInited; 
}

void CDragImages::FreeDragData()
{

    if (_hwnd)
    {
        SendMessage(_hwnd, UM_KILLYOURSELF, 0, 0);
        _hwnd = NULL;
    }

    _fCursorDataInited = FALSE;

    // Make sure we destroy the cursors on an invalidate.
    if (_himlCursors)
        _DestroyCachedCursors();

    // Do we have an array?
    if (_parc)
    {
        delete [] _parc;
        _parc = NULL;
    }

    if (_fImage)
        ImageList_EndDrag();

    if (_hbmpOld)
    {
        SelectObject(_hdcDragImage, _hbmpOld);
        _hbmpOld = NULL;
    }

    if (_hdcDragImage)
    {
        DeleteDC(_hdcDragImage);
        _hdcDragImage = NULL;
    }

    if (_shdi.hbmpDragImage)
        DeleteObject(_shdi.hbmpDragImage);

    ZeroMemory(&_Single, sizeof(_Single));
    ZeroMemory(&_shdi, sizeof(_shdi));

    _ptOffset.x = 0;
    _ptOffset.y = 0;

    _ptDebounce.x = 0;
    _ptDebounce.y = 0;

    _hwndTarget = _hwnd = NULL;
    _fCursorDataInited = _fLayeredSupported = FALSE;
    _fImage = FALSE;
    _idThread = 0;
    _himlCursors = NULL;
    _cRev = 0;
    _idCursor = 0;
}

void CDragImages::_InitDragData()
{
    _idThread = GetCurrentThreadId();

    if (_himlCursors && _cRev != g_cRev)
        _DestroyCachedCursors();

    if (_himlCursors == NULL)
    {
        UINT uFlags = ILC_MASK | ILC_SHARED;
        if (IS_BIDI_LOCALIZED_SYSTEM())
            uFlags |= ILC_MIRROR;

        //
        // if this is not a palette device, use a DDB for the imagelist
        // this is important when displaying high-color cursors
        //
        HDC hdc = GetDC(NULL);
        if (!(GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE))
        {
            uFlags |= ILC_COLORDDB;
        }
        ReleaseDC(NULL, hdc);

        _himlCursors = ImageList_Create(GetSystemMetrics(SM_CXCURSOR),
                                        GetSystemMetrics(SM_CYCURSOR),
                                        uFlags, 1, 0);

        _cRev = g_cRev;

        // We need to initialize s_cursors._aindex[*]
        _MapCursorIDToImageListIndex(-1);
    }
    _fCursorDataInited = TRUE;
}

BOOL AreAllMonitorsAtLeast(int iBpp)
{
    DISPLAY_DEVICE DisplayDevice;
    BOOL fAreAllMonitorsAtLeast = TRUE;

    for (int iEnum = 0; fAreAllMonitorsAtLeast && iEnum < MONITORS_MAX; iEnum++)
    {
        ZeroMemory(&DisplayDevice, sizeof(DisplayDevice));
        DisplayDevice.cb = sizeof(DisplayDevice);

        if (EnumDisplayDevices(NULL, iEnum, &DisplayDevice, 0) &&
            (DisplayDevice.StateFlags & DISPLAY_DEVICE_ATTACHED_TO_DESKTOP))
        {

            HDC hdc = CreateDC(NULL, (LPTSTR)DisplayDevice.DeviceName, NULL, NULL);
            if (hdc)
            {
                int iBits = GetDeviceCaps(hdc, BITSPIXEL);

                if (iBits < iBpp)
                    fAreAllMonitorsAtLeast = FALSE;

                DeleteDC(hdc);
            }
        }
    }

    return fAreAllMonitorsAtLeast;
}

BOOL CDragImages::_IsLayeredSupported()
{
    // For the first rev, we will only support Layered drag images
    // when the Color depth is greater than 65k colors.

    // We should ask everytime....
    _fLayeredSupported = AreAllMonitorsAtLeast(16);
    
    if (_fLayeredSupported)
    {
        BOOL bDrag;
        if (SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &bDrag, 0))
        {
            _fLayeredSupported = BOOLIFY(bDrag);
        }

        if (_fLayeredSupported)
            _fLayeredSupported = SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("NewDragImages"), FALSE, TRUE);
    }
    return _fLayeredSupported;
}

//
// initialize the static drag image manager from a structure
// this is implemented for WindowLess controls that can act as a
// drag source.
//
HRESULT CDragImages::_SetLayeredDragging(LPSHDRAGIMAGE pshdi)
{
    // We don't support being initialized from a bitmap when Layered Windows are not supported
    HRESULT hr;
    if (_IsLayeredSupported())
    {
        RIP(IsValidHANDLE(pshdi->hbmpDragImage));

        _shdi = *pshdi;     // Keep a copy of this.

        _idCursor = -1;     // Initialize this... This is an arbitraty place and can be put 
                            // anywhere before the first Setcursor call
        _InitDragData();
        hr = S_OK;
    }
    else
        hr = E_FAIL;
    return hr;
}

STDMETHODIMP CDragImages::InitializeFromBitmap(LPSHDRAGIMAGE pshdi, IDataObject* pdtobj)
{
    FreeDragData();

    HRESULT hr = _SetLayeredDragging(pshdi);
    if (SUCCEEDED(hr))
    {
        hr = _SaveToDataObject(pdtobj);
        if (FAILED(hr))
            FreeDragData();
    }
    return hr;
}

BOOL ListView_HasMask(HWND hwnd)
{
    HIMAGELIST himl = ListView_GetImageList(hwnd, LVSIL_NORMAL);
    return himl && (ImageList_GetFlags(himl) & ILC_MASK);
}

//
// initialize the static drag image manager from an HWND that
// can process the RegisteredWindowMessage(DI_GETDRAGIMAGE)
//
STDMETHODIMP CDragImages::InitializeFromWindow(HWND hwnd, POINT* ppt, IDataObject* pdtobj)
{
    HRESULT hr = E_FAIL;

    FreeDragData();

    if (_IsLayeredSupported())
    {
        // Register the message that gets us the Bitmap from the control.
        static int g_msgGetDragImage = 0;
        if (g_msgGetDragImage == 0)
            g_msgGetDragImage = RegisterWindowMessage(DI_GETDRAGIMAGE);

        // Can this HWND generate a drag image for me?
        if (g_msgGetDragImage && SendMessage(hwnd, g_msgGetDragImage, 0, (LPARAM)&_shdi))
        {
            // Yes; Now we select that into the window 
            hr = _SetLayeredDragging(&_shdi);
        }
    }

    if (FAILED(hr))
    {
        TCHAR szClassName[50];

        if (GetClassName(hwnd, szClassName, ARRAYSIZE(szClassName))) 
        {
            if (lstrcmpi(szClassName, WC_LISTVIEW) == 0)
            {
                POINT ptOffset = {0,0};

                if (ppt)
                    ptOffset = *ppt;

                int cItems = ListView_GetSelectedCount(hwnd);
                if (cItems >= 1)
                {
                    if ((cItems == 1) && ListView_HasMask(hwnd))
                    {
                        POINT ptTemp;
                        HIMAGELIST himl = ListView_CreateDragImage(hwnd, ListView_GetNextItem(hwnd, -1, LVNI_SELECTED), &ptTemp);
                        if (himl)
                        {
                            ClientToScreen(hwnd, &ptTemp);
                            ptOffset.x -= ptTemp.x;

                            // Since the listview is mirrored, then mirror the selected
                            // icon coord. This would result in negative offset so let's
                            // compensate. [samera]
                            if (IS_WINDOW_RTL_MIRRORED(hwnd))
                                ptOffset.x *= -1;

                            ptOffset.y -= ptTemp.y;
                            SetDragImage(himl, 0, &ptOffset);
                            ImageList_Destroy(himl);
                            hr = S_OK;
                        }
                    }
                    else
                    {
                        hr = _SetMultiItemDragging(hwnd, cItems, &ptOffset);
                    }
                }
            }
            else if (lstrcmpi(szClassName, WC_TREEVIEW) == 0)
            {
                HIMAGELIST himlDrag = TreeView_CreateDragImage(hwnd, NULL);
                if (himlDrag) 
                {
                    SetDragImage(himlDrag, 0, NULL);
                    ImageList_Destroy(himlDrag);
                    hr = S_OK;
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // ignore failure here as this will still work in process due to the globals
        // fonts folder depends on this
        _SaveToDataObject(pdtobj);
    }

    return hr;
}

//
//  create the drag window in the layered window case, or to begin drawing the 
//  Multi Rect or icon drag images.
//
STDMETHODIMP CDragImages::DragEnter(HWND hwndTarget, IDataObject* pdtobj, POINT* ppt, DWORD dwEffect)
{
    HRESULT hr = _LoadFromDataObject(pdtobj);
    if (SUCCEEDED(hr))
    {
        _hwndTarget = hwndTarget ? hwndTarget : GetDesktopWindow();
        SetDragCursor(-1);
        _Single.bDragging = TRUE;
        _Single.bSingle = _fImage;
        _Single.hwndLock = _hwndTarget;
        _Single.bLocked = FALSE;
        _Single.idThreadEntered = GetCurrentThreadId();

        _ptDebounce.x = 0;
        _ptDebounce.y = 0;

        if (_shdi.hbmpDragImage)
        {
            TraceMsg(TF_DRAGIMAGES, "CDragImages::DragEnter : Creating Drag Window");
            // At this point the information has been read from the data object. 
            // Reconstruct the HWND if necessary
            if (_CreateDragWindow() && _hdcDragImage)
            {
                POINT ptSrc = {0, 0};
                POINT pt;

                SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | 
                    SWP_NOSIZE | SWP_NOZORDER | SWP_SHOWWINDOW);

                GetMsgPos(&pt);

                pt.x -= _shdi.ptOffset.x;
                pt.y -= _shdi.ptOffset.y;

                BLENDFUNCTION blend;
                blend.BlendOp = AC_SRC_OVER;
                blend.BlendFlags = 0;
                blend.AlphaFormat = AC_SRC_ALPHA;
                blend.SourceConstantAlpha = 0xFF /*DRAGDROP_ALPHA*/;

                HDC hdc = GetDC(_hwnd);
                if (hdc)
                {
                    DWORD fULWType = ULW_ALPHA;

                    // Should have been preprocess already
                    UpdateLayeredWindow(_hwnd, hdc, &pt, &(_shdi.sizeDragImage), 
                                        _hdcDragImage, &ptSrc, _shdi.crColorKey,
                                        &blend, fULWType);

                    ReleaseDC(_hwnd, hdc);
                }
                hr = S_OK;
            }
        }
        else
        {
            // These are in Client Cordinates, not screen coords. Translate:
            POINT pt = *ppt;
            RECT rc;
            GetWindowRect(_hwndTarget, &rc);
            pt.x -= rc.left;
            pt.y -= rc.top;
            if (_fImage)
            {
                // Avoid the flicker by always pass even coords
                ImageList_DragEnter(hwndTarget, pt.x & ~1, pt.y & ~1);
                hr = S_OK;
            }
            else
            {
                _MultipleDragStart(hwndTarget, _parc, _cItems, pt, _ptOffset);
                hr = S_OK;
            }
        }

        //
        // We should always show the image whenever this function is called.
        //
        Show(TRUE);
    }
    return hr;
}

//
//  kill the Layered Window, or to stop painting the icon or rect drag images
//
STDMETHODIMP CDragImages::DragLeave()
{
    TraceMsg(TF_DRAGIMAGES, "CDragImages::DragLeave");
    if (Initialized())
    {
        if (_hwnd)
        {
            FreeDragData();
        }
        else if (_Single.bDragging &&
             _Single.idThreadEntered == GetCurrentThreadId())
        {
            Show(FALSE);

            if (_fImage)
            {
                ImageList_DragLeave(_Single.hwndLock);
            }

            _Single.bDragging = FALSE;

            DAD_SetDragImage((HIMAGELIST)-1, NULL);
        }

        _ptDebounce.x = 0;
        _ptDebounce.y = 0;
    }

    return S_OK;
}

//  move the Layered window or to rerender the icon or rect images within
//  the Window they are over.
//
STDMETHODIMP CDragImages::DragOver(POINT* ppt, DWORD dwEffect)
{
    if (Initialized())
    {
        TraceMsg(TF_DRAGIMAGES, "CDragImages::DragOver pt {%d, %d}", ppt->x, ppt->y);
        // Avoid the flicker by always pass even coords
        ppt->x &= ~1;
        ppt->y &= ~1;

        if (_ptDebounce.x != ppt->x || _ptDebounce.y != ppt->y)
        {
            _ptDebounce.x = ppt->x;
            _ptDebounce.y = ppt->y;
            if (IsDraggingLayeredWindow())
            {
                POINT pt;
                GetCursorPos(&pt);
                pt.x -= _shdi.ptOffset.x;
                pt.y -= _shdi.ptOffset.y;

                SetWindowPos(_hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | 
                    SWP_NOSIZE | SWP_SHOWWINDOW);

                UpdateLayeredWindow(_hwnd, NULL, &pt, NULL, NULL, NULL, 0,
                    NULL, 0);
            }
            else
            {
                // These are in Client Cordinates, not screen coords. Translate:
                POINT pt = *ppt;
                RECT rc;
                GetWindowRect(_hwndTarget, &rc);
                pt.x -= rc.left;
                pt.y -= rc.top;
                if (_fImage)
                {
                    ImageList_DragMove(pt.x, pt.y);
                }
                else
                {
                    _MultipleDragMove(pt);
                }
            }
        }
    }

    return S_OK;
}

//  do any cleanup after a drop (Currently calls DragLeave)
//
STDMETHODIMP CDragImages::Drop(IDataObject* pdtobj, POINT* ppt, DWORD dwEffect)
{
    return DragLeave();
}

//  initialize the static drag image manager from a structure
//  this is implemented for WindowLess controls that can act as a
//  drag source.
//
void CDragImages::SetDragCursor(int idCursor)
{
    //
    // Ignore if we are dragging over ourselves.
    //
    if (IsDraggingImage())
    {
        POINT ptHotSpot;

        if (_himlCursors && (idCursor != -1))
        {
            int iIndex = _MapCursorIDToImageListIndex(idCursor);
            if (iIndex != -1) 
            {
                ImageList_GetDragImage(NULL, &ptHotSpot);
                ptHotSpot.x -= _aptHotSpot[idCursor].x;
                ptHotSpot.y -= _aptHotSpot[idCursor].y;
                if (ptHotSpot.x < 0)
                {
                    ptHotSpot.x = 0;
                }

                if (ptHotSpot.y < 0)
                {
                    ptHotSpot.y = 0;
                }

                ImageList_SetDragCursorImage(_himlCursors, iIndex, ptHotSpot.x, ptHotSpot.y);
            } 
            else 
            {
                // You passed a bad Cursor ID.
                ASSERT(0);
            }
        }

        _idCursor = idCursor;
    }
}

// init our state from the hGlobal so we can draw 
HRESULT CDragImages::_LoadLayeredBitmapBits(HGLOBAL hGlobal)
{
    HRESULT hr = E_FAIL;

    if (!Initialized())
    {
        ASSERT(_shdi.hbmpDragImage == NULL);
        ASSERT(_hdcDragImage == NULL);

        HDC hdcScreen = GetDC(NULL);
        if (hdcScreen)
        {
            void *pvDragStuff = (void*)GlobalLock(hGlobal);
            if (pvDragStuff)
            {
                CopyMemory(&_shdi, pvDragStuff, sizeof(_shdi));

                BITMAPINFO bmi = {0};

                // Create a buffer to read the bits into
                bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
                bmi.bmiHeader.biWidth       = _shdi.sizeDragImage.cx;
                bmi.bmiHeader.biHeight      = _shdi.sizeDragImage.cy;
                bmi.bmiHeader.biPlanes      = 1;
                bmi.bmiHeader.biBitCount    = 32;
                bmi.bmiHeader.biCompression = BI_RGB;

                // Next create a DC and an HBITMAP.
                _hdcDragImage = CreateCompatibleDC(hdcScreen);
                if (_hdcDragImage)
                {
                    void *pvBits;
                    _shdi.hbmpDragImage = CreateDIBSection(_hdcDragImage, &bmi, DIB_RGB_COLORS, &pvBits, NULL, NULL);
                    if (_shdi.hbmpDragImage)
                    {
                        _hbmpOld = (HBITMAP)SelectObject(_hdcDragImage, _shdi.hbmpDragImage);

                        // then Set the bits into the Bitmap
                        RGBQUAD* pvStart = (RGBQUAD*)((BYTE*)pvDragStuff + sizeof(SHDRAGIMAGE));
                        DWORD dwCount = _shdi.sizeDragImage.cx * _shdi.sizeDragImage.cy * sizeof(RGBQUAD);
                        CopyMemory((RGBQUAD*)pvBits, (RGBQUAD*)pvStart, dwCount);

                        hr = S_OK;    // success!
                    }
                }
                GlobalUnlock(hGlobal);
            }
            ReleaseDC(NULL, hdcScreen);
        }
    }
    return hr;
}

// Writes the written information into phGlobal to recreate the drag image
HRESULT CDragImages::_SaveLayeredBitmapBits(HGLOBAL* phGlobal)
{
    HRESULT hr = E_FAIL;
    if (Initialized())
    {
        ASSERT(_shdi.hbmpDragImage);

        DWORD cbImageSize = _shdi.sizeDragImage.cx * _shdi.sizeDragImage.cy * sizeof(RGBQUAD);
        *phGlobal = GlobalAlloc(GPTR, cbImageSize + sizeof(SHDRAGIMAGE));
        if (*phGlobal)
        {
            void *pvDragStuff = GlobalLock(*phGlobal);
            CopyMemory(pvDragStuff, &_shdi, sizeof(SHDRAGIMAGE));

            void *pvBits;
            hr = _PreProcessDragBitmap(&pvBits) ? S_OK : E_FAIL;
            if (SUCCEEDED(hr))
            {
                RGBQUAD* pvStart = (RGBQUAD*)((BYTE*)pvDragStuff + sizeof(SHDRAGIMAGE));
                DWORD dwCount = _shdi.sizeDragImage.cx * _shdi.sizeDragImage.cy * sizeof(RGBQUAD);
                CopyMemory((RGBQUAD*)pvStart, (RGBQUAD*)pvBits, dwCount);
            }
            GlobalUnlock(*phGlobal);
        }
    }
    return hr;
}

BOOL IsColorKey(RGBQUAD rgbPixel, COLORREF crKey)
{
    // COLORREF is backwards to RGBQUAD
    return InRange( rgbPixel.rgbBlue,  ((crKey & 0xFF0000) >> 16) - 5, ((crKey & 0xFF0000) >> 16) + 5) &&
           InRange( rgbPixel.rgbGreen, ((crKey & 0x00FF00) >>  8) - 5, ((crKey & 0x00FF00) >>  8) + 5) &&
           InRange( rgbPixel.rgbRed,   ((crKey & 0x0000FF) >>  0) - 5, ((crKey & 0x0000FF) >>  0) + 5);
}

#ifdef RADIAL

int QuickRoot(int n, int iNum)
{

    int iRoot = iNum;
    for (int i=10; i > 0; i--)
    {
        int iOld = iRoot;
        iRoot = (iRoot + iNum/iRoot)/2;
        if (iRoot == iOld)
            break;
    }

    return iRoot;
}

#endif

BOOL CDragImages::_PreProcessDragBitmap(void** ppvBits)
{
    BOOL fRet = FALSE;

    ASSERT(_hdcDragImage == NULL);
    _hdcDragImage = CreateCompatibleDC(NULL);
    if (_hdcDragImage)
    {
        ULONG*          pul;
        HBITMAP         hbmpResult = NULL;
        HBITMAP         hbmpOld;
        HDC             hdcSource = NULL;
        BITMAPINFO      bmi = {0};
        HBITMAP         hbmp = _shdi.hbmpDragImage;

        bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
        bmi.bmiHeader.biWidth       = _shdi.sizeDragImage.cx;
        bmi.bmiHeader.biHeight      = _shdi.sizeDragImage.cy;
        bmi.bmiHeader.biPlanes      = 1;
        bmi.bmiHeader.biBitCount    = 32;
        bmi.bmiHeader.biCompression = BI_RGB;

        hdcSource = CreateCompatibleDC(_hdcDragImage);
        if (hdcSource)
        {
            hbmpResult = CreateDIBSection(_hdcDragImage,
                                       &bmi,
                                       DIB_RGB_COLORS,
                                       ppvBits,
                                       NULL,
                                       0);

            if (hbmpResult)
            {
                _hbmpOld = (HBITMAP)SelectObject(_hdcDragImage, hbmpResult);
                hbmpOld = (HBITMAP)SelectObject(hdcSource, hbmp);

                BitBlt(_hdcDragImage, 0, 0, _shdi.sizeDragImage.cx, _shdi.sizeDragImage.cy,
                       hdcSource, 0, 0, SRCCOPY);

                pul = (ULONG*)*ppvBits;

                int iOffsetX = _shdi.ptOffset.x;
                int iOffsetY = _shdi.ptOffset.y;
                int iDenomX = max(_shdi.sizeDragImage.cx - iOffsetX, iOffsetX);
                int iDenomY = max(_shdi.sizeDragImage.cy - iOffsetY, iOffsetY);
                BOOL fRadialFade = TRUE;
                // If both are less than the max, then no radial fade.
                if (_shdi.sizeDragImage.cy <= MAX_HEIGHT_ALPHA && _shdi.sizeDragImage.cx <= MAX_WIDTH_ALPHA)
                    fRadialFade = FALSE;

                for (int Y = 0; Y < _shdi.sizeDragImage.cy; Y++)
                {
                    int y = _shdi.sizeDragImage.cy - Y; // Bottom up DIB.
                    for (int x = 0; x < _shdi.sizeDragImage.cx; x++)
                    {
                        RGBQUAD* prgb = (RGBQUAD*)&pul[Y * _shdi.sizeDragImage.cx + x];

                        if (_shdi.crColorKey != CLR_NONE && 
                            IsColorKey(*prgb, _shdi.crColorKey))
                        {
                            // Write a pre-multiplied value of 0:

                            *((DWORD*)prgb) = 0;
                        }
                        else
                        {
                            int Alpha = prgb->rgbReserved;
                            if (_shdi.crColorKey != CLR_NONE)
                            {
                                Alpha = DRAGDROP_ALPHA;
                            }
                            else
                            {
                                Alpha -= (Alpha / 3);
                            }

                            if (fRadialFade && Alpha > 0)
                            {
                                // This does not generate a smooth curve, but this is just
                                // an effect, not trying to be accurate here.

                                // 3 devides per pixel
                                int ddx = (x < iOffsetX)? iOffsetX - x : x - iOffsetX;
                                int ddy = (y < iOffsetY)? iOffsetY - y : y - iOffsetY;

                                __int64 iAlphaX = (100000l - (((__int64)ddx * 100000l) / (iDenomX )));
                                __int64 iAlphaY = (100000l - (((__int64)ddy * 100000l) / (iDenomY )));

                                ASSERT (iAlphaX >= 0);
                                ASSERT (iAlphaY >= 0);

                                __int64 iDenom = 100000;
                                iDenom *= 100000;

                                Alpha = (int) ((Alpha * iAlphaX * iAlphaY * 100000) / (iDenom* 141428));
                            }

                            ASSERT(Alpha <= 0xFF);
                            prgb->rgbReserved = (BYTE)Alpha;
                            prgb->rgbRed      = ((prgb->rgbRed   * Alpha) + 128) / 255;
                            prgb->rgbGreen    = ((prgb->rgbGreen * Alpha) + 128) / 255;
                            prgb->rgbBlue     = ((prgb->rgbBlue  * Alpha) + 128) / 255;
                        }
                    }
                }

                DeleteObject(hbmp);
                _shdi.hbmpDragImage = hbmpResult;

                fRet = TRUE;

                if (hbmpOld)
                    SelectObject(hdcSource, hbmpOld);
            }

            DeleteObject(hdcSource);
        }
    }

    return fRet;
}

CLIPFORMAT _GetDragContentsCF()
{
    static UINT s_cfDragContents = 0;
    if (0 == s_cfDragContents)
        s_cfDragContents = RegisterClipboardFormat(CFSTR_DRAGCONTEXT);
    return (CLIPFORMAT) s_cfDragContents;
}

CLIPFORMAT _GetDragImageBitssCF()
{
    static UINT s_cfDragImageBitss = 0;
    if (0 == s_cfDragImageBitss)
        s_cfDragImageBitss = RegisterClipboardFormat(TEXT("DragImageBits"));
    return (CLIPFORMAT) s_cfDragImageBitss;
}


// persist our state into the data object. so on the target side they can grab this
// data out and render the thing being dragged

HRESULT CDragImages::_SaveToDataObject(IDataObject *pdtobj)
{
    HRESULT hr = E_FAIL;    // one form of the saves below must succeed
    if (Initialized())
    {
        STGMEDIUM medium = {0};
        medium.tymed = TYMED_ISTREAM;

        if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &medium.pstm)))
        {
            // Set the header .
            DragContextHeader hdr = {0};
            hdr.fImage   = _fImage;
            hdr.fLayered = IsDraggingLayeredWindow();
            hdr.ptOffset = _ptOffset;
       
            //First Write the drag context header
            ULONG ulWritten;
            if (SUCCEEDED(medium.pstm->Write(&hdr, sizeof(hdr), &ulWritten)) &&
                (ulWritten == sizeof(hdr)))
            {
                if (hdr.fLayered)
                {
                    STGMEDIUM mediumBits = {0};
                    // Set the medium.
                    mediumBits.tymed = TYMED_HGLOBAL;

                    // Write out layered window information
                    hr = _SaveLayeredBitmapBits(&mediumBits.hGlobal);
                    if (SUCCEEDED(hr))
                    {
                        FORMATETC fmte = {_GetDragImageBitssCF(), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

                        // Set the medium in the data.
                        hr = pdtobj->SetData(&fmte, &mediumBits, TRUE);
                        if (FAILED(hr))
                            ReleaseStgMedium(&mediumBits);  // cleanup
                    }
                }
                else if (hdr.fImage)
                {
                    // write an image
    
                    HIMAGELIST himl = ImageList_GetDragImage(NULL, NULL);
                    if (ImageList_Write(himl, medium.pstm))
                    {
                        hr = S_OK;  // success
                    }
                }
                else
                {
                    // multi rect
        
                    if (SUCCEEDED(medium.pstm->Write(&_cItems, sizeof(_cItems), &ulWritten)) &&
                        (ulWritten == sizeof(_cItems)))
                    {
                        // Write the  rects into the stream
                        if (SUCCEEDED(medium.pstm->Write(_parc, sizeof(_parc[0]) * _cItems, &ulWritten)) && 
                            (ulWritten == (sizeof(_parc[0]) * _cItems)))
                        {
                            hr = S_OK;  // success
                        }
                    }
                }

                if (SUCCEEDED(hr))
                {
                    // Set the seek pointer at the beginning.
                    medium.pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);

                    // Set the Formatetc
                    FORMATETC fmte = {_GetDragContentsCF(), NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM};

                    // Set the medium in the data.
                    hr = pdtobj->SetData(&fmte, &medium, TRUE);
                }
            }

            if (FAILED(hr))
                ReleaseStgMedium(&medium);
        }
    }
    return hr;
}

// Gets the information to rebuild the drag images from the data object
HRESULT CDragImages::_LoadFromDataObject(IDataObject *pdtobj)
{
    // Check if we have a drag context
    HRESULT hr;

    // NULL pdtobj is for the old DAD_DragEnterXXX() APIs...
    // we hope this in the same process
    if (Initialized() || !pdtobj)
    {
        hr = S_OK;    // already loaded
    }
    else
    {
        // Set the format we are interested in
        FORMATETC fmte = {_GetDragContentsCF(), NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM};

        //if the data object has the format we are interested in
        // then Get the data
        STGMEDIUM medium = {0};
        hr = pdtobj->GetData(&fmte, &medium);
        if (SUCCEEDED(hr))   // if no pstm, bag out.
        {
            // Set the seek pointer at the beginning. PARANOIA: This is for people
            // Who don't set the seek for me.
            medium.pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);

            //First Read the drag context header
            DragContextHeader hdr;
            if (SUCCEEDED(IStream_Read(medium.pstm, &hdr, sizeof(hdr))))
            {
                if (hdr.fLayered)
                {
                    STGMEDIUM mediumBits;
                    FORMATETC fmte = {_GetDragImageBitssCF(), NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

                    hr = pdtobj->GetData(&fmte, &mediumBits);
                    if (SUCCEEDED(hr))
                    {
                        hr = _LoadLayeredBitmapBits(mediumBits.hGlobal);
                        ReleaseStgMedium(&mediumBits);
                    }
                }
                else if (hdr.fImage)
                {
                    // single image
                    HIMAGELIST himl = ImageList_Read(medium.pstm);
                    if (himl)
                    {
                        DAD_SetDragImage(himl, &(hdr.ptOffset));
                        ImageList_Destroy(himl);
                        hr = S_OK;
                    }
                }
                else
                {
                    // multi rect
                    int cItems;
                    if (SUCCEEDED(IStream_Read(medium.pstm, &cItems, sizeof(cItems))))
                    {
                        RECT *prect = (RECT *)LocalAlloc(LPTR, sizeof(*prect) * cItems);
                        if (prect)
                        {
                            if (SUCCEEDED(IStream_Read(medium.pstm, prect, sizeof(*prect) * cItems)))
                            {
                                hr = _SetMultiRectDragging(cItems, prect, &hdr.ptOffset);
                            }
                            LocalFree(prect);
                        }
                    }
                }
            }

            if (SUCCEEDED(hr))
                _InitDragData();

            // Set the seek pointer at the beginning. Just cleaning up...
            medium.pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);

            // Release the stg medium.
            ReleaseStgMedium(&medium);
        }
    }
    return hr;
}


// Shows or hides the drag images. NOTE: Doesn't do anything in the layered window case.
// We don't need to because this function is specifically for drawing to a locked window.
STDMETHODIMP CDragImages::Show(BOOL bShow)
{
    BOOL fOld = bShow;
    TraceMsg(TF_DRAGIMAGES, "CDragImages::Show(%s)", bShow? TEXT("true") : TEXT("false"));

    if (!Initialized() || !_Single.bDragging)
    {
        return S_FALSE;
    }

    // No point in showing and hiding a Window. This causes unnecessary flicker.
    if (_hwnd)
    {
        return S_OK;
    }

    // If we're going across thread boundaries we have to try a context switch
    if (GetCurrentThreadId() != GetWindowThreadProcessId(_Single.hwndLock, NULL) &&
        _ShowDragImageInterThread(_Single.hwndLock, &fOld))
        return fOld;

    fOld = _Single.bLocked;

    //
    // If we are going to show the drag image, lock the target window.
    //
    if (bShow && !_Single.bLocked)
    {
        TraceMsg(TF_DRAGIMAGES, "CDragImages::Show : Shown and not locked");
        UpdateWindow(_Single.hwndLock);
        LockWindowUpdate(_Single.hwndLock);
        _Single.bLocked = TRUE;
    }

    if (_Single.bSingle)
    {
        TraceMsg(TF_DRAGIMAGES, "CDragImages::Show : Calling ImageList_DragShowNoLock");
        ImageList_DragShowNolock(bShow);
    }
    else
    {
        TraceMsg(TF_DRAGIMAGES, "CDragImages::Show : MultiDragShow");
        _MultipleDragShow(bShow);
    }

    //
    // If we have just hide the drag image, unlock the target window.
    //
    if (!bShow && _Single.bLocked)
    {
        TraceMsg(TF_DRAGIMAGES, "CDragImages::Show : hiding image, unlocking");
        LockWindowUpdate(NULL);
        _Single.bLocked = FALSE;
    }

    return fOld ? S_OK : S_FALSE;
}

// tell the drag source to hide or unhide the drag image to allow
// the destination to do drawing (unlock the screen)
//
// in:
//      bShow   FALSE   - hide the drag image, allow drawing
//              TRUE    - show the drag image, no drawing allowed after this

// Helper function for DAD_ShowDragImage - handles the inter-thread case.
// We need to handle this case differently because LockWindowUpdate calls fail
// if they are on the wrong thread.

BOOL CDragImages::_ShowDragImageInterThread(HWND hwndLock, BOOL * pfShow)
{
    TCHAR szClassName[50];

    if (GetClassName(hwndLock, szClassName, ARRAYSIZE(szClassName))) 
    {
        UINT uMsg = 0;
        ULONG_PTR dw = 0;

        if (lstrcmpi(szClassName, TEXT("SHELLDLL_DefView")) == 0)
            uMsg = WM_DSV_SHOWDRAGIMAGE;
        if (lstrcmpi(szClassName, TEXT("CabinetWClass")) == 0)
            uMsg = CWM_SHOWDRAGIMAGE;

        if (uMsg) 
        {
            SendMessageTimeout(hwndLock, uMsg, 0, *pfShow, SMTO_ABORTIFHUNG, 1000, &dw);
            *pfShow = (dw != 0);
            return TRUE;
        }
    }

    return FALSE;
}

void CDragImages::ThreadDetach()
{
    if (_idThread == GetCurrentThreadId())
        FreeDragData();
}

void CDragImages::ProcessDetach()
{
    FreeDragData();
}

BOOL CDragImages::SetDragImage(HIMAGELIST himl, int index, POINT * pptOffset)
{
    if (himl)
    {
        // We are setting
        if (Initialized())
            return FALSE;

        _fImage = TRUE;
        if (pptOffset) 
        {
            // Avoid the flicker by always pass even coords
            _ptOffset.x = (pptOffset->x & ~1);
            _ptOffset.y = (pptOffset->y & ~1);
        }

        ImageList_BeginDrag(himl, index, _ptOffset.x, _ptOffset.y);
        _InitDragData();
    }
    else
    {
        FreeDragData();
    }
    return TRUE;
}

//=====================================================================
// Multiple Drag show
//=====================================================================

void CDragImages::_MultipleDragShow(BOOL bShow)
{
    HDC hDC;
    int nRect;
    RECT rc, rcClip;

    if ((bShow && _Single._Multi.bShown) || (!bShow && !_Single._Multi.bShown))
        return;

    _Single._Multi.bShown = bShow;

    // clip to window, NOT SM_CXSCREEN/SM_CYSCREEN (multiple monitors)
    GetWindowRect(_Single.hwndLock, &rcClip);
    rcClip.right -= rcClip.left;
    rcClip.bottom -= rcClip.top;

    hDC = GetDCEx(_Single.hwndLock, NULL, DCX_WINDOW | DCX_CACHE |
        DCX_LOCKWINDOWUPDATE | DCX_CLIPSIBLINGS);


    for (nRect = _Single._Multi.nRects - 1; nRect >= 0; --nRect)
    {
        rc = _Single._Multi.pRect[nRect];
        OffsetRect(&rc, _Single._Multi.ptNow.x - _Single._Multi.ptOffset.x,
            _Single._Multi.ptNow.y - _Single._Multi.ptOffset.y);

        if ((rc.top < rcClip.bottom) && (rc.bottom > 0) &&
            (rc.left < rcClip.right) && (rc.right > 0))
        {
            DrawFocusRect(hDC, &rc);
        }
    }
    ReleaseDC(_Single.hwndLock, hDC);
}

void CDragImages::_MultipleDragStart(HWND hwndLock, LPRECT aRect, int nRects, POINT ptStart, POINT ptOffset)
{
    _Single._Multi.bShown = FALSE;
    _Single._Multi.pRect = aRect;
    _Single._Multi.nRects = nRects;
    _Single._Multi.ptOffset = ptOffset;
    _Single._Multi.ptNow = ptStart;
}

void CDragImages::_MultipleDragMove(POINT ptNew)
{
    if ((_Single._Multi.ptNow.x == ptNew.x) &&
        (_Single._Multi.ptNow.y == ptNew.y))
    {
        // nothing has changed.  bail
        return;
    }

    if (_Single._Multi.bShown)
    {
        HDC hDC;
        int nRect;
        RECT rc, rcClip;
        int dx1 = _Single._Multi.ptNow.x - _Single._Multi.ptOffset.x;
        int dy1 = _Single._Multi.ptNow.y - _Single._Multi.ptOffset.y;
        int dx2 = ptNew.x - _Single._Multi.ptNow.x;
        int dy2 = ptNew.y - _Single._Multi.ptNow.y;

        // clip to window, NOT SM_CXSCREEN/SM_CYSCREEN (multiple monitors)
        GetWindowRect(_Single.hwndLock, &rcClip);
        rcClip.right -= rcClip.left;
        rcClip.bottom -= rcClip.top;

        hDC = GetDCEx(_Single.hwndLock, NULL, DCX_WINDOW | DCX_CACHE |
            DCX_LOCKWINDOWUPDATE | DCX_CLIPSIBLINGS);

        for (nRect = _Single._Multi.nRects - 1; nRect >= 0; --nRect)
        {
            rc = _Single._Multi.pRect[nRect];
            // hide pass
            OffsetRect(&rc, dx1, dy1);
            if ((rc.top < rcClip.bottom) && (rc.bottom > 0) &&
                (rc.left < rcClip.right) && (rc.right > 0))
            {
                DrawFocusRect(hDC, &rc);
            }
            // show pass
            OffsetRect(&rc, dx2, dy2);
            if ((rc.top < rcClip.bottom) && (rc.bottom > 0) &&
                (rc.left < rcClip.right) && (rc.right > 0))
            {
                DrawFocusRect(hDC, &rc);
            }
        }
        ReleaseDC(_Single.hwndLock, hDC);
    }

    _Single._Multi.ptNow = ptNew;
}

HRESULT CDragImages::_SetMultiRectDragging(int cItems, LPRECT prect, POINT *pptOffset)
{
    if (!Initialized())
    {
        // Multiple item drag
        _cItems = cItems;
        _parc = new RECT[2 * _cItems];
        if (_parc)
        {
            for (int i = 0;  i < cItems; i++)
                _parc[i] = prect[i];

            // Avoid the flicker by always pass even coords
            _ptOffset.x = (pptOffset->x & ~1);
            _ptOffset.y = (pptOffset->y & ~1);
            _InitDragData();
        }
    }
    return S_OK;
}

#define ListView_IsIconView(hwndLV)    ((GetWindowLong(hwndLV, GWL_STYLE) & (UINT)LVS_TYPEMASK) == (UINT)LVS_ICON)

HRESULT CDragImages::_SetMultiItemDragging(HWND hwndLV, int cItems, POINT *pptOffset)
{
    HRESULT hr = E_FAIL;

    if (!Initialized())
    {
        // Multiple item drag
        ASSERT(NULL == _parc);

        _parc = new RECT[2 * cItems];
        if (_parc)
        {
            POINT ptTemp;
            int iLast, iNext;
            int cxScreens, cyScreens;
            LPRECT prcNext;
            RECT rc;

            _cItems = 0;
            ASSERT(_fImage == FALSE);

            //
            // If this is a mirrored Window, then lead edge is going
            // to be the far end in screen coord. So let's compute
            // as the original code, and later in _MultipleDragMove
            // we will compensate.
            //
        
            GetWindowRect( hwndLV , &rc );
            ptTemp.x = rc.left;
            ptTemp.y = rc.top;

            //
            // Reflect the shift the if the window is RTL mirrored.
            //
            if (IS_WINDOW_RTL_MIRRORED(hwndLV))
            {
                ptTemp.x = -ptTemp.x;
                pptOffset->x = ((rc.right-rc.left)-pptOffset->x);
            }

            cxScreens = GetSystemMetrics(SM_CXVIRTUALSCREEN);
            cyScreens = GetSystemMetrics(SM_CYVIRTUALSCREEN);

            // for pre-Nashville platforms
            if (!cxScreens || !cyScreens)
            {
                cxScreens = GetSystemMetrics(SM_CXSCREEN);
                cyScreens = GetSystemMetrics(SM_CYSCREEN);
            }

            for (iNext = cItems - 1, iLast = -1, prcNext = _parc; iNext >= 0; --iNext)
            {
                iLast = ListView_GetNextItem(hwndLV, iLast, LVNI_SELECTED);
                if (iLast != -1) 
                {
                    ListView_GetItemRect(hwndLV, iLast, &prcNext[0], LVIR_ICON);
                    OffsetRect(&prcNext[0], ptTemp.x, ptTemp.y);

                    if (((prcNext[0].left - pptOffset->x) < cxScreens) &&
                        ((pptOffset->x - prcNext[0].right) < cxScreens) &&
                        ((prcNext[0].top - pptOffset->y) < cyScreens)) 
                    {

                        ListView_GetItemRect(hwndLV, iLast, &prcNext[1], LVIR_LABEL);
                        OffsetRect(&prcNext[1], ptTemp.x, ptTemp.y);
                        if ((pptOffset->y - prcNext[1].bottom) < cxScreens) 
                        {
                            //
                            // Fix 24857: Ask JoeB why we are drawing a bar instead of
                            //  a text rectangle.
                            //
                            prcNext[1].top = (prcNext[1].top + prcNext[1].bottom)/2;
                            prcNext[1].bottom = prcNext[1].top + 2;
                            prcNext += 2;
                            _cItems += 2;
                        }
                    }
                }
            }

            // Avoid the flicker by always pass even coords
            _ptOffset.x = (pptOffset->x & ~1);
            _ptOffset.y = (pptOffset->y & ~1);
            _InitDragData();
            hr = S_OK;
        }
    }
    return hr;
}

//=====================================================================
// Cursor Merging
//=====================================================================
void CDragImages::_DestroyCachedCursors()
{
    if (_himlCursors) 
    {
        ImageList_Destroy(_himlCursors);
        _himlCursors = NULL;
    }

    HCURSOR hcursor = GetCursor();
    for (int i = 0; i < ARRAYSIZE(_ahcur); i++) 
    {
        if (_ahcur[i])
        {
            if (_ahcur[i] == hcursor)
            {
                //
                // Stuff in some random cursor so that we don't try to
                // destroy the current cursor (and leak it too).
                //
                SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));
            }
            DestroyCursor(_ahcur[i]);
            _ahcur[i] = NULL;
        }
    }
}

HBITMAP CDragImages::CreateColorBitmap(int cx, int cy)
{
    HDC hdc = GetDC(NULL);
    HBITMAP hbm = CreateCompatibleBitmap(hdc, cx, cy);
    ReleaseDC(NULL, hdc);
    return hbm;
}

#define CreateMonoBitmap( cx,  cy) CreateBitmap(cx, cy, 1, 1, NULL)
typedef WORD CURMASK;
#define _BitSizeOf(x) (sizeof(x)*8)

HRESULT CDragImages::_GetCursorLowerRight(HCURSOR hcursor, int * px, int * py, POINT *pptHotSpot)
{
    ICONINFO iconinfo;
    HRESULT hr = E_FAIL;
    if (GetIconInfo(hcursor, &iconinfo))
    {
        CURMASK CurMask[16*8];
        BITMAP bm;
        int i;
        int xFine = 16;

        GetObject(iconinfo.hbmMask, sizeof(bm), (LPTSTR)&bm);
        GetBitmapBits(iconinfo.hbmMask, sizeof(CurMask), CurMask);
        pptHotSpot->x = iconinfo.xHotspot;
        pptHotSpot->y = iconinfo.yHotspot;
        if (iconinfo.hbmColor) 
        {
            i = (int)(bm.bmWidth * bm.bmHeight / _BitSizeOf(CURMASK) - 1);
        } 
        else 
        {
            i = (int)(bm.bmWidth * (bm.bmHeight/2) / _BitSizeOf(CURMASK) - 1);
        }

        if ( i >= sizeof(CurMask)) 
        {
            i = sizeof(CurMask) -1;
        }

        // this assumes that the first pixel encountered on this bottom
        // up/right to left search will be reasonably close to the rightmost pixel
        // which for all of our cursors is correct, but it not necessarly correct.

        // also, it assumes the cursor has a good mask... not like the IBeam XOR only
        // cursor
        for (; i >= 0; i--)   
        {
            if (CurMask[i] != 0xFFFF) 
            {
                // this is only accurate to 16 pixels... which is a big gap..
                // so let's try to be a bit more accurate.
                int j;
                DWORD dwMask;

                for (j = 0; j < 16; j++, xFine--) 
                {
                    if (j < 8) 
                    {
                        dwMask = (1 << (8 + j));
                    } 
                    else 
                    {
                        dwMask = (1 << (j - 8));
                    }

                    if (!(CurMask[i] & dwMask))
                        break;
                }
                ASSERT(j < 16);
                break;
            }
        }

        if (iconinfo.hbmColor) 
        {
            DeleteObject(iconinfo.hbmColor);
        }

        if (iconinfo.hbmMask) 
        {
            DeleteObject(iconinfo.hbmMask);
        }

        // Compute the pointer height
        // use width in both directions because the cursor is square, but the
        // height might be doubleheight if it's mono
        *py = ((i + 1) * _BitSizeOf(CURMASK)) / (int)bm.bmWidth;
        *px = ((i * _BitSizeOf(CURMASK)) % (int)bm.bmWidth) + xFine + 2; // hang it off a little
        hr = S_OK;
    }
    return hr;
}

// this will draw iiMerge's image over iiMain on main's lower right.
BOOL CDragImages::_MergeIcons(HCURSOR hcursor, LPCTSTR idMerge, HBITMAP *phbmImage, HBITMAP *phbmMask, POINT* pptHotSpot)
{
    *phbmImage = NULL;
    *phbmMask = NULL;

    BOOL fRet = FALSE;

    int xDraw;
    int yDraw;
    // find the lower corner of the cursor and put it there.
    // do this whether or not we have an idMerge because it will set the hotspot
    if (SUCCEEDED(_GetCursorLowerRight(hcursor, &xDraw, &yDraw, pptHotSpot)))
    {
        int xBitmap;
        int yBitmap;
        int xCursor = GetSystemMetrics(SM_CXCURSOR);
        int yCursor = GetSystemMetrics(SM_CYCURSOR);
        HBITMAP hbmp;
        if (idMerge != (LPCTSTR)-1)
        {
            hbmp = (HBITMAP)LoadImage(HINST_THISDLL, idMerge, IMAGE_BITMAP, 0, 0, 0);
            if (hbmp) 
            {
                BITMAP bm;
                GetObject(hbmp, sizeof(bm), &bm);
                xBitmap = bm.bmWidth;
                yBitmap = bm.bmHeight/2;

                if (xDraw + xBitmap > xCursor)
                    xDraw = xCursor - xBitmap;
                if (yDraw + yBitmap > yCursor)
                    yDraw = yCursor - yBitmap;
            }
        }
        else
            hbmp = NULL;

        HDC hdcCursor = CreateCompatibleDC(NULL);

        HBITMAP hbmMask = CreateMonoBitmap(xCursor, yCursor);
        HBITMAP hbmImage = CreateColorBitmap(xCursor, yCursor);

        if (hdcCursor && hbmMask && hbmImage) 
        {
            HBITMAP hbmTemp = (HBITMAP)SelectObject(hdcCursor, hbmImage);
            DrawIconEx(hdcCursor, 0, 0, hcursor, 0, 0, 0, NULL, DI_NORMAL);

            HDC hdcBitmap;
            if (hbmp) 
            {
                hdcBitmap = CreateCompatibleDC(NULL);
                SelectObject(hdcBitmap, hbmp);

                //blt the two bitmaps onto the color and mask bitmaps for the cursor
                BitBlt(hdcCursor, xDraw, yDraw, xBitmap, yBitmap, hdcBitmap, 0, 0, SRCCOPY);
            }

            SelectObject(hdcCursor, hbmMask);

            DrawIconEx(hdcCursor, 0, 0, hcursor, 0, 0, 0, NULL, DI_MASK);

            if (hbmp) 
            {
                BitBlt(hdcCursor, xDraw, yDraw, xBitmap, yBitmap, hdcBitmap, 0, yBitmap, SRCCOPY);

                // select back in the old bitmaps
                SelectObject(hdcBitmap, hbmTemp);
                DeleteDC(hdcBitmap);
                DeleteObject(hbmp);
            }

            // select back in the old bitmaps
            SelectObject(hdcCursor, hbmTemp);
        }

        if (hdcCursor)
            DeleteDC(hdcCursor);

        *phbmImage = hbmImage;
        *phbmMask = hbmMask;
        fRet = (hbmImage && hbmMask);
    }
    return fRet;
}

// this will take a cursor index and load
int CDragImages::_AddCursorToImageList(HCURSOR hcur, LPCTSTR idMerge, POINT *pptHotSpot)
{
    int iIndex;
    HBITMAP hbmImage, hbmMask;

    // merge in the plus or link arrow if it's specified
    if (_MergeIcons(hcur, idMerge, &hbmImage, &hbmMask, pptHotSpot)) 
    {
        iIndex = ImageList_Add(_himlCursors, hbmImage, hbmMask);
    } 
    else 
    {
        iIndex = -1;
    }

    if (hbmImage)
        DeleteObject(hbmImage);

    if (hbmMask)
        DeleteObject(hbmMask);

    return iIndex;
}

int _MapEffectToId(DWORD dwEffect)
{
    int idCursor;

    // DebugMsg(DM_TRACE, "sh TR - DAD_GiveFeedBack dwEffect=%x", dwEffect);

    switch (dwEffect & (DROPEFFECT_COPY|DROPEFFECT_LINK|DROPEFFECT_MOVE))
    {
    case 0:
        idCursor = DCID_NO;
        break;

    case DROPEFFECT_COPY:
        idCursor = DCID_COPY;
        break;

    case DROPEFFECT_LINK:
        idCursor = DCID_LINK;
        break;

    case DROPEFFECT_MOVE:
        idCursor = DCID_MOVE;
        break;

    default:
        // if it's a right drag, we can have any effect... we'll
        // default to the arrow without merging in anything
        idCursor = DCID_MOVE;
        break;
    }

    return idCursor;
}

int CDragImages::_MapCursorIDToImageListIndex(int idCur)
{
    const static struct 
    {
        BOOL   fSystem;
        LPCTSTR idRes;
        LPCTSTR idMerge;
    } 
    c_acurmap[DCID_MAX] = 
    {
        { FALSE, MAKEINTRESOURCE(IDC_NULL), (LPCTSTR)-1},
        { TRUE, IDC_NO, (LPCTSTR)-1 },
        { TRUE, IDC_ARROW, (LPCTSTR)-1 },
        { TRUE, IDC_ARROW, MAKEINTRESOURCE(IDB_PLUS_MERGE) },
        { TRUE, IDC_ARROW, MAKEINTRESOURCE(IDB_LINK_MERGE) },
    };

    ASSERT(idCur >= -1 && idCur < (int)ARRAYSIZE(c_acurmap));

    // -1 means "Initialize the image list index array".
    if (idCur == -1)
    {
        for (int i = 0; i < ARRAYSIZE(c_acurmap); i++) 
        {
            _aindex[i] = -1;
        }
        idCur = 0;  // fall through to return -1
    }
    else
    {
        if (_aindex[idCur] == -1)
        {
            HINSTANCE hinst = c_acurmap[idCur].fSystem ? NULL : HINST_THISDLL;
            HCURSOR hcur = LoadCursor(hinst, c_acurmap[idCur].idRes);
            if (hcur)
            {
                _aindex[idCur] = _AddCursorToImageList(hcur, c_acurmap[idCur].idMerge, &_aptHotSpot[idCur]);
            }
        }
    }
    return _aindex[idCur];
}

HCURSOR CDragImages::_SetCursorHotspot(HCURSOR hcur, POINT *ptHot)
{
    ICONINFO iconinfo = { 0 };
    HCURSOR hcurHotspot;

    GetIconInfo(hcur, &iconinfo);
    iconinfo.xHotspot = ptHot->x;
    iconinfo.yHotspot = ptHot->y;
    iconinfo.fIcon = FALSE;
    hcurHotspot = (HCURSOR)CreateIconIndirect(&iconinfo);
    if (iconinfo.hbmColor) 
    {
        DeleteObject(iconinfo.hbmColor);
    }

    if (iconinfo.hbmMask) 
    {
        DeleteObject(iconinfo.hbmMask);
    }
    return hcurHotspot;
}

void CDragImages::SetDropEffectCursor(int idCur)
{
    if (_himlCursors && (idCur != -1))
    {
        if (!_ahcur[idCur])
        {
            int iIndex = _MapCursorIDToImageListIndex(idCur);
            if (iIndex != -1)
            {
                HCURSOR hcurColor = ImageList_GetIcon(_himlCursors, iIndex, 0);
                //
                // On non C1_COLORCURSOR displays, CopyImage() will enforce
                // monochrome.  So on color cursor displays, we'll get colored
                // dragdrop pix.
                //
                HCURSOR hcurScreen = (HCURSOR)CopyImage(hcurColor, IMAGE_CURSOR,
                    0, 0, LR_COPYRETURNORG | LR_DEFAULTSIZE);

                HCURSOR hcurFinal = _SetCursorHotspot(hcurScreen, &_aptHotSpot[idCur]);

                if ((hcurScreen != hcurColor) && hcurColor)
                {
                    DestroyCursor(hcurColor);
                }

                if (hcurFinal)
                {
                    if (hcurScreen)
                    {
                        DestroyCursor(hcurScreen);
                    }
                }
                else
                {
                    hcurFinal = hcurScreen;
                }

                _ahcur[idCur] = hcurFinal;
            }
        }

        if (_ahcur[idCur]) 
        {
            //
            // This code assumes that SetCursor is pretty quick if it is
            // already set.
            //
            SetCursor(_ahcur[idCur]);
        }
    }
}


//=====================================================================
// CDropSource
//=====================================================================

class CDropSource : public IDropSource
{
private:
    LONG            _cRef;
    DWORD           _grfInitialKeyState;
    IDataObject*    _pdtobj;

public:
    explicit CDropSource(IDataObject *pdtobj);
    virtual ~CDropSource();

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDropSource methods
    STDMETHODIMP GiveFeedback(DWORD dwEffect);
    STDMETHODIMP QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState);
};


void DAD_ShowCursor(BOOL fShow)
{
    static BOOL s_fCursorHidden = FALSE;

    if (fShow) 
    {
        if (s_fCursorHidden)
        {
            ShowCursor(TRUE);
            s_fCursorHidden = FALSE;
        }
    } 
    else 
    {
        if (!s_fCursorHidden)
        {
            ShowCursor(FALSE);
            s_fCursorHidden = TRUE;
        }
    }
}

CDropSource::CDropSource(IDataObject *pdtobj) : _cRef(1), _pdtobj(pdtobj), _grfInitialKeyState(0)
{
    _pdtobj->AddRef();
    
    // Tell the data object that we're entering the drag loop.
    DataObj_SetDWORD(_pdtobj, g_cfInDragLoop, 1);
}

CDropSource::~CDropSource()
{
    DAD_ShowCursor(TRUE); // just in case
    _pdtobj->Release();
}

//
// Create an instance of CDropSource
//
STDMETHODIMP CDropSource_CreateInstance(IDropSource **ppdsrc, IDataObject *pdtobj)
{
    *ppdsrc = new CDropSource(pdtobj);
    return *ppdsrc ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CDropSource::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDropSource, IDropSource),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CDropSource::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDropSource::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CDropSource::QueryContinueDrag(BOOL fEscapePressed, DWORD grfKeyState)
{
    HRESULT hr = S_OK;

    if (fEscapePressed)
    {
        hr = DRAGDROP_S_CANCEL;
    }
    else
    {
        // initialize ourself with the drag begin button
        if (_grfInitialKeyState == 0)
            _grfInitialKeyState = (grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON));

        // If the window is hung for a while, the drag operation can happen before
        // the first call to this function, so grfInitialKeyState will be 0. If this
        // happened, then we did a drop. No need to assert...
        //ASSERT(this->grfInitialKeyState);

        if (!(grfKeyState & _grfInitialKeyState))
        {
            //
            // A button is released.
            //
            hr = DRAGDROP_S_DROP;
        }
        else if (_grfInitialKeyState != (grfKeyState & (MK_LBUTTON | MK_RBUTTON | MK_MBUTTON)))
        {
            //
            //  If the button state is changed (except the drop case, which we handle
            // above, cancel the drag&drop.
            //
            hr = DRAGDROP_S_CANCEL;
        }
    }

    if (hr != S_OK)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        DAD_ShowCursor(TRUE);
        DAD_SetDragCursor(DCID_NULL);

        // Tell the data object that we're leaving the drag loop.
        if (_pdtobj)
           DataObj_SetDWORD(_pdtobj, g_cfInDragLoop, 0);
    }

    return hr;
}

STDMETHODIMP CDropSource::GiveFeedback(DWORD dwEffect)
{
    int idCursor = _MapEffectToId(dwEffect);

    //
    //  OLE does not give us DROPEFFECT_MOVE even though our IDT::DragOver
    // returns it, if we haven't set that bit when we have called DoDragDrop.
    // Instead of arguing whether or not this is a bug or by-design of OLE,
    // we work around it. It is important to note that this hack around
    // g_fDraggingOverSource is purely visual hack. It won't affect the
    // actual drag&drop operations at all (DV_AlterEffect does it all).
    //
    // - SatoNa
    //
    if (idCursor == DCID_NO && g_fDraggingOverSource)
    {
        idCursor = DCID_MOVE;
    }
    
    //
    //  No need to merge the cursor, if we are not dragging over to
    // one of shell windows.
    //
    if (DAD_IsDraggingImage())
    {
        // Feedback for single (image) dragging
        DAD_ShowCursor(FALSE);
        DAD_SetDragCursor(idCursor);
    }
    else if (DAD_IsDragging() && g_pdiDragImages)
    {
        // Feedback for multiple (rectangles) dragging
        g_pdiDragImages->SetDropEffectCursor(idCursor);
        DAD_ShowCursor(TRUE);
        return NOERROR;
    }
    else
    {
        DAD_ShowCursor(TRUE);
    }

    return DRAGDROP_S_USEDEFAULTCURSORS;
}

//=====================================================================
// DAD
//=====================================================================

void FixupDragPoint(HWND hwnd, POINT* ppt)
{
    if (hwnd)
    {
        RECT rc = {0};
        GetWindowRect(hwnd, &rc);
        ppt->x += rc.left;
        ppt->y += rc.top;
    }
}

BOOL DAD_InitDragImages()
{
    if (!g_pdiDragImages)
        CDragImages_CreateInstance(NULL, IID_IDragSourceHelper, NULL);

    return g_pdiDragImages != NULL;
}


STDAPI_(BOOL) DAD_ShowDragImage(BOOL bShow)
{
    if (DAD_InitDragImages())
        return g_pdiDragImages->Show(bShow) == S_OK ? TRUE : FALSE;
    return FALSE;
}

BOOL DAD_IsDragging()
{
    if (DAD_InitDragImages())
        return g_pdiDragImages->IsDragging();
    return FALSE;
}

void DAD_SetDragCursor(int idCursor)
{
    if (DAD_InitDragImages())
        g_pdiDragImages->SetDragCursor(idCursor);
}

STDAPI_(BOOL) DAD_DragEnterEx3(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtobj)
{
    RECT rc;
    GetWindowRect(hwndTarget, &rc);

    // If hwndTarget is RTL mirrored, then measure the
    // the client point from the visual right edge
    // (near edge in RTL mirrored windows). [samera]
    POINT pt;
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;

    pt.y = ptStart.y - rc.top;
    return DAD_DragEnterEx2(hwndTarget, pt, pdtobj);
}

STDAPI_(BOOL) DAD_DragEnterEx2(HWND hwndTarget, const POINT ptStart, IDataObject *pdtobj)
{
    BOOL bRet = FALSE;
    if (DAD_InitDragImages())
    {
        POINT pt = ptStart;
        FixupDragPoint(hwndTarget, &pt);
        bRet = SUCCEEDED(g_pdiDragImages->DragEnter(hwndTarget, pdtobj, &pt, NULL));
    }
    return bRet;
}

STDAPI_(BOOL) DAD_DragEnterEx(HWND hwndTarget, const POINT ptStart)
{
    return DAD_DragEnterEx2(hwndTarget, ptStart, NULL);
}

STDAPI_(BOOL) DAD_DragEnter(HWND hwndTarget)
{
    POINT ptStart;

    GetCursorPos(&ptStart);
    if (hwndTarget) 
        ScreenToClient(hwndTarget, &ptStart);

    return DAD_DragEnterEx(hwndTarget, ptStart);
}

STDAPI_(BOOL) DAD_DragMoveEx(HWND hwndTarget, const POINTL ptStart)
{
    RECT rc;
    GetWindowRect(hwndTarget, &rc);

    // If hwndTarget is RTL mirrored, then measure the
    // the client point from the visual right edge
    // (near edge in RTL mirrored windows). [samera]
    POINT pt;
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;

    pt.y = ptStart.y - rc.top;
    return DAD_DragMove(pt);
}


STDAPI_(BOOL) DAD_DragMove(POINT pt)
{
    if (DAD_InitDragImages())
    {
        FixupDragPoint(g_pdiDragImages->GetTarget(), &pt);
        return g_pdiDragImages->DragOver(&pt, 0);
    }
    return FALSE;
}

STDAPI_(BOOL) DAD_SetDragImage(HIMAGELIST him, POINT *pptOffset)
{
    if (DAD_InitDragImages() && !g_pdiDragImages->IsDraggingLayeredWindow())
    {
        //
        // DAD_SetDragImage(-1, NULL) means "clear the drag image only
        //  if the image is set by this thread"
        //
        if (him == (HIMAGELIST)-1)
        {
            BOOL fThisThreadHasImage = FALSE;
            ENTERCRITICAL;
            if (g_pdiDragImages->Initialized() && g_pdiDragImages->GetThread() == GetCurrentThreadId())
            {
                fThisThreadHasImage = TRUE;
            }
            LEAVECRITICAL;

            if (fThisThreadHasImage)
            {
                g_pdiDragImages->FreeDragData();
                return TRUE;
            }
            return FALSE;
        }

        return g_pdiDragImages->SetDragImage(him, 0, pptOffset);
    }

    return TRUE;
}

//
//  This function returns TRUE, if we are dragging an image. It means
// you have called either DAD_SetDragImage (with him != NULL) or
// DAD_SetDragImageFromListview.
//
BOOL DAD_IsDraggingImage(void)
{
    if (DAD_InitDragImages())
        return g_pdiDragImages->IsDraggingImage();
    return FALSE;
}


STDAPI_(BOOL) DAD_DragLeave()
{
    if (DAD_InitDragImages())
        return g_pdiDragImages->DragLeave();
    return FALSE;
}

STDAPI_(void) DAD_ProcessDetach(void)
{
    if (g_pdiDragImages)
    {
        g_pdiDragImages->ProcessDetach();
        g_pdiDragImages->Release();
    }
}

STDAPI_(void) DAD_ThreadDetach(void)
{
    if (g_pdiDragImages)
        g_pdiDragImages->ThreadDetach();
}

// called from defview on SPI_SETCURSORS (user changed the system cursors)
STDAPI_(void) DAD_InvalidateCursors(void)
{
    g_cRev++;
}

STDAPI_(BOOL) DAD_SetDragImageFromWindow(HWND hwnd, POINT* ppt, IDataObject* pdtobj)
{
    if (DAD_InitDragImages())
        return S_OK == g_pdiDragImages->InitializeFromWindow(hwnd, ppt, pdtobj);
    return FALSE;
}

// shell32.dll export, but only used by print queue window code
//
STDAPI_(BOOL) DAD_SetDragImageFromListView(HWND hwndLV, POINT ptOffset)
{
    // really a nop, as this does not have access to the data object
    return DAD_InitDragImages();
}

// wrapper around OLE DoDragDrop(), will create drag source on demand and supports
// drag images for you

STDAPI SHDoDragDrop(HWND hwnd, IDataObject *pdtobj, IDropSource *pdsrc, DWORD dwEffect, DWORD *pdwEffect)
{
    IDropSource *pdsrcRelease = NULL;

    if (pdsrc == NULL)
    {
        CDropSource_CreateInstance(&pdsrcRelease, pdtobj);
        pdsrc = pdsrcRelease;
    }

    // if there is no drag contents clipboard format present, try to add it
    FORMATETC fmte = {_GetDragContentsCF(), NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM};
    if (S_OK != pdtobj->QueryGetData(&fmte))
    {
        if (DAD_InitDragImages())
            g_pdiDragImages->InitializeFromWindow(hwnd, NULL, pdtobj);
    }

    HRESULT hr = DoDragDrop(pdtobj, pdsrc, dwEffect, pdwEffect);

    if (pdsrcRelease)
        pdsrcRelease->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\dll.cpp ===
/***************************************************************************
 *  dll.c
 *
 *  Standard DLL entry-point functions 
 *
 ***************************************************************************/

#include "shellprv.h"

#include <ntpsapi.h>        // for NtQuery
#include <ntverp.h>
#include <advpub.h>         // For REGINSTALL
#include "fstreex.h"
#include "ids.h"
#include "filefldr.h"
#include "uemapp.h"

#define DECL_CRTFREE
#include <crtfree.h>


void DoFusion();
STDAPI_(void) Control_FillCache_RunDLL( HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow );
BOOL    CopyRegistryValues (HKEY hKeyBaseSource, LPCTSTR pszSource, HKEY hKeyBaseTarget, LPCTSTR pszTarget);

// DllGetVersion - New for IE 4.0 shell integrated mode
//
// All we have to do is declare this puppy and CCDllGetVersion does the rest
//
DLLVER_DUALBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);

HRESULT CallRegInstall(LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");
        if (pfnri)
        {
            char szShdocvwPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "SHDOCVW_PATH", szShdocvwPath },
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            // Get the location of shdocvw.dll
            StrCpyNA(szShdocvwPath, "%SystemRoot%\\system32", ARRAYSIZE(szShdocvwPath));
            if (PathAppendA(szShdocvwPath, "shdocvw.dll"))
            {
                hr = pfnri(g_hinst, szSection, &stReg);
            }
        }
        // since we only do this from DllInstall() don't load and unload advpack over and over
        // FreeLibrary(hinstAdvPack);
    }
    return hr;
}

BOOL UnregisterTypeLibrary(const CLSID* piidLibrary)
{
    TCHAR szScratch[GUIDSTR_MAX];
    HKEY hk;
    BOOL f = FALSE;

    // convert the libid into a string.
    //
    SHStringFromGUID(*piidLibrary, szScratch, ARRAYSIZE(szScratch));

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("TypeLib"), 0, KEY_ALL_ACCESS, &hk) == ERROR_SUCCESS) 
    {
        f = RegDeleteKey(hk, szScratch);
        RegCloseKey(hk);
    }
    
    return f;
}

HRESULT Shell32RegTypeLib(void)
{
    TCHAR szPath[MAX_PATH];
    WCHAR wszPath[MAX_PATH];

    // Load and register our type library.
    //
    GetModuleFileName(HINST_THISDLL, szPath, ARRAYSIZE(szPath));
    SHTCharToUnicode(szPath, wszPath, ARRAYSIZE(wszPath));

    ITypeLib *pTypeLib;
    HRESULT hr = LoadTypeLib(wszPath, &pTypeLib);
    if (SUCCEEDED(hr))
    {
        // call the unregister type library as we had some old junk that
        // was registered by a previous version of OleAut32, which is now causing
        // the current version to not work on NT...
        UnregisterTypeLibrary(&LIBID_Shell32);
        hr = RegisterTypeLib(pTypeLib, wszPath, NULL);
        if (FAILED(hr))
        {
            TraceMsg(TF_WARNING, "SHELL32: RegisterTypeLib failed (%x)", hr);
        }
        pTypeLib->Release();
    }
    else
    {
        TraceMsg(TF_WARNING, "SHELL32: LoadTypeLib failed (%x)", hr);
    }

    return hr;
}

STDAPI CreateShowDesktopOnQuickLaunch()
{
    // delete the "_Current Item" key used for tip rotation in welcome.exe on every upgrade
    HKEY hkey;
    if ( ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Setup\\Welcome"), 0, MAXIMUM_ALLOWED, &hkey ) )
    {
       RegDeleteValue(hkey, TEXT("_Current Item"));
       RegCloseKey(hkey);
    }

    // create the "Show Desktop" icon in the quick launch tray
    TCHAR szPath[MAX_PATH];
    if ( SHGetSpecialFolderPath(NULL, szPath, CSIDL_APPDATA, TRUE) )
    {
        TCHAR szQuickLaunch[MAX_PATH];
        LoadString(g_hinst, IDS_QUICKLAUNCH, szQuickLaunch, ARRAYSIZE(szQuickLaunch));

        if ( PathAppend( szPath, szQuickLaunch ) )
        {
            WritePrivateProfileSection( TEXT("Shell"), TEXT("Command=2\0IconFile=explorer.exe,3\0"), szPath );
            WritePrivateProfileSection( TEXT("Taskbar"), TEXT("Command=ToggleDesktop\0"), szPath );

            return S_OK;
        }
    }

    return E_FAIL;
}

void _DoMyDocsPerUserInit(void)
{
    // mydocs!PerUserInit is invoked to setup the desktop.ini and do all the other work
    // required to make this correct.
    HINSTANCE hInstMyDocs = LoadLibrary(TEXT("mydocs.dll"));
    if (hInstMyDocs != NULL)
    {
        typedef void (*PFNPerUserInit)(void);
        PFNPerUserInit pfnPerUserInit = (PFNPerUserInit)GetProcAddress(hInstMyDocs, "PerUserInit");
        if (pfnPerUserInit)
        {
            pfnPerUserInit();
        }
        FreeLibrary(hInstMyDocs);
    }
}

void _NoDriveAutorunTweak()
{
    HKEY hkey;
    DWORD dwDisp;

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER,
        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"),
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_SET_VALUE, NULL, &hkey, &dwDisp))
    {
        DWORD dwRest;
        DWORD cbSize = sizeof(dwRest);

        if (ERROR_SUCCESS != RegQueryValueEx(hkey, TEXT("NoDriveTypeAutoRun"), NULL, NULL,
            (PBYTE)&dwRest, &cbSize))
        {
            dwRest = 0;
        }

        if ((0x95 == dwRest) || (0 == dwRest))
        {
            // Did not change or is not there, let's put 0x91

            dwRest = 0x91;

            RegSetValueEx(hkey, TEXT("NoDriveTypeAutoRun"), 0, REG_DWORD, (PBYTE)&dwRest, sizeof(dwRest));
        }
        else
        {
            // Did change, leave it as is
        }

        RegCloseKey(hkey);
    }
}

// code moved from grpconv.exe

// we'd much rather have new firm links than old floppy ones
// clear out any old ones made by previous runs of setup
void _DeleteOldFloppyLinks(LPITEMIDLIST pidlSendTo, IPersistFile *ppf, IShellLink *psl)
{
    IShellFolder *psfSendTo;
    if (SUCCEEDED(SHBindToObjectEx(NULL, pidlSendTo, NULL, IID_PPV_ARG(IShellFolder, &psfSendTo))))
    {
        IEnumIDList *penum;
        if (SUCCEEDED(psfSendTo->EnumObjects(NULL, SHCONTF_NONFOLDERS, &penum)))
        {
            LPITEMIDLIST pidl;
            ULONG celt;
            while (penum->Next(1, &pidl, &celt) == S_OK)
            {
                // is it a link???
                if (SHGetAttributes(psfSendTo, pidl, SFGAO_LINK))
                {
                    // get the target
                    LPITEMIDLIST pidlFullPath = ILCombine(pidlSendTo, pidl);
                    if (pidlFullPath)
                    {
                        WCHAR szPath[MAX_PATH];
                        if (SHGetPathFromIDList(pidlFullPath, szPath) &&
                            SUCCEEDED(ppf->Load(szPath, 0)))
                        {
                            LPITEMIDLIST pidlTarget;
                            if (SUCCEEDED(psl->GetIDList(&pidlTarget)))
                            {
                                TCHAR szTargetPath[MAX_PATH];
                                // its possible for the old drive letters to have changed.  for example if you
                                // move a removable drive from M:\ to N:\, the shortcut will be invalid, so
                                // we check against DRIVE_NO_ROOT_DIR.
                                // unfortunately we can't tell if we should remove it if they used to have a zip
                                // drive on D:\, and then upgraded and it turned into a hard drive on D:\.  the
                                // shortcut will resolve as DRIVE_FIXED and we dont remove it because they might
                                // have created a shortcut to the fixed drive before the upgrade.
                                if (SHGetPathFromIDList(pidlTarget, szTargetPath) &&
                                    PathIsRoot(szTargetPath) &&
                                    ((DriveType(PathGetDriveNumber(szTargetPath)) == DRIVE_REMOVABLE) ||
                                     (DriveType(PathGetDriveNumber(szTargetPath)) == DRIVE_NO_ROOT_DIR)))
                                {
                                    Win32DeleteFile(szPath);
                                }
                                ILFree(pidlTarget);
                            }
                        }
                        ILFree(pidlFullPath);
                    }
                }
                ILFree(pidl);
            }
            penum->Release();
        }
        psfSendTo->Release();
    }
}

void _DeleteOldRemovableLinks()
{
    IShellLink *psl;
    if (SUCCEEDED(CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLink, &psl))))
    {
        IPersistFile *ppf;
        if (SUCCEEDED(psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))) )
        {
            LPITEMIDLIST pidlSendTo = SHCloneSpecialIDList(NULL, CSIDL_SENDTO, TRUE);
            if (pidlSendTo)
            {
                // we no longer build a list of removable drives here, since that's done on the fly
                // by the sendto menu.  just delete any links that we owned before.
                _DeleteOldFloppyLinks(pidlSendTo, ppf, psl);
                ILFree(pidlSendTo);
            }
            ppf->Release();
        }
        psl->Release();
    }
}

static const struct
{
    PCWSTR pszExt;
}
_DeleteSendToList[] =
{
    // make sure these extensions are definitely owned by us, since we're deleting all of them.
    { L".cdburn" },          // clean up after XP beta2 upgrade
    { L".publishwizard" }    // clean up after XP beta1 upgrade
};

void _DeleteSendToEntries()
{
    TCHAR szSendTo[MAX_PATH];
    if (SUCCEEDED(SHGetFolderPath(NULL, CSIDL_SENDTO, NULL, 0, szSendTo)))
    {
        for (int i = 0; i < ARRAYSIZE(_DeleteSendToList); i++)
        {
            TCHAR szSearch[MAX_PATH];
            StrCpyN(szSearch, szSendTo, ARRAYSIZE(szSearch));
            if (PathAppend(szSearch, TEXT("*")))
            {
                HRESULT hr = StringCchCat(szSearch, ARRAYSIZE(szSearch), _DeleteSendToList[i].pszExt);

                if (SUCCEEDED(hr))
                {
                    WIN32_FIND_DATA fd;
                    HANDLE hfind = FindFirstFile(szSearch, &fd);
                    if (hfind != INVALID_HANDLE_VALUE)
                    {
                        do
                        {
                            TCHAR szFile[MAX_PATH];
                            StrCpyN(szFile, szSendTo, ARRAYSIZE(szFile));
                            if (PathAppend(szFile, fd.cFileName))
                            {
                                DeleteFile(szFile);
                            }
                        } while (FindNextFile(hfind, &fd));
                        FindClose(hfind);
                    }
                }
            }
        }
    }

    // next kill old removable drives
    _DeleteOldRemovableLinks();
}

DWORD _GetProcessorSpeed()  // in MHz
{
    static DWORD s_dwSpeed = 0;
    if (s_dwSpeed == 0)
    {
        DWORD cb = sizeof(s_dwSpeed);
        SHGetValue(HKEY_LOCAL_MACHINE, TEXT("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0"),
                    TEXT("~MHz"), NULL, &s_dwSpeed, &cb);
        s_dwSpeed += 1; // fudge factor, my 400 Mhz machine reports 399
    }
    return s_dwSpeed;
}

DWORD _GetPhysicalMemory() // in MBs
{
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION    BasicInfo;

    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
             );

    if (NT_SUCCESS(Status))
    {
        return ((BasicInfo.NumberOfPhysicalPages * BasicInfo.PageSize) / (1024 * 1024)) + 1; // fudge factor, my 256 Meg machine reports 255
    }
    else
    {
        return 64;      // Default to 64 Meg (something lame, so that we turn a bunch of stuff off)
    }
}

const TCHAR g_cszLetters[] = TEXT("The Quick Brown Fox Jumped Over The Lazy Dog");

BOOL _PerfTestSmoothFonts(void)
{
    int cchLength = lstrlen(g_cszLetters);
    HDC hdc;
    LOGFONT lf;
    HFONT hfont;
    HFONT hfontOld;
    int bkmodeOld;
    int iIter;
    int iIter2;
    int iIter3;
    LARGE_INTEGER liFrequency;
    LARGE_INTEGER liStart;
    LARGE_INTEGER liStop;
    LARGE_INTEGER liTotal;
    COLORREF colorref;
    SIZE size;
    DOUBLE eTime[2];
    BYTE lfQuality[2];

    HDC hdcScreen = GetDC(NULL);
    hdc = CreateCompatibleDC(hdcScreen);
    HBITMAP hbm = CreateCompatibleBitmap(hdcScreen,200,20);
    HBITMAP hbmOld = (HBITMAP)SelectObject(hdc,hbm);
    ReleaseDC(NULL,hdcScreen);

    bkmodeOld = SetBkMode(hdc, TRANSPARENT);

    QueryPerformanceFrequency( &liFrequency );

    lfQuality[0] = NONANTIALIASED_QUALITY;
    lfQuality[1] = ANTIALIASED_QUALITY;

    memset(&lf,0,sizeof(lf));
    StrCpyN(lf.lfFaceName, TEXT("Arial"), ARRAYSIZE(lf.lfFaceName));
    lf.lfWeight = FW_BOLD;

    for (iIter3 = 0; iIter3 < 2; iIter3++)
    {
        liTotal.QuadPart = 0;

        for (iIter2 = 0; iIter2 < 5; iIter2++)
        {
            //
            // First, Flush the constructed font cache
            //
            for (iIter = 0; iIter < 64; iIter++)
            {
                lf.lfHeight = -14-iIter;      // 10+ pt
                lf.lfQuality = NONANTIALIASED_QUALITY;

                hfont = CreateFontIndirect(&lf);
                hfontOld = (HFONT)SelectObject(hdc, hfont);

                TextOut(hdc, 0, 0, g_cszLetters, cchLength);

                SelectObject(hdc, hfontOld);
                DeleteObject(hfont);
            }
            GdiFlush();
            colorref = GetPixel(hdc,0,0);

            //
            // Now measure how long it takes to construct and use a this font
            //
            lf.lfHeight = -13;             // 10 pt
            lf.lfQuality = lfQuality[iIter3];

            QueryPerformanceCounter( &liStart );
            hfont = CreateFontIndirect(&lf);
            hfontOld = (HFONT)SelectObject(hdc, hfont);

            for (iIter = 0; iIter < 10; iIter++)
            {
                TextOut(hdc, 0, 0, g_cszLetters, cchLength);
            }

            GdiFlush();
            colorref = GetPixel(hdc,0,0);

            QueryPerformanceCounter( &liStop );
            liTotal.QuadPart += liStop.QuadPart - liStart.QuadPart;

            GetTextExtentPoint(hdc, g_cszLetters, cchLength, &size);

            SelectObject(hdc, hfontOld);
            DeleteObject(hfont);

        }

        eTime[iIter3] = (double)liTotal.QuadPart / (double)liFrequency.QuadPart;
    }

    SetBkMode(hdc, bkmodeOld);

    SelectObject(hdc,hbmOld);
    DeleteObject(hbm);
    DeleteDC(hdc);

    return (eTime[1]/eTime[0] <= 4.0);
}

BOOL _PerfTestAlphaLayer(void)
{
    DOUBLE eTime = 100.0;         // 100 is too large to enable features
    int cx = 200;
    int cy = 500;

    LARGE_INTEGER liFrequency;
    QueryPerformanceFrequency( &liFrequency );

    BITMAPINFO bmi;
    memset(&bmi, 0, sizeof(bmi));
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = cx;
    bmi.bmiHeader.biHeight = cy;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    //
    // Create the image we want to alpha blend onto the screen
    //
    HDC hdcScreen = GetDC(NULL);
    HDC hdcImage = CreateCompatibleDC(NULL);
    if (hdcImage != NULL)
    {
        PVOID pbits;
        HBITMAP hbmImage = CreateDIBSection(hdcImage, &bmi, DIB_RGB_COLORS,
                                     &pbits, NULL, NULL);
        if (hbmImage != NULL)
        {
            HBITMAP hbmOld = (HBITMAP)SelectObject(hdcImage, hbmImage);

            BitBlt(hdcImage, 0, 0, cx, cy, hdcScreen, 0, 0, SRCCOPY);

            if (pbits != NULL)
            {
                RGBQUAD *prgb = (RGBQUAD *)pbits;
                for (int y = 0; y < cy; y++)
                {
                    for (int x = 0; x < cx; x++)
                    {
                        BYTE color_r;
                        BYTE color_g;
                        BYTE color_b;

                        color_r = prgb->rgbRed;
                        color_g = prgb->rgbBlue;
                        color_b = prgb->rgbGreen;

                        color_r = color_r / 2;
                        color_g = color_g / 2;
                        color_b = color_b / 2;

                        prgb->rgbRed   = color_r;
                        prgb->rgbBlue  = color_g;
                        prgb->rgbGreen = color_b;
                        prgb->rgbReserved = 0x80;

                        prgb++;
                    }
                }
            }

            HWND hwnd1 = CreateWindowEx( WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TOOLWINDOW,
                    TEXT("Button"),
                    TEXT("Windows XP"),
                    WS_POPUPWINDOW,
                    0, 0,
                    cx, cy,
                    NULL, NULL,
                    0,
                    NULL);

            HWND hwnd2 = CreateWindowEx( WS_EX_TRANSPARENT | WS_EX_TOPMOST | WS_EX_LAYERED | WS_EX_TOOLWINDOW,
                    TEXT("Button"),
                    TEXT("Windows XP"),
                    WS_POPUPWINDOW,
                    0, 0,
                    cx, cy,
                    NULL, NULL,
                    0,
                    NULL);

            if (hwnd1 != NULL && hwnd2 != NULL)
            {
                SetWindowPos(hwnd1, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);
                SetWindowPos(hwnd2, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);

                BLENDFUNCTION blend;
                blend.BlendOp = AC_SRC_OVER;
                blend.BlendFlags = 0;
                blend.SourceConstantAlpha = 0xFF;
                blend.AlphaFormat = AC_SRC_ALPHA;

                HDC hdc1 = GetDC(hwnd1);
                HDC hdc2 = GetDC(hwnd2);
                POINT ptSrc;
                SIZE size;
                ptSrc.x = 0;
                ptSrc.y = 0;
                size.cx = cx;
                size.cy = cy;

                COLORREF colorref;
                LARGE_INTEGER liStart;
                LARGE_INTEGER liStop;
                LARGE_INTEGER liTotal;

                GdiFlush();
                colorref = GetPixel(hdc1,0,0);
                colorref = GetPixel(hdc2,0,0);
                colorref = GetPixel(hdcScreen,0,0);
                QueryPerformanceCounter( &liStart );

                for (int iIter = 0; iIter < 10; iIter++)
                {
                    UpdateLayeredWindow(hwnd1, hdc1, NULL, &size,
                                              hdcImage, &ptSrc, 0,
                                              &blend, ULW_ALPHA);
                    UpdateLayeredWindow(hwnd2, hdc2, NULL, &size,
                                              hdcImage, &ptSrc, 0,
                                              &blend, ULW_ALPHA);
                }

                GdiFlush();
                colorref = GetPixel(hdc1,0,0);
                colorref = GetPixel(hdc2,0,0);
                colorref = GetPixel(hdcScreen,0,0);
                QueryPerformanceCounter( &liStop );
                liTotal.QuadPart = liStop.QuadPart - liStart.QuadPart;

                eTime = ((DOUBLE)liTotal.QuadPart * 1000.0) / (DOUBLE)liFrequency.QuadPart;
                eTime = eTime / 10.0;

                ReleaseDC(hwnd1, hdc1);
                ReleaseDC(hwnd2, hdc2);

            }

            if (hwnd1)
            {
                DestroyWindow(hwnd1);
            }
            if (hwnd2)
            {
                DestroyWindow(hwnd2);
            }

            SelectObject(hdcImage,hbmOld);
            DeleteObject(hbmImage);
        }
        DeleteDC(hdcImage);
    }

    ReleaseDC(NULL, hdcScreen);

    return (eTime <= 75.0);
}

BOOL g_fPerfFont = FALSE;
BOOL g_fPerfAlpha = FALSE;

#define VISUALEFFECTS_KEY      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VisualEffects")

#define VISUALEFFECTS_CHECK     TEXT("CheckedValue")
#define VISUALEFFECTS_UNCHECK   TEXT("UncheckedValue")
#define VISUALEFFECTS_DEFAULT   TEXT("DefaultValue")
#define VISUALEFFECTS_APPLIED   TEXT("DefaultApplied")
#define VISUALEFFECTS_MINCPU    TEXT("MinimumCPU")
#define VISUALEFFECTS_MINMEM    TEXT("MinimumMEM")
#define VISUALEFFECTS_FONT      TEXT("DefaultByFontTest")
#define VISUALEFFECTS_ALPHA     TEXT("DefaultByAlphaTest")

#define VISUALEFFECTS_VER   1

void _ApplyDefaultVisualEffect(HKEY hkey, HKEY hkeyUser)
{
    //
    // blow this off completely on TS client to avoid stepping
    // on TS client's toes
    //
    if (!IsOS(OS_TERMINALCLIENT))
    {
        DWORD cb;
        DWORD dwDefaultApplied = 0;

        if (0 != hkeyUser)
        {
            cb = sizeof(dwDefaultApplied);
            RegQueryValueEx(hkeyUser, VISUALEFFECTS_APPLIED, NULL, NULL, (LPBYTE)&dwDefaultApplied, &cb);
        }

        //
        // Apply defaults only if the version number is old
        //
        if (VISUALEFFECTS_VER > dwDefaultApplied)
        {
            LPTSTR pszValue = NULL;     // use the default value
            DWORD dwMinimumCPU = 0;
            DWORD dwMinimumMEM = 0;
            BOOL fFontTestDefault = FALSE;
            BOOL fAlphaTestDefault = FALSE;

            //
            // see if a minimum physical memory value is specified
            //
            cb = sizeof(dwMinimumMEM);
            RegQueryValueEx(hkey, VISUALEFFECTS_MINMEM, NULL, NULL, (LPBYTE)&dwMinimumMEM, &cb);

            //
            // see if a minimum CPU speed is specified
            //
            cb = sizeof(dwMinimumCPU);
            RegQueryValueEx(hkey, VISUALEFFECTS_MINCPU, NULL, NULL, (LPBYTE)&dwMinimumCPU, &cb);

            //
            // see if the font performance test value is needed
            //
            cb = sizeof(fFontTestDefault);
            RegQueryValueEx(hkey, VISUALEFFECTS_FONT, NULL, NULL, (LPBYTE)&fFontTestDefault, &cb);

            //
            // see if the alpha performance test value is needed
            //
            cb = sizeof(fAlphaTestDefault);
            RegQueryValueEx(hkey, VISUALEFFECTS_ALPHA, NULL, NULL, (LPBYTE)&fAlphaTestDefault, &cb);


            if (   dwMinimumCPU > 0
                || dwMinimumMEM > 0
                || fFontTestDefault
                || fAlphaTestDefault)
            {
                pszValue = VISUALEFFECTS_CHECK;

                if (_GetProcessorSpeed() < dwMinimumCPU)
                {
                    pszValue = VISUALEFFECTS_UNCHECK;
                }
                if (_GetPhysicalMemory() < dwMinimumMEM)
                {
                    pszValue = VISUALEFFECTS_UNCHECK;
                }
                if (fFontTestDefault && !g_fPerfFont)
                {
                    pszValue = VISUALEFFECTS_UNCHECK;
                }
                if (fAlphaTestDefault && !g_fPerfAlpha)
                {
                    pszValue = VISUALEFFECTS_UNCHECK;
                }
            }

            if (IsOS(OS_ANYSERVER))
            {
                //
                // on server, we default to best performance (*everything* off)
                //
                pszValue = VISUALEFFECTS_UNCHECK;
            }

            DWORD dwValue = 0;
            cb = sizeof(dwValue);

            if (pszValue)
            {
                //
                // set the default according to the chosen value
                //
                RegQueryValueEx(hkey, pszValue, NULL, NULL, (LPBYTE)&dwValue, &cb);

                //
                // when figuring out settings that need to adjust the default
                // value the VISUALEFFECTS_DEFAULT value must be re-applied
                // to the per-user key.
                //
                if (0 != hkeyUser)
                {
                    RegSetValueEx(hkeyUser, VISUALEFFECTS_DEFAULT, 0, REG_DWORD, (LPBYTE)&dwValue, sizeof(dwValue));
                }
            }
            else
            {
                //
                // read in the default value
                //
                RegQueryValueEx(hkey, VISUALEFFECTS_DEFAULT, NULL, NULL, (LPBYTE)&dwValue, &cb);
            }

            //
            // how do we apply this setting?
            //
            DWORD uiAction;
            TCHAR szBuf[MAX_PATH];

            if (cb = sizeof(szBuf),
                ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("CLSID"), NULL, NULL, (LPBYTE)&szBuf, &cb))
            {
                //
                // by CLSID
                //
                CLSID clsid;
                GUIDFromString(szBuf, &clsid);

                IRegTreeItem* pti;
                if (SUCCEEDED(CoCreateInstance(clsid, NULL, (CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER), IID_PPV_ARG(IRegTreeItem, &pti))))
                {
                    pti->SetCheckState(dwValue);
                    pti->Release();
                }
            }
            else if (cb = sizeof(uiAction),
                ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("SPIActionSet"), NULL, NULL, (LPBYTE)&uiAction, &cb))
            {
                //
                // by SPI
                //
                SHBoolSystemParametersInfo(uiAction, &dwValue);
            }
            else if (cb = sizeof(szBuf),
                ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("RegPath"), NULL, NULL, (LPBYTE)&szBuf, &cb))
            {
                //
                // by reg key
                //
                TCHAR szValueName[96];
                cb = sizeof(szValueName);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("ValueName"), NULL, NULL, (LPBYTE)&szValueName, &cb))
                {
                    SHSetValue(HKEY_CURRENT_USER, szBuf, szValueName, REG_DWORD, &dwValue, sizeof(dwValue));
                }
            }

            if (0 != hkeyUser)
            {
                dwDefaultApplied = VISUALEFFECTS_VER;
                RegSetValueEx(hkeyUser, VISUALEFFECTS_APPLIED, 0, REG_DWORD, (LPBYTE)&dwDefaultApplied, sizeof(dwDefaultApplied));
            }
        }
    }
}

void _DefaultVisualEffects(void)
{
    HKEY hkeyUser;
    DWORD dw;

    g_fPerfFont = _PerfTestSmoothFonts();
    g_fPerfAlpha = _PerfTestAlphaLayer();

    if (ERROR_SUCCESS == RegCreateKeyExW(HKEY_CURRENT_USER, VISUALEFFECTS_KEY, 0, TEXTW(""), 0, KEY_SET_VALUE,
                        NULL, &hkeyUser, &dw))
    {
        HKEY hkey;
        REGSAM samDesired = KEY_READ;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, VISUALEFFECTS_KEY, 0, samDesired, &hkey))
        {
            TCHAR szName[96];
            for (int i = 0; ERROR_SUCCESS == RegEnumKey(hkey, i, szName, ARRAYSIZE(szName)); i++)
            {
                HKEY hkeyUserItem;

                if (ERROR_SUCCESS == RegCreateKeyExW(hkeyUser, szName, 0, TEXTW(""), 0, KEY_QUERY_VALUE | KEY_SET_VALUE,
                                    NULL, &hkeyUserItem, &dw))
                {
                    HKEY hkeyItem;
                    if (ERROR_SUCCESS == RegOpenKeyEx(hkey, szName, 0, samDesired, &hkeyItem))
                    {
                        // only apply the default for the setting if the "NoApplyDefault" reg value is NOT present
                        if (RegQueryValueEx(hkeyItem, TEXT("NoApplyDefault"), NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
                        {
                            _ApplyDefaultVisualEffect(hkeyItem, hkeyUserItem);
                        }

                        RegCloseKey(hkeyItem);
                    }

                    RegCloseKey(hkeyUserItem);
                }
            }
            RegCloseKey(hkey);
        }
        RegCloseKey(hkeyUser);
    }
}

STDAPI CDeskHtmlProp_RegUnReg(BOOL bInstall);
STDAPI_(BOOL) ApplyRegistrySecurity();
STDAPI_(void) FixPlusIcons();
STDAPI_(void) CleanupFileSystem();
STDAPI_(void) InitializeSharedDocs(BOOL fOnWow64);

#define KEEP_FAILURE(hrSum, hrLast) if (FAILED(hrLast)) hrSum = hrLast;

#ifdef _WIN64
// On IA64 machines we need to copy the EULA file (eula.txt) from %SytemRoot%\System32, to
// %SystemRoot%\SysWOW64. This is needed because when you do help|about on a 32-bit app running
// under wow64 it will look in the syswow64 directory for the file.
//
// Why is shell32.dll doing this and not setup you might ask? The EULA has to be installed by textmode
// since it is unsigned (and changes for every sku). Since txtmode setup does a MOVE instead of a copy, we
// cannot have it installed into two places. Thus the easies thing to do is to simply copy the file
// from the System32 directory to the SysWOW64 directory here. Sigh.

BOOL CopyEULAForWow6432()
{
    BOOL bRet = FALSE;
    TCHAR szEULAPath[MAX_PATH];
    TCHAR szWow6432EULAPath[MAX_PATH];

    if (GetSystemWindowsDirectory(szEULAPath, ARRAYSIZE(szEULAPath)))
    {
        StrCpyN(szWow6432EULAPath, szEULAPath, ARRAYSIZE(szWow6432EULAPath));
        
        if (PathAppend(szEULAPath, TEXT("System32\\eula.txt")) &&
            PathAppend(szWow6432EULAPath, TEXT("SysWOW64\\eula.txt")))
        {
            // now we have the source (%SystemRoot%\System32\eula.txt) and dest (%SystemRoot%\SysWOW64\eula.txt)
            // paths, lets do the copy!
            
            bRet = CopyFile(szEULAPath, szWow6432EULAPath, FALSE);
        }
    }

    return bRet;
}
#endif  // _WIN64    


//
// Upgrades from Win9x are internally handled by setup as "clean" installs followed by some
// migration of settings. So, the following function does the job of truly detecting a win9x
// upgrade.
// The way it detects: Look in %windir%\system32\$winnt$.inf in the section [Data] 
// for Win9xUpgrade=Yes if it is a Win9x upgrade.
//
BOOL IsUpgradeFromWin9x()
{
    TCHAR szFilePath[MAX_PATH];
    TCHAR szYesOrNo[10];
    
    GetSystemDirectory(szFilePath, ARRAYSIZE(szFilePath));
    if (PathAppend(szFilePath, TEXT("$WINNT$.INF")))
    {
        GetPrivateProfileString(TEXT("Data"),           // Section name.
                                TEXT("Win9xUpgrade"),   // Key name.
                                TEXT("No"),             // Default string, if key is missing.
                                szYesOrNo, 
                                ARRAYSIZE(szYesOrNo), 
                                szFilePath);            // Full path to "$winnt$.inf" file.
    }
    else
    {
        szYesOrNo[0] = _T('\0');
    }

    return (0 == lstrcmpi(szYesOrNo, TEXT("Yes")));
}

BOOL IsCleanInstallInProgress()
{
   LPCTSTR szKeyName = TEXT("SYSTEM\\Setup");
   HKEY hKeySetup;
   BOOL fCleanInstall = FALSE;

   if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, szKeyName, 0,
                     KEY_READ, &hKeySetup) == ERROR_SUCCESS) 
   {
        DWORD dwSize;
        LONG lResult;
        DWORD dwSystemSetupInProgress = 0;
        
        dwSize = sizeof(DWORD);
        lResult = RegQueryValueEx (hKeySetup, TEXT("SystemSetupInProgress"), NULL,
                                  NULL, (LPBYTE) &dwSystemSetupInProgress, &dwSize);

        if (lResult == ERROR_SUCCESS) 
        {
            DWORD dwMiniSetupInProgress = 0; 
            dwSize = sizeof(DWORD);
            RegQueryValueEx (hKeySetup, TEXT("MiniSetupInProgress"), NULL,
                                      NULL, (LPBYTE) &dwMiniSetupInProgress, &dwSize);
                                      
            if(dwSystemSetupInProgress && !dwMiniSetupInProgress)
            {
                DWORD dwUpgradeInProgress = 0;
                dwSize = sizeof(DWORD);
                //Setup is in progress and MiniSetup is NOT in progress.
                //That means that we are in the GUI mode of setup!

                //On clean installs, this value won't be there and the following call will fail.
                RegQueryValueEx (hKeySetup, TEXT("UpgradeInProgress"), NULL,
                                          NULL, (LPBYTE) &dwUpgradeInProgress, &dwSize);

                fCleanInstall = !dwUpgradeInProgress;
            }
        }
        RegCloseKey (hKeySetup);
    }

    if(fCleanInstall)
    {
        // Caution: An upgrade from Win9x is internally done by setup as a "clean" install.
        // So, we need to figure out if this is really a clean install or an upgrade from 
        // win9x.
        
        fCleanInstall = !IsUpgradeFromWin9x();
    }
    
    return fCleanInstall ;
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hrTemp, hr = S_OK;
    BOOL fServerAdmin = FALSE;

    // 99/05/03 vtan: If you're reading this section then you are considering
    // adding code to the registration/installation of shell32.dll. There are
    // now 3 schemes to accomplish this task:

    // 1. IE4UINIT.EXE
    //      Check HKLM\Software\Microsoft\Active Setup\Installed Components\{89820200-ECBD-11cf-8B85-00AA005B4383}
    //      This says that if there is a new version of IE5 to launch ie4uinit.exe.
    //      You can add code to this executable if you wish. You need to enlist in
    //      the setup project on \\trango\slmadd using "ieenlist setup"

    // 2. REGSVR32.EXE /n /i:U shell32.dll
    //      Check HKLM\Software\Microsoft\Active Setup\Installed Components\{89820200-ECBD-11cf-8B85-00AA005B4340}
    //      This is executed using the same scheme as IE4UINIT.EXE except that the
    //      executable used is regsvr32.exe with a command line passed to
    //      shell32!DllInstall. Add your code in the section for "U" below.
    //      If you put the code in the section which is NOT "U" then your
    //      code is executed at GUI setup and any changes you make to HKCU
    //      go into the default user (template). Be careful when putting
    //      things here as winlogon.exe (or some other process) may put
    //      your changes into a user profile unconditionally.

    // 3. HIVEUSD.INX
    //      Checks NT build numbers and does command based on the previous build
    //      number and the current build number only executing the changes between
    //      the builds. If you wish to add something using this method, currently
    //      you have to enlist in the setup project on \\rastaman\ntwin using
    //      "enlist -fgs \\rastaman\ntwin -p setup". To find hiveusd.inx go to
    //      nt\private\setup\inf\win4\inf. Add the build number which the delta
    //      is required and a command to launch %SystemRoot%\System32\shmgrate.exe
    //      with one or two parameters. The first parameter tells what command to
    //      execute. The second parameter is optional. shmgrate.exe then finds
    //      shell32.dll and calls shell32!FirstUserLogon. Code here is for upgrading
    //      HKCU user profiles from one NT build to another NT build.
    //      Code is executed in the process context shmgrate.exe and is executed
    //      at a time where no UI is possible. Always use HKLM\Software\Microsoft
    //      \Windows NT\CurrentVersion\Image File Execution Options\Debugger with
    //      "-d".

    // Schemes 1 and 2 work on either Win9x or WinNT but have the sometimes
    // unwanted side effect of ALWAYS getting executed on version upgrades.
    // Scheme 3 only gets executed on build number deltas. Because schemes 1
    // and 2 are always executed, if a user changes (or deletes) that setting
    // it will always get put back. Not so with scheme 3.

    // Ideally, the best solution is have an internal shell32 build number
    // delta scheme which determines the from build and the to build and does
    // a similar mechanism to what hiveusd.inx and shmgrate.exe do. This
    // would probably involve either a common installation function (such as
    // FirstUserLogon()) which is called differently from Win9x and WinNT or
    // common functions to do the upgrade and two entry points (such as
    // FirstUserLogonNT() and FirstUserLogonWin9X().
    
    if (bInstall)
    {
        NT_PRODUCT_TYPE type = NtProductWinNt;
        RtlGetNtProductType(&type);

        // "U" means it's the per user install call
        BOOL fPerUser = pszCmdLine && (StrCmpIW(pszCmdLine, L"U") == 0);

        // "SA" means it's ths ServerAdmin install call
        fServerAdmin = pszCmdLine && (StrCmpIW(pszCmdLine, L"SA") == 0);

        if (fPerUser)
        {
            // NOTE: Code in this segment get run during first login.  We want first
            // login to be as quick as possible so try to minimize this section.

            // Put per-user install stuff here.  Any HKCU registration
            // done here is suspect.  (If you are setting defaults, do
            // so in HKLM and use the SHRegXXXUSValue functions.)

            // WARNING: we get called by the ie4unit.exe (ieunit.inf) scheme:
            //      %11%\shell32.dll,NI,U
            // this happens per user, to test this code "regsvr32 /n /i:U shell32.dll"

            hrTemp = CreateShowDesktopOnQuickLaunch();
            KEEP_FAILURE(hrTemp, hr);

            //  upgrade the recent folder.
            WCHAR sz[MAX_PATH];
            SHGetFolderPath(NULL, CSIDL_RECENT | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, sz);
            SHGetFolderPath(NULL, CSIDL_FAVORITES | CSIDL_FLAG_CREATE | CSIDL_FLAG_PER_USER_INIT, NULL, SHGFP_TYPE_CURRENT, sz);

            // Switch FTP to default to "PASV" mode.
            SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\FTP"), TEXT("Use PASV"), REG_SZ, (LPCVOID) TEXT("yes"), (4 * sizeof(TCHAR)));

            //  torch this value on upgrade.
            //  insuring the warning that they will see the ugly desktop.ini files
            SKDeleteValue(SHELLKEY_HKCU_EXPLORER, L"Advanced", L"ShowSuperHidden");

            HKEY hk = SHGetShellKey(SHELLKEY_HKCULM_MUICACHE, NULL, FALSE);
            if (hk)
            {
                SHDeleteKeyA(hk, NULL);
                RegCloseKey(hk);
            }

            // delete old sendto entries we dont want any more
            _DeleteSendToEntries();

            // handle the per user init for this guy
            _DoMyDocsPerUserInit();

            _DefaultVisualEffects();

            // handle the per user change of value for NoDriveAutoRun
            if (!IsOS(OS_ANYSERVER))
            {
                _NoDriveAutorunTweak();
            }
        }
        else if (fServerAdmin)
        {
            hrTemp = CallRegInstall("RegServerAdmin");
            KEEP_FAILURE(hrTemp, hr);
        }
        else
        {
            // Delete any old registration entries, then add the new ones.
            // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
            // (The inf engine doesn't guarantee DelReg/AddReg order, that's
            // why we explicitly unreg and reg here.)
            //
            hrTemp = CallRegInstall("RegDll");
            KEEP_FAILURE(hrTemp, hr);

            // I suppose we should call out NT-only registrations, just in case
            // we ever have to ship a win9x based shell again
            hrTemp = CallRegInstall("RegDllNT");
            KEEP_FAILURE(hrTemp, hr);

            // If we are on NT server, do additional stuff
            if (type != NtProductWinNt)
            {
                hrTemp = CallRegInstall("RegDllNTServer");
                KEEP_FAILURE(hrTemp, hr);
            }
            else // workstation
            {
                if (!IsOS(OS_PERSONAL))
                {
                    hrTemp = CallRegInstall("RegDllNTPro");
                    KEEP_FAILURE(hrTemp, hr);

                    //
                    // NTRAID#NTBUG9-418621-2001/06/27-jeffreys
                    //
                    // If the ForceGuest value is unset, e.g. on upgrade
                    // from Win2k, set the SimpleSharing/DefaultValue to 0.
                    //
                    DWORD dwForceGuest;
                    DWORD cb = sizeof(dwForceGuest);
                    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, TEXT("System\\CurrentControlSet\\Control\\Lsa"), TEXT("ForceGuest"), NULL, &dwForceGuest, &cb))
                    {
                        dwForceGuest = 0;
                        SHSetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced\\Folder\\SimpleSharing"), TEXT("DefaultValue"), REG_DWORD, &dwForceGuest, sizeof(dwForceGuest));
                    }
                }
            }

            //
            // If this is clean install, then hide some desktop icons.
            //
            if(IsCleanInstallInProgress())
            {
                hrTemp = CallRegInstall("RegHideDeskIcons");
                KEEP_FAILURE(hrTemp, hr);
            }

            // This is apparently the only way to get setup to remove all the registry backup
            // for old names no longer in use...
            hrTemp = CallRegInstall("CleanupOldRollback1");
            KEEP_FAILURE(hrTemp, hr);

            hrTemp = CallRegInstall("CleanupOldRollback2");
            KEEP_FAILURE(hrTemp, hr);

            // REVIEW (ToddB): Move this to DllRegisterServer.
            hrTemp = Shell32RegTypeLib();
            KEEP_FAILURE(hrTemp, hr);
            ApplyRegistrySecurity();
            FixPlusIcons();

            // Filesystem stuff should be done only on the native platform
            // (don't do it when in the emulator) since there is only one
            // filesystem. Otherwise the 32-bit version writes 32-bit goo
            // into the filesystem that the 64-bit shell32 can't handle
            if (!IsOS(OS_WOW6432))
            {
                CleanupFileSystem();
            }

#ifdef _WIN64
            // this will copy eula.txt to the %SystemRoot%\SysWOW64 directory for 
            // 32-bit apps running on IA64 under emulation
            CopyEULAForWow6432();
#endif        
            // Initialize the shared documents objects
            InitializeSharedDocs(IsOS(OS_WOW6432));

            DoFusion();
        }
    }
    else
    {
        // We only need one unreg call since all our sections share
        // the same backup information
        hrTemp = CallRegInstall("UnregDll");
        KEEP_FAILURE(hrTemp, hr);
        UnregisterTypeLibrary(&LIBID_Shell32);
    }

    if (!fServerAdmin)
    {
        CDeskHtmlProp_RegUnReg(bInstall);
    }
    
    return hr;
}


STDAPI DllRegisterServer(void)
{
    // NT5 setup calls this so it is now safe to put code here.
    return S_OK;
}


STDAPI DllUnregisterServer(void)
{
    return S_OK;
}


BOOL CopyRegistryValues (HKEY hKeyBaseSource, LPCTSTR pszSource, HKEY hKeyBaseTarget, LPCTSTR pszTarget)
{
    DWORD   dwDisposition, dwMaxValueNameSize, dwMaxValueDataSize;
    HKEY    hKeySource, hKeyTarget;
    BOOL    fSuccess = FALSE; //Assume error!

    hKeySource = hKeyTarget = NULL;
    if ((ERROR_SUCCESS == RegOpenKeyEx(hKeyBaseSource,
                                       pszSource,
                                       0,
                                       KEY_READ,
                                       &hKeySource)) &&
        (ERROR_SUCCESS == RegCreateKeyEx(hKeyBaseTarget,
                                         pszTarget,
                                         0,
                                         TEXT(""),
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_SET_VALUE,
                                         NULL,
                                         &hKeyTarget,
                                         &dwDisposition)) &&
        (ERROR_SUCCESS == RegQueryInfoKey(hKeySource,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL,
                                          &dwMaxValueNameSize,
                                          &dwMaxValueDataSize,
                                          NULL,
                                          NULL)))
    {
        TCHAR   *pszValueName;
        void    *pValueData;

        pszValueName = reinterpret_cast<TCHAR*>(LocalAlloc(LMEM_FIXED, ++dwMaxValueNameSize * sizeof(TCHAR)));
        if (pszValueName != NULL)
        {
            pValueData = LocalAlloc(LMEM_FIXED, dwMaxValueDataSize);
            if (pValueData != NULL)
            {
                DWORD   dwIndex, dwType, dwValueNameSize, dwValueDataSize;

                dwIndex = 0;
                dwValueNameSize = dwMaxValueNameSize;
                dwValueDataSize = dwMaxValueDataSize;
                while (ERROR_SUCCESS == RegEnumValue(hKeySource,
                                                     dwIndex,
                                                     pszValueName,
                                                     &dwValueNameSize,
                                                     NULL,
                                                     &dwType,
                                                     reinterpret_cast<LPBYTE>(pValueData),
                                                     &dwValueDataSize))
                {
                    RegSetValueEx(hKeyTarget,
                                  pszValueName,
                                  0,
                                  dwType,
                                  reinterpret_cast<LPBYTE>(pValueData),
                                  dwValueDataSize);
                    ++dwIndex;
                    dwValueNameSize = dwMaxValueNameSize;
                    dwValueDataSize = dwMaxValueDataSize;
                }
                LocalFree(pValueData);
                fSuccess = TRUE; //Succeeded!
            }
            LocalFree(pszValueName);
        }
    }
    if(hKeySource)
        RegCloseKey(hKeySource);
    if(hKeyTarget)
        RegCloseKey(hKeyTarget);

    return fSuccess;
}

STDAPI MergeDesktopAndNormalStreams(void)
{
    static  const   TCHAR   scszBaseRegistryLocation[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer");
    static  const   int     sciMaximumStreams = 128;
    static  const   TCHAR   sccOldMRUListBase = TEXT('a');

    // Upgrade from NT4 (classic shell) to Windows 2000 (integrated shell)

    // This involves TWO major changes and one minor change:
    //    1. Merging DesktopStreamMRU and StreamMRU
    //    2. Upgrading the MRUList to MRUListEx
    //    3. Leaving the old settings alone for the roaming user profile scenario

    // This also involves special casing the users desktop PIDL because this is
    // stored as an absolute path PIDL in DesktopStream and needs to be stored
    // in Streams\Desktop instead.

    // The conversion is performed in-situ and simultaneously.

    // 1. Open all the keys we are going to need to do the conversion.

    HKEY    hKeyBase, hKeyDesktopStreamMRU, hKeyDesktopStreams, hKeyStreamMRU, hKeyStreams;

    hKeyBase = hKeyDesktopStreamMRU = hKeyDesktopStreams = hKeyStreamMRU = hKeyStreams = NULL;
    if ((ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                       scszBaseRegistryLocation,
                                       0,
                                       KEY_READ | KEY_SET_VALUE,
                                       &hKeyBase)) &&
        (ERROR_SUCCESS == RegOpenKeyEx(hKeyBase,
                                       TEXT("DesktopStreamMRU"),
                                       0,
                                       KEY_READ | KEY_SET_VALUE,
                                       &hKeyDesktopStreamMRU)) &&
        (ERROR_SUCCESS == RegOpenKeyEx(hKeyBase,
                                       TEXT("DesktopStreams"),
                                       0,
                                       KEY_READ | KEY_SET_VALUE,
                                       &hKeyDesktopStreams)) &&
        (ERROR_SUCCESS == RegOpenKeyEx(hKeyBase,
                                       TEXT("StreamMRU"),
                                       0,
                                       KEY_READ | KEY_SET_VALUE,
                                       &hKeyStreamMRU)) &&
        (ERROR_SUCCESS == RegOpenKeyEx(hKeyBase,
                                       TEXT("Streams"),
                                       0,
                                       KEY_READ | KEY_SET_VALUE,
                                       &hKeyStreams)) &&

    // 2. Determine whether this upgrade is needed at all. If the presence of
    // StreamMRU\MRUListEx is detected then stop.

        (ERROR_SUCCESS != RegQueryValueEx(hKeyStreamMRU,
                                         TEXT("MRUListEx"),
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL)))
    {
        DWORD   *pdwMRUListEx, *pdwMRUListExBase;

        pdwMRUListExBase = pdwMRUListEx = reinterpret_cast<DWORD*>(LocalAlloc(LPTR, sciMaximumStreams * sizeof(DWORD) * 2));
        if (pdwMRUListEx != NULL)
        {
            DWORD   dwLastFreeSlot, dwMRUListSize, dwType;
            TCHAR   *pszMRUList, szMRUList[sciMaximumStreams];

            // 3. Read the StreamMRU\MRUList, iterate thru this list
            // and convert as we go.

            dwLastFreeSlot = 0;
            dwMRUListSize = sizeof(szMRUList);
            if (ERROR_SUCCESS == RegQueryValueEx(hKeyStreamMRU,
                                                 TEXT("MRUList"),
                                                 NULL,
                                                 &dwType,
                                                 reinterpret_cast<LPBYTE>(szMRUList),
                                                 &dwMRUListSize))
            {
                pszMRUList = szMRUList;
                while (*pszMRUList != TEXT('\0'))
                {
                    DWORD   dwValueDataSize;
                    TCHAR   szValue[16];

                    // Read the PIDL information based on the letter in
                    // the MRUList.

                    szValue[0] = *pszMRUList++;
                    szValue[1] = TEXT('\0');
                    if (ERROR_SUCCESS == RegQueryValueEx(hKeyStreamMRU,
                                                         szValue,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         &dwValueDataSize))
                    {
                        DWORD   dwValueType;
                        void    *pValueData;

                        pValueData = LocalAlloc(LMEM_FIXED, dwValueDataSize);
                        if (pValueData != NULL)
                        {
                            if (ERROR_SUCCESS == RegQueryValueEx(hKeyStreamMRU,
                                                              szValue,
                                                              NULL,
                                                              &dwValueType,
                                                              reinterpret_cast<LPBYTE>(pValueData),
                                                              &dwValueDataSize))
                            {

                                // Allocate a new number in the MRUListEx for the PIDL.

                                *pdwMRUListEx = szValue[0] - sccOldMRUListBase;
                                wnsprintf(szValue, ARRAYSIZE(szValue), TEXT("%d"), *pdwMRUListEx++);
                                ++dwLastFreeSlot;
                                RegSetValueEx(hKeyStreamMRU,
                                            szValue,
                                            NULL,
                                            dwValueType,
                                            reinterpret_cast<LPBYTE>(pValueData),
                                            dwValueDataSize);
                            }
                            LocalFree(pValueData);
                        }
                    }
                }
            }

            // 4. Read the DesktopStreamMRU\MRUList, iterate thru this
            // this and append to the new MRUListEx that is being
            // created as well as copying both the PIDL in DesktopStreamMRU
            // and the view information in DesktopStreams.

            dwMRUListSize = sizeof(szMRUList);
            if (ERROR_SUCCESS == RegQueryValueEx(hKeyDesktopStreamMRU,
                                                 TEXT("MRUList"),
                                                 NULL,
                                                 &dwType,
                                                 reinterpret_cast<LPBYTE>(szMRUList),
                                                 &dwMRUListSize))
            {
                bool    fConvertedEmptyPIDL;
                TCHAR   szDesktopDirectoryPath[MAX_PATH];

                fConvertedEmptyPIDL = false;
                SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY, NULL, SHGFP_TYPE_CURRENT, szDesktopDirectoryPath);
                pszMRUList = szMRUList;
                while (*pszMRUList != TEXT('\0'))
                {
                    DWORD   dwValueDataSize;
                    TCHAR   szSource[16];

                    // Read the PIDL information based on the letter in
                    // the MRUList.

                    szSource[0] = *pszMRUList++;
                    szSource[1] = TEXT('\0');
                    if (ERROR_SUCCESS == RegQueryValueEx(hKeyDesktopStreamMRU,
                                                         szSource,
                                                         NULL,
                                                         NULL,
                                                         NULL,
                                                         &dwValueDataSize))
                    {
                        DWORD   dwValueType;
                        void    *pValueData;

                        pValueData = LocalAlloc(LMEM_FIXED, dwValueDataSize);
                        if (pValueData != NULL)
                        {
                            if (ERROR_SUCCESS == RegQueryValueEx(hKeyDesktopStreamMRU,
                                                              szSource,
                                                              NULL,
                                                              &dwValueType,
                                                              reinterpret_cast<LPBYTE>(pValueData),
                                                              &dwValueDataSize))
                            {
                                TCHAR   szTarget[16], szStreamPath[MAX_PATH];

                                if ((SHGetPathFromIDList(reinterpret_cast<LPCITEMIDLIST>(pValueData), szStreamPath) != 0) &&
                                    (0 == lstrcmpi(szStreamPath, szDesktopDirectoryPath)))
                                {
                                    if (!fConvertedEmptyPIDL)
                                    {

                                        // 99/05/24 #343721 vtan: Prefer the desktop relative PIDL
                                        // (empty PIDL) when given a choice of two PIDLs that refer
                                        // to the desktop. The old absolute PIDL is from SP3 and
                                        // earlier days. The new relative PIDL is from SP4 and
                                        // later days. An upgraded SP3 -> SP4 -> SPx -> Windows
                                        // 2000 system will possibly have old absolute PIDLs.
                                        // Check for the empty PIDL. If this is encountered already
                                        // then don't process this stream.

                                        fConvertedEmptyPIDL = ILIsEmpty(reinterpret_cast<LPCITEMIDLIST>(pValueData));
                                        wnsprintf(szSource, ARRAYSIZE(szSource), TEXT("%d"), szSource[0] - sccOldMRUListBase);
                                        CopyRegistryValues(hKeyDesktopStreams, szSource, hKeyStreams, TEXT("Desktop"));
                                    }
                                }
                                else
                                {

                                    // Allocate a new number in the MRUListEx for the PIDL.

                                    *pdwMRUListEx++ = dwLastFreeSlot;
                                    wnsprintf(szTarget, ARRAYSIZE(szTarget), TEXT("%d"), dwLastFreeSlot++);
                                    if (ERROR_SUCCESS == RegSetValueEx(hKeyStreamMRU,
                                                                    szTarget,
                                                                    NULL,
                                                                    dwValueType,
                                                                    reinterpret_cast<LPBYTE>(pValueData),
                                                                    dwValueDataSize))
                                    {

                                        // Copy the view information from DesktopStreams to Streams

                                        wnsprintf(szSource, ARRAYSIZE(szSource), TEXT("%d"), szSource[0] - sccOldMRUListBase);
                                        CopyRegistryValues(hKeyDesktopStreams, szSource, hKeyStreams, szTarget);
                                    }
                                }
                            }
                            LocalFree(pValueData);
                        }
                    }
                }
            }
            *pdwMRUListEx++ = static_cast<DWORD>(-1);
            RegSetValueEx(hKeyStreamMRU,
                          TEXT("MRUListEx"),
                          NULL,
                          REG_BINARY,
                          reinterpret_cast<LPCBYTE>(pdwMRUListExBase),
                          ++dwLastFreeSlot * sizeof(DWORD));
            LocalFree(reinterpret_cast<HLOCAL>(pdwMRUListExBase));
        }
    }
    if (hKeyStreams != NULL)
        RegCloseKey(hKeyStreams);
    if (hKeyStreamMRU != NULL)
        RegCloseKey(hKeyStreamMRU);
    if (hKeyDesktopStreams != NULL)
        RegCloseKey(hKeyDesktopStreams);
    if (hKeyDesktopStreamMRU != NULL)
        RegCloseKey(hKeyDesktopStreamMRU);
    if (hKeyBase != NULL)
        RegCloseKey(hKeyBase);
    return(S_OK);
}

static  const   int     s_ciMaximumNumericString = 32;

int GetRegistryStringValueAsInteger (HKEY hKey, LPCTSTR pszValue, int iDefaultValue)

{
    int     iResult;
    DWORD   dwType, dwStringSize;
    TCHAR   szString[s_ciMaximumNumericString];

    dwStringSize = sizeof(szString);
    if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                         pszValue,
                                         NULL,
                                         &dwType,
                                         reinterpret_cast<LPBYTE>(szString),
                                         &dwStringSize) && (dwType == REG_SZ))
    {
        iResult = StrToInt(szString);
    }
    else
    {
        iResult = iDefaultValue;
    }
    return(iResult);
}

void SetRegistryIntegerAsStringValue (HKEY hKey, LPCTSTR pszValue, int iValue)

{
    TCHAR   szString[s_ciMaximumNumericString];

    wnsprintf(szString, ARRAYSIZE(szString), TEXT("%d"), iValue);
    TW32(RegSetValueEx(hKey,
                       pszValue,
                       0,
                       REG_SZ,
                       reinterpret_cast<LPBYTE>(szString),
                       (lstrlen(szString) + 1) * sizeof(TCHAR)));
}

STDAPI MoveAndAdjustIconMetrics(void)
{
    // 99/06/06 #309198 vtan: The following comes from hiveusd.inx which is
    // where this functionality used to be executed. It used to consist of
    // simple registry deletion and addition. This doesn't work on upgrade
    // when the user has large icons (Shell Icon Size == 48).

    // In this case that metric must be moved and the new values adjusted
    // so that the metric is preserved should the user then decide to turn
    // off large icons.

    // To restore old functionality, remove the entry in hiveusd.inx at
    // build 1500 which is where this function is invoked and copy the
    // old text back in.

/*
    HKR,"1508\Hive\2","Action",0x00010001,3
    HKR,"1508\Hive\2","KeyName",0000000000,"Control Panel\Desktop\WindowMetrics"
    HKR,"1508\Hive\2","Value",0000000000,"75"
    HKR,"1508\Hive\2","ValueName",0000000000,"IconSpacing"
    HKR,"1508\Hive\3","Action",0x00010001,3
    HKR,"1508\Hive\3","KeyName",0000000000,"Control Panel\Desktop\WindowMetrics"
    HKR,"1508\Hive\3","Value",0000000000,"1"
    HKR,"1508\Hive\3","ValueName",0000000000,"IconTitleWrap"
*/

    // Icon metric keys have moved from HKCU\Control Panel\Desktop\Icon*
    // to HKCU\Control Panel\Desktop\WindowMetrics\Icon* but only 3 values
    // should be moved. These are "IconSpacing", "IconTitleWrap" and
    // "IconVerticalSpacing". This code is executed before the deletion
    // entry in hiveusd.inx so that it can get the values before they
    // are deleted. The addition section has been remove (it's above).

    static  const   TCHAR   s_cszIconSpacing[] = TEXT("IconSpacing");
    static  const   TCHAR   s_cszIconTitleWrap[] = TEXT("IconTitleWrap");
    static  const   TCHAR   s_cszIconVerticalSpacing[] = TEXT("IconVerticalSpacing");

    static  const   int     s_ciStandardOldIconSpacing = 75;
    static  const   int     s_ciStandardNewIconSpacing = -1125;

    HKEY    hKeyDesktop, hKeyWindowMetrics;

    hKeyDesktop = hKeyWindowMetrics = NULL;
    if ((ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                       TEXT("Control Panel\\Desktop"),
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKeyDesktop)) &&
        (ERROR_SUCCESS == RegOpenKeyEx(hKeyDesktop,
                                       TEXT("WindowMetrics"),
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKeyWindowMetrics)))
    {
        int     iIconSpacing, iIconTitleWrap, iIconVerticalSpacing;

        // 1. Read the values that we wish the move and adjust.

        iIconSpacing = GetRegistryStringValueAsInteger(hKeyDesktop, s_cszIconSpacing, s_ciStandardOldIconSpacing);
        iIconTitleWrap = GetRegistryStringValueAsInteger(hKeyDesktop, s_cszIconTitleWrap, 1);
        iIconVerticalSpacing = GetRegistryStringValueAsInteger(hKeyDesktop, s_cszIconVerticalSpacing, s_ciStandardOldIconSpacing);

        // 2. Perform the adjustment.

        iIconSpacing = s_ciStandardNewIconSpacing * iIconSpacing / s_ciStandardOldIconSpacing;
        iIconVerticalSpacing = s_ciStandardNewIconSpacing * iIconVerticalSpacing / s_ciStandardOldIconSpacing;

        // 3. Write the values back out in the new (moved) location.

        SetRegistryIntegerAsStringValue(hKeyWindowMetrics, s_cszIconSpacing, iIconSpacing);
        SetRegistryIntegerAsStringValue(hKeyWindowMetrics, s_cszIconTitleWrap, iIconTitleWrap);
        SetRegistryIntegerAsStringValue(hKeyWindowMetrics, s_cszIconVerticalSpacing, iIconVerticalSpacing);

        // 4. Let winlogon continue processing hiveusd.inx and delete the
        // old entries in the process. We already created the new entries
        // and that has been removed from hiveusd.inx.

    }
    if (hKeyWindowMetrics != NULL)
        TW32(RegCloseKey(hKeyWindowMetrics));
    if (hKeyDesktop != NULL)
        TW32(RegCloseKey(hKeyDesktop));
    return(S_OK);
}

STDAPI FirstUserLogon(LPCSTR pcszCommand, LPCSTR pcszOptionalArguments)
{
    const struct
    {
        LPCSTR  pcszCommand;
        HRESULT (WINAPI *pfn)();
    }  
    sCommands[] =
    {
        { "MergeDesktopAndNormalStreams",   MergeDesktopAndNormalStreams   },
        { "MoveAndAdjustIconMetrics",       MoveAndAdjustIconMetrics       },
    };

    HRESULT hr = E_FAIL;
    // Match what shmgrate.exe passed us and execute the command.
    // Only use the optional argument if required. Note this is
    // done ANSI because the original command line is ANSI from
    // shmgrate.exe.

    for (int i = 0; i < ARRAYSIZE(sCommands); ++i)
    {
        if (lstrcmpA(pcszCommand, sCommands[i].pcszCommand) == 0)
        {
            hr = sCommands[i].pfn();
            break;
        }
    }
    return hr;
}


// now is the time on sprockets when we lock down the registry
STDAPI_(BOOL) ApplyRegistrySecurity()
{
    BOOL fSuccess = FALSE;      // assume failure
    SHELL_USER_PERMISSION supEveryone;
    SHELL_USER_PERMISSION supSystem;
    SHELL_USER_PERMISSION supAdministrators;
    PSHELL_USER_PERMISSION aPerms[3] = {&supEveryone, &supSystem, &supAdministrators};

    // we want the "Everyone" to have read access
    supEveryone.susID = susEveryone;
    supEveryone.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supEveryone.dwAccessMask = KEY_READ;
    supEveryone.fInherit = TRUE;
    supEveryone.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supEveryone.dwInheritAccessMask = GENERIC_READ;

    // we want the "SYSTEM" to have full control
    supSystem.susID = susSystem;
    supSystem.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supSystem.dwAccessMask = KEY_ALL_ACCESS;
    supSystem.fInherit = TRUE;
    supSystem.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supSystem.dwInheritAccessMask = GENERIC_ALL;

    // we want the "Administrators" to have full control
    supAdministrators.susID = susAdministrators;
    supAdministrators.dwAccessType = ACCESS_ALLOWED_ACE_TYPE;
    supAdministrators.dwAccessMask = KEY_ALL_ACCESS;
    supAdministrators.fInherit = TRUE;
    supAdministrators.dwInheritMask = (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);
    supAdministrators.dwInheritAccessMask = GENERIC_ALL;

    SECURITY_DESCRIPTOR* psd = GetShellSecurityDescriptor(aPerms, ARRAYSIZE(aPerms));
    if (psd)
    {
        HKEY hkLMBitBucket;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\BitBucket"), 0, KEY_ALL_ACCESS, &hkLMBitBucket) == ERROR_SUCCESS)
        {
            if (RegSetKeySecurity(hkLMBitBucket, DACL_SECURITY_INFORMATION, psd) == ERROR_SUCCESS)
            {
                // victory is mine!
                fSuccess = TRUE;
            }

            RegCloseKey(hkLMBitBucket);
        }

        LocalFree(psd);
    }

    return fSuccess;
}

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    // nothing in here, use clsobj.c class table instead
END_OBJECT_MAP()

// ATL DllMain, needed to support our ATL classes that depend on _Module
// REVIEW: confirm that _Module is really needed

STDAPI_(BOOL) ATL_DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }
    return TRUE;    // ok
}

#define FUSION_FLAG_SYSTEM32        0
#define FUSION_FLAG_WINDOWS         1
#define FUSION_FLAG_PROGRAMFILES    2
#define FUSION_ENTRY(x, z)  {L#x, NULL, z},
#define FUSION_ENTRY_DEST(x, y, z)  {L#x, L#y, z},

struct
{
    PWSTR pszAppName;
    PWSTR pszDestination;
    DWORD dwFlags;
} 
g_FusionizedApps[] = 
{
    FUSION_ENTRY(ncpa.cpl, FUSION_FLAG_SYSTEM32)
    FUSION_ENTRY(nwc.cpl, FUSION_FLAG_SYSTEM32)
    FUSION_ENTRY(sapi.cpl, FUSION_FLAG_SYSTEM32)
    FUSION_ENTRY(wuaucpl.cpl, FUSION_FLAG_SYSTEM32)
    FUSION_ENTRY(cdplayer.exe, FUSION_FLAG_SYSTEM32)
    FUSION_ENTRY_DEST(msimn.exe, "OutLook Express", FUSION_FLAG_PROGRAMFILES)
    // WARNING: Do NOT add iexplorer or Explorer.exe! This will cause all apps to get fusioned; which is bad, mkay?
};



void DoFusion()
{
    TCHAR szManifest[MAX_PATH];

    // We will however generate a manifest for other apps
    for (int i = 0; i < ARRAYSIZE(g_FusionizedApps); i++)
    {
        BOOL fStatus = TRUE;
        switch(g_FusionizedApps[i].dwFlags)
        {
        case FUSION_FLAG_SYSTEM32:
            if (!GetSystemDirectory(szManifest, ARRAYSIZE(szManifest)))
            {
                fStatus = FALSE;
            }
            break;

        case FUSION_FLAG_WINDOWS:
            if (!GetWindowsDirectory(szManifest, ARRAYSIZE(szManifest)))
            {
                fStatus = FALSE;
            }
            break;

        case FUSION_FLAG_PROGRAMFILES:
            if (FAILED(SHGetSpecialFolderPath(NULL, szManifest, CSIDL_PROGRAM_FILES, FALSE)) ||
                !PathCombine(szManifest, szManifest, g_FusionizedApps[i].pszDestination))
            {
                fStatus = FALSE;
            }
            break;
        }

        if (fStatus && PathCombine(szManifest, szManifest, g_FusionizedApps[i].pszAppName) &&
            SUCCEEDED(StringCchCat(szManifest, ARRAYSIZE(szManifest), TEXT(".manifest"))))
        {
            SHSquirtManifest(HINST_THISDLL, IDS_EXPLORERMANIFEST, szManifest);
        }
    }

    SHGetManifest(szManifest, ARRAYSIZE(szManifest));
    SHSquirtManifest(HINST_THISDLL, IDS_EXPLORERMANIFEST, szManifest);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\drawpie.c ===
#include "shellprv.h"
#pragma  hdrstop

int IntSqrt(unsigned long dwNum)
{
	// We will keep shifting dwNum left and look at the top two bits.

	// initialize sqrt and remainder to 0.
	DWORD dwSqrt = 0, dwRemain = 0, dwTry;
	int i;

	// We iterate 16 times, once for each pair of bits.
	for (i=0; i<16; ++i)
	{
		// Mask off the top two bits of dwNum and rotate them into the
		// bottom of the remainder
		dwRemain = (dwRemain<<2) | (dwNum>>30);

		// Now we shift the sqrt left; next we'll determine whether the
		// new bit is a 1 or a 0.
		dwSqrt <<= 1;

		// This is where we double what we already have, and try a 1 in
		// the lowest bit.
		dwTry = dwSqrt*2 + 1;

		if (dwRemain >= dwTry)
		{
			// The remainder was big enough, so subtract dwTry from
			// the remainder and tack a 1 onto the sqrt.
			dwRemain -= dwTry;
			dwSqrt |= 0x01;
		}

		// Shift dwNum to the left by 2 so we can work on the next few
		// bits.
		dwNum <<= 2;
	}

	return(dwSqrt);
}

STDAPI_(VOID) DrawPie(HDC hDC, LPCRECT lprcItem, UINT uPctX10, BOOL TrueZr100,
                  UINT uOffset, const COLORREF *lpColors)
{
	int cx, cy, rx, ry, x, y;
	int uQPctX10;
	RECT rcItem;
	HRGN hEllRect, hEllipticRgn, hRectRgn;
	HBRUSH hBrush, hOldBrush;
	HPEN hPen, hOldPen;
    DWORD dwOldLayout;

	rcItem = *lprcItem;
	rcItem.left = lprcItem->left;
	rcItem.top = lprcItem->top;
	rcItem.right = lprcItem->right - rcItem.left;
	rcItem.bottom = lprcItem->bottom - rcItem.top - uOffset;

	rx = rcItem.right / 2;
	cx = rcItem.left + rx - 1;
	ry = rcItem.bottom / 2;
	cy = rcItem.top + ry - 1;
	if (rx<=10 || ry<=10)
	{
		return;
	}

    dwOldLayout = SET_DC_LAYOUT(hDC, 0);

	rcItem.right = rcItem.left+2*rx;
	rcItem.bottom = rcItem.top+2*ry;

	if (uPctX10 > 1000)
	{
		uPctX10 = 1000;
	}

	/* Translate to first quadrant of a Cartesian system
	*/
	uQPctX10 = (uPctX10 % 500) - 250;
	if (uQPctX10 < 0)
	{
		uQPctX10 = -uQPctX10;
	}

	/* Calc x and y.  I am trying to make the area be the right percentage.
	** I don't know how to calculate the area of a pie slice exactly, so I
	** approximate it by using the triangle area instead.
	*/
	if (uQPctX10 < 120)
	{
		x = IntSqrt(((DWORD)rx*(DWORD)rx*(DWORD)uQPctX10*(DWORD)uQPctX10)
			/((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

		y = IntSqrt(((DWORD)rx*(DWORD)rx-(DWORD)x*(DWORD)x)*(DWORD)ry*(DWORD)ry/((DWORD)rx*(DWORD)rx));
	}
	else
	{
		y = IntSqrt((DWORD)ry*(DWORD)ry*(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)
			/((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

		x = IntSqrt(((DWORD)ry*(DWORD)ry-(DWORD)y*(DWORD)y)*(DWORD)rx*(DWORD)rx/((DWORD)ry*(DWORD)ry));
	}

	/* Switch on the actual quadrant
	*/
	switch (uPctX10 / 250)
	{
	case 1:
		y = -y;
		break;

	case 2:
		break;

	case 3:
		x = -x;
		break;

	default: // case 0 and case 4
		x = -x;
		y = -y;
		break;
	}

	/* Now adjust for the center.
	*/
	x += cx;
	y += cy;

        // Hack to get around bug in NTGDI

        x = x < 0 ? 0 : x;

	/* Draw the shadows using regions (to reduce flicker).
	*/
	hEllipticRgn = CreateEllipticRgnIndirect(&rcItem);
	OffsetRgn(hEllipticRgn, 0, uOffset);
	hEllRect = CreateRectRgn(rcItem.left, cy, rcItem.right, cy+uOffset);
	hRectRgn = CreateRectRgn(0, 0, 0, 0);
	CombineRgn(hRectRgn, hEllipticRgn, hEllRect, RGN_OR);
	OffsetRgn(hEllipticRgn, 0, -(int)uOffset);
	CombineRgn(hEllRect, hRectRgn, hEllipticRgn, RGN_DIFF);

	/* Always draw the whole area in the free shadow/
	*/
	hBrush = CreateSolidBrush(lpColors[DP_FREESHADOW]);
	if (hBrush)
	{
		FillRgn(hDC, hEllRect, hBrush);
		DeleteObject(hBrush);
	}

	/* Draw the used shadow only if the disk is at least half used.
	*/
	if (uPctX10>500 && (hBrush=CreateSolidBrush(lpColors[DP_USEDSHADOW]))!=NULL)
	{
		DeleteObject(hRectRgn);
		hRectRgn = CreateRectRgn(x, cy, rcItem.right, lprcItem->bottom);
		CombineRgn(hEllipticRgn, hEllRect, hRectRgn, RGN_AND);
		FillRgn(hDC, hEllipticRgn, hBrush);
		DeleteObject(hBrush);
	}

	DeleteObject(hRectRgn);
	DeleteObject(hEllipticRgn);
	DeleteObject(hEllRect);

	hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
	hOldPen = SelectObject(hDC, hPen);

	if((uPctX10 < 100) && (cy == y))
	{
	    hBrush = CreateSolidBrush(lpColors[DP_FREECOLOR]);
	    hOldBrush = SelectObject(hDC, hBrush);
	    if((TrueZr100 == FALSE) || (uPctX10 != 0))
	    {
		Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
			rcItem.left, cy, x, y);
	    }
	    else
	    {
		Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right,
			     rcItem.bottom);
	    }
	}
	else if((uPctX10 > (1000 - 100)) && (cy == y))
	{
	    hBrush = CreateSolidBrush(lpColors[DP_USEDCOLOR]);
	    hOldBrush = SelectObject(hDC, hBrush);
	    if((TrueZr100 == FALSE) || (uPctX10 != 1000))
	    {
		Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
			rcItem.left, cy, x, y);
	    }
	    else
	    {
		Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right,
			     rcItem.bottom);
	    }
	}
	else
	{
	    hBrush = CreateSolidBrush(lpColors[DP_USEDCOLOR]);
	    hOldBrush = SelectObject(hDC, hBrush);

	    Ellipse(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom);
	    SelectObject(hDC, hOldBrush);
	    DeleteObject(hBrush);

	    hBrush = CreateSolidBrush(lpColors[DP_FREECOLOR]);
	    hOldBrush = SelectObject(hDC, hBrush);
	    Pie(hDC, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
		    rcItem.left, cy, x, y);
	}
	SelectObject(hDC, hOldBrush);
	DeleteObject(hBrush);

	/* Do not draw the lines if the %age is truely 0 or 100 (completely
	** empty disk or completly full disk)
	*/
	if((TrueZr100 == FALSE) || ((uPctX10 != 0) && (uPctX10 != 1000)))
	{
	    Arc(hDC, rcItem.left, rcItem.top+uOffset, rcItem.right, rcItem.bottom+uOffset,
		    rcItem.left, cy+uOffset, rcItem.right, cy+uOffset-1);
	    MoveToEx(hDC, rcItem.left, cy, NULL);
	    LineTo(hDC, rcItem.left, cy+uOffset);
	    MoveToEx(hDC, rcItem.right-1, cy, NULL);
	    LineTo(hDC, rcItem.right-1, cy+uOffset);

	    if (uPctX10 > 500)
	    {
		    MoveToEx(hDC, x, y, NULL);
		    LineTo(hDC, x, y+uOffset);
	    }
	}
	SelectObject(hDC, hOldPen);
	DeleteObject(hPen);
    SET_DC_LAYOUT(hDC, dwOldLayout);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\drivfldr.cpp ===
#include "shellprv.h"
#include "caggunk.h"
#include "views.h"
#include "drives.h"
#include "netview.h"
#include "propsht.h"
#include "infotip.h"
#include "mtpt.h"
#include "prop.h"
#include "defcm.h"

#include "basefvcb.h"
#include "fstreex.h"
#include "ovrlaymn.h"

#include "shitemid.h"
#include "clsobj.h"

#include "deskfldr.h"
#include "datautil.h"

#include <ntddcdrm.h>
#include <cfgmgr32.h>          // MAX_GUID_STRING_LEN
#include "ole2dup.h"

#include "category.h"
#define  EXCLUDE_COMPPROPSHEET
#include "unicpp\dcomp.h"
#undef   EXCLUDE_COMPPROPSHEET

#include "enumidlist.h"
#include <enumt.h>

#define ShowDriveInfo(_iDrive)  (!IsRemovableDrive(_iDrive))

#define CDRIVES_REGITEM_CONTROL 0
#define IDLIST_DRIVES           ((LPCITEMIDLIST)&c_idlDrives)

// These are the sort order for items in MyComputer
#define CONTROLS_SORT_INDEX             30
#define CDRIVES_REGITEM_CONTROL          0

REQREGITEM g_asDrivesReqItems[] =
{
    { &CLSID_ControlPanel, IDS_CONTROLPANEL, c_szShell32Dll, -IDI_CPLFLD, CONTROLS_SORT_INDEX, SFGAO_FOLDER | SFGAO_HASSUBFOLDER, NULL},
};


class CDrivesViewCallback;
class CDrivesFolderEnum;

class CDrivesBackgroundMenuCB : public IContextMenuCB
{
public:
    CDrivesBackgroundMenuCB(LPITEMIDLIST pidlFolder);
    ~CDrivesBackgroundMenuCB();
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();
    // IContextMenuCB
    STDMETHOD(CallBack) (IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);
private:
    STDMETHOD(_GetHelpText) (UINT offset, BOOL bWide, LPARAM lParam, UINT cch);
    LPITEMIDLIST _pidlFolder;
    LONG         _cRef;
};

class CDrivesFolder : public CAggregatedUnknown, IShellFolder2, IPersistFolder2, IShellIconOverlay
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj)
                { return CAggregatedUnknown::QueryInterface(riid, ppvObj); };
    STDMETHODIMP_(ULONG) AddRef(void) 
                { return CAggregatedUnknown::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) 
                { return CAggregatedUnknown::Release(); };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, IBindCtx *pbc, LPOLESTR pszDisplayName,
                                  ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList ** ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void** ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void** ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwndOwner, REFIID riid, void** ppvOut);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST* apidl,
                               REFIID riid, UINT* prgfInOut, void** ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags,
                           LPITEMIDLIST* ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD* pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS* pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID* pscid);

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST* ppidl);

    // IShellIconOverlay
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int* pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int* pIconIndex);

    STDMETHODIMP GetMaxNameLength(LPCITEMIDLIST pidlItem, UINT *pcchMax);

protected:
    CDrivesFolder(IUnknown* punkOuter);
    ~CDrivesFolder();

    // used by the CAggregatedUnknown stuff
    HRESULT v_InternalQueryInterface(REFIID riid, void **ppvObj);
    BOOL v_HandleDelete(PLONG pcRef);
    
    STDMETHODIMP CompareItemIDs(LPCIDDRIVE pidd1, LPCIDDRIVE pidd2);
    static BOOL _GetFreeSpace(LPCIDDRIVE pidd, ULONGLONG *pSize, ULONGLONG *pFree);
    static HRESULT _OnChangeNotify(LPARAM lNotification, LPCITEMIDLIST *ppidl);
    static HRESULT _GetCLSIDFromPidl(LPCIDDRIVE pidd, CLSID *pclsid);
    static HRESULT _CheckDriveType(int iDrive, LPCTSTR pszCLSID);
    static HRESULT _FindExtCLSID(int iDrive, CLSID *pclsid);
    static HRESULT _FillIDDrive(DRIVE_IDLIST *piddl, int iDrive, BOOL fNoCLSID, IBindCtx* pbc);
    static LPCIDDRIVE _IsValidID(LPCITEMIDLIST pidl);
    static HRESULT _GetDisplayNameStrRet(LPCIDDRIVE pidd, STRRET *pStrRet);
    static HRESULT _GetDisplayName(LPCIDDRIVE pidd, LPTSTR pszName, UINT cchMax);
    static HRESULT _CreateFSFolderObj(IBindCtx *pbc, LPCITEMIDLIST pidlDrive, LPCIDDRIVE pidd, REFIID riid, void **ppv);
    static HRESULT _CreateFSFolder(IBindCtx *pbc, LPCITEMIDLIST pidlDrive, LPCIDDRIVE pidd, REFIID riid, void **ppv);
    static HRESULT _GetEditTextStrRet(LPCIDDRIVE pidd, STRRET *pstr);
    static BOOL _IsReg(LPCIDDRIVE pidd) { return pidd->bFlags == SHID_COMPUTER_REGITEM; }
    static HRESULT _GetIconOverlayInfo(LPCIDDRIVE pidd, int *pIndex, DWORD dwFlags);

    static CDrivesFolder* _spThis;
    
private:
    friend HRESULT CDrives_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);
    friend void CDrives_Terminate(void);

    friend CDrivesViewCallback;
    friend class CDrivesFolderEnum;

    IUnknown* _punkReg;
};  

#define DRIVES_EVENTS \
    SHCNE_DRIVEADD | \
    SHCNE_DRIVEREMOVED | \
    SHCNE_MEDIAINSERTED | \
    SHCNE_MEDIAREMOVED | \
    SHCNE_NETSHARE | \
    SHCNE_NETUNSHARE | \
    SHCNE_CREATE | \
    SHCNE_DELETE | \
    SHCNE_RENAMEITEM | \
    SHCNE_RENAMEFOLDER | \
    SHCNE_UPDATEITEM


// return S_OK if non NULL CLSID copied out

HRESULT CDrivesFolder::_GetCLSIDFromPidl(LPCIDDRIVE pidd, CLSID *pclsid)
{
    *pclsid = CLSID_NULL;

    if ((pidd->cb >= sizeof(IDDRIVE)) &&
        ((pidd->wSig & IDDRIVE_ORDINAL_MASK) == IDDRIVE_ORDINAL_DRIVEEXT) &&
        (pidd->wSig & IDDRIVE_FLAGS_DRIVEEXT_HASCLSID))
    {
        *pclsid = pidd->clsid;
        return S_OK;
    }
    return S_FALSE;     // does not have a CLSID
}

HRESULT CDrivesFolder::GetMaxNameLength(LPCITEMIDLIST pidlItem, UINT *pcchMax)
{
    HRESULT hr = E_INVALIDARG;
    LPCIDDRIVE pidd = _IsValidID(pidlItem);
    if (pidd)
    {
        if (pidd->bFlags == SHID_COMPUTER_REGITEM)
        {
            // this is bogus, we are handling stuff for regfldr
            *pcchMax = MAX_REGITEMCCH;
            hr = S_OK;
        }
        else
        {
            CMountPoint* pMtPt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));
            if (pMtPt)
            {
                TCHAR szLabel[MAX_LABEL_NTFS + 1];
                hr = pMtPt->GetLabel(szLabel, ARRAYSIZE(szLabel));
                if (SUCCEEDED(hr))
                {
                    if (pMtPt->IsNTFS())
                        *pcchMax = MAX_LABEL_NTFS;
                    else
                        *pcchMax = MAX_LABEL_FAT;
                }
                pMtPt->Release();
            }
        }
    }
    return hr;
}

class CDrivesViewCallback : public CBaseShellFolderViewCB, public IFolderFilter
{
public:
    CDrivesViewCallback(CDrivesFolder *pfolder);

    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) { return CBaseShellFolderViewCB::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) { return CBaseShellFolderViewCB::Release(); };

    // IFolderFilter
    STDMETHODIMP ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem);
    STDMETHODIMP GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags);

private:
    ~CDrivesViewCallback();

    HRESULT OnMergeMenu(DWORD pv, QCMINFO*lP)
    {
        return S_OK;
    }

    HRESULT OnInsertItem(DWORD pv, LPCITEMIDLIST wP)
    {
        LPIDDRIVE pidd = (LPIDDRIVE)wP;
        if (pidd && pidd->bFlags != SHID_COMPUTER_REGITEM)
        {
            // clear the size info
            pidd->qwSize = pidd->qwFree = 0;
        }
        return S_OK;
    }

    HRESULT OnWindowCreated(DWORD pv, HWND wP)
    {
        InitializeStatus(_punkSite);
        return S_OK;
    }

    HRESULT OnSize(DWORD pv, UINT cx, UINT cy)
    {
        ResizeStatus(_punkSite, cx);
        return S_OK;
    }

    HRESULT OnGetPane(DWORD pv, LPARAM dwPaneID, DWORD *pdwPane)
    {
        if (PANE_ZONE == dwPaneID)
            *pdwPane = 2;
        return S_OK;
    }

    HRESULT OnDefViewMode(DWORD pv, FOLDERVIEWMODE* pfvm)
    {
        *pfvm = IsOS(OS_SERVERADMINUI) ? FVM_DETAILS : FVM_TILE;
        return S_OK;
    }

    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);

    HRESULT OnUpdateStatusBar(DWORD pv, BOOL fIniting)
    {
        // Ask DefView to set the default text but not initialize
        // since we did the initialization in our OnSize handler.
        return SFVUSB_INITED;
    }

    HRESULT OnFSNotify(DWORD pv, LPCITEMIDLIST*wP, LPARAM lP)
    {
        return CDrivesFolder::_OnChangeNotify(lP, wP);
    }

    HRESULT OnBACKGROUNDENUM(DWORD pv)
    {
        return S_OK;
    }

    HRESULT OnGetCCHMax(DWORD pv, LPCITEMIDLIST pidlItem, UINT *pcchMax)
    {
        return _pfolder->GetMaxNameLength(pidlItem, pcchMax);
    }

    CDrivesFolder *_pfolder;
    LONG _cRef;

public:
    // Web View Task implementations
    static HRESULT _CanEject(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanChangeSettings(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanSysProperties(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanAddRemovePrograms(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _OnSystemProperties(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnAddRemovePrograms(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnChangeSettings(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnEject(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
};

CDrivesViewCallback::CDrivesViewCallback(CDrivesFolder *pfolder) : 
    CBaseShellFolderViewCB((LPCITEMIDLIST)&c_idlDrives, DRIVES_EVENTS), _pfolder(pfolder), _cRef(1)
{ 
    _pfolder->AddRef();
}

CDrivesViewCallback::~CDrivesViewCallback()
{ 
    _pfolder->Release();
}


STDMETHODIMP CDrivesViewCallback::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_MERGEMENU, OnMergeMenu);
    HANDLE_MSG(0, SFVM_INSERTITEM, OnInsertItem);
    HANDLE_MSG(0, SFVM_UPDATESTATUSBAR, OnUpdateStatusBar);
    HANDLE_MSG(0, SFVM_FSNOTIFY, OnFSNotify);
    HANDLE_MSG(0, SFVM_BACKGROUNDENUM, OnBACKGROUNDENUM);
    HANDLE_MSG(0, SFVM_DEFVIEWMODE, OnDefViewMode);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);
    HANDLE_MSG(0, SFVM_ADDPROPERTYPAGES, SFVCB_OnAddPropertyPages);
    HANDLE_MSG(0, SFVM_WINDOWCREATED, OnWindowCreated);
    HANDLE_MSG(0, SFVM_SIZE, OnSize);
    HANDLE_MSG(0, SFVM_GETPANE, OnGetPane);
    HANDLE_MSG(0, SFVM_GETCCHMAX, OnGetCCHMax);

    default:
        return E_FAIL;
    }

    return S_OK;
}

HRESULT CDrivesViewCallback::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = CBaseShellFolderViewCB::QueryInterface(riid, ppv);
    if (FAILED(hr))
    {
        static const QITAB qit[] = {
            QITABENT(CDrivesViewCallback, IFolderFilter),
            { 0 },
        };
        hr = QISearch(this, qit, riid, ppv);
    }
    return hr;
}

STDMETHODIMP CDrivesViewCallback::ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem)
{
    HRESULT hr = S_OK;  //Assume that this item should be shown!
    
    if (SHRestricted(REST_NOMYCOMPUTERICON)) // this policy means hide my computer everywhere AND hide the contents if the user is sneaky and gets in anyway
    {
        hr = S_FALSE;
    }
    else
    {
        IShellFolder2 *psf2;
        if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
        {
            // Get the GUID in the pidl, which requires IShellFolder2.
            CLSID guidItem;
            if (SUCCEEDED(GetItemCLSID(psf2, pidlItem, &guidItem)))
            {
                //Convert the guid to a string
                TCHAR   szGuidValue[MAX_GUID_STRING_LEN];
            
                SHStringFromGUID(guidItem, szGuidValue, ARRAYSIZE(szGuidValue));

                //See if this item is turned off in the registry.
                if (SHRegGetBoolUSValue(REGSTR_PATH_HIDDEN_MYCOMP_ICONS, szGuidValue, FALSE, /* default */FALSE))
                    hr = S_FALSE; //They want to hide it; So, return S_FALSE.
            }
            psf2->Release();
        }
    }

    return hr;
}

STDMETHODIMP CDrivesViewCallback::GetEnumFlags(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HWND *phwnd, DWORD *pgrfFlags)
{
    return E_NOTIMPL;
}

HRESULT CDrivesViewCallback::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    SecureZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_DETAILS;
    return S_OK;
}


HRESULT CDrivesViewCallback::_CanAddRemovePrograms(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = (SHRestricted(REST_ARP_NOARP)) ? UIS_DISABLED : UIS_ENABLED;
    return S_OK;
}
    
// Note:
//  This method is NOT designed to handle multi-select cases.  If you enhance
//  the task list and wish to multi-eject (?why?), make sure you fix this up!
//
HRESULT CDrivesViewCallback::_CanEject(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = UIS_DISABLED;
    IDataObject *pdo;

    // should just use the ShellItemArray directly 

    if (psiItemArray && SUCCEEDED(psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdo))))
    {

        STGMEDIUM medium;
        LPIDA pida = DataObj_GetHIDA(pdo, &medium);
        if (pida)
        {
            ASSERT(pida->cidl == 1); // Only allow eject if a single item is selected.

            LPCIDDRIVE pidd = CDrivesFolder::_IsValidID(IDA_GetIDListPtr(pida, 0));
            if (pidd)
            {
                CMountPoint* pmtpt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));
                if (pmtpt)
                {
                    if (pmtpt->IsEjectable())
                        *puisState = UIS_ENABLED;
                    pmtpt->Release();
                }
            }

            HIDA_ReleaseStgMedium(pida, &medium);
        }

        pdo->Release();
    }


    return S_OK;
}

HRESULT CDrivesViewCallback::_CanSysProperties(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = SHRestricted(REST_MYCOMPNOPROP) ? UIS_DISABLED : UIS_ENABLED;

    return S_OK;
}

HRESULT CDrivesViewCallback::_OnSystemProperties(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDrivesViewCallback* pThis = (CDrivesViewCallback*)(void*)pv;

    return SHInvokeCommandOnPidl(pThis->_hwndMain, NULL, pThis->_pidl, 0, "properties");
}
HRESULT CDrivesViewCallback::_OnAddRemovePrograms(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    BOOL fRet = SHRunControlPanel(L"appwiz.cpl", NULL);

    return (fRet) ? S_OK : E_FAIL;
}

HRESULT CDrivesViewCallback::_CanChangeSettings(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    *puisState = SHRestricted(REST_NOCONTROLPANEL) ? UIS_DISABLED : UIS_ENABLED;

    return S_OK;
}

HRESULT CDrivesViewCallback::_OnChangeSettings(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDrivesViewCallback* pThis = (CDrivesViewCallback*)(void*)pv;

    IShellBrowser* psb;
    HRESULT hr = IUnknown_QueryService(pThis->_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &psb));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        hr = SHGetFolderLocation(NULL, CSIDL_CONTROLS, NULL, 0, &pidl); 
        if (SUCCEEDED(hr))
        {
            hr = psb->BrowseObject(pidl, 0);
            ILFree(pidl);
        }
        psb->Release();
    }

    return hr;

}

HRESULT CDrivesViewCallback::_OnEject(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    CDrivesViewCallback* pThis = (CDrivesViewCallback*)(void*)pv;
    IDataObject *pdo;
    HRESULT hr = E_FAIL;

    if (psiItemArray && SUCCEEDED(psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdo))))
    {
        hr = SHInvokeCommandOnDataObject(pThis->_hwndMain, NULL, pdo, 0, "eject");
        pdo->Release();
    }

    return hr;
}

const WVTASKITEM c_MyComputerTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_MYCOMPUTER, IDS_HEADER_MYCOMPUTER_TT);
const WVTASKITEM c_MyComputerTaskList[] =
{
    WVTI_ENTRY_ALL(CLSID_NULL,              L"shell32.dll",  IDS_TASK_MYCOMPUTER_SYSTEMPROPERTIES, IDS_TASK_MYCOMPUTER_SYSTEMPROPERTIES_TT, IDI_TASK_PROPERTIES,CDrivesViewCallback::_CanSysProperties, CDrivesViewCallback::_OnSystemProperties),
    WVTI_ENTRY_ALL(UICID_AddRemovePrograms, L"shell32.dll",  IDS_TASK_ARP,                         IDS_TASK_ARP_TT,                         IDI_CPCAT_ARP,      CDrivesViewCallback::_CanAddRemovePrograms,   CDrivesViewCallback::_OnAddRemovePrograms),
    WVTI_ENTRY_ALL(CLSID_NULL,              L"shell32.dll",  IDS_TASK_CHANGESETTINGS,              IDS_TASK_CHANGESETTINGS_TT,              IDI_CPLFLD,         CDrivesViewCallback::_CanChangeSettings,CDrivesViewCallback::_OnChangeSettings),
    WVTI_ENTRY_TITLE(CLSID_NULL,            L"shell32.dll",  0, IDS_TASK_EJECTDISK, 0,             IDS_TASK_EJECTDISK_TT,                   IDI_STEJECT,        CDrivesViewCallback::_CanEject,         CDrivesViewCallback::_OnEject),
};

HRESULT CDrivesViewCallback::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    SecureZeroMemory(pData, sizeof(*pData));

    Create_IUIElement(&c_MyComputerTaskHeader, &(pData->pFolderTaskHeader));

    // My Computer wants a different order than the default,
    // and it doesn't want to expose "Desktop" as a place to go
    LPCTSTR rgCSIDLs[] = { MAKEINTRESOURCE(CSIDL_NETWORK), MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_COMMON_DOCUMENTS), MAKEINTRESOURCE(CSIDL_CONTROLS) };
    CreateIEnumIDListOnCSIDLs(NULL, rgCSIDLs, ARRAYSIZE(rgCSIDLs), &(pData->penumOtherPlaces));

    return S_OK;
}

HRESULT CDrivesViewCallback::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    SecureZeroMemory(pTasks, sizeof(*pTasks));

    Create_IEnumUICommand((IUnknown*)(void*)this, c_MyComputerTaskList, ARRAYSIZE(c_MyComputerTaskList), &pTasks->penumFolderTasks);

    return S_OK;
}


STDAPI_(IShellFolderViewCB*) CDrives_CreateSFVCB(CDrivesFolder *pfolder)
{
    return new CDrivesViewCallback(pfolder);
}

typedef struct
{
    DWORD       dwDrivesMask;
    int         nLastFoundDrive;
    DWORD       dwRestricted;
    DWORD       dwSavedErrorMode;
    DWORD       grfFlags;
} EnumDrives;

typedef enum
{
    DRIVES_ICOL_NAME = 0,
    DRIVES_ICOL_TYPE,
    DRIVES_ICOL_CAPACITY,
    DRIVES_ICOL_FREE,
    DRIVES_ICOL_FILESYSTEM,
    DRIVES_ICOL_COMMENT,
};

const COLUMN_INFO c_drives_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,             20, IDS_NAME_COL),
    DEFINE_COL_STR_ENTRY(SCID_TYPE,             25, IDS_TYPE_COL),
    DEFINE_COL_SIZE_ENTRY(SCID_CAPACITY,            IDS_DRIVES_CAPACITY),
    DEFINE_COL_SIZE_ENTRY(SCID_FREESPACE,           IDS_DRIVES_FREE),
    DEFINE_COL_STR_MENU_ENTRY(SCID_FILESYSTEM,  15, IDS_DRIVES_FILESYSTEM),
    DEFINE_COL_STR_ENTRY(SCID_Comment,          20, IDS_EXCOL_COMMENT),
};

CDrivesFolder* CDrivesFolder::_spThis = NULL;

HRESULT CDrives_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv)
{
    HRESULT hr;
    ASSERT(NULL != ppv);
    
    ENTERCRITICAL;
    if (NULL != CDrivesFolder::_spThis)
    {
        hr = CDrivesFolder::_spThis->QueryInterface(riid, ppv);
        LEAVECRITICAL;
    }
    else
    {
        LEAVECRITICAL;
        CDrivesFolder* pDF = new CDrivesFolder(punkOuter);
        if (NULL != pDF)
        {
            ASSERT(NULL == pDF->_punkReg);

            if (SHRestricted(REST_NOCONTROLPANEL) || SHRestricted(REST_NOSETFOLDERS))
                g_asDrivesReqItems[CDRIVES_REGITEM_CONTROL].dwAttributes |= SFGAO_NONENUMERATED;

            REGITEMSINFO sDrivesRegInfo =
            {
                REGSTR_PATH_EXPLORER TEXT("\\MyComputer\\NameSpace"),
                NULL,
                TEXT(':'),
                SHID_COMPUTER_REGITEM,
                -1,
                SFGAO_CANLINK,
                ARRAYSIZE(g_asDrivesReqItems),
                g_asDrivesReqItems,
                RIISA_ORIGINAL,
                NULL,
                0,
                0,
            };

            CRegFolder_CreateInstance(&sDrivesRegInfo,
                                      (IUnknown*)(IShellFolder2*) pDF,
                                      IID_PPV_ARG(IUnknown, &pDF->_punkReg));

            if (SHInterlockedCompareExchange((void**) &CDrivesFolder::_spThis, pDF, NULL))
            {
                // Someone else snuck in and initialized a CDrivesFolder first,
                // so release our object and then recurse so we should get the other instance
                pDF->Release();
                hr = CDrives_CreateInstance(punkOuter, riid, ppv);
            }
            else
            {
                hr = pDF->QueryInterface(riid, ppv);

                // release the self-reference, but keep _spThis intact
                // (it will be reset to NULL in the destructor)
                pDF->Release();
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *ppv = NULL;
        }
    }
    return hr;
}

// This should only be called during process detach
void CDrives_Terminate(void)
{
    if (NULL != CDrivesFolder::_spThis)
    {
        delete CDrivesFolder::_spThis;
    }
}

CDrivesFolder::CDrivesFolder(IUnknown* punkOuter) : 
    CAggregatedUnknown      (punkOuter),
    _punkReg                (NULL)
{
    DllAddRef();
}

CDrivesFolder::~CDrivesFolder()
{
    SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), &_punkReg);
    SHInterlockedCompareExchange((void**) &CDrivesFolder::_spThis, NULL, this);
    DllRelease();
}

HRESULT CDrivesFolder::v_InternalQueryInterface(REFIID riid, void** ppv)
{
    static const QITAB qit[] = {
        QITABENT(CDrivesFolder, IShellFolder2),                        // IID_IShellFolder2
        QITABENTMULTI(CDrivesFolder, IShellFolder, IShellFolder2),     // IID_IShellFolder
        QITABENT(CDrivesFolder, IPersistFolder2),                      // IID_IPersistFolder2
        QITABENTMULTI(CDrivesFolder, IPersistFolder, IPersistFolder2), // IID_IPersistFolder
        QITABENTMULTI(CDrivesFolder, IPersist, IPersistFolder2),       // IID_IPersist
        QITABENTMULTI2(CDrivesFolder, IID_IPersistFreeThreadedObject, IPersist), // IID_IPersistFreeThreadedObject
        QITABENT(CDrivesFolder, IShellIconOverlay),                    // IID_IShellIconOverlay
        { 0 },
    };
    HRESULT hr;
    if (_punkReg && RegGetsFirstShot(riid))
    {
        hr = _punkReg->QueryInterface(riid, ppv);
    }
    else
    {
        hr = QISearch(this, qit, riid, ppv);
        if ((E_NOINTERFACE == hr) && _punkReg)
        {
            hr = _punkReg->QueryInterface(riid, ppv);
        }
    }
    return hr;
}

BOOL CDrivesFolder::v_HandleDelete(PLONG pcRef)
{
    ASSERT(NULL != pcRef);
    ENTERCRITICAL;

    //
    //  The same bad thing can happen here as in
    //  CNetRootFolder::v_HandleDelete.  See that function for gory details.
    //
    if (this == _spThis && 0 == *pcRef)
    {
        *pcRef = 1000; // protect against cached pointers bumping us up then down
        delete this;
    }
    LEAVECRITICAL;
    // return TRUE to indicate that we've implemented this function
    // (regardless of whether or not this object was actually deleted)
    return TRUE;
}


HRESULT CDrivesFolder::_GetDisplayName(LPCIDDRIVE pidd, LPTSTR pszName, UINT cchMax)
{
    HRESULT hr = E_FAIL;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));
    if (pMtPt)
    {
        hr = pMtPt->GetDisplayName(pszName, cchMax);
        pMtPt->Release();
    }
    return hr;
}

HRESULT CDrivesFolder::_GetDisplayNameStrRet(LPCIDDRIVE pidd, STRRET *pStrRet)
{
    HRESULT hr = E_FAIL;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));
    if (pMtPt)
    {
        TCHAR szName[MAX_DISPLAYNAME];

        hr = pMtPt->GetDisplayName(szName, ARRAYSIZE(szName));
        if (SUCCEEDED(hr))
            hr = StringToStrRet(szName, pStrRet);

        pMtPt->Release();
    }
    return hr;
}

#define REGKEY_DRIVE_FOLDEREXT L"Drive\\shellex\\FolderExtensions"

HRESULT CDrivesFolder::_CheckDriveType(int iDrive, LPCTSTR pszCLSID)
{
    HRESULT hr = E_FAIL;
    TCHAR szKey[MAX_PATH];
    StringCchCopy(szKey,  ARRAYSIZE(szKey), REGKEY_DRIVE_FOLDEREXT L"\\");
    StringCchCat(szKey,  ARRAYSIZE(szKey), pszCLSID);

    DWORD dwDriveMask;
    DWORD cb = sizeof(DWORD);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, szKey, L"DriveMask", NULL, &dwDriveMask, &cb))
    {
        TCHAR szDrive[4];
        if (PathBuildRoot(szDrive, iDrive))
        {
            int iType = GetDriveType(szDrive);
            // its possible that we're asked to parse a drive that's no longer mounted,
            // so GetDriveType will fail with DRIVE_NO_ROOT_DIR.
            // in that case, pass it on down to the handler anyway.
            // let's say it's the handler's job to remember the last drive it matched on.
            if ((DRIVE_NO_ROOT_DIR == iType) || ((1 << iType) & dwDriveMask))
            {
                hr = S_OK;
            }
        }
    }
    return hr;
}

HRESULT CDrivesFolder::_FindExtCLSID(int iDrive, CLSID *pclsid)
{
    *pclsid = CLSID_NULL;
    HRESULT hr = E_FAIL;

    HKEY hk;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, REGKEY_DRIVE_FOLDEREXT, 0, KEY_ENUMERATE_SUB_KEYS, &hk))
    {
        TCHAR szCLSID[MAX_GUID_STRING_LEN];
        for (int i = 0; FAILED(hr) && (ERROR_SUCCESS == RegEnumKey(hk, i, szCLSID, ARRAYSIZE(szCLSID))); i++) 
        {
            IDriveFolderExt *pdfe;
            if (SUCCEEDED(_CheckDriveType(iDrive, szCLSID)) &&
                SUCCEEDED(SHExtCoCreateInstance(szCLSID, NULL, NULL, IID_PPV_ARG(IDriveFolderExt, &pdfe)))) 
            {
                if (SUCCEEDED(pdfe->DriveMatches(iDrive)))
                {
                    SHCLSIDFromString(szCLSID, pclsid);
                }
                pdfe->Release();
            }

            // if we successfully matched one, break out.
            if (!IsEqualCLSID(*pclsid, CLSID_NULL))
                hr = S_OK;
        }
        RegCloseKey(hk);
    }
    return hr;
}

// this is called from parse and enum, both times passing a stack var into piddl.
// we reset the cb manually and then the callers will do ILClone to allocate the correct amount
// of memory.
HRESULT CDrivesFolder::_FillIDDrive(DRIVE_IDLIST *piddl, int iDrive, BOOL fNoCLSID, IBindCtx* pbc)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
    BOOL fDoIt = FALSE;
    
    SecureZeroMemory(piddl, sizeof(*piddl));

    PathBuildRootA(piddl->idd.cName, iDrive);

    if (S_OK == SHIsFileSysBindCtx(pbc, NULL))
    {
        fDoIt = TRUE;
    }
    else
    {
        if (BindCtx_GetMode(pbc, 0) & STGM_CREATE)
        {
            fDoIt = TRUE;
        }
        else
        {
            CMountPoint* pmtpt = CMountPoint::GetMountPoint(iDrive, FALSE);

            if (pmtpt)
            {
                fDoIt = TRUE;
                pmtpt->Release();
            }
        }
    }

    if (fDoIt)
    {
        // start the cb as the IDDRIVE less the clsid at the end
        // this is so that in the usual case when we dont have a clsid, the pidl will look
        // just like all our pidls on win2k.
        piddl->idd.cb = FIELD_OFFSET(IDDRIVE, clsid);
        piddl->idd.bFlags = SHID_COMPUTER_MISC;

        if (!fNoCLSID)
        {
            CLSID clsid;

            if (SUCCEEDED(_FindExtCLSID(iDrive, &clsid)))
            {
                piddl->idd.clsid = clsid;
                // boost the cb to include the whole thing
                piddl->idd.cb = sizeof(IDDRIVE);
                // mark the flags of the pidl to say "hey im a drive extension with a clsid"
                piddl->idd.wSig = IDDRIVE_ORDINAL_DRIVEEXT | IDDRIVE_FLAGS_DRIVEEXT_HASCLSID;
            }
        }

        hr = S_OK;
    }

    ASSERT(piddl->cbNext == 0);
    return hr;
}

STDMETHODIMP CDrivesFolder::ParseDisplayName(HWND hwnd, IBindCtx *pbc, LPOLESTR pwzDisplayName, 
                                             ULONG* pchEaten, LPITEMIDLIST* ppidlOut, ULONG* pdwAttributes)
{
    HRESULT hr = E_INVALIDARG;
    if (ppidlOut)
    {
        *ppidlOut = NULL;   // assume error

        if (pwzDisplayName && pwzDisplayName[0] && 
            pwzDisplayName[1] == TEXT(':') && pwzDisplayName[2] == TEXT('\\'))
        {
            DRIVE_IDLIST idlDrive;

            if (InRange(*pwzDisplayName, 'a', 'z') ||
                InRange(*pwzDisplayName, 'A', 'Z'))
            {
                hr = _FillIDDrive(&idlDrive, DRIVEID(pwzDisplayName), SHSkipJunctionBinding(pbc, NULL), pbc);
            }

            if (SUCCEEDED(hr))
            {
                // Check if there are any subdirs
                if (pwzDisplayName[3])
                {
                    IShellFolder *psfDrive;
                    hr = BindToObject((LPITEMIDLIST)&idlDrive, pbc, IID_PPV_ARG(IShellFolder, &psfDrive));
                    if (SUCCEEDED(hr))
                    {
                        ULONG chEaten;
                        LPITEMIDLIST pidlDir;
                        hr = psfDrive->ParseDisplayName(hwnd, pbc, pwzDisplayName + 3,
                                                        &chEaten, &pidlDir, pdwAttributes);
                        if (SUCCEEDED(hr))
                        {
                            hr = SHILCombine((LPCITEMIDLIST)&idlDrive, pidlDir, ppidlOut);
                            SHFree(pidlDir);
                        }
                        psfDrive->Release();
                    }
                }
                else
                {
                    hr = SHILClone((LPITEMIDLIST)&idlDrive, ppidlOut);
                    if (pdwAttributes && *pdwAttributes)
                        GetAttributesOf(1, (LPCITEMIDLIST *)ppidlOut, pdwAttributes);
                }
            }
        }
    }

    if (FAILED(hr))
        TraceMsg(TF_WARNING, "CDrivesFolder::ParseDisplayName(), hr:%x %ls", hr, pwzDisplayName);

    return hr;
}

BOOL IsShareable(int iDrive)
{
    return !IsRemoteDrive(iDrive);
}

class CDrivesFolderEnum : public CEnumIDListBase
{
public:
    // IEnumIDList
    STDMETHOD(Next)(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    
private:
    CDrivesFolderEnum(CDrivesFolder *psf, DWORD grfFlags);
    ~CDrivesFolderEnum();
    friend HRESULT Create_DrivesFolderEnum(CDrivesFolder* psf, DWORD grfFlags, IEnumIDList** ppenum);
    
    CDrivesFolder *_pdsf;     // CDrivesFolder object we're enumerating
    DWORD       _dwDrivesMask;
    int         _nLastFoundDrive;
    DWORD       _dwRestricted;
    DWORD       _dwSavedErrorMode;
    DWORD       _grfFlags;
};

CDrivesFolderEnum::CDrivesFolderEnum(CDrivesFolder *pdsf, DWORD grfFlags) : CEnumIDListBase()
{
    _pdsf = pdsf;
    _pdsf->AddRef();

    _dwDrivesMask = CMountPoint::GetDrivesMask();
    _nLastFoundDrive = -1;
    _dwRestricted = SHRestricted(REST_NODRIVES);
    _dwSavedErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    _grfFlags = grfFlags;
}

HRESULT Create_DrivesFolderEnum(CDrivesFolder *psf, DWORD grfFlags, IEnumIDList** ppenum)
{
    HRESULT hr;
    CDrivesFolderEnum* p= new CDrivesFolderEnum(psf, grfFlags);
    if (p)
    {
        hr = p->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
        p->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppenum = NULL;
    }
    return hr;
}

CDrivesFolderEnum::~CDrivesFolderEnum()
{
    _pdsf->Release();              // release the "this" ptr we have
}

STDMETHODIMP CDrivesFolderEnum::Next(ULONG celt, LPITEMIDLIST *ppidl, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE; // assume "no more element"
    LPITEMIDLIST pidl = NULL;

    for (int iDrive = _nLastFoundDrive + 1; iDrive < 26; iDrive++)
    {
        if (_dwRestricted & (1 << iDrive))
        {
            TraceMsg(DM_TRACE, "s.cd_ecb: Drive %d restricted.", iDrive);
        }
        else if ((_dwDrivesMask & (1 << iDrive)) || IsUnavailableNetDrive(iDrive))
        {
            if (!(SHCONTF_SHAREABLE & _grfFlags) || IsShareable(iDrive))
            {
                DRIVE_IDLIST iddrive;
                hr = _pdsf->_FillIDDrive(&iddrive, iDrive, FALSE, NULL);

                if (SUCCEEDED(hr))
                {
                    hr = SHILClone((LPITEMIDLIST)&iddrive, &pidl);
                    if (SUCCEEDED(hr))
                    {
                        CMountPoint* pmtpt = CMountPoint::GetMountPoint(iDrive, FALSE);
                        if (pmtpt)
                        {
                            pmtpt->ChangeNotifyRegisterAlias();
                            pmtpt->Release();
                        }

                        _nLastFoundDrive = iDrive;                        
                    }
                    break;
                }
                else
                {
                    hr = S_FALSE;
                }
            }
        }
    }

    *ppidl = pidl;
    if (pceltFetched)
        *pceltFetched = (S_OK == hr) ? 1 : 0;

    return hr;
}

STDMETHODIMP CDrivesFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList ** ppenum)
{
    return Create_DrivesFolderEnum(this, grfFlags, ppenum);
}

LPCIDDRIVE CDrivesFolder::_IsValidID(LPCITEMIDLIST pidl)
{
    if (pidl && (SIL_GetType(pidl) & SHID_GROUPMASK) == SHID_COMPUTER)
        return (LPCIDDRIVE)pidl;
    return NULL;
}

HRESULT CDrivesFolder::_CreateFSFolderObj(IBindCtx *pbc, LPCITEMIDLIST pidlDrive, LPCIDDRIVE pidd, REFIID riid, void **ppv)
{
    PERSIST_FOLDER_TARGET_INFO pfti = {0};

    pfti.pidlTargetFolder = (LPITEMIDLIST)pidlDrive;
    SHAnsiToUnicode(pidd->cName, pfti.szTargetParsingName, ARRAYSIZE(pfti.szTargetParsingName));
    pfti.dwAttributes = FILE_ATTRIBUTE_DIRECTORY; // maybe add system?
    pfti.csidl = -1;

    return CFSFolder_CreateFolder(NULL, pbc, pidlDrive, &pfti, riid, ppv);
}


HRESULT CDrivesFolder::_CreateFSFolder(IBindCtx *pbc, LPCITEMIDLIST pidlDrive, LPCIDDRIVE pidd, REFIID riid, void **ppv)
{
    HRESULT hr;
    CLSID clsid;
    if (S_OK == _GetCLSIDFromPidl(pidd, &clsid) && (!SHSkipJunctionBinding(pbc, NULL)))
    {
        IDriveFolderExt *pdfe;
        // SHExtCoCreateInstance since this shell extension needs to go through approval
        hr = SHExtCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IDriveFolderExt, &pdfe));
        if (SUCCEEDED(hr))
        {
            hr = pdfe->Bind(pidlDrive, pbc, riid, ppv);
            pdfe->Release();
        }
    }
    else
    {
        hr = _CreateFSFolderObj(pbc, pidlDrive, pidd, riid, ppv);
    }
    return hr;
}


STDMETHODIMP CDrivesFolder::BindToObject(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    LPCIDDRIVE pidd = _IsValidID(pidl);
    if (pidd)
    {
        LPCITEMIDLIST pidlNext = _ILNext(pidl);
        LPITEMIDLIST pidlDrive = ILCombineParentAndFirst(IDLIST_DRIVES, pidl, pidlNext);
        if (pidlDrive)
        {
            //  we only try ask for the riid at the end of the pidl binding.
            if (ILIsEmpty(pidlNext))
            {
                hr = _CreateFSFolder(pbc, pidlDrive, pidd, riid, ppv);
            }
            else
            {
                //  now we need to get the subfolder from which to grab our goodies
                IShellFolder *psfDrive;
                hr = _CreateFSFolder(pbc, pidlDrive, pidd, IID_PPV_ARG(IShellFolder, &psfDrive));
                if (SUCCEEDED(hr))
                {
                    //  this means that there is more to bind to, we must pass it on...
                    hr = psfDrive->BindToObject(pidlNext, pbc, riid, ppv);
                    psfDrive->Release();
                }
            }
            ILFree(pidlDrive);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = E_INVALIDARG;
        TraceMsg(TF_WARNING, "CDrivesFolder::BindToObject(), bad PIDL %s", DumpPidl(pidl));
    }

    return hr;
}

STDMETHODIMP CDrivesFolder::BindToStorage(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void** ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

BOOL CDrivesFolder::_GetFreeSpace(LPCIDDRIVE pidd, ULONGLONG *pSize, ULONGLONG *pFree)
{
    BOOL bRet = FALSE;
    CLSID clsid;
    if (S_OK == _GetCLSIDFromPidl(pidd, &clsid))
    {
        IDriveFolderExt *pdfe;
        // SHExtCoCreateInstance since this shell extension needs to go through approval
        if (SUCCEEDED(SHExtCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IDriveFolderExt, &pdfe))))
        {
            bRet = SUCCEEDED(pdfe->GetSpace(pSize, pFree));
            pdfe->Release();
        }
    }

    if (!bRet && !_IsReg(pidd) && ShowDriveInfo(DRIVEID(pidd->cName)))
    {
        if (pidd->qwSize || pidd->qwFree)
        {
            *pSize = pidd->qwSize;      // cache hit
            *pFree = pidd->qwFree;
            bRet = TRUE;
        }
        else
        {
            int iDrive = DRIVEID(pidd->cName);
            // Don't wake up sleeping net connections
            if (!IsRemoteDrive(iDrive) || !IsDisconnectedNetDrive(iDrive))
            {
                // Call our helper function Who understands
                // OSR2 and NT as well as old W95...
                ULARGE_INTEGER qwFreeUser, qwTotal, qwTotalFree;
                bRet = SHGetDiskFreeSpaceExA(pidd->cName, &qwFreeUser, &qwTotal, &qwTotalFree);
                if (bRet)
                {
                    *pSize = qwTotal.QuadPart;
                    *pFree = qwFreeUser.QuadPart;
                }
            }
        }
    }
    return bRet;
}

STDMETHODIMP CDrivesFolder::CompareIDs(LPARAM iCol, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPCIDDRIVE pidd1 = _IsValidID(pidl1);
    LPCIDDRIVE pidd2 = _IsValidID(pidl2);

    if (!pidd1 || !pidd2)
    {
        TraceMsg(TF_WARNING, "CDrivesFolder::CompareIDs(), bad(s) pidl11:%s, pidl2:%s", DumpPidl(pidl1), DumpPidl(pidl2));
        return E_INVALIDARG;
    }

    //  For any column other than DRIVES_ICOL_NAME, we force an
    //  all-fields comparison to break ties.
    if ((iCol & SHCIDS_COLUMNMASK) != DRIVES_ICOL_NAME) 
        iCol |= SHCIDS_ALLFIELDS;

    HRESULT hr;
    switch (iCol & SHCIDS_COLUMNMASK) 
    {
        default:                    // If asking for unknown column, just use name
        case DRIVES_ICOL_NAME:
            hr = ResultFromShort(StrCmpICA(pidd1->cName, pidd2->cName));
            break;

        case DRIVES_ICOL_TYPE:
        {
            TCHAR szName1[80], szName2[80];

            if (SHID_COMPUTER_REGITEM != pidd1->bFlags)
            {
                CMountPoint::GetTypeString(DRIVEID(pidd1->cName), szName1, ARRAYSIZE(szName1));
            }
            else
            {
                LoadString(HINST_THISDLL, IDS_DRIVES_REGITEM, szName1, ARRAYSIZE(szName1));
            }

            if (SHID_COMPUTER_REGITEM != pidd1->bFlags)
            {
                CMountPoint::GetTypeString(DRIVEID(pidd2->cName), szName2, ARRAYSIZE(szName2));
            }
            else
            {
                LoadString(HINST_THISDLL, IDS_DRIVES_REGITEM, szName2, ARRAYSIZE(szName2));
            }

            hr = ResultFromShort(ustrcmpi(szName1, szName2));
            break;
        }

        case DRIVES_ICOL_CAPACITY:
        case DRIVES_ICOL_FREE:
        {
            ULONGLONG qwSize1, qwFree1;
            ULONGLONG qwSize2, qwFree2;

            BOOL fGotInfo1 = _GetFreeSpace(pidd1, &qwSize1, &qwFree1);
            BOOL fGotInfo2 = _GetFreeSpace(pidd2, &qwSize2, &qwFree2);

            if (fGotInfo1 && fGotInfo2) 
            {
                ULONGLONG i1, i2;  // this is a "guess" at the disk size and free space

                if ((iCol & SHCIDS_COLUMNMASK) == DRIVES_ICOL_CAPACITY)
                {
                    i1 = qwSize1;
                    i2 = qwSize2;
                } 
                else 
                {
                    i1 = qwFree1;
                    i2 = qwFree2;
                }

                if (i1 == i2)
                    hr = ResultFromShort(0);
                else if (i1 < i2)
                    hr = ResultFromShort(-1);
                else
                    hr = ResultFromShort(1);
            } 
            else if (!fGotInfo1 && !fGotInfo2) 
            {
                hr = ResultFromShort(0);
            } 
            else 
            {
                hr = ResultFromShort(fGotInfo1 - fGotInfo2);
            }
            break;
        }
    }

    if (0 == HRESULT_CODE(hr))
    {
        // check if clsids are equivalent, if they're different then we're done.
        // duh... this should be checked AFTER the other checks so sort order is preserved.
        CLSID clsid1, clsid2;
        _GetCLSIDFromPidl(pidd1, &clsid1);
        _GetCLSIDFromPidl(pidd2, &clsid2);
        hr = ResultFromShort(memcmp(&clsid1, &clsid2, sizeof(CLSID)));
    }

    // if they were the same so far, and we forcing an all-fields
    // comparison, then use the all-fields comparison to break ties.
    if ((0 == HRESULT_CODE(hr)) && (iCol & SHCIDS_ALLFIELDS))
    {
        hr = CompareItemIDs(pidd1, pidd2);
    }

    //  If the items are still the same, then ask ILCompareRelIDs
    //  to walk recursively to the next ids.
    if (0 == HRESULT_CODE(hr))
    {
        hr = ILCompareRelIDs(SAFECAST(this, IShellFolder *), pidl1, pidl2, iCol);
    }

    return hr;
}

STDAPI CDrivesDropTarget_Create(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);

STDMETHODIMP CDrivesFolder::CreateViewObject(HWND hwnd, REFIID riid, void** ppv)
{
    // We should not get here unless we have initialized properly
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellView))
    {
        SFV_CREATE sSFV;

        sSFV.cbSize   = sizeof(sSFV);
        sSFV.psvOuter = NULL;
        sSFV.psfvcb   = CDrives_CreateSFVCB(this);

        QueryInterface(IID_PPV_ARG(IShellFolder, &sSFV.pshf));   // in case we are agregated

        hr = SHCreateShellFolderView(&sSFV, (IShellView**)ppv);

        if (sSFV.pshf)
            sSFV.pshf->Release();

        if (sSFV.psfvcb)
            sSFV.psfvcb->Release();
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = CDrivesDropTarget_Create(hwnd, IDLIST_DRIVES, (IDropTarget **)ppv);
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        LPITEMIDLIST pidlFolder;
        if (SUCCEEDED(GetCurFolder(&pidlFolder)))
        {
            IContextMenuCB *pcmcb = new CDrivesBackgroundMenuCB(pidlFolder);
            if (pcmcb) 
            {
                hr = CDefFolderMenu_Create2Ex(IDLIST_DRIVES, hwnd, 0, NULL, SAFECAST(this, IShellFolder*), pcmcb, 
                                              0, NULL, (IContextMenu **)ppv);
                pcmcb->Release();
            }
            ILFree(pidlFolder);
        }
    }
    else if (IsEqualIID(riid, IID_ICategoryProvider))
    {
        HKEY hk = NULL;

        BEGIN_CATEGORY_LIST(s_DriveCategories)
        CATEGORY_ENTRY_SCIDMAP(SCID_CAPACITY, CLSID_DriveSizeCategorizer)
        CATEGORY_ENTRY_SCIDMAP(SCID_TYPE, CLSID_DriveTypeCategorizer)
        CATEGORY_ENTRY_SCIDMAP(SCID_FREESPACE, CLSID_FreeSpaceCategorizer)
        END_CATEGORY_LIST()

        RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("Drive\\shellex\\Category"), 0, KEY_READ, &hk);
        hr = CCategoryProvider_Create(&CLSID_DetailCategorizer, &SCID_TYPE, hk, s_DriveCategories, this, riid, ppv);
        if (hk)
            RegCloseKey(hk);
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* prgfInOut)
{
    UINT rgfOut = SFGAO_HASSUBFOLDER | SFGAO_CANLINK | SFGAO_CANCOPY | 
                  SFGAO_DROPTARGET | SFGAO_HASPROPSHEET | SFGAO_FOLDER | SFGAO_STORAGE | 
                  SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR;

    if (cidl == 0)
    {
        // We are getting the attributes for the "MyComputer" folder itself.
        rgfOut = (*prgfInOut & g_asDesktopReqItems[CDESKTOP_REGITEM_DRIVES].dwAttributes);
    }
    else if (cidl == 1)
    {
        TCHAR szDrive[MAX_PATH];
        LPCIDDRIVE pidd = _IsValidID(apidl[0]);

        if (!pidd)
            return E_INVALIDARG;

        CMountPoint* pmtpt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));

        if (pmtpt)
        {
            SHAnsiToTChar(pidd->cName, szDrive, ARRAYSIZE(szDrive));

            if (*prgfInOut & SFGAO_VALIDATE)
            {
                // (tybeam) todo: make this extensible to validate through the clsid object
                // ill do this when i break everything out into IDriveFolderExt or whatever
                CLSID clsid;
                if (S_OK != _GetCLSIDFromPidl(pidd, &clsid))
                {
                    DWORD dwAttribs;
                    if (!PathFileExistsAndAttributes(szDrive, &dwAttribs))
                        return E_FAIL;
                }
            }

            // If caller wants compression status, we need to ask the filesystem

            if (*prgfInOut & SFGAO_COMPRESSED)
            {
                // Don't wake up sleeping net connections
                if (!pmtpt->IsRemote() || !pmtpt->IsDisconnectedNetDrive())
                {
                    if (pmtpt->IsCompressed())
                    {
                        rgfOut |= SFGAO_COMPRESSED;
                    }
                }
            }

            if (*prgfInOut & SFGAO_SHARE)
            {
                if (!pmtpt->IsRemote())
                {
                    if (IsShared(szDrive, FALSE))
                        rgfOut |= SFGAO_SHARE;
                }

            }

            if ((*prgfInOut & SFGAO_REMOVABLE) &&
                (pmtpt->IsStrictRemovable() || pmtpt->IsFloppy() ||
                pmtpt->IsCDROM()))
            {
                rgfOut |= SFGAO_REMOVABLE;
            }

            // we need to also handle the SFGAO_READONLY bit.
            if (*prgfInOut & SFGAO_READONLY)
            {
                DWORD dwAttributes = pmtpt->GetAttributes();
        
                if (dwAttributes != -1 && dwAttributes & FILE_ATTRIBUTE_READONLY)
                    rgfOut |= SFGAO_READONLY;
            }

            // Should we add the write protect stuff and readonly?
            if ((*prgfInOut & SFGAO_CANRENAME) &&
                (pmtpt->IsStrictRemovable() || pmtpt->IsFloppy() ||
                pmtpt->IsFixedDisk() || pmtpt->IsRemote()) ||
                pmtpt->IsDVDRAMMedia())
            {
                rgfOut |= SFGAO_CANRENAME;
            }

            // Is a restriction causing this drive to not be enumerated?
            if (*prgfInOut & SFGAO_NONENUMERATED)
            {
                DWORD dwRestricted = SHRestricted(REST_NODRIVES);
                if (dwRestricted)
                {
                    if (((1 << DRIVEID(pidd->cName)) & dwRestricted))
                    {
                        rgfOut |= SFGAO_NONENUMERATED;
                    }
                }
            }

            // We want to allow moving volumes for bulk copy from some media
            // such as dragging pictures from a compact flash to the my pictures
            // folder.
            if (*prgfInOut & SFGAO_CANMOVE)
            {
                if (pmtpt->IsStrictRemovable() || pmtpt->IsFloppy())
                    rgfOut |= SFGAO_CANMOVE;
            }

            if (*prgfInOut & SFGAO_HASPROPSHEET)
            {
                if (!pmtpt->IsMounted())
                {
                    // Drive is dismounted.  Sometimes touching it will remount it.
                    // Don't use the pmtpt call, we really want to touch it.
                    if (0xFFFFFFFF == GetFileAttributes(szDrive))
                    {
                        // Failed, check GLE
                        if (ERROR_NOT_READY == GetLastError())
                        {
                            // We get this error on Cluster system, where the drive
                            // was passed to the other node.
                            rgfOut &= ~SFGAO_HASPROPSHEET;
                        }
                    }
                }
            }

            pmtpt->Release();
        }
    }

    *prgfInOut = rgfOut;
    return S_OK;
}

HRESULT CDrivesFolder::_GetEditTextStrRet(LPCIDDRIVE pidd, STRRET *pstr)
{
    HRESULT hr = E_FAIL;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));
    if (pMtPt)
    {
        TCHAR szEdit[MAX_PATH];
        hr = pMtPt->GetLabel(szEdit, ARRAYSIZE(szEdit));
        if (SUCCEEDED(hr))
            hr = StringToStrRet(szEdit, pstr);
        pMtPt->Release();
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET* pStrRet)
{
    HRESULT hr;
    LPCIDDRIVE pidd = _IsValidID(pidl);
    if (pidd)
    {
        TCHAR szDrive[ARRAYSIZE(pidd->cName)];
        LPCITEMIDLIST pidlNext = _ILNext(pidl); // Check if pidl contains more than one ID

        SHAnsiToTChar(pidd->cName, szDrive, ARRAYSIZE(szDrive));

        if (ILIsEmpty(pidlNext))
        {
            if (uFlags & SHGDN_FORPARSING)
            {
                hr = StringToStrRet(szDrive, pStrRet);
            }
            else if (uFlags & SHGDN_FOREDITING)
            {
                hr = _GetEditTextStrRet(pidd, pStrRet);
            }
            else
                hr = _GetDisplayNameStrRet(pidd, pStrRet);
        }
        else
        {
            LPITEMIDLIST pidlDrive = ILCombineParentAndFirst(IDLIST_DRIVES, pidl, pidlNext);
            if (pidlDrive)
            {
                //  now we need to get the subfolder from which to grab our goodies
                IShellFolder *psfDrive;
                hr = _CreateFSFolder(NULL, pidlDrive, pidd, IID_PPV_ARG(IShellFolder, &psfDrive));
                if (SUCCEEDED(hr))
                {
                    hr = psfDrive->GetDisplayNameOf(pidlNext, uFlags, pStrRet);
                    psfDrive->Release();
                }
                ILFree(pidlDrive);
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
        TraceMsg(TF_WARNING, "CDrivesFolder::GetDisplayNameOf() bad PIDL %s", DumpPidl(pidl));
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, 
                                      LPCWSTR pszName, DWORD dwReserved, LPITEMIDLIST* ppidlOut)
{
    if (ppidlOut)
        *ppidlOut = NULL;

    HRESULT hr = E_INVALIDARG;
    LPCIDDRIVE pidd = _IsValidID(pidl);
    if (pidd)
    {
        hr = SetDriveLabel(hwnd, NULL, DRIVEID(pidd->cName), pszName);
        if (SUCCEEDED(hr) && ppidlOut)
        {
            *ppidlOut = ILClone(pidl);
        }
    }
    return hr;
}


class CDriveAssocEnumData : public CEnumAssociationElements 
{
public:
    CDriveAssocEnumData(int iDrive) : _iDrive(iDrive) {}
 
private:
    virtual BOOL _Next(IAssociationElement **ppae);
    
    int _iDrive;
    DWORD _dwChecked;
};

enum 
{
    DAED_CHECK_KEY      = 0x0001,
    DAED_CHECK_CDORDVD  = 0x0002,
    DAED_CHECK_TYPE     = 0x0004,
};

BOOL CDriveAssocEnumData::_Next(IAssociationElement **ppae)
{
    HRESULT hr = E_FAIL;
    CMountPoint* pmtpt = CMountPoint::GetMountPoint(_iDrive);
    if (pmtpt)
    {
        if (!(_dwChecked & DAED_CHECK_KEY))
        {
            HKEY hk = pmtpt->GetRegKey();
            if (hk)
            {
                hr = AssocElemCreateForKey(&CLSID_AssocShellElement, hk, ppae);
                RegCloseKey(hk);
            }
            _dwChecked |= DAED_CHECK_KEY;
        }

        if (FAILED(hr) && !(_dwChecked & DAED_CHECK_CDORDVD))
        {
            PCWSTR psz = NULL;
            if (pmtpt->IsAudioCD())
                psz = L"AudioCD";
            else if (pmtpt->IsDVD())
                psz = L"DVD";

            if (psz)
            {
                hr = AssocElemCreateForClass(&CLSID_AssocProgidElement, psz, ppae);
            }
            _dwChecked |= DAED_CHECK_CDORDVD;
        }

        if (FAILED(hr) && !(_dwChecked & DAED_CHECK_TYPE))
        {
            hr = pmtpt->GetAssocSystemElement(ppae);
            _dwChecked |= DAED_CHECK_TYPE;
        }
        
        pmtpt->Release();
    }

    return SUCCEEDED(hr);
}

STDAPI_(BOOL) TBCContainsObject(LPCWSTR pszKey)
{
    IUnknown *punk;
    if (SUCCEEDED(TBCGetObjectParam(pszKey, IID_PPV_ARG(IUnknown, &punk))))
    {
        punk->Release();
        return TRUE;
    }
    return FALSE;
}

HRESULT CDrives_AssocCreate(PCSTR pszName, REFIID riid, void **ppv)
{
    *ppv = NULL;
    IAssociationArrayInitialize *paai;
    HRESULT hr = ::AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IAssociationArrayInitialize, &paai));
    if (SUCCEEDED(hr))
    {
        hr = paai->InitClassElements(ASSOCELEM_BASEIS_FOLDER, L"Drive");
        if (SUCCEEDED(hr) && pszName && !TBCContainsObject(L"ShellExec SHGetAssociations"))
        {
            IEnumAssociationElements *penum = new CDriveAssocEnumData(DRIVEID(pszName));
            if (penum)
            {
                paai->InsertElements(ASSOCELEM_DATA, penum);
                penum->Release();
            }
        }

        if (SUCCEEDED(hr))
            hr = paai->QueryInterface(riid, ppv);

        paai->Release();
    }

    return hr;
}

STDAPI_(DWORD) CDrives_GetKeys(PCSTR pszName, HKEY *rgk, UINT ck)
{
    IAssociationArray *paa;
    HRESULT hr = CDrives_AssocCreate(pszName, IID_PPV_ARG(IAssociationArray, &paa));
    if (SUCCEEDED(hr))
    {
        ck = SHGetAssocKeysEx(paa, -1, rgk, ck);
        paa->Release();
    }
    else
        ck = 0;
    return ck;
}

STDMETHODIMP CDrivesFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl,
                                          REFIID riid, UINT* prgfInOut, void** ppv)
{
    HRESULT hr;
    LPCIDDRIVE pidd = (cidl && apidl) ? _IsValidID(apidl[0]) : NULL;

    *ppv = NULL;

    if (!pidd)
        return E_INVALIDARG;

    if (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW) && pidd)
    {
        WCHAR szDrive[MAX_PATH];

        SHAnsiToUnicode(pidd->cName, szDrive, ARRAYSIZE(szDrive));

        hr = SHCreateDrvExtIcon(szDrive, riid, ppv);
    }
    else
    {
        if (IsEqualIID(riid, IID_IContextMenu))
        {
            HKEY rgk[MAX_ASSOC_KEYS];
            DWORD ck = CDrives_GetKeys(pidd->cName, rgk, ARRAYSIZE(rgk));
            hr = CDefFolderMenu_Create2(IDLIST_DRIVES, hwnd, cidl, apidl, 
                SAFECAST(this, IShellFolder *), CDrives_DFMCallBack, ck, rgk, (IContextMenu **)ppv);

            SHRegCloseKeys(rgk, ck);
        }
        else if (IsEqualIID(riid, IID_IDataObject))
        {
            hr = SHCreateFileDataObject(IDLIST_DRIVES, cidl, apidl, NULL, (IDataObject **)ppv);
        }
        else if (IsEqualIID(riid, IID_IDropTarget))
        {
            IShellFolder *psfT;
            hr = BindToObject((LPCITEMIDLIST)pidd, NULL, IID_PPV_ARG(IShellFolder, &psfT));
            if (SUCCEEDED(hr))
            {
                hr = psfT->CreateViewObject(hwnd, IID_IDropTarget, ppv);
                psfT->Release();
            }
        }
        else if (IsEqualIID(riid, IID_IQueryInfo))
        {
            // REVIEW: Shouldn't we use IQA to determine the "prop" string dynamically??? (ZekeL / BuzzR)
            hr = CreateInfoTipFromItem(SAFECAST(this, IShellFolder2 *), (LPCITEMIDLIST)pidd, L"prop:FreeSpace;Capacity", riid, ppv);
        }
        else if (IsEqualIID(riid, IID_IQueryAssociations)
               || IsEqualIID(riid, IID_IAssociationArray))
        {
            hr = CDrives_AssocCreate(pidd->cName, riid, ppv);
        }
        else 
        {
            hr = E_NOINTERFACE;
        }
    }

    return hr;
}

STDMETHODIMP CDrivesFolder::GetDefaultSearchGUID(GUID *pGuid)
{
    return DefaultSearchGUID(pGuid);
}

STDMETHODIMP CDrivesFolder::EnumSearches(IEnumExtraSearch **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CDrivesFolder::GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDrivesFolder::GetDefaultColumnState(UINT iColumn, DWORD* pdwState)
{
    HRESULT hr;

    if (iColumn < ARRAYSIZE(c_drives_cols))
    {
        *pdwState = c_drives_cols[iColumn].csFlags;
        if (iColumn == DRIVES_ICOL_COMMENT)
        {
            *pdwState |= SHCOLSTATE_SLOW; // It takes a long time to extract the comment from drives
        }
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv)
{
    HRESULT hr = E_INVALIDARG;
    LPCIDDRIVE pidd = _IsValidID(pidl);
    if (pidd)
    {
        if (IsEqualSCID(*pscid, SCID_DESCRIPTIONID))
        {
            SHDESCRIPTIONID did;
            CMountPoint* pmtpt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));

            if (pmtpt)
            {
                did.dwDescriptionId = pmtpt->GetShellDescriptionID();

                pmtpt->Release();
            }
            else
            {
                did.dwDescriptionId = SHDID_COMPUTER_OTHER;
            }

            did.clsid = CLSID_NULL;
            hr = InitVariantFromBuffer(pv, &did, sizeof(did));
        }
        else if (IsEqualSCID(*pscid, SCID_DetailsProperties))
        {
            // DUI webview properties
            // shouldnt we use IQA??? - ZekeL
            hr = InitVariantFromStr(pv, TEXT("prop:Name;Type;FileSystem;FreeSpace;Capacity"));
        }
        else
        {
            int iCol = FindSCID(c_drives_cols, ARRAYSIZE(c_drives_cols), pscid);
            if (iCol >= 0)
            {
                switch (iCol)
                {
                case DRIVES_ICOL_CAPACITY:
                case DRIVES_ICOL_FREE:
                    {
                        ULONGLONG ullSize, ullFree;
                        hr = E_FAIL;
                        if (_GetFreeSpace(pidd, &ullSize, &ullFree))
                        {
                            pv->vt = VT_UI8;
                            pv->ullVal = iCol == DRIVES_ICOL_CAPACITY ? ullSize : ullFree;
                            hr = S_OK;
                        }
                    }
                    break;

                default:
                    {
                        SHELLDETAILS sd;

                        hr = GetDetailsOf(pidl, iCol, &sd);
                        if (SUCCEEDED(hr))
                        {
                            hr = InitVariantFromStrRet(&sd.str, pidl, pv);
                        }
                    }
                }
            }
        }
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
{
    TCHAR szTemp[INFOTIPSIZE];
    szTemp[0] = 0;
    
    pDetails->str.uType = STRRET_CSTR;
    pDetails->str.cStr[0] = 0;
    
    if (!pidl)
    {
        return GetDetailsOfInfo(c_drives_cols, ARRAYSIZE(c_drives_cols), iColumn, pDetails);
    }

    LPCIDDRIVE pidd = _IsValidID(pidl);
    ASSERTMSG(pidd != NULL, "someone passed us a bad pidl");
    if (!pidd)
        return E_FAIL;  // protect faulting code below
    
    switch (iColumn)
    {
    case DRIVES_ICOL_NAME:
        _GetDisplayName(pidd, szTemp, ARRAYSIZE(szTemp));
        break;
        
    case DRIVES_ICOL_TYPE:
        CMountPoint::GetTypeString(DRIVEID(pidd->cName), szTemp, ARRAYSIZE(szTemp));
        break;
        
    case DRIVES_ICOL_COMMENT:
        GetDriveComment(DRIVEID(pidd->cName), szTemp, ARRAYSIZE(szTemp));
        break;

    case DRIVES_ICOL_CAPACITY:
    case DRIVES_ICOL_FREE:
        {
            ULONGLONG ullSize, ullFree;

            if (_GetFreeSpace(pidd, &ullSize, &ullFree))
            {
                StrFormatByteSize64((iColumn == DRIVES_ICOL_CAPACITY) ? ullSize : ullFree, szTemp, ARRAYSIZE(szTemp));
            }
        }
        break;
    case DRIVES_ICOL_FILESYSTEM:
        {
            CMountPoint* pMtPt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));
            if (pMtPt)
            {
                WCHAR szFileSysName[MAX_FILESYSNAME];
                // GetFileSystemName hits the disk for floppies so disable it.
                // since this is a perf win for defview but disables some functionality, it means
                // do NOT rely on the namespace for getting filesystem information, go direct to
                // the mountpoint instead.  if filefldr ever supports SCID_FILESYSTEM like
                // SCID_FREESPACE then this should be munged around.
                if (!pMtPt->IsFloppy() && pMtPt->GetFileSystemName(szFileSysName, ARRAYSIZE(szFileSysName)))
                {
                    StringCchCopy(szTemp, min(ARRAYSIZE(szTemp), ARRAYSIZE(szFileSysName)), szFileSysName);
                }
                pMtPt->Release();
            }
        }
        break;

    }
    return StringToStrRet(szTemp, &pDetails->str);
}

HRESULT CDrivesFolder::MapColumnToSCID(UINT iColumn, SHCOLUMNID* pscid)
{
    return MapColumnToSCIDImpl(c_drives_cols, ARRAYSIZE(c_drives_cols), iColumn, pscid);
}

STDMETHODIMP CDrivesFolder::GetClassID(CLSID* pCLSID)
{
    *pCLSID = CLSID_MyComputer;
    return S_OK;
}

STDMETHODIMP CDrivesFolder::Initialize(LPCITEMIDLIST pidl)
{
    // Only allow the Drives root on the desktop
    ASSERT(AssertIsIDListInNameSpace(pidl, &CLSID_MyComputer) && ILIsEmpty(_ILNext(pidl)));
    return S_OK;
}

STDMETHODIMP CDrivesFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    return GetCurFolderImpl(IDLIST_DRIVES, ppidl);
}

STDMETHODIMP CDrivesFolder::_GetIconOverlayInfo(LPCIDDRIVE pidd, int *pIndex, DWORD dwFlags)
{
    IShellIconOverlayManager *psiom;
    HRESULT hr = GetIconOverlayManager(&psiom);
    if (SUCCEEDED(hr))
    {
        WCHAR wszDrive[10];
        SHAnsiToUnicode(pidd->cName, wszDrive, ARRAYSIZE(wszDrive));
        if (IsShared(wszDrive, FALSE))
        {
            hr = psiom->GetReservedOverlayInfo(wszDrive, 0, pIndex, SIOM_OVERLAYINDEX, SIOM_RESERVED_SHARED);
        }
        else
        {
            hr = psiom->GetFileOverlayInfo(wszDrive, 0, pIndex, dwFlags);
        }            
        psiom->Release();
    }
    return hr;
}    

STDMETHODIMP CDrivesFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    HRESULT hr = E_FAIL;
    LPCIDDRIVE pidd = _IsValidID(pidl);
    if (pidd)
    {
        hr = _GetIconOverlayInfo(pidd, pIndex, SIOM_OVERLAYINDEX);
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    HRESULT hr = E_FAIL;
    LPCIDDRIVE pidd = _IsValidID(pidl);
    if (pidd)
    {
        hr = _GetIconOverlayInfo(pidd, pIndex, SIOM_ICONINDEX);
    }
    return hr;
}

STDMETHODIMP CDrivesFolder::CompareItemIDs(LPCIDDRIVE pidd1, LPCIDDRIVE pidd2)
{
    // Compare the drive letter for sorting purpose.
    int iRes = StrCmpICA(pidd1->cName, pidd2->cName);   // don't need local goo

    // then, compare pidl sizes
    if (iRes == 0)
    {
        iRes = pidd1->cb - pidd2->cb;
    }

    // still equal, compare clsids if both pidls are big and have them
    if ((iRes == 0) && (pidd1->cb >= sizeof(IDDRIVE)))
    {
        iRes = memcmp(&pidd1->clsid, &pidd2->clsid, sizeof(CLSID));
    }

    // still equal, compare on bFlags
    if (iRes == 0)
    {
        iRes = pidd1->bFlags - pidd2->bFlags;
    }
    return ResultFromShort(iRes);
}

HRESULT CDrivesFolder::_OnChangeNotify(LPARAM lNotification, LPCITEMIDLIST *ppidl)
{
    // Get to the last part of this id list...
    if ((lNotification != SHCNE_DRIVEADD) || (ppidl == NULL) || (*ppidl == NULL))
        return S_OK;

    DWORD dwRestricted = SHRestricted(REST_NODRIVES);
    if (dwRestricted == 0)
        return S_OK;   // no drives restricted... (majority case)

    LPCIDDRIVE pidd = (LPCIDDRIVE)ILFindLastID(*ppidl);

    if (((1 << DRIVEID(pidd->cName)) & dwRestricted))
    {
        TraceMsg(DM_TRACE, "Drive not added due to restrictions or Drivespace says it should be hidden");
        return S_FALSE;
    }
    return S_OK;
}

CDrivesBackgroundMenuCB::CDrivesBackgroundMenuCB(LPITEMIDLIST pidlFolder) : _cRef(1)
{
    _pidlFolder = ILClone(pidlFolder);
}

CDrivesBackgroundMenuCB::~CDrivesBackgroundMenuCB()
{
    ILFree(_pidlFolder);
}

STDMETHODIMP CDrivesBackgroundMenuCB::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDrivesBackgroundMenuCB, IContextMenuCB), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CDrivesBackgroundMenuCB::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CDrivesBackgroundMenuCB::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CDrivesBackgroundMenuCB::_GetHelpText(UINT offset, BOOL bWide, LPARAM lParam, UINT cch)
{
    UINT idRes = IDS_MH_FSIDM_FIRST + offset;
    if (bWide)
        LoadStringW(HINST_THISDLL, idRes, (LPWSTR)lParam, cch);
    else
        LoadStringA(HINST_THISDLL, idRes, (LPSTR)lParam, cch);

    return S_OK;
}


STDMETHODIMP CDrivesBackgroundMenuCB::CallBack (IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg) 
    {
    case DFM_MERGECONTEXTMENU_BOTTOM:
        if (!(wParam & (CMF_VERBSONLY | CMF_DVFILE)))
        {
            DWORD dwAttr = SFGAO_HASPROPSHEET;
            if (FAILED(SHGetAttributesOf(_pidlFolder, &dwAttr)) ||
                SFGAO_HASPROPSHEET & dwAttr)
            {
                CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_PROPERTIES_BG, 0, (LPQCMINFO)lParam);
            }
        }
        break;

    case DFM_GETHELPTEXT:
    case DFM_GETHELPTEXTW:
        hr = _GetHelpText(LOWORD(wParam), uMsg == DFM_GETHELPTEXTW, lParam, HIWORD(wParam));
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case FSIDM_PROPERTIESBG:
            SHRunControlPanel(TEXT("SYSDM.CPL"), hwndOwner);
            break;

        default:
            hr = S_FALSE;
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\drives.h ===
#ifndef _DRIVES_H_
#define _DRIVES_H_

// "Public" exports from drivex.c
STDAPI_(UINT) CDrives_GetDriveType(int iDrive);
STDAPI_(DWORD) CDrives_GetKeys(PCSTR pszDrive, HKEY *keys, UINT ckeys);

STDAPI_(void) CDrives_Terminate(void);
STDAPI CDrives_DFMCallBackBG(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg,  WPARAM wParam, LPARAM lParam);
STDAPI CDrives_DFMCallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg,  WPARAM wParam, LPARAM lParam);

#define MAX_LABEL_NTFS      32  // not including the NULL
#define MAX_LABEL_FAT       11  // not including the NULL

STDAPI_(UINT) GetMountedVolumeIcon(LPCTSTR pszMountPoint, LPTSTR pszModule, DWORD cchModule);
STDAPI SetDriveLabel(HWND hwnd, IUnknown* punkEnableModless, int iDrive, LPCTSTR pszDriveLabel);
STDAPI GetDriveComment(int iDrive, LPTSTR pszComment, int cchComment);
STDAPI_(BOOL) IsUnavailableNetDrive(int iDrive);
STDAPI_(BOOL) DriveIOCTL(LPTSTR pszDrive, int cmd, void *pvIn, DWORD dwIn, void *pvOut, DWORD dwOut);
STDAPI_(BOOL) ShowMountedVolumeProperties(LPCTSTR pszMountedVolume, HWND hwndParent);

STDAPI SHCreateDrvExtIcon(LPCWSTR pszDrive, REFIID riid, void** ppvOut);

// Globals from drivesx.c

EXTERN_C const ICONMAP c_aicmpDrive[];
EXTERN_C const int c_nicmpDrives;

#endif // _DRIVES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\drivxicon.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "pidl.h"
#include "ids.h"
#include "drives.h"
#include "mtpt.h"
#include "shitemid.h"
#include "xiconwrap.h"
#include "hwcmmn.h"

// From drivfldr.cpp
int _GetSHID(int iDrive);

class CDrvExtIconBase : public CExtractIconBase
{
public:
    HRESULT _GetIconLocationW(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int *piIndex, UINT *pwFlags);
    HRESULT _ExtractW(LPCWSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);

    HRESULT _Init(LPCWSTR pszDrive)
    {
        _pszDrive = StrDup(pszDrive);
        return _pszDrive ? S_OK : E_OUTOFMEMORY;
    }

    CDrvExtIconBase() : CExtractIconBase(), _pszDrive(NULL) {}

protected:
    ~CDrvExtIconBase();

private:
    LPWSTR _pszDrive;
};

CDrvExtIconBase::~CDrvExtIconBase()
{
    LocalFree((HLOCAL)_pszDrive);   // accepts NULL
}


STDAPI SHCreateDrvExtIcon(LPCWSTR pszDrive, REFIID riid, void **ppv)
{
    HRESULT hr;
    CDrvExtIconBase* pdeib = new CDrvExtIconBase();
    if (pdeib)
    {
        hr = pdeib->_Init(pszDrive);
        if (SUCCEEDED(hr))
            hr = pdeib->QueryInterface(riid, ppv);
        pdeib->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CDrvExtIconBase::_GetIconLocationW(UINT uFlags, LPWSTR pszIconFile,
    UINT cchMax, int *piIndex, UINT *pwFlags)
{
    HRESULT hr = S_OK;
    pszIconFile[0] = 0;

    if (uFlags & GIL_DEFAULTICON)
    {
        *piIndex = CMountPoint::GetSuperPlainDriveIcon(_pszDrive,
            GetDriveType(_pszDrive));

        hr = StringCchCopy(pszIconFile, cchMax, TEXT("shell32.dll"));

        *pwFlags = GIL_PERCLASS;

        // Make sure our default icon makes it to the cache
        Shell_GetCachedImageIndex(c_szShell32Dll, *piIndex, *pwFlags);
    }
    else
    {
        if (!(uFlags & GIL_ASYNC))
        {
            CMountPoint* pmtpt = CMountPoint::GetMountPoint(_pszDrive);

            if (pmtpt)
            {
                *piIndex = pmtpt->GetIcon(pszIconFile, cchMax);

                if (!*pszIconFile)
                {
                    GetModuleFileName(HINST_THISDLL, pszIconFile, cchMax);
                }

                pmtpt->StoreIconForUpdateImage(Shell_GetCachedImageIndex(
                    pszIconFile, *piIndex, 0));

                pmtpt->Release();
            }
            else
            {
                *piIndex = CMountPoint::GetSuperPlainDriveIcon(_pszDrive,
                    GetDriveType(_pszDrive));

                hr = StringCchCopy(pszIconFile, cchMax, TEXT("shell32.dll"));
            }

            *pwFlags = GIL_PERCLASS;
        }
        else
        {
            hr = E_PENDING;
        }
    }

    return hr;
}

HRESULT CDrvExtIconBase::_ExtractW(LPCWSTR pszFile, UINT nIconIndex,
    HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    return SHDefExtractIcon(pszFile, nIconIndex, GIL_PERCLASS, phiconLarge,
            phiconSmall, nIconSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\drvx.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <hwtab.h>
#include "fstreex.h"
#include "views.h"
#include "drives.h"
#include "propsht.h"
#include "infotip.h"
#include "datautil.h"
#include "netview.h"
#include "bitbuck.h"
#include "drawpie.h"
#include "shitemid.h"
#include "devguid.h"
#include "ids.h"
#include "idldrop.h"
#include "util.h"
#include "shcombox.h"
#include "hwcmmn.h"
#include "prop.h"

#include "mtpt.h"
#include "ftascstr.h"   // for CFTAssocStore
#include "ascstr.h"     // for IAssocInfo class
#include "apdlg.h"
#include "cdburn.h"

#define REL_KEY_DEFRAG TEXT("MyComputer\\defragpath")
#define REL_KEY_BACKUP TEXT("MyComputer\\backuppath")

///////////////////////////////////////////////////////////////////////////////
// Begin: Old C fct required externally
///////////////////////////////////////////////////////////////////////////////
STDAPI_(int) RealDriveTypeFlags(int iDrive, BOOL fOKToHitNet)
{
    int iType = DRIVE_NO_ROOT_DIR;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive, TRUE, fOKToHitNet);

    if (pMtPt)
    {
        WCHAR szDrive[4];

        iType = GetDriveType(PathBuildRoot(szDrive, iDrive));
        iType |= pMtPt->GetDriveFlags();
        iType |= pMtPt->GetVolumeFlags();
        pMtPt->Release();
    }

    return iType;    
}

STDAPI_(int) RealDriveType(int iDrive, BOOL fOKToHitNet)
{
    WCHAR szDrive[4];

    return GetDriveType(PathBuildRoot(szDrive, iDrive)) & DRIVE_TYPE;    
}

STDAPI_(int) DriveType(int iDrive)
{
    return RealDriveType(iDrive, TRUE);
}

STDAPI_(DWORD) PathGetClusterSize(LPCTSTR pszPath)
{
    static TCHAR s_szRoot[MAX_PATH] = {'\0'};
    static int   s_nszRootLen = 0;
    static DWORD s_dwSize = 0;

    DWORD dwSize = 0;

    // Do we have a cache hit?  No need to hit the net if we can avoid it...
    if (s_nszRootLen)
    {
        ENTERCRITICAL;
        if (wcsncmp(pszPath, s_szRoot, s_nszRootLen) == 0)
        {
            dwSize = s_dwSize;
        }
        LEAVECRITICAL;
    }

    if (0 == dwSize)
    {
        TCHAR szRoot[MAX_PATH];

        StringCchCopy(szRoot, ARRAYSIZE(szRoot), pszPath);
        PathStripToRoot(szRoot);

        if (PathIsUNC(szRoot))
        {
            DWORD dwSecPerClus, dwBytesPerSec, dwClusters, dwTemp;

            if (PathAddBackslash(szRoot))
            {
                if (GetDiskFreeSpace(szRoot, &dwSecPerClus, &dwBytesPerSec, &dwTemp, &dwClusters))
                {
                    dwSize = dwSecPerClus * dwBytesPerSec;
                }
            }
            //  else dwSize which will get fixed below and the string compare-N above
            //  will still be reasonable.
        }
        else
        {
            CMountPoint* pMtPt = CMountPoint::GetMountPoint(pszPath);

            if (pMtPt)
            {
                dwSize = pMtPt->GetClusterSize();
                pMtPt->Release();
            }
        }

        // Sometimes on Millennium, we get 0 as the cluster size.
        // Reason unknown.  Sanitize the value so we don't go insane.
        if (dwSize == 0)
            dwSize = 512;

        // Remember this for later - chances are we'll be queried for the same drive again
        ENTERCRITICAL;
        StringCchCopy(s_szRoot, ARRAYSIZE(s_szRoot), szRoot);
        s_nszRootLen = lstrlen(s_szRoot);
        s_dwSize = dwSize;
        LEAVECRITICAL;
    }

    return dwSize;
}

STDAPI_(UINT) GetMountedVolumeIcon(LPCTSTR pszMountPoint, LPTSTR pszModule, DWORD cchModule)
{
    UINT iIcon = II_FOLDER;

    // zero-init string
    if (pszModule)
        *pszModule = 0;

    CMountPoint* pMtPt = CMountPoint::GetMountPoint(pszMountPoint);
    if (pMtPt)
    {
        iIcon = pMtPt->GetIcon(pszModule, cchModule);
        pMtPt->Release();
    }
    return iIcon;
}


STDAPI_(BOOL) IsDisconnectedNetDrive(int iDrive)
{
    BOOL fDisc = 0;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive);

    if (pMtPt)
    {
        fDisc = pMtPt->IsDisconnectedNetDrive();
        pMtPt->Release();
    }
    return fDisc;
}

STDAPI_(BOOL) IsUnavailableNetDrive(int iDrive)
{
    BOOL fUnAvail = 0;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive);

    if (pMtPt)
    {
        fUnAvail = pMtPt->IsUnavailableNetDrive();
        pMtPt->Release();
    }

    return fUnAvail;

}

STDMETHODIMP SetDriveLabel(HWND hwnd, IUnknown* punkEnableModless, int iDrive, LPCTSTR pszDriveLabel)
{
    HRESULT hr = E_FAIL;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive);

    if (pMtPt)
    {
        hr = pMtPt->SetDriveLabel(hwnd, pszDriveLabel);
        pMtPt->Release();
    }

    return hr;
}

STDMETHODIMP GetDriveComment(int iDrive, LPTSTR pszComment, int cchComment)
{
    HRESULT hr = E_FAIL;
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive);

    if (pMtPt)
    {
        hr = pMtPt->GetComment(pszComment, cchComment);
        pMtPt->Release();
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// End:   Old C fct required externally
///////////////////////////////////////////////////////////////////////////////

//
// fDoIt -- TRUE, if we make connections; FALSE, if just querying.
//
BOOL _MakeConnection(IDataObject *pDataObj, BOOL fDoIt)
{
    STGMEDIUM medium;
    FORMATETC fmte = {g_cfNetResource, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BOOL fAnyConnectable = FALSE;

    if (SUCCEEDED(pDataObj->GetData(&fmte, &medium)))
    {
        LPNETRESOURCE pnr = (LPNETRESOURCE)LocalAlloc(LPTR, 1024);
        if (pnr)
        {
            UINT iItem, cItems = SHGetNetResource(medium.hGlobal, (UINT)-1, NULL, 0);
            for (iItem = 0; iItem < cItems; iItem++)
            {
                if (SHGetNetResource(medium.hGlobal, iItem, pnr, 1024) &&
                    pnr->dwUsage & RESOURCEUSAGE_CONNECTABLE &&
                    !(pnr->dwType & RESOURCETYPE_PRINT))
                {
                    fAnyConnectable = TRUE;
                    if (fDoIt)
                    {
                        SHNetConnectionDialog(NULL, pnr->lpRemoteName, pnr->dwType);
                        SHChangeNotifyHandleEvents();
                    }
                    else
                    {
                        break;  // We are just querying.
                    }
                }
            }
            LocalFree(pnr);
        }
        ReleaseStgMedium(&medium);
    }

    return fAnyConnectable;
}

//
// the entry of "make connection thread"
//
DWORD WINAPI MakeConnectionThreadProc(void *pv)
{
    IDataObject *pdtobj;
    if (SUCCEEDED(CoGetInterfaceAndReleaseStream((IStream *)pv, IID_PPV_ARG(IDataObject, &pdtobj))))
    {
        _MakeConnection(pdtobj, TRUE);
        pdtobj->Release();
    }

    return 0;
}

STDAPI CDrivesDropTarget_Create(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);

class CDrivesDropTarget : public CIDLDropTarget
{
friend HRESULT CDrivesDropTarget_Create(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);
public:
    CDrivesDropTarget(HWND hwnd) : CIDLDropTarget(hwnd) { };
    // IDropTarget methods overwirte
    STDMETHODIMP DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
};


STDAPI CDrivesDropTarget_Create(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt)
{
    *ppdropt = NULL;

    HRESULT hr;
    CDrivesDropTarget *pCIDLDT = new CDrivesDropTarget(hwnd);
    if (pCIDLDT)
    {
        hr = pCIDLDT->_Init(pidl);
        if (SUCCEEDED(hr))
            pCIDLDT->QueryInterface(IID_PPV_ARG(IDropTarget, ppdropt));
        pCIDLDT->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

//
// puts DROPEFFECT_LINK in *pdwEffect, only if the data object
// contains one or more net resource.
//
STDMETHODIMP CDrivesDropTarget::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // Call the base class first.
    CIDLDropTarget::DragEnter(pDataObj, grfKeyState, pt, pdwEffect);

    *pdwEffect &= _MakeConnection(pDataObj, FALSE) ? DROPEFFECT_LINK : DROPEFFECT_NONE;

    m_dwEffectLastReturned = *pdwEffect;

    return S_OK;     // Notes: we should NOT return hr as it.
}

//
// creates a connection to a dropped net resource object.
//
STDMETHODIMP CDrivesDropTarget::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr;

    if (m_dwData & DTID_NETRES)
    {
        *pdwEffect = DROPEFFECT_LINK;

        hr = CIDLDropTarget::DragDropMenu(DROPEFFECT_LINK, pDataObj,
            pt, pdwEffect, NULL, NULL, POPUP_DRIVES_NONDEFAULTDD, grfKeyState);

        if (hr == S_FALSE)
        {
            // we create another thread to avoid blocking the source thread.
            IStream *pstm;
            if (S_OK == CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pDataObj, &pstm))
            {
                if (SHCreateThread(MakeConnectionThreadProc, pstm, CTF_COINIT, NULL))
                {
                    hr = S_OK;
                }
                else
                {
                    pstm->Release();
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
    else
    {
        //
        // Because QueryGetData() failed, we don't call CIDLDropTarget_
        // DragDropMenu(). Therefore, we must call this explicitly.
        //
        DAD_DragLeave();
        hr = E_FAIL;
    }

    CIDLDropTarget::DragLeave();

    return hr;
}

STDAPI_(DWORD) DrivesPropertiesThreadProc(void *pv)
{
    PROPSTUFF *pps = (PROPSTUFF *)pv;
    STGMEDIUM medium;
    ULONG_PTR dwCookie = 0;
    BOOL bDidActivate = FALSE;
    
    //
    // This __try/__finally block is to ensure that the activation context gets
    // removed, even if there's an assertion elsewhere in this code.  A missing
    // DeactivateActCtx will lead to a very strange-looking assertion in one of
    // the RtlpDeactivateActCtx-variant functions from the caller.  Old code
    // was missing the deactivate in all circumstances.
    //
    // (jonwis) 1/2/2001
    //
    __try
    {
        bDidActivate = ActivateActCtx(NULL, &dwCookie);
   
        LPIDA pida = DataObj_GetHIDA(pps->pdtobj, &medium);

        BOOL bMountedDriveInfo = FALSE;

        // Were we able to get data for a HIDA?
        if (!pida)
        {
            // No, pida is first choice, but if not present check for mounteddrive info
            FORMATETC fmte;

            fmte.cfFormat = g_cfMountedVolume;
            fmte.ptd = NULL;
            fmte.dwAspect = DVASPECT_CONTENT;
            fmte.lindex = -1;
            fmte.tymed = TYMED_HGLOBAL;

            // Is data available for the MountedVolume format?
            if (SUCCEEDED(pps->pdtobj->GetData(&fmte, &medium)))
                // Yes
                bMountedDriveInfo = TRUE;
        }

        // Do we have data for a HIDA or a mountedvolume?
        if (pida || bMountedDriveInfo)
        {
            // Yes
            TCHAR szCaption[MAX_PATH];
            LPTSTR pszCaption = NULL;

            if (pida)
            {
                pszCaption = SHGetCaption(medium.hGlobal);
            }
            else
            {
                TCHAR szMountPoint[MAX_PATH];
                TCHAR szVolumeGUID[MAX_PATH];

                DragQueryFile((HDROP)medium.hGlobal, 0, szMountPoint, ARRAYSIZE(szMountPoint));
            
                GetVolumeNameForVolumeMountPoint(szMountPoint, szVolumeGUID, ARRAYSIZE(szVolumeGUID));
                szCaption[0] = 0;
                GetVolumeInformation(szVolumeGUID, szCaption, ARRAYSIZE(szCaption), NULL, NULL, NULL, NULL, 0);

                if (!(*szCaption))
                    LoadString(HINST_THISDLL, IDS_UNLABELEDVOLUME, szCaption, ARRAYSIZE(szCaption));        

                PathRemoveBackslash(szMountPoint);

                // Fix 330388
                // If the szMountPoint is not a valid local path, do not
                // display it in the properties dialog title:
                if (-1 != PathGetDriveNumber(szMountPoint))
                {
                    int nCaptionLength = lstrlen(szCaption) ;
                    StringCchPrintf(szCaption + nCaptionLength, ARRAYSIZE(szCaption) - nCaptionLength, TEXT(" (%s)"), szMountPoint);
                }
                pszCaption = szCaption;
            }

            //  NOTE - if we pass the name of the drive then we can get a lot more keys...
            HKEY rgk[MAX_ASSOC_KEYS];
            DWORD ck = CDrives_GetKeys(NULL, rgk, ARRAYSIZE(rgk));

            SHOpenPropSheet(pszCaption, rgk, ck,
                            &CLSID_ShellDrvDefExt, pps->pdtobj, NULL, pps->pStartPage);

            SHRegCloseKeys(rgk, ck);

            if (pida && pszCaption)
                SHFree(pszCaption);

            if (pida)
                HIDA_ReleaseStgMedium(pida, &medium);
            else
                ReleaseStgMedium(&medium);

        }
        else
        {
            TraceMsg(DM_TRACE, "no HIDA in data obj nor Mounted drive info");
        }
    }
    __finally
    {
        if ( bDidActivate )
        {
            DeactivateActCtx( 0, dwCookie );
        }
    }

    return 0;
}

//
// To be called back from within CDefFolderMenu
//
STDAPI CDrives_DFMCallBack(IShellFolder *psf, HWND hwnd,
                           IDataObject *pdtobj, UINT uMsg, 
                           WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        if (pdtobj)
        {
            FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

            // Check if only file system objects are selected.
            if (pdtobj->QueryGetData(&fmte) == S_OK)
            {
                #define pqcm ((LPQCMINFO)lParam)

                STGMEDIUM medium;
                // Yes, only file system objects are selected.
                LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
                if (pida)
                {
                    LPIDDRIVE pidd = (LPIDDRIVE)IDA_GetIDListPtr(pida, 0);

                    if (pidd)
                    {
                        int iDrive = DRIVEID(pidd->cName);
                        UINT idCmdBase = pqcm->idCmdFirst;   // store it away

                        BOOL fIsEjectable = FALSE;

                        CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_DRIVES_ITEM, 0, pqcm);

                        CMountPoint* pmtpt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));

                        if (pmtpt)
                        {
                            if (!pmtpt->IsRemote() ||
                                SHRestricted( REST_NONETCONNECTDISCONNECT ))
                            {
                                DeleteMenu(pqcm->hmenu, idCmdBase + FSIDM_DISCONNECT, MF_BYCOMMAND);
                            }

                            if ((pida->cidl != 1) ||
                                (!pmtpt->IsFormattable()))
                            {
                                // Don't even try to format more than one disk
                                // Or a net drive, or a CD-ROM, or a RAM drive ...
                                // Note we are going to show the Format command on the
                                // boot drive, Windows drive, System drive, compressed
                                // drives, etc.  An appropriate error should be shown
                                // after the user chooses this command
                                DeleteMenu(pqcm->hmenu, idCmdBase + FSIDM_FORMAT, MF_BYCOMMAND);
                            }

                            if (pmtpt->IsEjectable())
                                fIsEjectable = TRUE;

                            pmtpt->Release();
                        }

                        if ((pida->cidl != 1) || (iDrive < 0) || !fIsEjectable)
                            DeleteMenu(pqcm->hmenu, idCmdBase + FSIDM_EJECT, MF_BYCOMMAND);

                    }

                    HIDA_ReleaseStgMedium(pida, &medium);    
                }

                #undef pqcm
            }
        }
        // Note that we always return S_OK from this function so that
        // default processing of menu items will occur
        ASSERT(hr == S_OK);
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_MAPCOMMANDNAME:
        if (lstrcmpi((LPCTSTR)lParam, TEXT("eject")) == 0)
            *(int *)wParam = FSIDM_EJECT;
        else if (lstrcmpi((LPCTSTR)lParam, TEXT("format")) == 0)
            *(int *)wParam = FSIDM_FORMAT;
        else
            hr = E_FAIL;  // command not found
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case DFM_CMD_PROPERTIES:
            // lParam contains the page name to open
            hr = SHLaunchPropSheet(DrivesPropertiesThreadProc, pdtobj, (LPCTSTR)lParam, NULL, NULL);
            break;

        case FSIDM_EJECT:
        case FSIDM_FORMAT:
        {
            STGMEDIUM medium;

            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);

            ASSERT(HIDA_GetCount(medium.hGlobal) == 1);

            LPIDDRIVE pidd = (LPIDDRIVE)IDA_GetIDListPtr(pida, 0);
            if (pidd)
            {
                UINT iDrive = DRIVEID(pidd->cName);

                ASSERT((int)iDrive >= 0);

                switch (wParam)
                {
                case FSIDM_FORMAT:
                    SHFormatDriveAsync(hwnd, iDrive, SHFMT_ID_DEFAULT, 0);
                    break;

                case FSIDM_EJECT:
                    {
                        CDBurn_OnEject(hwnd, iDrive);
                        CMountPoint* pMtPt = CMountPoint::GetMountPoint(iDrive);
                        if (pMtPt)
                        {
                            pMtPt->Eject(hwnd);
                            pMtPt->Release();
                        }
                        break;
                    }
                }
            }

            HIDA_ReleaseStgMedium(pida, &medium);
            break;
        }

        case FSIDM_DISCONNECT:

            if (pdtobj)
            {
                STGMEDIUM medium;
                LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
                if (pida)
                {
                    DISCDLGSTRUCT discd = {
                        sizeof(discd),          // cbStructure
                        hwnd,                   // hwndOwner
                        NULL,                   // lpLocalName
                        NULL,                   // lpRemoteName
                        DISC_UPDATE_PROFILE     // dwFlags
                    };
                    for (UINT iidl = 0; iidl < pida->cidl; iidl++)
                    {
                        LPIDDRIVE pidd = (LPIDDRIVE)IDA_GetIDListPtr(pida, iidl);

                        CMountPoint* pmtpt = CMountPoint::GetMountPoint(DRIVEID(pidd->cName));

                        if (pmtpt)
                        {
                            if (pmtpt->IsRemote())
                            {
                                TCHAR szPath[4], szDrive[4];
                                BOOL fUnavailable = pmtpt->IsUnavailableNetDrive();

                                SHAnsiToTChar(pidd->cName, szPath,  ARRAYSIZE(szPath));
                                SHAnsiToTChar(pidd->cName, szDrive, ARRAYSIZE(szDrive));
                                szDrive[2] = 0; // remove slash
                                discd.lpLocalName = szDrive;

                                if (SHWNetDisconnectDialog1(&discd) == WN_SUCCESS)
                                {
                                    // If it is a unavailable drive we get no
                                    // file system notification and as such
                                    // the drive will not disappear, so lets
                                    // set up to do it ourself...
                                    if (fUnavailable)
                                    {
                                        CMountPoint::NotifyUnavailableNetDriveGone(szPath);

                                        // Do we need this if we have the above?
                                        SHChangeNotify(SHCNE_DRIVEREMOVED, SHCNF_PATH, szPath, NULL);
                                    }
                                }
                            }

                            pmtpt->Release();
                        }
                    }

                    // flush them altogether
                    SHChangeNotifyHandleEvents();
                    HIDA_ReleaseStgMedium(pida, &medium);
                }
            }
            break;

        case FSIDM_CONNECT_PRN:
            SHNetConnectionDialog(hwnd, NULL, RESOURCETYPE_PRINT);
            break;

        case FSIDM_DISCONNECT_PRN:
            WNetDisconnectDialog(hwnd, RESOURCETYPE_PRINT);
            break;

        default:
            // This is one of view menu items, use the default code.
            hr = S_FALSE;
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}

void _DrvPrshtSetSpaceValues(DRIVEPROPSHEETPAGE *pdpsp)
{
    LPITEMIDLIST pidl;
    TCHAR szFormat[30];
    TCHAR szTemp[30];
    TCHAR szBuffer[64]; // needs to be big enough to hold "99,999,999,999,999 bytes" + room for localization

    // reset the total/free values to start with
    pdpsp->qwTot = pdpsp->qwFree = 0;

    // lets try to ask the shellfolder for this information!
    HRESULT hr = SHILCreateFromPath(pdpsp->szDrive, &pidl, NULL);
    if (SUCCEEDED(hr))
    {
        IShellFolder2 *psf2;
        LPCITEMIDLIST pidlLast;

        hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder2, &psf2), &pidlLast);
        if (SUCCEEDED(hr))
        {
            ULONGLONG ullFree;

            hr = GetLongProperty(psf2, pidlLast, &SCID_FREESPACE, &ullFree);
            if (SUCCEEDED(hr))
            {
                ULONGLONG ullTotal;

                hr = GetLongProperty(psf2, pidlLast, &SCID_CAPACITY, &ullTotal);
                if (SUCCEEDED(hr))
                {
                    pdpsp->qwTot = ullTotal;
                    pdpsp->qwFree = ullFree;
                }
            }
            psf2->Release();
        }
        ILFree(pidl);
    }

    // we want to use the IShellFolder stuff above so cdrom burning will be happy. However, the
    // above code fails for removable drives that have no media, so we need a fallback
    if (FAILED(hr))
    {
        ULARGE_INTEGER qwFreeUser;
        ULARGE_INTEGER qwTotal;
        ULARGE_INTEGER qwTotalFree;

        if (SHGetDiskFreeSpaceEx(pdpsp->szDrive, &qwFreeUser, &qwTotal, &qwTotalFree))
        {
            // Save away to use when drawing the pie
            pdpsp->qwTot = qwTotal.QuadPart;
            pdpsp->qwFree = qwFreeUser.QuadPart;
        }
    }
    
    LoadString(HINST_THISDLL, IDS_BYTES, szFormat, ARRAYSIZE(szFormat));

    // NT must be able to display 64-bit numbers; at least as much
    // as is realistic.  We've made the decision
    // that volumes up to 100 Terrabytes will display the byte value
    // and the short-format value.  Volumes of greater size will display
    // "---" in the byte field and the short-format value.  Note that the
    // short format is always displayed.
    const _int64 MaxDisplayNumber = 99999999999999; // 100TB - 1.

    if ((pdpsp->qwTot - pdpsp->qwFree) <= MaxDisplayNumber)
    {
        StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), szFormat, AddCommas64(pdpsp->qwTot - pdpsp->qwFree, szTemp, ARRAYSIZE(szTemp)));
        SetDlgItemText(pdpsp->hDlg, IDC_DRV_USEDBYTES, szBuffer);
    }

    if (pdpsp->qwFree <= MaxDisplayNumber)
    {
        StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), szFormat, AddCommas64(pdpsp->qwFree, szTemp, ARRAYSIZE(szTemp)));
        SetDlgItemText(pdpsp->hDlg, IDC_DRV_FREEBYTES, szBuffer);
    }

    if (pdpsp->qwTot <= MaxDisplayNumber)
    {
        StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), szFormat, AddCommas64(pdpsp->qwTot, szTemp, ARRAYSIZE(szTemp)));
        SetDlgItemText(pdpsp->hDlg, IDC_DRV_TOTBYTES, szBuffer);
    }

    ShortSizeFormat64(pdpsp->qwTot-pdpsp->qwFree, szBuffer, ARRAYSIZE(szBuffer));
    SetDlgItemText(pdpsp->hDlg, IDC_DRV_USEDMB, szBuffer);

    ShortSizeFormat64(pdpsp->qwFree, szBuffer, ARRAYSIZE(szBuffer));
    SetDlgItemText(pdpsp->hDlg, IDC_DRV_FREEMB, szBuffer);

    ShortSizeFormat64(pdpsp->qwTot, szBuffer, ARRAYSIZE(szBuffer));
    SetDlgItemText(pdpsp->hDlg, IDC_DRV_TOTMB, szBuffer);
}

void _DrvPrshtGetPieShadowHeight(DRIVEPROPSHEETPAGE* pdpsp)
{
    SIZE size;
    HDC hDC = GetDC(pdpsp->hDlg);

    // some bizzare black magic calculation for the pie size...
    GetTextExtentPoint(hDC, TEXT("W"), 1, &size);
    pdpsp->dwPieShadowHgt = size.cy * 2 / 3;
    ReleaseDC(pdpsp->hDlg, hDC);
}

void _DrvPrshtSetDriveIcon(DRIVEPROPSHEETPAGE* pdpsp, CMountPoint* pMtPt)
{
    TCHAR szModule[MAX_PATH];

    if (pMtPt)
    {
        UINT uIcon = pMtPt->GetIcon(szModule, ARRAYSIZE(szModule));

        if (uIcon)
        {
            HIMAGELIST hIL = NULL;

            Shell_GetImageLists(&hIL, NULL);

            if (hIL)
            {
                int iIndex = Shell_GetCachedImageIndex(szModule[0] ? szModule : c_szShell32Dll, uIcon, 0);
                HICON hIcon = ImageList_ExtractIcon(g_hinst, hIL, iIndex);

                if (hIcon)
                {
                    ReplaceDlgIcon(pdpsp->hDlg, IDC_DRV_ICON, hIcon);
                }
            }
        }
    }

}

void _DrvPrshtSetDriveAttributes(DRIVEPROPSHEETPAGE* pdpsp, CMountPoint* pMtPt)
{
    if (pMtPt)    
    {
        if (pMtPt->IsCompressible())
        {
            // file-based compression is supported (must be NTFS)
            pdpsp->fIsCompressionAvailable = TRUE;
        
            if (pMtPt->IsCompressed())
            {
                // the volume root is compressed
                pdpsp->asInitial.fCompress = TRUE;

                // if its compressed, compression better be available
                ASSERT(pdpsp->fIsCompressionAvailable);
            }
        }

        //
        // HACK (reinerf) - we dont have a FS_SUPPORTS_INDEXING so we 
        // use the FILE_SUPPORTS_SPARSE_FILES flag, because native index support
        // appeared first on NTFS5 volumes, at the same time sparse file support 
        // was implemented.
        //
        if (pMtPt->IsSupportingSparseFile())
        {
            // yup, we are on NTFS 5 or greater
            pdpsp->fIsIndexAvailable = TRUE;

            if (pMtPt->IsContentIndexed())
            {
                pdpsp->asInitial.fIndex = TRUE;
            }
        }
    }
    else
    {
        // if we don't have a mount point, we just leave everything alone
    }

    // Set the inital state of the compression / content index checkboxes
    if (!pdpsp->fIsCompressionAvailable)
    {
        // file-based compression is not supported
        DestroyWindow(GetDlgItem(pdpsp->hDlg, IDD_COMPRESS));
    }
    else
    {
        CheckDlgButton(pdpsp->hDlg, IDD_COMPRESS, pdpsp->asInitial.fCompress);
    }

    if (!pdpsp->fIsIndexAvailable)
    {
        // content index is only supported on NTFS 5 volumes
        DestroyWindow(GetDlgItem(pdpsp->hDlg, IDD_INDEX));
    }
    else
    {
        CheckDlgButton(pdpsp->hDlg, IDD_INDEX, pdpsp->asInitial.fIndex);
    }
}

void _DrvPrshtSetFileSystem(DRIVEPROPSHEETPAGE* pdpsp, CMountPoint* pMtPt)
{
    TCHAR szFileSystem[64];

    szFileSystem[0] = TEXT('\0');

    if (pMtPt)
    {
        if (!pMtPt->GetFileSystemName(szFileSystem, ARRAYSIZE(szFileSystem)) ||
            (*szFileSystem == TEXT('\0')))
        {
            if ((pMtPt->IsStrictRemovable() || pMtPt->IsFloppy() || pMtPt->IsCDROM()) &&
                !pMtPt->HasMedia())
            {
                // if this drive has removable media and it is empty, then fall back to "Unknown"
                LoadString(HINST_THISDLL, IDS_FMT_MEDIA0, szFileSystem, ARRAYSIZE(szFileSystem));
            }
            else
            {
                // for fixed drives, leave the text as "RAW" (set by default in dlg template)
                szFileSystem[0] = TEXT('\0');
            }
        }
    }

    if (*szFileSystem)
    {
        SetDlgItemText(pdpsp->hDlg, IDC_DRV_FS, szFileSystem);
    }    
}

void _DrvPrshtSetVolumeLabel(DRIVEPROPSHEETPAGE* pdpsp, CMountPoint* pMtPt)
{
    TCHAR szLabel[MAX_LABEL_NTFS + 1];
    UINT cchLabel = MAX_LABEL_FAT;  // assume the drive is FAT
    HWND hwndLabel = GetDlgItem(pdpsp->hDlg, IDC_DRV_LABEL);
    BOOL bAllowRename = TRUE;
    HRESULT hr = E_FAIL;

    szLabel[0] = TEXT('\0');

    if (pMtPt)
    {
        hr = pMtPt->GetLabelNoFancy(szLabel, ARRAYSIZE(szLabel));

        if (pMtPt->IsRemote() || 
            (pMtPt->IsCDROM() && !pMtPt->IsDVDRAMMedia()))
        {
            // ISSUE-2000/10/30-StephStm We probably want to distinguish between diff types of cdrom drives
            bAllowRename = FALSE;
        }
        
        if ( !bAllowRename && pMtPt->IsCDROM( ) )
        {
            //
            //  Check to see if it is CDFS, if not, make no assumptions about
            //  writing the label.
            //

            WCHAR szFS[ 10 ];   // random - just more than "CDFS\0"
            BOOL b = pMtPt->GetFileSystemName( szFS, ARRAYSIZE(szFS) );
            if (b && lstrcmpi(szFS, L"CDFS") != 0 ) 
            {
                //  Re-enable the label as we don't know if the FS doesn't support this
                //  until we actually try it.
                bAllowRename = TRUE;
            }
        }

        if (pMtPt->IsNTFS())
        {
            cchLabel = MAX_LABEL_NTFS;
        }
    }
    
    SetWindowText(hwndLabel, szLabel);

    if (FAILED(hr) || !bAllowRename)
    {
        Edit_SetReadOnly(hwndLabel, TRUE);
    }
    
    // limit the "Label" edit box based on the filesystem
    Edit_LimitText(hwndLabel, cchLabel);
    
    // make sure we don't recieve an EN_CHANGED message for the volume edit box
    // because we set it above
    Edit_SetModify(hwndLabel, FALSE);
}

void _DrvPrshtSetDriveType(DRIVEPROPSHEETPAGE* pdpsp, CMountPoint* pMtPt)
{
    TCHAR szDriveType[80];

    szDriveType[0] = TEXT('\0');

    if (pMtPt)
    {
        if (pMtPt->IsUnavailableNetDrive())
        {
            LoadString(HINST_THISDLL, IDS_DRIVES_NETUNAVAIL, szDriveType, ARRAYSIZE(szDriveType));
        }
        else
        {
            pMtPt->GetTypeString(szDriveType, ARRAYSIZE(szDriveType));
        }
    }

    SetDlgItemText(pdpsp->hDlg, IDC_DRV_TYPE, szDriveType);
}

void _DrvPrshtSetDriveLetter(DRIVEPROPSHEETPAGE* pdpsp)
{
    TCHAR szDriveLetterText[80];
    TCHAR szFormat[80];

    if (pdpsp->fMountedDrive)
    {
        TCHAR szLabel[MAX_LABEL_NTFS + 1];

        if (GetDlgItemText(pdpsp->hDlg, IDC_DRV_LABEL, szLabel, ARRAYSIZE(szLabel)))
        {
            LoadString(HINST_THISDLL, IDS_VOLUMELABEL, szFormat, ARRAYSIZE(szFormat));
            StringCchPrintf(szDriveLetterText, ARRAYSIZE(szDriveLetterText), szFormat, szLabel);
            SetDlgItemText(pdpsp->hDlg, IDC_DRV_LETTER, szDriveLetterText);
        }
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_DRIVELETTER, szFormat, ARRAYSIZE(szFormat));
        StringCchPrintf(szDriveLetterText, ARRAYSIZE(szDriveLetterText), szFormat, pdpsp->iDrive + TEXT('A'));
        SetDlgItemText(pdpsp->hDlg, IDC_DRV_LETTER, szDriveLetterText);
    }
}

void _DrvPrshtSetDiskCleanup(DRIVEPROPSHEETPAGE* pdpsp)
{
    // if we have a cleanup path in the registry, turn on the Disk Cleanup button on
    // NOTE: disk cleanup and mounted volumes don't get along to well, so disable it for now.
    WCHAR szPath[MAX_PATH] = L"";
    
    if (!pdpsp->fMountedDrive && GetDiskCleanupPath(szPath, ARRAYSIZE(szPath)) && IsBitBucketableDrive(pdpsp->iDrive))
    {
        ShowWindow(GetDlgItem(pdpsp->hDlg, IDC_DRV_CLEANUP), SW_SHOW);
        EnableWindow(GetDlgItem(pdpsp->hDlg, IDC_DRV_CLEANUP), TRUE);
    }
    else
    {
        ShowWindow(GetDlgItem(pdpsp->hDlg, IDC_DRV_CLEANUP), SW_HIDE);
        EnableWindow(GetDlgItem(pdpsp->hDlg, IDC_DRV_CLEANUP), FALSE);
    }
}

void _DrvPrshtInit(DRIVEPROPSHEETPAGE* pdpsp)
{
    HCURSOR hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // get the MountPoint object for this drive
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(pdpsp->szDrive);
    if ( !pMtPt )
    {
        pMtPt = CMountPoint::GetSimulatedMountPointFromVolumeGuid( pdpsp->szDrive );
    }

    _DrvPrshtGetPieShadowHeight(pdpsp);
    _DrvPrshtSetDriveIcon(pdpsp, pMtPt);
    _DrvPrshtSetDriveAttributes(pdpsp, pMtPt);
    _DrvPrshtSetFileSystem(pdpsp, pMtPt);
    _DrvPrshtSetVolumeLabel(pdpsp, pMtPt);
    _DrvPrshtSetDriveType(pdpsp, pMtPt);
    _DrvPrshtSetSpaceValues(pdpsp);
    _DrvPrshtSetDriveLetter(pdpsp);
    _DrvPrshtSetDiskCleanup(pdpsp);

    SetCursor(hcurOld);

    if (pMtPt)
    {
        pMtPt->Release();
    }
}

void _DrvPrshtUpdateInfo(DRIVEPROPSHEETPAGE* pdpsp)
{
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(pdpsp->szDrive);

    _DrvPrshtSetSpaceValues(pdpsp);
    _DrvPrshtSetDriveType(pdpsp, pMtPt);

    if (pMtPt)
    {
        pMtPt->Release();
    }
}

const COLORREF c_crPieColors[] =
{
    RGB(  0,   0, 255),      // Blue
    RGB(255,   0, 255),      // Red-Blue
    RGB(  0,   0, 128),      // 1/2 Blue
    RGB(128,   0, 128),      // 1/2 Red-Blue
};

STDAPI Draw3dPie(HDC hdc, RECT *prc, DWORD dwPer1000, const COLORREF *lpColors);
        
void DrawColorRect(HDC hdc, COLORREF crDraw, const RECT *prc)
{
    HBRUSH hbDraw = CreateSolidBrush(crDraw);
    if (hbDraw)
    {
        HBRUSH hbOld = (HBRUSH)SelectObject(hdc, hbDraw);
        if (hbOld)
        {
            PatBlt(hdc, prc->left, prc->top,
                prc->right - prc->left,
                prc->bottom - prc->top,
                PATCOPY);
            
            SelectObject(hdc, hbOld);
        }
        
        DeleteObject(hbDraw);
    }
}

void _DrvPrshtDrawItem(DRIVEPROPSHEETPAGE *pdpsp, const DRAWITEMSTRUCT * lpdi)
{
    switch (lpdi->CtlID)
    {
    case IDC_DRV_PIE:
        {
            DWORD dwPctX10 = pdpsp->qwTot ?
                (DWORD)((__int64)1000 * (pdpsp->qwTot - pdpsp->qwFree) / pdpsp->qwTot) : 
                1000;
#if 1
            DrawPie(lpdi->hDC, &lpdi->rcItem,
                dwPctX10, pdpsp->qwFree==0 || pdpsp->qwFree==pdpsp->qwTot,
                pdpsp->dwPieShadowHgt, c_crPieColors);
#else
            {
                RECT rcTemp = lpdi->rcItem;
                Draw3dPie(lpdi->hDC, &rcTemp, dwPctX10, c_crPieColors);
            }
#endif
        }
        break;
        
    case IDC_DRV_USEDCOLOR:
        DrawColorRect(lpdi->hDC, c_crPieColors[DP_USEDCOLOR], &lpdi->rcItem);
        break;
        
    case IDC_DRV_FREECOLOR:
        DrawColorRect(lpdi->hDC, c_crPieColors[DP_FREECOLOR], &lpdi->rcItem);
        break;
        
    default:
        break;
    }
}

BOOL_PTR CALLBACK DriveAttribsDlgProc(HWND hDlgRecurse, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    DRIVEPROPSHEETPAGE* pdpsp = (DRIVEPROPSHEETPAGE *)GetWindowLongPtr(hDlgRecurse, DWLP_USER);
    
    switch (uMessage)
    {
    case WM_INITDIALOG:
        {
            TCHAR szTemp[MAX_PATH];
            TCHAR szAttribsToApply[MAX_PATH];
            TCHAR szDriveText[MAX_PATH];
            TCHAR szFormatString[MAX_PATH];
            TCHAR szDlgText[MAX_PATH];
            int iLength;

            SetWindowLongPtr(hDlgRecurse, DWLP_USER, lParam);
            pdpsp = (DRIVEPROPSHEETPAGE *)lParam;

            // set the initial state of the radio button
            CheckDlgButton(hDlgRecurse, IDD_RECURSIVE, TRUE);
        
            szAttribsToApply[0] = 0;

            // set the IDD_ATTRIBSTOAPPLY based on what attribs we are applying
            if (pdpsp->asInitial.fIndex != pdpsp->asCurrent.fIndex)
            {
                if (pdpsp->asCurrent.fIndex)
                {
                    LoadString(HINST_THISDLL, IDS_INDEX, szTemp, ARRAYSIZE(szTemp)); 
                }
                else
                {
                    LoadString(HINST_THISDLL, IDS_DISABLEINDEX, szTemp, ARRAYSIZE(szTemp)); 
                }

                //  UI only - don't care if it gets truncated
                StringCchCat(szAttribsToApply, ARRAYSIZE(szAttribsToApply), szTemp);
            }

            if (pdpsp->asInitial.fCompress != pdpsp->asCurrent.fCompress)
            {
                if (pdpsp->asCurrent.fCompress)
                {
                    LoadString(HINST_THISDLL, IDS_COMPRESS, szTemp, ARRAYSIZE(szTemp)); 
                }
                else
                {
                    LoadString(HINST_THISDLL, IDS_UNCOMPRESS, szTemp, ARRAYSIZE(szTemp)); 
                }

                //  UI only - don't care if it gets truncated
                StringCchCat(szAttribsToApply, ARRAYSIZE(szAttribsToApply), szTemp);
            }

            // remove the trailing ", "
            iLength = lstrlen(szAttribsToApply);
            ASSERT(iLength >= 3);
            szAttribsToApply[iLength - 2] = 0;

            SetDlgItemText(hDlgRecurse, IDD_ATTRIBSTOAPPLY, szAttribsToApply);

            // this dialog was only designed for nice short paths like "c:\" not "\\?\Volume{GUID}\" paths
            if (lstrlen(pdpsp->szDrive) > 3)
            {
                // get the default string
                LoadString(HINST_THISDLL, IDS_THISVOLUME, szDriveText, ARRAYSIZE(szDriveText));
            }
            else
            {
                // Create the string "C:\"
                StringCchCopy(szDriveText, ARRAYSIZE(szDriveText), pdpsp->szDrive);
                PathAddBackslash(szDriveText);

                // sanity check; this better be a drive root!
                ASSERT(PathIsRoot(szDriveText));
            }
        
            // set the IDD_RECURSIVE_TXT text to have "C:\"
            GetDlgItemText(hDlgRecurse, IDD_RECURSIVE_TXT, szFormatString, ARRAYSIZE(szFormatString));
            StringCchPrintf(szDlgText, ARRAYSIZE(szDlgText), szFormatString, szDriveText);
            SetDlgItemText(hDlgRecurse, IDD_RECURSIVE_TXT, szDlgText);

            // set the IDD_NOTRECURSIVE raido button text to have "C:\"
            GetDlgItemText(hDlgRecurse, IDD_NOTRECURSIVE, szFormatString, ARRAYSIZE(szFormatString));
            StringCchPrintf(szDlgText, ARRAYSIZE(szDlgText), szFormatString, szDriveText);
            SetDlgItemText(hDlgRecurse, IDD_NOTRECURSIVE, szDlgText);

            // set the IDD_RECURSIVE raido button text to have "C:\"
            GetDlgItemText(hDlgRecurse, IDD_RECURSIVE, szFormatString, ARRAYSIZE(szFormatString));
            StringCchPrintf(szDlgText, ARRAYSIZE(szDlgText), szFormatString, szDriveText);
            SetDlgItemText(hDlgRecurse, IDD_RECURSIVE, szDlgText);
        }
        break;

    case WM_COMMAND:
        {
            UINT uID = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uID)
            {
            case IDOK:
                pdpsp->fRecursive = (IsDlgButtonChecked(hDlgRecurse, IDD_RECURSIVE) == BST_CHECKED);
                // fall through
            case IDCANCEL:
                EndDialog(hDlgRecurse, (uID == IDCANCEL) ? FALSE : TRUE);
                break;
            }
        }

    default:
        return FALSE;
    }
    return TRUE;
}


BOOL _DrvPrshtApply(DRIVEPROPSHEETPAGE* pdpsp)
{
    BOOL bFctRet;
    HWND hCtl;

    // take care of compression / content indexing first
    pdpsp->asCurrent.fCompress = (IsDlgButtonChecked(pdpsp->hDlg, IDD_COMPRESS) == BST_CHECKED);
    pdpsp->asCurrent.fIndex = (IsDlgButtonChecked(pdpsp->hDlg, IDD_INDEX) == BST_CHECKED);
    pdpsp->asCurrent.fRecordingEnabled = (IsDlgButtonChecked(pdpsp->hDlg, IDC_RECORD_ENABLE) == BST_CHECKED);

    // check to see if something has changed before applying attribs
    if (memcmp(&pdpsp->asInitial, &pdpsp->asCurrent, sizeof(pdpsp->asInitial)) != 0)
    {
        // the user toggled the attributes, so ask them if they want to recurse
        BOOL_PTR bRet = DialogBoxParam(HINST_THISDLL, 
                              MAKEINTRESOURCE(DLG_ATTRIBS_RECURSIVE),
                              pdpsp->hDlg,
                              DriveAttribsDlgProc,
                              (LPARAM)pdpsp);
        if (bRet)
        {
            FILEPROPSHEETPAGE fpsp = {0};

            fpsp.pfci = Create_FolderContentsInfo();
            if (fpsp.pfci)
            {
                // we cook up a fpsp and call ApplySingleFileAttributes instead of 
                // rewriting the apply attributes code
                if (pdpsp->fMountedDrive)
                {
                    GetVolumeNameForVolumeMountPoint(pdpsp->szDrive, fpsp.szPath, ARRAYSIZE(fpsp.szPath));
                }
                else
                {
                    StringCchCopy(fpsp.szPath, ARRAYSIZE(fpsp.szPath), pdpsp->szDrive);
                }

                fpsp.hDlg = pdpsp->hDlg;
                fpsp.asInitial = pdpsp->asInitial;
                fpsp.asCurrent = pdpsp->asCurrent;
                fpsp.pfci->fIsCompressionAvailable = pdpsp->fIsCompressionAvailable;
                fpsp.pfci->ulTotalNumberOfBytes.QuadPart = pdpsp->qwTot - pdpsp->qwFree; // for progress calculations
                fpsp.fIsIndexAvailable = pdpsp->fIsIndexAvailable;
                fpsp.fRecursive = pdpsp->fRecursive;
                fpsp.fIsDirectory = TRUE;
            
                bRet = ApplySingleFileAttributes(&fpsp);

                Release_FolderContentsInfo(fpsp.pfci);
                fpsp.pfci = NULL;

                // update the free/used space after applying attribs because something could
                // have changed (eg compression frees up space)
                _DrvPrshtUpdateInfo(pdpsp);

                // update the initial attributes to reflect the ones we just applied, regardless
                // if the operation was sucessful or not. If they hit cancel, then the volume
                // root was most likely still changed so we need to update.
                pdpsp->asInitial = pdpsp->asCurrent;
            }
            else
            {
                bRet = FALSE;
            }
        }

        if (!bRet)
        {
            // the user hit cancel somewhere
            return FALSE;
        }
    }

    hCtl = GetDlgItem(pdpsp->hDlg, IDC_DRV_LABEL);

    bFctRet = TRUE;

    if (Edit_GetModify(hCtl))
    {
        bFctRet = FALSE;    // assume we fail to set the label

        TCHAR szLabel[MAX_LABEL_NTFS + 1];
        GetWindowText(hCtl, szLabel, ARRAYSIZE(szLabel));

        CMountPoint* pMtPt = CMountPoint::GetMountPoint(pdpsp->szDrive);

        if ( !pMtPt )
        {
            pMtPt = CMountPoint::GetSimulatedMountPointFromVolumeGuid( pdpsp->szDrive );
        }

        if (pMtPt)
        {
            if (SUCCEEDED(pMtPt->SetLabel(GetParent(pdpsp->hDlg), szLabel)))
                bFctRet = TRUE;

            pMtPt->Release();
        }
    }

    return bFctRet;
}

const static DWORD aDrvPrshtHelpIDs[] = {  // Context Help IDs
    IDC_DRV_ICON,          IDH_FCAB_DRV_ICON,
    IDC_DRV_LABEL,         IDH_FCAB_DRV_LABEL,
    IDC_DRV_TYPE_TXT,      IDH_FCAB_DRV_TYPE,
    IDC_DRV_TYPE,          IDH_FCAB_DRV_TYPE,
    IDC_DRV_FS_TXT,        IDH_FCAB_DRV_FS,
    IDC_DRV_FS,            IDH_FCAB_DRV_FS,
    IDC_DRV_USEDCOLOR,     IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_USEDBYTES_TXT, IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_USEDBYTES,     IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_USEDMB,        IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_FREECOLOR,     IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_FREEBYTES_TXT, IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_FREEBYTES,     IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_FREEMB,        IDH_FCAB_DRV_USEDCOLORS,
    IDC_DRV_TOTSEP,        NO_HELP,
    IDC_DRV_TOTBYTES_TXT,  IDH_FCAB_DRV_TOTSEP,
    IDC_DRV_TOTBYTES,      IDH_FCAB_DRV_TOTSEP,
    IDC_DRV_TOTMB,         IDH_FCAB_DRV_TOTSEP,
    IDC_DRV_PIE,           IDH_FCAB_DRV_PIE,
    IDC_DRV_LETTER,        IDH_FCAB_DRV_LETTER,
    IDC_DRV_CLEANUP,       IDH_FCAB_DRV_CLEANUP,
    IDD_COMPRESS,          IDH_FCAB_DRV_COMPRESS,
    IDD_INDEX,             IDH_FCAB_DRV_INDEX,
    0, 0
};

//
// Descriptions:
//   This is the dialog procedure for the "general" page of a property sheet.
//
BOOL_PTR CALLBACK _DrvGeneralDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    DRIVEPROPSHEETPAGE * pdpsp = (DRIVEPROPSHEETPAGE *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage) 
    {
    case WM_INITDIALOG:
        // REVIEW, we should store more state info here, for example
        // the hIcon being displayed and the FILEINFO pointer, not just
        // the file name ptr
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pdpsp = (DRIVEPROPSHEETPAGE *)lParam;
        pdpsp->hDlg = hDlg;
        _DrvPrshtInit(pdpsp);
        break;

    case WM_DESTROY:
        ReplaceDlgIcon(hDlg, IDC_DRV_ICON, NULL);   // free the icon
        break;

    case WM_ACTIVATE:
        if (GET_WM_ACTIVATE_STATE(wParam, lParam) != WA_INACTIVE && pdpsp)
            _DrvPrshtUpdateInfo(pdpsp);
        return FALSE;   // Let DefDlgProc know we did not handle this

    case WM_DRAWITEM:
        _DrvPrshtDrawItem(pdpsp, (DRAWITEMSTRUCT *)lParam);
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aDrvPrshtHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aDrvPrshtHelpIDs);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDC_DRV_LABEL:
            if (GET_WM_COMMAND_CMD(wParam, lParam) != EN_CHANGE)
                break;
            // else, fall through
        case IDD_COMPRESS:
        case IDD_INDEX:
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
            break;

        // handle disk cleanup button      
        case IDC_DRV_CLEANUP:
            LaunchDiskCleanup(hDlg, pdpsp->iDrive, DISKCLEANUP_NOFLAG);
            break;

        default:
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) 
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            if (!_DrvPrshtApply(pdpsp))
            {
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            }
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


void _DiskToolsPrshtInit(DRIVEPROPSHEETPAGE * pdpsp)
{
    TCHAR szFmt[MAX_PATH + 20];
    DWORD cbLen = sizeof(szFmt);

    BOOL bFoundBackup = SUCCEEDED(SKGetValue(SHELLKEY_HKLM_EXPLORER, REL_KEY_BACKUP, NULL, NULL, szFmt, &cbLen));
    // If no backup utility is installed, then remove everything in the backup groupbox
    if (!bFoundBackup)
    {
        DestroyWindow(GetDlgItem(pdpsp->hDlg, IDC_DISKTOOLS_BKPNOW));
        DestroyWindow(GetDlgItem(pdpsp->hDlg, IDC_DISKTOOLS_BKPICON));
        DestroyWindow(GetDlgItem(pdpsp->hDlg, IDC_DISKTOOLS_BKPDAYS));
        DestroyWindow(GetDlgItem(pdpsp->hDlg, IDC_DISKTOOLS_BKPTXT));
    }

    cbLen = sizeof(szFmt);
    BOOL bFoundFmt = SUCCEEDED(SKGetValue(SHELLKEY_HKLM_EXPLORER, REL_KEY_DEFRAG, NULL, NULL, szFmt, &cbLen)) && szFmt[0];
    // If no defrag utility is installed, replace the default defrag text with
    // the "No defrag installed" message.  Also grey out the "defrag now" button.
    if (!bFoundFmt)
    {
        TCHAR szMessage[50];  // WARNING:  IDS_DRIVES_NOOPTINSTALLED is currently 47
        //           characters long.  Resize this buffer if
        //           the string resource is lengthened.
        
        LoadString(HINST_THISDLL, IDS_DRIVES_NOOPTINSTALLED, szMessage, ARRAYSIZE(szMessage));
        SetDlgItemText(pdpsp->hDlg, IDC_DISKTOOLS_OPTDAYS, szMessage);
        Button_Enable(GetDlgItem(pdpsp->hDlg, IDC_DISKTOOLS_OPTNOW), FALSE);
    }
}

const static DWORD aDiskToolsHelpIDs[] = {  // Context Help IDs
    IDC_DISKTOOLS_TRLIGHT,    IDH_FCAB_DISKTOOLS_CHKNOW,
    IDC_DISKTOOLS_CHKDAYS,    IDH_FCAB_DISKTOOLS_CHKNOW,
    IDC_DISKTOOLS_CHKNOW,     IDH_FCAB_DISKTOOLS_CHKNOW,
    IDC_DISKTOOLS_BKPTXT,     IDH_FCAB_DISKTOOLS_BKPNOW,
    IDC_DISKTOOLS_BKPDAYS,    IDH_FCAB_DISKTOOLS_BKPNOW,
    IDC_DISKTOOLS_BKPNOW,     IDH_FCAB_DISKTOOLS_BKPNOW,
    IDC_DISKTOOLS_OPTDAYS,    IDH_FCAB_DISKTOOLS_OPTNOW,
    IDC_DISKTOOLS_OPTNOW,     IDH_FCAB_DISKTOOLS_OPTNOW,

    0, 0
};

BOOL _DiskToolsCommand(DRIVEPROPSHEETPAGE * pdpsp, WPARAM wParam, LPARAM lParam)
{
    // Add 20 for extra formatting
    TCHAR szFmt[MAX_PATH + 20];
    TCHAR szCmd[MAX_PATH + 20];
    LPCTSTR pszRegName, pszDefFmt;
    int nErrMsg = 0;

    switch (GET_WM_COMMAND_ID(wParam, lParam))
    {
        case IDC_DISKTOOLS_CHKNOW:
            SHChkDskDriveEx(pdpsp->hDlg, pdpsp->szDrive);
            return FALSE;

        case IDC_DISKTOOLS_OPTNOW:
            pszRegName = REL_KEY_DEFRAG;
            if (pdpsp->fMountedDrive)
            {
                pszDefFmt = TEXT("defrag.exe");
            }
            else
            {
                pszDefFmt = TEXT("defrag.exe %c:");
            }
            nErrMsg =  IDS_NO_OPTIMISE_APP;
            break;

        case IDC_DISKTOOLS_BKPNOW:
            pszRegName = REL_KEY_BACKUP;
            pszDefFmt = TEXT("ntbackup.exe");
            nErrMsg = IDS_NO_BACKUP_APP;
            break;

        default:
            return FALSE;
    }

    DWORD cbLen = sizeof(szFmt);
    if (FAILED(SKGetValue(SHELLKEY_HKLM_EXPLORER, pszRegName, NULL, NULL, szFmt, &cbLen)))
    {
        // failed to read out the reg value, just use the default
        StringCchCopy(szFmt, ARRAYSIZE(szFmt), pszDefFmt);
    }

    // some apps write REG_SZ keys to the registry even though they have env variables in them
    ExpandEnvironmentStrings(szFmt, szCmd, ARRAYSIZE(szCmd));
    StringCchCopy(szFmt, ARRAYSIZE(szFmt), szCmd);

    // Plug in the drive letter in case they want it
    StringCchPrintf(szCmd, ARRAYSIZE(szCmd), szFmt, pdpsp->iDrive + TEXT('A'));

    if (!ShellExecCmdLine(pdpsp->hDlg,
                          szCmd,
                          NULL,
                          SW_SHOWNORMAL,
                          NULL,
                          SECL_USEFULLPATHDIR | SECL_NO_UI))
    {
        // Something went wrong - app's probably not installed.
        if (nErrMsg)
        {
            ShellMessageBox(HINST_THISDLL,
                            pdpsp->hDlg,
                            MAKEINTRESOURCE(nErrMsg), NULL,
                            MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
        }
        return FALSE;
    }

    return TRUE;
}

//
// Descriptions:
//   This is the dialog procedure for the "Tools" page of a property sheet.
//
BOOL_PTR CALLBACK _DiskToolsDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    DRIVEPROPSHEETPAGE * pdpsp = (DRIVEPROPSHEETPAGE *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage) 
    {
    case WM_INITDIALOG:
        // REVIEW, we should store more state info here, for example
        // the hIcon being displayed and the FILEINFO pointer, not just
        // the file name ptr
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pdpsp = (DRIVEPROPSHEETPAGE *)lParam;
        pdpsp->hDlg = hDlg;

        _DiskToolsPrshtInit(pdpsp);
        break;

    case WM_ACTIVATE:
        if (GET_WM_ACTIVATE_STATE(wParam, lParam) != WA_INACTIVE && pdpsp)
        {
            _DiskToolsPrshtInit(pdpsp);
        }
        return FALSE;   // Let DefDlgProc know we did not handle this

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aDiskToolsHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aDiskToolsHelpIDs);
        break;

    case WM_COMMAND:
        return _DiskToolsCommand(pdpsp, wParam, lParam);

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) 
        {
        case PSN_SETACTIVE:
            break;

        case PSN_APPLY:
            return TRUE;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

//
// This is the dialog procedure for the "Hardware" page.
//

const GUID c_rgguidDevMgr[] = 
{
    { 0x4d36e967, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } }, // GUID_DEVCLASS_DISKDRIVE
    { 0x4d36e980, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } }, // GUID_DEVCLASS_FLOPPYDISK
    { 0x4d36e965, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } }, // GUID_DEVCLASS_CDROM
};

BOOL_PTR CALLBACK _DriveHWDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage) 
    {
    case WM_INITDIALOG:
        {
            DRIVEPROPSHEETPAGE * pdpsp = (DRIVEPROPSHEETPAGE *)lParam;

            HWND hwndHW = DeviceCreateHardwarePageEx(hDlg, c_rgguidDevMgr, ARRAYSIZE(c_rgguidDevMgr), HWTAB_LARGELIST);
            if (hwndHW) 
            {
                TCHAR szBuf[MAX_PATH];
                LoadString(HINST_THISDLL, IDS_DRIVETSHOOT, szBuf, ARRAYSIZE(szBuf));
                SetWindowText(hwndHW, szBuf);

                LoadString(HINST_THISDLL, IDS_THESEDRIVES, szBuf, ARRAYSIZE(szBuf));
                SetDlgItemText(hwndHW, IDC_HWTAB_LVSTATIC, szBuf);
            } 
            else 
            {
                DestroyWindow(hDlg); // catastrophic failure
            }
        }
        return FALSE;
    }
    return FALSE;
}



BOOL CDrives_AddPage(LPPROPSHEETPAGE ppsp, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    BOOL fSuccess;
    HPROPSHEETPAGE hpage = CreatePropertySheetPage(ppsp);
    if (hpage)
    {
        fSuccess = pfnAddPage(hpage, lParam);
        if (!fSuccess)
        {   // Couldn't add page
            DestroyPropertySheetPage(hpage);
            fSuccess = FALSE;
        }
    }
    else
    {   // Couldn't create page
        fSuccess = FALSE;
    }
    return fSuccess;
}


HRESULT CDrives_AddPagesHelper(DRIVEPROPSHEETPAGE* pdpsp, int iType,
                               LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    if ((iType == DRIVE_NO_ROOT_DIR) ||
        (iType == DRIVE_REMOTE))
    {
        return S_OK;
    }
    
    CMountPoint* pMtPt = CMountPoint::GetMountPoint(pdpsp->szDrive);
    if (pMtPt)
    {
        if (IsShellServiceRunning())
        {
            if (pMtPt->IsStrictRemovable() || pMtPt->IsCDROM() ||
                (pMtPt->IsFixedDisk() && pMtPt->IsRemovableDevice()))
            {
                CAutoPlayDlg* papdlg = new CAutoPlayDlg();

                if (papdlg)
                {
                    // Autoplay
                    pdpsp->psp.pszTemplate = MAKEINTRESOURCE(DLG_AUTOPLAY);
                    pdpsp->psp.pfnDlgProc  = CAutoPlayDlg::BaseDlgWndProc;
                    pdpsp->psp.pfnCallback = CBaseDlg::BaseDlgPropSheetCallback;
                    pdpsp->psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;

                    papdlg->Init(pdpsp->szDrive, iType);
                    // for now
                    pdpsp->psp.lParam = (LPARAM)(CBaseDlg*)papdlg;

                    if (CDrives_AddPage(&pdpsp->psp, pfnAddPage, lParam))
                    {
                        papdlg->AddRef();
                    }

                    pdpsp->psp.lParam = NULL;
                    pdpsp->psp.pfnCallback = NULL;
                    pdpsp->psp.dwFlags = NULL;

                    papdlg->Release();
                }
            }
        }

        if ((iType != DRIVE_CDROM) || pMtPt->IsDVDRAMMedia())
        {
            // we add the tools page for non-cdrom and DVD-RAM disks
            pdpsp->psp.pszTemplate = MAKEINTRESOURCE(DLG_DISKTOOLS);
            pdpsp->psp.pfnDlgProc  = _DiskToolsDlgProc;

            CDrives_AddPage(&pdpsp->psp, pfnAddPage, lParam);
        }

        pMtPt->Release();
    }

    if (!SHRestricted(REST_NOHARDWARETAB))
    {           
        pdpsp->psp.pszTemplate = MAKEINTRESOURCE(DLG_DRV_HWTAB);
        pdpsp->psp.pfnDlgProc  = _DriveHWDlgProc;
        CDrives_AddPage(&pdpsp->psp, pfnAddPage, lParam);
    }

    return S_OK;
}

//
// We check if any of the IDList's points to a drive root.  If so, we use the
// drives property page.
// Note that drives should not be mixed with folders and files, even in a
// search window.
//
STDAPI CDrives_AddPages(IDataObject *pdtobj, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if (SUCCEEDED(pdtobj->GetData(&fmte, &medium)))
    {
        TCHAR szPath[MAX_PATH];
        int i, cItems = DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, NULL, 0);

        for (i = 0; DragQueryFile((HDROP)medium.hGlobal, i, szPath, ARRAYSIZE(szPath)); i++)
        {
            DRIVEPROPSHEETPAGE dpsp = {0};
            TCHAR szTitle[80];

            if (lstrlen(szPath) > 3)
                continue;               // can't be a drive letter
            
            dpsp.psp.dwSize      = sizeof(dpsp);    // extra data
            dpsp.psp.dwFlags     = PSP_DEFAULT;
            dpsp.psp.hInstance   = HINST_THISDLL;
            dpsp.psp.pszTemplate = MAKEINTRESOURCE(DLG_DRV_GENERAL);
            dpsp.psp.pfnDlgProc  = _DrvGeneralDlgProc,
            StringCchCopy(dpsp.szDrive, ARRAYSIZE(dpsp.szDrive), szPath);
            dpsp.iDrive          = DRIVEID(szPath);

            // if more than one drive selected give each tab the title of the drive
            // otherwise use "General"

            if (cItems > 1)
            {
                CMountPoint* pMtPt = CMountPoint::GetMountPoint(dpsp.iDrive);
                if (pMtPt)
                {
                    dpsp.psp.dwFlags = PSP_USETITLE;
                    dpsp.psp.pszTitle = szTitle;

                    pMtPt->GetDisplayName(szTitle, ARRAYSIZE(szTitle));

                    pMtPt->Release();
                }
            }

            if (!CDrives_AddPage(&dpsp.psp, pfnAddPage, lParam))
                break;

            // if only one property page added add the disk tools
            // and Hardware tab too...
            if (cItems == 1)
            {
                CDrives_AddPagesHelper(&dpsp,
                                       RealDriveType(dpsp.iDrive, FALSE /* fOKToHitNet */),
                                       pfnAddPage,
                                       lParam);
            }
        }
        ReleaseStgMedium(&medium);
    }
    else
    {
        // try mounteddrive
        fmte.cfFormat = g_cfMountedVolume;

        // Can we retrieve the MountedVolume format?
        if (SUCCEEDED(pdtobj->GetData(&fmte, &medium)))
        {
            // Yes
            DRIVEPROPSHEETPAGE dpsp = {0};
            HPROPSHEETPAGE hpage;
            TCHAR szMountPoint[MAX_PATH];

            dpsp.psp.dwSize      = sizeof(dpsp);    // extra data
            dpsp.psp.dwFlags     = PSP_DEFAULT;
            dpsp.psp.hInstance   = HINST_THISDLL;
            dpsp.psp.pszTemplate = MAKEINTRESOURCE(DLG_DRV_GENERAL);
            dpsp.psp.pfnDlgProc  = _DrvGeneralDlgProc,
            dpsp.iDrive          = -1;
            dpsp.fMountedDrive   = TRUE;

            DragQueryFile((HDROP)medium.hGlobal, 0, szMountPoint, ARRAYSIZE(szMountPoint));

            StringCchCopy(dpsp.szDrive, ARRAYSIZE(dpsp.szDrive), szMountPoint);

            hpage = CreatePropertySheetPage(&dpsp.psp);
            if (hpage)
            {
                if (!pfnAddPage(hpage, lParam))
                {
                    DestroyPropertySheetPage(hpage);
                }
            }

            // Disk tools page
            CMountPoint* pMtPt = CMountPoint::GetMountPoint(szMountPoint);
            if (pMtPt)
            {
                CDrives_AddPagesHelper(&dpsp, GetDriveType(szMountPoint),
                               pfnAddPage, lParam);
                pMtPt->Release();
            }

            ReleaseStgMedium(&medium);
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duidrag.cpp ===
#include "shellprv.h"
#include "duiview.h"
#include "duidrag.h"


CDUIDropTarget::CDUIDropTarget()
{
    _cRef = 1;
    _pDT = NULL;
    _pNextDT = NULL;
}

CDUIDropTarget::~CDUIDropTarget()
{
    _Cleanup();
}

HRESULT CDUIDropTarget::QueryInterface (REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CDUIDropTarget, IDropTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

ULONG CDUIDropTarget::AddRef (void)
{
    return ++_cRef;
}

ULONG CDUIDropTarget::Release (void)
{
    if (--_cRef == 0) {
        delete this;
        return 0;
    }

    return _cRef;
}


// Called by duser / directui to get the IDropTarget interface for the element
// the mouse just moved over.  It is important to understand the sequencing
// calls.  Initialize is called BEFORE DragLeave is called on the previous element's
// IDropTarget, so we can't switch out _pDT right away.  Instead, we'll store the
// new IDropTarget in _pNextDT and then in DragEnter, we'll move it over to _pDT.
//
// The sequence looks like this:
//
//    Initialize()    for first element (bumps ref count to 2)
//    DragEnter
//    DragMove

//    Initialize()    for second element (bumps ref count to 3)
//    DragLeave       for first element
//    Release         for first element  (decrements ref count to 2)

//    DragEnter       for second element

HRESULT CDUIDropTarget::Initialize (LPITEMIDLIST pidl, HWND hWnd, IDropTarget **pdt)
{
    ASSERT(_pNextDT == NULL);

    if (pidl)
    {
        SHGetUIObjectFromFullPIDL(pidl, hWnd, IID_PPV_ARG(IDropTarget, &_pNextDT));
    }

    QueryInterface (IID_PPV_ARG(IDropTarget, pdt));

    return S_OK;
}

VOID CDUIDropTarget::_Cleanup ()
{
    if (_pDT)
    {
        _pDT->Release();
        _pDT = NULL;
    }
}

STDMETHODIMP CDUIDropTarget::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    if ((_pDT != _pNextDT) || (_cRef == 2))
    {
        _pDT = _pNextDT;
        _pNextDT = NULL;

        if (_pDT)
        {
            _pDT->DragEnter (pDataObj, grfKeyState, ptl, pdwEffect);
        }
        else
        {
            *pdwEffect = DROPEFFECT_NONE;
        }

        POINT pt;
        GetCursorPos(&pt);
        DAD_DragEnterEx2 (NULL, pt, pDataObj);
    }

    return S_OK;
}

STDMETHODIMP CDUIDropTarget::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    if (_pDT)
    {
        _pDT->DragOver (grfKeyState, ptl, pdwEffect);
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }

    POINT pt;
    GetCursorPos(&pt);
    DAD_DragMove (pt);

    return S_OK;
}

STDMETHODIMP CDUIDropTarget::DragLeave(void)
{
    if (_pDT || (_cRef == 2))
    {
        if (_pDT)
        {
            _pDT->DragLeave ();
        }

        DAD_DragLeave();
        _Cleanup();
    }

    return S_OK;
}

STDMETHODIMP CDUIDropTarget::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    POINT pt = {ptl.x, ptl.y};
    HRESULT hr = S_OK;

    if (_pDT)
    {
        hr = _pDT->Drop (pDataObj, grfKeyState, ptl, pdwEffect);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duihost.cpp ===
#include "shellprv.h"
#include "duiview.h"
#include "duihost.h"


// DUIAxHost Initialization

HRESULT DUIAxHost::Create(UINT nCreate, UINT nActive, OUT DUIAxHost** ppElement)
{
    *ppElement = NULL;

    DUIAxHost* pe = HNewAndZero<DUIAxHost>();
    if (!pe)
        return E_OUTOFMEMORY;

    HRESULT hr = pe->Initialize(nCreate, nActive);
    if (FAILED(hr))
    {
        pe->Destroy();
    }
    else
    {
        *ppElement = pe;
    }

    return hr;
}

HWND DUIAxHost::CreateHWND(HWND hwndParent)
{
    return CreateWindowEx(0, CAxWindow::GetWndClassName(), NULL,
                          WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                          0, 0, 0, 0, hwndParent, NULL, NULL, NULL);
}


HRESULT DUIAxHost::SetSite(IUnknown* punkSite)
{
    CComPtr<IUnknown> spHost;
    HRESULT hr = AtlAxGetHost(GetHWND(), &spHost);
    if (SUCCEEDED(hr))
    {
        hr = IUnknown_SetSite(spHost, punkSite);
    }
    return hr;
}

void DUIAxHost::OnDestroy()
{
    SetSite(NULL);
    HWNDHost::OnDestroy();
    ATOMICRELEASE(_pOleObject);
}

bool DUIAxHost::OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet)
{
    switch (nMsg) 
    {
    case WM_DESTROY:
        SetSite(NULL);
        break;
    }

    return HWNDHost::OnNotify(nMsg, wParam, lParam, plRet);
}

HRESULT DUIAxHost::AttachControl(IUnknown* punkObject)
{
    if (NULL == GetHWND())
        return E_UNEXPECTED;

    if (NULL == punkObject)
        return E_INVALIDARG;

    ATOMICRELEASE(_pOleObject);

    HRESULT hr = punkObject->QueryInterface(IID_PPV_ARG(IOleObject, &_pOleObject));
    if (SUCCEEDED(hr))
    {
        CComPtr<IUnknown> spUnk;
        hr = AtlAxGetHost(GetHWND(), &spUnk);
        if (SUCCEEDED(hr))
        {
            CComPtr<IAxWinHostWindow> spDUIAxHostWindow;
            hr = spUnk->QueryInterface(&spDUIAxHostWindow);
            if (SUCCEEDED(hr))
            {
                hr = spDUIAxHostWindow->AttachControl(punkObject, GetHWND());
            }
        }
    }

    return hr;
}

////////////////////////////////////////////////////////
// DUIAxHost Rendering

SIZE DUIAxHost::GetContentSize(int dConstW, int dConstH, Surface* psrf)
{
    SIZE size = { 0, 0 };

    // Ask the attached ActiveX control for its preferred size
    if (NULL != _pOleObject)
    {
        SIZEL sizeT;
        if (SUCCEEDED(_pOleObject->GetExtent(DVASPECT_CONTENT, &sizeT)))
        {
            int dpiX;
            int dpiY;

            switch (psrf->GetType())
            {
            case Surface::stDC:
                {
                    HDC hDC = CastHDC(psrf);
                    dpiX = GetDeviceCaps(hDC, LOGPIXELSX);
                    dpiY = GetDeviceCaps(hDC, LOGPIXELSX);
                }
                break;

#ifdef GADGET_ENABLE_GDIPLUS
            case Surface::stGdiPlus:
                {
                    Gdiplus::Graphics * pgpgr = CastGraphics(psrf);
                    dpiX = (int)pgpgr->GetDpiX();
                    dpiY = (int)pgpgr->GetDpiY();
                }
                break;
#endif
            default:
                dpiX = dpiY = 96;
                break;
            }

            // Convert from HIMETRIC to pixels
            size.cx = (MAXLONG == sizeT.cx) ? MAXLONG : MulDiv(sizeT.cx, dpiX, 2540);
            size.cy = (MAXLONG == sizeT.cy) ? MAXLONG : MulDiv(sizeT.cy, dpiY, 2540);

            if (-1 != dConstW && size.cx > dConstW) size.cx = dConstW;
            if (-1 != dConstH && size.cy > dConstH) size.cy = dConstH;
        }
    }

    return size;
}

////////////////////////////////////////////////////////
// DUIAxHost Keyboard navigation

void DUIAxHost::SetKeyFocus()
{
    FakeTabEvent();

    // No matter what, we should continue with standard DUI operations.
    Element::SetKeyFocus();
}

void DUIAxHost::OnEvent(Event* pEvent)
{
    bool fHandled = false;

    if (pEvent->nStage == GMF_DIRECT && pEvent->uidType == Element::KeyboardNavigate) {
        int iNavDir = ((KeyboardNavigateEvent*) pEvent)->iNavDir;
        if (((iNavDir & NAV_NEXT) == NAV_NEXT) || ((iNavDir & NAV_PREV) == NAV_PREV)) {
            fHandled = FakeTabEvent();
         } else {
             // Handle other types of navigation here... (home/end/etc)
         }
    }

    // Continue with standard DUI operation if the navigation event wasn't handled
    // by our contained ActiveX control.
    if (!fHandled) {
        Element::OnEvent(pEvent);
    }
}

bool DUIAxHost::FakeTabEvent()
{
    bool fHandled = false;

    MSG msg = { 0 };

    msg.message = WM_KEYDOWN;
    msg.wParam = VK_TAB;
    msg.lParam = 1;

    // Note: we probably should do something to respect navoigating forward
    // or backwards.  The ActiveX control needs to know if it should activate
    // the first or last tab stop.  For now it will only reliably
    // activate the first one.  If it checks the keyboard Shift state
    // it will probably get it right, but not 100% guaranteed.

    if(SendMessage(GetHWND(), WM_FORWARDMSG, 0, (LPARAM)&msg)) {
        fHandled = true;
    }
            
    return fHandled;
}

// Define class info with type and base type, set static class pointer
IClassInfo* DUIAxHost::Class = NULL;
HRESULT DUIAxHost::Register()
{
    return ClassInfo<DUIAxHost,HWNDHost>::Register(L"DUIAxHost", NULL, 0);
}

HRESULT DUIAxHost::GetAccessibleImpl(IAccessible ** ppAccessible)
{
    return CreateStdAccessibleObject(GetHWND(), OBJID_CLIENT, IID_PPV_ARG(IAccessible, ppAccessible));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duihost.h ===
class DUIAxHost : public HWNDHost
{
public:
    static HRESULT Create(Element**) { return E_NOTIMPL; } // Required for ClassInfo
    static HRESULT Create(OUT DUIAxHost** ppElement) { return Create(0, AE_MouseAndKeyboard, ppElement); }
    static HRESULT Create(UINT nCreate, UINT nActive, OUT DUIAxHost** ppElement);

    ~DUIAxHost() { ATOMICRELEASE(_pOleObject); }

    // Initialization
    HRESULT SetSite(IUnknown* punkSite);
    HRESULT AttachControl(IUnknown* punkObject);

    virtual bool OnNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRet);
    virtual void OnDestroy();

    // Rendering
    virtual SIZE GetContentSize(int dConstW, int dConstH, Surface* psrf);

    // Keyboard navigation
    virtual void SetKeyFocus();
    virtual void OnEvent(Event* pEvent);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    DUIAxHost() : _pOleObject(NULL) {}
    bool FakeTabEvent();

    virtual HWND CreateHWND(HWND hwndParent);

    virtual HRESULT GetAccessibleImpl(IAccessible ** ppAccessible);

private:
    IOleObject* _pOleObject;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duidrag.h ===
class CDUIDropTarget:
    public IDropTarget
{

protected:
    ULONG         _cRef;
    IDropTarget * _pDT;
    IDropTarget * _pNextDT;

public:
    CDUIDropTarget();

    // IUnknown methods
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDropTarget methods
    STDMETHODIMP DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect);

    HRESULT Initialize (LPITEMIDLIST pidl, HWND hWnd, IDropTarget **pdt);

private:
    ~CDUIDropTarget();

    VOID _Cleanup();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duilist.h ===
// DUIListView

// Class definition
class DUIListView : public HWNDHost
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(AE_MouseAndKeyboard, NULL, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement) { return Create(nActive, NULL, ppElement); }
    static HRESULT Create(UINT nActive, HWND hwndListView, OUT Element** ppElement);

    // System events
    virtual void OnInput(InputEvent* pie);

    virtual UINT MessageCallback(GMSG* pGMsg);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    void DetachListview();

    DUIListView() { }
    ~DUIListView();
    HRESULT Initialize(UINT nActive, HWND hwndListView) { m_hwndListview = hwndListView; return HWNDHost::Initialize(HHC_CacheFont | HHC_NoMouseForward, nActive); }

    virtual HWND CreateHWND(HWND hwndParent);

private:

    HWND m_hwndParent;
    HWND m_hwndLVOrgParent;
    HWND m_hwndListview;
    BOOL m_bClientEdge;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duiinfo.cpp ===
#include "shellprv.h"
#include "duiinfo.h"
#include "ids.h"
#include "datautil.h"


DWORD FormatMessageArg(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageID, DWORD dwLangID,
        LPWSTR pwzBuffer, DWORD cchSize, ...)
{
    va_list vaParamList;

    va_start(vaParamList, cchSize);
    DWORD dwResult = FormatMessageW(dwFlags, lpSource, dwMessageID, dwLangID, pwzBuffer,
        cchSize, &vaParamList);
    va_end(vaParamList);

    return dwResult;
}

CNameSpaceItemUIProperty::~CNameSpaceItemUIProperty()
{
}

void CNameSpaceItemUIProperty::_SetParentAndItem(IShellFolder2 *psf, LPCITEMIDLIST pidl)
{
    // set aliases to current values these are not refed
    // it is assumed that all helpers that use these variables won't be called
    // unless these have been set. since this can't fail this all works out fine
    m_psf = psf;        // alias, not refed
    m_pidl = pidl;      // alias, not cloned
}

STDMETHODIMP CNameSpaceItemUIProperty::GetPropertyDisplayName(SHCOLUMNID scid, WCHAR* pwszPropDisplayName, int cchPropDisplayName)
{
    *pwszPropDisplayName = 0;
    
    CComPtr<IPropertyUI> spPropertyUI;
    HRESULT hr = _GetPropertyUI(&spPropertyUI);
    if (SUCCEEDED(hr))
    {
        hr = spPropertyUI->GetDisplayName(
                scid.fmtid,
                scid.pid,
                PUIFNF_DEFAULT,
                pwszPropDisplayName,
                cchPropDisplayName);
    }

    return hr;
}

STDMETHODIMP CNameSpaceItemUIProperty::GetPropertyDisplayValue(SHCOLUMNID scid, WCHAR* pszValue, int cch, PROPERTYUI_FORMAT_FLAGS flagsFormat)
{
    *pszValue = 0;
    HRESULT hr = E_FAIL;
    
    // Use GetDisplayNameOf for the SCID_NAME property
    if (IsEqualSCID(scid, SCID_NAME))
    {
        hr = DisplayNameOf(m_psf, m_pidl, SHGDN_INFOLDER, pszValue, cch);
    }
    else
    {   // Use GetDetailsEx to get the value
        CComVariant varPropDisplayValue;
        
        if (m_psf->GetDetailsEx(m_pidl, &scid, &varPropDisplayValue) == S_OK) // S_FALSE means property wasn't there.
        {
            if (IsEqualSCID(scid, SCID_SIZE) && 
                ((varPropDisplayValue.vt == VT_UI8) && (varPropDisplayValue.ullVal <= 0)))
            {
                hr = E_FAIL;    // Don't display 0 byte sizes
            }
            else
            {
                CComPtr<IPropertyUI> spPropertyUI;
                hr = _GetPropertyUI(&spPropertyUI);
                if (SUCCEEDED(hr))
                {
                    hr = spPropertyUI->FormatForDisplay(scid.fmtid, scid.pid,
                            (PROPVARIANT*)&varPropDisplayValue,  //cast from VARIANT to PROPVARIANT should be ok
                            flagsFormat, pszValue, cch);
                }
            }
        }
    }
    return hr;
}

HRESULT CNameSpaceItemUIProperty::_GetPropertyUI(IPropertyUI **pppui)
{
    HRESULT hr = E_FAIL;
    if (!m_spPropertyUI)
    {
        hr = SHCoCreateInstance(NULL, &CLSID_PropertiesUI, NULL, IID_PPV_ARG(IPropertyUI, &m_spPropertyUI));
    }
    
    *pppui = m_spPropertyUI;
    if (*pppui)
    {
        (*pppui)->AddRef();
        hr = S_OK;
    }
    return hr;
}

CNameSpaceItemInfoList::~CNameSpaceItemInfoList()
{
    if (m_pDUIView)
    {
        m_pDUIView->SetDetailsInfoMsgWindowPtr(NULL, this);
        m_pDUIView->Release();
    }
}

STDMETHODIMP CNameSpaceItemInfoList::Create(CDUIView* pDUIView, Value* pvDetailsSheet,
        IShellItemArray *psiItemArray, Element** ppElement)
{
    HRESULT hr;

    *ppElement = NULL;

    CNameSpaceItemInfoList* pNSIInfoList = HNewAndZero<CNameSpaceItemInfoList>();
    if (!pNSIInfoList)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pNSIInfoList->Initialize(pDUIView, pvDetailsSheet, psiItemArray);
        if (SUCCEEDED(hr))
            *ppElement = pNSIInfoList;
        else
            pNSIInfoList->Destroy();
    }

    return hr;
}

STDMETHODIMP CNameSpaceItemInfoList::Initialize(CDUIView* pDUIView, Value* pvDetailsSheet,
        IShellItemArray *psiItemArray)
{
    HRESULT hr = Element::Initialize(0);
    if (SUCCEEDED(hr))
    {
        IDataObject *pdtobj = NULL;

        (m_pDUIView = pDUIView)->AddRef();
        
         Value* pvLayout = NULL;
        int arVLOptions[] = { FALSE, ALIGN_LEFT, ALIGN_JUSTIFY, ALIGN_TOP };
        hr = VerticalFlowLayout::Create(ARRAYSIZE(arVLOptions), arVLOptions, &pvLayout);
        if (SUCCEEDED(hr))
        {
            SetValue(LayoutProp, PI_Local, pvLayout);
            pvLayout->Release();
        }

        if (pvDetailsSheet)
        {
            SetValue(SheetProp, PI_Local, pvDetailsSheet);
        }

        // the HIDA format has 2 forms, one is each item in the array is a
        // fully qualified pidl. this is what the search folder produces
        // the other is the items are relative to a sigle folder pidl
        // the code below deals with both cases

        // Should just use use the ShellItemArray instead of getting the HIDA
        if (psiItemArray)
        {
            if (FAILED(psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdtobj))))
            {
                pdtobj = NULL;
            }

        }
        hr = S_OK;
        BOOL bDetailsAvailable = FALSE;

        if (pdtobj)
        {
            STGMEDIUM medium;
            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                IShellFolder2 *psfRoot;
                LPCITEMIDLIST pidlFolder = HIDA_GetPIDLFolder(pida);
                hr = SHBindToObjectEx(NULL, pidlFolder, NULL, IID_PPV_ARG(IShellFolder2, &psfRoot));
                if (SUCCEEDED(hr))
                {
                    if (pida->cidl == 1)
                    {
                        LPCITEMIDLIST pidlItem = IDA_GetIDListPtr(pida, 0);
                        IShellFolder2 *psf;
                        LPCITEMIDLIST pidl;
                        hr = SHBindToFolderIDListParent(psfRoot, pidlItem, IID_PPV_ARG(IShellFolder2, &psf), &pidl);
                        if (SUCCEEDED(hr))
                        {
                            ULONG rgfInOut = SFGAO_FOLDER | SFGAO_ISSLOW;
                            if (SUCCEEDED(psf->GetAttributesOf(1, &pidl, &rgfInOut)) && !(rgfInOut & SFGAO_ISSLOW))
                            {
                                if (!(rgfInOut & SFGAO_FOLDER) && m_pDUIView->ShouldShowMiniPreview())
                                {
                                    _AddMiniPreviewerToList(psf, pidl);
                                    bDetailsAvailable = TRUE;
                                }

                                LPITEMIDLIST  pidlFull;
                                if (SUCCEEDED(SHILCombine(pidlFolder, pidlItem, &pidlFull)))
                                {
                                    if (SUCCEEDED(m_pDUIView->InitializeDetailsInfo(
                                            CNameSpaceItemInfoList::WindowProc)))
                                    {
                                        m_pDUIView->SetDetailsInfoMsgWindowPtr(this, NULL);
                                        m_pDUIView->StartInfoExtraction(pidlFull);
                                        bDetailsAvailable = TRUE;
                                    }
                                    ILFree(pidlFull);
                                }
                            }

                            psf->Release();
                        }
                    }
                    else
                    {
                        hr = _OnMultiSelect(psfRoot, pida);
                        bDetailsAvailable = SUCCEEDED(hr);
                    }
                    psfRoot->Release();
                }
                HIDA_ReleaseStgMedium(pida, &medium);
            }

            pdtobj->Release();
        }


        if (!pdtobj || !bDetailsAvailable)
        {
            pDUIView->ShowDetails(FALSE);
        }
    }
    return hr;
}

LRESULT CALLBACK CNameSpaceItemInfoList::WindowProc(HWND hwnd, UINT uMsg,
        WPARAM wParam, LPARAM lParam)
{
    CNameSpaceItemInfoList* pNSIInfoList = (CNameSpaceItemInfoList*)::GetWindowPtr(hwnd, 0);

    switch(uMsg)
    {
    case WM_DESTROY:
        // ignore late messages
        {
            MSG msg;
            while (PeekMessage(&msg, hwnd, WM_DETAILS_INFO, WM_DETAILS_INFO, PM_REMOVE))
            {
                if (msg.lParam)
                {
                    CDetailsInfoList* pDetailsInfoList = (CDetailsInfoList*)msg.lParam;
                    // The destructor will do the necessary cleanup
                    delete pDetailsInfoList;
                }
            }
            SetWindowPtr(hwnd, 0, NULL);
        }
        break;

    case WM_DETAILS_INFO:
    {
        // Check that pDetailsInfo is still alive and that you have a CDetailsInfoList object of the requested pidl
        CDetailsInfoList* pDetailsInfoList = (CDetailsInfoList*)lParam;
        if (pDetailsInfoList && pNSIInfoList
                && (wParam == pNSIInfoList->m_pDUIView->_dwDetailsInfoID))
        {
            BOOL fShow = FALSE;

            StartDefer();

            Element * peDetailsInfoArea = pNSIInfoList->GetParent();

            if (peDetailsInfoArea)
            {
                peDetailsInfoArea->RemoveLocalValue(HeightProp);
            }

            for (int i = 0; i < pDetailsInfoList->_nProperties; i++)
            {
                if (!pDetailsInfoList->_diProperty[i].bstrValue)
                {
                    continue;
                }

                // 253647 - surpress the comment field from showing in the
                // Details section.  Note, I left the support for Comments
                // in the code below because this decision might be reversed.
                if (IsEqualSCID(pDetailsInfoList->_diProperty[i].scid, SCID_Comment))
                {
                    continue;
                }
                
                WCHAR wszInfoString[INTERNET_MAX_URL_LENGTH];
                wszInfoString[0] = L'\0';
                
                SHCOLUMNID scid = pDetailsInfoList->_diProperty[i].scid;
                // No DisplayName if we don't have one
                // or if it is one of the following properties
                if ((!pDetailsInfoList->_diProperty[i].bstrDisplayName)
                        || ( IsEqualSCID(scid, SCID_NAME)
                        ||   IsEqualSCID(scid, SCID_TYPE)
                        ||   IsEqualSCID(scid, SCID_Comment) ))
                {
                    StringCchCopyW(wszInfoString, ARRAYSIZE(wszInfoString), pDetailsInfoList->_diProperty[i].bstrValue);
                }
                else
                {
                    // Now, combine the display name and value, seperated by a colon
                    // ShellConstructMessageString here to form the string.  Note:  A
                    // truncated string in wszInfoString is not considered fatal.
                    WCHAR wszFormatStr[50];
                    LoadStringW(HINST_THISDLL, IDS_COLONSEPERATED, wszFormatStr, ARRAYSIZE(wszFormatStr));
                    FormatMessageArg(FORMAT_MESSAGE_FROM_STRING, wszFormatStr, 0, 0,
                            wszInfoString, ARRAYSIZE(wszInfoString),
                            pDetailsInfoList->_diProperty[i].bstrDisplayName,
                            pDetailsInfoList->_diProperty[i].bstrValue);
                }

                if (wszInfoString[0])
                {
                    Element* pElement;
                    HRESULT hr = CNameSpaceItemInfo::Create(wszInfoString, &pElement);
                    if (SUCCEEDED(hr))
                    {
                        hr = pNSIInfoList->Add(pElement);
                        
                        if (IsEqualSCID(scid, SCID_NAME))
                        {
                            pElement->SetID(L"InfoName");
                        }
                        else if (IsEqualSCID(scid, SCID_TYPE))
                        {
                            pElement->SetID(L"InfoType");
                        }
                        else if (IsEqualSCID(scid, SCID_Comment))
                        {
                            pElement->SetID(L"InfoTip");
                        }

                        fShow = TRUE;
                    }
                }
            }

            pNSIInfoList->m_pDUIView->ShowDetails(fShow);

            EndDefer();
        }

        if (pDetailsInfoList)
        {
            delete pDetailsInfoList;    // The destructor will do the necessary cleanup
        }
        break;
    }

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return (LRESULT)0;
}

HRESULT CNameSpaceItemInfoList::_AddMiniPreviewerToList(IShellFolder2 *psf, LPCITEMIDLIST pidl)
{
    Element* pElement;
    HRESULT hr = CMiniPreviewer::Create(m_pDUIView, psf, pidl, &pElement);
    if (SUCCEEDED(hr))
    {
        hr = Add(pElement);
    }
    return E_NOTIMPL;
}

#define MAX_FILES_FOR_COMPUTING_SIZE        100

HRESULT CNameSpaceItemInfoList::_OnMultiSelect(IShellFolder2 *psfRoot, LPIDA pida)
{
    WCHAR wszText[INTERNET_MAX_URL_LENGTH];
    
    // Get the format string for n selection text
    WCHAR wszFormatStr[128];
    LoadStringW(HINST_THISDLL, IDS_NSELECTED, wszFormatStr, ARRAYSIZE(wszFormatStr));

    // Now, form the n selection text
    StringCchPrintfW(wszText, ARRAYSIZE(wszText), wszFormatStr, pida->cidl); // truncation ok (for display only)

    CComPtr<IPropertyUI> spPropertyUI;
    HRESULT hr = _GetPropertyUI(&spPropertyUI);
    if (SUCCEEDED(hr))
    {
        ULONGLONG ullSizeTotal = 0;
        if (pida->cidl <= MAX_FILES_FOR_COMPUTING_SIZE)
        {
            // Compute the total size and the names of the selected files
            for (UINT i = 0; i < pida->cidl; i++)
            {
                IShellFolder2 *psf;
                LPCITEMIDLIST pidl;
                hr = SHBindToFolderIDListParent(psfRoot, IDA_GetIDListPtr(pida, i), IID_PPV_ARG(IShellFolder2, &psf), &pidl);
                if (SUCCEEDED(hr))
                {
                    ULONGLONG ullSize;
                    if (SUCCEEDED(GetLongProperty(psf, pidl, &SCID_SIZE, &ullSize)))
                    {
                        ullSizeTotal += ullSize;
                    }
                    psf->Release();
                }
            }
        }

        // Get the display string for Total Size
        if (ullSizeTotal > 0)
        {
            // Convert ullSizeTotal to a string
            PROPVARIANT propvar;
            propvar.vt = VT_UI8;
            propvar.uhVal.QuadPart = ullSizeTotal;

            WCHAR wszFormattedTotalSize[128];
            if (SUCCEEDED(spPropertyUI->FormatForDisplay(SCID_SIZE.fmtid, SCID_SIZE.pid,
                    &propvar, PUIFFDF_DEFAULT, wszFormattedTotalSize,
                    ARRAYSIZE(wszFormattedTotalSize))))
            {
                // Get the format string for Total File Size text
                LoadStringW(HINST_THISDLL, IDS_TOTALFILESIZE, wszFormatStr, ARRAYSIZE(wszFormatStr));

                // Now, form the Total File Size text
                WCHAR wszTemp[MAX_PATH];
                if (SUCCEEDED(StringCchPrintfW(wszTemp, ARRAYSIZE(wszTemp), wszFormatStr, wszFormattedTotalSize)))
                {
                    // Append two line breaks
                    StringCchCatW(wszText, ARRAYSIZE(wszText), L"\n\n"); // truncation ok (for display only)
                    // Append the Total Size string
                    StringCchCatW(wszText, ARRAYSIZE(wszText), wszTemp); // truncation ok (for display only)
                }
            }
        }
    }

    // Now make a dui gadget for wszText
    Element* pElement;
    if (SUCCEEDED(CNameSpaceItemInfo::Create(wszText, &pElement)))
    {
        Add(pElement);
    }

    return S_OK;
}

IClassInfo* CNameSpaceItemInfoList::Class = NULL;
HRESULT CNameSpaceItemInfoList::Register()
{
    return ClassInfo<CNameSpaceItemInfoList,Element>::Register(L"NameSpaceItemInfoList", NULL, 0);
}


STDMETHODIMP CNameSpaceItemInfo::Create(WCHAR* pwszInfoString, Element** ppElement)
{
    *ppElement = NULL;
    HRESULT hr = E_FAIL;

    CNameSpaceItemInfo* pNSIInfo = HNewAndZero<CNameSpaceItemInfo>();
    if (!pNSIInfo)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pNSIInfo->Initialize(pwszInfoString);
        if (SUCCEEDED(hr))
            *ppElement = pNSIInfo;
        else
            pNSIInfo->Destroy();
    }
    return hr;
}

STDMETHODIMP CNameSpaceItemInfo::Initialize(WCHAR* pwszInfoString)
{
    HRESULT hr = Element::Initialize(0);
    if (SUCCEEDED(hr))
    {
        hr = SetContentString(pwszInfoString);
    }
    return hr;
}

IClassInfo* CNameSpaceItemInfo::Class = NULL;
HRESULT CNameSpaceItemInfo::Register()
{
    return ClassInfo<CNameSpaceItemInfo,Element>::Register(L"NameSpaceItemInfo", NULL, 0);
}


STDMETHODIMP CBitmapElement::Create(HBITMAP hBitmap, Element** ppElement)
{
    *ppElement = NULL;
    HRESULT hr;

    CBitmapElement* pBitmapElement = HNewAndZero<CBitmapElement>();
    if (!pBitmapElement)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pBitmapElement->Initialize(hBitmap);
        if (SUCCEEDED(hr))
            *ppElement = pBitmapElement;
        else
            pBitmapElement->Destroy();
    }
    return hr;
}

STDMETHODIMP CBitmapElement::Initialize(HBITMAP hBitmap)
{
    HRESULT hr = Element::Initialize(0);
    if (SUCCEEDED(hr))
    {
        if (hBitmap)
        {
            Value* pGraphic = Value::CreateGraphic(hBitmap);
            if (pGraphic)
            {
                SetValue(ContentProp, PI_Local, pGraphic);
                pGraphic->Release();
            }
        }
    }
    return hr;
}

IClassInfo* CBitmapElement::Class = NULL;
HRESULT CBitmapElement::Register()
{
    return ClassInfo<CBitmapElement,Element>::Register(L"BitmapElement", NULL, 0);
}


CMiniPreviewer::~CMiniPreviewer()
{
    // We are going away
    if (m_pDUIView)
    {
        m_pDUIView->SetThumbnailMsgWindowPtr(NULL, this);
        m_pDUIView->Release();
    }
}

STDMETHODIMP CMiniPreviewer::Create(CDUIView* pDUIView, IShellFolder2* psf, LPCITEMIDLIST pidl, Element** ppElement)
{
    HRESULT hr;

    *ppElement = NULL;

    CMiniPreviewer* pMiniPreviewer = HNewAndZero<CMiniPreviewer>();
    if (!pMiniPreviewer)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = pMiniPreviewer->Initialize(pDUIView, psf, pidl);
        if (SUCCEEDED(hr))
            *ppElement = pMiniPreviewer;
        else
            pMiniPreviewer->Destroy();
    }

    return hr;
}

STDMETHODIMP CMiniPreviewer::Initialize(CDUIView* pDUIView, IShellFolder2 *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = Element::Initialize(0);
    if (SUCCEEDED(hr))
    {
        (m_pDUIView = pDUIView)->AddRef();

        LPITEMIDLIST pidlFull;
        if (SUCCEEDED(SHFullIDListFromFolderAndItem(psf, pidl, &pidlFull)))
        {
            if (SUCCEEDED(m_pDUIView->InitializeThumbnail(CMiniPreviewer::WindowProc)))
            {
                m_pDUIView->SetThumbnailMsgWindowPtr(this, NULL);
                m_pDUIView->StartBitmapExtraction(pidlFull);
            }
            ILFree(pidlFull);
        }
    }
    return hr;
}

// Window procedure for catching the "image-extraction-done" message
// from m_pDUIView->_spThumbnailExtractor2
LRESULT CALLBACK CMiniPreviewer::WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMiniPreviewer* pMiniPreviewer = (CMiniPreviewer*)::GetWindowPtr(hwnd, 0);

    switch(uMsg)
    {
    case WM_DESTROY:
        // ignore late messages
        {
            MSG msg;
            while (PeekMessage(&msg, hwnd, WM_HTML_BITMAP, WM_HTML_BITMAP, PM_REMOVE))
            {
                if (msg.lParam)
                {
                    DeleteObject((HBITMAP)msg.lParam);
                }
            }
            SetWindowPtr(hwnd, 0, NULL);
        }
        break;

    case WM_HTML_BITMAP:
        // Check that pMiniPreviewer is still alive and that you have an HBITMAP of the requested pidl
        if (pMiniPreviewer && (wParam == pMiniPreviewer->m_pDUIView->_dwThumbnailID))
        {
            if (lParam) // This is the HBITMAP of the extracted image
            {
                Element* pElement;
                HRESULT hr = CBitmapElement::Create((HBITMAP)lParam, &pElement);
                if (SUCCEEDED(hr))
                {
                    // The addition of the thumbnail comes in late.  DUI is
                    // not currently set up to handle a DisableAnimations()/
                    // EnableAnimations() here, which we were originally
                    // doing to prevent jumpiness.  This was discovered in
                    // RAID 389343, because our coming off the background
                    // thread and calling DisableAnimations() was screwing up
                    // other animations that were already underway.  Talking
                    // with markfi, the problem is understood BUT not one to
                    // be fixed because of the negative perf impact it would
                    // have on DUI.  So instead we'll StartDefer()/EndDefer()
                    // to minimize jumpiness from our two layout ops below.
                    StartDefer();

                    // Set the VerticalFlowLayout for our element. Otherwise,
                    // our control will not render.
                    Value* pvLayout = NULL;
                    hr = FillLayout::Create(0, NULL, &pvLayout);
                    if (SUCCEEDED(hr))
                    {
                        hr = pMiniPreviewer->SetValue(LayoutProp, PI_Local, pvLayout);
                        if (SUCCEEDED(hr))
                        {
                            hr = pMiniPreviewer->Add(pElement);
                        }
                        pvLayout->Release();
                    }
                    
                    if (FAILED(hr))
                    {
                        pElement->Destroy();
                    }

                    EndDefer();
                }
                else
                {
                    DeleteObject((HBITMAP)lParam);
                }
            }
        }
        else if (lParam)    // This extraction got done too late.
                            // So, just delete the wasted HBITMAP.
        {
            DeleteObject((HBITMAP)lParam);
        }
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return (LRESULT)0;
}

IClassInfo* CMiniPreviewer::Class = NULL;
HRESULT CMiniPreviewer::Register()
{
    return ClassInfo<CMiniPreviewer,Element>::Register(L"MiniPreviewer", NULL, 0);
}





// ***** CDetailsInfoList *******

CDetailsInfoList::CDetailsInfoList() : _nProperties(0)
{
}

CDetailsInfoList::~CDetailsInfoList()
{
    for (int i = 0; i < _nProperties; i++)
    {
        if (_diProperty[i].bstrValue)
        {
            SysFreeString(_diProperty[i].bstrValue);
        }
        if (_diProperty[i].bstrDisplayName)
        {
            SysFreeString(_diProperty[i].bstrDisplayName);
        }
    }
}

// ***** CDetailsSectionInfoTask *******

CDetailsSectionInfoTask::CDetailsSectionInfoTask(HRESULT *phr,
                                                 IShellFolder *psfContaining,
                                                 LPCITEMIDLIST pidlAbsolute,
                                                 HWND hwndMsg,
                                                 UINT uMsg,
                                                 DWORD dwDetailsInfoID)
                                                 : CRunnableTask(RTF_DEFAULT),
                                                   _hwndMsg(hwndMsg),
                                                   _uMsg(uMsg),
                                                   _dwDetailsInfoID(dwDetailsInfoID)
{
    ASSERT(psfContaining && pidlAbsolute && hwndMsg);

    _psfContaining = psfContaining;
    _psfContaining->AddRef();

    *phr = SHILClone(pidlAbsolute, &_pidlAbsolute);
}

CDetailsSectionInfoTask::~CDetailsSectionInfoTask()
{
    _psfContaining->Release();

    ILFree(_pidlAbsolute);
}

HRESULT CDetailsSectionInfoTask_CreateInstance(IShellFolder *psfContaining,
                                               LPCITEMIDLIST pidlAbsolute,
                                               HWND hwndMsg,
                                               UINT uMsg,
                                               DWORD dwDetailsInfoID,
                                               CDetailsSectionInfoTask **ppTask)
{
    *ppTask = NULL;

    HRESULT hr;
    CDetailsSectionInfoTask* pNewTask = new CDetailsSectionInfoTask(
        &hr,
        psfContaining,
        pidlAbsolute,
        hwndMsg,
        uMsg,
        dwDetailsInfoID);
    if (pNewTask)
    {
        if (SUCCEEDED(hr))
            *ppTask = pNewTask;
        else
            pNewTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CDetailsSectionInfoTask::RunInitRT()
{
    ASSERT(_pidlAbsolute);
    
    BOOL bMsgPosted = FALSE;

    HRESULT hr = E_FAIL;
    CDetailsInfoList* pCDetailsInfoList = new CDetailsInfoList;
    if (!pCDetailsInfoList)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        CComPtr<IShellFolder2>  psf2;
        LPCITEMIDLIST           pidlLast;
        hr = SHBindToIDListParent(_pidlAbsolute, IID_PPV_ARG(IShellFolder2, &psf2), &pidlLast);
        if (SUCCEEDED(hr))
        {
            _SetParentAndItem(psf2, pidlLast);

            WCHAR wszProperties[MAX_PATH];
            hr = _GetDisplayedDetailsProperties(psf2, pidlLast, wszProperties, ARRAYSIZE(wszProperties));
            if (SUCCEEDED(hr))
            {
                // pwszProperties is usually of the form "prop:Name;Type;Author"
                CComPtr<IPropertyUI> spPropertyUI;
                hr = _GetPropertyUI(&spPropertyUI);
                if (SUCCEEDED(hr))
                {
                    SHCOLUMNID scid;
                    WCHAR wszInfoString[INTERNET_MAX_URL_LENGTH];
                    
                    ULONG chEaten = 0;  // loop var, incremented by ParsePropertyName
                    for (pCDetailsInfoList->_nProperties = 0;
                            pCDetailsInfoList->_nProperties < ARRAYSIZE(pCDetailsInfoList->_diProperty)
                                && SUCCEEDED(spPropertyUI->ParsePropertyName(wszProperties, &scid.fmtid, &scid.pid, &chEaten));
                            pCDetailsInfoList->_nProperties++)
                    {
                        pCDetailsInfoList->_diProperty[pCDetailsInfoList->_nProperties].scid = scid;
                        
                        PROPERTYUI_FORMAT_FLAGS flagsFormat = IsEqualSCID(scid, SCID_WRITETIME) ? PUIFFDF_FRIENDLYDATE : PUIFFDF_DEFAULT;
                        // Get the display value
                        hr = GetPropertyDisplayValue(scid, wszInfoString, ARRAYSIZE(wszInfoString), flagsFormat);
                        if (SUCCEEDED(hr) && wszInfoString[0])
                        {
                            pCDetailsInfoList->_diProperty[pCDetailsInfoList->_nProperties].bstrValue = SysAllocString(wszInfoString);
                        }

                        // Get the display name
                        hr = GetPropertyDisplayName(scid, wszInfoString, ARRAYSIZE(wszInfoString));
                        if (SUCCEEDED(hr) && wszInfoString[0])
                        {
                            pCDetailsInfoList->_diProperty[pCDetailsInfoList->_nProperties].bstrDisplayName = SysAllocString(wszInfoString);
                        }
                    }

                    //The extraction is done. Now post a message.
                    if (PostMessage(_hwndMsg, WM_DETAILS_INFO,
                            (WPARAM)_dwDetailsInfoID, (LPARAM)pCDetailsInfoList))
                    {
                        bMsgPosted = TRUE;
                    }
                }
            }

        }
    }

    if (!bMsgPosted && pCDetailsInfoList)
    {
        delete pCDetailsInfoList;
    }
    return S_OK;
}


HRESULT CDetailsSectionInfoTask::_GetDisplayedDetailsProperties(IShellFolder2* psf,
                                                                LPCITEMIDLIST pidl,
                                                                WCHAR* pwszProperties,
                                                                int cchProperties)
{
    HRESULT hr = GetStringProperty(psf, pidl, &SCID_DetailsProperties, pwszProperties, cchProperties);
    if (FAILED(hr)) // Default properties
    {
        if (SHGetAttributes(psf, pidl, SFGAO_ISSLOW))
        {
            // SCID_NAME;SCID_TYPE
            StringCchCopyW(pwszProperties, cchProperties, L"prop:Name;Type");
        }
        else
        {
            // SCID_NAME;SCID_TYPE;SCID_ATTRIBUTES_DESCRIPTION;SCID_Comment;SCID_WRITETIME;SCID_SIZE;SCID_Author;SCID_CSC_STATUS
            StringCchCopyW(pwszProperties, cchProperties, L"prop:Name;Type;AttributesDescription;DocComments;Write;Size;DocAuthor;CSCStatus");
        }
    }

    // Augment properties to include "Location" if in CLSID_DocFindFolder.
    IPersist *pPersist;
    ASSERT(_psfContaining);
    if (SUCCEEDED(_psfContaining->QueryInterface(IID_IPersist, (void**)&pPersist)))
    {
        CLSID clsid;
        if (SUCCEEDED(pPersist->GetClassID(&clsid)) && IsEqualCLSID(clsid, CLSID_DocFindFolder))
            _AugmentDisplayedDetailsProperties(pwszProperties, cchProperties);
        pPersist->Release();
    }

    return S_OK;
}

void CDetailsSectionInfoTask::_AugmentDisplayedDetailsProperties(LPWSTR pszDetailsProperties, size_t cchDetailsProperties)
{
    static WCHAR  szDeclarator[]    = L"prop:";
    static size_t lenDeclarator     = lstrlen(szDeclarator);
    static WCHAR  szName[64]        = { 0 };
    static size_t lenName           = 0;
    static WCHAR  szType[64]        = { 0 };
    static size_t lenType           = 0;
    static WCHAR  szDirectory[64]   = { 0 };
    static size_t lenDirectory      = 0;

    // Initialize statics once 'n only once.
    if (!szName[0] || !szType[0] || !szDirectory[0])
    {
        HRESULT hr;

        hr = SCIDCannonicalName((SHCOLUMNID *)&SCID_NAME, szName, ARRAYSIZE(szName));
        ASSERT(SUCCEEDED(hr));
        lenName = lstrlen(szName);

        hr = SCIDCannonicalName((SHCOLUMNID *)&SCID_TYPE, szType, ARRAYSIZE(szType));
        ASSERT(SUCCEEDED(hr));
        lenType = lstrlen(szType);

        hr = SCIDCannonicalName((SHCOLUMNID *)&SCID_DIRECTORY, szDirectory, ARRAYSIZE(szDirectory));
        ASSERT(SUCCEEDED(hr));
        lenDirectory = lstrlen(szDirectory);
    }

    // Attempt to merge the "Directory" property, in the following ways:
    //  "prop:Name;Type;Directory;..."
    //  "prop:Name;Directory;..."
    //  "prop:Directory;..."
    //
    size_t lenDetailsProperties = lstrlen(pszDetailsProperties);
    size_t lenMerged = lenDetailsProperties + 1 + lenDirectory;
    if (lenMerged < cchDetailsProperties && 0 == StrCmpNI(pszDetailsProperties, szDeclarator, lenDeclarator))
    {
        // Search for "Directory" property (in case it is already specified).
        if (!_SearchDisplayedDetailsProperties(pszDetailsProperties, lenDetailsProperties, szDirectory, lenDirectory))
        {
            // Allocate a temporary buffer to merge into.
            size_t cchMerged = cchDetailsProperties;
            LPWSTR pszMerged = new WCHAR[cchMerged];
            if (pszMerged)
            {
                // Determine offset in pszDetailsProperties to merge at.
                size_t offsetInsert;
                if (lenDeclarator < lenDetailsProperties)
                {
                    // Search for "Name" property.
                    LPWSTR pszName = _SearchDisplayedDetailsProperties(
                        &pszDetailsProperties[lenDeclarator],
                        lenDetailsProperties - lenDeclarator,
                        szName,
                        lenName);
                    if (pszName)
                    {
                        // Search for "Type" property (immediately following "Name").
                        size_t offsetName = (pszName - pszDetailsProperties);
                        size_t offsetType = offsetName + lenName + 1;
                        size_t offsetRemainder = offsetType + lenType;
                        if ((offsetRemainder == lenDetailsProperties || (offsetRemainder < lenDetailsProperties && pszDetailsProperties[offsetRemainder] == ';')) &&
                            !StrCmpNI(&pszDetailsProperties[offsetType], szType, lenType))
                        {
                            offsetInsert = offsetRemainder;
                        }
                        else
                            offsetInsert = offsetName + lenName;
                    }
                    else
                        offsetInsert = lenDeclarator;
                }
                else
                    offsetInsert = lenDeclarator;

                // Merge the "Directory" property.
                StringCchCopy(pszMerged, offsetInsert + 1, pszDetailsProperties); // + 1 to account for null terminator.
                if (offsetInsert > lenDeclarator)                           
                    StringCchCat(pszMerged, cchMerged, L";");                     // ';' prepend if necessary
                StringCchCat(pszMerged, cchMerged, szDirectory);                  // "Directory"
                if (offsetInsert < lenDetailsProperties)
                {
                    if (pszDetailsProperties[offsetInsert] != ';')
                        StringCchCat(pszMerged, cchMerged, L";");                 // ';' append if necessary
                    StringCchCat(pszMerged, cchMerged, &pszDetailsProperties[offsetInsert]);
                }

                // Update in/out pszDetailsProperties.
                StringCchCopy(pszDetailsProperties, cchDetailsProperties, pszMerged);
                ASSERT(lenMerged == lstrlen(pszMerged));
                ASSERT(lenMerged < cchDetailsProperties);
                delete[] pszMerged;
            }
        }
    }
    else
    {
        // Invalid format.
        ASSERT(FALSE);
    }
}

LPWSTR CDetailsSectionInfoTask::_SearchDisplayedDetailsProperties(LPWSTR pszDetailsProperties, size_t lenDetailsProperties, LPWSTR pszProperty, size_t lenProperty)
{
    LPWSTR psz = StrStrI(pszDetailsProperties, pszProperty);
    while (psz)
    {
        // Check start...
        if (psz == pszDetailsProperties || psz[-1] == ';')
        {
            // ... and end.
            size_t lenToEndOfProperty = (psz - pszDetailsProperties) + lenProperty;
            if (lenToEndOfProperty == lenDetailsProperties || pszDetailsProperties[lenToEndOfProperty] == ';')
                break;
        }

        psz = StrStrI(psz + lenProperty, pszProperty);
    }

    return psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duiinfo.h ===
#ifndef _DUIINFO_
#define _DUIINFO_

#include "defviewp.h"
#include "duiview.h"
#include "prop.h"

class CNameSpaceItemUIProperty
{
public:
    virtual ~CNameSpaceItemUIProperty();
    
    STDMETHODIMP GetPropertyDisplayName(SHCOLUMNID scid, WCHAR* pwszPropDisplayName, int cchPropDisplayName);
    STDMETHODIMP GetPropertyDisplayValue(SHCOLUMNID scid, WCHAR* pwszPropDisplayValue, int cchPropDisplayValue, PROPERTYUI_FORMAT_FLAGS flagsFormat);

protected:
    HRESULT _GetPropertyUI(IPropertyUI** ppPropertyUI);
    void _SetParentAndItem(IShellFolder2 *psf, LPCITEMIDLIST pidl);

private:
    
    CComPtr<IPropertyUI>    m_spPropertyUI;
    IShellFolder2           *m_psf;             // alias to current psf
    LPCITEMIDLIST           m_pidl;             // alias to current relative pidl
};


class CNameSpaceItemInfoList : public Element, public CNameSpaceItemUIProperty
{
public:
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    static STDMETHODIMP Create(Element** ppElement) { return Create(NULL, NULL, NULL, ppElement); }
    static STDMETHODIMP Create(CDUIView* pDUIView, Value* pvDetailsSheet,IShellItemArray *psiItemArray,
            Element** ppElement);

    STDMETHODIMP Initialize(CDUIView* pDUIView, Value* pvDetailsSheet,IShellItemArray *psiItemArray);

    // Window procedure for catching the "info-extraction-done" message
    // from CDetailsSectionInfoTask::RunInitRT
    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam,
            LPARAM lParam);

private:
    HRESULT _AddMiniPreviewerToList(IShellFolder2 *psf, LPCITEMIDLIST pidl);
    HRESULT _OnMultiSelect(IShellFolder2 *psfRoot, LPIDA pida);

    CDUIView*               m_pDUIView;
};


class CNameSpaceItemInfo : public Element
{
public:
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    static STDMETHODIMP Create(Element** ppElement) { return Create(L"", ppElement); }
    static STDMETHODIMP Create(WCHAR* pwszInfoString, Element** ppElement);

    STDMETHODIMP Initialize(WCHAR* pwszInfoString);
};

class CMiniPreviewer : public Element
{
public:
    ~CMiniPreviewer();
    
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    static STDMETHODIMP Create(Element** ppElement) { return Create(NULL, NULL, NULL, ppElement); }
    static STDMETHODIMP Create(CDUIView* pDUIView, IShellFolder2 *psf, LPCITEMIDLIST pidl, Element** ppElement);

    STDMETHODIMP Initialize(CDUIView* pDUIView, IShellFolder2 *psf, LPCITEMIDLIST pidl);

    // Window procedure for catching the "image-extraction-done" message
    // from m_pDUIView->m_spThumbnailExtractor2
    static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    CDUIView*               m_pDUIView;
};

class CBitmapElement : public Element
{
public:
    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    static STDMETHODIMP Create(Element** ppElement) { return Create(NULL, ppElement); }
    static STDMETHODIMP Create(HBITMAP hBitmap, Element** ppElement);

    STDMETHODIMP Initialize(HBITMAP hBitmap);
};




typedef struct
{
    SHCOLUMNID  scid;
    BSTR        bstrValue;
    BSTR        bstrDisplayName;
} DetailsInfo;

// A wrapper class around a DetailsInfo array. See CDetailsSectionInfoTask for its use.
class CDetailsInfoList
{
public:
    CDetailsInfoList();
    ~CDetailsInfoList();

    DetailsInfo     _diProperty[20];    // A max of 20 properties allowed
    int             _nProperties;       // The count of properties
};


// Task used to extract the Details Section info in the background:
// Given a pidl, this task extracts the display names and display values
// of properties mentioned by SCID_WebViewDisplayProperties.
// Once the extraction is done, it posts uMsg to hwndMsg
// with lParam == pointer to an object of CDetailsInfoList
// wParam == the ID of the info extraction, the results of which are in lParam
class CDetailsSectionInfoTask : public CRunnableTask, public CNameSpaceItemUIProperty
{
public:
    CDetailsSectionInfoTask(HRESULT *phr, IShellFolder *psfContaining, LPCITEMIDLIST pidlAbsolute, HWND hwndMsg, UINT uMsg, DWORD dwDetailsInfoID);
    STDMETHODIMP RunInitRT();

protected:
    ~CDetailsSectionInfoTask();

    // Helper functions
    HRESULT _GetDisplayedDetailsProperties(IShellFolder2 *psf, LPCITEMIDLIST pidl, WCHAR* pwszProperties, int cch);
    void    _AugmentDisplayedDetailsProperties(LPWSTR pszDetailsProperties, size_t lenDetailsProperties);
    LPWSTR  _SearchDisplayedDetailsProperties(LPWSTR pszDetailsProperties, size_t lenDetailsProperties, LPWSTR pszProperty, size_t lenProperty);

    IShellFolder *  _psfContaining;     // AddRef()'d
    LPITEMIDLIST    _pidlAbsolute;      // SHILClone()'d
    HWND            _hwndMsg;           // the window to post _uMsg to
    UINT            _uMsg;
    DWORD           _dwDetailsInfoID;   // an ID to the current info extraction
};

#endif _DUIINFO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duisec.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "duiview.h"
#include "duisec.h"
#include "duitask.h"


////////////////////////////////////////////////////////
// Expando class
////////////////////////////////////////////////////////

// Cached IDs
ATOM Expando::idTitle = NULL;
ATOM Expando::idIcon = NULL;
ATOM Expando::idTaskList = NULL;
ATOM Expando::idWatermark = NULL;


HRESULT Expando::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Expando* pex = HNewAndZero<Expando>();
    if (!pex)
        return E_OUTOFMEMORY;

    HRESULT hr = pex->Initialize();
    if (FAILED(hr))
    {
        pex->Destroy();
        return hr;
    }

    *ppElement = pex;

    return S_OK;
}

Expando::Expando()
{
    // Catch unexpected STACK allocations which would break us.
    ASSERT(_puiHeader   == NULL);
    ASSERT(_pDUIView    == NULL);
    ASSERT(_pDefView    == NULL);

    // Initialize member variables.
    _eDUISecID = DUISEC_UNKNOWN;
    _bInfotip = FALSE;
}
Expando::~Expando()
{
    DeleteAtom(idTitle);
    DeleteAtom(idIcon);
    DeleteAtom(idTaskList);
    DeleteAtom(idWatermark);

    if (_bInfotip)
        _pDefView->DestroyInfotip(_hwndRoot, (UINT_PTR)this);

    if (_puiHeader)
        _puiHeader->Release();

    if (_pDUIView)
        _pDUIView->Release();

    if (_pDefView)
        _pDefView->Release();
}

HRESULT Expando::Initialize()
{
    HRESULT hr;

    // Initialize base
    hr = Element::Initialize(0); // Normal display node creation
    if (FAILED(hr))
        return hr;

    // Initialize
    _fExpanding = false;
    SetSelected(true);

    // Cache atoms used for loading from resources
    idTitle = AddAtomW(L"title");
    idIcon = AddAtomW(L"icon");
    idTaskList = AddAtomW(L"tasklist");
    idWatermark = AddAtomW(L"watermark");

    return S_OK;
}

void Expando::Initialize(DUISEC eDUISecID, IUIElement *puiHeader, CDUIView *pDUIView, CDefView *pDefView)
{
    ASSERT(eDUISecID != DUISEC_UNKNOWN);
    ASSERT(pDUIView);
    ASSERT(pDefView);

    _eDUISecID = eDUISecID;

    _puiHeader = puiHeader;
    if (_puiHeader)
        _puiHeader->AddRef();

    pDUIView->AddRef();
    _pDUIView = pDUIView;

    pDefView->AddRef();
    _pDefView = pDefView;

    _SetAccStateInfo(TRUE);
}

HRESULT Expando::ShowInfotipWindow(Element *peHeader, BOOL bShow)
{
    HRESULT hr;

    if (_puiHeader)
    {
        RECT rect = { 0 };

        if (bShow)
        {
            _pDUIView->CalculateInfotipRect(peHeader, &rect);
            if (_bInfotip)
            {
                // Reposition infotip at position.
                hr = _pDefView->RepositionInfotip(_hwndRoot, (UINT_PTR)this, &rect);
            }
            else
            {
                // Create infotip at position (on the ui thread).
                LPWSTR pwszInfotip;
                hr = _puiHeader->get_Tooltip(NULL, &pwszInfotip);
                if (SUCCEEDED(hr))
                {
                    hr = GetElementRootHWND(this, &_hwndRoot);
                    if (SUCCEEDED(hr))
                    {
                        hr = _pDefView->CreateInfotip(_hwndRoot, (UINT_PTR)this, &rect, pwszInfotip, 0);
                        if (SUCCEEDED(hr))
                        {
                            _bInfotip = TRUE;
                        }
                    }
                    CoTaskMemFree(pwszInfotip);
                }
            }
        }
        else
        {
            if (_bInfotip)
            {
                // Reposition infotip at nowhere.
                hr = _pDefView->RepositionInfotip(_hwndRoot, (UINT_PTR)this, &rect);
            }
            else
            {
                // No infotip == no show!
                hr = S_OK;
            }
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

void Expando::OnEvent(Event* pev)
{
    if (pev->uidType == Button::Click)
    {
        // Update exanded property based on clicks that originate
        // only from the first child's subtree
        Value* pv;
        ElementList* peList = GetChildren(&pv);

        if (peList && peList->GetSize() > 0)
        {
            if (peList->GetItem(0) == GetImmediateChild(pev->peTarget))
            {
                SetSelected(!GetSelected());
                pev->fHandled = true;
            }
        }

        pv->Release();
    }

    Element::OnEvent(pev);
}

////////////////////////////////////////////////////////
// System events

void Expando::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Do default processing
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    if (IsProp(Selected))
    {
        // Update height of second child based on expanded state
        Value* pvChildren;
        ElementList* peList = GetChildren(&pvChildren);
        if (peList && peList->GetSize() > 1)
        {
            // The following will cause a relayout, mark object so that
            // when the expando's Extent changes, it'll go through
            // with the EnsureVisible. Otherwise, it's being resized
            // as a result of something else. In which case, do nothing.
            _fExpanding = true;

            Element* pe = peList->GetItem(1);

            // To achieve "pulldown" animation, we use a clipper control that will
            // size it's child based on it's unconstrained desired size in its Y direction.
            //
            if (pvNew->GetBool())
            {
                pe->RemoveLocalValue(HeightProp);
                _pDUIView->OnExpandSection(_eDUISecID, TRUE);
            }
            else
            {
                pe->SetHeight(0);
                _pDUIView->OnExpandSection(_eDUISecID, FALSE);
            }

        }
        pvChildren->Release();

        _SetAccStateInfo(pvNew->GetBool());
    }
    else if (IsProp(Extent))
    {
        if (_fExpanding && GetSelected())
        {
            _fExpanding = false;

            // On extent, we want to ensure that not just the client area but
            // also the bottom margin of the expando is visible.  Why?  Simply
            // because it looks better to scroll the expando plus its margin
            // into view versus just the expando.
            //
            Value* pvSize;
            Value* pvMargin;
            const SIZE* psize = GetExtent(&pvSize);
            const RECT* prect = GetMargin(&pvMargin);
            EnsureVisible(0, 0, psize->cx, psize->cy + prect->bottom);
            pvSize->Release();
            pvMargin->Release();
        }
    }
    else if (IsProp(MouseWithin))
    {
        // Extended processing for infotip...
        Value* pvChildren;
        ElementList* peList = GetChildren(&pvChildren);
        if (peList && peList->GetSize() > 0 && pvNew->GetBool() && SHShowInfotips())
        {
            // ... only displays tip if mouse is within title of Expando.
            Element *peHeader = peList->GetItem(0);
            ShowInfotipWindow(peHeader, peHeader->GetMouseWithin());
        }
        else
        {
            ShowInfotipWindow(NULL, FALSE);
        }
        pvChildren->Release();

    }
}

////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* Expando::Class = NULL;
HRESULT Expando::Register()
{
    return ClassInfo<Expando,Element>::Register(L"Expando", NULL, 0);
}

void Expando::UpdateTitleUI(IShellItemArray *psiItemArray)
{
    if (_puiHeader)
    {
        LPWSTR pszTitle;
        if (SUCCEEDED(_puiHeader->get_Name(psiItemArray, &pszTitle)))
        {
            Value* pv = Value::CreateString(pszTitle);
            if (pv)
            {
                Element* pe = FindDescendent(StrToID(L"header"));

                if (pe)
                {
                    pe->SetAccessible(true);
                    pe->SetAccRole(ROLE_SYSTEM_OUTLINEBUTTON);
                    pe->SetValue (Element::AccNameProp, PI_Local, pv);
                }
                else
                {
                    TraceMsg (TF_ERROR, "Expando::UpdateTitleUI: Button child for Expando not found.");
                }

                pe = FindDescendent (Expando::idTitle);
                if (pe)
                {
                    pe->SetValue (Element::ContentProp, PI_Local, pv);
                }
                else
                {
                    TraceMsg (TF_ERROR, "Expando::UpdateTitleUI: FindDescendent for the title failed.");
                }
                pv->Release ();
            }
            else
            {
                TraceMsg (TF_ERROR, "Expando::UpdateTitleUI: CreateString for the title failed.");
            }

            CoTaskMemFree(pszTitle);
        }
        else
        {
            TraceMsg (TF_ERROR, "Expando::UpdateTitleUI: get_Name failed.");
        }
    }
}

void Expando::ShowExpando(BOOL fShow)
{
    if (fShow && (_fShow != TRIBIT_TRUE))
    {
        SetHeight(-1);
        RemoveLocalValue(MarginProp);

        _fShow = TRIBIT_TRUE;
    }

    if (!fShow && (_fShow != TRIBIT_FALSE))
    {
        SetHeight(0);
        SetMargin(0,0,0,0);
        
        _fShow = TRIBIT_FALSE;
    }
}

void Expando::_SetAccStateInfo (BOOL bExpanded)
{
    // Update the accessibility state information
    //
    // Note:  In the Expando::Initialize() method, we explicitly set the
    // Selected state to true.  This causes OnPropertyChanged to be called
    // for the Selected property, which will call this method.  However,
    // the child elements will not exist yet (since we are in the creation process).
    // Hence, the call to FindDescendent will return NULL and this method will exit.
    // This method is explicitly called in the second version of Initialze to
    // set the correct accessibility information.

    Element * pe = FindDescendent(StrToID(L"header"));

    if (pe)
    {
        TCHAR szDefaultAction[50] = {0};

        if (bExpanded)
        {
            pe->SetAccState(STATE_SYSTEM_EXPANDED);
            LoadString(HINST_THISDLL, IDS_EXPANDO_DEFAULT_ACTION_COLLAPSE, szDefaultAction, ARRAYSIZE(szDefaultAction));
        }
        else
        {
            pe->SetAccState(STATE_SYSTEM_COLLAPSED);
            LoadString(HINST_THISDLL, IDS_EXPANDO_DEFAULT_ACTION_EXPAND, szDefaultAction, ARRAYSIZE(szDefaultAction));
        }

        pe->SetAccDefAction(szDefaultAction);
    }
}

////////////////////////////////////////////////////////
// Clipper class
////////////////////////////////////////////////////////

HRESULT Clipper::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    Clipper* pc = HNewAndZero<Clipper>();
    if (!pc)
        return E_OUTOFMEMORY;

    HRESULT hr = pc->Initialize();
    if (FAILED(hr))
    {
        pc->Destroy();
        return hr;
    }

    *ppElement = pc;

    return S_OK;
}

HRESULT Clipper::Initialize()
{
    // Initialize base
    HRESULT hr = Element::Initialize(EC_SelfLayout); // Normal display node creation, self layout
    if (FAILED(hr))
        return hr;

    // Children can exist outside of Element bounds
    SetGadgetStyle(GetDisplayNode(), GS_CLIPINSIDE, GS_CLIPINSIDE);

    return S_OK;
}

////////////////////////////////////////////////////////
// Self-layout methods

SIZE Clipper::_SelfLayoutUpdateDesiredSize(int cxConstraint, int cyConstraint, Surface* psrf)
{
    UNREFERENCED_PARAMETER(cyConstraint);

    Value* pvChildren;
    SIZE size = { 0, 0 };
    ElementList* peList = GetChildren(&pvChildren);

    // Desired size of this is based solely on it's first child.
    // Width is child's width, height is unconstrained height of child.
    if (peList && peList->GetSize() > 0)
    {
        Element* pec = peList->GetItem(0);
        size = pec->_UpdateDesiredSize(cxConstraint, INT_MAX, psrf);

        if (size.cx > cxConstraint)
            size.cx = cxConstraint;
        if (size.cy > cyConstraint)
            size.cy = cyConstraint;
    }

    pvChildren->Release();

    return size;
}

void Clipper::_SelfLayoutDoLayout(int cx, int cy)
{
    Value* pvChildren;
    ElementList* peList = GetChildren(&pvChildren);

    // Layout first child giving it's desired height and aligning
    // it with the clipper's bottom edge
    if (peList && peList->GetSize() > 0)
    {
        Element* pec = peList->GetItem(0);
        const SIZE* pds = pec->GetDesiredSize();

        pec->_UpdateLayoutPosition(0, cy - pds->cy);
        pec->_UpdateLayoutSize(cx, pds->cy);
    }

    pvChildren->Release();
}

////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* Clipper::Class = NULL;
HRESULT Clipper::Register()
{
    return ClassInfo<Clipper,Element>::Register(L"Clipper", NULL, 0);
}


////////////////////////////////////////////////////////
// TaskList class
////////////////////////////////////////////////////////

HRESULT TaskList::Create(OUT Element** ppElement)
{
    *ppElement = NULL;

    TaskList* pc = HNewAndZero<TaskList>();
    if (!pc)
        return E_OUTOFMEMORY;

    HRESULT hr = pc->Initialize();
    if (FAILED(hr))
    {
        pc->Destroy();
        return hr;
    }

    *ppElement = pc;

    return S_OK;
}

HRESULT TaskList::Initialize()
{
    // Initialize base
    HRESULT hr = Element::Initialize(0); // Normal display node creation, self layout
    if (FAILED(hr))
        return hr;

    return S_OK;
}

////////////////////////////////////////////////////////
// Hierarchy

Element* TaskList::GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable)
{
    if ((iNavDir & NAV_LOGICAL) && peFrom)
        return NULL;

    return Element::GetAdjacent(peFrom, iNavDir, pnr, bKeyable);
}


////////////////////////////////////////////////////////
// Property definitions

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* TaskList::Class = NULL;
HRESULT TaskList::Register()
{
    return ClassInfo<TaskList,Element>::Register(L"TaskList", NULL, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duilist.cpp ===
#include "shellprv.h"
#include "duiview.h"
#include "duilist.h"


// DUIListView

DUIListView::~DUIListView()
{
    DetachListview();
}

void DUIListView::DetachListview()
{
    if (m_hwndListview)
    {
        // Unhook DUI from the HWND before doing this
        HWNDHost::Detach();

        if (m_bClientEdge)
            SetWindowBits(m_hwndListview, GWL_EXSTYLE, WS_EX_CLIENTEDGE, WS_EX_CLIENTEDGE);

        ShowWindow(m_hwndListview, SW_HIDE);       // HIDE IT SO IT doesn't flash before switching.
        SHSetParentHwnd(m_hwndListview, m_hwndLVOrgParent);
    }
}

HRESULT DUIListView::Create(UINT nActive, HWND hwndListView, OUT Element** ppElement)
{
    *ppElement = NULL;

    DUIListView* pDUIListView = HNewAndZero<DUIListView>();
    if (!pDUIListView)
        return E_OUTOFMEMORY;

    HRESULT hr = pDUIListView->Initialize(nActive, hwndListView);
    if (FAILED(hr))
    {
        pDUIListView->Destroy();
        return E_OUTOFMEMORY;
    }

    pDUIListView->SetAccessible(true);
    *ppElement = pDUIListView;

    return S_OK;
}

HWND DUIListView::CreateHWND(HWND hwndParent)
{
    m_hwndParent = hwndParent;

    // Save the original parent window handle

    m_hwndLVOrgParent = ::GetParent(m_hwndListview);

    SHSetParentHwnd(m_hwndListview, hwndParent);

    LONG lExStyle = GetWindowLong(m_hwndListview, GWL_EXSTYLE);

    m_bClientEdge = lExStyle & WS_EX_CLIENTEDGE ? TRUE : FALSE;

    if (m_bClientEdge)
    {
        lExStyle &= ~WS_EX_CLIENTEDGE;
        SetWindowLong(m_hwndListview, GWL_EXSTYLE, lExStyle);
    }

    return m_hwndListview;
}

// Global action callback

UINT DUIListView::MessageCallback(GMSG* pGMsg)
{
    return HWNDHost::MessageCallback(pGMsg);
}

// Pointer is only guaranteed good for the lifetime of the call
void DUIListView::OnInput(InputEvent* pie)
{

    // Bypass HWNDHost::OnInput for tab input events so they aren't forwarded
    // to the HWND control. Element::OnInput will handle the events (keyboard nav)

    if (pie->nStage == GMF_DIRECT)
    {
        if (pie->nDevice == GINPUT_KEYBOARD)
        {
            KeyboardEvent* pke = (KeyboardEvent*)pie;

            if (pke->nCode == GKEY_DOWN || pke->nCode == GKEY_UP)  // Virtual keys
            {
                if (pke->ch == VK_TAB)
                {
                    Element::OnInput(pie);
                    return;
                }
            }
            else if (pke->nCode == GKEY_CHAR) // Characters
            {
                if (pke->ch == 9)
                {
                    Element::OnInput(pie);
                    return;
                }
            }
        }
    }

    HWNDHost::OnInput(pie);
}

////////////////////////////////////////////////////////
// Property definitions

/** Property template (replace !!!), also update private PropertyInfo* parray and class header (element.h)
// !!! property
static int vv!!![] = { V_INT, -1 }; StaticValue(svDefault!!!, V_INT, 0);
static PropertyInfo imp!!!Prop = { L"!!!", PF_Normal, 0, vv!!!, (Value*)&svDefault!!! };
PropertyInfo* Element::!!!Prop = &imp!!!Prop;
**/

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Class properties

// Define class info with type and base type, set static class pointer

IClassInfo* DUIListView::Class = NULL;
HRESULT DUIListView::Register()
{
    return ClassInfo<DUIListView,HWNDHost>::Register(L"DUIListView", NULL, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duitask.cpp ===
#include "shellprv.h"
#include "defviewp.h"
#include "duiview.h"
#include "duitask.h"
#include "dvtasks.h"
#include "contextmenu.h"
#include "ids.h"





//  Returns a given task element's root HWND element.
//
//

HRESULT GetElementRootHWNDElement(Element *pe, HWNDElement **pphwndeRoot)
{
    HRESULT hr;
    if (pe)
    {
        Element *peRoot = pe->GetRoot();
        if (peRoot && peRoot->GetClassInfo()->IsSubclassOf(HWNDElement::Class))
        {
            *pphwndeRoot = reinterpret_cast<HWNDElement *>(peRoot);
            hr = S_OK;
        }
        else
        {
            *pphwndeRoot = NULL;
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
        ASSERT(FALSE);
    }
    return hr;
}

//  Returns a given task element's root HWND element's HWND.
//
//

HRESULT GetElementRootHWND(Element *pe, HWND *phwnd)
{
    HWNDElement *phwndeRoot;
    HRESULT hr = GetElementRootHWNDElement(pe, &phwndeRoot);
    if (SUCCEEDED(hr))
    {
        *phwnd = phwndeRoot->GetHWND();
        hr = *phwnd ? S_OK : S_FALSE;
    }
    return hr;
}

//  Creates an instance of the ActionTask and
//  initializes it
//
//  nActive    - Activation type
//  puiCommand - the Task itself
//  ppElement  - Receives element pointer

HRESULT ActionTask::Create(UINT nActive, IUICommand* puiCommand, IShellItemArray* psiItemArray, CDUIView* pDUIView, CDefView* pDefView, OUT Element** ppElement)
{
    *ppElement = NULL;

    if (!puiCommand || !pDUIView || !pDefView)
    {
        return E_INVALIDARG;
    }

    ActionTask* pAT = HNewAndZero<ActionTask>();
    if (!pAT)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pAT->Initialize(puiCommand, psiItemArray, pDUIView, pDefView);
    if (FAILED(hr))
    {
        pAT->Destroy();
        return hr;
    }

    *ppElement = pAT;

    return S_OK;
}

//  Initializes this task
//
//  puiCommand - the Task itself

HRESULT ActionTask::Initialize(IUICommand *puiCommand, IShellItemArray *psiItemArray, CDUIView *pDUIView, CDefView *pDefView)
{
    HRESULT hr;

    // Initialize this DUI Element.
    hr = InitializeElement();
    if (SUCCEEDED(hr))
    {
        // Initialize the contained DUI Button.
        hr = InitializeButton();
        if (SUCCEEDED(hr))
        {
            // Save the pointer to the IUICommand class
            puiCommand->AddRef();
            _puiCommand = puiCommand;

            // Save the pointer to the CDUIView class
            pDUIView->AddRef();
            _pDUIView = pDUIView;

            // Save the pointer to the CDefView class
            pDefView->AddRef();
            _pDefView = pDefView;

            // Save the pointer to the IShellItemArray class (if available)
            if (psiItemArray)
            {
                psiItemArray->AddRef();
                _psiItemArray = psiItemArray;
            }

            UpdateTaskUI();
        }
    }

    return hr;
}

HRESULT ActionTask::InitializeElement()
{
    HRESULT hr;

    // Initialize base class (normal display node creation).
    hr = Element::Initialize(0);
    if (SUCCEEDED(hr))
    {
        // Create a layout for this element.
        Value *pv;
        hr = BorderLayout::Create(0, NULL, &pv);
        if (SUCCEEDED(hr))
        {
            // Set the layout for this element.
            hr = SetValue(LayoutProp, PI_Local, pv);
            pv->Release();
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "ActionTask::Initialize: base class failed to initialize with 0x%x", hr);
    }

    return hr;
}

HRESULT ActionTask::InitializeButton()
{
    HRESULT hr;

    // Create the button.
    hr = Button::Create((Element**)&_peButton);
    if (SUCCEEDED(hr))
    {
        // Set some button attributes.
        _peButton->SetLayoutPos(BLP_Left);
        _peButton->SetAccessible(true);
        _peButton->SetAccRole(ROLE_SYSTEM_PUSHBUTTON);
        TCHAR szDefaultAction[50] = {0};
        LoadString(HINST_THISDLL, IDS_LINKWINDOW_DEFAULTACTION, szDefaultAction, ARRAYSIZE(szDefaultAction));
        _peButton->SetAccDefAction(szDefaultAction);

        // Create a border layout for the icon and title in the button.
        Value *pv;
        hr = BorderLayout::Create(0, NULL, &pv);
        if (SUCCEEDED(hr))
        {
            // Set the button layout.
            hr = _peButton->SetValue(LayoutProp, PI_Local, pv);
            if (SUCCEEDED(hr))
            {
                // Add the button to this element.
                hr = Add(_peButton);
            }
            pv->Release();
        }

        // Cleanup (if necessary).
        if (FAILED(hr))
        {
            _peButton->Destroy();
            _peButton = NULL;
        }
    }

    return hr;
}

ActionTask::ActionTask()
{
    // Catch unexpected STACK allocations which would break us.
    ASSERT(_peButton     == NULL);
    ASSERT(_puiCommand   == NULL);
    ASSERT(_psiItemArray == NULL);
    ASSERT(_pDefView     == NULL);
    ASSERT(_pDefView     == NULL);
    ASSERT(_hwndRoot     == NULL);
    ASSERT(_pDUIView     == NULL);

    _bInfotip = FALSE;
}

ActionTask::~ActionTask()
{
    if (_bInfotip)
    {
        // Destroy the infotip.
        _pDefView->DestroyInfotip(_hwndRoot, (UINT_PTR)this);
    }

    if (_puiCommand)
        _puiCommand->Release();

    if (_psiItemArray)
        _psiItemArray->Release();

    if (_pDUIView)
        _pDUIView->Release();

    if (_pDefView)
        _pDefView->Release();
}

void ActionTask::UpdateTaskUI()
{
    // Set the icon

    LPWSTR pIconDesc;
    if (SUCCEEDED(_puiCommand->get_Icon(_psiItemArray, &pIconDesc)))
    {
        Element* pe;
        if (SUCCEEDED(Element::Create(0, &pe)))
        {
            pe->SetLayoutPos(BLP_Left);
            pe->SetID(L"icon");
            if (SUCCEEDED(_peButton->Add(pe)))
            {
                HICON hIcon = DUILoadIcon(pIconDesc, TRUE);
                if (hIcon)
                {
                    Value* pv = Value::CreateGraphic (hIcon);
                    if (pv)
                    {
                        pe->SetValue(Element::ContentProp, PI_Local, pv);
                        pv->Release();
                    }
                    else
                    {
                        DestroyIcon(hIcon);

                        TraceMsg(TF_ERROR, "ActionTask::Initialize: CreateGraphic for the icon failed.");
                    }
                }
                else
                {
                    TraceMsg(TF_ERROR, "ActionTask::Initialize: DUILoadIcon failed.");
                }
            }
            else
            {
                pe->Destroy();
            }
        }
        else
        {
            TraceMsg(TF_ERROR, "ActionTask::Initialize: Failed to create icon element");
        }

        CoTaskMemFree(pIconDesc);
    }

    // Set the title

    LPWSTR pszTitleDesc;
    if (SUCCEEDED(_puiCommand->get_Name(_psiItemArray, &pszTitleDesc)))
    {
        Element* pe;
        if (SUCCEEDED(Element::Create(0, &pe)))
        {
            pe->SetLayoutPos(BLP_Left);
            pe->SetID(L"title");
            if (SUCCEEDED(_peButton->Add(pe)))
            {
                Value* pv = Value::CreateString(pszTitleDesc);
                if (pv)
                {
                    _peButton->SetValue(Element::AccNameProp, PI_Local, pv);
                    pe->SetValue(Element::ContentProp, PI_Local, pv);
                    pv->Release();
                }
                else
                {
                    TraceMsg(TF_ERROR, "ActionTask::Initialize: CreateString for the title failed.");
                }
            }
            else
            {
                pe->Destroy();
            }
        }
        else
        {
            TraceMsg(TF_ERROR, "ActionTask::Initialize: Failed to create title element");
        }

        CoTaskMemFree(pszTitleDesc);
    }
}

//  Shows/hides an Infotip window
//
//  bShow - TRUE or FALSE to show or hide the Infotip window

HRESULT ActionTask::ShowInfotipWindow(BOOL bShow)
{
    RECT rect = { 0 };
    HRESULT hr;

    if (bShow)
    {
        _pDUIView->CalculateInfotipRect(this, &rect);
        if (_bInfotip)
        {
            // Reposition infotip at position.
            hr = _pDefView->RepositionInfotip(_hwndRoot, (UINT_PTR)this, &rect);
        }
        else
        {
            // Create infotip at position (on the ui thread).
            LPWSTR pwszInfotip;
            hr = _puiCommand->get_Tooltip(_psiItemArray, &pwszInfotip);
            if (SUCCEEDED(hr))
            {
                hr = GetElementRootHWND(this, &_hwndRoot);
                if (SUCCEEDED(hr))
                {
                    hr = _pDefView->CreateInfotip(_hwndRoot, (UINT_PTR)this, &rect, pwszInfotip, 0);
                    if (SUCCEEDED(hr))
                    {
                        _bInfotip = TRUE;
                    }
                }
                CoTaskMemFree(pwszInfotip);
            }
        }
    }
    else
    {
        if (_bInfotip)
        {
            // Reposition infotip at nowhere.
            hr = _pDefView->RepositionInfotip(_hwndRoot, (UINT_PTR)this, &rect);
        }
        else
        {
            // No infotip == no show!
            hr = S_OK;
        }
    }

    return hr;
}

// System event handler
//
//

void ActionTask::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Default processing...
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    // Extended processing for infotip...
    if (IsProp(MouseWithin))
        ShowInfotipWindow(pvNew->GetBool() && SHShowInfotips());
}


//  Event handler
//
//  pev - event information

void ActionTask::OnEvent(Event* pev)
{
    if (pev->peTarget == _peButton)
    {
        if (pev->uidType == Button::Click)
        {
            if ( NULL != _pDUIView )    // This should have been past in during initialization.
            {
                _pDUIView->DelayedNavigation(_psiItemArray, _puiCommand);
            }
            pev->fHandled = true;
        }
    }
    Element::OnEvent(pev);
}

// Class information

IClassInfo* ActionTask::Class = NULL;
HRESULT ActionTask::Register()
{
    return ClassInfo<ActionTask,Element>::Register(L"ActionTask", NULL, 0);
}


//  Creates an instance of the DestinationTask and
//  initializes it
//
//  nActive    - Activation type
//  pidl       - pidl of destination
//  ppElement  - Receives element pointer
//

HRESULT DestinationTask::Create(UINT nActive, LPITEMIDLIST pidl,
                                 CDUIView * pDUIView, CDefView *pDefView, OUT Element** ppElement)
{
    *ppElement = NULL;

    if (!pidl || !pDUIView || !pDefView)
    {
        return E_FAIL;
    }

    DestinationTask* pDT = HNewAndZero<DestinationTask>();
    if (!pDT)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pDT->Initialize(pidl, pDUIView, pDefView);

    if (FAILED(hr))
    {
        pDT->Destroy();
        return hr;
    }

    *ppElement = pDT;

    return S_OK;
}

//  Initializes this task
//
//  pidl - Destination pidl

HRESULT DestinationTask::Initialize(LPITEMIDLIST pidl, CDUIView *pDUIView, CDefView *pDefView)
{
    HRESULT hr;

    // Initialize this DUI Element.
    hr = InitializeElement();
    if (SUCCEEDED(hr))
    {
        HICON hIcon = NULL;
        WCHAR szTitle[MAX_PATH];

        // Retrieve the info needed to initialize the contained DUI Button.
        HIMAGELIST himl;
        if (Shell_GetImageLists(NULL, &himl))
        {
            IShellFolder *psf;
            LPCITEMIDLIST pidlItem;
            hr = SHBindToFolderIDListParent(NULL, pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlItem);
            if (SUCCEEDED(hr))
            {
                // Retrieve icon.
                int iSysIndex = SHMapPIDLToSystemImageListIndex(psf, pidlItem, NULL);
                if (iSysIndex != -1)
                {
                    hIcon = ImageList_GetIcon(himl, iSysIndex, 0);
                }

                // Retrieve text.
                hr = DisplayNameOf(psf, pidlItem, SHGDN_INFOLDER, szTitle, ARRAYSIZE(szTitle));

                psf->Release();
            }

        }
        else
        {
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            // Initialize the contained DUI Button.
            hr = InitializeButton(hIcon, szTitle);
            if (SUCCEEDED(hr))
            {
                // Save the destination pidl
                hr = SHILClone(pidl, &_pidlDestination);
                if (SUCCEEDED(hr))
                {
                    // Save the pointer to the CDUIView class
                    pDUIView->AddRef();
                    _pDUIView = pDUIView;

                    // Save the pointer to the CDefView class
                    pDefView->AddRef();
                    _pDefView = pDefView;
                }
            }
        }
    }
    return hr;
}

HRESULT DestinationTask::InitializeElement()
{
    HRESULT hr;

    // Initialize base class (normal display node creation).
    hr = Element::Initialize(0);
    if (SUCCEEDED(hr))
    {
        // Create a layout for this element.
        Value *pv;
        hr = BorderLayout::Create(0, NULL, &pv);
        if (SUCCEEDED(hr))
        {
            // Set the layout for this element.
            hr = SetValue(LayoutProp, PI_Local, pv);
            pv->Release();
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "DestinationTask::Initialize: base class failed to initialize with 0x%x", hr);
    }

    return hr;
}

HRESULT DestinationTask::InitializeButton(HICON hIcon, LPCWSTR pwszTitle)
{
    ASSERT(pwszTitle);
    HRESULT hr;

    // Create the button.
    hr =  Button::Create((Element**)&_peButton);
    if (SUCCEEDED(hr))
    {
        // Set some button attributes.
        _peButton->SetLayoutPos(BLP_Left);
        _peButton->SetAccessible(true);
        _peButton->SetAccRole(ROLE_SYSTEM_LINK);
        TCHAR szDefaultAction[50] = {0};
        LoadString(HINST_THISDLL, IDS_LINKWINDOW_DEFAULTACTION, szDefaultAction, ARRAYSIZE(szDefaultAction));
        _peButton->SetAccDefAction(szDefaultAction);

        // Create a border layout for the icon and title in the button.
        Value *pv;
        hr = BorderLayout::Create(0, NULL, &pv);
        if (SUCCEEDED(hr))
        {
            // Set the layout for the button.
            hr = _peButton->SetValue(LayoutProp, PI_Local, pv);
            pv->Release();
            if (SUCCEEDED(hr))
            {
                HRESULT hr2 = E_FAIL;
                HRESULT hr3 = E_FAIL;

                // Init the button icon.
                if (hIcon)
                {
                    Element *peIcon;

                    // Create an icon element.
                    hr2 = Element::Create(0, &peIcon);
                    if (SUCCEEDED(hr2))
                    {
                        // Set some icon element attributes.
                        peIcon->SetLayoutPos(BLP_Left);
                        peIcon->SetID(L"icon");

                        // Add the icon to the icon element.
                        pv = Value::CreateGraphic(hIcon);
                        if (pv)
                        {
                            hr2 = peIcon->SetValue(Element::ContentProp, PI_Local, pv);
                            pv->Release();
                            if (SUCCEEDED(hr2))
                            {
                                // Add the icon element to the button.
                                hr2 = _peButton->Add(peIcon);
                            }
                        }

                        // Cleanup (if necessary).
                        if (FAILED(hr2))
                        {
                            peIcon->Destroy();
                        }
                    }
                }

                // Init the button title.
                if (pwszTitle[0])
                {
                    Element *peTitle;
                    
                    // Create a title element.
                    hr3 = Element::Create(0, &peTitle);
                    if (SUCCEEDED(hr3))
                    {
                        // Set some title element attributes.
                        peTitle->SetLayoutPos(BLP_Left);
                        peTitle->SetID(L"title");

                        // Add the title to the title element.
                        pv = Value::CreateString(pwszTitle);
                        if (pv)
                        {
                            hr3 = peTitle->SetValue(Element::ContentProp, PI_Local, pv);
                            if (SUCCEEDED(hr3))
                            {
                                _peButton->SetValue(Element::AccNameProp, PI_Local, pv);

                                // Add the title element to the button.
                                hr3 = _peButton->Add(peTitle);
                            }
                            pv->Release();
                        }

                        // Cleanup (if necessary).
                        if (FAILED(hr3))
                        {
                            peTitle->Destroy();
                        }
                    }
                }

                if (SUCCEEDED(hr2) || SUCCEEDED(hr3))
                {
                    // Add the button to this element.
                    hr = Add(_peButton);
                }
                else
                {
                    // Failed init icon AND init title for button.
                    hr = E_FAIL;
                }
            }
        }

        if (FAILED(hr))
        {
            _peButton->Destroy();
            _peButton = NULL;
        }
    }

    return hr;
}

DestinationTask::DestinationTask()
{
    // Catch unexpected STACK allocations which would break us.
    ASSERT(_peButton        == NULL);
    ASSERT(_pidlDestination == NULL);
    ASSERT(_pDUIView        == NULL);
    ASSERT(_pDefView        == NULL);
    ASSERT(_hwndRoot        == NULL);

    _bInfotip = FALSE;
}

DestinationTask::~DestinationTask()
{
    if (_bInfotip)
    {
        // Kill the background infotip task (if any).
        if (_pDefView->_pScheduler)
            _pDefView->_pScheduler->RemoveTasks(TOID_DVBackgroundInfoTip, (DWORD_PTR)this, FALSE);

        // Destroy the infotip.
        _pDefView->DestroyInfotip(_hwndRoot, (UINT_PTR)this);
    }

    ILFree(_pidlDestination); /* NULL ok */

    if (_pDUIView)
        _pDUIView->Release();

    if (_pDefView)
        _pDefView->Release();
}


// To use _pDUIView->DelayedNavigation(_psiItemArray, _puiCommand)
// we create this bogus IUICommand impl to get Invoke through
class CInvokePidl : public IUICommand
{
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    // IUICommand
    STDMETHODIMP get_Name(IShellItemArray *psiItemArray, LPWSTR *ppszName) { return E_NOTIMPL; }
    STDMETHODIMP get_Icon(IShellItemArray *psiItemArray, LPWSTR *ppszIcon) { return E_NOTIMPL; }
    STDMETHODIMP get_Tooltip(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip) { return E_NOTIMPL; }
    STDMETHODIMP get_CanonicalName(GUID* pguidCommandName) { return E_NOTIMPL; }
    STDMETHODIMP get_State(IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState) { return E_NOTIMPL; }
    // Our one real method:
    STDMETHODIMP Invoke(IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        return _pDUIView->NavigateToDestination(_pidlDestination);
    }

    friend HRESULT Create_InvokePidl(CDUIView* pDUIView, LPCITEMIDLIST pidl, REFIID riid, void** ppv);

private:
    CInvokePidl(CDUIView* pDUIView, LPCITEMIDLIST pidl, HRESULT* phr);
    ~CInvokePidl();

    LONG _cRef;
    CDUIView* _pDUIView;
    LPITEMIDLIST _pidlDestination;
};

CInvokePidl::CInvokePidl(CDUIView* pDUIView, LPCITEMIDLIST pidl, HRESULT* phr)
{
    _cRef = 1;
    (_pDUIView = pDUIView)->AddRef();

    _pidlDestination = ILClone(pidl);
    if (_pidlDestination)
        *phr = S_OK;
    else
        *phr = E_OUTOFMEMORY;
}

CInvokePidl::~CInvokePidl()
{
    ILFree(_pidlDestination);
    if (_pDUIView)
        _pDUIView->Release();
}

HRESULT Create_InvokePidl(CDUIView* pDUIView, LPCITEMIDLIST pidl, REFIID riid, void** ppv)
{
    HRESULT hr;
    *ppv = NULL;
    CInvokePidl* p = new CInvokePidl(pDUIView, pidl, &hr);
    if (p)
    {
        hr = p->QueryInterface(riid, ppv);
        p->Release();
    }

    return hr;
}

STDMETHODIMP CInvokePidl::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CInvokePidl, IUICommand),
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CInvokePidl::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CInvokePidl::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


//  Navigates to the destination pidl
//
//  none

HRESULT DestinationTask::InvokePidl()
{
    IUICommand* puiInvokePidl;
    HRESULT hr = Create_InvokePidl(_pDUIView, _pidlDestination, IID_PPV_ARG(IUICommand, &puiInvokePidl));
    if (SUCCEEDED(hr))
    {
        hr = _pDUIView->DelayedNavigation(NULL, puiInvokePidl);
        puiInvokePidl->Release();
    }
    return hr;
}

//  Displays the context menu
//
//  ppt - point to display menu

HRESULT DestinationTask::OnContextMenu(POINT *ppt)
{
    HRESULT hr = E_FAIL;

    if (!GetHWND())
        return hr;

    if (ppt->x == -1) // Keyboard context menu
    {
        Value *pv;
        const SIZE *psize = GetExtent(&pv);
        ppt->x = psize->cx/2;
        ppt->y = psize->cy/2;
        pv->Release();
    }

    POINT pt;
    GetRoot()->MapElementPoint(this, ppt, &pt);

    ClientToScreen(GetHWND(), &pt);

    IContextMenu *pcm;
    if (SUCCEEDED(SHGetUIObjectFromFullPIDL(_pidlDestination, GetHWND(), IID_PPV_ARG(IContextMenu, &pcm))))
    {
        IContextMenu *pcmWrap;
        if (SUCCEEDED(Create_ContextMenuWithoutVerbs(pcm, L"link;cut;delete", IID_PPV_ARG(IContextMenu, &pcmWrap))))
        {
            hr = IUnknown_DoContextMenuPopup(SAFECAST(_pDefView, IShellView2*), pcmWrap, CMF_NORMAL, pt);

            pcmWrap->Release();
        }
        pcm->Release();
    }

    return hr;
}

//  Shows/hides an Infotip window
//
//  bShow - TRUE or FALSE to show or hide the Infotip window

HRESULT DestinationTask::ShowInfotipWindow(BOOL bShow)
{
    RECT rect = { 0 };
    HRESULT hr;

    if (bShow)
    {
        _pDUIView->CalculateInfotipRect(this, &rect);
        if (_bInfotip)
        {
            // Reposition infotip at position.
            hr = _pDefView->RepositionInfotip(_hwndRoot, (UINT_PTR)this, &rect);
        }
        else
        {
            // Create infotip at position.
            hr = GetElementRootHWND(this, &_hwndRoot);
            if (SUCCEEDED(hr))
            {
                // PreCreateInfotip() on the ui thread.
                hr = _pDefView->PreCreateInfotip(_hwndRoot, (UINT_PTR)this, &rect);
                if (SUCCEEDED(hr))
                {
                    // PostCreateInfotip() on a background thread.
                    CDUIInfotipTask *pTask;
                    hr = CDUIInfotipTask_CreateInstance(_pDefView, _hwndRoot, (UINT_PTR)this, _pidlDestination, &pTask);
                    if (SUCCEEDED(hr))
                    {
                        hr = _pDefView->_AddTask(pTask, TOID_DVBackgroundInfoTip, (DWORD_PTR)this, TASK_PRIORITY_INFOTIP, ADDTASK_ATEND);
                        pTask->Release();
                    }

                    // Persist success or cleanup failure.
                    if (SUCCEEDED(hr))
                        _bInfotip = TRUE;
                    else
                        _pDefView->DestroyInfotip(_hwndRoot, (UINT_PTR)this);
                }
            }
        }
    }
    else
    {
        if (_bInfotip)
        {
            // Reposition infotip at nowhere.
            hr = _pDefView->RepositionInfotip(_hwndRoot, (UINT_PTR)this, &rect);
        }
        else
        {
            // No infotip == no show!
            hr = S_OK;
        }
    }

    return hr;
}

// System event handler
//
//

void DestinationTask::OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew)
{
    // Default processing...
    Element::OnPropertyChanged(ppi, iIndex, pvOld, pvNew);

    // Extended processing for infotip...
    if (IsProp(MouseWithin))
        ShowInfotipWindow(pvNew->GetBool() && SHShowInfotips());
}

//  Event handler
//
//  pev - event information

void DestinationTask::OnEvent(Event* pev)
{
    if (pev->peTarget == _peButton)
    {
        if (pev->uidType == Button::Click)
        {
            InvokePidl();
            pev->fHandled = true;
        }
        else if (pev->uidType == Button::Context)
        {
            ButtonContextEvent *peButton = reinterpret_cast<ButtonContextEvent *>(pev);
            OnContextMenu(&peButton->pt);
            pev->fHandled = true;
        }
    }
    Element::OnEvent(pev);
}

//  Gadget message callback handler used to return
//  the IDropTarget interface
//
//  pGMsg - Gadget message
//
//  DU_S_COMPLETE if handled
//  Host element's return value if not

UINT DestinationTask::MessageCallback(GMSG* pGMsg)
{
    EventMsg * pmsg = static_cast<EventMsg *>(pGMsg);

    switch (GET_EVENT_DEST(pmsg))
    {
    case GMF_DIRECT:
    case GMF_BUBBLED:

        if (pGMsg->nMsg == GM_QUERY)
        {
            GMSG_QUERYDROPTARGET * pTemp = (GMSG_QUERYDROPTARGET *)pGMsg;

            if (pTemp->nCode == GQUERY_DROPTARGET)
            {
                if (SUCCEEDED(_pDUIView->InitializeDropTarget(_pidlDestination, GetHWND(), &pTemp->pdt)))
                {
                    pTemp->hgadDrop = pTemp->hgadMsg;
                    return DU_S_COMPLETE;
                }
            }
        }
        break;
    }

    return Element::MessageCallback(pGMsg);
}

// Class information

IClassInfo* DestinationTask::Class = NULL;
HRESULT DestinationTask::Register()
{
    return ClassInfo<DestinationTask,Element>::Register(L"DestinationTask", NULL, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duitask.h ===
HRESULT GetElementRootHWNDElement(Element *pe, HWNDElement **pphwndeRoot);
HRESULT GetElementRootHWND(Element *pe, HWND *phwnd);

class ActionTask: public Element
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(0, NULL, NULL, NULL, NULL, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement) { return Create(nActive, NULL, NULL, NULL, NULL, ppElement); }
    static HRESULT Create(UINT nActive, IUICommand* puiCommand, IShellItemArray* psiItemArray, CDUIView* pDUIView, CDefView* pDefView, OUT Element** ppElement);

    // System event callbacks
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    void UpdateTaskUI();

    ActionTask();
    virtual ~ActionTask();

protected:
    HRESULT Initialize(IUICommand* puiCommand, IShellItemArray* psiItemArray, CDUIView* pDUIView, CDefView* pDefView);
    HRESULT InitializeElement();    // init ActionTask DUI Element
    HRESULT InitializeButton();     // init ActionTask's DUI Button
    HRESULT ShowInfotipWindow(BOOL bShow);

private:
    Button*      _peButton;
    IUICommand*  _puiCommand;
    IShellItemArray* _psiItemArray;
    CDUIView*    _pDUIView; // weak link - do not ref.
    CDefView*    _pDefView;
    HWND         _hwndRoot;         // cache of root hwnd element's hwnd
    BOOL         _bInfotip;         // TRUE if infotip has been created
};


class DestinationTask: public Element
{
public:
    static HRESULT Create(OUT Element** ppElement) { return Create(0, NULL, NULL, NULL, ppElement); }
    static HRESULT Create(UINT nActive, OUT Element** ppElement) { return Create(nActive, NULL, NULL, NULL, ppElement); }
    static HRESULT Create(UINT nActive, LPITEMIDLIST pidl, CDUIView* pDUIView, CDefView* pDefView, OUT Element** ppElement);

    // System event callbacks
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    virtual UINT MessageCallback(GMSG* pGMsg);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    DestinationTask();
    virtual ~DestinationTask();

protected:
    HRESULT Initialize(LPITEMIDLIST pidl, CDUIView* pDUIView, CDefView *pDefView);
    HRESULT InitializeElement();                                // init DestinationTask DUI Element
    HRESULT InitializeButton(HICON hIcon, LPCWSTR pwszTitle);   // init DestinationTask's DUI Button
    HRESULT InvokePidl();
    HRESULT OnContextMenu(POINT *ppt);
    HRESULT ShowInfotipWindow(BOOL bShow);

    HWND GetHWND()
    {
        if (!_peHost)
            GetElementRootHWNDElement(this, &_peHost);
        return _peHost ? _peHost->GetHWND() : NULL;
    }


private:
    Button*      _peButton;
    LPITEMIDLIST _pidlDestination;
    CDUIView*    _pDUIView;
    CDefView*    _pDefView;
    HWND         _hwndRoot;         // cache of root hwnd element's hwnd
    BOOL         _bInfotip;         // TRUE if infotip has been created

    // Caching host information
    HWNDElement *           _peHost;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duisec.h ===
class Expando: public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Generic events
    virtual void OnEvent(Event* pEvent);

    // System events
    virtual void OnPropertyChanged(PropertyInfo* ppi, int iIndex, Value* pvOld, Value* pvNew);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    static ATOM idTitle;
    static ATOM idIcon;
    static ATOM idTaskList;
    static ATOM idWatermark;

    void Initialize(DUISEC eDUISecID, IUIElement *puiHeader, CDUIView *pDUIView, CDefView *pDefView);

    void UpdateTitleUI(IShellItemArray *psiItemArray);

    void ShowExpando(BOOL fShow);
    void _SetAccStateInfo (BOOL bExpanded);

    Expando();
    virtual ~Expando();
    HRESULT Initialize();
    HRESULT ShowInfotipWindow(Element *peHeader, BOOL bShow);

private:
    bool        _fExpanding;
    TRIBIT      _fShow;
    DUISEC      _eDUISecID;
    IUIElement* _puiHeader;
    CDUIView*   _pDUIView;
    CDefView*   _pDefView;
    HWND        _hwndRoot;      // cache of root hwnd element's hwnd
    BOOL        _bInfotip;      // TRUE if infotip has been created
};


class TaskList: public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    virtual Element* GetAdjacent(Element* peFrom, int iNavDir, NavReference const* pnr, bool bKeyable);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    TaskList() { }
    virtual ~TaskList() { }
    HRESULT Initialize();

private:
};

class Clipper: public Element
{
public:
    static HRESULT Create(OUT Element** ppElement);

    // Self-layout methods
    void _SelfLayoutDoLayout(int dWidth, int dHeight);
    SIZE _SelfLayoutUpdateDesiredSize(int dConstW, int dConstH, Surface* psrf);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    Clipper() { }
    virtual ~Clipper() { }
    HRESULT Initialize();

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\dvtasks.h ===
#ifndef _DVTASKS_H
#define _DVTASKS_H

#include <runtask.h>

class CDefView;
class CGetIconTask;
class CStatusBarAndInfoTipTask;
class CDUIInfotipTask;
class CTestCacheTask;
class CBackgroundInfoTip;   // Used for the background processing of InfoTips

STDAPI CCategoryTask_Create(CDefView *pView, LPCITEMIDLIST pidl, UINT uId, IRunnableTask **ppTask);
STDAPI CBkgrndEnumTask_CreateInstance(CDefView *pdsv, IEnumIDList * peunk, HDPA hdpaNew, BOOL fRefresh, IRunnableTask **ppTask);
STDAPI CIconOverlayTask_CreateInstance(CDefView *pdsv, LPCITEMIDLIST pdl, int iList, IRunnableTask **ppTask);
STDAPI CExtendedColumnTask_CreateInstance(CDefView *pdsv, LPCITEMIDLIST pidl, UINT uId, int fmt, UINT uiColumn, IRunnableTask **ppTask);
STDAPI CFileTypePropertiesTask_CreateInstance(CDefView *pdsv, LPCITEMIDLIST pidl, UINT uMaxPropertiesToShow, UINT uId, IRunnableTask **ppTask);
STDAPI CStatusBarAndInfoTipTask_CreateInstance(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl, UINT uMsg, int nMsgParam, CBackgroundInfoTip *pbit, HWND hwnd, IShellTaskScheduler2* pScheduler, CStatusBarAndInfoTipTask ** ppTask);
STDAPI CDUIInfotipTask_CreateInstance(CDefView *pDefView, HWND hwndContaining, UINT uToolID, LPCITEMIDLIST pidl, CDUIInfotipTask **ppTask);

STDAPI CTestCacheTask_Create(DWORD dwTaskID, CDefView *pView, 
                             IExtractImage * pExtract, LPCWSTR pszPath, FILETIME ftDateStamp,
                             LPCITEMIDLIST pidl, int iItem, DWORD dwFlags, DWORD dwPriority,
                             BOOL fAsync, BOOL fBackground, BOOL fForce, CTestCacheTask **ppTask);
HRESULT CDiskCacheTask_Create(DWORD dwTaskID, CDefView *pView, 
                              DWORD dwPriority, int iItem, LPCITEMIDLIST pidl, LPCWSTR pszPath, 
                              FILETIME ftDateStamp, IExtractImage *pExtract, DWORD dwFlags, IRunnableTask **ppTask);
HRESULT CExtractImageTask_Create(DWORD dwTaskID, CDefView* pView, 
                                 IExtractImage *pExtract, LPCWSTR pszPath, LPCITEMIDLIST pidl,
                                 FILETIME fNewTimeStamp, int iItem, 
                                 DWORD dwFlags, DWORD dwPriority, IRunnableTask **ppTask);
HRESULT CWriteCacheTask_Create(DWORD dwTaskID, CDefView *pView, 
                               LPCWSTR pszFullPath, FILETIME ftTimeStamp, HBITMAP hImage, IRunnableTask **ppTask);

HRESULT CReadAheadTask_Create(CDefView *pView, IRunnableTask **ppTask);

HRESULT CGetCommandStateTask_Create(CDefView *pView, IUICommand *puiCommand,IShellItemArray *psiItemArray, IRunnableTask **ppTask);

class CTestCacheTask : public CRunnableTask
{
public:
    CTestCacheTask(DWORD dwTaskID, CDefView *pView, IExtractImage *pExtract, LPCWSTR pszPath,
                   FILETIME ftDateStamp, int iItem, DWORD dwFlags, DWORD dwPriority,
                   BOOL fAsync, BOOL fBackground, BOOL fForce);

    STDMETHOD (RunInitRT)();
    HRESULT Init(LPCITEMIDLIST pidl);

protected:
    ~CTestCacheTask();

    CDefView *_pView;
    IExtractImage * _pExtract;
    WCHAR _szPath[MAX_PATH];
    FILETIME _ftDateStamp;
    LPITEMIDLIST _pidl;
    int _iItem;
    DWORD _dwFlags;
    DWORD _dwPriority;
    BOOL _fAsync;
    BOOL _fBackground;
    BOOL _fForce;
    DWORD _dwTaskID;
};

// task used to perform the background status bar update
class CStatusBarAndInfoTipTask : public CRunnableTask
{
public:
    CStatusBarAndInfoTipTask(HRESULT *phr, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl, UINT uMsg, int nMsgParam, CBackgroundInfoTip *pbit, HWND hwnd, IShellTaskScheduler2* pScheduler);
    STDMETHODIMP RunInitRT(void);

protected:
    ~CStatusBarAndInfoTipTask();

    LPITEMIDLIST    _pidl;
    LPITEMIDLIST    _pidlFolder;
    UINT            _uMsg;
    int             _nMsgParam;
    CBackgroundInfoTip *_pbit;
    HWND            _hwnd;
    IShellTaskScheduler2* _pScheduler;
};

class CBackgroundInfoTip : IUnknown
{
public:
    CBackgroundInfoTip(HRESULT *phr, NMLVGETINFOTIP *plvGetInfoTip)
    {
        _lvSetInfoTip.cbSize = sizeof(_lvSetInfoTip);
        _lvSetInfoTip.iItem = plvGetInfoTip->iItem;
        _lvSetInfoTip.iSubItem = plvGetInfoTip->iSubItem;

        *phr = SHStrDup(plvGetInfoTip->pszText, &_lvSetInfoTip.pszText);
        if (SUCCEEDED(*phr))
        {
            // Do not repeat the text if the item is not folded
            if (plvGetInfoTip->dwFlags & LVGIT_UNFOLDED)
                _lvSetInfoTip.pszText[0] = 0;
        }

        _cRef = 1;
    }

    // IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj) { return E_NOINTERFACE; }

    virtual STDMETHODIMP_(ULONG) AddRef(void)
    {
        return InterlockedIncrement(&_cRef);
    }

    virtual STDMETHODIMP_(ULONG) Release(void)
    {
        ASSERT( 0 != _cRef );
        ULONG cRef = InterlockedDecrement(&_cRef);
        if ( 0 == cRef )
        {
            delete this;
        }
        return cRef;
    }

    LVSETINFOTIP _lvSetInfoTip;

    BOOL        _fReady; // This ensures that we will not try to use the object before it's ready
                         // CONSIDER: the memory can be released and then re-used by the same object
                         // CONSIDER: which would have us believe that the InfoTip should be shown.
                         // CONSIDER: But if another InfoTip had been requested and the memory re-used for the new CBackgroundInfoTip
                         // CONSIDER: we would handle the message WM_AEB_ASYNCNAVIGATION with an
                         // CONSIDER: unprocessed CBackgroundInfoTip object. (See the handler for WM_AEB_ASYNCNAVIGATION).

private:
    LONG _cRef;
    ~CBackgroundInfoTip()
    {
        CoTaskMemFree(_lvSetInfoTip.pszText);   // NULL ok
    }
};

class CDUIInfotipTask : public CRunnableTask
{
public:
    CDUIInfotipTask() : CRunnableTask(RTF_DEFAULT) {}

    // Local
    HRESULT Initialize(CDefView *pDefView, HWND hwndContaining, UINT uToolID, LPCITEMIDLIST pidl);

    // IRunnableTask
    STDMETHOD(RunInitRT)(void);

protected:
    virtual ~CDUIInfotipTask();

    CDefView *      _pDefView;
    HWND            _hwndContaining;    // hwnd containing tool
    UINT            _uToolID;           // tool id (unique among tools in containing hwnd)
    LPITEMIDLIST    _pidl;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duiview.cpp ===
#include "shellprv.h"
#include "duiview.h"
#include "duilist.h"
#include "duisec.h"
#include "duitask.h"
#include "duiinfo.h"
#include "duihost.h"
#include "duidrag.h"
#include "defviewp.h"
#include "ids.h"
#include "dvtasks.h"
#include <shimgvw.h>
#include <uxtheme.h>
#include <shstyle.h>

UsingDUIClass(DUIListView);
UsingDUIClass(DUIAxHost);
UsingDUIClass(Expando);
UsingDUIClass(ActionTask);
UsingDUIClass(DestinationTask);


//
// These are private window messages posted to the host window
// so they will be processed async.  There are issues with
// trying to destroy a handler while inside of the handler
//

#define WM_NAVIGATETOPIDL  (WM_USER + 42)
#define WM_REFRESHVIEW     (WM_USER + 43)


#define DUI_HOST_WINDOW_CLASS_NAME  TEXT("DUIViewWndClassName")

//
// Default attributes associated with our DUI sections.
//

struct DUISEC_ATTRIBUTES {
    DUISEC  _eDUISecID;
    BOOL    _bExpandedDefault;
    LPCWSTR _pszExpandedPropName;
} const c_DUISectionAttributes[] = {
    DUISEC_SPECIALTASKS,        TRUE,   L"ExpandSpecialTasks",
    DUISEC_FILETASKS,           TRUE,   L"ExpandFileTasks",
    DUISEC_OTHERPLACESTASKS,    TRUE,   L"ExpandOtherPlacesTasks",
    DUISEC_DETAILSTASKS,        FALSE,  L"ExpandDetailsTasks"
};




//  pDefView - pointer to the defview class

CDUIView* Create_CDUIView(CDefView * pDefView)
{
    CDUIView* p = new CDUIView(pDefView);
    if (p)
    {
        if (FAILED(p->Initialize()))
        {
            delete p;
            p = NULL;
        }
    }
    return p;
}

CDUIView::CDUIView(CDefView * pDefView)
{
    // We have a zero-init constructor.  Be paranoid and check a couple:
    ASSERT(NULL ==_hWnd);
    ASSERT(NULL == _pshlItems);
    ASSERT(NULL == _ppbShellFolders);

    _cRef = 1;
    _pDefView = pDefView;
    _pDefView->AddRef();
}

HRESULT CDUIView::Initialize()
{
    // Initialize DirectUI process (InitProcess) and register classes
    _hrInit = InitializeDirectUI();
    if (FAILED(_hrInit))
        goto Failure;

    // Initialize DirectUI thread
    _hrInit = InitThread();
    if (FAILED(_hrInit))
        goto Failure;
        
    ManageAnimations(FALSE);

    _pDT = new CDUIDropTarget ();

Failure:

    return _hrInit;
}

CDUIView::~CDUIView()
{
    IUnknown_SetSite(_spThumbnailExtractor2, NULL);
    if (_hwndMsgThumbExtract)  // May have been (likely) created by CMiniPreviewer
    {
        DestroyWindow(_hwndMsgThumbExtract);
    }
    
    if (_hwndMsgInfoExtract)  // May have been (likely) created by CNameSpaceItemInfoList
    {
        DestroyWindow(_hwndMsgInfoExtract);
    }
    
    ATOMICRELEASE(_pshlItems);
    if (_bstrIntroText)
    {
        SysFreeString(_bstrIntroText);
    }

    if (_hinstTheme)
    {
        FreeLibrary(_hinstTheme);
        _hinstTheme = NULL;
        _fLoadedTheme = FALSE;
    }

    if (_hinstScrollbarTheme)
    {
        CloseThemeData(_hinstScrollbarTheme);
        _hinstScrollbarTheme = NULL;
    }

    UnInitializeDirectUI();

    if (_ppbShellFolders)
        _ppbShellFolders->Release();

    _pDefView->Release();
}


//
// This DUI uninitialization code was broken out from the destructor
// because we need to call it from defview in response to WM_NCDESTROY
// before the CDUIView object is destroyed.  This is required to properly
// initiate the shutdown of DUser on the thread.  Since we don't own the
// browser thread message pump we must ensure all DUser processing is
// complete before our defview instance goes away.
// Therefore, since it can be called twice, once from defview and once
// from CDUIView::~CDUIView, all processing must tolerate multiple calls
// for the same instance.
//
void CDUIView::UnInitializeDirectUI(void)
{
    ATOMICRELEASE(_pvSpecialTaskSheet);
    ATOMICRELEASE(_pvFolderTaskSheet);
    ATOMICRELEASE(_pvDetailsSheet);
    _ClearNonStdTaskSections();

    if (_pDT)
    {
        _pDT->Release();
        _pDT = NULL;
    }

    ManageAnimations(TRUE);

    if (SUCCEEDED(_hrInit))
    {
        UnInitThread();
        _hrInit = E_FAIL;  // UnInit thread only once.
    }
}


// Right now our themeing information is hard-coded due to limitations of DirectUI (only one resource)
// so we'll ask the namespace for a hardcoded name that we can look up in the below table.  Add new
// names/entries to this list as we add theme parts to our shellstyle.dll.
//

// These theme elements come from shellstyle.dll.
const WVTHEME c_wvTheme[] =
{
    { L"music",   IDB_MUSIC_ICON_BMP,    IDB_MUSIC_TASKS_BMP,    IDB_MUSIC_LISTVIEW_BMP },
    { L"picture", IDB_PICTURES_ICON_BMP, IDB_PICTURES_TASKS_BMP, IDB_PICTURES_LISTVIEW_BMP },
    { L"video",   IDB_VIDEO_ICON_BMP,    IDB_VIDEO_TASKS_BMP,    IDB_VIDEO_LISTVIEW_BMP },
    { L"search",  IDB_SEARCH_ICON_BMP,   IDB_SEARCH_TASKS_BMP,   IDB_SEARCH_LISTVIEW_BMP },
};

const WVTHEME* CDUIView::GetThemeInfo()
{
    for (UINT i = 0 ; i < ARRAYSIZE(c_wvTheme) ; i++)
    {
        if (0 == lstrcmp(_pDefView->_wvTheme.pszThemeID, c_wvTheme[i].pszThemeName))
            return &(c_wvTheme[i]);
    }

    return NULL;
}

//  Main intialization point for DUI view
//
//  bDisplayBarrier - Display soft barrier over top of listview

HRESULT CDUIView::Initialize(BOOL bDisplayBarrier, IUnknown * punkPreview)
{
    DisableAnimations();
    Element::StartDefer();

    // Create the host window for the DUI elements

    HRESULT hr = _CreateHostWindow();
    if (SUCCEEDED(hr))
    {
        // Dynamically build the .ui file for this view

        int iCharCount;
        char *pUIFile = NULL;
        hr = _BuildUIFile(&pUIFile, &iCharCount);
        if (SUCCEEDED(hr))
        {
            // Parse the .ui file and initialize the elements
            hr = _InitializeElements(pUIFile, iCharCount, bDisplayBarrier, punkPreview);
            if (SUCCEEDED(hr))
            {
                BuildDropTarget(_phe->GetDisplayNode(), _phe->GetHWND());

                // Set visible for host element
                _phe->SetVisible(true);
            }
            LocalFree(pUIFile);
        }
    }

    // Note:
    //  EndDefer() here so layout coordinates are calculated before executing
    //  the next snippit of code which depends on them being set properly.
    //  The one thing to be aware of in future is that if this isn't the
    //  outermost BeginDefer()/EndDefer() pair in the codepath, we're in
    //  trouble because then DUI won't calculate its layout coordinates.
    Element::EndDefer();

    if (SUCCEEDED(hr))
    {
        Value* pv;
        if (_peTaskPane->GetExtent(&pv))
        {
            const SIZE * pSize = pv->GetSize();

            _iOriginalTaskPaneWidth = pSize->cx;
            _iTaskPaneWidth = pSize->cx;

            pv->Release();

            // REVIEW: Why are we doing this based on a resource string, instead
            // of simply having the localizers localize the size in the theme???
            // It kind of sucks because we're forcing two layouts all the time.
            _iTaskPaneWidth = ScaleSizeBasedUponLocalization(_iOriginalTaskPaneWidth);

            if (_iTaskPaneWidth != _iOriginalTaskPaneWidth)
            {
                Element::StartDefer();

                // Increase the width of the scroller if the localizers have
                // bumped up the size defined in the resources
                _peTaskPane->SetWidth(_iTaskPaneWidth);

                Element::EndDefer();
            }
        }

        if (_fHideTasklist || (_phe->GetWidth() / 2) < _iTaskPaneWidth)
        {
            Element::StartDefer();

            _peTaskPane->SetWidth(0);

            Element::EndDefer();
        }
        _bInitialized = true;
    }
    else
    {
        if (_hWnd)
        {
            DestroyWindow (_hWnd);
            _hWnd = NULL;
        }
    }

    // Note:
    //  We don't re-enable animations until after we're completely finished
    //  with all our crazy resizing and stuff.  This prevents some nasty
    //  issues with DUI panes only partly painting (i.e. RAID 422057).
    EnableAnimations();

    return hr;
}

void CDUIView::DetachListview()
{
    if (_peListView)
        _peListView->DetachListview();

    if (_hWnd)
    {
        DestroyWindow(_hWnd);
        _hWnd = NULL;
    }
}

//  Creates the host window for the DUI elements to
//  be associated with.  This child window
//  will also be passed back to defview to be used
//  as the result pane host.

HRESULT CDUIView::_CreateHostWindow (void)
{
    WNDCLASS wc = {0};
    
    wc.style          = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc    = _DUIHostWndProc;
    wc.hInstance      = HINST_THISDLL;
    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground  = (HBRUSH)GetStockObject(HOLLOW_BRUSH);
    wc.lpszClassName  = DUI_HOST_WINDOW_CLASS_NAME;
    
    RegisterClass(&wc);
    
    // Query for the size of defview's client window so we can size this window
    // to match
    RECT rc;
    GetClientRect(_pDefView->_hwndView, &rc);
    
    _hWnd = CreateWindowEx(0, DUI_HOST_WINDOW_CLASS_NAME, NULL,
        WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN,
        rc.left, rc.top, rc.right, rc.bottom,
        _pDefView->_hwndView, NULL, HINST_THISDLL, (void *)this);
    
    if (!_hWnd)
    {
        TraceMsg(TF_ERROR, "CDUIView::_CreateHostWindow: CreateWindowEx failed with %d", GetLastError());
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Temporary work-around for DUI mirroring bug 259158
    SHSetWindowBits(_hWnd, GWL_EXSTYLE, WS_EX_LAYOUTRTL, 0);

    return S_OK;
}

void CDUIView::ManageAnimations(BOOL bExiting)
{
    if (bExiting)
    {
        if (_bAnimationsDisabled)
        {
            DirectUI::EnableAnimations();
            _bAnimationsDisabled = FALSE;
        }
    }
    else
    {
        BOOL bAnimate = TRUE;
        SystemParametersInfo(SPI_GETMENUANIMATION, 0, &bAnimate, 0);


        if (bAnimate)
        {
            if (_bAnimationsDisabled)
            {
                DirectUI::EnableAnimations();
                _bAnimationsDisabled = FALSE;
            }
        }
        else
        {
            if (!_bAnimationsDisabled)
            {
                DirectUI::DisableAnimations();
                _bAnimationsDisabled = TRUE;
            }
        }
    }
}

HINSTANCE CDUIView::_GetThemeHinst()
{
    if (!_fLoadedTheme)
    {
        _fLoadedTheme = TRUE;
        if (_hinstTheme)
        {
            FreeLibrary(_hinstTheme);
        }

        _hinstTheme = SHGetShellStyleHInstance();

        if (_hinstScrollbarTheme)
        {
            CloseThemeData (_hinstScrollbarTheme);
        }

        _hinstScrollbarTheme = OpenThemeData(_hWnd, L"Scrollbar");
    }

    return _hinstTheme ? _hinstTheme : HINST_THISDLL;
}

//  Loads the requested UI file from shell32's resources
//
//  iID         - UI file id
//  pUIFile     - receives a pointer to the UI file

HRESULT CDUIView::_LoadUIFileFromResources(HINSTANCE hinst, int iID, char **pUIFile)
{
    HRESULT hr;

    HRSRC hFile = FindResource(hinst, MAKEINTRESOURCE(iID), TEXT("UIFILE"));
    if (hFile)
    {
        HGLOBAL hFileHandle = LoadResource(hinst, hFile);
        if (hFileHandle)
        {
            char *pFile = (char *)LockResource(hFileHandle);
            if (pFile)
            {
                DWORD dwSize = SizeofResource(hinst, hFile);

                *pUIFile = (char *)LocalAlloc(LPTR, dwSize + 1); // +1 ensures *pUIFile is NULL-terminated
                if (*pUIFile)
                {
                    CopyMemory(*pUIFile, pFile, dwSize);
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = ResultFromLastError();
            }
        }
        else
        {
            hr = ResultFromLastError();
        }
    }
    else
    {
        hr = ResultFromLastError();
    }
    return hr;
}

//  Builds the UI file for this view from the
//  appropriate base template + style sheet
//
//  pUIFile receives a pointer to the ui file in memory
//  piCharCount receives the size of the file

HRESULT CDUIView::_BuildUIFile(char **pUIFile, int *piCharCount)
{
    // Load the base UI file
    char * pBase;
    HRESULT hr = _LoadUIFileFromResources(HINST_THISDLL, IDR_DUI_FOLDER, &pBase);
    if (SUCCEEDED(hr))
    {
        // Load the style sheet.  First, check if the current theme has a style sheet,
        // if not, use the default style sheet in the resources.
        char *pStyle;
        hr = _LoadUIFileFromResources(_GetThemeHinst(), IDR_DUI_STYLESHEET, &pStyle);
        if (SUCCEEDED(hr))
        {
            size_t cchResult = lstrlenA(pBase) + lstrlenA(pStyle) + 1;
            char *pResult = (char *)LocalAlloc(LPTR, cchResult * sizeof(char));
            if (pResult)
            {
                // Put the files together
                StringCchCopyA(pResult, cchResult, pStyle); // pResult allocated above to be sufficient size
                StringCchCatA(pResult, cchResult, pBase);   // pResult allocated above to be sufficient size

                // Store the final results
                *pUIFile = pResult;
                *piCharCount = lstrlenA(pResult);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
            LocalFree(pStyle);
        }
        LocalFree(pBase);
    }
    return hr;
}

//  Callback function used by the ui file parser
//
//  pszError -  Error text
//  pszToken -  Token text
//  iLine    -  Line number

void CALLBACK UIFileParseError(LPCWSTR pszError, LPCWSTR pszToken, int iLine)
{
    TraceMsg (TF_ERROR, "UIFileParseError: %s '%s' at line %d", pszError, pszToken, iLine);
}

//  Builds a section which holds tasks
//
//  peSectionList  - parent of the section
//  bMain          - Main section or normal section
//  pTitleUI       - interface describing the title, may be NULL if pTitleDesc provided
//  pBitmapDesc    - Description of the bitmap
//  pWatermarkDesc - Description of the watermark
//  pvSectionSheet - Style sheet to be used
//  pParser        - Parser instance pointer
//  fExpanded      - Expanded or closed
//  ppeExpando     - [out,optional] Receives the section just created
//  pTaskList      - [out] Receives the task list area element pointer within the pExpando

HRESULT CDUIView::_BuildSection(Element* peSectionList, BOOL bMain, IUIElement* pTitleUI,
                                int idBitmapDesc, int idWatermarkDesc, Value* pvSectionSheet,
                                Parser* pParser, DUISEC eDUISecID, Expando** ppeExpando, Element ** ppTaskList)
{
    Expando* peSection = NULL;
    Value* pv = NULL;
    Element* pe = NULL;
    HBITMAP hBitmap;


    // Create a section using the definition in the ui file

    HRESULT hr = pParser->CreateElement (bMain ? L"mainsection" : L"section", NULL, &pe);

    if (FAILED(hr))
    {
        TraceMsg (TF_ERROR, "CDUIView::_BuildSection: CreateElement failed with 0x%x", hr);
        return hr;
    }

    ASSERTMSG(pe->GetClassInfo() == Expando::Class, "CDUIView::_BuildSection: didn't get an Expando::Class object (%s)", pe->GetClassInfo()->GetName());
    peSection = (Expando*)pe;

    pe->SetWidth(ScaleSizeBasedUponLocalization(pe->GetWidth()));

    peSection->Initialize(eDUISecID, pTitleUI, this, _pDefView);
    if (ppeExpando)
        *ppeExpando = peSection;

    // Add the section to the list

    hr = peSectionList->Add (peSection);
    if (SUCCEEDED(hr))
    {
        // Set the title

        peSection->UpdateTitleUI(NULL); // nothing is selected when the folder starts up


        // Set the bitmap on the left side

        if (idBitmapDesc)
        {
            pe = peSection->FindDescendent (Expando::idIcon);

            if (pe)
            {
                hBitmap = DUILoadBitmap(_GetThemeHinst(), idBitmapDesc, LR_CREATEDIBSECTION);
                if (hBitmap)
                {
                    pv = Value::CreateGraphic(hBitmap, GRAPHIC_AlphaConstPerPix);

                    if (pv)
                    {
                        pe->SetValue (Element::ContentProp, PI_Local, pv);
                        pv->Release ();
                    }
                    else
                    {
                        DeleteObject(hBitmap);

                        TraceMsg (TF_ERROR, "CDUIView::_BuildSection: CreateGraphic for the bitmap failed.");
                    }
                }
                else
                {
                    TraceMsg (TF_ERROR, "CDUIView::_BuildSection: DUILoadBitmap failed.");
                }
            }
            else
            {
                TraceMsg (TF_ERROR, "CDUIView::_BuildSection: FindDescendent for the bitmap failed.");
            }
        }


        if (idWatermarkDesc)
        {
            HINSTANCE hinstTheme = _GetThemeHinst();
            pe = peSection->FindDescendent (Expando::idWatermark);
            if (pe)
            {
                // Note:  in Classic mode, we don't want the watermarks, so this function
                // will return NULL
                hBitmap = DUILoadBitmap(hinstTheme, idWatermarkDesc, LR_CREATEDIBSECTION);
                if (hBitmap)
                {
                    pv = Value::CreateGraphic(hBitmap, GRAPHIC_NoBlend);
                    if (pv)
                    {
                        pe->SetValue (Element::ContentProp, PI_Local, pv);
                        pv->Release ();
                    }
                    else
                    {
                        DeleteObject(hBitmap);

                        TraceMsg (TF_ERROR, "CDUIView::_BuildSection: CreateGraphic for the watermark failed.");
                    }
                }
            }
            else
            {
                TraceMsg (TF_ERROR, "CDUIView::_BuildSection: FindDescendent for the watermark failed.");
            }
        }


        // Set the style sheet if specified

        if (pvSectionSheet)
        {
            peSection->SetValue (Element::SheetProp, PI_Local, pvSectionSheet);
        }


        // Set the expanded state.  By default, it is expanded.

        if (!_ShowSectionExpanded(eDUISecID))
        {
            peSection->SetSelected(FALSE);
        }


        // Add padding for the icon if appropriate.  Note, this has to happen
        // after the style sheet is applied

        if (idBitmapDesc)
        {
            Element* pe = peSection->FindDescendent(StrToID(L"header"));

            if (pe)
            {
                Value* pvValue;
                const RECT * prect;

                prect = pe->GetPadding (&pvValue);

                if (prect)
                {
                    pe->SetPadding ((prect->left + 20), prect->top, prect->right, prect->bottom);
                    pvValue->Release();
                }
            }
        }


        // Return the task list element pointer

        *ppTaskList = peSection->FindDescendent (Expando::idTaskList);

        if (*ppTaskList)
        {
            hr = S_OK;
        }
        else
        {
            TraceMsg (TF_ERROR, "CDUIView::_BuildSection: Failed to find task list element");
            hr = E_FAIL;
        }

    }
    else
    {
        peSection->Destroy();
        if (ppeExpando)
            *ppeExpando = NULL;
        *ppTaskList = NULL;
    }

    return hr;
}

//  Adds the action tasks to the task list
//
//  peTaskList  - Parent element
//  penum       - enumeration interface
//  pvTaskSheet - Style sheet

HRESULT CDUIView::_AddActionTasks(Expando* peExpando, Element* peTaskList, IEnumUICommand* penum, Value* pvTaskSheet, BOOL bIntroAdded)
{
    IUICommand* puiCommand;
    BOOL fShow = bIntroAdded;

    while (S_OK==penum->Next(1, &puiCommand, NULL))
    {
        UISTATE uis;
        HRESULT hr = puiCommand->get_State(_pshlItems, FALSE, &uis);  // Don't do it if it's going to take long, instead, returns E_PENDING
        if (SUCCEEDED(hr) && (uis==UIS_ENABLED))
        {
            Element *pe;
            HRESULT hr = ActionTask::Create(0, puiCommand, _pshlItems, this, _pDefView, &pe);
            if (SUCCEEDED(hr))
            {
                if (pvTaskSheet)
                {
                    pe->SetValue(Element::SheetProp, PI_Local, pvTaskSheet);
                }

                if (SUCCEEDED(peTaskList->Add(pe)))
                {
                    fShow = TRUE;
                }
                else
                {
                    pe->Destroy();
                }
            }
        }
        else if (hr == E_PENDING)
        {
            IRunnableTask *pTask;
            if (SUCCEEDED(CGetCommandStateTask_Create(_pDefView, puiCommand, _pshlItems, &pTask)))
            {
                _pDefView->_AddTask(pTask, TOID_DVGetCommandState, 0, TASK_PRIORITY_GETSTATE, ADDTASK_ATEND);
                pTask->Release();
            }
        }

        puiCommand->Release();
    }
    penum->Reset();

    peExpando->ShowExpando(fShow);

    return S_OK;
}

//  Adds the destination tasks to the task list
//
//  peTaskList  - Parent element
//  penum       - enumerator of pidls to display
//  pvTaskSheet - Style sheet

HRESULT CDUIView::_AddDestinationTasks(Element* peTaskList, IEnumIDList* penum, Value* pvTaskSheet)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidl;

    while (S_OK==penum->Next(1, &pidl, NULL))
    {
        Element *pe;
        hr = DestinationTask::Create (0, pidl, this, _pDefView, &pe);
        if (SUCCEEDED(hr))
        {
            if (pvTaskSheet)
            {
                pe->SetValue(Element::SheetProp, PI_Local, pvTaskSheet);
            }

            if (FAILED(peTaskList->Add(pe)))
            {
                pe->Destroy();
            }
        }
        ILFree(pidl);
    }

    penum->Reset();

    return hr;
}

//
//  Purpose:    Adds the DetailsSectionInfo
//
HRESULT CDUIView::_AddDetailsSectionInfo()
{
    IShellItemArray *psiShellItems = _pshlItems;

    if (!psiShellItems && _pDefView)
    {
        psiShellItems = _pDefView->_GetFolderAsShellItemArray();
    }
    
    //TODO: background thread!
    Element* pElement;
    HRESULT hr = CNameSpaceItemInfoList::Create(this, _pvDetailsSheet,psiShellItems, &pElement);
    if (pElement)
    {
        hr = _peDetailsInfoArea->Add(pElement);
        if (FAILED(hr))
        {
            pElement->Destroy();
        }
    }
    return hr;
}

//  Navigates to the destination pidl
//
//  pidl - destination

HRESULT CDUIView::NavigateToDestination(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlClone = ILClone(pidl);

    if (pidlClone)
    {
        UINT wFlags = (SBSP_DEFBROWSER | SBSP_ABSOLUTE);

        // mimic "new window" behavior
        if (0 > GetKeyState(VK_SHIFT))
        {
            wFlags |= SBSP_NEWBROWSER;
        }

        if (!PostMessage(_hWnd, WM_NAVIGATETOPIDL, (WPARAM)wFlags, (LPARAM)pidlClone))
        {
            ILFree(pidlClone);
        }
    }
    
    return S_OK;
}

//  Sends a delay navigation command to the view window. This delay allows 
//  double-clicks to be interpretted as a single click. This prevents
//  double navigations usually causing the user to end up with two "things"
//  instead of just one. 
//
//  Also by doing this, the issue of the 2nd click causing the old window to 
//  get activation is handled. The user is expecting the new window to pop 
//  up in front of the old window. But, because the user double-clicked,
//  the old window would get reactivated and the new window would end up 
//  behind the current window. See WM_USER_DELAY_NAVIGATION in HWNDView (below)
//  for more details.
//
//  psiItemArray - the shell item to navigate. Can be NULL.
//  puiCommand - the command object to send the navigation to.

HRESULT CDUIView::DelayedNavigation(IShellItemArray *psiItemArray, IUICommand *puiCommand)
{
    SendMessage(_phe->GetHWND(), WM_USER_DELAY_NAVIGATION, (WPARAM) psiItemArray, (LPARAM) puiCommand);
    return S_OK;
}


//  Builds the task list area
//
//  pParser - Parsing instance

HRESULT CDUIView::_BuildTaskList(Parser* pParser)
{
    HRESULT hr = S_OK;

    // Locate section list element

    Element* peSectionList = _phe->FindDescendent (StrToID(L"sectionlist"));

    if (!peSectionList)
    {
        TraceMsg (TF_ERROR, "CDUIView::_BuildTaskList: Failed to find section list element");
        return E_FAIL;
    }

    if (SFVMWVF_ENUMTASKS & _pDefView->_wvContent.dwFlags)
    {
        if (_bInitialized)
        {
            //
            // The 'non-standard' task list is the type who's contents
            // are dynamically enumerated by the folder view.
            // In the case of Control Panel, items in this content appear
            // conditionally based upon many factors, one being the categorization
            // of applets.  In order for the content to be correct, categorization
            // must be correct which means that all folder items are known.
            // To avoid multiple repaints of the task lists, we defer creation 
            // of the task lists until AFTER the initial creation of the view.  
            // Once all folder items have been enumerated, the webview content
            // is refreshed in response to a 'contents changed' notification from
            // defview.  It is during this update that we pass through this code
            // section and build the task list.
            // 
            _ClearNonStdTaskSections();
            hr = _GetNonStdTaskSectionsFromViewCB();
            if (SUCCEEDED(hr) && NULL != _hdsaNonStdTaskSections)
            {
                hr = _BuildNonStandardTaskList(pParser, peSectionList, _hdsaNonStdTaskSections);
            }
        }
    }
    else
    {
        hr = _BuildStandardTaskList(pParser, peSectionList);
    }
    return THR(hr);
}


//
// Builds the task list by requesting task section information
// from the view callback using an enumeration mechanism.
//
//
// ISSUE-2001/01/03-BrianAu  Review
//
//     Review this with MikeSh and EricFlo.  
//     I think we should build this generic mechanism then implement the
//     'standard' webview code in terms of this generic mechanism.  
//     Would be best to replace the SFVM_ENUMWEBVIEWTASKS callback message
//     with a message that receives a COM enumerator.
//
//     I like the idea.  We replace SFVMWVF_SPECIALTASK with an LPCSTR to the theme identifier.
//     We can put a SFVM_GETWEBVIEWTASKS to SFVM_ENUMWEBVIEWTASKS layer in for us too.
//
HRESULT CDUIView::_BuildNonStandardTaskList(Parser *pParser, Element *peSectionList, HDSA hdsaSections)
{
    Value* pvMainSectionSheet = NULL;
    Value *pvMainTaskSheet    = NULL;
    Value* pvStdSectionSheet  = NULL;
    Value* pvStdTaskSheet     = NULL;

    HRESULT hr = S_OK;

    ASSERT(NULL != hdsaSections);
    ASSERT(NULL != pParser);
    ASSERT(NULL != peSectionList);

    const int cSections = DSA_GetItemCount(hdsaSections);
    for (int i = 0; i < cSections; i++)
    {
        SFVM_WEBVIEW_ENUMTASKSECTION_DATA *pSection = (SFVM_WEBVIEW_ENUMTASKSECTION_DATA *)DSA_GetItemPtr(hdsaSections, i);
        ASSERT(NULL != pSection);

        const BOOL bMainSection = (0 != (SFVMWVF_SPECIALTASK & pSection->dwFlags));

        Value *pvSectionSheet = NULL;
        Value *pvTaskSheet    = NULL;
        DUISEC eDUISecID;

        if (bMainSection)
        {
            if (NULL == pvMainSectionSheet)
            {
                pvMainSectionSheet = pParser->GetSheet(L"mainsectionss");
            }
            if (NULL == pvMainTaskSheet)
            {
                pvMainTaskSheet = pParser->GetSheet(L"mainsectiontaskss");
            }

            pvSectionSheet = pvMainSectionSheet;
            pvTaskSheet    = pvMainTaskSheet;
            eDUISecID      = DUISEC_SPECIALTASKS;
        }
        else
        {
            if (NULL == pvStdSectionSheet)
            {
                pvStdSectionSheet = pParser->GetSheet(L"sectionss");
            }
            if (NULL == pvStdTaskSheet)
            {
                pvStdTaskSheet = pParser->GetSheet(L"sectiontaskss");
            }

            pvSectionSheet = pvStdSectionSheet;
            pvTaskSheet    = pvStdTaskSheet;
            eDUISecID      = DUISEC_FILETASKS;
        }

        ASSERT(NULL != pvSectionSheet);
        Expando *peSection;
        Element *peTaskList;
        hr = _BuildSection(peSectionList, 
                           bMainSection,
                           pSection->pHeader,
                           pSection->idBitmap,
                           pSection->idWatermark,
                           pvSectionSheet,
                           pParser,
                           eDUISecID,
                           &peSection,
                           &peTaskList);
        if (SUCCEEDED(hr))
        {
            hr = _AddActionTasks(peSection, peTaskList, pSection->penumTasks, pvTaskSheet, FALSE);
        }
    }

    if (pvMainSectionSheet)
    {
        pvMainSectionSheet->Release();
    }
    if (pvMainTaskSheet)
    {
        pvMainTaskSheet->Release();
    }
    if (pvStdSectionSheet)
    {
        pvStdSectionSheet->Release();
    }
    if (pvStdTaskSheet)
    {
        pvStdTaskSheet->Release();
    }

    return THR(hr);
}


HRESULT CDUIView::_GetIntroTextElement(Element** ppeIntroText)
{
    if (SHRegGetBoolUSValue(REGSTR_PATH_EXPLORER, TEXT("ShowWebViewIntroText"), FALSE, FALSE))
    {
        if (!_bstrIntroText)
        {
            WCHAR wszIntroText[INFOTIPSIZE];
            if (_bBarrierShown)
            {
                LoadString(HINST_THISDLL, IDS_INTRO_BARRICADED, wszIntroText, ARRAYSIZE(wszIntroText));
            }
            else if (!_pDefView->_pshf2Parent
                    || FAILED(GetStringProperty(_pDefView->_pshf2Parent, _pDefView->_pidlRelative,
                        &SCID_FolderIntroText, wszIntroText, ARRAYSIZE(wszIntroText))))
            {
                wszIntroText[0] = L'\0';
            }

            _bstrIntroText = SysAllocString(wszIntroText);
        }
    }
    
    HRESULT hr = E_FAIL;
    if (_bstrIntroText && _bstrIntroText[0])
    {
        hr = CNameSpaceItemInfo::Create(_bstrIntroText, ppeIntroText);
        if (SUCCEEDED(hr))
        {
            if (_pvDetailsSheet)
            {
                (*ppeIntroText)->SetValue(Element::SheetProp, PI_Local, _pvDetailsSheet);
            }
        }
    }
    return hr;
}

HRESULT CDUIView::_BuildStandardTaskList(Parser *pParser, Element *peSectionList)
{
    Element* peTaskList;
    Value* pvSectionSheet = NULL;
    Value* pvTaskSheet = NULL;
    Value* pvDetailsSheet = NULL;

    HRESULT hr = S_OK;

    Element* peIntroText;
    if (FAILED(_GetIntroTextElement(&peIntroText)))
    {
        peIntroText = NULL;
    }

    //
    // Special Tasks section is optional (main section)
    //
    if (_pDefView->_wvContent.pSpecialTaskHeader)
    {
        pvSectionSheet = pParser->GetSheet(L"mainsectionss");

        int idBitmap = 0;
        int idWatermark = 0;
        const WVTHEME* pThemeInfo = GetThemeInfo();
        if (pThemeInfo)
        {
            idBitmap = pThemeInfo->idSpecialSectionIcon;
            idWatermark = pThemeInfo->idSpecialSectionWatermark;
        }

        // TODO: get special section open/closed state from the per-user-per-pidl property bag

        hr = _BuildSection(
            peSectionList,
            TRUE,
            _pDefView->_wvContent.pSpecialTaskHeader,
            idBitmap,
            idWatermark,
            pvSectionSheet,
            pParser,
            DUISEC_SPECIALTASKS,
            &_peSpecialSection,
            &peTaskList);


        if (SUCCEEDED(hr))
        {
            BOOL bIntroTextAdded = FALSE;

            _peSpecialTaskList = peTaskList;

            // Add the tasks + style sheet

            _pvSpecialTaskSheet = pParser->GetSheet(L"mainsectiontaskss");

            if (peIntroText)
            {
                if (SUCCEEDED(_peSpecialTaskList->Add(peIntroText)))
                {
                    bIntroTextAdded = TRUE;
                    peIntroText = NULL;
                }
            }
            
            _AddActionTasks(_peSpecialSection, _peSpecialTaskList, _pDefView->_wvTasks.penumSpecialTasks, _pvSpecialTaskSheet, bIntroTextAdded);
        }

        if (pvSectionSheet)
            pvSectionSheet->Release();
    }

    // Get the style sheets for remaining standard sections

    pvSectionSheet = pParser->GetSheet (L"sectionss");
    pvTaskSheet = pParser->GetSheet (L"sectiontaskss");

    // File tasks section (standard section) Not shown if the barricade is shown.

    if (!_bBarrierShown)
    {
        if (_pDefView->_wvContent.pFolderTaskHeader)
        {
            // TODO: get folder section open/closed state from the per-user-per-pidl property bag

            hr = _BuildSection(
                peSectionList,
                FALSE,
                _pDefView->_wvContent.pFolderTaskHeader,
                0,
                0,
                pvSectionSheet,
                pParser,
                DUISEC_FILETASKS,
                &_peFolderSection,
                &peTaskList);
            if (SUCCEEDED(hr))
            {
                BOOL bIntroTextAdded = FALSE;

                _peFolderTaskList = peTaskList;

                _pvFolderTaskSheet = pvTaskSheet;
                if (_pvFolderTaskSheet)
                    _pvFolderTaskSheet->AddRef();

                if (peIntroText)
                {
                    if (SUCCEEDED(_peFolderTaskList->Add(peIntroText)))
                    {
                        bIntroTextAdded = TRUE;
                        peIntroText = NULL;
                    }
                }
                
                _AddActionTasks(_peFolderSection, _peFolderTaskList, _pDefView->_wvTasks.penumFolderTasks, _pvFolderTaskSheet, bIntroTextAdded);
            }
        }
    }

    // Other places tasks section (standard section)

    if (_pDefView->_pOtherPlacesHeader)
    {
        // TODO: get OtherPlaces section open/closed state from the per-user-per-pidl property bag

        hr = _BuildSection(
            peSectionList,
            FALSE,
            _pDefView->_pOtherPlacesHeader,
            0,
            0,
            pvSectionSheet,
            pParser,
            DUISEC_OTHERPLACESTASKS,
            NULL,
            &peTaskList);
        if (SUCCEEDED(hr))
        {
            _AddDestinationTasks(peTaskList, _pDefView->_wvContent.penumOtherPlaces, pvTaskSheet);
        }
    }


    // Details tasks section (standard section)

    if (_pDefView->_pDetailsHeader)
    {
        // TODO: get Details section open/closed state from the per-user-per-pidl property bag

        hr = _BuildSection(
            peSectionList,
            FALSE,
            _pDefView->_pDetailsHeader,
            0,
            0,
            pvSectionSheet,
            pParser,
            DUISEC_DETAILSTASKS,
            &_peDetailsSection,
            &_peDetailsInfoArea);
        if (SUCCEEDED(hr))
        {
            _AddDetailsSectionInfo();
            
        }
    }

    if (peIntroText)
    {
        peIntroText->Destroy();
    }
    
    if (pvTaskSheet)
    {
        pvTaskSheet->Release();
    }

    if (pvSectionSheet)
    {
        pvSectionSheet->Release();
    }

    return hr;
}

BOOL CDUIView::_ShowSectionExpanded(DUISEC eDUISecID)
{
    const struct DUISEC_ATTRIBUTES *pAttrib = _GetSectionAttributes(eDUISecID);
    BOOL bDefault;
    BOOL bShow;

    if (eDUISecID == DUISEC_DETAILSTASKS)
        bDefault = ((_pDefView->_wvLayout.dwLayout & SFVMWVL_ORDINAL_MASK) == SFVMWVL_DETAILS);
    else
        bDefault = pAttrib->_bExpandedDefault;

    if (_ppbShellFolders)
        bShow = SHPropertyBag_ReadBOOLDefRet(_ppbShellFolders, pAttrib->_pszExpandedPropName, bDefault);
    else
        bShow = bDefault;

    return bShow;
}

const struct DUISEC_ATTRIBUTES *CDUIView::_GetSectionAttributes(DUISEC eDUISecID)
{
    static const size_t nSections = ARRAYSIZE(c_DUISectionAttributes);
    size_t iSection;

    // Determine attributes of DUISEC we're interested in.
    for (iSection = 0; iSection < nSections; iSection++)
        if (c_DUISectionAttributes[iSection]._eDUISecID == eDUISecID)
            return &c_DUISectionAttributes[iSection];

    ASSERT(FALSE);  // Game over -- insert quarters!
    return NULL;    // AV!
}

HRESULT SetDescendentString(Element* pe, LPWSTR pszID, UINT idString)
{
    HRESULT hr;
    
    Element* peChild = pe->FindDescendent(StrToID(pszID));
    if (peChild)
    {
        TCHAR szString [INFOTIPSIZE];
        LoadString(HINST_THISDLL, idString, szString, ARRAYSIZE(szString));

        hr = peChild->SetContentString(szString);
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

//  Parses the .ui file and initializes the DUI elements
//
//  pUIFile         - Pointer to the UI file in memory
//  iCharCount      - Number of characters in the ui file
//  bDisplayBarrier - Display soft barrier over listview
//  punkPreview     - IUnknown interface for the preview control

HRESULT CDUIView::_InitializeElements (char * pUIFile, int iCharCount,
                                       BOOL bDisplayBarrier, IUnknown * punkPreview)
{
    Parser* pParser;
    Element* pe;
    RECT rc;
    HANDLE arH[2];

    // Parse the UI file

    arH[0] = _GetThemeHinst();
    arH[1] = _hinstScrollbarTheme;

    HRESULT hr = Parser::Create(pUIFile, iCharCount, arH, UIFileParseError, &pParser);

    if (FAILED(hr))
    {
        TraceMsg (TF_ERROR, "CDUIView::_InitializeElements: Parser::Create failed with 0x%x", hr);
        return hr;
    }

    if (pParser->WasParseError())
    {
        TraceMsg (TF_ERROR, "CDUIView::_InitializeElements: WasParseError is TRUE");
        pParser->Destroy();
        return E_FAIL;
    }

    // Create the host element
    hr = HWNDView::Create(_hWnd, false, 0, this, _pDefView, (Element**)&_phe); // _phe is owned by _hWnd
    if (FAILED(hr))
    {
        TraceMsg (TF_ERROR, "CDUIView::_InitializeElements: HWNDElement::Create failed with 0x%x", hr);
        pParser->Destroy();
        return hr;
    }

    // We need to ensure that the root item will not paint on WM_ERASEBCKGRND, so here we remove the default brush
    // - Turn off the (default) background fill
    HGADGET hgadRoot = _phe->GetDisplayNode();
    ASSERTMSG(hgadRoot != NULL, "Must have a peer Gadget");
    SetGadgetFillI(hgadRoot, NULL, BLEND_OPAQUE, 0, 0);

    // We need to ensure that the root item will not paint on WM_ERASEBCKGRND, so make it transparent
    _phe->SetBackgroundColor(ARGB(0, 0, 0, 0));

    // Size the host element to match the size of the host window

    GetClientRect (_hWnd, &rc);
    _phe->SetWidth(rc.right - rc.left);
    _phe->SetHeight(rc.bottom - rc.top);

    // Create the main element in the ui file

    hr = pParser->CreateElement(L"main", _phe, &pe);

    if (FAILED(hr))
    {
        TraceMsg (TF_ERROR, "CDUIView::_InitializeElements: pParser->CreateElement failed with 0x%x", hr);
        pParser->Destroy();
        return hr;
    }

    // Cache the element pointers to the 3 main areas: taskpane, clientviewhost, blockade
    _peTaskPane = _phe->FindDescendent(StrToID(L"scroller"));
    _peClientViewHost = _phe->FindDescendent(StrToID(L"clientviewhost"));
    _peBarrier = _phe->FindDescendent(StrToID(L"blockade"));

    // Cache style sheets for the items we create directly (that don't inherit from their immediate parents)
    _pvDetailsSheet = pParser->GetSheet(L"NameSpaceItemInfoList");
        
    if (_peTaskPane && _peClientViewHost && _peBarrier && _pvDetailsSheet)
    {
        // Double buffered items need to be opaque
        _peTaskPane->SetBackgroundColor(ARGB(255, 0, 0, 0));
        _peTaskPane->DoubleBuffered(true);

        // Create the real listview element
        hr = DUIListView::Create(AE_MouseAndKeyboard, _pDefView->_hwndListview, (Element **)&_peListView);
        if (SUCCEEDED(hr))
        {
            _peListView->SetLayoutPos(BLP_Client);
            _peListView->SetID(L"listview");

            hr = _peClientViewHost->Add(_peListView);
            if (SUCCEEDED(hr))
            {
                _pDefView->_AutoAutoArrange(0);
            }
            else
            {
                TraceMsg(TF_ERROR, "CDUIView::_InitializeElements: DUIListView::Could not add listview with 0x%x", hr);

                _peListView->Destroy();
                _peListView = NULL;
            }
        }
        else
        {
            TraceMsg(TF_ERROR, "CDUIView::_InitializeElements: Could not create listview element");
        }
    }
    else
    {
        TraceMsg(TF_ERROR, "CDUIView::_InitializeElements: Could not find main element");

        hr = E_FAIL;
    }
    
    if (FAILED(hr))
    {
        // we gotta have the listview or you get no webview...
        pParser->Destroy();
        return hr;
    }

    // Build the preview control if appropriate
    _ManagePreview(punkPreview);

    _BuildSoftBarrier();

    _SwitchToBarrier(bDisplayBarrier);

    // Create an interface to the property bag for this class of IShellFolder.

    _InitializeShellFolderPropertyBag();

    // Build the task list area

    hr = _BuildTaskList (pParser);

    _fHideTasklist = (S_OK == IUnknown_Exec(_pDefView->_psb, &CGID_ShellDocView, SHDVID_ISEXPLORERBARVISIBLE, 0, NULL, NULL));

    pParser->Destroy();

    return hr;
}

void CDUIView::_InitializeShellFolderPropertyBag()
{
    CLSID clsid;
    if (SUCCEEDED(IUnknown_GetClassID(_pDefView->_pshf, &clsid)))
    {
        WCHAR szSubKey[] = L"DUIBags\\ShellFolders\\{00000000-0000-0000-0000-000000000000}";
        if (SHStringFromGUID(clsid, &szSubKey[lstrlen(szSubKey) + 1 - GUIDSTR_MAX], GUIDSTR_MAX) == GUIDSTR_MAX)
        {
            HKEY hk = SHGetShellKey(SKPATH_SHELLNOROAM, szSubKey, TRUE);
            if (hk)
            {
                SHCreatePropertyBagOnRegKey(hk, NULL, STGM_READWRITE | STGM_SHARE_DENY_NONE, IID_PPV_ARG(IPropertyBag, &_ppbShellFolders));
                RegCloseKey(hk);
            }
        }
    }
}

HRESULT CDUIView::_BuildSoftBarrier(void)
{
    HRESULT hr = S_OK;
    
    // Build the soft barrier if the view wants one
    if (_pDefView->_wvContent.dwFlags & SFVMWVF_BARRICADE)
    {
        // Allow the view to give us a barrier implementation
        Element* peBarricade = NULL;
        _pDefView->CallCB(SFVM_GETWEBVIEWBARRICADE, 0, (LPARAM)&peBarricade);
        if (peBarricade)
        {
            Element *pe = _peBarrier->GetParent();
            hr = pe->Add(peBarricade);
            if (SUCCEEDED(hr))
            {
                _peBarrier->Destroy();
                _peBarrier = peBarricade;
            }
            else
            {
                peBarricade->Destroy();
            }
        }
        else
        {
            // Load the bitmap
            Element *peClient = _peBarrier->FindDescendent(StrToID(L"blockadeclient"));
            if (peClient)
            {
                HBITMAP hBitmap = DUILoadBitmap(_GetThemeHinst(), IDB_BLOCKADE_WATERMARK, LR_CREATEDIBSECTION);

                if (hBitmap)
                {
                    BITMAP bmp;

                    if (GetObject (hBitmap, sizeof(bmp), &bmp))
                    {
                        BYTE dBlendMode = GRAPHIC_TransColor;

                        if (bmp.bmBitsPixel == 32)
                        {
                            dBlendMode = GRAPHIC_AlphaConstPerPix;
                        }

                        Value *pVal = Value::CreateGraphic(hBitmap, dBlendMode, 255);

                        if (pVal)
                        {
                            peClient->SetValue(Element::ContentProp, PI_Local, pVal);
                            pVal->Release();
                        }
                    }
                }
            }

            // Give the view the standard barrier
            hr = SetDescendentString(_peBarrier, L"blockadetitle", IDS_BLOCKADETITLE);
            if (SUCCEEDED(hr))
            {
                hr = SetDescendentString(_peBarrier, L"blockademessage", IDS_BLOCKADEMESSAGE);

                // "clear barrier" button (failure of "clear barrier" button setup is not fatal)
                Element *peButton = _peBarrier->FindDescendent(StrToID(L"blockadeclearbutton"));
                if (peButton)
                {
                    Element *peButtonText = peButton->FindDescendent(StrToID(L"blockadecleartext"));
                    if (peButtonText)
                    {
                        WCHAR wsz[INFOTIPSIZE];
                        if (LoadString(HINST_THISDLL, IDS_TASK_DEFVIEW_VIEWCONTENTS_FOLDER, wsz, ARRAYSIZE(wsz)))
                        {
                            Value *pv = Value::CreateString(wsz, NULL);
                            if (pv)
                            {
                                if (SUCCEEDED(peButtonText->SetValue(Element::ContentProp, PI_Local, pv)))
                                {

                                    peButton->SetAccessible(true);
                                    peButton->SetAccName(wsz);
                                    peButton->SetAccRole(ROLE_SYSTEM_PUSHBUTTON);
                                    if (LoadString(HINST_THISDLL, IDS_LINKWINDOW_DEFAULTACTION, wsz, ARRAYSIZE(wsz)))
                                    {
                                        peButton->SetAccDefAction(wsz);
                                    }
                                }
                                pv->Release();
                            }
                        }
                    }
                }
            }
        }
        // Double buffered items need to be opaque
        _phe->SetBackgroundColor(ARGB(255, 0, 0, 0));
        _phe->DoubleBuffered(true);

        // We couldn't create the barrier? don't use it then...
        if (FAILED(hr))
        {
            _peBarrier->Destroy();
            _peBarrier = NULL;
        }
    }
    return hr;
}


//  Switches to / from the soft barrier and the listview

HRESULT CDUIView::_SwitchToBarrier (BOOL bDisplayBarrier)
{
    if (bDisplayBarrier && !_peBarrier)
        bDisplayBarrier = FALSE;

    Element *peClearButton = _peBarrier ? _peBarrier->FindDescendent(StrToID(L"blockadeclearbutton")) : NULL;
    if (peClearButton)
    {
        // Note:
        //  This is required to prevent the "clear barrier" button from being
        //  accessed via our accessibility interface when the barrier is hidden.
        peClearButton->SetAccessible(bDisplayBarrier == TRUE);
    }

    if (bDisplayBarrier)
    {
        _peClientViewHost->SetVisible(FALSE);
        _peBarrier->SetVisible(TRUE);
    }
    else
    {
        if (_peBarrier)
        {
            _peBarrier->SetVisible(FALSE);
        }

        _peClientViewHost->SetVisible(TRUE);
        _pDefView->_AutoAutoArrange(0);
    }

    _bBarrierShown = bDisplayBarrier;

    return S_OK;
}

//  Controls the display of the soft barrier

HRESULT CDUIView::EnableBarrier (BOOL bDisplayBarrier)
{
    if (_bBarrierShown != bDisplayBarrier)
    {
        DisableAnimations();
        Element::StartDefer ();

        _SwitchToBarrier (bDisplayBarrier);
        PostMessage (_hWnd, WM_REFRESHVIEW, 0, 0);

        Element::EndDefer ();
        EnableAnimations();
    }

    return S_OK;
}

//  Creates / destroys the preview control

HRESULT CDUIView::_ManagePreview (IUnknown * punkPreview)
{
    HRESULT hr = S_OK;

    if ((_pePreview && punkPreview) ||
        (!_pePreview && !punkPreview))
    {
        return S_OK;
    }

    if (punkPreview)
    {
        // Create the DUI element that can host an active x control

        hr = DUIAxHost::Create (&_pePreview);
        if (SUCCEEDED(hr))
        {
            _pePreview->SetLayoutPos (BLP_Top);
            _pePreview->SetID (L"preview");
            _pePreview->SetHeight(_phe->GetHeight());
            _pePreview->SetAccessible(TRUE);

            // The order of the next 4 calls is very important!
            //
            // Initialize atl so the window class is registered.
            // Then call the Add method.  This will cause CreateHWND to be
            // called.  Then site it so when we call AttachControl to 
            // put the preview control in (this requires the hwnd to exist already)
            // it will be parented properly

            AtlAxWinInit();

            hr = _peClientViewHost->Add (_pePreview);

            if (SUCCEEDED(hr))
            {
                _pePreview->SetSite(SAFECAST(_pDefView, IShellView2*));

                hr = _pePreview->AttachControl(punkPreview);

                if (SUCCEEDED(hr))
                {
                    // Double buffered items need to be opaque
                    _phe->SetBackgroundColor(ARGB(255, 0, 0, 0));
                    _phe->DoubleBuffered(true);

                    if (_peListView)
                    {
                        // Since the preview control is displayed, the listview
                        // will be sized to 1 row in height.  Determine the height
                        // of the listview now so we can size the preview control
                        // appropriate plus take care of the sizing in the SetSize
                        // method later
                        
                        DWORD dwItemSpace = ListView_GetItemSpacing (_peListView->GetHWND(), FALSE);
                        _iListViewHeight = (int)HIWORD(dwItemSpace) + GetSystemMetrics (SM_CYHSCROLL) + 4;

                        if (_phe->GetHeight() > _iListViewHeight)
                        {
                            _pePreview->SetHeight(_phe->GetHeight() - _iListViewHeight);
                        }
                        else
                        {
                            _pePreview->SetHeight(0);
                        }
                    }
                }
            }

            if (FAILED(hr))
            {
                _pePreview->Destroy();
                _pePreview = NULL;
            }
        }
        else
        {
            TraceMsg (TF_ERROR, "CDUIView::_ManagePreview: DUIAxHost::Create failed with 0x%x", hr);
        }
    }
    else
    {
        _pePreview->Destroy();
        _pePreview = NULL;
    }

    return S_OK;
}

//  Controls the display of the preview control

HRESULT CDUIView::EnablePreview(IUnknown * punkPreview)
{
    DisableAnimations();
    Element::StartDefer ();

    _ManagePreview (punkPreview);

    Element::EndDefer ();
    EnableAnimations();

    return S_OK;
}

//  Refreshes the view

HRESULT CDUIView::Refresh(void)
{
    Element *pe;
    Parser* pParser = NULL;
    Value* pvSheet = NULL;
    HANDLE arH[2];

    ManageAnimations(FALSE);
    DisableAnimations();
    Element::StartDefer();

    _fLoadedTheme = FALSE; // try to re-load the theme file

    _iTaskPaneWidth = ScaleSizeBasedUponLocalization(_iOriginalTaskPaneWidth);

    // Setting the task pane visibility to the current state will
    // cause it to re-initialize the task pane width appropriately
    SetTaskPaneVisibility(!_bHideTaskPaneAlways);

    // Dynamically build the .ui file for this view

    int iCharCount;
    char *pUIFile = NULL;
    HRESULT hr = _BuildUIFile(&pUIFile, &iCharCount);
    if (FAILED(hr))
    {
        TraceMsg (TF_ERROR, "CDUIView::Refresh: _BuildUIFile failed with 0x%x", hr);
        goto Exit;
    }


    // Parse the UI file

    arH[0] = _GetThemeHinst();
    arH[1] = _hinstScrollbarTheme;

    hr = Parser::Create(pUIFile, iCharCount, arH, UIFileParseError, &pParser);

    if (FAILED(hr))
    {
        TraceMsg (TF_ERROR, "CDUIView::Refresh: Parser::Create failed with 0x%x", hr);
        goto Exit;
    }

    if (pParser->WasParseError())
    {
        TraceMsg (TF_ERROR, "CDUIView::Refresh: WasParseError is TRUE");
        hr = E_FAIL;
        goto Exit;
    }

    // Find the section list element

    pe = _phe->FindDescendent (StrToID(L"sectionlist"));

    if (!pe)
    {
        TraceMsg (TF_ERROR, "CDUIView::Refresh: Failed to find section list element");
        hr = E_FAIL;
        goto Exit;
    }

    // Free all the pointers we have to elements inside of the sectionlist

    ATOMICRELEASE(_pshlItems);
    ATOMICRELEASE(_pvSpecialTaskSheet);
    ATOMICRELEASE(_pvFolderTaskSheet);
    ATOMICRELEASE(_peDetailsInfoArea);
    ATOMICRELEASE(_pvDetailsSheet);

    _peSpecialSection = NULL;
    _peSpecialTaskList = NULL;
    _peFolderSection = NULL;
    _peFolderTaskList = NULL;
    _peDetailsSection = NULL;

    // Destroy the section list

    pe->DestroyAll();

    // Take the style sheets from the new .UI file and put them on the running objects...
    //
    pe = _phe->FindDescendent (StrToID(L"main"));
    if (pe)
    {
        // Query for the main style sheet and set it
        pvSheet = pParser->GetSheet (L"main");
        if (pvSheet)
        {
            pe->SetValue(Element::SheetProp, PI_Local, pvSheet);
            pvSheet->Release();
            pvSheet = NULL;
        }
    }

    pe = _phe->FindDescendent (StrToID(L"scroller"));
    if (pe)
    {
        // Query for the taskpane style sheet and set it
        pvSheet = pParser->GetSheet (L"taskpane");
        if (pvSheet)
        {
            pe->SetValue(Element::SheetProp, PI_Local, pvSheet);
            pvSheet->Release();
            pvSheet = NULL;
        }
    }

    _pvDetailsSheet = pParser->GetSheet(L"NameSpaceItemInfoList");

    // Rebuild the soft barrier if one exists.
    
    _BuildSoftBarrier();
    
    // Build the task list area again

    _BuildTaskList (pParser);

Exit:

    Element::EndDefer();
    EnableAnimations();

    // When turning off the barricade the icons in listview
    // are arranged as if duiview isn't present.  Call _AutoAutoArrange
    // to reposition the icons correctly.

    _pDefView->_AutoAutoArrange(0);

    if (pParser)
    {
        pParser->Destroy();
    }
   
    if (pUIFile)
    {
        LocalFree(pUIFile);
    }

    return hr;
}

//  Resizes the host element when the frame size changes
//
//  rc - size of frame
//

HRESULT CDUIView::SetSize(RECT * rc)
{
    _fHideTasklist = (S_OK == IUnknown_Exec(_pDefView->_psb, &CGID_ShellDocView, SHDVID_ISEXPLORERBARVISIBLE, 0, NULL, NULL));

    SetWindowPos(_hWnd, NULL, rc->left, rc->top,
        rc->right - rc->left, rc->bottom - rc->top, SWP_NOZORDER | SWP_NOACTIVATE);

    return S_OK;
}


HRESULT CDUIView::_OnResize(long lWidth, long lHeight)
{
    DisableAnimations();
    Element::StartDefer();

    _phe->SetWidth(lWidth);
    _phe->SetHeight(lHeight);

    if (_pePreview)
    {
        if (_phe->GetHeight() > _iListViewHeight)
        {
            _pePreview->SetHeight(_phe->GetHeight() - _iListViewHeight);
        }
        else
        {
            _pePreview->SetHeight(0);
        }
    }

    // Hide task pane if task area is greater than 50% of the window size

    // The show/hide state of the tasklist pane can change for:
    //   1) we're told to always hide
    //   2) an explorer bar is showing
    //   3) the window is too narrow.
    //
    if (_peTaskPane)
    {
        if (_bHideTaskPaneAlways || _fHideTasklist || ((lWidth / 2) < _iTaskPaneWidth))
        {
            _peTaskPane->SetWidth(0);
        }
        else if (_peTaskPane->GetWidth() == 0)
        {
            _peTaskPane->SetWidth(_iTaskPaneWidth);
        }
    }

    Element::EndDefer();
    EnableAnimations();

    return S_OK;
}

HRESULT CDUIView::SetTaskPaneVisibility(BOOL bShow)
{
    _bHideTaskPaneAlways = !bShow;
    return _OnResize(_phe->GetWidth(), _phe->GetHeight());
}

// Description:
//  Calculates the bounding rectangle of the infotip hotspot for
//  the specified element.  The bounding rectangle's coordinates
//  are relative to the specified element's root element.
//
void CDUIView::CalculateInfotipRect(Element *pe, RECT *pRect)
{
    ASSERT(pe);
    ASSERT(pRect);

    // Calculate location.
    const POINT ptLocation = { 0, 0 };
    POINT ptLocationRelativeToRoot;
    pe->GetRoot()->MapElementPoint(pe, &ptLocation, &ptLocationRelativeToRoot);
    pRect->left = ptLocationRelativeToRoot.x;
    pRect->top = ptLocationRelativeToRoot.y;

    // Calculate size.
    Value *pvExtent;
    const SIZE *psizeExtent = pe->GetExtent(&pvExtent);
    pRect->right = pRect->left + psizeExtent->cx;
    pRect->bottom = pRect->top + psizeExtent->cy;
    pvExtent->Release();

    // Sanity check.
    ASSERT(pRect->right  > pRect->left);
    ASSERT(pRect->bottom > pRect->top);
}

HRESULT CDUIView::InitializeThumbnail(WNDPROC pfnWndProc)
{
    HRESULT hr = E_FAIL;
    if (!_spThumbnailExtractor2)
    {
        if (SUCCEEDED(CoCreateInstance(CLSID_Thumbnail, NULL, CLSCTX_INPROC_SERVER,
            IID_PPV_ARG(IThumbnail2, &_spThumbnailExtractor2))))
        {
            _hwndMsgThumbExtract = SHCreateWorkerWindowW(pfnWndProc, NULL, 0, WS_POPUP, NULL, this);
            if (_hwndMsgThumbExtract)
            {
                // Set defview as the site for the thumbnail extractor so that
                // it can QueryService defview for IShellTaskScheduler
                IUnknown_SetSite(_spThumbnailExtractor2, SAFECAST(_pDefView, IShellView2*));
                
                // Tell the image extractor to post WM_HTML_BITMAP to _hwndMsgThumbExtract
                // The lParam will be the HBITMAP of the extracted image.
                _spThumbnailExtractor2->Init(_hwndMsgThumbExtract, WM_HTML_BITMAP);
            }
        }
    }
    return (_spThumbnailExtractor2 && _hwndMsgThumbExtract) ? S_OK : E_FAIL;
}

// if pCheck != NULL, check if the current window ptr == pCheck before setting it to p
HRESULT CDUIView::SetThumbnailMsgWindowPtr(void* p, void* pCheck)
{
    if (_hwndMsgThumbExtract)
    {
        if (pCheck)
        {
            void* pCurrent = GetWindowPtr(_hwndMsgThumbExtract, 0);
            if (pCurrent == pCheck)
            {
                SetWindowPtr(_hwndMsgThumbExtract, 0, p);
            }
        }
        else
        {
            SetWindowPtr(_hwndMsgThumbExtract, 0, p);
        }
    }
    return S_OK;
}

HRESULT CDUIView::StartBitmapExtraction(LPCITEMIDLIST pidl)
{
    _dwThumbnailID++;   // We are looking for a new thumbnail

    return _spThumbnailExtractor2 ? _spThumbnailExtractor2->GetBitmapFromIDList(pidl,
            _dwThumbnailID, 150, 100) : E_FAIL;
}

HRESULT CDUIView::InitializeDetailsInfo(WNDPROC pfnWndProc)
{
    if (!_hwndMsgInfoExtract)
    {
        _hwndMsgInfoExtract = SHCreateWorkerWindowW(pfnWndProc, NULL, 0, WS_POPUP, NULL, this);
    }
    return _hwndMsgInfoExtract ? S_OK : E_FAIL;
}

// if pCheck != NULL, check if the current window ptr == pCheck before setting it to p
HRESULT CDUIView::SetDetailsInfoMsgWindowPtr(void* p, void* pCheck)
{
    if (_hwndMsgInfoExtract)
    {
        if (pCheck)
        {
            void* pCurrent = GetWindowPtr(_hwndMsgInfoExtract, 0);
            if (pCurrent == pCheck)
            {
                SetWindowPtr(_hwndMsgInfoExtract, 0, p);
            }
        }
        else
        {
            SetWindowPtr(_hwndMsgInfoExtract, 0, p);
        }
    }
    return S_OK;
}

HRESULT CDUIView::StartInfoExtraction(LPCITEMIDLIST pidl)
{
    _dwDetailsInfoID++;   // We are looking for a new Details section info
    CDetailsSectionInfoTask *pTask;
    HRESULT hr = CDetailsSectionInfoTask_CreateInstance(
        _pDefView->_pshf, pidl, _hwndMsgInfoExtract, WM_DETAILS_INFO, _dwDetailsInfoID, &pTask);
    if (SUCCEEDED(hr))
    {
        if (_pDefView->_pScheduler)
        {
            // Make sure there are no other background DetailsSectionInfo
            // extraction going on...
            _pDefView->_pScheduler->RemoveTasks(TOID_DVBackgroundDetailsSectionInfo,
                    ITSAT_DEFAULT_LPARAM, FALSE);
        }

        hr = _pDefView->_AddTask(pTask, TOID_DVBackgroundDetailsSectionInfo,
                0, TASK_PRIORITY_INFOTIP, ADDTASK_ATEND);
        pTask->Release();
    }
    return hr;
}

VOID CDUIView::ShowDetails (BOOL fShow)
{
    if (_peDetailsSection)
    {
        _peDetailsSection->ShowExpando (fShow);
    }
}

BOOL CDUIView::ShouldShowMiniPreview()
{
    return !_pDefView->_IsImageMode();
}

//  Window procedure for host window

LRESULT CALLBACK CDUIView::_DUIHostWndProc(HWND hWnd, UINT uMessage, WPARAM wParam,
                                          LPARAM lParam)
{
    CDUIView  *pThis = (CDUIView*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch (uMessage)
    {
        case WM_NCCREATE:
            {
                LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
                pThis = (CDUIView*)(lpcs->lpCreateParams);
                SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            }
            break;

        case WM_SIZE:
            if (pThis && pThis->_phe)
            {
                pThis->_OnResize(LOWORD(lParam), HIWORD(lParam));
            }
            break;

        case WM_SETFOCUS:
            // Push focus to HWNDElement (won't set gadget focus to the HWNDElement, but
            // will push focus to the previous gadget with focus)

            if (pThis)
            {

                if (pThis->_phe && pThis->_phe->GetHWND())
                    SetFocus(pThis->_phe->GetHWND());
            }
            break;

        case WM_PALETTECHANGED:
        case WM_QUERYNEWPALETTE:
        case WM_DISPLAYCHANGE:
            if (pThis && pThis->_phe)
            {
                return SendMessageW(pThis->_phe->GetHWND(), uMessage, wParam, lParam);
            }
            break;

        case WM_DESTROY:
            // clear posted messages
            MSG msg;

            while (PeekMessage(&msg, hWnd, WM_NAVIGATETOPIDL, WM_NAVIGATETOPIDL, PM_REMOVE))
            {
                // PeekMessage(hwnd) can return messages posted to CHILDREN of this hwnd...
                // Verify that the message was really for us.

                if (msg.hwnd == hWnd)
                {
                    LPITEMIDLIST pidl = (LPITEMIDLIST)msg.lParam;
                    ILFree(pidl);
                }
            }
            break;


        case WM_NAVIGATETOPIDL:
            {
                LPITEMIDLIST pidl = (LPITEMIDLIST)lParam;
                UINT wFlags = (UINT)wParam;

                pThis->_pDefView->_psb->BrowseObject(pidl, wFlags);

                ILFree(pidl);
            }
            break;

        case WM_REFRESHVIEW:
            {
                pThis->Refresh();       
            }
            break;

        case WM_MOUSEACTIVATE:
            if (pThis->_bBarrierShown)
            {
                return MA_ACTIVATE;
            }
            break;

        default:
            break;
    }

    return DefWindowProc(hWnd, uMessage, wParam, lParam);
}

//  Updates all selection-parameterized UI
//
//  pdo - data object representing the selection

void CDUIView::_Refresh(IShellItemArray *psiItemArray, DWORD dwRefreshFlags)
{
    //DirectUI::DisableAnimations();
    Element::StartDefer();

    IUnknown_Set((IUnknown **)&_pshlItems,psiItemArray);

    if (SFVMWVF_ENUMTASKS & _pDefView->_wvContent.dwFlags)
    {
        if (0 == (REFRESH_SELCHG & dwRefreshFlags))
        {
            //
            // Only refresh if it's not a selection change.
            // If we refresh here, Control Panel's left-pane menus
            // are constantly rebuilt as the folder items selection
            // changes.  That's really ugly.
            // Will this affect other folders?  No, Control Panel
            // is currently the only folder that sets this SFVMWVF_ENUMTASKS
            // flag.  Post WinXP if we decide to keep this webview
            // content in the left pane, we need to re-think how better
            // to handle Control Panel's special needs.
            //
            Refresh();
        }
    }
    else
    {
        if (REFRESH_CONTENT & dwRefreshFlags)
        {
            _BuildSoftBarrier();
        }

        if (REFRESH_TASKS & dwRefreshFlags)
        {
            Element* peIntroText;
            if (FAILED(_GetIntroTextElement(&peIntroText)))
            {
                peIntroText = NULL;
            }
            
            if (_peSpecialSection)
            {
                BOOL bIntroTextAdded = FALSE;

                _peSpecialSection->UpdateTitleUI(_pshlItems);
                _peSpecialTaskList->DestroyAll();

                if (peIntroText)
                {
                    if (SUCCEEDED(_peSpecialTaskList->Add(peIntroText)))
                    {
                        bIntroTextAdded = TRUE;
                        peIntroText = NULL;
                    }
                }
                
                _AddActionTasks(_peSpecialSection, _peSpecialTaskList, _pDefView->_wvTasks.penumSpecialTasks, _pvSpecialTaskSheet, bIntroTextAdded);
            }

            if (_peFolderSection)
            {
                BOOL bIntroTextAdded = FALSE;

                _peFolderSection->UpdateTitleUI(_pshlItems);
                _peFolderTaskList->DestroyAll();

                if (peIntroText)
                {
                    if (SUCCEEDED(_peFolderTaskList->Add(peIntroText)))
                    {
                        bIntroTextAdded = TRUE;
                        peIntroText = NULL;
                    }
                }
                        
                _AddActionTasks(_peFolderSection, _peFolderTaskList, _pDefView->_wvTasks.penumFolderTasks, _pvFolderTaskSheet, bIntroTextAdded);
            }

    if (_peDetailsInfoArea)
    {
        const SIZE *pSize;
        LONG lHeight = 0;
        Value * pv;

        pSize = _peDetailsInfoArea->GetExtent(&pv);

        if (pSize)
        {
            _peDetailsInfoArea->SetHeight(pSize->cy);
            pv->Release();
        }

        _peDetailsInfoArea->DestroyAll();

                _AddDetailsSectionInfo();
            }
        
            if (peIntroText)
            {
                peIntroText->Destroy();
            }
        }
    }
    
    Element::EndDefer();
    //DirectUI::EnableAnimations();
}

void CDUIView::OnSelectionChange(IShellItemArray *psiItemArray)
{
    _Refresh(psiItemArray, REFRESH_ALL | REFRESH_SELCHG);
}


void CDUIView::OnContentsChange(IShellItemArray *psiItemArray)
{
    DWORD dwRefreshFlags = 0;
    if (_pDefView->_wvTasks.dwUpdateFlags & SFVMWVTSDF_CONTENTSCHANGE)
    {
        dwRefreshFlags |= REFRESH_TASKS;
    }
    if (_pDefView->_wvContent.dwFlags & SFVMWVF_CONTENTSCHANGE)
    {
        dwRefreshFlags |= REFRESH_CONTENT;
    }
    if (0 != dwRefreshFlags)
    {
        _Refresh(psiItemArray, dwRefreshFlags);
    }
}


void CDUIView::OnExpandSection(DUISEC eDUISecID, BOOL bExpanded)
{
    if (_ppbShellFolders)
    {
        SHPropertyBag_WriteDWORD(_ppbShellFolders, _GetSectionAttributes(eDUISecID)->_pszExpandedPropName, bExpanded);
    }
}


//
// ISSUE-2001/01/02-BrianAu  Review
//
//     This webview task section code may be reworked soon.
//     I created it to address the webview needs of Control Panel.
//     Following this first checkin, the webview guys (EricFlo
//     and MikeSh) and I will look at consolidating the generic
//     needs of Control Panel with the existing webview code.
//
//
// Add a WebView task section to the list of task sections.
//
HRESULT CDUIView::_AddNonStdTaskSection(const SFVM_WEBVIEW_ENUMTASKSECTION_DATA *pData)
{
    ASSERT(NULL != pData);

    HRESULT hr = E_OUTOFMEMORY;
    if (NULL == _hdsaNonStdTaskSections)
    {
        _hdsaNonStdTaskSections = DSA_Create(sizeof(*pData), 5);
    }
    if (NULL != _hdsaNonStdTaskSections)
    {
        if (-1 != DSA_AppendItem(_hdsaNonStdTaskSections, (void *)pData))
        {
            ASSERT(NULL != pData->pHeader);
            ASSERT(NULL != pData->penumTasks);
            //
            // The list now owns a ref count on the referenced objects.
            //
            pData->pHeader->AddRef();
            pData->penumTasks->AddRef();
            hr = S_OK;
        }
    }
    return THR(hr);
}


void CDUIView::_ClearNonStdTaskSections(void)
{
    if (NULL != _hdsaNonStdTaskSections)
    {
        HDSA hdsa = _hdsaNonStdTaskSections;
        _hdsaNonStdTaskSections = NULL;

        const int cItems = DSA_GetItemCount(hdsa);
        for (int i = 0; i < cItems; i++)
        {
            SFVM_WEBVIEW_ENUMTASKSECTION_DATA *pData = (SFVM_WEBVIEW_ENUMTASKSECTION_DATA *)DSA_GetItemPtr(hdsa, i);
            if (NULL != pData)
            {
                ATOMICRELEASE(pData->pHeader);
                ATOMICRELEASE(pData->penumTasks);
            }
        }
        DSA_Destroy(hdsa);
    }
}

//
// Enumerate the non-standard webview task sections
// from the view callback.
//
// ISSUE-2001/01/03-BrianAu  Review
//
//     This SFVM_ENUMWEBVIEWTASKS mechanism may be replaced
//     with a COM enumerator.  I'll be revisiting this with
//     the webview guys soon.
//
HRESULT CDUIView::_GetNonStdTaskSectionsFromViewCB(void)
{
    SFVM_WEBVIEW_ENUMTASKSECTION_DATA data;

    HRESULT hr = S_OK;
    do
    {
        //
        // Continue requesting task section information from
        // the callback until it sets the SFVMWVF_NOMORETASKS
        // flag in the data.  The record with this flag set
        // should not contain any valid data.
        //
        ZeroMemory(&data, sizeof(data));
        hr = _pDefView->CallCB(SFVM_ENUMWEBVIEWTASKS, 0, (LPARAM)&data);
        if (SUCCEEDED(hr))
        {
            if (0 == (SFVMWVF_NOMORETASKS & data.dwFlags))
            {
                hr = _AddNonStdTaskSection(&data);
                ASSERT(S_FALSE != hr);

                data.pHeader->Release();
                data.penumTasks->Release();
            }
            else
            {
                ASSERT(NULL == data.pHeader);
                ASSERT(NULL == data.penumTasks);
                hr = S_FALSE;
            }
        }
    }
    while(S_OK == hr);

    return THR(hr);
}




//  Loads a bitmap based upon:
//
//  lpBitmapID - contains the bitmap description
//  hInstTheme   - instance handle of theme dll

HBITMAP DUILoadBitmap(HINSTANCE hInstTheme, int idBitmapID, UINT uiLoadFlags)
{
    return (HBITMAP)LoadImage(hInstTheme, MAKEINTRESOURCE(idBitmapID), IMAGE_BITMAP, 0, 0, uiLoadFlags);
}

//  Loads an icon based upon the description.
//    Example:  shell32,-42
//
//  pszIconDesc - contains the icon description
//  bSmall     - small icon vs large icon

HICON DUILoadIcon(LPCWSTR pszIconDesc, BOOL bSmall)
{
    HICON hIcon = NULL;
    TCHAR szFile[MAX_PATH];

    if (SUCCEEDED(StringCchCopy(szFile, ARRAYSIZE(szFile), pszIconDesc))) // the below writes this buffer
    {
        int iIconID = PathParseIconLocation(szFile);

        if (bSmall)
        {
            PrivateExtractIcons(szFile, iIconID, 16, 16, &hIcon, NULL, 1, 0);
        }
        else
        {
            PrivateExtractIcons(szFile, iIconID, 32, 32, &hIcon, NULL, 1, 0);
        }
    }

    return hIcon;
}

BOOL CDUIView::Navigate(BOOL fForward)
{
    if (!_phe)
        return FALSE;

    return _phe->Navigate(fForward);
}

HRESULT CDUIView::InitializeDropTarget (LPITEMIDLIST pidl, HWND hWnd, IDropTarget **pdt)
{
    HRESULT hr = E_FAIL;

    if (_pDT)
    {
        hr = _pDT->Initialize(pidl, hWnd, pdt);
    }

    return hr;
}

////////////////////////////////////////////////////////
// HWNDView class
////////////////////////////////////////////////////////

HWNDView::HWNDView(void)
    : _fFocus(TRUE),
      _fDelayedNavigation(false),
      _puiDelayNavCmd(NULL),
      _psiDelayNavArray(NULL),
      _pDefView(NULL),
      _pDUIView(NULL)
{

}

HWNDView::~HWNDView(void)
{
    ATOMICRELEASE(_puiDelayNavCmd);
    ATOMICRELEASE(_psiDelayNavArray);
    ATOMICRELEASE(_pDefView);
    ATOMICRELEASE(_pDUIView);
}


HRESULT HWNDView::Create(OUT Element** ppElement)
{
    UNREFERENCED_PARAMETER(ppElement);
    DUIAssertForce("Cannot instantiate an HWND host derived Element via parser. Must use substitution.");
    return E_NOTIMPL;
}

HRESULT HWNDView::Create(HWND hParent, bool fDblBuffer, UINT nCreate, CDUIView * pDUIView, CDefView *pDefView, OUT Element** ppElement)
{
    *ppElement = NULL;

    HWNDView* phv = HNewAndZero<HWNDView>();
    if (!phv)
        return E_OUTOFMEMORY;

    HRESULT hr = phv->Initialize(hParent, fDblBuffer, nCreate);
    if (FAILED(hr))
    {
        phv->Destroy();
        return hr;
    }

    phv->SetWrapKeyboardNavigate(false);
    phv->SetAccessible(true);
    phv->SetAccRole(ROLE_SYSTEM_PANE);
    phv->SetAccName(L"WebView Pane");
    phv->SetViewPtrs(pDUIView, pDefView);
    *ppElement = phv;

    return S_OK;
}

void HWNDView::SetViewPtrs (CDUIView * pDUIView, CDefView *pDefView)
{
    pDUIView->AddRef();
    _pDUIView = pDUIView;
    pDefView->AddRef();
    _pDefView = pDefView;
}


#define DELAYED_NAVIGATION_TIMER_ID     1236    // random - can be moved

LRESULT HWNDView::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
    case WM_TIMER:
        if (wParam == DELAYED_NAVIGATION_TIMER_ID)
        {
            KillTimer(hWnd, DELAYED_NAVIGATION_TIMER_ID);

            //
            // We have encountered some rare scenarios where _puiDelayNavCmd
            // can be NULL.  
            //
            if (_puiDelayNavCmd)
            {
                HRESULT hr = _puiDelayNavCmd->Invoke(_psiDelayNavArray, NULL);
                if (FAILED(hr))
                {
                    MessageBeep(0);
                }
            }
            ATOMICRELEASE(_puiDelayNavCmd);
            ATOMICRELEASE(_psiDelayNavArray);

            _fDelayedNavigation = false;
        }
        break;

    case WM_USER_DELAY_NAVIGATION:
        ATOMICRELEASE(_puiDelayNavCmd);
        ATOMICRELEASE(_psiDelayNavArray);

        _puiDelayNavCmd = (IUICommand *) lParam;
        _puiDelayNavCmd->AddRef();

        _psiDelayNavArray = (IShellItemArray *) wParam;
        if (NULL != _psiDelayNavArray)
        {
            _psiDelayNavArray->AddRef();
        }

        _fDelayedNavigation = true;

        ::SetTimer(hWnd, DELAYED_NAVIGATION_TIMER_ID, GetDoubleClickTime(), NULL);
        break;

    case WM_MOUSEACTIVATE:
        if ( _fDelayedNavigation )
        {
            //
            //  KB: gpease  05-APR-2001     Fix for WinBug #338552
            //
            //      This prevents the re-activation of the view window after
            //      the user clicks on a link that launches another application,
            //      window, or CPL Applet.
            //
            return MA_NOACTIVATE;
        }
        break;  // do the default wndproc
    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
        if (_pDefView)
        {
            // Relay relevant messages to CDefView's infotip control so any
            // infotip tools created in the DUI view will appear/function.
            _pDefView->RelayInfotipMessage(hWnd, uMsg, wParam, lParam);
        }
        break;
    }

    return HWNDElement::WndProc(hWnd, uMsg, wParam, lParam);
}

BOOL HWNDView::Navigate(BOOL fForward)
{
    KeyboardNavigateEvent kne;
    kne.uidType = Element::KeyboardNavigate;
    kne.iNavDir = fForward ? NAV_NEXT : NAV_PREV;

    if (_fFocus)   // remove this check after SetGadgetFocus(NULL) is fixed.
    {
        kne.peTarget = GetKeyFocusedElement();
    }
    else
    {
        kne.peTarget = NULL;
    }

    if (kne.peTarget)
    {
        kne.peTarget->FireEvent(&kne);
        _fFocus = !kne.peTarget->GetKeyFocused();
 
        // If this is the last element in the duiview focus cycle clear focus so if
        // no one else grabs focus and we come back to duiview we'll restart at the 
        // first element.
        //
        // 
        //if (!fFocus)
        //{
        //    SetGadgetFocus(NULL);    Doesn't like NULL!!!
        //}
    }
    else
    {
        bool fWrap;
        if(!fForward)
        {
            fWrap = GetWrapKeyboardNavigate();
            SetWrapKeyboardNavigate(true);
        }

        FireEvent(&kne);  
        _fFocus = (GetKeyFocusedElement() != NULL);

        if(!fForward)
        {
            SetWrapKeyboardNavigate(fWrap);
        }
    }

    return _fFocus;
}

UINT HWNDView::MessageCallback(GMSG* pGMsg)
{
    EventMsg * pmsg = static_cast<EventMsg *>(pGMsg);

    switch (GET_EVENT_DEST(pmsg))
    {
    case GMF_DIRECT:
    case GMF_BUBBLED:

        if (pGMsg->nMsg == GM_QUERY)
        {
            GMSG_QUERYDROPTARGET * pTemp = (GMSG_QUERYDROPTARGET *)pGMsg;

            if (pTemp->nCode == GQUERY_DROPTARGET)
            {
                if (SUCCEEDED(_pDUIView->InitializeDropTarget(NULL, NULL, &pTemp->pdt)))
                {
                    pTemp->hgadDrop = pTemp->hgadMsg;
                    return DU_S_COMPLETE;
                }
            }
        }
        break;
    }

    return Element::MessageCallback(pGMsg);
}

void HWNDView::OnEvent(Event* pev)
{
    if (pev->uidType == Button::Click)
    {
        if (pev->peTarget == FindDescendent(StrToID(L"blockadeclearbutton")))
        {
            if (NULL != _pDefView)
            {
                _pDefView->RemoveBarricade();
            }
            pev->fHandled = true;
        }
    }
    HWNDElement::OnEvent(pev);
}

////////////////////////////////////////////////////////
// ClassInfo (must appear after property definitions)

// Define class info with type and base type, set static class pointer
IClassInfo* HWNDView::Class = NULL;
HRESULT HWNDView::Register()
{
    return ClassInfo<HWNDView,HWNDElement>::Register(L"HWNDView", NULL, 0);
}

HRESULT InitializeDUIViewClasses(void)
{
    HRESULT hr;

    hr = DUIAxHost::Register();
    if (FAILED(hr))
        goto Failure;

    hr = CNameSpaceItemInfoList::Register();
    if (FAILED(hr))
        goto Failure;

    hr = CNameSpaceItemInfo::Register();
    if (FAILED(hr))
        goto Failure;

    hr = CMiniPreviewer::Register();
    if (FAILED(hr))
        goto Failure;

    hr = CBitmapElement::Register();
    if (FAILED(hr))
        goto Failure;

    hr = DUIListView::Register();
    if (FAILED(hr))
        goto Failure;

    hr = Expando::Register();
    if (FAILED(hr))
        goto Failure;

    hr = Clipper::Register();
    if (FAILED(hr))
        goto Failure;

    hr = TaskList::Register();
    if (FAILED(hr))
        goto Failure;

    hr = ActionTask::Register();
    if (FAILED(hr))
        goto Failure;

    hr = DestinationTask::Register();
    if (FAILED(hr))
        goto Failure;

    hr = HWNDView::Register();
    if (FAILED(hr))
        goto Failure;

    return S_OK;

Failure:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\dvtasks.cpp ===
#include "shellprv.h"
#include <runtask.h>
#include "defviewp.h"
#include "dvtasks.h"
#include "ids.h"
#include "guids.h"
#include "prop.h"    // for SCID_Comment
#include "infotip.h"

// ACL stuff from public/internal/base/inc/seopaque.h
typedef struct _KNOWN_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG SidStart;
} KNOWN_ACE, *PKNOWN_ACE;

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))


CDefviewEnumTask::CDefviewEnumTask(CDefView *pdsv, DWORD dwId)
   : CRunnableTask(RTF_SUPPORTKILLSUSPEND), _pdsv(pdsv), _dwId(dwId)
{
}

CDefviewEnumTask::~CDefviewEnumTask()
{
    ATOMICRELEASE(_peunk);
    DPA_FreeIDArray(_hdpaEnum); // accepts NULL
    if (_hdpaPending)
        DPA_DeleteAllPtrs(_hdpaPending);    // the pidl's are owned by defview/listview
}

HRESULT CDefviewEnumTask::FillObjectsToDPA(BOOL fInteractive)
{
    DWORD dwTimeout, dwTime = GetTickCount();

    if (_pdsv->_IsDesktop())
        dwTimeout = 30000;          // 30 seconds
    else if (_pdsv->_fs.fFlags & FWF_BESTFITWINDOW)
        dwTimeout = 3000;           // 3 seconds
    else
        dwTimeout = 500;            // 1/2 sec

    // Make sure _GetEnumFlags calculates the correct bits
    _pdsv->_UpdateEnumerationFlags();

    HRESULT hr = _pdsv->_pshf->EnumObjects(fInteractive ? _pdsv->_hwndMain : NULL, _pdsv->_GetEnumFlags(), &_peunk);
    if (S_OK == hr)
    {
        IUnknown_SetSite(_peunk, SAFECAST(_pdsv, IOleCommandTarget *));      // give enum a ref to defview

        _hdpaEnum = DPA_Create(16);
        if (_hdpaEnum)
        {
            // let callback force background enum
            //
            // NOTE: If it is desktop, avoid the Background enumeration. Otherwise, it results in
            // a lot of flickering when ActiveDesktop is ON. Bug #394940. Fixed by: Sankar.
            if ((!_pdsv->_fAllowSearchingWindow && !_pdsv->_IsDesktop()) || S_OK == _pdsv->CallCB(SFVM_BACKGROUNDENUM, 0, 0) || ((GetTickCount() - dwTime) > dwTimeout))
            {
                _fBackground = TRUE;
            }
            else
            {
                LPITEMIDLIST pidl;
                ULONG celt;
                while (S_OK == _peunk->Next(1, &pidl, &celt))
                {
                    ASSERT(1==celt);
                    if (DPA_AppendPtr(_hdpaEnum, pidl) == -1)
                        SHFree(pidl);

                    // Are we taking too long?
                    if (((GetTickCount() - dwTime) > dwTimeout))
                    {
                        _fBackground = TRUE;
                        break;
                    }
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        IUnknown_SetSite(_peunk, NULL);      // Break the site back pointer.
    }

    _hrRet = hr;

    // Let the callback have a chance to "sniff" the items we just enumerated
    _pdsv->CallCB(SFVM_ENUMERATEDITEMS, (WPARAM)DPACount(), (LPARAM)DPAArray());

    return hr;
}

HRESULT CDefviewEnumTask::FillObjectsDPAToDone()
{
    HRESULT hr = S_OK;

    if (_fBackground)
    {
        ASSERT(S_OK == _hrRet);
        ASSERT(_peunk);

        // let defview do it's background thing
        _pdsv->_OnStartBackgroundEnum();

        // put ourself on the background scheduler
        hr = _pdsv->_AddTask(this, TOID_DVBackgroundEnum, 0, TASK_PRIORITY_BKGRND_FILL, ADDTASK_ATEND);
        if (FAILED(hr))
        {
            // we can't do background, pretend we're done
            hr = _pdsv->_OnStopBackgroundEnum();
        }
    }

    if (!_fBackground)
    {
        _pdsv->FillDone();
    }

    return hr;
}

HRESULT CDefviewEnumTask::FillObjectsDoneToView()
{
    if (SUCCEEDED(_hrRet))
    {
        HDPA hdpaView = NULL;
        int cItems = ListView_GetItemCount(_pdsv->_hwndListview);
        if (cItems)
        {
            hdpaView = DPA_Create(16);
            if (hdpaView)
            {
                for (int i = 0; i < cItems; i++)
                {
                    LPCITEMIDLIST pidl = _pdsv->_GetPIDL(i);
                    ASSERT(IsValidPIDL(pidl));
                    if (pidl)
                    {
                        DPA_AppendPtr(hdpaView, (void *)pidl);
                    }
                }
            }
        }

        // We only need to sort _hdpaView and _hdpaEnum if they both exist
        if (hdpaView && _hdpaEnum)
        {
            _SortForFilter(hdpaView);
            if (!_fEnumSorted)
                _SortForFilter(_hdpaEnum);
        }

        _FilterDPAs(_hdpaEnum, hdpaView);

        DPA_Destroy(hdpaView);
    }

    return _hrRet;
}

// 99/05/13 vtan: Only use CDefView::_CompareExact if you know that
// IShellFolder2 is implemented. SHCIDS_ALLFIELDS is IShellFolder2
// specific. Use CDefView::_GetCanonicalCompareFunction() to get the function
// to pass to DPA_Sort() if you don't want to make this determination.

// p1 and p2 are pointers to the lv_item's LPARAM, which is currently the pidl
int CALLBACK CDefviewEnumTask::_CompareExactCanonical(void *p1, void *p2, LPARAM lParam)
{
    CDefView *pdv = (CDefView *)lParam;
    return pdv->_CompareIDsDirection(0 | SHCIDS_ALLFIELDS | SHCIDS_CANONICALONLY, (LPITEMIDLIST)p1, (LPITEMIDLIST)p2);
}


PFNDPACOMPARE CDefviewEnumTask::_GetCanonicalCompareFunction(void)
{
    if (_pdsv->_pshf2)
        return _CompareExactCanonical;
    else
        return &(CDefView::_Compare);

}

LPARAM CDefviewEnumTask::_GetCanonicalCompareBits()
{
    if (_pdsv->_pshf2)
        return 0 | SHCIDS_ALLFIELDS | SHCIDS_CANONICALONLY;
    else
        return 0;
}

void CDefviewEnumTask::_SortForFilter(HDPA hdpa)
{
    DPA_Sort(hdpa, _GetCanonicalCompareFunction(), (LPARAM)_pdsv);
}

//  We refreshed the view.  Take the old pidls and new pidls and compare
//  them, doing a _AddObject for all the new pidls, _RemoveObject
//  for the deleted pidls, and _UpdateObject for the inplace modifies.
void CDefviewEnumTask::_FilterDPAs(HDPA hdpaNew, HDPA hdpaOld)
{
    LPARAM lParamSort = _GetCanonicalCompareBits();

    for (;;)
    {
        LPITEMIDLIST pidlNew, pidlOld;

        int iCompare;
        int cOld = hdpaOld ? DPA_GetPtrCount(hdpaOld) : 0;
        int cNew = hdpaNew ? DPA_GetPtrCount(hdpaNew) : 0;

        if (!cOld && !cNew)
            break;

        if (!cOld)
        {
            // only new ones left.  Insert all of them.
            iCompare = -1;
            pidlNew = (LPITEMIDLIST)DPA_FastGetPtr(hdpaNew, 0);
        }
        else if (!cNew)
        {
            // only old ones left.  remove them all.
            iCompare = 1;
            pidlOld = (LPITEMIDLIST)DPA_FastGetPtr(hdpaOld, 0);
        }
        else
        {
            pidlOld = (LPITEMIDLIST)DPA_FastGetPtr(hdpaOld, 0);
            pidlNew = (LPITEMIDLIST)DPA_FastGetPtr(hdpaNew, 0);

            iCompare = _pdsv->_CompareIDsDirection(lParamSort, pidlNew, pidlOld);
        }

        if (iCompare == 0)
        {
            // they're the same, remove one of each.
            ILFree(pidlNew);
            DPA_DeletePtr(hdpaNew, 0);
            DPA_DeletePtr(hdpaOld, 0);
        }
        else
        {
            // Not identical.  See if it's just a modify.
            if (cOld && cNew && (lParamSort&SHCIDS_ALLFIELDS))
            {
                iCompare = _pdsv->_CompareIDsDirection((lParamSort&~SHCIDS_ALLFIELDS), pidlNew, pidlOld);
            }
            if (iCompare == 0)
            {
                _pdsv->_UpdateObject(pidlOld, pidlNew);
                ILFree(pidlNew);
                DPA_DeletePtr(hdpaNew, 0);
                DPA_DeletePtr(hdpaOld, 0);
            }
            else if (iCompare < 0) // we have a new item!
            {
                _pdsv->_AddObject(pidlNew);  // takes over pidl ownership.
                DPA_DeletePtr(hdpaNew, 0);
            }
            else // there's an old item in the view!
            {
                if (!_DeleteFromPending(pidlOld))
                    _pdsv->_RemoveObject(pidlOld, TRUE);
                DPA_DeletePtr(hdpaOld, 0);
            }
        }
    }
}

BOOL CDefviewEnumTask::_DeleteFromPending(LPCITEMIDLIST pidl)
{
    if (_hdpaPending)
    {
        for (int i = 0; i < DPA_GetPtrCount(_hdpaPending); i++)
        {
            LPCITEMIDLIST pidlPending = (LPCITEMIDLIST) DPA_FastGetPtr(_hdpaPending, i);

            if (S_OK == _pdsv->_CompareIDsFallback(0, pidl, pidlPending))
            {
                //  remove this from the pending list
                DPA_DeletePtr(_hdpaPending, i);    // the pidl is owned by defview/listview
                return TRUE;
            }
        }
    }
    return FALSE;
}

void CDefviewEnumTask::_AddToPending(LPCITEMIDLIST pidl)
{
    if (!_hdpaPending)
        _hdpaPending = DPA_Create(16);

    if (_hdpaPending)
        DPA_AppendPtr(_hdpaPending, (void *)pidl);
}



STDMETHODIMP CDefviewEnumTask::RunInitRT()
{
    return S_OK;
}

STDMETHODIMP CDefviewEnumTask::InternalResumeRT()
{
    ULONG celt;
    LPITEMIDLIST pidl;

    IUnknown_SetSite(_peunk, SAFECAST(_pdsv, IOleCommandTarget *));      // give enum a ref to defview
    while (S_OK == _peunk->Next(1, &pidl, &celt))
    {
        if (DPA_AppendPtr(_hdpaEnum, pidl) == -1)
        {
            SHFree(pidl);
        }

        // we were told to either suspend or quit...
        if (WaitForSingleObject(_hDone, 0) == WAIT_OBJECT_0)
        {
            return (_lState == IRTIR_TASK_SUSPENDED) ? E_PENDING : E_FAIL;
        }
    }

    IUnknown_SetSite(_peunk, NULL);      // Break the site back pointer.

    // Sort on this thread so we do not hang the main thread for as long
    DPA_Sort(_hdpaEnum, _GetCanonicalCompareFunction(), (LPARAM)_pdsv);
    _fEnumSorted = TRUE;

    // notify DefView (async) that we're done
    PostMessage(_pdsv->_hwndView, WM_DSV_BACKGROUNDENUMDONE, 0, (LPARAM)_dwId);
    return S_OK;
}




class CExtendedColumnTask : public CRunnableTask
{
public:
    CExtendedColumnTask(HRESULT *phr, CDefView *pdsv, LPCITEMIDLIST pidl, UINT uId, int fmt, UINT uiColumn);
    STDMETHODIMP RunInitRT(void);

private:
    ~CExtendedColumnTask();

    CDefView *_pdsv;
    LPITEMIDLIST _pidl;
    const int _fmt;
    const UINT _uiCol;
    const UINT _uId;
};


CExtendedColumnTask::CExtendedColumnTask(HRESULT *phr, CDefView *pdsv, LPCITEMIDLIST pidl, UINT uId, int fmt, UINT uiColumn)
    : CRunnableTask(RTF_DEFAULT), _pdsv(pdsv), _fmt(fmt), _uiCol(uiColumn), _uId(uId)
{
    *phr = SHILClone(pidl, &_pidl);
}

CExtendedColumnTask::~CExtendedColumnTask()
{
    ILFree(_pidl);
}

STDMETHODIMP CExtendedColumnTask::RunInitRT(void)
{
    DETAILSINFO di;

    di.pidl = _pidl;
    di.fmt = _fmt;

    if (SUCCEEDED(_pdsv->_GetDetailsHelper(_uiCol, &di)))
    {
        CBackgroundColInfo *pbgci = new CBackgroundColInfo(_pidl, _uId, _uiCol, di.str);
        if (pbgci)
        {
            _pidl = NULL;        // give up ownership of this, ILFree checks for null

            if (!PostMessage(_pdsv->_hwndView, WM_DSV_UPDATECOLDATA, 0, (LPARAM)pbgci))
                delete pbgci;
        }
    }
    return S_OK;
}

HRESULT CExtendedColumnTask_CreateInstance(CDefView *pdsv, LPCITEMIDLIST pidl, UINT uId, int fmt, UINT uiColumn, IRunnableTask **ppTask)
{
    HRESULT hr;
    CExtendedColumnTask *pECTask = new CExtendedColumnTask(&hr, pdsv, pidl, uId, fmt, uiColumn);
    if (pECTask)
    {
        if (SUCCEEDED(hr))
            *ppTask = SAFECAST(pECTask, IRunnableTask*);
        else
            pECTask->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

class CIconOverlayTask : public CRunnableTask
{
public:
    CIconOverlayTask(HRESULT *phr, LPCITEMIDLIST pidl, int iList, CDefView *pdsv);

    STDMETHODIMP RunInitRT(void);

private:
    ~CIconOverlayTask();

    CDefView *_pdsv;
    LPITEMIDLIST _pidl;
    int _iList;
};


CIconOverlayTask::CIconOverlayTask(HRESULT *phr, LPCITEMIDLIST pidl, int iList,  CDefView *pdsv)
    : CRunnableTask(RTF_DEFAULT), _iList(iList), _pdsv(pdsv)
{
    *phr = SHILClone(pidl, &_pidl);
}

CIconOverlayTask::~CIconOverlayTask()
{
    ILFree(_pidl);
}

STDMETHODIMP CIconOverlayTask::RunInitRT()
{
    int iOverlay = 0;

    // get the overlay index for this item.
    _pdsv->_psio->GetOverlayIndex(_pidl, &iOverlay);

    if (iOverlay > 0)
    {
        // now post the result back to the main thread
        PostMessage(_pdsv->_hwndView, WM_DSV_UPDATEOVERLAY, (WPARAM)_iList, (LPARAM)iOverlay);
    }

    return S_OK;
}

HRESULT CIconOverlayTask_CreateInstance(CDefView *pdsv, LPCITEMIDLIST pidl, int iList, IRunnableTask **ppTask)
{
    *ppTask = NULL;

    HRESULT hr;
    CIconOverlayTask * pNewTask = new CIconOverlayTask(&hr, pidl, iList, pdsv);
    if (pNewTask)
    {
        if (SUCCEEDED(hr))
            *ppTask = SAFECAST(pNewTask, IRunnableTask *);
        else
            pNewTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

CStatusBarAndInfoTipTask::CStatusBarAndInfoTipTask(HRESULT *phr, 
                                 LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl,
                                 UINT uMsg, int nMsgParam, CBackgroundInfoTip *pbit,
                                 HWND hwnd, IShellTaskScheduler2* pScheduler)
    : CRunnableTask(RTF_DEFAULT), _uMsg(uMsg), _nMsgParam(nMsgParam), _pbit(pbit), _hwnd(hwnd), _pScheduler(pScheduler)
{
    // If we have a pidl, then the number of objects selected must be 1
    // This assert applies to the status bar text, but not to the InfoTip text
    ASSERT(pbit || !pidl || nMsgParam == 1);
    *phr = pidl ? SHILClone(pidl, &_pidl) : S_OK;

    if (SUCCEEDED(*phr))
    {
        *phr = SHILClone(pidlFolder, &_pidlFolder); 
        if (FAILED(*phr))
        {
            ILFree(_pidl);
        }
    }

    if (_pbit)
        _pbit->AddRef();
}

CStatusBarAndInfoTipTask::~CStatusBarAndInfoTipTask()
{
    ILFree(_pidl);
    ILFree(_pidlFolder);
    ATOMICRELEASE(_pbit);
}

HRESULT CleanTipForSingleLine(LPWSTR pwszTip)
{
    HRESULT hr = E_FAIL;    // NULL string, same as failure
    if (pwszTip)
    {
        // Infotips often contain \t\r\n characters, so
        // map control characters to spaces.  Also collapse
        // consecutive spaces to make us look less badf.
        LPWSTR pwszDst, pwszSrc;

        // Since we are unicode, we don't have to worry about DBCS.
        for (pwszDst = pwszSrc = pwszTip; *pwszSrc; pwszSrc++)
        {
            if ((UINT)*pwszSrc <= (UINT)L' ')
            {
                if (pwszDst == pwszTip || pwszDst[-1] != L' ')
                {
                    *pwszDst++ = L' ';
                }
            }
            else
            {
                *pwszDst++ = *pwszSrc;
            }
        }
        *pwszDst = 0;
        // GetInfoTip can return a Null String too.
        if (*pwszTip)
            hr = S_OK;
        else
            SHFree(pwszTip);
    }
    return hr;
}

STDMETHODIMP CStatusBarAndInfoTipTask::RunInitRT()
{
    LPWSTR pwszTip = NULL;
    HRESULT hr;
    if (_pidl)
    {
        IShellFolder* psf;
        hr = SHBindToObjectEx(NULL, _pidlFolder, NULL, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            IQueryInfo *pqi;
            hr = psf->GetUIObjectOf(_hwnd, 1, (LPCITEMIDLIST*)&_pidl, IID_X_PPV_ARG(IQueryInfo, 0, &pqi));
            IShellFolder2* psf2;
            if (FAILED(hr) && SUCCEEDED(hr = psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
            {
                hr = CreateInfoTipFromItem(psf2, _pidl, TEXT("prop:Comment"), IID_PPV_ARG(IQueryInfo, &pqi));
                psf2->Release();
            }

            if (SUCCEEDED(hr))
            {
                DWORD dwFlags = _pbit ? QITIPF_USESLOWTIP : 0;

                if (_pbit && _pbit->_lvSetInfoTip.pszText[0])
                {
                    ICustomizeInfoTip *pcit;
                    if (SUCCEEDED(pqi->QueryInterface(IID_PPV_ARG(ICustomizeInfoTip, &pcit))))
                    {
                        pcit->SetPrefixText(_pbit->_lvSetInfoTip.pszText);
                        pcit->Release();
                    }
                }

                hr = pqi->GetInfoTip(dwFlags, &pwszTip);

                // Prepare for status bar if we have not requested the InfoTip
                if (SUCCEEDED(hr) && !_pbit)
                    hr = CleanTipForSingleLine(pwszTip);
                pqi->Release();
            }

            psf->Release();
        }

        if (FAILED(hr))
        {
            pwszTip = NULL;
            _uMsg = IDS_FSSTATUSSELECTED;
        }
    }

    if (_pbit)
    {
        // regular info tip case
        CoTaskMemFree(_pbit->_lvSetInfoTip.pszText);
        _pbit->_lvSetInfoTip.pszText = pwszTip;

        _pbit->_fReady = TRUE;
        if (_pScheduler->CountTasks(TOID_DVBackgroundInfoTip) == 1)
            PostMessage(_hwnd, WM_DSV_DELAYINFOTIP, (WPARAM)_pbit, 0);
    }
    else
    {
        // status bar case
        // Now prepare the text and post it to the view which will set the status bar text
        LPWSTR pszStatus = pwszTip;
        if (pwszTip)
        {
            pszStatus = StrDupW(pwszTip);
            SHFree(pwszTip);
        }
        else
        {
            WCHAR szTemp[30];
            pszStatus = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(_uMsg),
                             AddCommas(_nMsgParam, szTemp, ARRAYSIZE(szTemp)));
        }

        if (pszStatus && _pScheduler->CountTasks(TOID_DVBackgroundStatusBar) != 1 ||
            !PostMessage(_hwnd, WM_DSV_DELAYSTATUSBARUPDATE, 0, (LPARAM)pszStatus))
        {
            LocalFree((void *)pszStatus);
        }
    }

    return S_OK;
}

HRESULT CStatusBarAndInfoTipTask_CreateInstance(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidl,
                                                  UINT uMsg, int nMsgParam, CBackgroundInfoTip *pbit, 
                                                  HWND hwnd, IShellTaskScheduler2* pScheduler,
                                                  CStatusBarAndInfoTipTask **ppTask)
{
    *ppTask = NULL;

    HRESULT hr;
    CStatusBarAndInfoTipTask * pNewTask = new CStatusBarAndInfoTipTask(&hr, pidlFolder, pidl, uMsg, nMsgParam, pbit, hwnd, pScheduler);
    if (pNewTask)
    {
        if (SUCCEEDED(hr))
            *ppTask = pNewTask;
        else
            pNewTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CDUIInfotipTask_CreateInstance(CDefView *pDefView, HWND hwndContaining, UINT uToolID, LPCITEMIDLIST pidl, CDUIInfotipTask **ppTask)
{
    HRESULT hr;

    CDUIInfotipTask* pTask = new CDUIInfotipTask();
    if (pTask)
    {
        hr = pTask->Initialize(pDefView, hwndContaining, uToolID, pidl);
        if (SUCCEEDED(hr))
            *ppTask = pTask;
        else
            pTask->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

CDUIInfotipTask::~CDUIInfotipTask()
{
    if (_pDefView)
        _pDefView->Release();

    if (_pidl)
        ILFree(_pidl);
}

HRESULT CDUIInfotipTask::Initialize(CDefView *pDefView, HWND hwndContaining, UINT uToolID, LPCITEMIDLIST pidl)
{
    HRESULT hr;

    if (pDefView && hwndContaining && pidl)
    {
        ASSERT(!_pDefView && !_hwndContaining && !_uToolID && !_pidl);

        _hwndContaining = hwndContaining;   // DUI task's containing hwnd
        _uToolID = uToolID;                 // DUI task's identifier
        hr = SHILClone(pidl, &_pidl);       // DUI task's destination pidl

        if (SUCCEEDED(hr))
        {
            _pDefView = pDefView;
            pDefView->AddRef();
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CDUIInfotipTask::RunInitRT()
{
    HRESULT hr;

    ASSERT(_pDefView);
    ASSERT(_hwndContaining);
    ASSERT(_pidl);

    // Retrieve an IQueryInfo for the _pidl.
    IQueryInfo *pqi;
    hr = SHGetUIObjectFromFullPIDL(_pidl, _hwndContaining, IID_PPV_ARG(IQueryInfo, &pqi));
    if (SUCCEEDED(hr))
    {
        // Retrieve infotip text from IQueryInfo.
        LPWSTR pwszInfotip;
        hr = pqi->GetInfoTip(QITIPF_USESLOWTIP, &pwszInfotip);
        if (SUCCEEDED(hr))
        {
            // Create infotip.
            hr = _pDefView->PostCreateInfotip(_hwndContaining, _uToolID, pwszInfotip, 0);
            CoTaskMemFree(pwszInfotip);
        }

        pqi->Release();
    }

    return hr;
}

STDMETHODIMP CTestCacheTask::RunInitRT()
{
    HRESULT hr = E_FAIL;

    if (!_fForce)
    {
        // make sure the disk cache is open for reading.
        DWORD dwLock = 0;
        hr = _pView->_pDiskCache ? _pView->_pDiskCache->Open(STGM_READ, &dwLock) : E_FAIL;
        if (SUCCEEDED(hr))
        {
            // start the timer, once every two seconds....
            SetTimer(_pView->_hwndView, DV_IDTIMER_DISKCACHE, 2000, NULL);

            // is it in the cache....
            FILETIME ftCacheTimeStamp;
            hr = _pView->_pDiskCache->IsEntryInStore(_szPath, &ftCacheTimeStamp);

            // if it is in the cache, and it is an uptodate image, then fetch from disk....
            // if the timestamps are wrong, then the extract code further down will then try
            // and write its image back to the cache to update it anyway.....
            if ((hr == S_OK) &&
                ((0 == CompareFileTime(&ftCacheTimeStamp, &_ftDateStamp)) || IsNullTime(&_ftDateStamp)))
            {
                DWORD dwPriority = _dwPriority - PRIORITY_DELTA_DISKCACHE;

                if ((!_pView->_fDestroying) &&
                    (S_OK != _pView->_pScheduler->MoveTask(TOID_DiskCacheTask, _dwTaskID, dwPriority, ITSSFLAG_TASK_PLACEINFRONT)))
                {
                    // try it in the background...
                    IRunnableTask *pTask;
                    hr = CDiskCacheTask_Create(_dwTaskID, _pView, dwPriority, _iItem, _pidl, _szPath, _ftDateStamp, _pExtract, _dwFlags, &pTask);
                    if (SUCCEEDED(hr))
                    {
                        // add the task to the scheduler...
                        TraceMsg(TF_DEFVIEW, "CTestCacheTask *ADDING* CDiskCacheTask (path=%s, priority=%x)", _szPath, dwPriority);
                        hr = _pView->_pScheduler->AddTask2(pTask, TOID_DiskCacheTask, _dwTaskID, dwPriority, ITSSFLAG_TASK_PLACEINFRONT);
                        if (SUCCEEDED(hr))
                            hr = S_FALSE;
                        pTask->Release();
                    }
                }
                else
                {
                    hr = S_FALSE;
                }
            }
            else
            {
                TraceMsg(TF_DEFVIEW, "CTestCacheTask *MISS* (hr:%x)", hr);
                hr = E_FAIL;
            }
            _pView->_pDiskCache->ReleaseLock(&dwLock);
        }
        else
        {
           TraceMsg(TF_DEFVIEW, "CTestCacheTask *WARNING* Could not open thumbnail cache");
        }
    }
    if (FAILED(hr))
    {
        // Extract It....
        
        // does it not support Async, or were we told to run it forground ?
        if (!_fAsync || !_fBackground)
        {
            IRunnableTask *pTask;
            if (SUCCEEDED(hr = CExtractImageTask_Create(_dwTaskID, _pView, _pExtract, _szPath,  _pidl, _ftDateStamp, _iItem, _dwFlags, _dwPriority, &pTask)))
            {
                if (!_fBackground)
                {
                    // make sure there is no extract task already underway as we
                    // are not adding this to the queue...
                    _pView->_pScheduler->RemoveTasks(TOID_ExtractImageTask, _dwTaskID, TRUE);
                }
                hr = pTask->Run();

                pTask->Release();
            }
        }
        else
        {
            DWORD dwPriority = _dwPriority - PRIORITY_DELTA_EXTRACT;
            if (S_OK != _pView->_pScheduler->MoveTask(TOID_ExtractImageTask, _dwTaskID, dwPriority, ITSSFLAG_TASK_PLACEINFRONT))
            {
                IRunnableTask *pTask;
                if (SUCCEEDED(hr = CExtractImageTask_Create(_dwTaskID, _pView, _pExtract, _szPath,  _pidl, _ftDateStamp, _iItem, _dwFlags, _dwPriority, &pTask)))
                {
                    // add the task to the scheduler...
                    TraceMsg(TF_DEFVIEW, "CTestCacheTask *ADDING* CExtractImageTask (path=%s, priority=%x)", _szPath, dwPriority);
                    hr = _pView->_pScheduler->AddTask2(pTask, TOID_ExtractImageTask, _dwTaskID, dwPriority, ITSSFLAG_TASK_PLACEINFRONT);
                    pTask->Release();
                }
            }
            
            // signify we want a default icon for now....
            hr = S_FALSE;
        }
    }
    return hr;
}

CTestCacheTask::CTestCacheTask(DWORD dwTaskID, CDefView* pView, IExtractImage *pExtract,
                               LPCWSTR pszPath, FILETIME ftDateStamp,
                               int iItem, DWORD dwFlags, DWORD dwPriority,
                               BOOL fAsync, BOOL fBackground, BOOL fForce) :
    CRunnableTask(RTF_DEFAULT), _iItem(iItem), _dwTaskID(dwTaskID), _dwFlags(dwFlags), _dwPriority(dwPriority),
    _fAsync(fAsync), _fBackground(fBackground), _fForce(fForce), _pExtract(pExtract), _pView(pView), _ftDateStamp(ftDateStamp)
{
    StrCpyNW(_szPath, pszPath, ARRAYSIZE(_szPath));

    _pExtract->AddRef();
}

CTestCacheTask::~CTestCacheTask()
{
    ILFree(_pidl);

    _pExtract->Release();
}

HRESULT CTestCacheTask::Init(LPCITEMIDLIST pidl)
{
    return SHILClone(pidl, &_pidl);
}

HRESULT CTestCacheTask_Create(DWORD dwTaskID, CDefView* pView, IExtractImage *pExtract,
                               LPCWSTR pszPath, FILETIME ftDateStamp, LPCITEMIDLIST pidl,
                               int iItem, DWORD dwFlags, DWORD dwPriority,
                               BOOL fAsync, BOOL fBackground, BOOL fForce,
                               CTestCacheTask **ppTask)
{
    *ppTask = NULL;

    HRESULT hr;
    CTestCacheTask * pNew = new CTestCacheTask(dwTaskID, pView, pExtract,
                               pszPath, ftDateStamp, iItem, dwFlags, dwPriority,
                               fAsync, fBackground, fForce);
    if (pNew)
    {
        hr = pNew->Init(pidl);
        if (SUCCEEDED(hr))
        {
            *ppTask = pNew;
            hr = S_OK;
        }
        else
            pNew->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

class CDiskCacheTask : public CRunnableTask
{
public:
    STDMETHODIMP RunInitRT(void);

    CDiskCacheTask(DWORD dwTaskID, CDefView *pView, DWORD dwPriority, int iItem, LPCWSTR pszPath, FILETIME ftDateStamp, IExtractImage *pExtract, DWORD dwFlags);
    HRESULT Init(LPCITEMIDLIST pidl);

private:
    ~CDiskCacheTask();

    int _iItem;
    LPITEMIDLIST _pidl;
    CDefView* _pView;
    WCHAR _szPath[MAX_PATH];
    FILETIME _ftDateStamp;
    DWORD _dwTaskID;
    DWORD _dwPriority;
    IExtractImage *_pExtract;
    DWORD _dwFlags;
};


CDiskCacheTask::CDiskCacheTask(DWORD dwTaskID, CDefView *pView, DWORD dwPriority, int iItem, LPCWSTR pszPath, FILETIME ftDateStamp, IExtractImage *pExtract, DWORD dwFlags)
    : CRunnableTask(RTF_DEFAULT), _pView(pView), _dwTaskID(dwTaskID), _dwPriority(dwPriority), _iItem(iItem), _ftDateStamp(ftDateStamp),
      _pExtract(pExtract), _dwFlags(dwFlags)
{
    StrCpyNW(_szPath, pszPath, ARRAYSIZE(_szPath));
    _pExtract->AddRef();
}

CDiskCacheTask::~CDiskCacheTask()
{
    ILFree(_pidl);
    _pExtract->Release();
}

HRESULT CDiskCacheTask::Init(LPCITEMIDLIST pidl)
{
    return SHILClone(pidl, &_pidl);
}

STDMETHODIMP CDiskCacheTask::RunInitRT()
{
    DWORD dwLock;

    HRESULT hr = E_FAIL;

    if (_dwFlags & IEIFLAG_CACHE)
    {
        hr = _pView->_pDiskCache->Open(STGM_READ, &dwLock);
        if (SUCCEEDED(hr))
        {
            HBITMAP hBmp;
            hr = _pView->_pDiskCache->GetEntry(_szPath, STGM_READ, &hBmp);
            if (SUCCEEDED(hr))
            {
                TraceMsg(TF_DEFVIEW, "CDiskCacheTask *CACHE* (path=%s, priority=%x)", _szPath, _dwPriority);
                hr = _pView->UpdateImageForItem(_dwTaskID, hBmp, _iItem, _pidl, _szPath, _ftDateStamp, FALSE, _dwPriority);
                if (hr != S_FALSE)
                    DeleteObject(hBmp);
            }
            // set the tick count so we know when we last accessed the disk cache
            SetTimer(_pView->_hwndView, DV_IDTIMER_DISKCACHE, 2000, NULL);
            _pView->_pDiskCache->ReleaseLock(&dwLock);
        }
    }

    if (FAILED(hr)) // We couldn't pull it out of the disk cache, try an extract
    {
        DWORD dwPriority = _dwPriority - PRIORITY_DELTA_EXTRACT;
        if (S_OK != _pView->_pScheduler->MoveTask(TOID_ExtractImageTask, _dwTaskID, dwPriority, ITSSFLAG_TASK_PLACEINFRONT))
        {
            IRunnableTask *pTask;
            if (SUCCEEDED(hr = CExtractImageTask_Create(_dwTaskID, _pView, _pExtract, _szPath,  _pidl, _ftDateStamp, _iItem, _dwFlags, _dwPriority, &pTask)))
            {
                // add the task to the scheduler...
                TraceMsg(TF_DEFVIEW, "CDiskCacheTask *ADDING* CExtractImageTask (path=%s, priority=%x)", _szPath, dwPriority);
                hr = _pView->_pScheduler->AddTask2(pTask, TOID_ExtractImageTask, _dwTaskID, dwPriority, ITSSFLAG_TASK_PLACEINFRONT);
                pTask->Release();
            }
        }
    }
    return hr;
}

HRESULT CDiskCacheTask_Create(DWORD dwTaskID, CDefView *pView, DWORD dwPriority, int iItem, LPCITEMIDLIST pidl,
                              LPCWSTR pszPath, FILETIME ftDateStamp, IExtractImage *pExtract, DWORD dwFlags, IRunnableTask **ppTask)
{
    HRESULT hr;
    CDiskCacheTask *pTask = new CDiskCacheTask(dwTaskID, pView, dwPriority, iItem, pszPath, ftDateStamp, pExtract, dwFlags);
    if (pTask)
    {
        hr = pTask->Init(pidl);
        if (SUCCEEDED(hr))
            hr = pTask->QueryInterface(IID_PPV_ARG(IRunnableTask, ppTask));
        pTask->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}


class CWriteCacheTask : public CRunnableTask
{
public:
    STDMETHOD (RunInitRT)();

    CWriteCacheTask(DWORD dwTaskID, CDefView *pView, LPCWSTR pszPath, FILETIME ftDateStamp, HBITMAP hImage);

private:
    ~CWriteCacheTask();

    LONG _lState;
    CDefView* _pView;
    WCHAR _szPath[MAX_PATH];
    FILETIME _ftDateStamp;
    HBITMAP _hImage;
    DWORD _dwTaskID;
};

CWriteCacheTask::CWriteCacheTask(DWORD dwTaskID, CDefView *pView, LPCWSTR pszPath, FILETIME ftDateStamp, HBITMAP hImage)
    : CRunnableTask(RTF_DEFAULT), _dwTaskID(dwTaskID), _hImage(hImage), _pView(pView), _ftDateStamp(ftDateStamp)
{
    StrCpyNW(_szPath, pszPath, ARRAYSIZE(_szPath));
}

CWriteCacheTask::~CWriteCacheTask()
{
    DeleteObject(_hImage);
}

HRESULT CWriteCacheTask_Create(DWORD dwTaskID, CDefView *pView, LPCWSTR pszPath, FILETIME ftDateStamp,
                               HBITMAP hImage, IRunnableTask **ppTask)
{
    *ppTask = NULL;

    CWriteCacheTask * pNew = new CWriteCacheTask(dwTaskID, pView, pszPath, ftDateStamp, hImage);
    if (!pNew)
        return E_OUTOFMEMORY;

    *ppTask = SAFECAST(pNew, IRunnableTask *);
    return S_OK;
}

STDMETHODIMP CWriteCacheTask::RunInitRT()
{
    DWORD dwLock;

    HRESULT hr = _pView->_pDiskCache->Open(STGM_WRITE, &dwLock);
    if (hr == STG_E_FILENOTFOUND)
    {
        hr = _pView->_pDiskCache->Create(STGM_WRITE, &dwLock);
    }

    if (SUCCEEDED(hr))
    {
        hr = _pView->_pDiskCache->AddEntry(_szPath, IsNullTime(&_ftDateStamp) ? NULL : &_ftDateStamp, STGM_WRITE, _hImage);
        // set the tick count so that when the timer goes off, we can know when we
        // last used it...
        SetTimer(_pView->_hwndView, DV_IDTIMER_DISKCACHE, 2000, NULL);
        hr = _pView->_pDiskCache->ReleaseLock(&dwLock);
    }

    return hr;
}

class CReadAheadTask : public IRunnableTask
{
public:
    CReadAheadTask(CDefView *pView);
    HRESULT Init();

    // IUnknown
    STDMETHOD (QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IRunnableTask
    STDMETHOD (Run)(void);
    STDMETHOD (Kill)(BOOL fWait);
    STDMETHOD (Suspend)();
    STDMETHOD (Resume)();
    STDMETHOD_(ULONG, IsRunning)(void);

private:
    ~CReadAheadTask();
    HRESULT InternalResume();

    LONG _cRef;
    LONG _lState;
    CDefView *_pView;
    HANDLE _hEvent;

    ULONG _ulCntPerPage;
    ULONG _ulCntTotal;
    ULONG _ulCnt;
};

CReadAheadTask::~CReadAheadTask()
{
    if (_hEvent)
        CloseHandle(_hEvent);
}

CReadAheadTask::CReadAheadTask(CDefView *pView) : _cRef(1), _pView(pView)
{
    _ulCntPerPage = pView->_ApproxItemsPerView();
    _ulCntTotal = ListView_GetItemCount(pView->_hwndListview);
#ifndef DEBUG
    // Because we define a small cache in debug we need to only do this
    // in retail.  Otherwise we would not be able to debug readahead.
    _ulCntTotal = min(_ulCntTotal, (ULONG)pView->_iMaxCacheSize);
#endif
    _ulCnt = _ulCntPerPage;
}

HRESULT CReadAheadTask::Init()
{
    _hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    return _hEvent ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CReadAheadTask::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CReadAheadTask, IRunnableTask),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CReadAheadTask::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CReadAheadTask::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CReadAheadTask_Create(CDefView *pView, IRunnableTask **ppTask)
{
    HRESULT hr;
    CReadAheadTask *pTask = new CReadAheadTask(pView);
    if (pTask)
    {
        hr = pTask->Init();
        if (SUCCEEDED(hr))
            hr = pTask->QueryInterface(IID_PPV_ARG(IRunnableTask, ppTask));
        pTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CReadAheadTask::Run()
{
    if (_lState == IRTIR_TASK_RUNNING)
    {
        return S_FALSE;
    }

    if (_lState == IRTIR_TASK_PENDING)
    {
        // it is about to die, so fail
        return E_FAIL;
    }

    LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_RUNNING);
    if (lRes == IRTIR_TASK_PENDING)
    {
        _lState = IRTIR_TASK_FINISHED;
        return S_OK;
    }

    // otherwise, run the task ....
    HRESULT hr = InternalResume();
    if (hr != E_PENDING)
        _lState = IRTIR_TASK_FINISHED;

    return hr;
}

STDMETHODIMP CReadAheadTask::Suspend()
{
    if (_lState != IRTIR_TASK_RUNNING)
    {
        return E_FAIL;
    }

    // suspend ourselves
    LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_SUSPENDED);
    if (lRes == IRTIR_TASK_FINISHED)
    {
        _lState = lRes;
        return S_OK;
    }

    // if it is running, then there is an Event Handle, if we have passed where
    // we are using it, then we are close to finish, so it will ignore the suspend
    // request
    ASSERT(_hEvent);
    SetEvent(_hEvent);

    return S_OK;
}

STDMETHODIMP CReadAheadTask::Resume()
{
    if (_lState != IRTIR_TASK_SUSPENDED)
    {
        return E_FAIL;
    }

    ResetEvent(_hEvent);
    _lState = IRTIR_TASK_RUNNING;

    HRESULT hr = InternalResume();
    if (hr != E_PENDING)
    {
        _lState= IRTIR_TASK_FINISHED;
    }
    return hr;
}

STDMETHODIMP CReadAheadTask::Kill(BOOL fWait)
{
    if (_lState == IRTIR_TASK_RUNNING)
    {
        LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_PENDING);
        if (lRes == IRTIR_TASK_FINISHED)
        {
            _lState = lRes;
        }
        else if (_hEvent)
        {
            // signal the event it is likely to be waiting on
            SetEvent(_hEvent);
        }

        return S_OK;
    }
    else if (_lState == IRTIR_TASK_PENDING || _lState == IRTIR_TASK_FINISHED)
    {
        return S_FALSE;
    }

    return E_FAIL;
}

STDMETHODIMP_(ULONG) CReadAheadTask::IsRunning()
{
    return _lState;
}

HRESULT CReadAheadTask::InternalResume()
{
    HRESULT hr = S_OK;

    // pfortier: this algorithm of determining which guys are off the page or not, seems kind of broken.
    // For example, grouping will screw it up.  Also, the Z-order of the items, is not necessarily
    // the same as the item order, and we're going by item order.
    // Also, _ulCnt is calculated before dui view is present, so the value is off.
    TraceMsg(TF_DEFVIEW, "ReadAhead: Start");

    for (; _ulCnt < _ulCntTotal; ++_ulCnt)
    {
        // See if we need to suspend
        if (WaitForSingleObject(_hEvent, 0) == WAIT_OBJECT_0)
        {
            // why were we signalled ...
            if (_lState == IRTIR_TASK_SUSPENDED)
            {
                hr = E_PENDING;
                break;
            }
            else
            {
                hr = E_FAIL;
                break;
            }
        }

        LV_ITEMW rgItem;
        rgItem.iItem = (int)_ulCnt;
        rgItem.mask = LVIF_IMAGE;
        rgItem.iSubItem = 0;

        TraceMsg(TF_DEFVIEW, "Thumbnail readahead for item %d", _ulCnt);
            
        // This will force the extraction of the image if necessary.  We will extract it at the right
        // priority, by determining if the item is visible during GetDisplayInfo.
        int iItem = ListView_GetItem(_pView->_hwndListview, &rgItem);
    }

    TraceMsg(TF_DEFVIEW, "ReadAhead: Done (hr:%x)", hr);

    return hr;
}

class CFileTypePropertiesTask : public CRunnableTask
{
public:
    CFileTypePropertiesTask(HRESULT *phr, CDefView *pdsv, LPCITEMIDLIST pidl, UINT uMaxPropertiesToShow, UINT uId);
    STDMETHODIMP RunInitRT();
    STDMETHODIMP InternalResumeRT();

private:
    ~CFileTypePropertiesTask();

    CDefView *_pdsv;
    LPITEMIDLIST _pidl;
    UINT _uMaxPropertiesToShow;
    UINT _uId;
};

CFileTypePropertiesTask::CFileTypePropertiesTask(HRESULT *phr, CDefView *pdsv, LPCITEMIDLIST pidl, UINT uMaxPropertiesToShow, UINT uId)
    : CRunnableTask(RTF_SUPPORTKILLSUSPEND), _pdsv(pdsv), _uMaxPropertiesToShow(uMaxPropertiesToShow), _uId(uId)
{
    *phr = SHILClone(pidl, &_pidl);
}

CFileTypePropertiesTask::~CFileTypePropertiesTask()
{
    ILFree(_pidl);
}
STDMETHODIMP CFileTypePropertiesTask::RunInitRT()
{
    return S_OK;
}

STDMETHODIMP CFileTypePropertiesTask::InternalResumeRT(void)
{
    // If Columns are not loaded yet, this means this window is just starting up
    // so we want to give it some time to finish the startup (let it paint and such)
    // before we proceed here because the first call to GetImportantColumns will
    // causes all column handlers to be loaded, a slow process.
    if (!_pdsv->_bLoadedColumns)
    {
        if (WaitForSingleObject(_hDone, 750) == WAIT_OBJECT_0)
        {
            return (_lState == IRTIR_TASK_SUSPENDED) ? E_PENDING : E_FAIL;
        }
    }

    UINT rgColumns[8];  // currently _uMaxPropertiesToShow is 2, this is big enough if that grows
    UINT cColumns = min(_uMaxPropertiesToShow, ARRAYSIZE(rgColumns));

    if (SUCCEEDED(_pdsv->_GetImportantColumns(_pidl, rgColumns, &cColumns)))
    {
        CBackgroundTileInfo *pbgTileInfo = new CBackgroundTileInfo(_pidl, _uId, rgColumns, cColumns);
        if (pbgTileInfo)
        {
            _pidl = NULL;        // give up ownership of this, ILFree checks for null

            if (!PostMessage(_pdsv->_hwndView, WM_DSV_SETIMPORTANTCOLUMNS, 0, (LPARAM)pbgTileInfo))
                delete pbgTileInfo;
        }
    }
        
    return S_OK;
}

HRESULT CFileTypePropertiesTask_CreateInstance(CDefView *pdsv, LPCITEMIDLIST pidl, UINT uMaxPropertiesToShow, UINT uId, IRunnableTask **ppTask)
{
    HRESULT hr;
    CFileTypePropertiesTask *pFTPTask = new CFileTypePropertiesTask(&hr, pdsv, pidl, uMaxPropertiesToShow, uId);
    if (pFTPTask)
    {
        if (SUCCEEDED(hr))
            *ppTask = SAFECAST(pFTPTask, IRunnableTask*);
        else
            pFTPTask->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}



class CExtractImageTask : public IRunnableTask
{
public:
    CExtractImageTask(DWORD dwTaskID, CDefView*pView, IExtractImage *pExtract,
                                 LPCWSTR pszPath, LPCITEMIDLIST pidl,
                                 FILETIME ftNewDateStamp, int iItem, DWORD dwFlags, DWORD dwPriority);
    HRESULT Init(LPCITEMIDLIST pidl);

    // IUnknown
    STDMETHOD (QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IRunnableTask
    STDMETHOD (Run)(void);
    STDMETHOD (Kill)(BOOL fWait);
    STDMETHOD (Suspend)();
    STDMETHOD (Resume)();
    STDMETHOD_(ULONG, IsRunning)(void);

private:
    ~CExtractImageTask();
    HRESULT InternalResume();

    LONG _cRef;
    LONG _lState;
    IExtractImage *_pExtract;
    WCHAR _szPath[MAX_PATH];
    LPITEMIDLIST _pidl;
    CDefView* _pView;
    DWORD _dwMask;
    DWORD _dwFlags;
    int _iItem;
    HBITMAP _hBmp;
    FILETIME _ftDateStamp;
    DWORD _dwTaskID;
    DWORD _dwPriority;
};

CExtractImageTask::CExtractImageTask(DWORD dwTaskID, CDefView*pView, IExtractImage *pExtract, LPCWSTR pszPath,
                                     LPCITEMIDLIST pidl, FILETIME ftNewDateStamp, int iItem, DWORD dwFlags, DWORD dwPriority)
    : _cRef(1), _lState(IRTIR_TASK_NOT_RUNNING), _dwTaskID(dwTaskID), _ftDateStamp(ftNewDateStamp), _dwFlags(dwFlags), _pExtract(pExtract), _pView(pView), _dwPriority(dwPriority)
{
    _pExtract->AddRef();

    StrCpyNW(_szPath, pszPath, ARRAYSIZE(_szPath));
    _iItem = iItem == -1 ? _pView->_FindItem(pidl, NULL, FALSE) : iItem;
    _dwMask = pView->_GetOverlayMask(pidl);
}

CExtractImageTask::~CExtractImageTask()
{
    _pExtract->Release();

    ILFree(_pidl);

    if (_hBmp)
        DeleteObject(_hBmp);
}

STDMETHODIMP CExtractImageTask::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CExtractImageTask, IRunnableTask),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CExtractImageTask::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CExtractImageTask::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CExtractImageTask::Init(LPCITEMIDLIST pidl)
{
    return SHILClone(pidl, &_pidl);
}

HRESULT CExtractImageTask_Create(DWORD dwTaskID, CDefView*pView, IExtractImage *pExtract,
                                 LPCWSTR pszPath, LPCITEMIDLIST pidl,
                                 FILETIME ftNewDateStamp, int iItem, DWORD dwFlags,
                                 DWORD dwPriority, IRunnableTask **ppTask)
{
    HRESULT hr;
    CExtractImageTask *pTask = new CExtractImageTask(dwTaskID, pView, pExtract,
                                 pszPath, pidl, ftNewDateStamp, iItem, dwFlags, dwPriority);
    if (pTask)
    {
        hr = pTask->Init(pidl);
        if (SUCCEEDED(hr))
            hr = pTask->QueryInterface(IID_PPV_ARG(IRunnableTask, ppTask));
        pTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CExtractImageTask::Run(void)
{
    HRESULT hr = E_FAIL;
    if (_lState == IRTIR_TASK_RUNNING)
    {
        hr = S_FALSE;
    }
    else if (_lState == IRTIR_TASK_PENDING)
    {
        hr = E_FAIL;
    }
    else if (_lState == IRTIR_TASK_NOT_RUNNING)
    {
        LONG lRes = InterlockedExchange(&_lState, IRTIR_TASK_RUNNING);
        if (lRes == IRTIR_TASK_PENDING)
        {
            _lState = IRTIR_TASK_FINISHED;
            return S_OK;
        }

        if (_lState == IRTIR_TASK_RUNNING)
        {
            TraceMsg(TF_DEFVIEW, "CExtractImageTask *START* (path=%s, priority=%x)", _szPath, _dwPriority);
            // start the extractor....
            // extractor can return S_FALSE and set _hBmp to NULL.  We will use _hBmp to recognize this situation
            ASSERT(_hBmp == NULL);
            if (FAILED(_pExtract->Extract(&_hBmp)))
            {
                _hBmp = NULL;
            }
        }

        if (_hBmp && _lState == IRTIR_TASK_RUNNING)
        {
            TraceMsg(TF_DEFVIEW, "CExtractImageTask *EXTRACT* (path=%s, priority=%x)", _szPath, _dwPriority);
            hr = InternalResume();
        }

        if (_lState != IRTIR_TASK_SUSPENDED || hr != E_PENDING)
        {
            _lState = IRTIR_TASK_FINISHED;
        }
    }

    return hr;
}

STDMETHODIMP CExtractImageTask::Kill(BOOL fWait)
{
    return E_NOTIMPL;
}

STDMETHODIMP CExtractImageTask::Suspend(void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CExtractImageTask::Resume(void)
{
    return E_NOTIMPL;
}

HRESULT CExtractImageTask::InternalResume()
{
    ASSERT(_hBmp != NULL);

    BOOL bCache = (_dwFlags & IEIFLAG_CACHE);

    if (bCache)
    {
        IShellFolder* psf = NULL;

        if (SUCCEEDED(_pView->GetShellFolder(&psf)))
        {
            TCHAR szPath[MAX_PATH];
            if (SUCCEEDED(DisplayNameOf(psf, _pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath))))
            {            
                // Make sure we don't request to cache an item that is encrypted in a folder that is not
                if (SFGAO_ENCRYPTED == SHGetAttributes(psf, _pidl, SFGAO_ENCRYPTED))
                {
                    bCache = FALSE;
                    
                    LPITEMIDLIST pidlParent = _pView->_GetViewPidl();
                    if (pidlParent)
                    {
                        if (SFGAO_ENCRYPTED == SHGetAttributes(NULL, pidlParent, SFGAO_ENCRYPTED))
                        {
                            bCache = TRUE;
                        }
#ifdef DEBUG                            
                        else
                        {
                            TraceMsg(TF_DEFVIEW, "CExtractImageTask (%s is encrypted in unencrypted folder)", szPath);
                        }
#endif                                
                        ILFree(pidlParent);
                    }
                }

                // Make sure we don't request to cache an item that has differing ACLs applied
                if (bCache)
                {
                    PACL pdacl;
                    PSECURITY_DESCRIPTOR psd;

                    bCache = FALSE;
                    
                    if (ERROR_SUCCESS == GetNamedSecurityInfo(szPath, 
                                                                            SE_FILE_OBJECT,
                                                                            DACL_SECURITY_INFORMATION,
                                                                            NULL,
                                                                            NULL,
                                                                            &pdacl,
                                                                            NULL,
                                                                            &psd))
                    {
                        SECURITY_DESCRIPTOR_CONTROL sdc;
                        DWORD dwRevision;
                        if (GetSecurityDescriptorControl(psd, &sdc, &dwRevision) && !(sdc & SE_DACL_PROTECTED))
                        {
                            if (pdacl)
                            {
                                PKNOWN_ACE pACE = (PKNOWN_ACE) FirstAce(pdacl);
                                if ((pACE->Header.AceType != ACCESS_DENIED_ACE_TYPE) || (pACE->Header.AceFlags & INHERITED_ACE))
                                {
                                    bCache = TRUE;
                                }
#ifdef DEBUG                                
                                else
                                {
                                    TraceMsg(TF_DEFVIEW, "CExtractImageTask (%s has a non-inherited deny acl)", szPath);
                                }
#endif                                
                            }
                            else
                            {
                                bCache = TRUE; // NULL dacl == everyone all access
                            }
                        }
#ifdef DEBUG
                        else
                        {
                            TraceMsg(TF_DEFVIEW,"CExtractImageTask (%s has a protected dacl)", szPath);
                        }                            
#endif
                        LocalFree(psd);
                    }
                }
            }
            psf->Release();
        }
        
        if (!bCache && _pView->_pDiskCache) // If we were asked to cache and are not for security reasons
        {
            DWORD dwLock;            
            if (SUCCEEDED(_pView->_pDiskCache->Open(STGM_WRITE, &dwLock)))
            {
                _pView->_pDiskCache->DeleteEntry(_szPath);
                _pView->_pDiskCache->ReleaseLock(&dwLock);
                SetTimer(_pView->_hwndView, DV_IDTIMER_DISKCACHE, 2000, NULL);  // Keep open for 2 seconds, just in case
            }        
        }
    }

    HRESULT hr = _pView->UpdateImageForItem(_dwTaskID, _hBmp, _iItem, _pidl, _szPath, _ftDateStamp, bCache, _dwPriority);

    // UpdateImageForItem returns S_FALSE if it assumes ownership of bitmap
    if (hr == S_FALSE)
    {
        _hBmp = NULL;
    }

    _lState = IRTIR_TASK_FINISHED;

    return hr;
}

STDMETHODIMP_(ULONG) CExtractImageTask::IsRunning(void)
{
    return _lState;
}

class CCategoryTask : public CRunnableTask
{
public:
    STDMETHOD (RunInitRT)();

    CCategoryTask(CDefView *pView, UINT uId, LPCITEMIDLIST pidl);

private:
    ~CCategoryTask();

    CDefView* _pView;
    LPITEMIDLIST _pidl;
    ICategorizer* _pcat;
    UINT _uId;
};

CCategoryTask::CCategoryTask(CDefView *pView, UINT uId, LPCITEMIDLIST pidl) 
    : CRunnableTask(RTF_DEFAULT), _uId(uId), _pView(pView), _pcat(pView->_pcat)
                                  
{    
    _pcat->AddRef();
    _pidl = ILClone(pidl);
    
    _pView->_GlobeAnimation(TRUE);
    _pView->_ShowSearchUI(TRUE); 
    InterlockedIncrement(&_pView->_cTasksOutstanding);
}

CCategoryTask::~CCategoryTask()
{
    ATOMICRELEASE(_pcat);
    ILFree(_pidl);

    ENTERCRITICAL;
    {    
        _pView->_cTasksCompleted++;
        if (0 == InterlockedDecrement(&_pView->_cTasksOutstanding) && !_pView->_fGroupingMsgInFlight)
        {        
            PostMessage(_pView->_hwndView, WM_DSV_GROUPINGDONE, 0, 0);
            _pView->_fGroupingMsgInFlight = TRUE;
        }
    }
    LEAVECRITICAL;
}

HRESULT CCategoryTask_Create(CDefView *pView, LPCITEMIDLIST pidl, UINT uId, IRunnableTask **ppTask)
{
    *ppTask = NULL;
    
    CCategoryTask * pNew = new CCategoryTask(pView, uId, pidl);
    if (!pNew)
        return E_OUTOFMEMORY;

    *ppTask = SAFECAST(pNew, IRunnableTask *);
    return S_OK;
}

STDMETHODIMP CCategoryTask::RunInitRT()
{
    BOOL fSuccess = FALSE;
    if (_pidl)
    {
        DWORD dwGroup = -1;
        _pcat->GetCategory(1, (LPCITEMIDLIST*)&_pidl, &dwGroup);

        CBackgroundGroupInfo* pbggi = new CBackgroundGroupInfo(_pidl, _uId, dwGroup);
        if (pbggi)
        {
            _pidl = NULL;       // Transferred ownership to BackgroundInfo
            
            ENTERCRITICAL;
            {
                fSuccess = (-1 != DPA_AppendPtr(_pView->_hdpaGroupingListActive, pbggi));
            }
            LEAVECRITICAL;

            if (!fSuccess)
            {
                delete pbggi;
            }
        }
    }

    return S_OK;
}

class CGetCommandStateTask : public CRunnableTask
{
public:
    STDMETHODIMP RunInitRT();
    STDMETHODIMP InternalResumeRT();

    CGetCommandStateTask(CDefView *pView, IUICommand *puiCommand,IShellItemArray *psiItemArray);

private:
    ~CGetCommandStateTask();

    CDefView    *_pView;
    IUICommand  *_puiCommand;
    IShellItemArray *_psiItemArray;
};

HRESULT CGetCommandStateTask_Create(CDefView *pView, IUICommand *puiCommand,IShellItemArray *psiItemArray, IRunnableTask **ppTask)
{
    *ppTask = NULL;
    
    CGetCommandStateTask *pNew = new CGetCommandStateTask(pView, puiCommand, psiItemArray);
    if (!pNew)
        return E_OUTOFMEMORY;

    *ppTask = SAFECAST(pNew, IRunnableTask *);
    return S_OK;
}

CGetCommandStateTask::CGetCommandStateTask(CDefView *pView, IUICommand *puiCommand,IShellItemArray *psiItemArray)
    : CRunnableTask(RTF_SUPPORTKILLSUSPEND)
{
    _pView = pView;
    _puiCommand = puiCommand;
    _puiCommand->AddRef();
    _psiItemArray = psiItemArray;
    if (_psiItemArray)
        _psiItemArray->AddRef();
}
CGetCommandStateTask::~CGetCommandStateTask()
{
    ATOMICRELEASE(_puiCommand);
    ATOMICRELEASE(_psiItemArray);
}

STDMETHODIMP CGetCommandStateTask::RunInitRT()
{
    return S_OK;
}

STDMETHODIMP CGetCommandStateTask::InternalResumeRT()
{
    // Don't want to interfere with the explorer view starting up, so give it a head start.
    // we were told to either suspend or quit...
    if (WaitForSingleObject(_hDone, 1000) == WAIT_OBJECT_0)
    {
        return (_lState == IRTIR_TASK_SUSPENDED) ? E_PENDING : E_FAIL;
    }
    UISTATE uis;
    HRESULT hr = _puiCommand->get_State(_psiItemArray, TRUE, &uis);
    if (SUCCEEDED(hr) && (uis==UIS_ENABLED))
    {
        _pView->_PostSelectionChangedMessage(LVIS_SELECTED);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\dvmenu.cpp ===
#include "shellprv.h"
#include "defview.h"
#include "defviewp.h"
#include "contextmenu.h"
#include "ids.h"
#include "unicpp\deskhtm.h"

class CThumbnailMenu : public IContextMenu3,
                       public CComObjectRoot,
                       public IObjectWithSite
{
public:
    BEGIN_COM_MAP(CThumbnailMenu)
        COM_INTERFACE_ENTRY_IID(IID_IContextMenu3,IContextMenu3)
        COM_INTERFACE_ENTRY_IID(IID_IContextMenu2,IContextMenu2)
        COM_INTERFACE_ENTRY_IID(IID_IContextMenu,IContextMenu)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CThumbnailMenu)
    
    CThumbnailMenu();
    ~CThumbnailMenu();

    HRESULT Init(CDefView* pView, LPCITEMIDLIST * apidl, UINT cidl);
    
    STDMETHOD(QueryContextMenu)(HMENU hmenu,
                                   UINT indexMenu,
                                   UINT idCmdFirst,
                                   UINT idCmdLast,
                                   UINT uFlags);


    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);

    STDMETHOD(GetCommandString)(UINT_PTR idCmd,
                                 UINT uType,
                                 UINT * pwReserved,
                                 LPSTR pszName,
                                 UINT cchMax);
                                 
    STDMETHOD(HandleMenuMsg)(UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam);

    STDMETHOD(HandleMenuMsg2)(UINT uMsg,
                              WPARAM wParam,
                              LPARAM lParam,
                              LRESULT* plRes);
                              
    STDMETHOD(SetSite)(IUnknown *punkSite);
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

protected:
    LPCITEMIDLIST * _apidl;
    UINT _cidl;
    IContextMenu *_pMenu;
    IContextMenu2 *_pMenu2;
    BOOL _fCaptureAvail;
    UINT _wID;
    CDefView* _pView;
};


HRESULT CDefView::_CreateSelectionContextMenu(REFIID riid, void** ppv)
{
    *ppv = NULL;

    HRESULT hr = E_OUTOFMEMORY;
    if (_IsImageMode() && !_IsOwnerData())
    {
        LPCITEMIDLIST* apidl;
        UINT cidl;

        _GetItemObjects(&apidl, SVGIO_SELECTION, &cidl);
        if (apidl)
        {
            // get the context menu interface for the object ....
            CComObject<CThumbnailMenu> * pMenuTmp = new CComObject<CThumbnailMenu>;
            if (pMenuTmp)
            {
                pMenuTmp->AddRef(); // ATL is strange, start with zero ref
                hr = pMenuTmp->Init(this, apidl, cidl);
                if (SUCCEEDED(hr))
                    hr = pMenuTmp->QueryInterface(riid, ppv);
                pMenuTmp->Release();
            }

            LocalFree((HLOCAL)apidl);
        }
    }
    else
    {
        hr = GetItemObject(SVGIO_SELECTION, riid, ppv);
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && !*ppv));
    return hr;
}


LPCITEMIDLIST * DuplicateIDArray(LPCITEMIDLIST * apidl, UINT cidl)
{
    LPCITEMIDLIST * apidlNew = (LPCITEMIDLIST *) LocalAlloc(LPTR, cidl * sizeof(LPCITEMIDLIST));

    if (apidlNew)
    {
        CopyMemory(apidlNew, apidl, cidl * sizeof(LPCITEMIDLIST));
    }

    return apidlNew;
}

CThumbnailMenu::CThumbnailMenu()
{
    _pMenu = NULL;
    _pMenu2 = NULL;
    _pView = NULL;
    _apidl = NULL;
    _cidl = NULL;
    _fCaptureAvail = FALSE;
    _wID = -1;
}

CThumbnailMenu::~CThumbnailMenu()
{
    if (_pMenu)
    {
        _pMenu->Release();
    }

    if (_pMenu2)
    {
        _pMenu2->Release();
    }

    if (_pView)
    {
        _pView->Release();
    }
    
    if (_apidl)
    {
        LocalFree(_apidl);
    }
}

HRESULT CThumbnailMenu::Init(CDefView*pView, LPCITEMIDLIST *apidl, UINT cidl)
{
    if (cidl == 0)
        return E_INVALIDARG;

    // duplicate the array that holds the pointers ..
    _apidl = DuplicateIDArray(apidl, cidl);
    _cidl  = cidl;

    if (_apidl == NULL)
    {
        _cidl = 0;
        return E_OUTOFMEMORY;
    }

    _pView = pView;
    pView->AddRef();
    
    // scan the pidl array and check for Extractors ...
    for (int i = 0; i < (int) _cidl; i++)
    {
        IExtractImage *pExtract;
        HRESULT hr = pView->_pshf->GetUIObjectOf(pView->_hwndView, 1, &_apidl[i], IID_PPV_ARG_NULL(IExtractImage, &pExtract));
        if (SUCCEEDED(hr))
        {
            WCHAR szPath[MAX_PATH];
            DWORD dwFlags = 0;
            SIZE rgThumbSize;
            pView->_GetThumbnailSize(&rgThumbSize);
            
            hr = pExtract->GetLocation(szPath, ARRAYSIZE(szPath), NULL, &rgThumbSize, pView->_dwRecClrDepth, &dwFlags);
            pExtract->Release();
            if (dwFlags & (IEIFLAG_CACHE | IEIFLAG_REFRESH))
            {
                _fCaptureAvail = TRUE;
                break;
            }
        }
        else
        {
            // blank it out so we don't bother trying it if the user choses the command
            _apidl[i] = NULL;
        }
    }

    HRESULT hr = pView->_pshf->GetUIObjectOf(pView->_hwndMain, cidl, apidl, 
        IID_PPV_ARG_NULL(IContextMenu, & _pMenu));
    if (SUCCEEDED(hr))
    {
        _pMenu->QueryInterface(IID_PPV_ARG(IContextMenu2, &_pMenu2));
    }
    
    return hr;
}

STDMETHODIMP CThumbnailMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, 
                                              UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    ASSERT(_pMenu != NULL);
    
    // generate the proper menu 
    HRESULT hr = _pMenu->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
    if (SUCCEEDED(hr) && _fCaptureAvail)
    {
        // find the first separator and insert the menu text after it....
        int cMenuSize = GetMenuItemCount(hmenu);
        for (int iIndex = 0; iIndex < cMenuSize; iIndex ++)
        {
            WCHAR szText[80];
            MENUITEMINFOW mii = {0};
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_TYPE;
            mii.fType = 0;
            mii.dwTypeData = szText;
            mii.cch = ARRAYSIZE(szText);

            GetMenuItemInfo(hmenu, iIndex, TRUE, &mii);
            if (mii.fType & MFT_SEPARATOR)
            {
                szText[0] = 0;
                LoadString(HINST_THISDLL, IDS_CREATETHUMBNAIL, szText, ARRAYSIZE(szText));
                
                mii.fMask = MIIM_ID | MIIM_TYPE;
                mii.fType = MFT_STRING;
                mii.dwTypeData = szText;
                mii.cch = 0;

                // assuming 0 is the first id, therefore the next one = the count they returned
                _wID = HRESULT_CODE(hr);
                mii.wID = idCmdFirst + _wID;

                InsertMenuItem(hmenu, iIndex, TRUE, &mii);

                // we used an extra ID.
                hr++;
                
                break;
            }
        }
    }
    return hr;
}

STDMETHODIMP CThumbnailMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_FAIL;
    
    ASSERT(_pMenu != NULL);

    if (pici->lpVerb != IntToPtr_(LPCSTR, _wID))
    {
        hr = _pMenu->InvokeCommand(pici);
    }
    else
    {
        // capture thumbnails .....
        for (UINT i = 0; i < _cidl; i++)
        {
            if (_apidl[i])
            {
                UINT uiImage;
                _pView->ExtractItem(&uiImage, -1, _apidl[i], TRUE, TRUE, PRIORITY_P5);
            }
        }
    }
    return hr;    
}


STDMETHODIMP CThumbnailMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwRes, LPSTR pszName, UINT cchMax)
{
    if (cchMax)
        pszName[0] = 0;

    if (!IS_INTRESOURCE(idCmd))
    {
        // it is really a text verb ...
        LPSTR pszCommand = (LPSTR) idCmd;
        if (lstrcmpA(pszCommand, "CaptureThumbnail") == 0)
        {
            return S_OK;
        }
    }
    else
    {
        if (idCmd == _wID)
        {
            // it is ours ...
            switch(uType)
            {
            case GCS_VERB:
                StrCpyN((LPWSTR) pszName, TEXT("CaptureThumbnail"), cchMax);
                break;
                
            case GCS_HELPTEXT:
                LoadString(HINST_THISDLL, IDS_CREATETHUMBNAILHELP, (LPWSTR) pszName, cchMax);
                break;
                
            case GCS_VALIDATE:
                break;

            default:
                return E_INVALIDARG;
            }

            return S_OK;
        }
    }
    return _pMenu->GetCommandString(idCmd, uType, pwRes, pszName, cchMax);
}

STDMETHODIMP CThumbnailMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plRes)
{
    HRESULT hr = E_NOTIMPL;

    if (uMsg == WM_MENUCHAR)
    {
        hr = SHForwardContextMenuMsg(_pMenu2, uMsg, wParam, lParam, plRes, FALSE);
    }
    else
    {
        hr = HandleMenuMsg(uMsg, wParam, lParam);

        if (plRes)
            *plRes = 0;
    }

    return hr;
}

STDMETHODIMP CThumbnailMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (_pMenu2 == NULL)
    {
        return E_NOTIMPL;
    }
    
    switch (uMsg)
    {
    case WM_DRAWITEM:
        {
            DRAWITEMSTRUCT * pdi = (DRAWITEMSTRUCT *)lParam;
            
            if (pdi->CtlType == ODT_MENU && pdi->itemID == _wID) 
            {
                return E_NOTIMPL;
            }
        }
        break;
        
    case WM_MEASUREITEM:
        {
            MEASUREITEMSTRUCT *pmi = (MEASUREITEMSTRUCT *)lParam;
            
            if (pmi->CtlType == ODT_MENU && pmi->itemID == _wID) 
            {
                return E_NOTIMPL;
            }
        }
        break;
    }
    return _pMenu2->HandleMenuMsg(uMsg, wParam, lParam);
}

HRESULT CThumbnailMenu::SetSite(IUnknown *punkSite)
{
    IUnknown_SetSite(_pMenu, punkSite);
    return S_OK;
}

HRESULT CThumbnailMenu::GetSite(REFIID riid, void **ppvSite)
{
    return IUnknown_GetSite(_pMenu, riid, ppvSite);
}


// Create defview's POPUP_SFV_BACKGROUND menu
HRESULT CDefView::_Create_BackgrndHMENU(BOOL fViewMenuOnly, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    HMENU hmContext = SHLoadPopupMenu(HINST_THISDLL, POPUP_SFV_BACKGROUND);
    if (hmContext)
    {
        // HACK: we are only initializing the Paste command, so we don't
        // need any attributes
        Def_InitEditCommands(0, hmContext, SFVIDM_FIRST, _pdtgtBack,
            DIEC_BACKGROUNDCONTEXT);

        InitViewMenu(hmContext);

        // Do a whole lot of desktop-only stuff for the actual desktop
        if (_IsDesktop() && IsDesktopBrowser(_psb))
        {
            // We only want LargeIcons on the real desktop
            // so we remove the View menu
            DeleteMenu(hmContext, SFVIDM_MENU_VIEW, MF_BYCOMMAND);

            // No Choose Columns either
            DeleteMenu(hmContext, SFVIDM_VIEW_COLSETTINGS, MF_BYCOMMAND);

            // Only put on ActiveDesktop menu item if it isn't restricted.
            if (SHRestricted(REST_FORCEACTIVEDESKTOPON) ||
                (!PolicyNoActiveDesktop() &&
                 !SHRestricted(REST_CLASSICSHELL) &&
                 !SHRestricted(REST_NOACTIVEDESKTOPCHANGES)))
            {
                HMENU hmenuAD;

                // Load the menu and make the appropriate modifications
                if (hmenuAD = SHLoadMenuPopup(HINST_THISDLL, POPUP_SFV_BACKGROUND_AD))
                {
                    MENUITEMINFO mii = {0};

                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_SUBMENU;

                    if (GetMenuItemInfo(hmContext, SFVIDM_MENU_ARRANGE, FALSE, &mii))
                    {
                        // Get the present settings regarding HTML on desktop
                        SHELLSTATE ss;
                        SHGetSetSettings(&ss, SSF_DESKTOPHTML | SSF_HIDEICONS, FALSE);

                        if (!ss.fHideIcons)
                            CheckMenuItem(hmenuAD, SFVIDM_DESKTOPHTML_ICONS, MF_BYCOMMAND | MF_CHECKED);
                        if (GetDesktopFlags() & COMPONENTS_LOCKED)
                            CheckMenuItem(hmenuAD, SFVIDM_DESKTOPHTML_LOCK, MF_BYCOMMAND | MF_CHECKED);

                        // Hide the desktop cleanup wizard item if we're not allowed to run it
                        // (user is guest or policy forbids it)
                        if (IsOS(OS_ANYSERVER) || IsUserAGuest() || SHRestricted(REST_NODESKTOPCLEANUP))
                        {
                            DeleteMenu(hmenuAD, SFVIDM_DESKTOPHTML_WIZARD, MF_BYCOMMAND);
                        }

                        Shell_MergeMenus(mii.hSubMenu, hmenuAD, (UINT)-1, 0, (UINT)-1, MM_ADDSEPARATOR);
                    }

                    DestroyMenu(hmenuAD);
                }
            }
        }

        if (fViewMenuOnly)
        {
            MENUITEMINFO mii = {0};
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_SUBMENU;

            GetMenuItemInfo(hmContext, SFVIDM_MENU_VIEW, MF_BYCOMMAND, &mii);

            HMENU hmenuView = mii.hSubMenu;
            RemoveMenu(hmContext, SFVIDM_MENU_VIEW, MF_BYCOMMAND);

            DestroyMenu(hmContext);
            hmContext = hmenuView;
        }

        hr = Create_ContextMenuOnHMENU(hmContext, _hwndView, riid, ppv);
    }

    return hr;
}

// Create defview's actual background context menu, an array of:
//   defview's POPUP_SFV_BACKGROUND and
//   the IShellFolder's CreateViewObject(IID_IContextMenu)
//
HRESULT CDefView::_CBackgrndMenu_CreateInstance(REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    IContextMenu* pcmMenu;
    hr = _Create_BackgrndHMENU(FALSE, IID_PPV_ARG(IContextMenu, &pcmMenu));
    if (SUCCEEDED(hr))
    {
        IContextMenu* pcmView;
        if (SUCCEEDED(_pshf->CreateViewObject(_hwndMain, IID_PPV_ARG(IContextMenu, &pcmView))))
        {
            IContextMenu* rgpcm[2] = {pcmMenu, pcmView};
            hr = Create_ContextMenuOnContextMenuArray(rgpcm, ARRAYSIZE(rgpcm), riid, ppv);

            pcmView->Release();
        }
        else
        {
            // Compat - RNAUI fails the CreateViewObject and they rely on simply having the default stuff...
            //
            hr = pcmMenu->QueryInterface(riid, ppv);
        }

        pcmMenu->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\duiview.h ===
#ifndef _DUIVIEW_H_INCLUDED_
#define _DUIVIEW_H_INCLUDED_

#define GADGET_ENABLE_TRANSITIONS
#define GADGET_ENABLE_CONTROLS
#define GADGET_ENABLE_OLE
#include <duser.h>
#include <directui.h>
#include <duserctrl.h>

using namespace DirectUI;

UsingDUIClass(Element);
UsingDUIClass(Button);
UsingDUIClass(RepeatButton);
UsingDUIClass(Thumb);
UsingDUIClass(ScrollBar);
UsingDUIClass(Viewer);
UsingDUIClass(Selector);
UsingDUIClass(HWNDElement);
UsingDUIClass(ScrollViewer);
UsingDUIClass(Edit);


#define WM_HTML_BITMAP  (WM_USER + 100)
#define WM_DETAILS_INFO (WM_USER + 101)

typedef enum {
    DUISEC_UNKNOWN          = 0,
    DUISEC_SPECIALTASKS     = 1,
    DUISEC_FILETASKS        = 2,
    DUISEC_OTHERPLACESTASKS = 3,
    DUISEC_DETAILSTASKS     = 4
} DUISEC;

struct DUISEC_ATTRIBUTES;


// Right now our themeing information is hard-coded due to limitations of DirectUI (only one resource)
// so we'll ask the namespace for a hardcoded name that we can look up in the below table.  Add new
// names/entries to this list as we add theme parts to our shellstyle.dll.
//
typedef struct {
    LPCWSTR pszThemeName;
    int     idSpecialSectionIcon;
    int     idSpecialSectionWatermark;
    int     idListviewWatermark;
} WVTHEME;

#include "defviewp.h"
#include "w32utils.h"

class CDefView;
class Expando;
class HWNDView;
class ActionTask;
class DestinationTask;
class DUIListView;
class DUIAxHost;
class CDetailsSectionInfoTask;
class CDUIDropTarget;

STDAPI CDetailsSectionInfoTask_CreateInstance(IShellFolder *psfContaining,
                                              LPCITEMIDLIST pidlAbsolute,
                                              HWND hwndMsg,
                                              UINT uMsg,
                                              DWORD dwDetailsInfoID,
                                              CDetailsSectionInfoTask **ppTask);

//
// CDUIView class
//

class CDUIView
{

private:
    LONG                _cRef;
    HWND                _hWnd;
    HWNDView *          _phe;
    DUIListView *       _peListView;
    INT                 _iListViewHeight;  // used when the preview control is also displayed
    INT                 _iOriginalTaskPaneWidth;
    INT                 _iTaskPaneWidth;
    DUIAxHost *         _pePreview;
    IUnknown *          _punkPreview;
    CDefView *          _pDefView;
    Element *           _peTaskPane;
    Element *           _peClientViewHost;
    Element *           _peBarrier;
    BOOL                _bBarrierShown;
    BOOL                _bInitialized;
    BSTR                _bstrIntroText;
    IPropertyBag *      _ppbShellFolders;
    CDUIDropTarget *    _pDT;


    Expando* _peSpecialSection;
    Element* _peSpecialTaskList;
    Value*   _pvSpecialTaskSheet;
    Expando* _peFolderSection;
    Element* _peFolderTaskList;
    Value*   _pvFolderTaskSheet;
    Expando* _peDetailsSection;
    Element* _peDetailsInfoArea;
    Value*   _pvDetailsSheet;
    IShellItemArray* _pshlItems;
    HDSA      _hdsaNonStdTaskSections;
    BOOL      _fLoadedTheme;
    HINSTANCE _hinstTheme;
    HANDLE    _hinstScrollbarTheme;
    BOOL      _bAnimationsDisabled;

    HRESULT _hrInit;
    CDUIView(CDefView * pDefView);
    ~CDUIView();

public:
    HRESULT Initialize();
    friend CDUIView* Create_CDUIView(CDefView * pDefView);

    void AddRef(void)
        { InterlockedIncrement(&_cRef); }
    
    void Release(void)
        { ASSERT( 0 != _cRef ); if (0 == InterlockedDecrement(&_cRef)) delete this; }

    void DetachListview();

    HRESULT Initialize(BOOL bDisplayBarrier, IUnknown * punkPreview);
    HRESULT EnableBarrier(BOOL bDisplayBarrier);
    HRESULT EnablePreview(IUnknown * punkPreview);
    HRESULT Refresh(void);
    HRESULT SetSize(RECT *rc);
    HRESULT SetTaskPaneVisibility(BOOL bShow);
    void CalculateInfotipRect(Element *pe, RECT *pRect);
    BOOL Navigate(BOOL fForward);
    HRESULT InitializeDropTarget (LPITEMIDLIST pidl, HWND hWnd, IDropTarget **pdt);

    HRESULT NavigateToDestination(LPCITEMIDLIST pidl);
    HRESULT DelayedNavigation(IShellItemArray *psiItemArray, IUICommand *puiCommand);

    void UnInitializeDirectUI(void);

    void ManageAnimations(BOOL bExiting);
    HINSTANCE _GetThemeHinst(void);

    void OnSelectionChange(IShellItemArray *psiItemArray);
    void OnContentsChange(IShellItemArray *psiItemArray);
    void OnExpandSection(DUISEC eDUISecID, BOOL bExpanded);
    const WVTHEME* GetThemeInfo();

private:

    //
    // Flags passed to _Refresh().
    //
    enum REFRESH_FLAGS { 
        REFRESH_TASKS   = 0x00000001,  // Refresh webview task list content.
        REFRESH_CONTENT = 0x00000002,  // Refresh webview right-pane content.
        REFRESH_SELCHG  = 0x00000004,  // Refreshing for a selection change
        REFRESH_ALL     = 0x00000003
        };

    HRESULT _CreateHostWindow(void);
    HRESULT _LoadUIFileFromResources(HINSTANCE hinst, INT iID, char **pUIFile);
    HRESULT _BuildUIFile(char **pUIFile, int *piCharCount);
    HRESULT _BuildSection(Element* peSectionList, BOOL bMain, IUIElement* pTitle,
                              int idBitmapDesc, int idWatermarkDesc, Value* pvSectionSheet,
                              Parser* pParser, DUISEC eDUISecID, Expando ** ppeExpando, Element ** pTaskList);
    HRESULT _AddActionTasks(Expando* peExpando, Element* peTaskList, IEnumUICommand* penum, Value* pvTaskSheet, BOOL bIntroAdded);
    HRESULT _AddDestinationTasks(Element* peTaskList, IEnumIDList* penum, Value* pvTaskSheet);
    HRESULT _AddDetailsSectionInfo();
    HRESULT _BuildTaskList(Parser* pParser);
    HRESULT _BuildStandardTaskList(Parser *pParser, Element *peSectionList);
    HRESULT _BuildNonStandardTaskList(Parser *pParser, Element *peSectionList, HDSA hdsaSections);
    HRESULT _InitializeElements(char * pUIFile, int iCharCount, BOOL bDisplayBarrier, IUnknown * punkPreview);
    HRESULT _SwitchToBarrier(BOOL bDisplayBarrier);
    HRESULT _ManagePreview(IUnknown * punkPreview);
    HRESULT _GetIntroTextElement(Element** ppeIntroText);
    HRESULT _BuildSoftBarrier(void);
    void    _InitializeShellFolderPropertyBag();
    BOOL    _ShowSectionExpanded(DUISEC eDUISecID);
    const struct DUISEC_ATTRIBUTES *_GetSectionAttributes(DUISEC eDUISecID);
    static LRESULT CALLBACK _DUIHostWndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

    HRESULT _OnResize(long lWidth, long lHeight);
    void _Refresh(IShellItemArray *psiItemArray, DWORD dwRefreshFlags = REFRESH_ALL);

    HRESULT _AddNonStdTaskSection(const SFVM_WEBVIEW_ENUMTASKSECTION_DATA *pData);
    HRESULT _GetNonStdTaskSectionsFromViewCB(void);
    void _ClearNonStdTaskSections(void);

    BOOL _bHideTaskPaneAlways;    // Set to TRUE when "Use Classic View" is used, FALSE otherwise
    BOOL _fHideTasklist;          // Set to TRUE when an explorer bar is visible

public:
    // Thumbnail extraction stuff...
    HRESULT InitializeThumbnail(WNDPROC pfnWndProc);
    HRESULT SetThumbnailMsgWindowPtr(void* p, void* pCheck);
    HRESULT StartBitmapExtraction(LPCITEMIDLIST pidl);

    // Details section info extraction stuff...
    HRESULT InitializeDetailsInfo(WNDPROC pfnWndProc);
    HRESULT SetDetailsInfoMsgWindowPtr(void* p, void* pCheck);
    HRESULT StartInfoExtraction(LPCITEMIDLIST pidl);
    VOID ShowDetails(BOOL fShow);
    BOOL ShouldShowMiniPreview();

    DWORD                   _dwThumbnailID;         // Accessed by CMiniPreviewer (duiinfo.cpp)
    DWORD                   _dwDetailsInfoID;       // Accessed by CMiniPreviewer (duiinfo.cpp)

protected:
    CComPtr<IThumbnail2>    _spThumbnailExtractor2;
    HWND                    _hwndMsgThumbExtract;
    HWND                    _hwndMsgInfoExtract;
    
};

HBITMAP DUILoadBitmap(HINSTANCE hInstTheme, int idBitmapID, UINT uiLoadFlags);
HICON DUILoadIcon(LPCWSTR pszIconDesc, BOOL bSmall);


class HWNDView: public HWNDElement
{
public:
    static HRESULT Create(OUT Element** ppElement); // Required for ClassInfo (always fails)
    static HRESULT Create(HWND hParent, bool fDblBuffer, UINT nCreate, OUT Element** ppElement);
    static HRESULT Create(HWND hParent, bool fDblBuffer, UINT nCreate, CDUIView * pDUIView, CDefView* pDefView, OUT Element** ppElement);

    BOOL Navigate(BOOL fForward);
    virtual LRESULT WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    virtual UINT MessageCallback(GMSG* pGMsg);
    virtual void OnEvent(Event* pEvent);
    void SetViewPtrs (CDUIView * pDUIView, CDefView* pDefView);

    // ClassInfo accessors (static and virtual instance-based)
    static IClassInfo* Class;
    virtual IClassInfo* GetClassInfo() { return Class; }
    static HRESULT Register();

    HWNDView(void);
    virtual ~HWNDView(void);

private:
    BOOL _fFocus;               // hack until SetGadgetFocus(NULL) works.
                                // see HWNDView::Navigate.
    BOOL _fDelayedNavigation;   //  Try to prevent double-clicking. If this is TRUE, then one click
                                //  has already been fired.
    IUICommand *      _puiDelayNavCmd;      //  The UI command object for delayed navigation. Look for WM_USER_DELAY_NAGIVATION.
    IShellItemArray * _psiDelayNavArray;    //  The Shell Item Arraay for delayed navigation. Look for WM_USER_DELAY_NAGIVATION.
    CDefView *        _pDefView;// used to relay infotip messages
    CDUIView*         _pDUIView;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\dvthumbnail.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "defview.h"
#include "defviewp.h"
#include "dvtasks.h"
#include "guids.h"
#include "prop.h"
#include "CommonControls.h"
#include "thumbutil.h"

// Thumbnail support
HRESULT CDefView::_SafeAddImage(BOOL fQuick, IMAGECACHEINFO* prgInfo, UINT* piImageIndex, int iListID)
{
    HRESULT hr = S_FALSE;
    UINT uCacheSize = 0;
    _pImageCache->GetCacheSize(&uCacheSize);
    
    ASSERT(_iMaxCacheSize>0);

    BOOL bSpaceOpen = (uCacheSize < (UINT)_iMaxCacheSize);
    if (!bSpaceOpen)
    {
        BOOL bMakeSpace = TRUE;
        int iListIndex = -1;

        // Check to see if we are visible and need to make space
        if (-1 != iListID)
        {
            iListIndex = _MapIDToIndex(iListID);
            if (-1 == iListIndex) // Someone removed our item
            {
                hr = E_INVALIDARG;
                bMakeSpace = FALSE;
            }
            else if (!ListView_IsItemVisible(_hwndListview, iListIndex))
            {
                hr = S_FALSE;
                bMakeSpace = FALSE;
            }
        }

        if (bMakeSpace)
        {
            // item is visible... try and make a space
            UINT uCacheIndex = 0;
            do
            {
                UINT uImageIndex;
                int iUsage;
                if (FAILED(_pImageCache->GetImageIndexFromCacheIndex(uCacheIndex, &uImageIndex)) ||
                    FAILED(_pImageCache->GetUsage(uImageIndex, (UINT*) &iUsage)))
                {
                    break;
                }

                if (iUsage != ICD_USAGE_SYSTEM) // Magic number for System Image
                {
                    TraceMsg(TF_DEFVIEW, "CDefView::_SafeAddImage -- FreeImage (CI::%d II::%d)", uCacheIndex, uImageIndex);
                    _pImageCache->FreeImage(uImageIndex);
                    _UpdateImage(uImageIndex);
                    bSpaceOpen = TRUE;

                    ASSERT((LONG)(uCacheSize - uCacheIndex) > (LONG)_ApproxItemsPerView()); 
                }

                uCacheIndex++;
            }
            while (!bSpaceOpen);

            // If we repeatedly fail to add images to the list and are still decoding more images this means
            // we will have to re-walk the list view every time we finish decoding another image, only to then
            // throw away the result because we have no where to save it.  This could lead to sluggish response
            // from the UI.  In short, if the following Trace is common then we have a problem that needs to be
            // fixed (which might required considerable rearchitecting).
            if (!bSpaceOpen)
            {
                TraceMsg(TF_WARNING, "CDefView::_SafeAddImage failed to make room in cache!!");
                hr = E_FAIL;
            }
        }
    }
    
    *piImageIndex = I_IMAGECALLBACK;
    if (bSpaceOpen) // There is space in the cache for this image
    {
        hr = _pImageCache->AddImage(prgInfo, piImageIndex);
        TraceMsg(TF_DEFVIEW, "CDefView::_SafeAddImage -- AddImage (HR:0x%08x name:%s,index:%u)", hr, prgInfo->pszName, *piImageIndex);
    }
    
    return hr;
}

COLORREF CDefView::_GetBackColor()
{
    // SendMessage traffic is greatly reduced if we don't ask for the bkcolor
    // every time we need it...
    if (_rgbBackColor == CLR_INVALID)
    {
        _rgbBackColor = ListView_GetBkColor(_hwndListview); 
        if (_rgbBackColor == CLR_NONE)
            _rgbBackColor = GetSysColor(COLOR_WINDOW);
    }

    return _rgbBackColor;
}


HRESULT CDefView::TaskUpdateItem(LPCITEMIDLIST pidl, int iItem, DWORD dwMask, LPCWSTR pszPath,
                                 FILETIME ftDateStamp, int iThumbnail, HBITMAP hBmp, DWORD dwItemID)
{
    // check the size of the bitmap to make sure it is big enough, if it is not, then 
    // we must center it on a background...
    BITMAP rgBitmap;
    HBITMAP hBmpCleanup = NULL;
    HRESULT hr = E_FAIL;

    if (::GetObject((HGDIOBJ)hBmp, sizeof(rgBitmap), &rgBitmap))
    {
        // if the image is the wrong size, or the wrong colour depth, then do the funky stuff on it..
        SIZE sizeThumbnail;
        _GetThumbnailSize(&sizeThumbnail);

        if (rgBitmap.bmWidth != sizeThumbnail.cx || 
            rgBitmap.bmHeight != sizeThumbnail.cy ||
            rgBitmap.bmBitsPixel > _dwRecClrDepth)
        {
            // alloc the colour table just incase....
            BITMAPINFO *pInfo = (BITMAPINFO *)LocalAlloc(LPTR, sizeof(BITMAPINFO) + sizeof(RGBQUAD) * 256);
            if (pInfo)
            {
                // get a DC for this operation...
                HDC hdcMem = CreateCompatibleDC(NULL);
                if (hdcMem)
                {
                    pInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                    if (GetDIBits(hdcMem, hBmp, 0, 0, NULL, pInfo, DIB_RGB_COLORS))
                    {
                        // we have the header, now get the data....
                        void *pBits = LocalAlloc(LPTR, pInfo->bmiHeader.biSizeImage);
                        if (pBits)
                        {
                            if (GetDIBits(hdcMem, hBmp, 0, pInfo->bmiHeader.biHeight, pBits, pInfo, DIB_RGB_COLORS))
                            {
                                RECT rgRect = {0, 0, rgBitmap.bmWidth, rgBitmap.bmHeight};
                                CalculateAspectRatio(&sizeThumbnail, &rgRect);

                                HPALETTE hpal = NULL;
                                HRESULT hrPalette = _dwRecClrDepth <= 8 ? _GetBrowserPalette(&hpal) : S_OK;
                                if (SUCCEEDED(hrPalette))
                                {
                                    if (FactorAspectRatio(pInfo, pBits, &sizeThumbnail, rgRect, _dwRecClrDepth, hpal, FALSE, _GetBackColor(), &hBmpCleanup))
                                    {
                                        // finally success :-) we have the new image we can abandon the old one...
                                        hBmp = hBmpCleanup;
                                        hr = S_OK;
                                    }
                                }
                            }
                            LocalFree(pBits);
                        }
                    }
                    DeleteDC(hdcMem);
                }
                LocalFree(pInfo);
           }
        }
        else
        {
            // the original bitmap is fine
            hr = S_OK;
        }
    }

    UINT iImage;
    if (SUCCEEDED(hr))
    {
        // check if we are going away, if so, then don't use Sendmessage because it will block the
        // destructor of the scheduler...
        if (_fDestroying)
        {
            hr = E_FAIL;
        }
        else
        {
            // copy thumbnail into the cache.
            IMAGECACHEINFO rgInfo = {0};
            rgInfo.cbSize = sizeof(rgInfo);
            rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_FLAGS | ICIFLAG_INDEX | ICIFLAG_LARGE | ICIFLAG_BITMAP;
            rgInfo.pszName = pszPath;
            rgInfo.dwFlags = dwMask;
            rgInfo.iIndex = (int) iThumbnail;
            rgInfo.hBitmapLarge = hBmp;
            rgInfo.ftDateStamp = ftDateStamp;

            if (!IsNullTime(&ftDateStamp))
                rgInfo.dwMask |= ICIFLAG_DATESTAMP;

            if (IS_WINDOW_RTL_MIRRORED(_hwndListview))
                rgInfo.dwMask |= ICIFLAG_MIRROR;

            hr = _SafeAddImage(FALSE, &rgInfo, &iImage, (int) dwItemID);
        }
    }

    if (hBmpCleanup)
    {
        DeleteObject(hBmpCleanup);
    }

#ifdef USEMASK
    DeleteObject(hbmMask);
#endif

    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlToSend = ILClone(pidl);
        if (pidlToSend)
        {
            DSV_UPDATETHUMBNAIL* putn = (DSV_UPDATETHUMBNAIL*)LocalAlloc(LPTR, sizeof(DSV_UPDATETHUMBNAIL));
            if (putn)
            {
                putn->iImage = (hr == S_OK) ? iImage : I_IMAGECALLBACK;
                putn->iItem  = iItem;
                putn->pidl   = pidlToSend;

                // post to the main thread so we don't deadlock
                if (!::PostMessage(_hwndView, WM_DSV_UPDATETHUMBNAIL, 0, (LPARAM)putn))
                    _CleanupUpdateThumbnail(putn);
            }
            else
            {
                ILFree(pidlToSend);
            }
        }
    }

    return hr;
}

HRESULT CDefView::UpdateImageForItem(DWORD dwTaskID, HBITMAP hImage, int iItem, LPCITEMIDLIST pidl,
                                     LPCWSTR pszPath, FILETIME ftDateStamp, BOOL fCache, DWORD dwPriority)
{
    HRESULT hr = S_OK;
    
    TaskUpdateItem(pidl, iItem, _GetOverlayMask(pidl), pszPath, ftDateStamp, 0, hImage, dwTaskID);

    if (_pDiskCache && fCache && (_iWriteTaskCount < MAX_WRITECACHE_TASKS))
    {
        // REVIEW: if pidl is an encrypted file but isn't in an encrytped folder, should avoid writing it's thumbnail?
        // If we don't, other users could otherwise view the thumbnail and thus know the contents of the encrypted file.

        // Add a cache write test
        IRunnableTask *pTask;
        if (SUCCEEDED(CWriteCacheTask_Create(dwTaskID, this, pszPath, ftDateStamp, hImage, &pTask)))
        {
            _AddTask(pTask, TOID_WriteCacheHandler, dwTaskID, dwPriority - PRIORITY_DELTA_WRITE, ADDTASK_ONLYONCE | ADDTASK_ATEND);
            pTask->Release();
            hr = S_FALSE;
        }
    }

    return hr;
}

DWORD CDefView::_GetOverlayMask(LPCITEMIDLIST pidl)
{
    DWORD dwLink = SFGAO_GHOSTED; // SFGAO_LINK | SFGAO_SHARE
    _pshf->GetAttributesOf(1, &pidl, &dwLink);
    return dwLink;
}

void CDefView::_UpdateThumbnail(int iItem, int iImage, LPCITEMIDLIST pidl)
{
    if (!_IsOwnerData())
    {
        if (_hwndListview)
        {
            int iFoundItem = _FindItemHint(pidl, iItem);
            if (-1 != iFoundItem)
            {
                LV_ITEM rgItem = {0};
                rgItem.mask = LVIF_IMAGE;
                rgItem.iItem = iFoundItem;
                rgItem.iImage = iImage;

                // We are about to change the given item for purely internal reasons, we should not treat
                // this change as a "real change".  As such we set a flag so that we ignore the LVN_ITEMCHANGED
                // notification that is generated by this LVM_SETITEM message.  If we don't ingore this
                // next message then we would fire another DISPID_SELECTIONCHANGED every time we finish
                // extracting an image (if the image is selected).
                _fIgnoreItemChanged = TRUE;
                ListView_SetItem(_hwndListview, &rgItem);
                _fIgnoreItemChanged = FALSE;
            }
        }
    }
    else
    {
        RECT rc;
        ListView_GetItemRect(_hwndListview, iItem, &rc, LVIR_BOUNDS);
        InvalidateRect(_hwndListview, &rc, FALSE);
    }
}

void CDefView::_CleanupUpdateThumbnail(DSV_UPDATETHUMBNAIL* putn)
{
    ILFree(putn->pidl);
    LocalFree((HLOCAL)putn);
}

int CDefView::ViewGetIconIndex(LPCITEMIDLIST pidl)
{
    int iIndex = -1;

    if (_psi)
    {
        // check to see if we succeeded and we weren't told to extract the icon
        // ourselves ...

        if ((S_OK == _psi->GetIconOf(pidl, 0, &iIndex)) && _psio)
        {
            int iOverlay;
            if (SUCCEEDED(_psio->GetOverlayIndex(pidl, &iOverlay)))
            {
                iIndex |= iOverlay << 24;
            }
        }
    }

    if (-1 == iIndex)
    {
        iIndex = SHMapPIDLToSystemImageListIndex(_pshf, pidl, NULL);
    }

    return (iIndex >= 0) ? iIndex : II_DOCNOASSOC;
}

HRESULT CDefView::CreateDefaultThumbnail(int iIndex, HBITMAP *phBmpThumbnail, BOOL fCorner)
{
    HRESULT hr = E_FAIL;
    
    // get the background for the default thumbnail.
    HDC hdc = GetDC(NULL);
    HDC hMemDC = CreateCompatibleDC(hdc);
    if (hMemDC)
    {
        SIZE sizeThumbnail;
        _GetThumbnailSize(&sizeThumbnail);

        *phBmpThumbnail = CreateCompatibleBitmap(hdc, sizeThumbnail.cx, sizeThumbnail.cy);
        if (*phBmpThumbnail)
        {
            HGDIOBJ hTmp = SelectObject(hMemDC, *phBmpThumbnail);
            RECT rc = {0, 0, sizeThumbnail.cx, sizeThumbnail.cy};

            SHFillRectClr(hMemDC, &rc, _GetBackColor());
            
            IImageList* piml;
            if (SUCCEEDED(SHGetImageList(SHIL_EXTRALARGE, IID_PPV_ARG(IImageList, &piml))))
            {
                int cxIcon, cyIcon, x, y, dx, dy;
                
                // calculate position and width of icon.
                piml->GetIconSize(&cxIcon, &cyIcon);
                if (cxIcon < sizeThumbnail.cx)
                {
                    if (fCorner)
                    {
                        x = 0;
                    }
                    else
                    {
                        x = (sizeThumbnail.cx - cxIcon) / 2;
                    }
                    dx = cxIcon;
                }
                else
                {
                    // in case icon size is larger than thumbnail size.
                    x = 0;
                    dx = sizeThumbnail.cx;
                }
                
                if (cyIcon < sizeThumbnail.cy)
                {
                    if (fCorner)
                    {
                        y = sizeThumbnail.cy - cyIcon;
                    }
                    else
                    {
                        y = (sizeThumbnail.cy - cyIcon) / 2;
                    }
                    dy = cyIcon;
                }
                else
                {
                    // in case icon size is larger than thumbnail size.
                    y = 0;
                    dy = sizeThumbnail.cy;
                }

                IMAGELISTDRAWPARAMS idp = {sizeof(idp)};
                idp.i = (iIndex & 0x00ffffff);
                idp.hdcDst = hMemDC;
                idp.x = x;
                idp.y = y;
                idp.cx = dx;
                idp.cy = dy;
                idp.rgbBk = CLR_DEFAULT;
                idp.rgbFg = CLR_DEFAULT;
                idp.fStyle = ILD_TRANSPARENT;
                
                piml->Draw(&idp);
                piml->Release();
            }
            
            // get the bitmap produced so that it will be returned.
            *phBmpThumbnail = (HBITMAP) SelectObject(hMemDC, hTmp);
            hr = S_OK;
        }
    }
    
    if (hMemDC)
        DeleteDC(hMemDC);
    ReleaseDC(NULL, hdc);
    return hr;
}

void CDefView::_CacheDefaultThumbnail(LPCITEMIDLIST pidl, int* piIcon)
{
    // create the default one for that file type,
    // the index into the sys image list is used to detect items of the
    // same type, thus we only generate one default thumbnail for each
    // particular icon needed
    UINT iIndex = (UINT) ViewGetIconIndex(pidl);

    if (iIndex == (UINT) I_IMAGECALLBACK)
    {
        iIndex = II_DOCNOASSOC;
    }

    if (_pImageCache)
    {
        // check if the image is already in the image cache.
        IMAGECACHEINFO rgInfo;
        rgInfo.cbSize = sizeof(rgInfo);
        rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_FLAGS | ICIFLAG_INDEX;
        rgInfo.pszName = L"Default";
        rgInfo.dwFlags = _GetOverlayMask(pidl);
        rgInfo.iIndex = (int) iIndex;

        HRESULT hr = _pImageCache->FindImage(&rgInfo, (UINT*)piIcon);
        if (hr != S_OK)
        {
            HBITMAP hBmpThumb = NULL;

            hr = CreateDefaultThumbnail(iIndex, &hBmpThumb, FALSE);
            if (SUCCEEDED(hr))
            {
                // we are creating a new one, so we shouldn't have an index yet ..
                Assert(*piIcon == I_IMAGECALLBACK);

                // copy thumbnail into the imagelist.
                rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_FLAGS | ICIFLAG_INDEX | ICIFLAG_LARGE | ICIFLAG_BITMAP;
                rgInfo.hBitmapLarge = hBmpThumb;
                rgInfo.hMaskLarge = NULL;

                if (IS_WINDOW_RTL_MIRRORED(_hwndListview))
                    rgInfo.dwMask |= ICIFLAG_MIRROR;

                hr = _SafeAddImage(TRUE, &rgInfo, (UINT*)piIcon, -1);

                DeleteObject(hBmpThumb);
            }
            else
            {
                *piIcon = (UINT) I_IMAGECALLBACK;
            }
        }
    }
    else
    {
        *piIcon = II_DOCNOASSOC;
    }
}

//
// Creates an thumbnail overlay based on the system index
//
HRESULT CDefView::_CreateOverlayThumbnail(int iIndex, HBITMAP* phbmOverlay, HBITMAP* phbmMask)
{
    HRESULT hr = CreateDefaultThumbnail(iIndex, phbmOverlay, TRUE);
    if (SUCCEEDED(hr))
    {
        HDC    hdc = GetDC(NULL);
        BITMAP bm;
        
        hr = E_FAIL;
        if (::GetObject(*phbmOverlay, sizeof(bm), &bm) == sizeof(bm)) 
        {
            HDC hdcImg = ::CreateCompatibleDC(hdc);
            HDC hdcMask = ::CreateCompatibleDC(hdc);

            if (hdcImg && hdcMask)
            {
                *phbmMask = ::CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);
                if (*phbmMask)
                {
                    HBITMAP  hbmpOldImg = (HBITMAP) ::SelectObject(hdcImg,  *phbmOverlay);
                    HBITMAP  hbmpOldMsk = (HBITMAP) ::SelectObject(hdcMask, *phbmMask);
                    COLORREF clrTransparent = ::GetPixel(hdcImg, 0, 0);
                    
                    ::SetBkColor(hdcImg, clrTransparent);
                    ::BitBlt(hdcMask, 0, 0, bm.bmWidth, bm.bmHeight, hdcImg, 0, 0, SRCCOPY);

                    ::SelectObject(hdcImg, hbmpOldImg);
                    ::SelectObject(hdcMask, hbmpOldMsk);

                    hr = S_OK;
                }
            }
                    
            if (hdcImg)
            {
                DeleteDC(hdcImg);
            }
            if (hdcMask)
            {
                DeleteDC(hdcMask);
            }
        }

        ReleaseDC(NULL, hdc);
    }

    return hr;
}

void CDefView::_DoThumbnailReadAhead()
{
    // Start up the ReadAheadHandler if:
    //  1) view requires thumbnails
    //  2) we have items in view (handle delayed enum)
    //  3) we haven't kicked it off already
    //  4) If we're not ownerdata
    if (_IsImageMode())
    {
        UINT cItems = ListView_GetItemCount(_hwndListview);
        if (cItems && !_fReadAhead && !_IsOwnerData())
        {
            // Start the read-ahead task
            _fReadAhead = TRUE;
            
            IRunnableTask *pTask;
            if (SUCCEEDED(CReadAheadTask_Create(this, &pTask)))
            {
                // add with a low prority, but higher than HTML extraction...
                _AddTask(pTask, TOID_ReadAheadHandler, 0, PRIORITY_READAHEAD, ADDTASK_ATEND);
                pTask->Release();
            }
        }
    }
}

HRESULT CDefView::ExtractItem(UINT *puIndex, int iItem, LPCITEMIDLIST pidl, BOOL fBackground, BOOL fForce, DWORD dwMaxPriority)
{   
    if (!_pImageCache || _fDestroying)
        return S_FALSE;

    if (iItem == -1 && !pidl)
    {
        return S_FALSE;   // failure....
    }

    if (iItem == -1)
    {
        // LISTVIEW
        iItem = _FindItem(pidl, NULL, FALSE);
        if (iItem == -1)
        {
            return S_FALSE;
        }
    }

    IExtractImage *pExtract;
    HRESULT hr = _pshf->GetUIObjectOf(_hwndMain, 1, &pidl, IID_X_PPV_ARG(IExtractImage, 0, &pExtract));
    if (FAILED(hr))
    {
        hr = _GetDefaultTypeExtractor(pidl, &pExtract);
    }

    if (SUCCEEDED(hr))
    {
        FILETIME ftImageTimeStamp = {0,0};

        // do they support date stamps....
        IExtractImage2 *pei2;
        if (SUCCEEDED(pExtract->QueryInterface(IID_PPV_ARG(IExtractImage2, &pei2))))
        {
            pei2->GetDateStamp(&ftImageTimeStamp);
            pei2->Release();
        }

        if (IsNullTime(&ftImageTimeStamp) && _pshf2)
        {
            // fall back to this (most common case)
            GetDateProperty(_pshf2, pidl, &SCID_WRITETIME, &ftImageTimeStamp);
        }

        // always extract at 24 bit incase we have to cache it ...
        WCHAR szPath[MAX_PATH];
        DWORD dwFlags = IEIFLAG_ASYNC | IEIFLAG_ORIGSIZE;
        if (fForce)
        {
            dwFlags |= IEIFLAG_QUALITY;     // Force means give me the high-quality thumbnail, if possible
        }

        // Let this run at a slightly higher priority so that we can get the eventual
        // cache read or extract task scheduled sooner
        DWORD dwPriority = PRIORITY_EXTRACT_NORMAL;
        SIZE sizeThumbnail;
        _GetThumbnailSize(&sizeThumbnail);
        hr = pExtract->GetLocation(szPath, ARRAYSIZE(szPath), &dwPriority, &sizeThumbnail, 24, &dwFlags);
        if (dwPriority == PRIORITY_EXTRACT_NORMAL)
        {
            dwPriority = dwMaxPriority;
        }
        else if (dwPriority > PRIORITY_EXTRACT_NORMAL)
        {
            dwPriority = dwMaxPriority + PRIORITY_DELTA_FAST;
        }
        else
        {
            dwPriority = dwMaxPriority - PRIORITY_DELTA_SLOW;
        }

        if (SUCCEEDED(hr) || (hr == E_PENDING))
        {
            BOOL fAsync = (hr == E_PENDING);
            hr = E_FAIL;

            // use the name of the item in defview as the key for the caches
            DisplayNameOf(_pshf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath));

            if (!fForce)
            {
                // check if the image is already in the in memory cache
                IMAGECACHEINFO rgInfo = {0};
                rgInfo.cbSize = sizeof(rgInfo);
                rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_FLAGS;
                rgInfo.pszName = szPath;
                rgInfo.dwFlags = _GetOverlayMask(pidl);
                rgInfo.ftDateStamp = ftImageTimeStamp;

                if (!IsNullTime(&ftImageTimeStamp))
                    rgInfo.dwMask |= ICIFLAG_DATESTAMP;
                
                hr = _pImageCache->FindImage(&rgInfo, puIndex);
            }

            if (hr != S_OK)
            {
                DWORD dwTaskID = _MapIndexPIDLToID(iItem, pidl);
                if (dwTaskID != (DWORD) -1)
                {
                    // create a task for a disk cache
                    CTestCacheTask *pTask;
                    hr = CTestCacheTask_Create(dwTaskID, this, pExtract, szPath, ftImageTimeStamp, pidl, 
                                               iItem, dwFlags, dwPriority, fAsync, fBackground, fForce, &pTask);
                    if (SUCCEEDED(hr))
                    {
                        // does it not support Async, or were we told to run it forground ?
                        if (!fAsync || !fBackground)
                        {
                            TraceMsg(TF_WARNING, "CDefView::ExtractItem is going to extract on the foreground thread (%s)", szPath);
                            if (!fBackground)
                            {
                                // make sure there is no extract task already underway as we
                                // are not adding this to the queue...
                                _pScheduler->RemoveTasks(TOID_ExtractImageTask, dwTaskID, TRUE);
                            }

                            // NOTE: We must call RunInitRT, not Run, for CTestCacheTask.  The reason is that RunInitRT
                            // will return S_FALSE if it needs the default icon to be displayed but we would loose that
                            // extra data if we call Run directly.

                            hr = pTask->RunInitRT();

                            // If RunInitRT returns S_OK then the correct image index was generated, however we don't know what
                            // that index is at this time.  We will return S_OK and I_IMAGECALLBACK in this case because we
                            // know that a WM_UPDATEITEMIMAGE message should have been posted
                        }
                        else
                        {
                            // add the task to the scheduler...
                            TraceMsg(TF_DEFVIEW, "ExtractItem *ADDING* CCheckCacheTask (szPath=%s priority=%x index=%d ID=%d)", szPath, dwPriority, iItem, dwTaskID);
                            hr = _AddTask((IRunnableTask *)pTask, TOID_CheckCacheTask, dwTaskID, dwPriority, ADDTASK_ONLYONCE);

                            // signify we want a default icon for now....
                            hr = S_FALSE;
                        }
                        pTask->Release();
                    }
                }
            }
        }
        pExtract->Release();
    }

    return hr;
}

DWORD GetCurrentColorFlags(UINT * puBytesPerPixel)
{
    DWORD dwFlags = 0;
    UINT uBytesPerPix = 1;
    int res = (int)GetCurColorRes();
    switch (res)
    {
    case 16 :   dwFlags = ILC_COLOR16;
                uBytesPerPix = 2;
                break;
    case 24 :
    case 32 :   dwFlags = ILC_COLOR24;
                uBytesPerPix = 3;
                break;
    default :   dwFlags = ILC_COLOR8;
                uBytesPerPix = 1;
    }
    if (puBytesPerPixel)
    {
        *puBytesPerPixel = uBytesPerPix;
    }

    return dwFlags;
}

UINT CalcCacheMaxSize(const SIZE * psizeThumbnail, UINT uBytesPerPix)
{
    // the minimum in the cache is the number of thumbnails visible on the screen at once.
    HDC hdc = GetDC(NULL);
    int iWidth = GetDeviceCaps(hdc, HORZRES);
    int iHeight = GetDeviceCaps(hdc, VERTRES);
    ReleaseDC(NULL, hdc);

    // the minimum number of thumbnails in the cache, is set to the maximum amount
    // of thumbnails that can be diplayed by a single view at once.
    int iRow =  iWidth / (psizeThumbnail->cx + DEFSIZE_BORDER);
    int iCol = iHeight / (psizeThumbnail->cy + DEFSIZE_VERTBDR);
    UINT iMinThumbs = iRow * iCol + NUM_OVERLAY_IMAGES;

    // calculate the maximum number of thumbnails in the cache based on available memory
    MEMORYSTATUS ms;
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatus(&ms);

    // set the thumbnail maximum by calculating the memory required for a single thumbnail.
    // then use no more than 1/3 the available memory.
    // Say you had 80x80x32bpp thumbnails, this would be 13 images per MB of available memory.
    int iMemReqThumb = psizeThumbnail->cx * psizeThumbnail->cy * uBytesPerPix;
    UINT iMaxThumbs = UINT((ms.dwAvailPhys / 3) / iMemReqThumb);

#ifdef DEBUG
    return iMinThumbs;
#else
    return __max(iMaxThumbs, iMinThumbs);
#endif    
}

void ListView_InvalidateImageIndexes(HWND hwndList)
{
    int iItem = -1;
    while ((iItem = ListView_GetNextItem(hwndList, iItem, 0)) != -1)
    {
        LV_ITEM lvi = {0};
        lvi.mask = LVIF_IMAGE;
        lvi.iItem = iItem;
        lvi.iImage = I_IMAGECALLBACK;

        ListView_SetItem(hwndList, &lvi);
    }
}

ULONG CDefView::_ApproxItemsPerView()
{
    RECT rcClient;
    ULONG ulItemsPerView = 0;
    
    if (_hwndView && GetClientRect(_hwndView, &rcClient))
    {
        SIZE sizeThumbnail;
        _GetThumbnailSize(&sizeThumbnail);

        ULONG ulItemWidth = sizeThumbnail.cx + DEFSIZE_BORDER;
        ULONG ulItemHeight = sizeThumbnail.cy + DEFSIZE_VERTBDR;
        
        ulItemsPerView = (rcClient.right - rcClient.left + ulItemWidth / 2) / ulItemWidth;
        ulItemsPerView *= (rcClient.bottom - rcClient.top + ulItemHeight / 2) / ulItemHeight;
    }

    return ulItemsPerView;
}

void CDefView::_SetThumbview()
{
    // Since we are switching into thumbnail view, remove any icon tasks
    if (_pScheduler)
        _pScheduler->RemoveTasks(TOID_DVIconExtract, ITSAT_DEFAULT_LPARAM, TRUE);

    if (_pImageCache == NULL)
    {
        // create the image cache (before we do the CreateWindow)....
        CoCreateInstance(CLSID_ImageListCache, NULL, CLSCTX_INPROC, 
                         IID_PPV_ARG(IImageCache3, &_pImageCache)); 
    }

    if (_pDiskCache == NULL && 
        !SHRestricted(REST_NOTHUMBNAILCACHE) && 
        !SHRegGetBoolUSValue(REGSTR_EXPLORER_ADVANCED, TEXT("DisableThumbnailCache"), 0, FALSE))
    {
        LPITEMIDLIST pidlFolder = _GetViewPidl();
        if (pidlFolder)
        {
            LoadFromIDList(CLSID_ShellThumbnailDiskCache, pidlFolder, IID_PPV_ARG(IShellImageStore, &_pDiskCache));
            ILFree(pidlFolder);
        }
    }

    if (_IsOwnerData())
        _ThumbnailMapInit();

    if (_pImageCache)
    {
        HRESULT hrInit = E_FAIL;
        UINT uBytesPerPix;
        IMAGECACHEINITINFO rgInitInfo;
        rgInitInfo.cbSize = sizeof(rgInitInfo);
        rgInitInfo.dwMask = ICIIFLAG_LARGE | ICIIFLAG_SORTBYUSED;
        _GetThumbnailSize(&rgInitInfo.rgSizeLarge);
        rgInitInfo.iStart = 0;
        rgInitInfo.iGrow = 5;
        _dwRecClrDepth = rgInitInfo.dwFlags = GetCurrentColorFlags(&uBytesPerPix);
        rgInitInfo.dwFlags |= ILC_MASK;
        
        _iMaxCacheSize = CalcCacheMaxSize(&rgInitInfo.rgSizeLarge, uBytesPerPix);

        hrInit = _pImageCache->GetImageList(&rgInitInfo);
        if (SUCCEEDED(hrInit))
        {
            // GetImageList() will return S_FALSE if it was already created...

            if (_dwRecClrDepth <= 8)
            {
                HPALETTE hpal = NULL;
                HRESULT hrPalette = _GetBrowserPalette(&hpal);
                if (SUCCEEDED(_GetBrowserPalette(&hpal)))
                {
                    PALETTEENTRY rgColours[256];
                    RGBQUAD rgDIBColours[256];

                    int nColours = GetPaletteEntries(hpal, 0, ARRAYSIZE(rgColours), rgColours);

                    // translate from the LOGPALETTE structure to the RGBQUAD structure ...
                    for (int iColour = 0; iColour < nColours; iColour ++)
                    {
                        rgDIBColours[iColour].rgbRed = rgColours[iColour].peRed;
                        rgDIBColours[iColour].rgbBlue = rgColours[iColour].peBlue;
                        rgDIBColours[iColour].rgbGreen = rgColours[iColour].peGreen;
                        rgDIBColours[iColour].rgbReserved = 0;
                    }

                    ImageList_SetColorTable(rgInitInfo.himlLarge, 0, nColours, rgDIBColours);
                }

                // Make sure we are not using the double buffer stuff...
                ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_DOUBLEBUFFER, 0);
            }

            ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_BORDERSELECT, LVS_EX_BORDERSELECT);

            if (_fs.fFlags & FWF_OWNERDATA)
            {
                InvalidateRect(_hwndListview, NULL, TRUE);
            }
            else
            {
                ListView_InvalidateImageIndexes(_hwndListview);
            }

            ListView_SetImageList(_hwndListview, rgInitInfo.himlLarge, LVSIL_NORMAL);

            HIMAGELIST himlLarge;
            Shell_GetImageLists(&himlLarge, NULL);

            int cxIcon, cyIcon;
            ImageList_GetIconSize(himlLarge, &cxIcon, &cyIcon);
            int cySpacing = (_fs.fFlags & FWF_HIDEFILENAMES) ? cyIcon / 4 + rgInitInfo.rgSizeLarge.cy + 3 : 0;
            int cxSpacing = cxIcon / 4 + rgInitInfo.rgSizeLarge.cx + 1;

            // Usability issue: people have trouble unselecting, marquee selecting, and dropping
            // since they can't find the background.  Add an extra 20 pixels between the thumbnails
            // to avoid this problem.
            //
            ListView_SetIconSpacing(_hwndListview, cxSpacing + 20, cySpacing);

            // NOTE: if you need to adjust cySpacing above, you can't do it directly since we
            // can't calculate the proper size of the icons.  Do it this way:
            //   DWORD dwOld = ListView_SetIconSpacing(_hwndListview, cxSpacing, cySpacing);
            //   ListView_SetIconSpacing(_hwndListview, LOWORD(dwOld)+20, HIWORD(dwOld)+20);

            if (_fs.fFlags & FWF_HIDEFILENAMES)
                ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_HIDELABELS, LVS_EX_HIDELABELS);

            // We need to pre-populate the ImageList controled by _pImageCache
            // to contain the default system overlays so that our overlays will
            // work.  We are going to get them from the already created shell image
            // lists as they are in hard-coded locations
            UINT uCacheSize = 0;
            _pImageCache->GetCacheSize(&uCacheSize);

            if (!uCacheSize)  // If there are images in the cache the overlays are already there
            {
                IImageList* piml;
                if (SUCCEEDED(SHGetImageList(SHIL_EXTRALARGE, IID_PPV_ARG(IImageList, &piml))))
                {
                    struct _OverlayMap 
                    {
                        int iSystemImage;
                        int iThumbnailImage;
                    } rgOverlay[NUM_OVERLAY_IMAGES];
                    
                    // For whatever reason Overlays are one-based
                    for (int i = 1; i <= NUM_OVERLAY_IMAGES; i++)
                    {
                        int iSysImageIndex;
                        if (SUCCEEDED(piml->GetOverlayImage(i, &iSysImageIndex)) && (iSysImageIndex != -1))
                        {
                            int iMap;
                            for (iMap = 0; iMap < i - 1; iMap++)
                            {
                                if (rgOverlay[iMap].iSystemImage == iSysImageIndex)
                                    break;
                            }

                            if (iMap == (i - 1)) // We haven't used this System Image yet
                            {
                                HBITMAP hbmOverlay = NULL;
                                HBITMAP hbmMask = NULL;
                                if (SUCCEEDED(_CreateOverlayThumbnail(iSysImageIndex, &hbmOverlay, &hbmMask)) && hbmOverlay && hbmMask)
                                {
                                    IMAGECACHEINFO rgInfo = {0};
                                    int iThumbImageIndex;
                    
                                    rgInfo.cbSize = sizeof(rgInfo);
                                    rgInfo.dwMask = ICIFLAG_SYSTEM | ICIFLAG_LARGE | ICIFLAG_BITMAP;
                                    rgInfo.hBitmapLarge = hbmOverlay;
                                    rgInfo.hMaskLarge = hbmMask;

                                    if (IS_WINDOW_RTL_MIRRORED(_hwndListview))
                                        rgInfo.dwMask |= ICIFLAG_MIRROR;

                                    if (SUCCEEDED(_SafeAddImage(TRUE, &rgInfo, (UINT*)&iThumbImageIndex, -1)))
                                    {
                                        ImageList_SetOverlayImage(rgInitInfo.himlLarge, iThumbImageIndex, i);
                                        rgOverlay[iMap].iSystemImage = iSysImageIndex;
                                        rgOverlay[iMap].iThumbnailImage = iThumbImageIndex;
                                    }
                                    else
                                    {
                                        rgOverlay[i - 1].iSystemImage = -1; // failed to add the image
                                        ImageList_SetOverlayImage(rgInitInfo.himlLarge, -1, i);
                                    }
                                }
                                else
                                {
                                    rgOverlay[i - 1].iSystemImage = -1;  // failed to import htis image
                                    ImageList_SetOverlayImage(rgInitInfo.himlLarge, -1, i); 
                                }
                                if (hbmOverlay)
                                {
                                    DeleteObject(hbmOverlay);
                                }
                                if (hbmMask)
                                {
                                    DeleteObject(hbmMask);
                                }
                            }
                            else
                            {
                                ImageList_SetOverlayImage(rgInitInfo.himlLarge, rgOverlay[iMap].iThumbnailImage, i);
                                rgOverlay[i - 1].iSystemImage = -1;  // image already shows up in list
                            }
                        }
                        else
                        {
                            rgOverlay[i - 1].iSystemImage = -1; // Didn't find a system image
                            ImageList_SetOverlayImage(rgInitInfo.himlLarge, -1, i);
                        }                    
                    }
                }
            }
        }
    } 
}
void CDefView::_ResetThumbview()
{
    ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_BORDERSELECT, 0);

    if (_fs.fFlags & FWF_HIDEFILENAMES)
        ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_HIDELABELS, 0);

    if (_dwRecClrDepth <= 8)
    {
        ListView_SetExtendedListViewStyleEx(_hwndListview, LVS_EX_DOUBLEBUFFER, LVS_EX_DOUBLEBUFFER);
    }

    ListView_SetIconSpacing(_hwndListview, -1, -1);
    _SetSysImageList();

    if (_IsOwnerData())
        _ThumbnailMapClear();        
}

HRESULT CDefView::_GetDefaultTypeExtractor(LPCITEMIDLIST pidl, IExtractImage **ppExt)
{
    IAssociationArray * paa;
    HRESULT hr = _pshf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IAssociationArray, NULL, &paa));
    if (SUCCEEDED(hr))
    {
        LPWSTR psz;
        hr = paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, AQN_NAMED_VALUE, L"Thumbnail", &psz);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlThumb;
            hr = SHILCreateFromPath(psz, &pidlThumb, NULL);
            if (SUCCEEDED(hr))
            {
                SHGetUIObjectFromFullPIDL(pidlThumb, NULL, IID_PPV_ARG(IExtractImage, ppExt));
                ILFree(pidlThumb);
            }
            CoTaskMemFree(psz);
        }
        paa->Release();
    }
    return hr;
}

struct ThumbMapNode
{
    int iIndex;
    LPITEMIDLIST pidl;

    ~ThumbMapNode() { ILFree(pidl); }
};

int CDefView::_MapIndexPIDLToID(int iIndex, LPCITEMIDLIST pidl)
{
    int ret = -1;
    if (_IsOwnerData())
    {
        int cNodes = DPA_GetPtrCount(_dpaThumbnailMap);
        int iNode = 0;
        for (; iNode < cNodes; iNode++)
        {
            ThumbMapNode* pNode = (ThumbMapNode*) DPA_GetPtr(_dpaThumbnailMap, iNode);
            ASSERT(pNode);
            if (pNode->iIndex == iIndex)
            {
                if (!(_pshf->CompareIDs(0, pidl, pNode->pidl)))  // 99 percent of the time we are good
                {
                    ret = iNode;
                }
                else  // Someone moved our pidl!
                {
                    int iNodeStop = iNode;
                    for (iNode = (iNode + 1) % cNodes; iNode != iNodeStop; iNode = (iNode + 1) % cNodes)
                    {
                        pNode = (ThumbMapNode*) DPA_GetPtr(_dpaThumbnailMap, iNode);
                        if (!(_pshf->CompareIDs(0, pidl, pNode->pidl)))
                        {
                            ret = iNode;
                            pNode->iIndex = iIndex; // Newer index for pidl
                            break;
                        }
                    }
                }
                break;
            }
        }
        if (ret == -1)
        {
            ThumbMapNode* pNode = new ThumbMapNode;
            if (pNode)
            {
                pNode->iIndex = iIndex;
                pNode->pidl = ILClone(pidl);
                ret = DPA_AppendPtr(_dpaThumbnailMap, pNode);
                if (ret == -1)
                {
                    delete pNode;
                }
            }
        }
    }
    else
    {
        ret = ListView_MapIndexToID(_hwndListview, iIndex);
    }
    return ret;
}

int CDefView::_MapIDToIndex(int iID)
{
   int ret = -1;
   if (_IsOwnerData())
   {
        ThumbMapNode* pNode = (ThumbMapNode*) DPA_GetPtr(_dpaThumbnailMap, iID);
        if (pNode)
        {
            ret = pNode->iIndex;
        }
   }
   else
   {
       ret = ListView_MapIDToIndex(_hwndListview, iID);
   }
   return ret;
}

void CDefView::_ThumbnailMapInit()
{
    if (_dpaThumbnailMap)
    {
        _ThumbnailMapClear();
    }
    else
    {
        _dpaThumbnailMap = DPA_Create(1);
    }
}

void CDefView::_ThumbnailMapClear()
{
    if (_dpaThumbnailMap)
    {
        int i = DPA_GetPtrCount(_dpaThumbnailMap);
        while (--i >= 0)
        {
            ThumbMapNode* pNode = (ThumbMapNode*) DPA_FastGetPtr(_dpaThumbnailMap, i);
            delete pNode;
        }
        DPA_DeleteAllPtrs(_dpaThumbnailMap);
    }
}

HRESULT CDefView::_GetBrowserPalette(HPALETTE* phpal)
{
    HRESULT hr = E_UNEXPECTED;
    
    if (_psb) 
    {
        IBrowserService *pbs;
        hr = _psb->QueryInterface(IID_PPV_ARG(IBrowserService, &pbs));
        if (SUCCEEDED(hr))
        {
            hr = pbs->GetPalette(phpal);
            pbs->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\eballoon.h ===
typedef enum
{
    CBSHOW_HIDE     = -1,
    CBSHOW_SHOW     = 0,
} CBSHOW;

typedef struct 
{
    POINT pt;           //  REQUIRED - maybe OPTIONAL?
    HINSTANCE hinst;    //  REQUIRED - for LoadString
    int idsTitle;       //  REQUIRED 
    int idsMessage;     //  REQUIRED 
    int ttiIcon;        //  REQUIRED one of TTI_ values

    DWORD dwMSecs;      //  OPTIONAL 
    DWORD cLimit;       //  OPTIONAL - if non-zero then query registry
    HKEY hKey;          //  OPTIONAL - REQUIRED if cLimit > 0
    LPCWSTR pszSubKey;  //  OPTIONAL - REQUIRED if cLimit > 0
    LPCWSTR pszValue;   //  OPTIONAL - REQUIRED if cLimit > 0
} CONDITIONALBALLOON;

STDAPI SHShowConditionalBalloon(HWND hwnd, CBSHOW show, CONDITIONALBALLOON *pscb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\eballoon.cpp ===
#include "shellprv.h"
#include "EBalloon.h"

class CErrorBalloon
{
public:
    CErrorBalloon();
    ~CErrorBalloon();

    HRESULT ShowToolTip(HINSTANCE hInstance, HWND hwndTarget, const POINT *ppt, LPTSTR pszTitle, LPTSTR pszMessage, DWORD dwIconIndex, int iTimeout);
    void HideToolTip(BOOL fDestroy);

protected:
    HWND _CreateToolTipWindow(HWND hwnd);
    static LRESULT CALLBACK _SubclassTipProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData);
    
    HWND        _hwndTarget;   // the targeted control hwnd
    HWND        _hwndToolTip;  // the tooltip control
    UINT_PTR    _uTimerID;     // the timer id
};


#define ERRORBALLOONTIMERID 1000
#define EB_WARNINGBELOW    0x00000000      // default value.  Balloon tooltips will be shown below the window by default.
#define EB_WARNINGABOVE    0x00000004      // Ballon tooltips will be shown above the window by default.
#define EB_WARNINGCENTERED 0x00000008      // Ballon tooltips will be shown pointing to the center of the window.

CErrorBalloon::CErrorBalloon()
{
    // our allocation function should have zeroed our memory.  Check to make sure:
    ASSERT(0==_hwndToolTip);
    ASSERT(0==_uTimerID);
}

CErrorBalloon::~CErrorBalloon()
{
    ASSERT(0==_hwndToolTip);
    ASSERT(0==_hwndTarget);
}

LRESULT CALLBACK CErrorBalloon::_SubclassTipProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, UINT_PTR uID, ULONG_PTR dwRefData)
{
    UNREFERENCED_PARAMETER(uID);
    CErrorBalloon * pthis = (CErrorBalloon*)dwRefData;

    switch (uMsg)
    {
        case WM_MOUSEACTIVATE:  // Never activate tooltip
            pthis->HideToolTip(FALSE);
            return MA_NOACTIVATEANDEAT;

        case WM_DESTROY:  
            pthis->HideToolTip(TRUE);
            delete pthis;
            break;

        case WM_TIMER:
            if (wParam == ERRORBALLOONTIMERID)
            {
                pthis->HideToolTip(FALSE);
                return 0;
            }
            break;

    default:
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

HRESULT CErrorBalloon::ShowToolTip(HINSTANCE hinst, HWND hwndTarget, const POINT *ppt, LPTSTR pszTitle, LPTSTR pszMessage, DWORD dwIconIndex, int iTimeout)
{
    if (_hwndToolTip)
    {
        HideToolTip(FALSE);
    }

    HWND hwnd = _CreateToolTipWindow(hwndTarget);
    if (hwnd)
    {
        int x, y;
        x = ppt->x;
        y = ppt->y;

        SendMessage(hwnd, TTM_TRACKPOSITION, 0, MAKELONG(x,y));

        if (pszTitle)
        {
            SendMessage(hwnd, TTM_SETTITLE, (WPARAM)dwIconIndex, (LPARAM)pszTitle);
        }

        TOOLINFO ti = {0};
        ti.cbSize = TTTOOLINFOW_V2_SIZE;
        ti.hwnd = hwnd;
        ti.uId = 1;
        ti.lpszText = pszMessage;
        SendMessage(hwnd, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);

        // Show the tooltip
        SendMessage(hwnd, TTM_TRACKACTIVATE, TRUE, (LPARAM)&ti);

        _uTimerID = SetTimer(hwnd, ERRORBALLOONTIMERID, iTimeout, NULL);

        if (SetWindowSubclass(hwnd, CErrorBalloon::_SubclassTipProc, (UINT_PTR)this, (LONG_PTR)this))
        {
            _hwndToolTip = hwnd;
            return S_OK;
        }

        //  we blew the subclassing
        DestroyWindow(hwnd);
    }
    return E_FAIL;
}

// CreateToolTipWindow
//
// Creates our tooltip control.  We share this one tooltip control and use it for all invalid
// input messages.  The control is hiden when not in use and then shown when needed.
//
HWND CErrorBalloon::_CreateToolTipWindow(HWND hwndTarget)
{
    HWND hwnd = CreateWindow(
            TOOLTIPS_CLASS,
            NULL,
            WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            hwndTarget,
            NULL,
            GetModuleHandle(NULL),
            NULL);

    ASSERT(!_hwndToolTip);
    ASSERT(!_hwndTarget);

    if (hwnd)
    {
        TOOLINFO ti = {0};

        ti.cbSize = TTTOOLINFOW_V2_SIZE;
        ti.uFlags = TTF_TRACK;
        ti.hwnd = hwnd;
        ti.uId = 1;

        // set the version so we can have non buggy mouse event forwarding
        SendMessage(hwnd, CCM_SETVERSION, COMCTL32_VERSION, 0);
        SendMessage(hwnd, TTM_ADDTOOL, 0, (LPARAM)&ti);
        SendMessage(hwnd, TTM_SETMAXTIPWIDTH, 0, 300);
        //  set tink-tink?
    }

    return hwnd;
}

void CErrorBalloon::HideToolTip(BOOL fOnDestroy)
{
    // When the timer fires we hide the tooltip window
    if (fOnDestroy)
    {
        //  we need to tear everything down
        if (_uTimerID)
        {
            KillTimer(_hwndTarget, ERRORBALLOONTIMERID);
            _uTimerID = 0;
        }
        
        if (_hwndTarget)
        {
            //  RemoveWindowSubclass(_hwndTarget, CErrorBalloon::_SubclassTargetProc, (UINT_PTR)this);
            RemoveProp(_hwndTarget, L"ShellConditionalBalloon");
            _hwndTarget = NULL;
        }

        if (_hwndToolTip)
        {
            RemoveWindowSubclass(_hwndToolTip, CErrorBalloon::_SubclassTipProc, (UINT_PTR)this);
            SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, FALSE, 0);
            _hwndToolTip = NULL;
        }
    }
    else
        DestroyWindow(_hwndToolTip);
}

STDAPI SHShowConditionalBalloon(HWND hwnd, CBSHOW show, CONDITIONALBALLOON *pscb)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (hwnd)
    {
        CErrorBalloon *peb = (CErrorBalloon *) GetProp(hwnd, L"ShellConditionalBalloon");
        if (show != CBSHOW_HIDE && pscb)
        {
            DWORD dw = 0;
            BOOL fShow = TRUE;
            HKEY hkSession = NULL;
            if (SUCCEEDED(SHCreateSessionKey(MAXIMUM_ALLOWED, &hkSession)))
            {
                fShow = (ERROR_SUCCESS != SHGetValue(hkSession, NULL, pscb->pszValue, NULL, NULL, NULL));
            }
            //  check cLimit
            if (fShow && pscb->cLimit)
            {
                ASSERT(pscb->hKey);
                DWORD cb = sizeof(dw);
                SHGetValue(pscb->hKey, pscb->pszSubKey, pscb->pszValue, NULL, &dw, &cb);
                fShow = dw < pscb->cLimit;
            }

            if (fShow)
            {
                //  we need to show something
                if (!peb)
                {
                    peb = new CErrorBalloon();
                    if (peb && !SetProp(hwnd, L"ShellConditionalBalloon", peb))
                    {
                        delete peb;
                        peb = NULL;
                    }
                }

                if (peb)
                {
                    TCHAR szTitle[MAX_PATH];
                    TCHAR szMessage[INFOTIPSIZE];
                    LoadString(pscb->hinst, pscb->idsTitle, szTitle, ARRAYSIZE(szTitle));
                    LoadString(pscb->hinst, pscb->idsMessage, szMessage, ARRAYSIZE(szMessage));
                    // Set the tooltip display point
                    //if (pscb->pt.x == -1 && pscb->pt.y == -1)
                    //    _GetTipPoint(hwndTarget, &pscb->pt);    
                    DWORD dwMSecs = pscb->dwMSecs;
                    if (dwMSecs == 0)
                    {
                        // default to 1 sec / 10 chars;
                        dwMSecs = lstrlen(szMessage) * 100;
                        if (dw == 0)
                            dwMSecs *= 5;  //  first time put it up for a while
                    }
                        
                    hr = peb->ShowToolTip(pscb->hinst, hwnd, &pscb->pt, szTitle, szMessage, pscb->ttiIcon, dwMSecs);
                    if (FAILED(hr))
                    {
                        RemoveProp(hwnd, L"ShellConditionalBalloon");
                        delete peb;
                    }

                    if (pscb->cLimit)
                    {
                        dw++;
                        SHSetValueW(pscb->hKey, pscb->pszSubKey, pscb->pszValue, REG_DWORD, &dw, sizeof(dw));
                    }
                }
            }
            else 
                hr = S_FALSE;

            if (hkSession)
            {
                SHSetValueW(hkSession, NULL, pscb->pszValue, REG_NONE, NULL, NULL);
                RegCloseKey(hkSession);
            }
                
        }
        else if (peb)
        {
            peb->HideToolTip(FALSE);
            //  we delete ourselves during WM_DESTROY
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\dynastg.cpp ===
#include "shellprv.h"
#include <shlobj.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <assert.h>
#include <shlwapi.h>
#include <stgutil.h>
#include <datautil.h>
#include <idlcomm.h>
#include <dpa.h>
#include <objbase.h>

#define DSTYPE_STORAGE      0x1
#define DSTYPE_STREAM       0x2

// do not change order of these parameters, we have some in line variable initializations going on
typedef struct 
{
    LPWSTR pwszTag;
    IShellItem *psi;
    DWORD_PTR grfMode;
} DYNASTGDATA;

// Prototype definitions
STDAPI CDynamicStorage_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);
STDAPI CDynamicStorageEnum_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);

class CDynamicStorage : public IStorage, public IDynamicStorage
{
friend class CDynamicStorageEnum;
friend HRESULT CDynamicStorage_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv);

public:
    CDynamicStorage();
    ~CDynamicStorage();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IDynamicStorage
    STDMETHODIMP AddIDList(DWORD cpidl, LPITEMIDLIST* rgpidl, DSTGF dstgf);
    STDMETHODIMP BindToItem(LPCWSTR pwszName, REFIID riid, void **ppv);
    STDMETHODIMP EnumItems(IEnumShellItems **ppesi);
    
    // IStorage
    //  we only implement: CreateStream, OpenStream, OpenStorage, MoveElementTo, EnumElements.
    //  others just return E_NOTIMPL;

    STDMETHODIMP CreateStream(const WCHAR * pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStream **ppstm);
    STDMETHODIMP OpenStream(const WCHAR *pwcsName, void *reserved1, DWORD grfMode, DWORD reserved2, IStream **ppstm);
    STDMETHODIMP CreateStorage(const WCHAR *pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStorage **ppstg)
        { return E_NOTIMPL; }
    STDMETHODIMP OpenStorage(const WCHAR *pwcsName, IStorage * pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage ** ppstg);
    STDMETHODIMP CopyTo(DWORD ciidExclude, IID const * rgiidExclude,  SNB snbExclude, IStorage * pstgDest)
        { return E_NOTIMPL; }
    STDMETHODIMP MoveElementTo(const WCHAR * pwcsName, IStorage * pstgDest, const WCHAR * pwcsNewName, DWORD grfFlags);
    STDMETHODIMP Commit(DWORD grfCommitFlags)
        { return S_OK; }
    STDMETHODIMP Revert(void)
        { return E_NOTIMPL; }
    STDMETHODIMP EnumElements(DWORD reserved1, void * reserved2, DWORD reserved3, IEnumSTATSTG ** ppenum);
    STDMETHODIMP DestroyElement(const WCHAR* pwcsName) 
        { return E_NOTIMPL; }
    STDMETHODIMP RenameElement(const WCHAR * pwcsOldName, const WCHAR * pwcsNewName)
        { return E_NOTIMPL; }
    STDMETHODIMP SetElementTimes(const WCHAR * pwcsName, FILETIME const * pctime, FILETIME const * patime, FILETIME const * pmtime)
        { return E_NOTIMPL; }
    STDMETHODIMP SetClass(REFCLSID clsid)
        { return E_NOTIMPL; }
    STDMETHODIMP SetStateBits(DWORD grfStateBits, DWORD grfMask)
        { return E_NOTIMPL; }
    STDMETHODIMP Stat(STATSTG * pstatstg, DWORD grfStatFlag)
        { return E_NOTIMPL; }

private:
    HRESULT _Init();
    HRESULT _EnsureDirectory();
    HRESULT _InsertItem(LPWSTR pszTag, IShellItem *psi, DSTGF dstgf);
    HRESULT _GetStream(int i, DWORD grfMode, IStream **ppstm);
    HRESULT _GetStorage(int i, DWORD grfMode, IStorage **ppstg);

    static int s_DataCompare(DYNASTGDATA *pData1, DYNASTGDATA *pData2, LPARAM lParam);
    static int s_DataDestroy(DYNASTGDATA* pData, void* pv);
    
private:        
    CDPA<DYNASTGDATA>   _dpaData;
    IStorage*           _pstgTemp;   // pointer to our temp subfolder
    IStorage*           _pstgTempDir; // the temp folder itself
    LPWSTR              _pwszTemp; // name of our temp subfolder
    LONG                _cRef;
};

class CDynamicStorageEnum : public IEnumSTATSTG 
                          , public IEnumShellItems
{
public:    
    CDynamicStorageEnum();
    ~CDynamicStorageEnum();

    STDMETHODIMP Init(CDynamicStorage* pDynStorage);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void** ppv);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // IEnumXXX
    STDMETHODIMP Next(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched);
    STDMETHODIMP Clone(IEnumShellItems **ppenum) { return E_NOTIMPL; }
    STDMETHODIMP Next(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumSTATSTG **ppenum) { return E_NOTIMPL; }

private:
    CDynamicStorage *_pDynStorage;
    IShellFolder *_psfParent;
    LPITEMIDLIST _pidlParent;
    ULONG _cItems;
    ULONG _cPos;
    LONG  _cRef;
};

#define DYNSTG_DPA_GROW_SIZE 10

CDynamicStorage::CDynamicStorage(): _cRef(1)
{    
}

int CDynamicStorage::s_DataDestroy(DYNASTGDATA* pData, void* pv)
{
    ASSERTMSG(pData != NULL, "NULL dynamic storage data element");
    CoTaskMemFree(pData->pwszTag);
    pData->psi->Release();
    LocalFree(pData);
    return 1;
}

CDynamicStorage::~CDynamicStorage()
{
    _dpaData.DestroyCallback(s_DataDestroy, NULL);
    if (_pstgTemp)
    {
        ASSERT(_pstgTempDir);
        _pstgTempDir->DestroyElement(_pwszTemp);
        _pstgTempDir->Release();

        _pstgTemp->Release();

        CoTaskMemFree(_pwszTemp);
    }
}


// IUnknown

STDMETHODIMP CDynamicStorage::QueryInterface(REFIID iid, void** ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDynamicStorage, IDynamicStorage), 
        QITABENT(CDynamicStorage, IStorage), 
        { 0 },
    };
    return QISearch(this, qit, iid, ppv);
}

ULONG STDMETHODCALLTYPE CDynamicStorage::AddRef()
{
    return ::InterlockedIncrement(&_cRef);
}
    
ULONG STDMETHODCALLTYPE CDynamicStorage::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDAPI CDynamicStorage_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (punkOuter)
        return CLASS_E_NOAGGREGATION;
        
    HRESULT hr = E_OUTOFMEMORY;
    CDynamicStorage *pstgf = new CDynamicStorage();
    if (pstgf)
    {
        hr = pstgf->_Init();
        if (SUCCEEDED(hr))
        {
            hr = pstgf->QueryInterface(riid, ppv);
        }
        pstgf->Release();
    }
    
    return hr;    
}


HRESULT CDynamicStorage::_InsertItem(LPWSTR pszTag, IShellItem *psi, DSTGF dstgf)
{
    HRESULT hr = E_OUTOFMEMORY;
    DYNASTGDATA* pData = (DYNASTGDATA*)LocalAlloc(LPTR, sizeof(DYNASTGDATA));
    if (pData)
    {
        hr = SHStrDup(pszTag, &pData->pwszTag);
        if (SUCCEEDED(hr))
        {
            pData->psi = psi;
            pData->psi->AddRef();
            if (!(dstgf & DSTGF_ALLOWDUP))
            {
                int i = _dpaData.Search(pData, 0, s_DataCompare, 0, 0);
                if (i != -1)
                {
                    s_DataDestroy(_dpaData.GetPtr(i), NULL);
                    _dpaData.DeletePtr(i);
                }
            }

            // i != -1 if we succeeded, at which point pass out the data pointer or
            // ensure that we clean up.

            if (-1 == _dpaData.AppendPtr(pData))
            {
                s_DataDestroy(pData, NULL);
                hr = E_FAIL;
            }
        }
    }
    
    return hr;
}

// IDynamicStorage 
STDMETHODIMP CDynamicStorage::AddIDList(DWORD cpidl, LPITEMIDLIST* rgpidl, DSTGF dstgf)
{
    if (!rgpidl || !cpidl)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    for (DWORD i = 0; SUCCEEDED(hr) && i < cpidl; i++)
    {
        IShellItem *psi;
        hr = SHCreateShellItem(NULL, NULL, rgpidl[i], &psi);
        if (SUCCEEDED(hr))
        {
            LPWSTR pszName;
            hr = psi->GetDisplayName(SIGDN_PARENTRELATIVEFORADDRESSBAR, &pszName);
            if (SUCCEEDED(hr))
            {
                hr = _InsertItem(pszName, psi, dstgf);
                CoTaskMemFree(pszName);
            }
            psi->Release();
        }
    }

    return hr;
} 
                         
HRESULT CDynamicStorage::BindToItem(LPCWSTR pwszName, REFIID riid, void **ppv)
{
    HRESULT hr = STG_E_FILENOTFOUND;
    DYNASTGDATA data = {(LPWSTR)pwszName};
    INT iResult = _dpaData.Search(&data, 0, s_DataCompare, 0, 0);
    if (iResult != -1)
    {
        DYNASTGDATA* pData = _dpaData.GetPtr(iResult);
        if (pData && riid == IID_IShellItem)
            hr = pData->psi->QueryInterface(riid, ppv);
        else
            hr = E_NOINTERFACE;
    }       
    return hr;
}

HRESULT CDynamicStorage::EnumItems(IEnumShellItems **ppesi)
{
    *ppesi = NULL;
    
    IEnumShellItems *penum = NULL;
    HRESULT hr = CDynamicStorageEnum_CreateInstance(NULL, IID_PPV_ARG(IEnumShellItems, &penum));
    if (SUCCEEDED(hr))
    {
        hr = ((CDynamicStorageEnum*)penum)->Init(this);
        if (FAILED(hr))
        {
            penum->Release();
        }
    }
    
    if (SUCCEEDED(hr))
    {
        *ppesi = penum;
    }

    return hr;

}

HRESULT CDynamicStorage::_Init()
{
    return _dpaData.Create(DYNSTG_DPA_GROW_SIZE) ? S_OK : E_OUTOFMEMORY;
}

HRESULT CDynamicStorage::_EnsureDirectory()
{
    HRESULT hr = S_OK;

    if (!_pstgTemp)
    {
        hr = E_FAIL;
        WCHAR wszTempDir[MAX_PATH];
        if (GetTempPath(ARRAYSIZE(wszTempDir), wszTempDir))
        {
            LPITEMIDLIST pidl;
            hr = SHILCreateFromPath(wszTempDir, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                hr = SHBindToObjectEx(NULL, pidl, NULL, IID_PPV_ARG(IStorage, &_pstgTempDir));
                if (SUCCEEDED(hr))
                {
                    hr = StgMakeUniqueName(_pstgTempDir, L"dynastg", IID_PPV_ARG(IStorage, &_pstgTemp));
                    if (SUCCEEDED(hr))
                    {
                        STATSTG statstg = {0};

                        hr = _pstgTemp->Stat(&statstg, STATFLAG_DEFAULT);
                        if (SUCCEEDED(hr))
                            _pwszTemp = statstg.pwcsName;
                    }

                    if (FAILED(hr))
                    {
                        ATOMICRELEASE(_pstgTempDir);                            // if we failed, _pwszTemp could not have been allocated...
                        ATOMICRELEASE(_pstgTemp);
                    }
                }
                ILFree(pidl);
            }
        }
    }
    
    return hr;
}

int CDynamicStorage::s_DataCompare(DYNASTGDATA *pData1, DYNASTGDATA *pData2, LPARAM lParam)
{
    return lstrcmp(pData1->pwszTag, pData2->pwszTag);
}

HRESULT CDynamicStorage::_GetStream(int i, DWORD grfMode, IStream **ppstm)
{
    *ppstm = NULL;
    
    HRESULT hr = E_FAIL;
    DYNASTGDATA* pData = _dpaData.GetPtr(i);
    if (pData)
    {
        IBindCtx *pbc;
        hr = BindCtx_CreateWithMode(grfMode, &pbc);
        if (SUCCEEDED(hr))
        {
            hr = pData->psi->BindToHandler(pbc, BHID_Stream, IID_PPV_ARG(IStream, ppstm));
            pbc->Release();
        }
    }

    return hr;
}

STDMETHODIMP CDynamicStorage::OpenStream(const WCHAR * pwcsName,
                                         void * reserved1,
                                         DWORD grfMode,
                                         DWORD reserved2,
                                         IStream ** ppstm)
{
    if (reserved1 || reserved2)
        return E_INVALIDARG;
        
    HRESULT hr = STG_E_FILENOTFOUND;
    DYNASTGDATA data = {(LPWSTR)pwcsName};
    INT iResult = _dpaData.Search(&data, 0, s_DataCompare, 0, 0);
    if (iResult != -1)
    {
        hr = _GetStream(iResult, grfMode, ppstm);
    }

    return hr;
}

HRESULT CDynamicStorage::_GetStorage(int i, DWORD grfMode, IStorage **ppstg)
{
    *ppstg = NULL;
    
    HRESULT hr = E_FAIL;
    DYNASTGDATA* pData = _dpaData.GetPtr(i);
    if (pData)
    {
        IBindCtx *pbc;
        hr = BindCtx_CreateWithMode(grfMode, &pbc);
        if (SUCCEEDED(hr))
        {
            hr = pData->psi->BindToHandler(pbc, BHID_Storage, IID_PPV_ARG(IStorage, ppstg));
            pbc->Release();
        }
    }

    return hr;
}

STDMETHODIMP CDynamicStorage::OpenStorage(const WCHAR * pwcsName,
                                          IStorage * pstgPriority,
                                          DWORD grfMode,
                                          SNB snbExclude,
                                          DWORD reserved,
                                          IStorage ** ppstg)
{
    if (pstgPriority || snbExclude || reserved)
        return E_INVALIDARG;
        
    HRESULT hr = STG_E_FILENOTFOUND;
    DYNASTGDATA data = {(LPWSTR)pwcsName};
    INT iResult = _dpaData.Search(&data, 0, s_DataCompare, 0, 0);
    if (iResult != -1)
    {
        hr = _GetStorage(iResult, grfMode, ppstg);
    }

    return hr;
}

STDMETHODIMP CDynamicStorage::EnumElements(DWORD reserved1,
                                           void * reserved2,
                                           DWORD reserved3,
                                           IEnumSTATSTG ** ppenum)
{
    if (reserved1 || reserved2 || reserved3 || !ppenum)
        return E_INVALIDARG;

    *ppenum = NULL;
    IEnumSTATSTG* pEnumObj = NULL;
    HRESULT hr = CDynamicStorageEnum_CreateInstance(NULL, IID_PPV_ARG(IEnumSTATSTG, &pEnumObj));
    if (SUCCEEDED(hr))
    {
        hr = ((CDynamicStorageEnum*)pEnumObj)->Init(this);
        if (FAILED(hr))
        {
            pEnumObj->Release();
        }
    }
    
    if (SUCCEEDED(hr))
    {
        *ppenum = pEnumObj;
    }

    return hr;
}


STDMETHODIMP CDynamicStorage::MoveElementTo(const WCHAR * pwcsName,
                                            IStorage * pstgDest,
                                            const WCHAR* pwcsNewName,
                                            DWORD grfFlags)
{
    if (!pwcsName || !pstgDest || !pwcsNewName || grfFlags != STGMOVE_COPY)
        return E_INVALIDARG;

    IStorage* pStorageSrc;
    HRESULT hr = OpenStorage(pwcsName, NULL, STGM_READ, NULL, 0, &pStorageSrc);
    if (SUCCEEDED(hr))
    {
        IStorage* pStorageDest;
        hr = pstgDest->CreateStorage(pwcsNewName, STGM_WRITE | STGM_CREATE, 0, 0, &pStorageDest);
        if (SUCCEEDED(hr))
        {
            hr = pStorageSrc->CopyTo(0, NULL, NULL, pStorageDest);
        }
    }
    else 
    {
        IStream* pStreamSrc;
        hr = OpenStream(pwcsName, NULL, STGM_READ, 0, &pStreamSrc);
        if (SUCCEEDED(hr))
        {
            IStream* pStreamDest;
            hr = pstgDest->CreateStream(pwcsNewName, STGM_WRITE | STGM_CREATE, 0, 0, &pStreamDest);
            if (SUCCEEDED(hr))
            {                    
                ULARGE_INTEGER ulSize = {0xffffffff, 0xffffffff};
                hr = pStreamSrc->CopyTo(pStreamDest, ulSize, NULL, NULL);
                pStreamDest->Release();
            }
            pStreamSrc->Release();
        }
    }
    
    return hr;
}

STDMETHODIMP CDynamicStorage::CreateStream(const WCHAR *pwcsName,
                                           DWORD grfMode,
                                           DWORD reserved1,
                                           DWORD reserved2,
                                           IStream **ppstm)
{
    *ppstm = NULL;
    
    HRESULT hr = _EnsureDirectory();
    if (SUCCEEDED(hr))
    {
        hr = _pstgTemp->CreateStream(pwcsName, grfMode, 0, 0, ppstm);
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
            WCHAR wszPath[MAX_PATH];
            if (GetTempPath(ARRAYSIZE(wszPath), wszPath) && PathCombine(wszPath, wszPath, _pwszTemp))
            {
                STATSTG statstg;
                if (SUCCEEDED((*ppstm)->Stat(&statstg, 0)))
                {
                    LPITEMIDLIST pidl;
                    if (PathCombine(wszPath, wszPath, statstg.pwcsName) && SUCCEEDED(SHILCreateFromPath(wszPath, &pidl, NULL)))
                    {
                        hr = AddIDList(1, &pidl, DSTGF_NONE);
                        ILFree(pidl);
                    }
                    CoTaskMemFree(statstg.pwcsName);
                }
            }

            if (FAILED(hr))
            {
                // no need to DeleteElement here because the whole temp storage
                // will be deleted in destructor
                ATOMICRELEASE(*ppstm);
            }
        }
    }

    return hr;
}


CDynamicStorageEnum::CDynamicStorageEnum(): _cRef(1)
{
}

CDynamicStorageEnum::~CDynamicStorageEnum()
{
    if (_pDynStorage)
        _pDynStorage->Release();

    if (_psfParent)
        _psfParent->Release();

    ILFree(_pidlParent);
}

STDMETHODIMP CDynamicStorageEnum::Init(CDynamicStorage* pDynStorage)
{
    _pDynStorage = pDynStorage;        
    _pDynStorage->AddRef();

    _cItems = _pDynStorage->_dpaData.GetPtrCount();
    _cPos = 0;    

    return S_OK;
}

STDMETHODIMP CDynamicStorageEnum::QueryInterface(REFIID iid, void** ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CDynamicStorageEnum, IEnumSTATSTG), 
        QITABENT(CDynamicStorageEnum, IEnumShellItems), 
        { 0 },
    };
    return QISearch(this, qit, iid, ppv);
}

ULONG STDMETHODCALLTYPE CDynamicStorageEnum::AddRef()
{
    return ::InterlockedIncrement(&_cRef);
}
    
ULONG STDMETHODCALLTYPE CDynamicStorageEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDAPI CDynamicStorageEnum_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv)
{
    *ppv = NULL;
    if (punkOuter)
        return CLASS_E_NOAGGREGATION;

    HRESULT hr = E_OUTOFMEMORY;
    CDynamicStorageEnum *pstgEnum = new CDynamicStorageEnum();
    if (pstgEnum)
    {
        hr = pstgEnum->QueryInterface(riid, ppv);
        pstgEnum->Release();
    }
    
    return hr;    
}

STDMETHODIMP CDynamicStorageEnum::Next(ULONG celt, IShellItem **rgelt, ULONG *pceltFetched)
{
    if (!rgelt || celt != 1)
        return E_INVALIDARG;

    if (pceltFetched)
        *pceltFetched = 0;
    *rgelt = NULL;
    
    if (_cPos >= _cItems)
        return S_FALSE;

    ASSERTMSG(_pDynStorage != NULL, "dynamic storage enumerator initialized with NULL dynamic storage");

    DYNASTGDATA* pData = _pDynStorage->_dpaData.GetPtr(_cPos++);
    HRESULT hr;
    if (_cPos > _cItems)
    {
        hr = S_FALSE;
    }
    else
    {
        ASSERTMSG(pData != NULL, "dynamic storage has null DPA item");

        hr = S_OK;
        rgelt[0] = pData->psi;
        rgelt[0]->AddRef();
        if (pceltFetched)
            *pceltFetched = 1;
    }

    return hr;
}

STDMETHODIMP CDynamicStorageEnum::Next(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched)
{
    // ISSUE: for now, we only support calling next asking for one item
    if (!rgelt || celt != 1)
        return E_INVALIDARG;

    if (_cPos >= _cItems)
        return S_FALSE;

    ASSERTMSG(_pDynStorage != NULL, "dynamic storage enumerator initialized with NULL dynamic storage");

    ZeroMemory(rgelt, sizeof(STATSTG));  // per COM conventions
    if (pceltFetched)
        *pceltFetched = 0;

    HRESULT hr = E_FAIL;
    IStorage *pstg;
    IStream *pstm;
    if (SUCCEEDED(_pDynStorage->_GetStream(_cPos, STGM_READ, &pstm)))
    {
        hr = pstm->Stat(rgelt, STATFLAG_DEFAULT);
        pstm->Release();
    }
    else if (SUCCEEDED(_pDynStorage->_GetStorage(_cPos, STGM_READ, &pstg)))
    {
        hr = pstg->Stat(rgelt, STATFLAG_DEFAULT);
        pstg->Release();
    }

    if (SUCCEEDED(hr))
    {
        _cPos++;
        if (pceltFetched)
            *pceltFetched = 1;
    }

    return hr;
}
    
STDMETHODIMP CDynamicStorageEnum::Skip(ULONG celt)
{
    ASSERTMSG(_pDynStorage != NULL, "dynamic storage enumerator initialized with NULL dynamic storage");
    HRESULT hr;
    if (_cPos + celt > _cItems)
    {
        _cPos = _cItems;
        hr = S_FALSE;
    }
    else
    {
        _cPos += celt;
        hr = S_OK;
    }

    return hr;
}
    
STDMETHODIMP CDynamicStorageEnum::Reset()
{
    ASSERTMSG(_pDynStorage != NULL, "dynamic storage enumerator initialized with NULL dynamic storage");
    _cPos = 0;
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\enumidlist.cpp ===
#include <shellprv.h>
#include "enumidlist.h"

CEnumIDListBase::CEnumIDListBase() : _cRef(1)
{
}

CEnumIDListBase::~CEnumIDListBase()
{
}

STDMETHODIMP CEnumIDListBase::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CEnumIDListBase, IEnumIDList),                        // IID_IEnumIDList
        QITABENT(CEnumIDListBase, IObjectWithSite),                    // IID_IObjectWithSite
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CEnumIDListBase::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CEnumIDListBase::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


class CEnumArray : public CEnumIDListBase
{
public:
    CEnumArray();
    HRESULT Init(const LPCITEMIDLIST rgpidl[], UINT cidl, UINT ulIndex);
    HRESULT InitFromPaths(LPCTSTR pszPaths);
    HRESULT InitFromCSIDLArray(const LPCTSTR rgcsidl[], UINT ccsidls, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum);

protected:
    virtual ~CEnumArray();
    LPITEMIDLIST *_ppidl;

    BOOL         _InitFolderParent(LPITEMIDLIST rgItems[], UINT cMaxItems, UINT *pcItems, LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidlParent);
    LPITEMIDLIST _ILLogical(LPCITEMIDLIST pidl);
    BOOL         _ShouldEnumCSIDL(int csidl);

private:
    LONG  _cRef;
    ULONG _ulIndex;
    UINT _cItems;
};

CEnumArray::CEnumArray() : CEnumIDListBase()
{
}

CEnumArray::~CEnumArray()
{
    if (_ppidl)
        FreeIDListArray(_ppidl, _cItems);
}

HRESULT CEnumArray::Init(const LPCITEMIDLIST rgpidl[], UINT cidl, UINT ulIndex)
{
    _ulIndex = ulIndex;
    HRESULT hr = CloneIDListArray(cidl, rgpidl, &_cItems, &_ppidl);
    if (S_FALSE == hr)
        hr = S_OK;  // S_FALSE to S_OK
    return hr;
}

HRESULT CEnumArray::InitFromCSIDLArray(const LPCTSTR rgcsidl[], UINT ccsidls, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem)
{
    LPITEMIDLIST rgItems[32] = {0}; // reasonable max size, grow as needed
    UINT cItems = 0;

    LPITEMIDLIST pidlParent = NULL;         // pidlFolder's pidlParent (filesystem or logical pidl)
    LPITEMIDLIST pidlParentLogical = NULL;  // pidlFolder's pidlParent (logical pidl -- if exists)

    // Initialize pidlFolder's parent pidl.
    if (_InitFolderParent(rgItems, ARRAYSIZE(rgItems), &cItems, pidlFolder, &pidlParent))
    {
        // Retrieve pidlFolder's logical parent pidl.
        pidlParentLogical = _ILLogical(pidlParent);
    }

    // Initialize pidlItem.
    if (pidlItem &&
        (!pidlParent || !ILIsEqual(pidlItem, pidlParent)) &&
        (!pidlParentLogical || !ILIsEqual(pidlItem, pidlParentLogical)))
    {
        if (rgItems[cItems] = ILClone(pidlItem))
        {
            cItems++;
        }
    }

    // Initialize CSIDLs.
    for (UINT i = 0; (i < ccsidls) && (cItems < ARRAYSIZE(rgItems)); i++)
    {
        LPITEMIDLIST pidl;
        if (IS_INTRESOURCE(rgcsidl[i]))
        {
            int csidl = LOWORD((UINT_PTR)rgcsidl[i]);

            if (_ShouldEnumCSIDL(csidl))
                SHGetSpecialFolderLocation(NULL, csidl, &pidl);
            else
                pidl = NULL;
        }
        else
        {
            SHParseDisplayName((LPTSTR)rgcsidl[i], NULL, &pidl, 0, NULL);
        }

        if (pidl)
        {
            DWORD dwAttribs = SFGAO_NONENUMERATED;
            if ((pidlFolder && ILIsEqual(pidlFolder, pidl)) ||                  // if pidl is not myself
                (pidlParent && ILIsEqual(pidlParent, pidl)) ||                  // if pidl is not my parent
                (pidlParentLogical && ILIsEqual(pidlParentLogical, pidl)) ||    // (need to check logical parent too)
                (pidlItem && ILIsEqual(pidlItem, pidl)) ||                      // if pidl is not pidlItem
                FAILED(SHGetNameAndFlags(pidl, 0, NULL, 0, &dwAttribs)) ||      // if pidl is not SFGAO_NONENUMERATED
                (SFGAO_NONENUMERATED & dwAttribs))
            {
                ILFree(pidl);
            }
            else
            {
                rgItems[cItems++] = pidl;                                       // then add pidl
            }
        }
    }

    // Initialize CEnumArray with collected pidls.
    HRESULT hr = Init(rgItems, cItems, 0);

    // Cleanup.
    for (i = 0; i < cItems; i++)
    {
        ILFree(rgItems[i]);
    }
    ILFree(pidlParentLogical);

    return hr;
}

BOOL CEnumArray::_InitFolderParent(LPITEMIDLIST rgItems[], UINT cMaxItems, UINT *pcItems, LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidlParent)
{
    ASSERT(*pcItems == 0);  // Currently we expect to add the parent pidl as the FIRST entry.
    ASSERT(cMaxItems > 0);  // Sanity check.

    // If there is a pidlFolder and it's NOT the Desktop pidl, add its parent
    // as the first entry in the rgItems array.  Note that the reason we
    // exclude the Desktop pidl from having its parent added to the array is
    // because its parent is itself, and we don't want the folder we're
    // currently in appearing in rgItems since we're already there!

    if (pidlFolder && !ILIsEmpty(pidlFolder))
    {
        *ppidlParent = ILCloneParent(pidlFolder);
        if (*ppidlParent)
        {
            rgItems[*pcItems] = *ppidlParent;
            (*pcItems)++;
        }
    }
    else
    {
        *ppidlParent = NULL;
    }

    return (*ppidlParent != NULL);
}

// Description:
//  _ILLogical() will return NULL in three cases:
//  1.  out of memory
//  2.  pidl has no logical pidl equivalent
//  3.  pidl is SAME as logical pidl equivalent
//      (thus we already have the logical pidl)
//
// Note:
//  ILFree() must be called on returned pidls.
//
LPITEMIDLIST CEnumArray::_ILLogical(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlLogical = SHLogILFromFSIL(pidl);
    if (pidlLogical && ILIsEqual(pidl, pidlLogical))
    {
        // If the pidl argument is logical, then we already
        // have the logical pidl so don't return another one.
        ILFree(pidlLogical);
        pidlLogical = NULL;
    }
    return pidlLogical;
}

STDMETHODIMP CEnumArray::Next(ULONG celt, LPITEMIDLIST *ppidl, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;
    if (_ppidl && (_ulIndex < _cItems))
    {
        hr = SHILClone(_ppidl[_ulIndex++], ppidl);
    }
    
    if (pceltFetched)
        *pceltFetched = (hr == S_OK) ? 1 : 0;

    return hr;
}

STDMETHODIMP CEnumArray::Skip(ULONG celt) 
{
    _ulIndex = min(_cItems, _ulIndex + celt);
    return S_OK;
}

STDMETHODIMP CEnumArray::Reset() 
{
    _ulIndex = 0;
    return S_OK;
}

HRESULT _CreateIEnumIDListOnIDLists(const LPCITEMIDLIST rgpidl[], UINT cItems, UINT ulIndex, IEnumIDList **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppenum = NULL;

    CEnumArray *p = new CEnumArray();
    if (p)
    {
        hr = p->Init(rgpidl, cItems, ulIndex);
        if (SUCCEEDED(hr))
        {
            hr = p->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
        }
        p->Release();
    }
    return hr;
}

STDMETHODIMP CEnumArray::Clone(IEnumIDList **ppenum) 
{ 
    return _CreateIEnumIDListOnIDLists(_ppidl, _cItems, _ulIndex, ppenum);
}

// Depending on the current state of the world, certain we may not want
// to allow certain CSIDLs to be enumerated (i.e. we want to hide them).
//
BOOL CEnumArray::_ShouldEnumCSIDL(int csidl)
{
    BOOL bEnum;

    switch (csidl)
    {
        case CSIDL_COMMON_DOCUMENTS:
        case CSIDL_COMMON_MUSIC:
        case CSIDL_COMMON_PICTURES:
        case CSIDL_COMMON_VIDEO:
            bEnum = SHShowSharedFolders();
            break;

        default:
            bEnum = TRUE;
            break;
    }

    return bEnum;
}

STDAPI CreateIEnumIDListOnIDLists(const LPCITEMIDLIST rgpidl[], UINT cItems, IEnumIDList **ppenum)
{
    return _CreateIEnumIDListOnIDLists(rgpidl, cItems, 0, ppenum);
}

STDAPI CreateIEnumIDListOnCSIDLs(LPCITEMIDLIST pidlFolder, const LPCTSTR rgcsidl[], UINT cItems, IEnumIDList **ppenum)
{
    return CreateIEnumIDListOnCSIDLs2(pidlFolder, NULL, rgcsidl, cItems, ppenum);
}

STDAPI CreateIEnumIDListOnCSIDLs2(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem, const LPCTSTR rgcsidl[], UINT cItems, IEnumIDList **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppenum = NULL;

    CEnumArray *p = new CEnumArray();
    if (p)
    {
        hr = p->InitFromCSIDLArray(rgcsidl, cItems, pidlFolder, pidlItem);
        if (SUCCEEDED(hr))
        {
            hr = p->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
        }
        p->Release();
    }
    return hr;
}

STDAPI CreateIEnumIDListPaths(LPCTSTR pszPaths, IEnumIDList **ppenum)
{
    *ppenum = NULL;
    HRESULT hr = E_FAIL;

    LPITEMIDLIST rgItems[32] = {0};
    TCHAR szPath[MAX_PATH];
    LPCTSTR pszNext = pszPaths;
    int cItems = 0;

    while ((cItems < ARRAYSIZE(rgItems)) && (pszNext = NextPath(pszNext, szPath, ARRAYSIZE(szPath))))
    {
        PathRemoveBackslash(szPath);
        TCHAR szExpanded[MAX_PATH];
        if (SHExpandEnvironmentStrings(szPath, szExpanded, ARRAYSIZE(szExpanded)))
        {
            if (SUCCEEDED(SHParseDisplayName(szExpanded, NULL, &rgItems[cItems], 0, NULL)))
            {
                cItems++;
            }
        }
    }

    if (cItems > 0)
    {
        hr = _CreateIEnumIDListOnIDLists(rgItems, cItems, 0, ppenum);

        for (int i = 0; i < cItems; i++)
            ILFree(rgItems[i]);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\enumidlist.h ===
#ifndef _enumidlist_h_
#define _enumidlist_h_
#include "cowsite.h"

// A minimal base IEnumIDList implementation good enough for all our IShellFolder's EnumObject implementations.
// Just provide a Next..
class CEnumIDListBase : public CObjectWithSite, IEnumIDList
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched) PURE;
    STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; }
    STDMETHODIMP Reset() { return E_NOTIMPL; }
    STDMETHODIMP Clone(IEnumIDList **ppenum) { *ppenum = NULL; return E_NOTIMPL; }

protected:
    CEnumIDListBase();
    virtual ~CEnumIDListBase();

private:
    LONG _cRef;
};


// [in] pidlFolder - optional parent of this pidl is the first item in the enumerator
// [in] rgcsidl - array of CSIDLs to include in the enumerator
// [in] cItems - count of rgcsidl
// [out] ppenum
//
STDAPI CreateIEnumIDListOnCSIDLs(LPCITEMIDLIST pidlFolder, const LPCTSTR rgcsidl[], UINT cItems, IEnumIDList** ppenum);

// [in] pidlFolder - optional parent of this pidl is the first item in the enumerator
// [in] pidlItem - optional pidl is the next item in the enumerator
// [in] rgcsidl - array of CSIDLs to include in the enumerator
// [in] cItems - count of rgcsidl
// [out] ppenum
//
STDAPI CreateIEnumIDListOnCSIDLs2(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem, const LPCTSTR rgcsidl[], UINT cItems, IEnumIDList** ppenum);

// [in] apidl - array of LPCITEMIDLISTs
// [in] cItems - count of *papidl
// [out] ppenum
//
STDAPI CreateIEnumIDListOnIDLists(const LPCITEMIDLIST rgpidl[], UINT cItems, IEnumIDList** ppenum);
STDAPI CreateIEnumIDListPaths(LPCTSTR pszPaths, IEnumIDList** ppenum);

#endif // _enumidlist_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\enumuicommand.h ===
#ifndef _enumuicommand_h_
#define _enumuicommand_h_

// a helper class for defview and task implementations
class CWVTASKITEM
{
public:
    HRESULT get_Name(const WVTASKITEM* pTask, IShellItemArray *psiItemArray, LPWSTR *ppszName);
    HRESULT get_Icon(const WVTASKITEM* pTask, IShellItemArray *psiItemArray, LPWSTR *ppszIcon);
    HRESULT get_Tooltip(const WVTASKITEM* pTask, IShellItemArray *psiItemArray, LPWSTR *ppszInfotip);
    HRESULT get_CanonicalName(const WVTASKITEM* pTask, GUID* pguidCommandName);
    HRESULT get_State(const WVTASKITEM* pTask, IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    HRESULT Invoke(const WVTASKITEM* pTask, IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);

    CWVTASKITEM() {};
    virtual ~CWVTASKITEM() {};

private:
    HRESULT _get_String(const WVTASKITEM* pTask, DWORD dwIndex, LPWSTR* ppsz, DWORD cchMin, BOOL bIsIcon);
    DWORD _GetSelectionState(const WVTASKITEM* pTask,IShellItemArray *psiItemArray);
};

#endif // _enumuicommand_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\exec2nt.c ===
#define UNICODE 1

#include "shellprv.h"
#pragma  hdrstop

const WCHAR szCommdlgHelp[] = L"commdlg_help";

UINT wBrowseHelp = WM_USER; /* Set to an unused value */

const CHAR szGetOpenFileName[] = "GetOpenFileNameW";

/* the defines below should be in windows.h */

/* Dialog window class */
#define WC_DIALOG       (MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA  30


/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT   0
#define DWL_DLGPROC     4
#define DWL_USER        8

/* For Long File Name support */
#define MAX_EXTENSION 64

typedef struct {
   LPWSTR lpszExe;
   LPWSTR lpszPath;
   LPWSTR lpszName;
} FINDEXE_PARAMS, FAR *LPFINDEXE_PARAMS;

typedef INT (APIENTRY *LPFNGETOPENFILENAME)(LPOPENFILENAME);

VOID APIENTRY
CheckEscapesW(LPWSTR szFile, DWORD cch)
{
   LPWSTR szT;
   WCHAR *p, *pT;

   for (p = szFile; *p; p++) {

       switch (*p) {
           case WCHAR_SPACE:
           case WCHAR_COMMA:
           case WCHAR_SEMICOLON:
           case WCHAR_HAT:
           case WCHAR_QUOTE:
           {
               // this path contains an annoying character
               if (cch < (wcslen(szFile) + 2)) {
                   return;
               }
               szT = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));
               if (!szT) {
                   return;
               }
               StringCchCopy(szT, cch, szFile); // ok to truncate, we checked size above
               p = szFile;
               *p++ = WCHAR_QUOTE;
               for (pT = szT; *pT; ) {
                    *p++ = *pT++;
               }
               *p++ = WCHAR_QUOTE;
               *p = WCHAR_NULL;
               LocalFree(szT);
               return;
            }
        }
    }
}

VOID APIENTRY
CheckEscapesA(LPSTR lpFileA, DWORD cch)
{
   if (lpFileA && *lpFileA) {
      LPWSTR lpFileW;

      lpFileW = (LPWSTR)LocalAlloc(LPTR, (cch * sizeof(WCHAR)));
      if (!lpFileW) {
         return;
      }

      SHAnsiToUnicode(lpFileA, lpFileW, cch);

      CheckEscapesW(lpFileW, cch);

      try {
         SHUnicodeToAnsi(lpFileW, lpFileA, cch);
      } except(EXCEPTION_EXECUTE_HANDLER) {
         LocalFree(lpFileW);
         return;
      }

      LocalFree(lpFileW);
   }

   return;
}

//----------------------------------------------------------------------------
// FindExeDlgProc was mistakenly exported in the original NT SHELL32.DLL when
// it didn't need to be (dlgproc's, like wndproc's don't need to be exported
// in the 32-bit world).  In order to maintain loadability of some app
// which might have linked to it, we stub it here.  If some app ended up really
// using it, then we'll look into a specific fix for that app.
//
// -BobDay
//
BOOL_PTR WINAPI FindExeDlgProc( HWND hDlg, UINT wMsg, WPARAM wParam, LONG lParam )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\enumuicommand.cpp ===
#include "shellprv.h"
#include "enumuicommand.h"
#include "datautil.h"


HRESULT CWVTASKITEM::_get_String(const WVTASKITEM* pTask,
                                 DWORD dwIndex,
                                 LPWSTR * ppsz,
                                 DWORD cchMin,
                                 BOOL bIsIcon)
{
    HRESULT hr;
    DWORD cchIcon = (unsigned)(lstrlen(pTask->pszDllName) + 9); // 9 = comma + minus + 2*65535 + \0
    DWORD cch = bIsIcon
        ? cchIcon                   // "DLL,-0" string format required for loading icons from DLL resource
        : max(cchIcon + 1, cchMin); // "@DLL,-0" string format required for loading strings from DLL resource
    LPWSTR psz = (LPWSTR)CoTaskMemAlloc(cch * sizeof(WCHAR));
    if (psz)
    {
        if (bIsIcon)
        {
            hr = StringCchPrintf(psz, cch, L"%s,-%u", pTask->pszDllName, dwIndex);
        }
        else
        {
            hr = StringCchPrintf(psz, cch, L"@%s,-%u", pTask->pszDllName, dwIndex);
            if (SUCCEEDED(hr))
            {
                hr = SHLoadIndirectString(psz, psz, cch, NULL);
            }
        }
        if (FAILED(hr))
        {
            CoTaskMemFree(psz);
            psz = NULL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    *ppsz = psz;
    return hr;
}

#define SS_UNKNOWN      0
#define SS_NOTSUPPORTED 1
#define SS_NONE         2
#define SS_FILE         3
#define SS_FOLDER       4
#define SS_MULTI        5
DWORD CWVTASKITEM::_GetSelectionState(const WVTASKITEM* pTask, IShellItemArray *psiItemArray)
{
    DWORD dwSelectionState;
    
    DWORD cItems = 0;

    if (psiItemArray)
    {
        if (FAILED(psiItemArray->GetCount(&cItems)))
        {
            cItems = 0;
        }
    }

    switch (cItems)
    {
    case 0:
        dwSelectionState = SS_NONE;
        break;
    case 1:
        {
            DWORD dwAttribs = 0;

            if (psiItemArray)
            {
                if (FAILED(psiItemArray->GetAttributes(SIATTRIBFLAGS_AND, SFGAO_FOLDER|SFGAO_STREAM,&dwAttribs)))
                {
                    dwAttribs = 0;
                }
            }

            switch (dwAttribs)
            {
            case SFGAO_FOLDER:
                dwSelectionState = SS_FOLDER;
                break;
            case SFGAO_FOLDER|SFGAO_STREAM:
                // zip and cab files are the only things that get here.
                // we'll call them files unless somebody has a better idea
                // (SS_MULTI has plurality that sounds funny).
                // fall through
            default:
                dwSelectionState = SS_FILE;
                break;
            }
        }
        break;
    default:
        dwSelectionState = SS_MULTI;
        break;
    }

    if ((SS_NONE == dwSelectionState && 0 == pTask->dwTitleIndexNoSelection) ||
        (SS_FILE == dwSelectionState && 0 == pTask->dwTitleIndexFileSelected) ||
        (SS_FOLDER == dwSelectionState && 0 == pTask->dwTitleIndexFolderSelected) ||
        (SS_MULTI == dwSelectionState && 0 == pTask->dwTitleIndexMultiSelected))
    {
        dwSelectionState = SS_NOTSUPPORTED;
    }

    return dwSelectionState;
}

HRESULT CWVTASKITEM::get_Name(const WVTASKITEM* pTask, IShellItemArray *psiItemArray, LPWSTR *ppszName)
{
    DWORD dwSelState = _GetSelectionState(pTask, psiItemArray);
    switch (dwSelState)
    {
    case SS_NONE:   return _get_String(pTask, pTask->dwTitleIndexNoSelection,    ppszName, MAX_PATH, FALSE);
    case SS_FILE:   return _get_String(pTask, pTask->dwTitleIndexFileSelected,   ppszName, MAX_PATH, FALSE);
    case SS_FOLDER: return _get_String(pTask, pTask->dwTitleIndexFolderSelected, ppszName, MAX_PATH, FALSE);
    case SS_MULTI:  return _get_String(pTask, pTask->dwTitleIndexMultiSelected,  ppszName, MAX_PATH, FALSE);
    }
    *ppszName = NULL;
    return E_NOTIMPL;
}
HRESULT CWVTASKITEM::get_Icon(const WVTASKITEM* pTask, IShellItemArray *psiItemArray, LPWSTR *ppszIcon)
{
    return _get_String(pTask, pTask->dwIconIndex, ppszIcon, 0, TRUE);
}
HRESULT CWVTASKITEM::get_Tooltip(const WVTASKITEM* pTask, IShellItemArray *psiItemArray, LPWSTR *ppszInfotip)
{
    return _get_String(pTask, pTask->dwTooltipIndex, ppszInfotip, INFOTIPSIZE, FALSE);
}

HRESULT CWVTASKITEM::get_CanonicalName(const WVTASKITEM* pTask, GUID* pguidCommandName)
{
    *pguidCommandName = *(pTask->pguidCanonicalName);
    return S_OK;
}
HRESULT CWVTASKITEM::get_State(const WVTASKITEM* pTask, IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    HRESULT hr = S_OK;

    *puisState = UIS_DISABLED;

    if (_GetSelectionState(pTask, psiItemArray) != SS_NOTSUPPORTED)
    {
        if (pTask->pfn_get_State)
            hr = pTask->pfn_get_State(pv, psiItemArray, fOkToBeSlow, puisState);
        else
            *puisState = UIS_ENABLED;
    }

    return hr;
}
HRESULT CWVTASKITEM::Invoke(const WVTASKITEM* pTask, IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    return pTask->pfn_Invoke(pv, psiItemArray, pbc);
}



class CUIElement : public CWVTASKITEM, public IUIElement
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    // IUIElement
    STDMETHODIMP get_Name(IShellItemArray *psiItemArray, LPWSTR *ppszName) {return CWVTASKITEM::get_Name(_pTask, psiItemArray, ppszName);}
    STDMETHODIMP get_Icon(IShellItemArray *psiItemArray, LPWSTR *ppszIcon) {return CWVTASKITEM::get_Icon(_pTask, psiItemArray, ppszIcon);}
    STDMETHODIMP get_Tooltip(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip) {return CWVTASKITEM::get_Tooltip(_pTask, psiItemArray, ppszInfotip);}

    friend HRESULT Create_IUIElement(const WVTASKITEM* pwvti, IUIElement**ppuie);

protected:
    CUIElement(const WVTASKITEM* pTask) { _cRef = 1; _pTask=pTask; }
    ~CUIElement() {}

    LONG              _cRef;
    const WVTASKITEM* _pTask;
};

HRESULT Create_IUIElement(const WVTASKITEM* pwvti, IUIElement**ppuie)
{
    HRESULT hr;

    if (NULL!=pwvti)
    {
        CUIElement* p = new CUIElement(pwvti);
        if (p)
        {
            hr = p->QueryInterface(IID_PPV_ARG(IUIElement, ppuie));
            p->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *ppuie = NULL;
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "Create_IUIElement: caller passed in bad pwvti.");

        hr = E_INVALIDARG;
        *ppuie = NULL;
    }
    return hr;
}

HRESULT CUIElement::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CUIElement, IUIElement),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}
ULONG CUIElement::AddRef()
{
    return InterlockedIncrement(&_cRef);
}
ULONG CUIElement::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


class CUICommand : public CUIElement, public IUICommand
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef() { return CUIElement::AddRef(); }
    STDMETHODIMP_(ULONG) Release() { return CUIElement::Release(); }
    // IUICommand
    STDMETHODIMP get_Name(IShellItemArray *psiItemArray, LPWSTR *ppszName) { return CUIElement::get_Name(psiItemArray, ppszName); }
    STDMETHODIMP get_Icon(IShellItemArray *psiItemArray, LPWSTR *ppszIcon) { return CUIElement::get_Icon(psiItemArray, ppszIcon); }
    STDMETHODIMP get_Tooltip(IShellItemArray *psiItemArray, LPWSTR *ppszInfotip) { return CUIElement::get_Tooltip(psiItemArray, ppszInfotip); }
    STDMETHODIMP get_CanonicalName(GUID* pguidCommandName) { return CWVTASKITEM::get_CanonicalName(_pTask, pguidCommandName); }
    STDMETHODIMP get_State(IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState) { return CWVTASKITEM::get_State(_pTask, _pv, psiItemArray, fOkToBeSlow, puisState); }
    STDMETHODIMP Invoke(IShellItemArray *psiItemArray, IBindCtx *pbc) { return CWVTASKITEM::Invoke(_pTask, _pv, psiItemArray, pbc); }

    friend HRESULT Create_IUICommand(IUnknown* pv, const WVTASKITEM* pwvti, IUICommand**ppuic);

private:
    CUICommand(IUnknown* pv, const WVTASKITEM* pTask);
    ~CUICommand();

    IUnknown* _pv;
};

HRESULT Create_IUICommand(IUnknown* pv, const WVTASKITEM* pwvti, IUICommand**ppuic)
{
    HRESULT hr;

    if (NULL!=pwvti)
    {
        CUICommand* p = new CUICommand(pv, pwvti);
        if (p)
        {
            hr = p->QueryInterface(IID_PPV_ARG(IUICommand, ppuic));
            p->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *ppuic = NULL;
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "Create_IUICommand: caller passed in bad pwvti.");

        hr = E_INVALIDARG;
        *ppuic = NULL;
    }

    return hr;
}

CUICommand::CUICommand(IUnknown* pv, const WVTASKITEM* pTask)
    : CUIElement(pTask)
{
    _pv = pv;
    if (_pv)
        _pv->AddRef();
}
CUICommand::~CUICommand()
{
    if (_pv)
        _pv->Release();
}

HRESULT CUICommand::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CUICommand, IUICommand),
        QITABENTMULTI(CUICommand, IUIElement, IUICommand),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

class CEnumUICommand : public IEnumUICommand
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    // IEnumUICommand
    STDMETHODIMP Next(ULONG celt, IUICommand** pUICommand, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumUICommand **ppenum);

    friend HRESULT Create_IEnumUICommandWithArray(IUnknown *pv, const WVTASKITEM* rgwvti, UINT cwvti, IUICommand** rguiCommand, UINT cuiCommand, IEnumUICommand**ppenum);

private:
    CEnumUICommand(IUnknown *pv, const WVTASKITEM* rgwvti, ULONG cwvti, IUICommand** rguiCommand, UINT cuiCommand);
    ~CEnumUICommand();

    LONG              _cRef;
    IUnknown*         _pv;
    const WVTASKITEM* _rgwvti;
    ULONG             _cItems;
    IUICommand**      _prguiCommand;
    ULONG             _cuiCommand;
    ULONG             _ulIndex;
};

HRESULT Create_IEnumUICommandWithArray(IUnknown *pv, const WVTASKITEM* rgwvti, UINT cwvti, IUICommand** rguiCommand, UINT cuiCommand, IEnumUICommand**ppenum)
{
    HRESULT hr;

    if (NULL!=rgwvti)
    {
        CEnumUICommand* p = new CEnumUICommand(pv, rgwvti, cwvti, rguiCommand, cuiCommand);
        if (p)
        {
            hr = p->QueryInterface(IID_PPV_ARG(IEnumUICommand, ppenum));
            p->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *ppenum = NULL;
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "Create_IEnumUICommand: caller passed in bad pwvti.");

        hr = E_INVALIDARG;
        *ppenum = NULL;
    }

    return hr;
}

HRESULT Create_IEnumUICommand(IUnknown *pv, const WVTASKITEM* rgwvti, UINT cwvti, IEnumUICommand**ppenum)
{
    return Create_IEnumUICommandWithArray(pv, rgwvti, cwvti, NULL, 0, ppenum);
}

CEnumUICommand::CEnumUICommand(IUnknown *pv, const WVTASKITEM* rgwvti, ULONG cwvti, IUICommand** rguiCommand, UINT cuiCommand)
{
    if (pv)
    {
        _pv = pv;
        _pv->AddRef();
    }

    _rgwvti = rgwvti;
    _cItems = cwvti;

    if (cuiCommand)
    {
        _prguiCommand = (IUICommand**)LocalAlloc(LPTR, cuiCommand*sizeof(IUICommand*));
        if (_prguiCommand)
        {
            for (UINT i = 0 ; i < cuiCommand && rguiCommand[i]; i++)
            {
                _prguiCommand[i] = rguiCommand[i];
                _prguiCommand[i]->AddRef();
            }
            _cuiCommand = i;
        }
    }

    _cRef = 1;
}
CEnumUICommand::~CEnumUICommand()
{
    if (_pv)
        _pv->Release();

    if (_prguiCommand)
    {
        for (UINT i = 0 ; i < _cuiCommand ; i++)
            _prguiCommand[i]->Release();
        LocalFree(_prguiCommand);
    }
}

HRESULT CEnumUICommand::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CEnumUICommand, IEnumUICommand),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}
ULONG CEnumUICommand::AddRef()
{
    return InterlockedIncrement(&_cRef);
}
ULONG CEnumUICommand::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CEnumUICommand::Next(ULONG celt, IUICommand** ppUICommand, ULONG *pceltFetched)
{
    HRESULT hr;

    if (_ulIndex < _cItems)
    {
        hr = Create_IUICommand(_pv, &_rgwvti[_ulIndex++], ppUICommand);
    }
    else if (_ulIndex < _cItems + _cuiCommand)
    {
        *ppUICommand = _prguiCommand[_ulIndex++ - _cItems];
        (*ppUICommand)->AddRef();
        hr = S_OK;
    }
    else
    {
        *ppUICommand = NULL;
        hr = S_FALSE;
    }
    
    if (pceltFetched)
        *pceltFetched = (hr == S_OK) ? 1 : 0;

    return hr;
}

HRESULT CEnumUICommand::Skip(ULONG celt)
{
    _ulIndex = min(_cItems, _ulIndex+celt);
    return S_OK;
}

HRESULT CEnumUICommand::Reset()
{
    _ulIndex = 0;
    return S_OK;
}

HRESULT CEnumUICommand::Clone(IEnumUICommand **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\exec.c ===
#include "shellprv.h"
#pragma  hdrstop

BOOL _CopyCommand(LPCTSTR pszCommand, LPCTSTR pszDir, LPTSTR pszOut, DWORD cchOut)
{
    BOOL fCopyBack = TRUE;
    BOOL fRet = TRUE;
    // if it does not have quotes, try unquoted name to see if that works...
    if (pszCommand[0] != TEXT('"'))
    {
        if (UrlIs(pszCommand, URLIS_URL))
        {
            //  urls never have params...
            fCopyBack = fRet = FALSE;
            lstrcpyn(pszOut, pszCommand, cchOut);
        }
        else if (StrChr(pszCommand, TEXT(' ')))
        {
            lstrcpyn(pszOut, pszCommand, cchOut);
            PathQualifyDef(pszOut, pszDir, 0);

            // Check for possible existence of arguments
            if (PathFileExistsAndAttributes(pszOut, NULL))
            {
                fCopyBack = fRet = FALSE;
                
            }
        }
        else
            fRet = FALSE;
    }

    //  we need to put the original command for args parsing
    if (fCopyBack)
        lstrcpyn(pszOut, pszCommand, cchOut);

    return fRet;
}

BOOL _QualifyWorkingDir(LPCTSTR pszPath, LPTSTR pszDir, DWORD cchDir)
{
    // special case to make sure the working dir gets set right:
    //   1) no working dir specified
    //   2) a drive or a root path, or a relative path specified
    // derive the working dir from the qualified path. this is to make
    // sure the working dir for setup programs "A:setup" is set right

    if (StrChr(pszPath, TEXT('\\')) || StrChr(pszPath, TEXT(':')))
    {
        // build working dir based on qualified path
        lstrcpyn(pszDir, pszPath, cchDir);
        PathQualifyDef(pszDir, NULL, PQD_NOSTRIPDOTS);
        PathRemoveFileSpec(pszDir);
        return TRUE;
    }

    return FALSE;
}
    
// Run the thing, return TRUE if everything went OK
BOOL ShellExecCmdLine(HWND hwnd, LPCTSTR pszCommand, LPCTSTR pszDir,
        int nShow, LPCTSTR pszTitle, DWORD dwFlags)
{
    TCHAR szWD[MAX_PATH];
    TCHAR szFileName[MAX_PATH];
    LPTSTR pszArgs;
    SHELLEXECUTEINFO ei = {0};

    if (pszDir && *pszDir == TEXT('\0'))
        pszDir = NULL;

    if (_CopyCommand(pszCommand, pszDir, szFileName, SIZECHARS(szFileName)))
    {
        //  there might be args in that command
        pszArgs = PathGetArgs(szFileName);
        if (*pszArgs)
            *(pszArgs - 1) = TEXT('\0');
    }
    else
        pszArgs = NULL;

    PathUnquoteSpaces(szFileName);

    // this needs to be here.  app installs rely on the current directory
    // to be the directory with the setup.exe 
    if (!UrlIs(szFileName, URLIS_URL) 
    && ((dwFlags & SECL_USEFULLPATHDIR) || !pszDir))
    {
        if (_QualifyWorkingDir(szFileName, szWD, SIZECHARS(szWD)))
            pszDir = szWD;
    }

    FillExecInfo(ei, hwnd, NULL, szFileName, pszArgs, pszDir, nShow);
    ei.fMask = SEE_MASK_FLAG_DDEWAIT | SEE_MASK_DOENVSUBST;

    if (dwFlags & SECL_NO_UI)
        ei.fMask |= SEE_MASK_FLAG_NO_UI;

    if (dwFlags & SECL_SEPARATE_VDM)
        ei.fMask |= SEE_MASK_FLAG_SEPVDM;

    if (dwFlags & SECL_LOG_USAGE)
        ei.fMask |= SEE_MASK_FLAG_LOG_USAGE;

    return ShellExecuteEx(&ei);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\execute.cpp ===
#include "shellprv.h"
#include "shlexec.h"
#include <newexe.h>
#include <appmgmt.h>
#include "ids.h"
#include <shstr.h>
#include "pidl.h"
#include "apithk.h"     // for TermsrvAppInstallMode()
#include "fstreex.h"
#include "uemapp.h"
#include "views.h"      // for SHRunControlPanelEx
#include "control.h"    // for MakeCPLCommandLine, etc
#include <wincrui.h>    // for CredUIInitControls

#include <winsafer.h>   // for ComputeAccessTokenFromCodeAuthzLevel, etc
#include <winsaferp.h>  // for Saferi APIs
#include <softpub.h>    // for WinVerifyTrust constants

#include <lmcons.h>     // for UNLEN (max username length), GNLEN (max groupname length), PWLEN (max password length)

#define DM_MISC     0           // miscellany

#define SZWNDCLASS          TEXT("WndClass")
#define SZTERMEVENT         TEXT("TermEvent")

typedef PSHCREATEPROCESSINFOW PSHCREATEPROCESSINFO;

// stolen from sdk\inc\winbase.h
#define LOGON_WITH_PROFILE              0x00000001

#define IntToHinst(i)     IntToPtr_(HINSTANCE, i)

// the timer id for the kill this DDE window...
#define DDE_DEATH_TIMER_ID  0x00005555

// the timeout value (180 seconds) for killing a dead dde window...
#define DDE_DEATH_TIMEOUT   (1000 * 180)

//  timeout for conversation window terminating with us...
#define DDE_TERMINATETIMEOUT  (10 * 1000)

#define SZCONV            TEXT("ddeconv")
#define SZDDEEVENT        TEXT("ddeevent")

#define PEMAGIC         ((WORD)'P'+((WORD)'E'<<8))

void *g_pfnWowShellExecCB = NULL;

class CEnvironmentBlock
{
public:
    ~CEnvironmentBlock() { if (_pszBlock) LocalFree(_pszBlock); }

    void SetToken(HANDLE hToken) { _hToken = hToken; }
    void *GetCustomBlock() { return _pszBlock; }
    HRESULT SetVar(LPCWSTR pszVar, LPCWSTR pszValue);
    HRESULT AppendVar(LPCWSTR pszVar, WCHAR chDelimiter, LPCWSTR pszValue);
private:  //  methods
    HRESULT _InitBlock(DWORD cchNeeded);
    DWORD _BlockLen(LPCWSTR pszEnv);
    DWORD _BlockLenCached();
    BOOL _FindVar(LPCWSTR pszVar, DWORD cchVar, LPWSTR *ppszBlockVar);

private:  //  members
    HANDLE _hToken;
    LPWSTR _pszBlock;
    DWORD _cchBlockSize;
    DWORD _cchBlockLen;
};

typedef enum
{
    CPT_FAILED      = -1,
    CPT_NORMAL      = 0,
    CPT_ASUSER,
    CPT_SANDBOX,
    CPT_INSTALLTS,
    CPT_WITHLOGON,
    CPT_WITHLOGONADMIN,
    CPT_WITHLOGONCANCELLED,
} CPTYPE;

typedef enum {
    TRY_RETRYASYNC      = -1,     //  stop execution (complete on async thread)
    TRY_STOP            = 0,      //  stop execution (completed or failed)
    TRY_CONTINUE,       //  continue exec (did something useful)
    TRY_CONTINUE_UNHANDLED, //  continue exec (did nothing)
} TRYRESULT;

#define KEEPTRYING(tr)      (tr >= TRY_CONTINUE ? TRUE : FALSE)
#define STOPTRYING(tr)      (tr <= TRY_STOP ? TRUE : FALSE)

class CShellExecute
{
public:
    CShellExecute();
    STDMETHODIMP_(ULONG) AddRef()
        {
            return InterlockedIncrement(&_cRef);
        }

    STDMETHODIMP_(ULONG) Release()
        {
            ASSERT( 0 != _cRef );
            ULONG cRef = InterlockedDecrement(&_cRef);
            if ( 0 == cRef )
            {
                delete this;
            }
            return cRef;
        }

    void ExecuteNormal(LPSHELLEXECUTEINFO pei);
    DWORD Finalize(LPSHELLEXECUTEINFO pei);

    BOOL Init(PSHCREATEPROCESSINFO pscpi);
    void ExecuteProcess(void);
    DWORD Finalize(PSHCREATEPROCESSINFO pscpi);

protected:
    ~CShellExecute();
    // default inits
    HRESULT _Init(LPSHELLEXECUTEINFO pei);

    //  member init methods
    TRYRESULT _InitAssociations(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl);
    HRESULT _InitClassAssociations(LPCTSTR pszClass, HKEY hkClass, DWORD mask);
    HRESULT _InitShellAssociations(LPCTSTR pszFile, LPCITEMIDLIST pidl);
    void _SetMask(ULONG fMask);
    void _SetWorkingDir(LPCTSTR pszIn);
    void _SetFile(LPCTSTR pszIn, BOOL fFileAndUrl);
    void _SetFileAndUrl();
    BOOL _SetDDEInfo(void);
    TRYRESULT _MaybeInstallApp(BOOL fSync);
    TRYRESULT _ShouldRetryWithNewClassKey(BOOL fSync);
    TRYRESULT _SetDarwinCmdTemplate(BOOL fSync);
    BOOL _SetAppRunAsCmdTemplate(void);
    TRYRESULT _SetCmdTemplate(BOOL fSync);
    BOOL _FileIsApp();
    BOOL _SetCommand(void);
    void _SetStartup(LPSHELLEXECUTEINFO pei);
    IBindCtx *_PerfBindCtx();
    TRYRESULT _PerfPidl(LPCITEMIDLIST *ppidl);

    //  utility methods
    HRESULT _QueryString(ASSOCF flags, ASSOCSTR str, LPTSTR psz, DWORD cch);
    BOOL _CheckForRegisteredProgram();
    BOOL _ExecMayCreateProcess(LPCTSTR *ppszNewEnvString);
    HRESULT _BuildEnvironmentForNewProcess(LPCTSTR pszNewEnvString);
    void _FixActivationStealingApps(HWND hwndOldActive, int nShow);
    DWORD _GetCreateFlags(ULONG fMask);
    BOOL _Resolve(LPCITEMIDLIST *ppidl);

    //  DDE stuff
    HWND _GetConversationWindow(HWND hwndDDE);
    HWND _CreateHiddenDDEWindow(HWND hwndParent);
    HGLOBAL _CreateDDECommand(int nShow, BOOL fLFNAware, BOOL fNative);
    void _DestroyHiddenDDEWindow(HWND hwnd);
    BOOL _TryDDEShortCircuit(HWND hwnd, HGLOBAL hMem, int nShow);
    BOOL _PostDDEExecute(HWND hwndOurs, HWND hwndTheirs, HGLOBAL hDDECommand, HANDLE hWait);
    BOOL _DDEExecute(BOOL fWillRetry,
                    HWND hwndParent,
                    int   nShowCmd,
                    BOOL fWaitForDDE);

    // exec methods
    TRYRESULT _TryHooks(LPSHELLEXECUTEINFO pei);
    TRYRESULT _TryValidateUNC(LPTSTR pszFile, LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl);
    void _DoExecCommand(void);
    void _NotifyShortcutInvoke();
    TRYRESULT _TryExecDDE(void);
    TRYRESULT _ZoneCheckFile(PCWSTR pszFile);
    TRYRESULT _VerifyZoneTrust(PCWSTR pszFile);
    TRYRESULT _VerifySaferTrust(PCWSTR pszFile);
    TRYRESULT _VerifyExecTrust(LPSHELLEXECUTEINFO pei);
    TRYRESULT _TryExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl);
    TRYRESULT _DoExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl);
    BOOL _ShellExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidlExec);
    TRYRESULT _TryInvokeApplication(BOOL fSync);

    //  uninit/error handling methods
    DWORD _FinalMapError(HINSTANCE UNALIGNED64 *phinst);
    BOOL _ReportWin32(DWORD err);
    BOOL _ReportHinst(HINSTANCE hinst);
    DWORD _MapHINSTToWin32Err(HINSTANCE se_err);
    HINSTANCE _MapWin32ErrToHINST(UINT errWin32);

    TRYRESULT _TryWowShellExec(void);
    TRYRESULT _RetryAsync();
    DWORD  _InvokeAppThreadProc();

    static DWORD WINAPI s_InvokeAppThreadProc(void *pv);

    //
    // PRIVATE MEMBERS
    //
    LONG _cRef;
    TCHAR _szFile[INTERNET_MAX_URL_LENGTH];
    TCHAR _szWorkingDir[MAX_PATH];
    TCHAR _szCommand[INTERNET_MAX_URL_LENGTH];
    TCHAR _szCmdTemplate[INTERNET_MAX_URL_LENGTH];
    TCHAR _szDDECmd[MAX_PATH];
    TCHAR _szApplication[MAX_PATH];
    TCHAR _szPolicyApp[MAX_PATH];
    TCHAR _szAppFriendly[MAX_PATH];
    TCHAR _szUrl[INTERNET_MAX_URL_LENGTH];
    DWORD _dwCreateFlags;
    STARTUPINFO _startup;
    int _nShow;
    UINT _uConnect;
    PROCESS_INFORMATION _pi;

    //  used only within restricted scope
    //  to avoid stack usage;
    WCHAR _wszTemp[INTERNET_MAX_URL_LENGTH];
    TCHAR _szTemp[MAX_PATH];

    //  we always pass a UNICODE verb to the _pqa
    WCHAR       _wszVerb[MAX_PATH];
    LPCWSTR     _pszQueryVerb;

    LPCTSTR    _lpParameters;
    LPTSTR     _pszAllocParams;
    LPCTSTR    _lpClass;
    LPCTSTR    _lpTitle;
    LPTSTR     _pszAllocTitle;
    LPCITEMIDLIST _lpID;
    SFGAOF      _sfgaoID;
    LPITEMIDLIST _pidlFree;
    ATOM       _aApplication;
    ATOM       _aTopic;
    LPITEMIDLIST _pidlGlobal;
    IQueryAssociations *_pqa;

    HWND _hwndParent;
    LPSECURITY_ATTRIBUTES _pProcAttrs;
    LPSECURITY_ATTRIBUTES _pThreadAttrs;
    HANDLE _hUserToken;
    HANDLE _hCloseToken;
    CEnvironmentBlock _envblock;
    CPTYPE _cpt;

    //  error state
    HINSTANCE  _hInstance; // hinstance value should only be set with ReportHinst
    DWORD      _err;   //  win32 error value should only be set with ReportWin32

    // FLAGS
    BOOL _fNoUI;                         //  dont show any UI
    BOOL _fUEM;                          //  fire UEM events
    BOOL _fDoEnvSubst;                   // do environment substitution on paths
    BOOL _fUseClass;
    BOOL _fNoQueryClassStore;            // blocks calling darwins class store
    BOOL _fClassStoreOnly;
    BOOL _fIsUrl;                        //_szFile is actually an URL
    BOOL _fActivateHandler;
    BOOL _fDDEInfoSet;
    BOOL _fDDEWait;
    BOOL _fNoExecPidl;
    BOOL _fNoResolve;                    // unnecessary to resolve this path
    BOOL _fAlreadyQueriedClassStore;     // have we already queried the NT5 class store?
    BOOL _fInheritHandles;
    BOOL _fIsNamespaceObject;            // is namespace object like ::{GUID}, must pidlexec
    BOOL _fWaitForInputIdle;
    BOOL _fUseNullCWD;                   // should we pass NULL as the lpCurrentDirectory param to _SHCreateProcess?
    BOOL _fInvokeIdList;
    BOOL _fAsync;                        // shellexec() switched
};

CShellExecute::CShellExecute() : _cRef(1)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::SHEX Created [%X]", this);
}

CShellExecute::~CShellExecute()
{
    if (_hCloseToken)
        CloseHandle(_hCloseToken);

    // Clean this up if the exec failed
    if (_err != ERROR_SUCCESS && _pidlGlobal)
        SHFreeShared((HANDLE)_pidlGlobal,GetCurrentProcessId());

    if (_aTopic)
        GlobalDeleteAtom(_aTopic);
    if (_aApplication)
        GlobalDeleteAtom(_aApplication);

    if (_pqa)
        _pqa->Release();

    if (_pi.hProcess)
        CloseHandle(_pi.hProcess);

    if (_pi.hThread)
        CloseHandle(_pi.hThread);

    if (_pszAllocParams)
        LocalFree(_pszAllocParams);

    if (_pszAllocTitle)
        LocalFree(_pszAllocTitle);

    ILFree(_pidlFree);

    TraceMsg(TF_SHELLEXEC, "SHEX::SHEX deleted [%X]", this);
}

void CShellExecute::_SetMask(ULONG fMask)
{
    _fDoEnvSubst = (fMask & SEE_MASK_DOENVSUBST);
    _fNoUI       = (fMask & SEE_MASK_FLAG_NO_UI);
    _fUEM        = (fMask & SEE_MASK_FLAG_LOG_USAGE);
    _fNoQueryClassStore = (fMask & SEE_MASK_NOQUERYCLASSSTORE) || !IsOS(OS_DOMAINMEMBER);
    _fDDEWait = fMask & SEE_MASK_FLAG_DDEWAIT;
    _fWaitForInputIdle = fMask & SEE_MASK_WAITFORINPUTIDLE;
    _fUseClass   = _UseClassName(fMask) || _UseClassKey(fMask);
    _fInvokeIdList = _InvokeIDList(fMask);

    _dwCreateFlags = _GetCreateFlags(fMask);
    _uConnect = fMask & SEE_MASK_CONNECTNETDRV ? VALIDATEUNC_CONNECT : 0;
    if (_fNoUI)
        _uConnect |= VALIDATEUNC_NOUI;

    // must be off for this condition to pass.

    // PARTIAL ANSWER (reinerf): the SEE_MASK_FILEANDURL has to be off
    // so we can wait until we find out what the associated App is and query
    // to find out whether they want the the cache filename or the URL name passed
    // on the command line.
#define NOEXECPIDLMASK   (SEE_MASK_NOCLOSEPROCESS | SEE_MASK_FLAG_DDEWAIT | SEE_MASK_FORCENOIDLIST | SEE_MASK_FILEANDURL)
    _fNoExecPidl = BOOLIFY(fMask & NOEXECPIDLMASK);
}

HRESULT CShellExecute::_Init(LPSHELLEXECUTEINFO pei)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::_Init()");

    _SetMask(pei->fMask);

    _lpParameters = pei->lpParameters;
    _lpID        = (LPITEMIDLIST)((pei->fMask) & SEE_MASK_PIDL ? pei->lpIDList : NULL);
    _lpTitle     = _UseTitleName(pei->fMask) ? pei->lpClass : NULL;


    //  default to TRUE;
    _fActivateHandler = TRUE;

    if (pei->lpVerb && *(pei->lpVerb))
    {
        SHTCharToUnicode(pei->lpVerb, _wszVerb, SIZECHARS(_wszVerb));
        _pszQueryVerb = _wszVerb;

        if (0 == lstrcmpi(pei->lpVerb, TEXT("runas")))
            _cpt = CPT_WITHLOGON;
    }

    _hwndParent = pei->hwnd;

    pei->hProcess = 0;

    _nShow = pei->nShow;

    //  initialize the startup struct
    _SetStartup(pei);

    return S_OK;
}

void CShellExecute::_SetWorkingDir(LPCTSTR pszIn)
{
        //  if we were given a directory, we attempt to use it
    if (pszIn && *pszIn)
    {
        StrCpyN(_szWorkingDir, pszIn, SIZECHARS(_szWorkingDir));
        if (_fDoEnvSubst)
            DoEnvironmentSubst(_szWorkingDir, SIZECHARS(_szWorkingDir));

        //
        // if the passed directory is not valid (after env subst) dont
        // fail, act just like Win31 and use whatever the current dir is.
        //
        // Win31 is stranger than I could imagine, if you pass ShellExecute
        // an invalid directory, it will change the current drive.
        //
        if (!PathIsDirectory(_szWorkingDir))
        {
            if (PathGetDriveNumber(_szWorkingDir) >= 0)
            {
                TraceMsg(TF_SHELLEXEC, "SHEX::_SetWorkingDir() bad directory %s, using %c:", _szWorkingDir, _szWorkingDir[0]);
                PathStripToRoot(_szWorkingDir);
            }
            else
            {
                TraceMsg(TF_SHELLEXEC, "SHEX::_SetWorkingDir() bad directory %s, using current dir", _szWorkingDir);
                GetCurrentDirectory(SIZECHARS(_szWorkingDir), _szWorkingDir);
            }
        }
        else
        {
            goto Done;
        }
    }
    else
    {
        // if we are doing a SHCreateProcessAsUser or a normal shellexecute w/ the "runas" verb, and
        // the caller passed NULL for lpCurrentDirectory then we we do NOT want to fall back and use
        // the CWD because the newly logged on user might not have permissions in the current users CWD.
        // We will have better luck just passing NULL and letting the OS figure it out.
        if (_cpt != CPT_NORMAL)
        {
            _fUseNullCWD = TRUE;
            goto Done;
        }
        else
        {
            GetCurrentDirectory(SIZECHARS(_szWorkingDir), _szWorkingDir);
        }
    }

    //  there are some cases where even CD is bad.
    //  and CreateProcess() will then fail.
    if (!PathIsDirectory(_szWorkingDir))
    {
        GetWindowsDirectory(_szWorkingDir, SIZECHARS(_szWorkingDir));
    }

Done:
    TraceMsg(TF_SHELLEXEC, "SHEX::_SetWorkingDir() pszIn = %s, NewDir = %s", pszIn, _szWorkingDir);

}

inline BOOL _IsNamespaceObject(LPCTSTR psz)
{
    return (psz[0] == L':' && psz[1] == L':' && psz[2] == L'{');
}

void CShellExecute::_SetFile(LPCTSTR pszIn, BOOL fFileAndUrl)
{
    if (pszIn && pszIn[0])
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::_SetFileName() Entered pszIn = %s", pszIn);

        _fIsUrl = UrlIs(pszIn, URLIS_URL);
        StrCpyN(_szFile, pszIn, SIZECHARS(_szFile));
        _fIsNamespaceObject = (!_fInvokeIdList && !_fUseClass && _IsNamespaceObject(_szFile));

        if (_fDoEnvSubst)
            DoEnvironmentSubst(_szFile, SIZECHARS(_szFile));

        if (fFileAndUrl)
        {
            ASSERT(!_fIsUrl);
            // our lpFile points to a string that contains both an Internet Cache
            // File location and the URL name that is associated with that cache file
            // (they are seperated by a single NULL). The application that we are
            // about to execute wants the URL name instead of the cache file, so
            // use it instead.
            int iLength = lstrlen(pszIn);
            LPCTSTR pszUrlPart = &pszIn[iLength + 1];

            if (IsBadStringPtr(pszUrlPart, INTERNET_MAX_URL_LENGTH) || !PathIsURL(pszUrlPart))
            {
                ASSERT(FALSE);
            }
            else
            {
                // we have a vaild URL, so use it
                StrCpyN(_szUrl, pszUrlPart, ARRAYSIZE(_szUrl));
            }
        }
    }
    else
    {
        //  LEGACY - to support shellexec() of directories.
        if (!_lpID)
            StrCpyN(_szFile, _szWorkingDir, SIZECHARS(_szFile));
    }

    PathUnquoteSpaces(_szFile);

    TraceMsg(TF_SHELLEXEC, "SHEX::_SetFileName() exit:  szFile = %s", _szFile);

}

void CShellExecute::_SetFileAndUrl()
{
    TraceMsg(TF_SHELLEXEC, "SHEX::_SetFileAndUrl() enter:  pszIn = %s", _szUrl);

    if (*_szUrl && SUCCEEDED(_QueryString(0, ASSOCSTR_EXECUTABLE, _szTemp, SIZECHARS(_szTemp)))
    &&  DoesAppWantUrl(_szTemp))
    {
        // we have a vaild URL, so use it
        StrCpyN(_szFile, _szUrl, ARRAYSIZE(_szFile));
    }
    TraceMsg(TF_SHELLEXEC, "SHEX::_SetFileAndUrl() exit: szFile = %s",_szFile);

}

//
//  _TryValidateUNC() has queer return values
//
TRYRESULT CShellExecute::_TryValidateUNC(LPTSTR pszFile, LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;

    if (PathIsUNC(pszFile))
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::_TVUNC Is UNC: %s", pszFile);
        // Notes:
        //  SHValidateUNC() returns FALSE if it failed. In such a case,
        //   GetLastError will gives us the right error code.
        //
        if (!(_sfgaoID & SFGAO_FILESYSTEM) && !SHValidateUNC(_hwndParent, pszFile, _uConnect))
        {
            tr = TRY_STOP;
            // Note that SHValidateUNC calls SetLastError() and we need
            // to preserve that so that the caller makes the right decision
            DWORD err = GetLastError();

            if (ERROR_CANCELLED == err)
            {
                // Not a print share, use the error returned from the first call
                // _ReportWin32(ERROR_CANCELLED);
                //  we dont need to report this error, it is the callers responsibility
                //  the caller should GetLastError() on E_FAIL and do a _ReportWin32()
                TraceMsg(TF_SHELLEXEC, "SHEX::_TVUNC FAILED with ERROR_CANCELLED");
            }
            else if (pei && ERROR_NOT_SUPPORTED == err && PathIsUNC(pszFile))
            {
                //
                // Now check to see if it's a print share, if it is, we need to exec as pidl
                //
                //  we only check for print shares when ERROR_NOT_SUPPORTED is returned
                //  from the first call to SHValidateUNC().  this error means that
                //  the RESOURCETYPE did not match the requested.
                //
                // Note: This call should not display "connect ui" because SHValidateUNC()
                //  will already have shown UI if necessary/possible.
                // CONNECT_CURRENT_MEDIA is not used by any provider (per JSchwart)
                //
                if (SHValidateUNC(_hwndParent, pszFile, VALIDATEUNC_NOUI | VALIDATEUNC_PRINT))
                {
                    tr = TRY_CONTINUE;
                    TraceMsg(TF_SHELLEXEC, "SHEX::TVUNC found print share");
                }
                else
                    // need to reset the orginal error ,cuz SHValidateUNC() has set it again
                    SetLastError(err);

            }
        }
        else
        {
            TraceMsg(TF_SHELLEXEC, "SHEX::_TVUNC UNC is accessible");
        }
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::_TVUNC exit: hr = %X", hr);

    switch (tr)
    {
//  TRY_CONTINUE_UNHANDLED  pszFile is not a UNC or is a valid UNC according to the flags
//  TRY_CONTINUE            pszFile is a valid UNC to a print share
//  TRY_STOP                pszFile is a UNC but cannot be validated use GetLastError() to get the real error
        case TRY_CONTINUE:
            //  we got a good UNC
            ASSERT(pei);
            tr = _DoExecPidl(pei, pidl);
            //  if we dont get a pidl we just try something else.
            break;

        case TRY_STOP:
            if (pei)
                _ReportWin32(GetLastError());
            tr = TRY_STOP;
            break;

        default:
            break;
    }

    return tr;
}

HRESULT  _InvokeInProcExec(IContextMenu *pcm, LPSHELLEXECUTEINFO pei)
{
    HRESULT hr = E_OUTOFMEMORY;
    HMENU hmenu = CreatePopupMenu();
    if (hmenu)
    {
        CMINVOKECOMMANDINFOEX ici;
        void * pvFree;
        if (SUCCEEDED(SEI2ICIX(pei, &ici, &pvFree)))
        {
            BOOL fDefVerb (ici.lpVerb == NULL || *ici.lpVerb == 0);
            // This optimization eliminate creating handlers that
            // will not change the default verb
            UINT uFlags = fDefVerb ? CMF_DEFAULTONLY : 0;
            ici.fMask |= CMIC_MASK_FLAG_NO_UI;

            hr = pcm->QueryContextMenu(hmenu, 0, CONTEXTMENU_IDCMD_FIRST, CONTEXTMENU_IDCMD_LAST, uFlags);
            if (SUCCEEDED(hr))
            {
                if (fDefVerb)
                {
                    UINT idCmd = GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0);
                    if (-1 == idCmd)
                    {
                        //  i dont think we should ever get here...
                        ici.lpVerb = (LPSTR)MAKEINTRESOURCE(0);  // best guess
                    }
                    else
                        ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - CONTEXTMENU_IDCMD_FIRST);
                }

                hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);

            }

            if (pvFree)
                LocalFree(pvFree);
        }

        DestroyMenu(hmenu);
    }

    return hr;
}

BOOL CShellExecute::_ShellExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidlExec)
{
    IContextMenu *pcm;
    HRESULT hr = SHGetUIObjectFromFullPIDL(pidlExec, pei->hwnd, IID_PPV_ARG(IContextMenu, &pcm));
    if (SUCCEEDED(hr))
    {
        hr = _InvokeInProcExec(pcm, pei);

        pcm->Release();
    }

    if (FAILED(hr))
    {
        DWORD errWin32 = (HRESULT_FACILITY(hr) == FACILITY_WIN32) ? HRESULT_CODE(hr) : GetLastError();
        if (!errWin32)
            errWin32 = ERROR_ACCESS_DENIED;

        if (errWin32 != ERROR_CANCELLED)
            _ReportWin32(errWin32);
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::_ShellExecPidl() exiting hr = %X", hr);

    return(SUCCEEDED(hr));
}


//
//  BOOL CShellExecute::_DoExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl)
//
//  returns TRUE if a pidl was created, FALSE otherwise
//
TRYRESULT CShellExecute::_DoExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::_DoExecPidl enter: szFile = %s", _szFile);

    LPITEMIDLIST pidlFree = NULL;
    if (!pidl)
        pidl = pidlFree = ILCreateFromPath(_szFile);

    if (pidl)
    {
        //
        //  if _ShellExecPidl() FAILS, it does
        //  Report() for us
        //
        _ShellExecPidl(pei, pidl);

        if (pidlFree)
            ILFree(pidlFree);

        return TRY_STOP;
    }
    else
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::_DoExecPidl() unhandled cuz ILCreateFromPath() failed");

        return TRY_CONTINUE;
    }
}


/*----------------------------------------------------------
Purpose: This function looks up the given file in "HKLM\Software\
         Microsoft\Windows\CurrentVersion\App Paths" to
         see if it has an absolute path registered.

Returns: TRUE if the file has a registered path
         FALSE if it does not or if the provided filename has
               a relative path already


Cond:    !! Side effect: the szFile field may be changed by
         !! this function.

*/
BOOL CShellExecute::_CheckForRegisteredProgram()
{
    TCHAR szTemp[MAX_PATH];
    TraceMsg(TF_SHELLEXEC, "SHEX::CFRP entered");

    // Only supported for files with no paths specified
    if (PathIsFileSpec(_szFile) 
    && PathToAppPath(_szFile, szTemp) 
    && PathResolve(szTemp, NULL, PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS))
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::CFRP Set szFile = %s", szTemp);

        StrCpyN(_szFile, szTemp, ARRAYSIZE(_szFile));
        return TRUE;
    }

    return FALSE;
}

BOOL CShellExecute::_Resolve(LPCITEMIDLIST *ppidl)
{
    // No; get the fully qualified path and add .exe extension
    // if needed
    LPCTSTR rgszDirs[2] =  { _szWorkingDir, NULL };
    const UINT uFlags = PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS | PRF_FIRSTDIRDEF;

    // if the Path is not an URL
    // and the path cant be resolved
    //
    //  PathResolve() now does SetLastError() when we pass VERIFYEXISTS
    //  this means that we can be assure if all these tests fail
    //  that LastError is set.
    //

    //  _CheckForRegisteredProgram() changes _szFile if
    //  there is a registered program in the registry
    //  so we recheck to see if it exists.
    if (!_fNoResolve && !_fIsUrl && !_fIsNamespaceObject &&
        !_CheckForRegisteredProgram())
    {
        if (!PathResolve(_szFile, rgszDirs, uFlags))
        {
            DWORD cchFile = ARRAYSIZE(_szFile);
            if (S_OK != UrlApplyScheme(_szFile, _szFile, &cchFile, URL_APPLY_GUESSSCHEME))
            {
                // No; file not found, bail out
                //
                //  WARNING LEGACY - we must return ERROR_FILE_NOT_FOUND - ZekeL - 14-APR-99
                //  some apps, specifically Netscape Navigator 4.5, rely on this
                //  failing with ERROR_FILE_NOT_FOUND.  so even though PathResolve() does
                //  a SetLastError() to the correct error we cannot propagate that up
                //
                _ReportWin32(ERROR_FILE_NOT_FOUND);
                ASSERT(_err);
                TraceMsg(TF_SHELLEXEC, "SHEX::TryExecPidl FAILED %d", _err);

                return FALSE;
            }
            else
                _fIsUrl = TRUE;
        }
    }

    // _PerfPidl(ppidl);

    return TRUE;
}


//  this is the SAFER exe detection API
//  only use if this is really a file system file
//  and we are planning on using CreateProcess()
TRYRESULT CShellExecute::_VerifySaferTrust(PCWSTR pszFile)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    DWORD dwPolicy, cbPolicy;

    if (_cpt == CPT_NORMAL
    && SaferGetPolicyInformation(
                    SAFER_SCOPEID_MACHINE,
                    SaferPolicyEnableTransparentEnforcement,
                    sizeof(dwPolicy), &dwPolicy, &cbPolicy, NULL)
    && dwPolicy != 0
    && SaferiIsExecutableFileType(pszFile, TRUE)
    && (_pszQueryVerb && !StrCmpIW(_pszQueryVerb, L"open")))
    {
        SAFER_LEVEL_HANDLE hAuthzLevel;
        SAFER_CODE_PROPERTIES codeprop;

        // prepare the code properties struct.
        memset(&codeprop, 0, sizeof(codeprop));
        codeprop.cbSize = sizeof(SAFER_CODE_PROPERTIES);
        codeprop.dwCheckFlags = SAFER_CRITERIA_IMAGEPATH |
                                  SAFER_CRITERIA_IMAGEHASH |
                                  SAFER_CRITERIA_AUTHENTICODE;
        codeprop.ImagePath = pszFile;
        codeprop.dwWVTUIChoice = WTD_UI_NOBAD;
        codeprop.hWndParent = _hwndParent;

        //
        // check if file extension is of executable type, don't care on error
        //

        // evaluate all of the criteria and get the resulting level.
        if (SaferIdentifyLevel(
                         1,              // only 1 element in codeprop[]
                         &codeprop,      // pointer to one-element array
                         &hAuthzLevel,   // receives identified level
                         NULL)) 
        {

            //
            // try to log an event in case level != SAFER_LEVELID_FULLYTRUSTED
            //

            // compute the final restricted token that should be used.
            ASSERT(_hCloseToken == NULL);
            if (SaferComputeTokenFromLevel(
                                     hAuthzLevel,        // identified level restrictions
                                     NULL,               // source token
                                     &_hUserToken,       // resulting restricted token
                                     SAFER_TOKEN_NULL_IF_EQUAL,
                                     NULL)) 
            {
                if (_hUserToken) 
                {
                    _cpt = CPT_ASUSER;
                    //  WARNING - runas is needed to circumvent DDE - ZekeL - 31 -JAN-2001
                    //  we must set runas as the verb so that we make sure
                    //  that we are not using a type that is going to do window reuse
                    //  via DDE (or anything else).  if they dont support runas, then the
                    //  the exec will fail, intentionally.
                    _pszQueryVerb = L"runas";
                    tr = TRY_CONTINUE;
                }
                _hCloseToken = _hUserToken;     // potentially NULL
            } 
            else 
            {
                // TODO: add event logging callback here.
                _ReportWin32(GetLastError());
                SaferRecordEventLogEntry(hAuthzLevel, pszFile, NULL);
                tr = TRY_STOP;
            }

            if (tr != TRY_STOP)
            {
                //  we havent added anything to our log
                //  try to log an event in case level != AUTHZLEVELID_FULLYTRUST ED
                DWORD   dwLevelId;
                DWORD   dwBufferSize;
                if (SaferGetLevelInformation(
                        hAuthzLevel,
                        SaferObjectLevelId,
                        &dwLevelId,
                        sizeof(DWORD),
                        &dwBufferSize)) 
                {

                    if ( dwLevelId != SAFER_LEVELID_FULLYTRUSTED ) 
                    {

                        SaferRecordEventLogEntry(hAuthzLevel,
                                                  pszFile,
                                                  NULL);
                    }
                }
            }

            SaferCloseLevel(hAuthzLevel);
        } 
        else 
        {
            _ReportWin32(GetLastError());
            tr = TRY_STOP;
        }
    }

    return tr;
}

HANDLE _GetSandboxToken()
{
    SAFER_LEVEL_HANDLE hConstrainedAuthz;
    HANDLE hSandboxToken = NULL;

    // right now we always use the SAFER_LEVELID_CONSTRAINED to "sandbox" the process
    if (SaferCreateLevel(SAFER_SCOPEID_MACHINE,
                         SAFER_LEVELID_CONSTRAINED,
                         SAFER_LEVEL_OPEN,
                         &hConstrainedAuthz,
                         NULL))
    {
        if (!SaferComputeTokenFromLevel(
                    hConstrainedAuthz,
                    NULL,
                    &hSandboxToken,
                    0,
                    NULL)) {
            hSandboxToken = NULL;
        }

        SaferCloseLevel(hConstrainedAuthz);
    }

    return hSandboxToken;
}

TRYRESULT CShellExecute::_ZoneCheckFile(PCWSTR pszFile)
{
    TRYRESULT tr = TRY_STOP;
    //  now we need to determine if it is intranet or local zone
    DWORD dwPolicy = 0, dwContext = 0;
    ZoneCheckUrlEx(pszFile, &dwPolicy, sizeof(dwPolicy), &dwContext, sizeof(dwContext),
                URLACTION_SHELL_SHELLEXECUTE, PUAF_ISFILE | PUAF_NOUI, NULL);
    dwPolicy = GetUrlPolicyPermissions(dwPolicy);
    switch (dwPolicy)
    {
    case URLPOLICY_ALLOW:
        tr = TRY_CONTINUE_UNHANDLED;
        //  continue
        break;

    case URLPOLICY_QUERY:
        if (SafeOpenPromptForShellExec(_hwndParent, pszFile))
        {
            tr = TRY_CONTINUE;
        }
        else
        {
            //  user cancelled
            tr = TRY_STOP;
            _ReportWin32(ERROR_CANCELLED);
        }
        
        break;

    case URLPOLICY_DISALLOW:
        tr = TRY_STOP;
        _ReportWin32(ERROR_ACCESS_DENIED);
        break;

    default:
        ASSERT(FALSE);
        break;
    
    }
    return tr;
}

TRYRESULT CShellExecute::_VerifyZoneTrust(PCWSTR pszFile)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    //
    //  pszFile maybe different than _szFile in the case of being invoked by a LNK or URL
    //  in this case we could prompt for either but not both
    //  we only care about the target file's type for determining dangerousness
    //  so that shortcuts to TXT files should never get a prompt.
    //  if (pszFile == internet) prompt(pszFile)
    //  else if (_szFile = internet prompt(_szFile)
    //
    if (AssocIsDangerous(PathFindExtension(_szFile)))
    {
        //  first try 
        tr = _ZoneCheckFile(pszFile);
        if (tr == TRY_CONTINUE_UNHANDLED && pszFile != _szFile)
            tr = _ZoneCheckFile(_szFile);
    }
       
    return tr;
}

TRYRESULT CShellExecute::_VerifyExecTrust(LPSHELLEXECUTEINFO pei)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    if ((_sfgaoID & (SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_STREAM)) == (SFGAO_FILESYSTEM | SFGAO_STREAM))
    {
        //  if this is a FILE, we check for security implications
        //  if fHasLinkName is set, then this invoke originates from an LNK file
        //  the _lpTitle should have the acual path to the LNK.  we want to verify 
        //  our trust of that more than the trust of the target
        PCWSTR pszFile = (pei->fMask & SEE_MASK_HASLINKNAME && _lpTitle) ? _lpTitle : _szFile;
        BOOL fZoneCheck = !(pei->fMask & SEE_MASK_NOZONECHECKS);
        if (fZoneCheck)
        {
            //  630796 - check the env var for policy scripts - ZekeL - 31-MAY-2002
            //  scripts cannot be updated, and they need to be trusted
            //  since a script can call into more scripts without passing
            //  the SEE_MASK_NOZONECHECKS.
            if (GetEnvironmentVariable(L"SEE_MASK_NOZONECHECKS", _szTemp, ARRAYSIZE(_szTemp)))
            {
                fZoneCheck = (0 != StrCmpICW(_szTemp, L"1"));
                ASSERT(!IsProcessAnExplorer());
            }
        }

        if (fZoneCheck)
            tr = _VerifyZoneTrust(pszFile);

        if (tr == TRY_CONTINUE_UNHANDLED)
            tr = _VerifySaferTrust(pszFile);
    }
    return tr;
}

/*----------------------------------------------------------
Purpose: decide whether it is appropriate to TryExecPidl()

Returns: S_OK        if it should _DoExecPidl()
         S_FALSE     it shouldnt _DoExecPidl()
         E_FAIL      ShellExec should quit  Report*() has the real error


Cond:    !! Side effect: the szFile field may be changed by
         !! this function.

*/
TRYRESULT CShellExecute::_TryExecPidl(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    TraceMsg(TF_SHELLEXEC, "SHEX::TryExecPidl entered szFile = %s", _szFile);

    //
    // If we're explicitly given a class then we don't care if the file exists.
    // Just let the handler for the class worry about it, and _TryExecPidl()
    // will return the default of FALSE.
    //

    //  these should never coincide
    RIP(!(_fInvokeIdList && _fUseClass));

    if ((*_szFile || pidl)
    && (!_fUseClass || _fInvokeIdList || _fIsNamespaceObject))
    {
        if (!pidl && !_fNoResolve && !_Resolve(&pidl))
        {
            tr = TRY_STOP;
        }
        
        if (tr == TRY_CONTINUE_UNHANDLED)
        {
            // The optimal execution path is to check for the default
            // verb and exec the pidl.  It is smarter than all this path
            // code (it calls the context menu handlers, etc...)

            if ((!_pszQueryVerb && !(_fNoExecPidl))
            ||  _fIsUrl
            ||  _fInvokeIdList            //  caller told us to!
            ||  _fIsNamespaceObject      //  namespace objects can only be invoked through pidls
            ||  (_sfgaoID & SFGAO_LINK)
            ||  (!pidl && PathIsShortcut(_szFile, -1))) //  to support LNK files and soon URL files
            {
                //  this means that we can tryexecpidl
                TraceMsg(TF_SHELLEXEC, "SHEX::TryExecPidl() succeeded now TEP()");
                tr = _DoExecPidl(pei, pidl);
            }
            else
            {
                TraceMsg(TF_SHELLEXEC, "SHEX::TryExecPidl dont bother");
            }
        }
    }
    else
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::TryExecPidl dont bother");
    }

    return tr;
}

HRESULT CShellExecute::_InitClassAssociations(LPCTSTR pszClass, HKEY hkClass, DWORD mask)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::InitClassAssoc enter: lpClass = %s, hkClass = %X", pszClass, hkClass);

    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &_pqa));
    if (SUCCEEDED(hr))
    {
        if (_UseClassKey(mask))
        {
            hr = _pqa->Init(0, NULL, hkClass, NULL);
        }
        else if (_UseClassName(mask))
        {
            hr = _pqa->Init(0, pszClass, NULL, NULL);
        }
        else
        {
            //  LEGACY - they didnt pass us anything to go on so we default to folder
            //  because of the chaos of the original shellexec() we didnt even notice
            //  when we had nothing to be associated with, and just used
            //  our base key, which turns out to be explorer.
            //  this permitted ShellExecute(NULL, "explore", NULL, NULL, NULL, SW_SHOW);
            //  to succeed.  in order to support this, we will fall back to it here.
            hr = _pqa->Init(0, L"Folder", NULL, NULL);
        }
    }

    return hr;
}

HRESULT CShellExecute::_InitShellAssociations(LPCTSTR pszFile, LPCITEMIDLIST pidl)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::InitShellAssoc enter: pszFile = %s, pidl = %X", pszFile, pidl);

    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlFree = NULL;
    if (*pszFile)
    {
        if (!pidl)
        {
            hr = SHILCreateFromPath(pszFile, &pidlFree, NULL);

            if (SUCCEEDED(hr))
                pidl = pidlFree;
        }
    }
    else if (pidl)
    {
        // Other parts of CShellExecute expect that _szFile is
        // filled in, so we may as well do it here.
        SHGetNameAndFlags(pidl, SHGDN_FORPARSING, _szFile, SIZECHARS(_szFile), NULL);
        _fNoResolve = TRUE;
    }

    if (pidl)
    {
        //  NT#413115 - ShellExec("D:\") does AutoRun.inf instead of Folder.Open - ZekeL - 25-JUN-2001
        //  this is because drivflder now explicitly supports GetUIObjectOf(IQueryAssociations)
        //  whereas it didnt in win2k, so that SHGetAssociations() would fallback to "Folder".
        //  to emulate this, we communicate that this associations object is going to be
        //  used by ShellExec() for invocation, so we dont want all of the keys in the assoc array.
        //
        IBindCtx *pbc;
        TBCRegisterObjectParam(L"ShellExec SHGetAssociations", NULL, &pbc);
        hr = SHGetAssociations(pidl, (void **)&_pqa);
        if (pbc)
            pbc->Release();

        // NOTE: sometimes we can have the extension or even the progid in the registry, but there
        // is no "shell" subkey. An example of this is for .xls files in NT5: the index server guys
        // create HKCR\.xls and HKCR\Excel.Sheet.8 but all they put under Excel.Sheet.8 is the clsid.
        //
        //  so we need to check and make sure that we have a valid command value for
        //  this object.  if we dont, then that means that this is not valid
        //  class to shellexec with.  we need to fall back to the Unknown key
        //  so that we can query the Darwin/NT5 ClassStore and/or
        //  show the openwith dialog box.
        //
        DWORD cch;
        if (FAILED(hr) ||
        (FAILED(_pqa->GetString(0, ASSOCSTR_COMMAND, _pszQueryVerb, NULL, &cch))
        && FAILED(_pqa->GetData(0, ASSOCDATA_MSIDESCRIPTOR, _pszQueryVerb, NULL, &cch))))

        {
            if (!_pqa)
                hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &_pqa));

            if (_pqa)
            {
                hr = _pqa->Init(0, L"Unknown", NULL, NULL);

                //  this allows us to locate something
                //  in the class store, but restricts us
                //  from using the openwith dialog if the
                //  caller instructed NOUI
                if (SUCCEEDED(hr) && _fNoUI)
                    _fClassStoreOnly = TRUE;
            }
        }

    }
    else
    {
        LPCTSTR pszExt = PathFindExtension(_szFile);
        if (*pszExt)
        {
            hr = _InitClassAssociations(pszExt, NULL, SEE_MASK_CLASSNAME);
            if (S_OK!=hr)
            {
                TraceMsg(TF_WARNING, "SHEX::InitAssoc parsing failed, but there is a valid association for *.%s", pszExt);
            }
        }
    }

    if (pidlFree)
        ILFree(pidlFree);

    return hr;
}

TRYRESULT CShellExecute::_InitAssociations(LPSHELLEXECUTEINFO pei, LPCITEMIDLIST pidl)
{
    HRESULT hr;
    if (pei && (_fUseClass || (!_szFile[0] && !_lpID)))
    {
        hr = _InitClassAssociations(pei->lpClass, pei->hkeyClass, pei->fMask);
    }
    else
    {
        hr = _InitShellAssociations(_szFile, pidl ? pidl : _lpID);
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::InitAssoc return %X", hr);

    if (FAILED(hr))
    {
        if (PathIsExe(_szFile))
        {
            hr = S_FALSE;
        }
        else
        {
            _ReportWin32(ERROR_NO_ASSOCIATION);
        }
    }

    return SUCCEEDED(hr) ? TRY_CONTINUE : TRY_STOP;
}

void CShellExecute::_SetStartup(LPSHELLEXECUTEINFO pei)
{
    // Was zero filled by Alloc...
    ASSERT(!_startup.cb);
    _startup.cb = sizeof(_startup);
    _startup.dwFlags |= STARTF_USESHOWWINDOW;
    _startup.wShowWindow = (WORD) pei->nShow;
    _startup.lpTitle = (LPTSTR)_lpTitle;

    if (pei->fMask & SEE_MASK_RESERVED)
    {
        _startup.lpReserved = (LPTSTR)pei->hInstApp;
    }

    if ((pei->fMask & SEE_MASK_HASLINKNAME) && _lpTitle)
    {
        _startup.dwFlags |= STARTF_TITLEISLINKNAME;
    }

    if (pei->fMask & SEE_MASK_HOTKEY)
    {
        _startup.hStdInput = LongToHandle(pei->dwHotKey);
        _startup.dwFlags |= STARTF_USEHOTKEY;
    }


// Multi-monitor support (dli) pass a hMonitor to createprocess

#ifndef STARTF_HASHMONITOR
#define STARTF_HASHMONITOR       0x00000400  // same as HASSHELLDATA
#endif

    if (pei->fMask & SEE_MASK_ICON)
    {
        _startup.hStdOutput = (HANDLE)pei->hIcon;
        _startup.dwFlags |= STARTF_HASSHELLDATA;
    }
    else if (pei->fMask & SEE_MASK_HMONITOR)
    {
        _startup.hStdOutput = (HANDLE)pei->hMonitor;
        _startup.dwFlags |= STARTF_HASHMONITOR;
    }
    else if (pei->hwnd)
    {
        _startup.hStdOutput = (HANDLE)MonitorFromWindow(pei->hwnd,MONITOR_DEFAULTTONEAREST);
        _startup.dwFlags |= STARTF_HASHMONITOR;
    }
    TraceMsg(TF_SHELLEXEC, "SHEX::SetStartup() called");

}

DWORD CEnvironmentBlock::_BlockLen(LPCWSTR pszEnv)
{
    LPCWSTR psz = pszEnv;
    while (*psz)
    {
        psz += lstrlen(psz)+1;
    }
    return (DWORD)(psz - pszEnv) + 1;
}

DWORD CEnvironmentBlock::_BlockLenCached()
{
    if (!_cchBlockLen && _pszBlock)
    {
        _cchBlockLen = _BlockLen(_pszBlock);
    }
    return _cchBlockLen;
}

HRESULT CEnvironmentBlock::_InitBlock(DWORD cchNeeded)
{
    if (_BlockLenCached() + cchNeeded > _cchBlockSize)
    {
        if (!_pszBlock)
        {
            //  we need to create a new block.
            LPTSTR pszEnv = GetEnvBlock(_hToken);
            if (pszEnv)
            {
                // Now lets allocate some memory for our block.
                //   -- Why 10 and not 11?  Or 9? --
                // Comment from BobDay: 2 of the 10 come from nul terminators of the
                // pseem->_szTemp and cchT strings added on.  The additional space might
                // come from the fact that 16-bit Windows used to pass around an
                // environment block that had some extra stuff on the end.  The extra
                // stuff had things like the path name (argv[0]) and a nCmdShow value.
                DWORD cchEnv = _BlockLen(pszEnv);
                DWORD cchAlloc = ROUNDUP(cchEnv + cchNeeded + 10, 256);
                _pszBlock = (LPWSTR)LocalAlloc(LPTR, CbFromCchW(cchAlloc));
                if (_pszBlock)
                {
                    //  copy stuff over
                    CopyMemory(_pszBlock, pszEnv, CbFromCchW(cchEnv));
                    _cchBlockSize = cchAlloc - 10;  // leave the 10 out
                    _cchBlockLen = cchEnv;
                }
                FreeEnvBlock(_hToken, pszEnv);
            }
        }
        else
        {
            //  need to resize the current block
            DWORD cchAlloc = ROUNDUP(_cchBlockSize + cchNeeded + 10, 256);
            LPWSTR pszNew = (LPWSTR)LocalReAlloc(_pszBlock, CbFromCchW(cchAlloc), LMEM_MOVEABLE);
            if (pszNew)
            {
                _cchBlockSize = cchAlloc - 10;  // leave the 10 out
                _pszBlock = pszNew;
            }
        }
    }

    return (_BlockLenCached() + cchNeeded <= _cchBlockSize) ? S_OK : E_OUTOFMEMORY;
}

BOOL CEnvironmentBlock::_FindVar(LPCWSTR pszVar, DWORD cchVar, LPWSTR *ppszBlockVar)
{
    int iCmp = CSTR_LESS_THAN;
    LPTSTR psz = _pszBlock;
    ASSERT(_pszBlock);
    for ( ; *psz && iCmp == CSTR_LESS_THAN; psz += lstrlen(psz)+1)
    {
        iCmp = CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, psz, cchVar, pszVar, cchVar);
        *ppszBlockVar = psz;
    }

    if (iCmp == CSTR_LESS_THAN)
        *ppszBlockVar = psz;

    return iCmp == CSTR_EQUAL;
}

HRESULT CEnvironmentBlock::SetVar(LPCWSTR pszVar, LPCWSTR pszValue)
{
    //  additional size needed in worst case scenario.
    //  var + val + '=' + NULL
    DWORD cchValue = lstrlenW(pszValue);
    DWORD cchVar = lstrlenW(pszVar);
    DWORD cchNeeded = cchVar + cchValue + 2;
    HRESULT hr = _InitBlock(cchNeeded);
    if (SUCCEEDED(hr))
    {
        //  we have enough room in our private block
        //  to copy the whole thing
        LPWSTR pszBlockVar;
        if (_FindVar(pszVar, cchVar, &pszBlockVar))
        {
            //  we need to replace this var
            LPWSTR pszBlockVal = StrChrW(pszBlockVar, L'=');
            DWORD cchBlockVal = lstrlenW(++pszBlockVal);
            LPWSTR pszDst = pszBlockVal + cchValue + 1;
            LPWSTR pszSrc = pszBlockVal + cchBlockVal + 1;
            DWORD cchMove = _BlockLenCached() - (DWORD)(pszSrc - _pszBlock);
            MoveMemory(pszDst, pszSrc, CbFromCchW(cchMove));
            StrCpyW(pszBlockVal, pszValue);
            _cchBlockLen = _cchBlockLen + cchValue - cchBlockVal;
            ASSERT(_BlockLen(_pszBlock) == _cchBlockLen);
        }
        else
        {
            //  this means that var doesnt exist yet
            //  however pszBlockVar points to where it
            //  would be alphabetically.  need to make space right here
            LPWSTR pszDst = pszBlockVar + cchNeeded;
            INT cchMove = _BlockLenCached() - (DWORD)(pszBlockVar - _pszBlock);
            MoveMemory(pszDst, pszBlockVar, CbFromCchW(cchMove));
            StrCpyW(pszBlockVar, pszVar);
            pszBlockVar += cchVar;
            *pszBlockVar = L'=';
            StrCpyW(++pszBlockVar, pszValue);
            _cchBlockLen += cchNeeded;
            ASSERT(_BlockLen(_pszBlock) == _cchBlockLen);
        }
    }
    return hr;
}

HRESULT CEnvironmentBlock::AppendVar(LPCWSTR pszVar, WCHAR chDelimiter, LPCWSTR pszValue)
{
    //  we could make the delimiter optional
    //  additional size needed in worst case scenario.
    //  var + val + 'chDelim' + '=' + NULL
    DWORD cchValue = lstrlenW(pszValue);
    DWORD cchVar = lstrlenW(pszVar);
    DWORD cchNeeded = cchVar + cchValue + 3;
    HRESULT hr = _InitBlock(cchNeeded);
    if (SUCCEEDED(hr))
    {
        //  we have enough room in our private block
        //  to copy the whole thing
        LPWSTR pszBlockVar;
        if (_FindVar(pszVar, cchVar, &pszBlockVar))
        {
            //  we need to append to this var
            pszBlockVar += lstrlen(pszBlockVar);
            LPWSTR pszDst = pszBlockVar + cchValue + 1;
            int cchMove = _BlockLenCached() - (DWORD)(pszBlockVar - _pszBlock);
            MoveMemory(pszDst, pszBlockVar, CbFromCchW(cchMove));
            *pszBlockVar = chDelimiter;
            StrCpyW(++pszBlockVar, pszValue);
            _cchBlockLen += cchValue + 1;
            ASSERT(_BlockLen(_pszBlock) == _cchBlockLen);
        }
        else
            hr = SetVar(pszVar, pszValue);
    }

    return hr;
}

HRESULT CShellExecute::_BuildEnvironmentForNewProcess(LPCTSTR pszNewEnvString)
{
    HRESULT hr;

    _envblock.SetToken(_hUserToken);
    // Use the _szTemp to build key to the programs specific
    // key in the registry as well as other things...
    hr = PathToAppPathKey(_szApplication, _szTemp, SIZECHARS(_szTemp));
    if (SUCCEEDED(hr))
    {
        // Currently only clone environment if we have path.
        DWORD cbTemp = sizeof(_szTemp);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, _szTemp, TEXT("PATH"), NULL, _szTemp, &cbTemp))
        {
            //  setit up to be appended
            hr = _envblock.AppendVar(L"PATH", L';', _szTemp);
        }
    }

    if (SUCCEEDED(hr) && pszNewEnvString)
    {
        StrCpyN(_szTemp, pszNewEnvString, ARRAYSIZE(_szTemp));
        LPTSTR pszValue = StrChrW(_szTemp, L'=');
        if (pszValue)
        {
            *pszValue++ = 0;
            hr = _envblock.SetVar(_szTemp, pszValue);
        }
    }

    if (SUCCEEDED(hr) && SUCCEEDED(TBCGetEnvironmentVariable(L"__COMPAT_LAYER", _szTemp, ARRAYSIZE(_szTemp))))
    {
        hr = _envblock.SetVar(L"__COMPAT_LAYER", _szTemp);
    }

    return hr;
}


// Some apps when run no-active steal the focus anyway so we
// we set it back to the previously active window.

void CShellExecute::_FixActivationStealingApps(HWND hwndOldActive, int nShow)
{
    HWND hwndNew;

    if (nShow == SW_SHOWMINNOACTIVE && (hwndNew = GetForegroundWindow()) != hwndOldActive && IsIconic(hwndNew))
        SetForegroundWindow(hwndOldActive);
}


//
//  The flags that need to passed to CreateProcess()
//
DWORD CShellExecute::_GetCreateFlags(ULONG fMask)
{
    DWORD dwFlags = 0;

    dwFlags |= CREATE_DEFAULT_ERROR_MODE;
    if (fMask & SEE_MASK_FLAG_SEPVDM)
    {
        dwFlags |= CREATE_SEPARATE_WOW_VDM;
    }

    dwFlags |= CREATE_UNICODE_ENVIRONMENT;

    if (!(fMask & SEE_MASK_NO_CONSOLE))
    {
        dwFlags |= CREATE_NEW_CONSOLE;
    }

    return dwFlags;
}

//***   GetUEMAssoc -- approximate answer to 'is path an executable' (etc.)
// ENTRY/EXIT
//  pszFile     thing we asked to run (e.g. foo.xls)
//  pszImage    thing we ultimately ran (e.g. excel.exe)
int GetUEMAssoc(LPCTSTR pszFile, LPCTSTR pszImage, LPCITEMIDLIST pidl)
{
    LPTSTR pszExt, pszExt2;

    // .exe's and associations come thru here
    // folders go thru ???
    // links go thru ResolveLink
    pszExt = PathFindExtension(pszFile);
    if (StrCmpIC(pszExt, c_szDotExe) == 0) {
        // only check .exe (assume .com, .bat, etc. are rare)
        return UIBL_DOTEXE;
    }
    pszExt2 = PathFindExtension(pszImage);
    // StrCmpC (non-I, yes-C) o.k ?  i think so since
    // all we really care about is that they don't match
    if (StrCmpC(pszExt, pszExt2) != 0) {
        TraceMsg(DM_MISC, "gua: UIBL_DOTASSOC file=%s image=%s", pszExt, pszExt2);
        return UIBL_DOTASSOC;
    }

    int iRet = UIBL_DOTOTHER;   // UIBL_DOTEXE?
    if (pidl)
    {
        LPCITEMIDLIST pidlChild;
        IShellFolder *psf;
        if (SUCCEEDED(SHBindToFolderIDListParent(NULL, pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
        {
            if (SHGetAttributes(psf, pidlChild, SFGAO_FOLDER | SFGAO_STREAM) == SFGAO_FOLDER)
            {
                iRet = UIBL_DOTFOLDER;
            }
            psf->Release();
        }
    }
    return iRet;
}

typedef struct {
    TCHAR szAppName[MAX_PATH];
    TCHAR szUser[UNLEN + 1];
    TCHAR szDomain[GNLEN + 1];
    TCHAR szPassword[PWLEN + 1];
    CPTYPE cpt;
} LOGONINFO;


// this is what gets called in the normal runas case
void InitUserLogonDlg(LOGONINFO* pli, HWND hDlg, LPCTSTR pszFullUserName)
{
    HWNDWSPrintf(GetDlgItem(hDlg, IDC_USECURRENTACCOUNT), pszFullUserName);

    CheckRadioButton(hDlg, IDC_USECURRENTACCOUNT, IDC_USEOTHERACCOUNT, IDC_USECURRENTACCOUNT);
    CheckDlgButton(hDlg, IDC_SANDBOX, TRUE);
    EnableWindow(GetDlgItem(hDlg, IDC_CREDCTL), FALSE);
    SetFocus(GetDlgItem(hDlg, IDOK));
}


// this is what gets called in the install app launching as non admin case
void InitSetupLogonDlg(LOGONINFO* pli, HWND hDlg, LPCTSTR pszFullUserName)
{
    HWNDWSPrintf(GetDlgItem(hDlg, IDC_USECURRENTACCOUNT), pszFullUserName);
    HWNDWSPrintf(GetDlgItem(hDlg, IDC_MESSAGEBOXCHECKEX), pszFullUserName);

    CheckRadioButton(hDlg, IDC_USECURRENTACCOUNT, IDC_USEOTHERACCOUNT, IDC_USEOTHERACCOUNT);
    EnableWindow(GetDlgItem(hDlg, IDC_SANDBOX), FALSE);
    SetFocus(GetDlgItem(hDlg, IDC_CREDCTL));
}

BOOL_PTR CALLBACK UserLogon_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    TCHAR szTemp[UNLEN + 1 + GNLEN + 1];    // enough to hold "reinerf@NTDEV" or "NTDEV\reinerf"
    LOGONINFO *pli= (LOGONINFO*)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            TCHAR szName[UNLEN];
            TCHAR szFullName[UNLEN + 1 + GNLEN]; // enough to hold "reinerf@NTDEV" or "NTDEV\reinerf"
            ULONG cchFullName = ARRAYSIZE(szFullName);
            HWND hwndCred = GetDlgItem(hDlg, IDC_CREDCTL);
            WPARAM wparamCredStyles = CRS_USERNAMES | CRS_CERTIFICATES | CRS_SMARTCARDS | CRS_ADMINISTRATORS | CRS_PREFILLADMIN;

            pli = (LOGONINFO*)lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pli);

            if (!IsOS(OS_DOMAINMEMBER))
            {
                wparamCredStyles |= CRS_COMPLETEUSERNAME;
            }

            if (!Credential_InitStyle(hwndCred, wparamCredStyles))
            {
                EndDialog(hDlg, IDCANCEL);
            }

            // Limit the user name and password
            Credential_SetUserNameMaxChars(hwndCred, UNLEN + 1 + GNLEN); // enough room for "reinerf@NTDEV" or "NTDEV\reinerf"
            Credential_SetPasswordMaxChars(hwndCred, PWLEN);

            if (!GetUserNameEx(NameSamCompatible, szFullName, &cchFullName))
            {
                ULONG cchName;
                if (GetUserNameEx(NameDisplay, szName, &(cchName = ARRAYSIZE(szName)))  ||
                    GetUserName(szName, &(cchName = ARRAYSIZE(szName)))                 ||
                    (GetEnvironmentVariable(TEXT("USERNAME"), szName, ARRAYSIZE(szName)) > 0))
                {
                    if (GetEnvironmentVariable(TEXT("USERDOMAIN"), szFullName, ARRAYSIZE(szFullName)) > 0)
                    {
                        StringCchCat(szFullName, ARRAYSIZE(szFullName), TEXT("\\"));
                        StringCchCat(szFullName, ARRAYSIZE(szFullName), szName);
                    }
                    else
                    {
                        // use just the username if we cannot get a domain name
                        StrCpyN(szFullName, szName, ARRAYSIZE(szFullName));
                    }

                }
                else
                {
                    TraceMsg(TF_WARNING, "UserLogon_DlgProc: failed to get the user's name using various methods");
                    szFullName[0] = TEXT('\0');
                }
            }

            // call the proper init function depending on whether this is a setup program launching or the normal runas case
            switch (pli->cpt)
            {
            case CPT_WITHLOGONADMIN:
                {
                    InitSetupLogonDlg(pli, hDlg, szFullName);
                    break;
                }
            case CPT_WITHLOGON:
                {
                    InitUserLogonDlg(pli, hDlg, szFullName);
                    break;
                }
            default:
                {
                    ASSERTMSG(FALSE, "UserLogon_DlgProc: found CPTYPE that is not CPT_WITHLOGON or CPT_WITHLOGONADMIN!");
                }
            }
            break;
        }
        break;

        case WM_COMMAND:
        {
            CPTYPE cptRet = CPT_WITHLOGONCANCELLED;
            int idCmd = GET_WM_COMMAND_ID(wParam, lParam);
            switch (idCmd)
            {
                /* need some way to tell that valid credentials are present so we will only
                   enable the ok button if the user has something that is somewhat valid
                case IDC_USERNAME:
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_UPDATE)
                    {
                        EnableOKButtonFromID(hDlg, IDC_USERNAME);
                        GetDlgItemText(hDlg, IDC_USERNAME, szTemp, ARRAYSIZE(szTemp));
                    }
                    break;
                */
                case IDC_USEOTHERACCOUNT:
                case IDC_USECURRENTACCOUNT:
                    if (IsDlgButtonChecked(hDlg, IDC_USECURRENTACCOUNT))
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_CREDCTL), FALSE);
                        EnableWindow(GetDlgItem(hDlg, IDC_SANDBOX), TRUE);
                        // EnableWindow(GetDlgItem(hDlg, IDOK), TRUE);
                    }
                    else
                    {
                        EnableWindow(GetDlgItem(hDlg, IDC_CREDCTL), TRUE);
                        EnableWindow(GetDlgItem(hDlg, IDC_SANDBOX), FALSE);
                        Credential_SetUserNameFocus(GetDlgItem(hDlg, IDC_CREDCTL));
                        // EnableOKButtonFromID(hDlg, IDC_USERNAME);
                    }
                    break;

                case IDOK:
                    if (IsDlgButtonChecked(hDlg, IDC_USEOTHERACCOUNT))
                    {
                        HWND hwndCred = GetDlgItem(hDlg, IDC_CREDCTL);

                        if (Credential_GetUserName(hwndCred, szTemp, ARRAYSIZE(szTemp)) &&
                            Credential_GetPassword(hwndCred, pli->szPassword, ARRAYSIZE(pli->szPassword)))
                        {
                            CredUIParseUserName(szTemp,
                                                pli->szUser,
                                                ARRAYSIZE(pli->szUser),
                                                pli->szDomain,
                                                ARRAYSIZE(pli->szDomain));
                        }
                        cptRet = pli->cpt;
                    }
                    else
                    {
                        if (IsDlgButtonChecked(hDlg, IDC_SANDBOX))
                            cptRet = CPT_SANDBOX;
                        else
                            cptRet = CPT_NORMAL;
                    }
                // fall through

                case IDCANCEL:
                    EndDialog(hDlg, cptRet);
                    return TRUE;
                    break;
            }
            break;
        }

        default:
            return FALSE;
    }

    if (!pli || (pli->cpt == CPT_WITHLOGONADMIN))
    {
        // we want the MessageBoxCheckExDlgProc have a crack at all messages in
        // the CPT_WITHLOGONADMIN case, so return FALSE here
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

//  implement this after we figure out what
//  errors that CreateProcessWithLogonW() will return
//  that mean the user should retry the logon.
BOOL _IsLogonError(DWORD err)
{
    static const DWORD s_aLogonErrs[] = {
        ERROR_LOGON_FAILURE,
        ERROR_ACCOUNT_RESTRICTION,
        ERROR_INVALID_LOGON_HOURS,
        ERROR_INVALID_WORKSTATION,
        ERROR_PASSWORD_EXPIRED,
        ERROR_ACCOUNT_DISABLED,
        ERROR_NONE_MAPPED,
        ERROR_NO_SUCH_USER,
        ERROR_INVALID_ACCOUNT_NAME
        };

    for (int i = 0; i < ARRAYSIZE(s_aLogonErrs); i++)
    {
        if (err == s_aLogonErrs[i])
            return TRUE;
    }
    return FALSE;
}


BOOL CheckForAppPathsBoolValue(LPCTSTR pszImageName, LPCTSTR pszValueName)
{
    BOOL bRet = FALSE;
    TCHAR szAppPathKeyName[MAX_PATH + ARRAYSIZE(REGSTR_PATH_APPPATHS) + 2]; // +2 = +1 for '\' and +1 for the null terminator
    DWORD cbSize = sizeof(bRet);
    HRESULT hr = PathToAppPathKey(pszImageName, szAppPathKeyName, ARRAYSIZE(szAppPathKeyName));
    if (SUCCEEDED(hr))
    {
        SHGetValue(HKEY_LOCAL_MACHINE, szAppPathKeyName, pszValueName, NULL, &bRet, &cbSize);
    }

    return bRet;
}

__inline BOOL IsRunAsSetupExe(LPCTSTR pszImageName)
{
    return CheckForAppPathsBoolValue(pszImageName, TEXT("RunAsOnNonAdminInstall"));
}

__inline BOOL IsTSSetupExe(LPCTSTR pszImageName)
{
    return CheckForAppPathsBoolValue(pszImageName, TEXT("BlockOnTSNonInstallMode"));
}

typedef BOOL (__stdcall * PFNTERMSRVAPPINSTALLMODE)(void);
// This function is used by hydra (Terminal Server) to see if we
// are in application install mode
//
// exported from kernel32.dll by name but not in kernel32.lib (it is in kernel32p.lib, bogus)

BOOL TermsrvAppInstallMode()
{
    static PFNTERMSRVAPPINSTALLMODE s_pfn = NULL;
    if (NULL == s_pfn)
    {
        s_pfn = (PFNTERMSRVAPPINSTALLMODE)GetProcAddress(LoadLibrary(TEXT("KERNEL32.DLL")), "TermsrvAppInstallMode");
    }

    return s_pfn ? s_pfn() : FALSE;
}

//
// this function checks for the different cases where we need to display a "runas" or warning dialog
// before a program is run.
//
// NOTE: pli->raType is an outparam that tells the caller what type of dialog is needed
//
// return:  TRUE    - we need to bring up a dialog
//          FALSE   - we do not need to prompt the user
//
CPTYPE CheckForInstallApplication(LPCTSTR pszApplicationName, LOGONINFO* pli)
{
    // if we are on a TS "Application Server" machine, AND this is a TS setup exe (eg install.exe or setup.exe)
    // AND we aren't in install mode...
    if (IsOS(OS_TERMINALSERVER) && IsTSSetupExe(pszApplicationName) && !TermsrvAppInstallMode())
    {
        // ...AND the app we are launching is not TS aware, then we block the install and tell the user to go
        // to Add/Remove Programs.
        if (!IsExeTSAware(pszApplicationName))
        {
            TraceMsg(TF_SHELLEXEC, "_SHCreateProcess: blocking the install on TS because the machine is not in install mode for %s", pszApplicationName);
            return CPT_INSTALLTS;
        }
    }

    // the hyrda case failed, so we check for the user not running as an admin but launching a setup exe (eg winnt32.exe, install.exe, or setup.exe)
    if (!SHRestricted(REST_NORUNASINSTALLPROMPT) && IsRunAsSetupExe(pszApplicationName) && !IsUserAnAdmin())
    {
        BOOL bPromptForInstall = TRUE;

        if (!SHRestricted(REST_PROMPTRUNASINSTALLNETPATH))
        {
            if (PathIsUNC(pszApplicationName) || IsNetDrive(PathGetDriveNumber(pszApplicationName)))
            {
                TraceMsg(TF_SHELLEXEC, "_SHCreateProcess: not prompting for runas install on unc/network path %s", pszApplicationName);
                bPromptForInstall = FALSE;
            }
        }

        if (bPromptForInstall)
        {
            TraceMsg(TF_SHELLEXEC, "_SHCreateProcess: bringing up the Run As... dialog for %s", pszApplicationName);
            return CPT_WITHLOGONADMIN;
        }
    }

    return CPT_NORMAL;
}


typedef HRESULT (__stdcall * PFN_INSTALLONTERMINALSERVERWITHUI)(IN HWND hwnd, IN LPCWSTR lpApplicationName,  // name of executable module
  LPCWSTR lpCommandLine,       // command line string
  LPSECURITY_ATTRIBUTES lpProcessAttributes,
  LPSECURITY_ATTRIBUTES lpThreadAttributes,
  BOOL bInheritHandles,       // handle inheritance flag
  DWORD dwCreationFlags,      // creation flags
  void *lpEnvironment,       // new environment block
  LPCWSTR lpCurrentDirectory, // current directory name
  LPSTARTUPINFOW lpStartupInfo,
  LPPROCESS_INFORMATION lpProcessInformation);

HRESULT InstallOnTerminalServerWithUIDD(IN HWND hwnd, IN LPCWSTR lpApplicationName,  // name of executable module
  IN LPCWSTR lpCommandLine,       // command line string
  IN LPSECURITY_ATTRIBUTES lpProcessAttributes,
  IN LPSECURITY_ATTRIBUTES lpThreadAttributes,
  IN BOOL bInheritHandles,       // handle inheritance flag
  IN DWORD dwCreationFlags,      // creation flags
  IN void *lpEnvironment,       // new environment block
  IN LPCWSTR lpCurrentDirectory, // current directory name
  IN LPSTARTUPINFOW lpStartupInfo,
  IN LPPROCESS_INFORMATION lpProcessInformation)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hDll = LoadLibrary(TEXT("appwiz.cpl"));

    if (hDll)
    {
        PFN_INSTALLONTERMINALSERVERWITHUI pfnInstallOnTerminalServerWithUI = NULL;

        pfnInstallOnTerminalServerWithUI = (PFN_INSTALLONTERMINALSERVERWITHUI) GetProcAddress(hDll, "InstallOnTerminalServerWithUI");
        if (pfnInstallOnTerminalServerWithUI)
        {
            hr = pfnInstallOnTerminalServerWithUI(hwnd, lpApplicationName, lpCommandLine, lpProcessAttributes,
                        lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment,
                        lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        }

        FreeLibrary(hDll);
    }

    return hr;
}

CPTYPE _LogonUser(HWND hwnd, CPTYPE cpt, LOGONINFO *pli)
{
    if (CredUIInitControls())
    {
        pli->cpt = cpt;
        switch (cpt)
        {
        case CPT_WITHLOGON:
            // this is the normal "Run as..." verb dialog
            cpt = (CPTYPE) DialogBoxParam(HINST_THISDLL,
                                    MAKEINTRESOURCE(DLG_RUNUSERLOGON),
                                    hwnd,
                                    UserLogon_DlgProc,
                                    (LPARAM)pli);
            break;

        case CPT_WITHLOGONADMIN:
            // in the non-administrator setup app case. we want the "don't show me
            // this again" functionality, so we use the SHMessageBoxCheckEx function
            cpt = (CPTYPE) SHMessageBoxCheckEx(hwnd,
                                         HINST_THISDLL,
                                         MAKEINTRESOURCE(DLG_RUNSETUPLOGON),
                                         UserLogon_DlgProc,
                                         (void*)pli,
                                         CPT_NORMAL, // if they checked the "dont show me this again", we want to just launch it as the current user
                                         TEXT("WarnOnNonAdminInstall"));
            break;

        default:
            {
                ASSERTMSG(FALSE, "_SHCreateProcess: pli->raType not recognized!");
            }
            break;
        }
        return cpt;
    }
    return CPT_FAILED;
}

//
//  SHCreateProcess()
//  WARNING: lpApplicationName is not actually passed to CreateProcess() it is
//            for internal use only.
//
BOOL _SHCreateProcess(HWND hwnd,
                      HANDLE hToken,
                      LPCTSTR pszDisplayName,
                      LPCTSTR lpApplicationName,
                      LPTSTR lpCommandLine,
                      DWORD dwCreationFlags,
                      LPSECURITY_ATTRIBUTES  lpProcessAttributes,
                      LPSECURITY_ATTRIBUTES  lpThreadAttributes,
                      BOOL  bInheritHandles,
                      void *lpEnvironment,
                      LPCTSTR lpCurrentDirectory,
                      LPSTARTUPINFO lpStartupInfo,
                      LPPROCESS_INFORMATION lpProcessInformation,
                      CPTYPE cpt,
                      BOOL fUEM)
{
    LOGONINFO li = {0};
    
    //  maybe we should do this for all calls
    //  except CPT_ASUSER??
    if (cpt == CPT_NORMAL)
    {
        // see if we need to put up a warning prompt either because the user is not an
        // admin or this is hydra and we are not in install mode.
        cpt = CheckForInstallApplication(lpApplicationName, &li);
    }

    if ((cpt == CPT_WITHLOGON || cpt == CPT_WITHLOGONADMIN) && pszDisplayName)
    {
        StringCchCopy(li.szAppName, ARRAYSIZE(li.szAppName), pszDisplayName);

RetryUserLogon:
        cpt = _LogonUser(hwnd, cpt, &li);

    }

    BOOL fRet = FALSE;
    DWORD err = NOERROR;

    //  BUGFIX #612540 + #616999 - CMD and BAT files are handled specially by CreateProcess() - ZekeL - 14-MAY-2002
    //  CreateProcess() handles prepending "cmd.exe /c" differently since 
    //  we now pass in both the lpApplicationName and the lpCommandLine.
    //  changing CreateProcess() is too risky, and so is changing the file assocs
    //  for CMD and BAT files only, we will not pass in both parameters
    if (PathMatchSpec(PathFindFileName(lpApplicationName), L"*.CMD;*.BAT"))
        lpApplicationName = NULL;

    switch(cpt)
    {
    case CPT_NORMAL:
        {
            // DEFAULT use CreateProcess
            fRet = CreateProcess(lpApplicationName,
                                 lpCommandLine,
                                 lpProcessAttributes,
                                 lpThreadAttributes,
                                 bInheritHandles,
                                 dwCreationFlags,
                                 lpEnvironment,
                                 lpCurrentDirectory,
                                 lpStartupInfo,
                                 lpProcessInformation);
        }
        break;


    case CPT_SANDBOX:
        {
            ASSERT(!hToken);
            hToken = _GetSandboxToken();
            if (hToken)
            {
                //  using our special token
                fRet = CreateProcessAsUser(hToken,
                                           lpApplicationName,
                                           lpCommandLine,
                                           lpProcessAttributes,
                                           lpThreadAttributes,
                                           bInheritHandles,
                                           dwCreationFlags,
                                           lpEnvironment,
                                           lpCurrentDirectory,
                                           lpStartupInfo,
                                           lpProcessInformation);
                CloseHandle(hToken);
            }

            // no token means failure.
        }
        break;


    case CPT_ASUSER:
        {
            if (hToken)
            {
                // using our special token
                fRet = CreateProcessAsUser(hToken,
                                           lpApplicationName,
                                           lpCommandLine,
                                           lpProcessAttributes,
                                           lpThreadAttributes,
                                           bInheritHandles,
                                           dwCreationFlags | CREATE_PRESERVE_CODE_AUTHZ_LEVEL,
                                           lpEnvironment,
                                           lpCurrentDirectory,
                                           lpStartupInfo,
                                           lpProcessInformation);
            }
            else
            {
                // no token means normal create process, but with the "preserve authz level" flag.
                fRet = CreateProcess(lpApplicationName,
                                     lpCommandLine,
                                     lpProcessAttributes,
                                     lpThreadAttributes,
                                     bInheritHandles,
                                     dwCreationFlags | CREATE_PRESERVE_CODE_AUTHZ_LEVEL,
                                     lpEnvironment,
                                     lpCurrentDirectory,
                                     lpStartupInfo,
                                     lpProcessInformation);
            }
        }
        break;


    case CPT_INSTALLTS:
        {
            HRESULT hr = InstallOnTerminalServerWithUIDD(hwnd,
                                                         lpApplicationName,
                                                         lpCommandLine,
                                                         lpProcessAttributes,
                                                         lpThreadAttributes,
                                                         bInheritHandles,
                                                         dwCreationFlags,
                                                         lpEnvironment,
                                                         lpCurrentDirectory,
                                                         lpStartupInfo,
                                                         lpProcessInformation);
            fRet = SUCCEEDED(hr);
            err = (HRESULT_FACILITY(hr) == FACILITY_WIN32) ? HRESULT_CODE(hr) : ERROR_ACCESS_DENIED;
        }
        break;

    case CPT_WITHLOGON:
    case CPT_WITHLOGONADMIN:
        {
            LPTSTR pszDesktop = lpStartupInfo->lpDesktop;
            // 99/08/19 #389284 vtan: clip username and domain to 125
            // characters each to avoid hitting the combined MAX_PATH
            // limit in AllowDesktopAccessToUser in advapi32.dll which
            // is invoked by CreateProcessWithLogonW.
            // This can be removed when the API is fixed. Check:
            // %_ntbindir%\mergedcomponents\advapi\cseclogn.cxx
            li.szUser[125] = li.szDomain[125] = 0;

            //  we are attempting logon the user. NOTE: pass LOGON_WITH_PROFILE so that we ensure that the profile is loaded
            fRet = CreateProcessWithLogonW(li.szUser, 
                                           li.szDomain,
                                           li.szPassword,
                                           LOGON_WITH_PROFILE,
                                           lpApplicationName,
                                           lpCommandLine,
                                           dwCreationFlags,
                                           NULL,  // we pass a null lpEnvironment so that the new process will inherit the new users default env
                                           lpCurrentDirectory,
                                           lpStartupInfo,
                                           lpProcessInformation);

            if (!fRet)
            {
                // HACKHACK: When CreateProcessWithLogon fails, it munges the desktop. This causes
                // the next call to "Appear" to fail because the app show up on another desktop...
                //     Why? I don't know...
                // I'm going to assign the bug back to them and have them fix it on their end, this is just to
                // work around their bug.

                if (lpStartupInfo)
                    lpStartupInfo->lpDesktop = pszDesktop;

                //  ShellMessageBox can alter LastError
                err = GetLastError();
                if (_IsLogonError(err))
                {
                    TCHAR szTemp[MAX_PATH];
                    LoadString(HINST_THISDLL, IDS_CANTLOGON, szTemp, SIZECHARS(szTemp));

                    SHSysErrorMessageBox(
                        hwnd,
                        li.szAppName,
                        IDS_SHLEXEC_ERROR,
                        err,
                        szTemp,
                        MB_OK | MB_ICONSTOP);

                    err = NOERROR;
                    goto RetryUserLogon;
                }
            }
        }
        break;

    case CPT_WITHLOGONCANCELLED:
        err = ERROR_CANCELLED;
        break;
    }

    // fire *after* the actual process since:
    //  - if there's a bug we at least get the process started (hopefully)
    //  - don't want to log failed events (for now at least)
    if (fRet)
    {
        if (fUEM && UEMIsLoaded())
        {
            // skip the call if stuff isn't there yet.
            // the load is expensive (forces ole32.dll and browseui.dll in
            // and then pins browseui).
            UEMFireEvent(&UEMIID_SHELL, UEME_RUNPATH, UEMF_XEVENT, -1, (LPARAM)lpApplicationName);
            // we do the UIBW_RUNASSOC elsewhere.  this can cause slight
            // inaccuracies since there's no guarantees the 2 places are
            // 'paired'.  however it's way easier to do UIBW_RUNASSOC
            // elsewhere so we'll live w/ it.
        }
    }
    else if (err)
    {
        SetLastError(err);
    }
    else
    {
        //  somebody is responsible for setting this...
        ASSERT(GetLastError());
    }

    //  eliminate the password
    SecureZeroMemory(&li, sizeof(li));
    
    return fRet;
}

BOOL _ParamIsApp(PCWSTR pszCmdTemplate)
{
    return (0 == StrCmpNW(pszCmdTemplate, L"%1", ARRAYSIZE(L"%1")-1))
        || (0 == StrCmpNW(pszCmdTemplate, L"\"%1\"", ARRAYSIZE(L"\"%1\"")-1));
}

BOOL CShellExecute::_FileIsApp()
{
    return !_szCmdTemplate[0] && PathIsExe(_szFile) && (!_pszQueryVerb || StrCmpI(_pszQueryVerb, TEXT("open")));
}
__inline BOOL IsConsoleApp(PCWSTR pszApp)
{
    return GetExeType(pszApp) == PEMAGIC;
}

BOOL IsCurrentProcessConsole()
{
    static TRIBIT s_tbConsole = TRIBIT_UNDEFINED;
    if (s_tbConsole == TRIBIT_UNDEFINED)
    {
        WCHAR sz[MAX_PATH];
        if (GetModuleFileNameW(NULL, sz, ARRAYSIZE(sz))
            && IsConsoleApp(sz))
        {
            s_tbConsole = TRIBIT_TRUE;
        }
        else
        {
            s_tbConsole = TRIBIT_FALSE;
        }
    }
    return s_tbConsole == TRIBIT_TRUE;
}

BOOL CShellExecute::_SetCommand(void)
{
    HRESULT hr;
    BOOL fRet = FALSE;
    if (_ParamIsApp(_szCmdTemplate) || _FileIsApp())
    {
        //  we need to fix up the parameters
        hr = StringCchCopy(_szApplication, ARRAYSIZE(_szApplication), _szFile);
        DWORD cchImageName = ARRAYSIZE(_szAppFriendly);
        AssocQueryString(ASSOCF_VERIFY | ASSOCF_INIT_BYEXENAME, ASSOCSTR_FRIENDLYAPPNAME, _szApplication, NULL, _szAppFriendly, &cchImageName);
        StringCchCopy(_szPolicyApp, ARRAYSIZE(_szPolicyApp), _szFile);
    }
    else if (_szCmdTemplate[0])
    {
        PWSTR pszApp;
        PWSTR pszCmd;
        hr = SHEvaluateSystemCommandTemplate(_szCmdTemplate, &pszApp, &pszCmd, NULL);
        if (SUCCEEDED(hr))
        {
            //  we need to fix up the parameters
            hr = StringCchCopy(_szApplication, ARRAYSIZE(_szApplication), pszApp);
            StringCchCopy(_szCmdTemplate, ARRAYSIZE(_szCmdTemplate), pszCmd);
            //  the Assoc code will redirect for RunDll32 to the DLL name
            _QueryString(ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, _szAppFriendly, ARRAYSIZE(_szAppFriendly));
            _QueryString(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, _szPolicyApp, ARRAYSIZE(_szPolicyApp));


            CoTaskMemFree(pszApp);
            CoTaskMemFree(pszCmd);
        }
        else if (hr == CO_E_APPNOTFOUND)
        {
            //  this replaces the old find associated exe
            if (!_fNoUI)
            {
                // have user choose a new association for this type
                OPENASINFO oai = {0};
                oai.pcszFile = _szFile;
                oai.dwInFlags = OAIF_ALLOW_REGISTRATION | OAIF_REGISTER_EXT | OAIF_EXEC;

                _ReportWin32(SUCCEEDED(OpenAsDialog(_hwndParent, &oai)) ? ERROR_SUCCESS : ERROR_CANCELLED);
                hr = S_FALSE;
            }
        }
    }
    else
    {
        _ReportWin32(ERROR_NO_ASSOCIATION);
        hr = S_FALSE;
    }
    
    if (S_OK == hr)
    {
        // parse arguments into command line
        DWORD se_err = ReplaceParameters(_szCommand, ARRAYSIZE(_szCommand),
            _szFile, _szCmdTemplate, _lpParameters,
            _nShow, NULL, FALSE, _lpID, &_pidlGlobal);

        if (0 == se_err)
            fRet = TRUE;
        else
            _ReportHinst(IntToHinst(se_err));

        if (!_fInheritHandles && SHRestricted(REST_INHERITCONSOLEHANDLES))
        {
            _fInheritHandles = IsCurrentProcessConsole() && IsConsoleApp(_szApplication);
        }
    }
    else if (FAILED(hr))
    {
        _ReportWin32(hr);
    }


    return fRet;
}

BOOL CShellExecute::_ExecMayCreateProcess(LPCTSTR *ppszNewEnvString)
{
    DWORD err = ERROR_SUCCESS;
    // Check exec restrictions.
    if (SHRestricted(REST_RESTRICTRUN) && RestrictedApp(_szPolicyApp))
    {
        err = ERROR_RESTRICTED_APP;
    }
    else if (SHRestricted(REST_DISALLOWRUN) && DisallowedApp(_szPolicyApp))
    {
        err = ERROR_RESTRICTED_APP;
    }
    //  try to validate the image if it is on a UNC share
    //  we dont need to check for Print shares, so we
    //  will fail if it is on one.
    else if (STOPTRYING(_TryValidateUNC(_szPolicyApp, NULL, NULL)))
    {
        // returns TRUE if it failed or handled the operation
        // Note that SHValidateUNC calls SetLastError
        // this continue will test based on GetLastError()
        err = GetLastError();
    }

    //
    // WOWShellExecute sets a global variable
    //     The cb is only valid when we are being called from wow
    //     If valid use it
    //
    else if (STOPTRYING(_TryWowShellExec()))
        return FALSE;

    return !_ReportWin32(err);
}

//
//  TryExecCommand() is the most common and default way to get an app started.
//  mostly it uses CreateProcess() with a command line composed from
//  the pei and the registry.  it can also do a ddeexec afterwards.
//

void CShellExecute::_DoExecCommand(void)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::DoExecCommand() entered szCommand = %s", _szCommand);

    HWND hwndOld = GetForegroundWindow();
    LPCTSTR pszNewEnvString = NULL;

    if (_SetCommand() && _ExecMayCreateProcess(&pszNewEnvString))
    {
        // See if we need to pass a new environment to the new process
        _BuildEnvironmentForNewProcess(pszNewEnvString);

        TraceMsg(TF_SHELLEXEC, "SHEX::DoExecCommand() CreateProcess(NULL,%s,...)", _szCommand);

        //  CreateProcess will SetLastError() if it fails
        if (_SHCreateProcess(_hwndParent,
                             _hUserToken,
                             _szAppFriendly,
                             _szApplication,
                             _szCommand,
                             _dwCreateFlags,
                             _pProcAttrs,
                             _pThreadAttrs,
                             _fInheritHandles,
                             _envblock.GetCustomBlock(),
                             _fUseNullCWD ? NULL : _szWorkingDir,
                             &_startup,
                             &_pi,
                             _cpt,
                             _fUEM))
        {
            // If we're doing DDE we'd better wait for the app to be up and running
            // before we try to talk to them.
            if (_fDDEInfoSet || _fWaitForInputIdle)
            {
                // Yep, How long to wait? For now, try 60 seconds to handle
                // pig-slow OLE apps.
                WaitForInputIdle(_pi.hProcess, 60*1000);
            }

            // Find the "hinstance" of whatever we just created.
            // PEIOUT - hinst reported for pei->hInstApp
            HINSTANCE hinst = 0;

            // Now fix the focus and do any dde stuff that we need to do
            _FixActivationStealingApps(hwndOld, _nShow);

            if (_fDDEInfoSet)
            {
                //  this will _Report() any errors for us if necessary
                _DDEExecute(NULL, _hwndParent, _nShow, _fDDEWait);
            }
            else
                _ReportHinst(hinst);

            //
            // Tell the taskbar about this application so it can re-tickle
            // the associated shortcut if the app runs for a long time.
            // This keeps long-running apps from aging off your Start Menu.
            //
            if (_fUEM && (_startup.dwFlags & STARTF_TITLEISLINKNAME))
            {
                _NotifyShortcutInvoke();
            }
        }
        else
        {
            _ReportWin32(GetLastError());
        }
    }

    // (we used to do a UIBW_RUNASSOC here, but moved it higher up)
}

void CShellExecute::_NotifyShortcutInvoke()
{
    SHShortcutInvokeAsIDList sidl;
    sidl.cb = FIELD_OFFSET(SHShortcutInvokeAsIDList, cbZero);
    sidl.dwItem1 = SHCNEE_SHORTCUTINVOKE;
    sidl.dwPid = _pi.dwProcessId;

    if (_startup.lpTitle)
    {
        lstrcpynW(sidl.szShortcutName, _startup.lpTitle, ARRAYSIZE(sidl.szShortcutName));
    }
    else
    {
        sidl.szShortcutName[0] = TEXT('\0');
    }
    lstrcpynW(sidl.szTargetName, _szApplication, ARRAYSIZE(sidl.szTargetName));
    sidl.cbZero = 0;
    SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_IDLIST, (LPCITEMIDLIST)&sidl, NULL);
}

HGLOBAL CShellExecute::_CreateDDECommand(int nShow, BOOL fLFNAware, BOOL fNative)
{
    // Now that we can handle ShellExec for URLs, we need to have a much bigger
    // command buffer. Explorer's DDE exec command even has two file names in
    // it. (WHY?) So the command buffer have to be a least twice the size of
    // INTERNET_MAX_URL_LENGTH plus room for the command format.
    SHSTR strTemp;
    HGLOBAL hRet = NULL;

    if (SUCCEEDED(strTemp.SetSize((2 * INTERNET_MAX_URL_LENGTH) + 64)))
    {
        if (0 == ReplaceParameters(strTemp.GetInplaceStr(), strTemp.GetSize(), _szFile,
            _szDDECmd, _lpParameters, nShow, ((DWORD*) &_startup.hStdInput), fLFNAware, _lpID, &_pidlGlobal))
        {

            TraceMsg(TF_SHELLEXEC, "SHEX::_CreateDDECommand(%d, %d) : %s", fLFNAware, fNative, strTemp.GetStr());

            //  we only have to thunk on NT
            if (!fNative)
            {
                SHSTRA stra;
                if (SUCCEEDED(stra.SetStr(strTemp)))
                {
                    // Get dde memory for the command and copy the command line.

                    hRet = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, CbFromCch(lstrlenA(stra.GetStr()) + 1));

                    if (hRet)
                    {
                        LPSTR psz = (LPSTR) GlobalLock(hRet);
                        StrCpyNA(psz, stra.GetStr(), GlobalSize(hRet) / sizeof(CHAR));
                        GlobalUnlock(hRet);
                    }
                }
            }
            else
            {
                // Get dde memory for the command and copy the command line.

                hRet = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, CbFromCch(lstrlen(strTemp.GetStr()) + 1));

                if (hRet)
                {
                    LPTSTR psz = (LPTSTR) GlobalLock(hRet);
                    StrCpyN(psz, strTemp.GetStr(), GlobalSize(hRet) / sizeof(TCHAR));
                    GlobalUnlock(hRet);
                }
            }
        }
    }

    return hRet;
}

// Short cut all DDE commands with a WM_NOTIFY
//  returns true if this was handled...or unrecoverable error.
BOOL CShellExecute::_TryDDEShortCircuit(HWND hwnd, HGLOBAL hMem, int nShow)
{
    if (hwnd  && IsWindowInProcess(hwnd))
    {
        HINSTANCE hret = (HINSTANCE)SE_ERR_FNF;

        // get the top most owner.
        hwnd = GetTopParentWindow(hwnd);

        if (IsWindowInProcess(hwnd))
        {
            LPNMVIEWFOLDER lpnm = (LPNMVIEWFOLDER)LocalAlloc(LPTR, sizeof(NMVIEWFOLDER));

            if (lpnm)
            {
                lpnm->hdr.hwndFrom = NULL;
                lpnm->hdr.idFrom = 0;
                lpnm->hdr.code = SEN_DDEEXECUTE;
                lpnm->dwHotKey = HandleToUlong(_startup.hStdInput);
                if ((_startup.dwFlags & STARTF_HASHMONITOR) != 0)
                    lpnm->hMonitor = reinterpret_cast<HMONITOR>(_startup.hStdOutput);
                else
                    lpnm->hMonitor = NULL;

                StrCpyN(lpnm->szCmd, (LPTSTR) GlobalLock(hMem), ARRAYSIZE(lpnm->szCmd));
                GlobalUnlock(hMem);

                if (SendMessage(hwnd, WM_NOTIFY, 0, (LPARAM)lpnm))
                    hret =  Window_GetInstance(hwnd);

                LocalFree(lpnm);
            }
            else
                hret = (HINSTANCE)SE_ERR_OOM;
        }

        TraceMsg(TF_SHELLEXEC, "SHEX::_TryDDEShortcut hinst = %d", hret);

        if ((UINT_PTR)hret != SE_ERR_FNF)
        {
            _ReportHinst(hret);
            return TRUE;
        }
    }

    return FALSE;
}


// _WaiteForDDEMsg()
// this does a message loop until DDE msg or a timeout occurs
//
STDAPI_(void) _WaitForDDEMsg(HWND hwnd, DWORD dwTimeout, UINT wMsg)
{
    //  termination event
    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    SetProp(hwnd, SZTERMEVENT, hEvent);

    for (;;)
    {
        MSG msg;
        DWORD dwEndTime = GetTickCount() + dwTimeout;
        LONG lWait = (LONG)dwTimeout;

        DWORD dwReturn = MsgWaitForMultipleObjects(1, &hEvent,
                FALSE, lWait, QS_POSTMESSAGE);

        //  if we time out or get an error or get our EVENT!!!
        //  we just bag out
        if (dwReturn != (WAIT_OBJECT_0 + 1))
        {
            break;
        }

        // we woke up because of messages.
        while (PeekMessage(&msg, NULL, WM_DDE_FIRST, WM_DDE_LAST, PM_REMOVE))
        {
            ASSERT(msg.message != WM_QUIT);
            DispatchMessage(&msg);

            if (msg.hwnd == hwnd && msg.message == wMsg)
                goto Quit;
        }

        // calculate new timeout value
        if (dwTimeout != INFINITE)
        {
            lWait = (LONG)dwEndTime - GetTickCount();
        }
    }

Quit:
    if (hEvent)
        CloseHandle(hEvent);
    RemoveProp(hwnd, SZTERMEVENT);

    return;
}

LRESULT CALLBACK DDESubClassWndProc(HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndConv = (HWND) GetProp(hWnd, SZCONV);
    WPARAM nLow;
    WPARAM nHigh;
    HANDLE hEvent;

    switch (wMsg)
    {
      case WM_DDE_ACK:
        if (!hwndConv)
        {
            // this is the first ACK for our INITIATE message
            TraceMsg(TF_SHELLEXEC, "SHEX::DDEStubWnd get ACK on INITIATE");
            return SetProp(hWnd, SZCONV, (HANDLE)wParam);
        }
        else if (((UINT_PTR)hwndConv == 1) || ((HWND)wParam == hwndConv))

        {
            // this is the ACK for our EXECUTE message
            TraceMsg(TF_SHELLEXEC, "SHEX::DDEStubWnd got ACK on EXECUTE");

            if (UnpackDDElParam(wMsg, lParam, &nLow, &nHigh))
            {
                GlobalFree((HGLOBAL)nHigh);
                FreeDDElParam(wMsg, lParam);
            }

            // prevent us from destroying again....
            if ((UINT_PTR) hwndConv != 1)
                DestroyWindow(hWnd);
        }

        // This is the ACK for our INITIATE message for all servers
        // besides the first.  We return FALSE, so the conversation
        // should terminate.
        break;

      case WM_DDE_TERMINATE:
        if (hwndConv == (HANDLE)wParam)
        {
            // this TERMINATE was originated by another application
            // (otherwise, hwndConv would be 1)
            // they should have freed the memory for the exec message

            TraceMsg(TF_SHELLEXEC, "SHEX::DDEStubWnd got TERMINATE from hwndConv");

            PostMessage((HWND)wParam, WM_DDE_TERMINATE, (WPARAM)hWnd, 0L);

            RemoveProp(hWnd, SZCONV);
            DestroyWindow(hWnd);
        }
        // Signal the termination event to ensure nested dde calls will terminate the
        // appropriate _WaitForDDEMsg loop properly...
        if (hEvent = GetProp(hWnd, SZTERMEVENT))
            SetEvent(hEvent);

        // This is the TERMINATE response for our TERMINATE message
        // or a random terminate (which we don't really care about)
        break;

      case WM_TIMER:
        if (wParam == DDE_DEATH_TIMER_ID)
        {
            // The conversation will be terminated in the destroy code
            DestroyWindow(hWnd);

            TraceMsg(TF_SHELLEXEC, "SHEX::DDEStubWnd TIMER closing DDE Window due to lack of ACK");
            break;
        }
        else
          return DefWindowProc(hWnd, wMsg, wParam, lParam);

      case WM_DESTROY:
        TraceMsg(TF_SHELLEXEC, "SHEX::DDEStubWnd WM_DESTROY'd");

        // kill the timer just incase.... (this may fail if we never set the timer)
        KillTimer(hWnd, DDE_DEATH_TIMER_ID);
        if (hwndConv)
        {
            // Make sure the window is not destroyed twice
            SetProp(hWnd, SZCONV, (HANDLE)1);

            /* Post the TERMINATE message and then
             * Wait for the acknowledging TERMINATE message or a timeout
             */
            PostMessage(hwndConv, WM_DDE_TERMINATE, (WPARAM)hWnd, 0L);

            _WaitForDDEMsg(hWnd, DDE_TERMINATETIMEOUT, WM_DDE_TERMINATE);

            RemoveProp(hWnd, SZCONV);
        }

        // the DDE conversation is officially over, let ShellExec know if it was waiting
        hEvent = RemoveProp(hWnd, SZDDEEVENT);
        if (hEvent)
        {
            SetEvent(hEvent);
        }

        /* Fall through */
      default:
        return DefWindowProc(hWnd, wMsg, wParam, lParam);
    }

    return 0L;
}

HWND CShellExecute::_CreateHiddenDDEWindow(HWND hwndParent)
{
    // lets be lazy and not create a class for it
    HWND hwnd = SHCreateWorkerWindow(DDESubClassWndProc, GetTopParentWindow(hwndParent),
        0, 0, NULL, NULL);

    TraceMsg(TF_SHELLEXEC, "SHEX::_CreateHiddenDDEWindow returning hwnd = 0x%X", hwnd);
    return hwnd;
}

void CShellExecute::_DestroyHiddenDDEWindow(HWND hwnd)
{
    if (IsWindow(hwnd))
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::_DestroyHiddenDDEWindow on hwnd = 0x%X", hwnd);
        DestroyWindow(hwnd);
    }
}

BOOL CShellExecute::_PostDDEExecute(HWND hwndOurs, HWND hwndTheirs, HGLOBAL hDDECommand, HANDLE hWait)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::_PostDDEExecute(0x%X, 0x%X) entered", hwndTheirs, hwndOurs);
    DWORD dwProcessID = 0;
    GetWindowThreadProcessId(hwndTheirs, &dwProcessID);
    if (dwProcessID)
    {
        AllowSetForegroundWindow(dwProcessID);
    }

    if (PostMessage(hwndTheirs, WM_DDE_EXECUTE, (WPARAM)hwndOurs, (LPARAM)PackDDElParam(WM_DDE_EXECUTE, 0,(UINT_PTR)hDDECommand)))
    {
        _ReportHinst(Window_GetInstance(hwndTheirs));
        TraceMsg(TF_SHELLEXEC, "SHEX::_PostDDEExecute() connected");

        // everything's going fine so far, so return to the application
        // with the instance handle of the guy, and hope he can execute our string
        if (hWait)
        {
            // We can't return from this call until the DDE conversation terminates.
            // Otherwise the thread may go away, nuking our hwndConv window,
            // messing up the DDE conversation, and Word drops funky error messages on us.
            TraceMsg(TF_SHELLEXEC, "SHEX::_PostDDEExecute() waiting for termination");
            SetProp(hwndOurs, SZDDEEVENT, hWait);
            SHProcessMessagesUntilEvent(NULL, hWait, INFINITE);
            //  it is removed during WM_DESTROY (before signaling)
        }
        else if (IsWindow(hwndOurs))
        {
            // set a timer to tidy up the window incase we never get a ACK....
            TraceMsg(TF_SHELLEXEC, "SHEX::_PostDDEExecute() setting DEATH timer");

            SetTimer(hwndOurs, DDE_DEATH_TIMER_ID, DDE_DEATH_TIMEOUT, NULL);
        }

        return TRUE;
    }

    return FALSE;
}

#define DDE_TIMEOUT             30000       // 30 seconds.
#define DDE_TIMEOUT_LOW_MEM     80000       // 80 seconds - Excel takes 77.87 on 486.33 with 8mb

typedef struct {
    WORD  aName;
    HWND  hwndDDE;
    LONG  lAppTopic;
    UINT  timeout;
} INITDDECONV;



HWND CShellExecute::_GetConversationWindow(HWND hwndDDE)
{
    ULONG_PTR dwResult;  //unused
    HWND hwnd = NULL;
    INITDDECONV idc = { NULL,
                        hwndDDE,
                        MAKELONG(_aApplication, _aTopic),
                        SHIsLowMemoryMachine(ILMM_IE4) ? DDE_TIMEOUT_LOW_MEM : DDE_TIMEOUT
                        };

    //  if we didnt find him, then we better default to the old way...
    if (!hwnd)
    {

        //  we found somebody who used to like us...
        // Send the initiate message.
        // NB This doesn't need packing.
        SendMessageTimeout((HWND) -1, WM_DDE_INITIATE, (WPARAM)hwndDDE,
                idc.lAppTopic, SMTO_ABORTIFHUNG,
                idc.timeout,
                &dwResult);

        hwnd = (HWND) GetProp(hwndDDE, SZCONV);
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::GetConvWnd returns [%X]", hwnd);
    return hwnd;
}

BOOL CShellExecute::_DDEExecute(
    BOOL fWillRetry,
    HWND hwndParent,
    int   nShowCmd,
    BOOL fWaitForDDE
)
{
    LONG err = ERROR_OUTOFMEMORY;
    BOOL fReportErr = TRUE;

    // Get the actual command string.
    // NB We'll assume the guy we're going to talk to is LFN aware. If we're wrong
    // we'll rebuild the command string a bit later on.
    HGLOBAL hDDECommand = _CreateDDECommand(nShowCmd, TRUE, TRUE);
    if (hDDECommand)
    {
        //  we have a DDE command to try
        if (_TryDDEShortCircuit(hwndParent, hDDECommand, nShowCmd))
        {
            //  the shortcut tried and now we have an error reported
            fReportErr = FALSE;
        }
        else
        {
            HANDLE hWait = fWaitForDDE ? CreateEvent(NULL, FALSE, FALSE, NULL) : NULL;
            if (hWait || !fWaitForDDE)
            {
                // Create a hidden window for the conversation
                HWND hwndDDE = _CreateHiddenDDEWindow(hwndParent);
                if (hwndDDE)
                {
                    HWND hwndConv = _GetConversationWindow(hwndDDE);
                    if (hwndConv)
                    {
                        //  somebody answered us.
                        // This doesn't work if the other guy is using ddeml.
                        if (_fActivateHandler)
                            ActivateHandler(hwndConv, (DWORD_PTR) _startup.hStdInput);

                        // Can the guy we're talking to handle LFNs?
                        BOOL fLFNAware = Window_IsLFNAware(hwndConv);
                        BOOL fNative = IsWindowUnicode(hwndConv);
                        if (!fLFNAware || !fNative)
                        {
                            //  we need to redo the command string.
                            // Nope - App isn't LFN aware - redo the command string.
                            GlobalFree(hDDECommand);

                            //  we may need a new _pidlGlobal too.
                            if (_pidlGlobal)
                            {
                                SHFreeShared((HANDLE)_pidlGlobal,GetCurrentProcessId());
                                _pidlGlobal = NULL;

                            }

                            hDDECommand = _CreateDDECommand(nShowCmd, fLFNAware, fNative);
                        }


                        // Send the execute message to the application.
                        err = ERROR_DDE_FAIL;

                        if (_PostDDEExecute(hwndDDE, hwndConv, hDDECommand, hWait))
                        {
                            fReportErr = FALSE;
                            hDDECommand = NULL;

                            //  hwnd owns itself now
                            if (!hWait)
                                hwndDDE = NULL;
                        }
                    }
                    else
                    {
                        err = (ERROR_FILE_NOT_FOUND);
                    }

                    //  cleanup
                    _DestroyHiddenDDEWindow(hwndDDE);

                }

                if (hWait)
                    CloseHandle(hWait);
            }

        }

        //  cleanup
        if (hDDECommand)
            GlobalFree(hDDECommand);
    }


    if (fReportErr)
    {
        if (fWillRetry && ERROR_FILE_NOT_FOUND == err)
        {
            //  this means that we need to update the
            //  command so that we can try DDE again after
            //  starting the app up...
            // if it wasn't found, determine the correct command

            _QueryString(0, ASSOCSTR_DDEIFEXEC, _szDDECmd, SIZECHARS(_szDDECmd));

            return FALSE;
        }
        else
        {

            _ReportWin32(err);
        }
    }

    return TRUE;
}

BOOL CShellExecute::_SetDDEInfo(void)
{
    ASSERT(_pqa);

    if (SUCCEEDED(_QueryString(0, ASSOCSTR_DDECOMMAND, _szDDECmd, SIZECHARS(_szDDECmd))))
    {
        TraceMsg(TF_SHELLEXEC, "SHEX::SetDDEInfo command: %s", _szDDECmd);

        // Any activation info?
        _fActivateHandler = FAILED(_pqa->GetData(0, ASSOCDATA_NOACTIVATEHANDLER, _pszQueryVerb, NULL, NULL));

        if (SUCCEEDED(_QueryString(0, ASSOCSTR_DDEAPPLICATION, _szTemp, SIZECHARS(_szTemp))))
        {
            TraceMsg(TF_SHELLEXEC, "SHEX::SetDDEInfo application: %s", _szTemp);

            if (_aApplication)
                GlobalDeleteAtom(_aApplication);

            _aApplication = GlobalAddAtom(_szTemp);

            if (SUCCEEDED(_QueryString(0, ASSOCSTR_DDETOPIC, _szTemp, SIZECHARS(_szTemp))))
            {
                TraceMsg(TF_SHELLEXEC, "SHEX::SetDDEInfo topic: %s", _szTemp);

                if (_aTopic)
                    GlobalDeleteAtom(_aTopic);
                _aTopic = GlobalAddAtom(_szTemp);

                _fDDEInfoSet = TRUE;
            }
        }
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::SetDDEInfo returns %d", _fDDEInfoSet);

    return _fDDEInfoSet;
}

TRYRESULT CShellExecute::_TryExecDDE(void)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    TraceMsg(TF_SHELLEXEC, "SHEX::TryExecDDE entered ");

    if (_SetDDEInfo())
    {
        //  try the real deal here.  we pass TRUE for fWillRetry because
        //  if this fails to find the app, we will attempt to start
        //  the app and then use DDE again.
        if (_DDEExecute(TRUE, _hwndParent, _nShow, _fDDEWait))
            tr = TRY_STOP;
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::TryDDEExec() returning %d", tr);

    return tr;
}

TRYRESULT CShellExecute::_SetDarwinCmdTemplate(BOOL fSync)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    if (SUCCEEDED(_pqa->GetData(0, ASSOCDATA_MSIDESCRIPTOR, _pszQueryVerb, (void *)_wszTemp, (LPDWORD)MAKEINTRESOURCE(sizeof(_wszTemp)))))
    {
        if (fSync)
        {
            // call darwin to give us the real location of the app.
            //
            // Note: this call could possibly fault the application in thus
            // installing it on the users machine.
            HRESULT hr = ParseDarwinID(_wszTemp, _szCmdTemplate, ARRAYSIZE(_szCmdTemplate));
            if (SUCCEEDED(hr))
            {
                tr = TRY_CONTINUE;
            }
            else
            {
                _ReportWin32(hr);
                tr = TRY_STOP;
            }
        }
        else
            tr = TRY_RETRYASYNC;
    }

    return tr;
}

HRESULT CShellExecute::_QueryString(ASSOCF flags, ASSOCSTR str, LPTSTR psz, DWORD cch)
{
    if (_pqa)
    {
        HRESULT hr = _pqa->GetString(flags, str, _pszQueryVerb, _wszTemp, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(_wszTemp)));

        if (SUCCEEDED(hr))
            SHUnicodeToTChar(_wszTemp, psz, cch);

        return hr;
    }
    return E_FAIL;
}

BOOL CShellExecute::_SetAppRunAsCmdTemplate(void)
{
    DWORD cb = sizeof(_szCmdTemplate);
    //  we want to use a special command
    HRESULT hr = PathToAppPathKey(_szFile, _szTemp, SIZECHARS(_szTemp));
    if (SUCCEEDED(hr))
    {
        return (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, _szTemp, TEXT("RunAsCommand"), NULL, _szCmdTemplate, &cb) && *_szCmdTemplate);
    }
    else
    {
        return FALSE;
    }
}

#if DBG && defined(_X86_)
#pragma optimize("", off) // work around compiler bug
#endif


TRYRESULT CShellExecute::_MaybeInstallApp(BOOL fSync)
{
    // we check darwin first since it should override everything else
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    if (IsDarwinEnabled())
    {
        // if darwin is enabled, then check for the darwin ID in
        // the registry and set the value based on that.
        tr = _SetDarwinCmdTemplate(fSync);
    }
    if (TRY_CONTINUE_UNHANDLED == tr)
    {
        // no darwin information in the registry
        // so now we have to check to see if the NT5 class store will populate our registry
        // with some helpful information (darwin or otherwise)
        tr = _ShouldRetryWithNewClassKey(fSync);
    }
    return tr;
}


TRYRESULT CShellExecute::_SetCmdTemplate(BOOL fSync)
{
    TRYRESULT tr = _MaybeInstallApp(fSync);
    if (tr == TRY_CONTINUE_UNHANDLED)
    {
        //
        //  both darwin and the class store were unsuccessful, so fall back to
        //  the good ole' default command value.
        //
        //  but if we the caller requested NOUI and we
        //  decided to use Unknown as the class
        //  then we should fail here so that
        //  we dont popup the OpenWith dialog box.
        //
        HRESULT hr = E_FAIL;
        if (!_fClassStoreOnly)
        {
            if ((_cpt != CPT_NORMAL)
            || !PathIsExe(_szFile)
            || !_SetAppRunAsCmdTemplate())
            {
                hr = _QueryString(0, ASSOCSTR_COMMAND, _szCmdTemplate, SIZECHARS(_szCmdTemplate));
            }
        }

        if (SUCCEEDED(hr))
        {
            tr = TRY_CONTINUE;
        }
        else
        {
            _ReportWin32(ERROR_NO_ASSOCIATION);
            tr = TRY_STOP;
        }
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::SetCmdTemplate() value = %s", _szCmdTemplate);
    return tr;
}

#if DBG && defined(_X86_)
#pragma optimize("", on) // return to previous optimization level
#endif

TRYRESULT CShellExecute::_TryWowShellExec(void)
{
    // WOWShellExecute sets this global variable
    //     The cb is only valid when we are being called from wow
    //     If valid use it

    if (g_pfnWowShellExecCB)
    {
        SHSTRA strCmd;
        SHSTRA strDir;

        HINSTANCE hinst = (HINSTANCE)SE_ERR_OOM;
        if (SUCCEEDED(strCmd.SetStr(_szCommand)) && SUCCEEDED(strDir.SetStr(_szWorkingDir)))
        {
            hinst = IntToHinst((*(LPFNWOWSHELLEXECCB)g_pfnWowShellExecCB)(strCmd.GetInplaceStr(), _startup.wShowWindow, strDir.GetInplaceStr()));
        }

        if (!_ReportHinst(hinst))
        {
            //  SUCCESS!

            //
            // If we were doing DDE, then retry now that the app has been
            // exec'd.  Note we don't keep HINSTANCE returned from _DDEExecute
            // because it will be constant 33 instead of the valid WOW HINSTANCE
            // returned from *g_pfnWowShellExecCB above.
            //
            if (_fDDEInfoSet)
            {
                _DDEExecute(NULL, _hwndParent, _nShow, _fDDEWait);
            }
        }

        TraceMsg(TF_SHELLEXEC, "SHEX::TryWowShellExec() used Wow");

        return TRY_STOP;
    }
    return TRY_CONTINUE_UNHANDLED;
}

TRYRESULT CShellExecute::_ShouldRetryWithNewClassKey(BOOL fSync)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    // If this is an app who's association is unknown, we might need to query the ClassStore if
    // we have not already done so.

    // The easiest way we can tell if the file we are going to execute is "Unknown" is by looking for
    // the "QueryClassStore" string value under the hkey we have. DllInstall in shell32 writes this key
    // so that we know when we are dealing with HKCR\Unknown (or any other progid that always wants to
    // do a classtore lookup)
    if (!_fAlreadyQueriedClassStore && !_fNoQueryClassStore &&
        SUCCEEDED(_pqa->GetData(0, ASSOCDATA_QUERYCLASSSTORE, NULL, NULL, NULL)))
    {
        if (fSync)
        {
            // go hit the NT5 Directory Services class store
            if (_szFile[0])
            {
                INSTALLDATA id;
                LPTSTR pszExtPart;
                WCHAR szFileExt[MAX_PATH];

                // all we have is a filename so whatever PathFindExtension
                // finds, we will use
                pszExtPart = PathFindExtension(_szFile);
                StrCpyN(szFileExt, pszExtPart, ARRAYSIZE(szFileExt));

                // Need to zero init id (can't do a = {0} when we declated it, because it has a non-zero enum type)
                ZeroMemory(&id, sizeof(INSTALLDATA));

                id.Type = FILEEXT;
                id.Spec.FileExt = szFileExt;

                // call the DS to lookup the file type in the class store
                if (ERROR_SUCCESS == InstallApplication(&id))
                {
                    // Since InstallApplication succeeded, it could have possibly installed and app
                    // or munged the registry so that we now have the necesssary reg info to
                    // launch the app. So basically re-read the class association to see if there is any
                    // new darwin info or new normal info, and jump back up and retry to execute.
                    LPITEMIDLIST pidlUnkFile = ILCreateFromPath(_szFile);

                    if (pidlUnkFile)
                    {
                        IQueryAssociations *pqa;
                        if (SUCCEEDED(SHGetAssociations(pidlUnkFile, (void **)&pqa)))
                        {
                            _pqa->Release();
                            _pqa = pqa;

                            if (_pszQueryVerb && (lstrcmpi(_pszQueryVerb, TEXT("openas")) == 0))
                            {
                                // Since we just sucessfully queried the class store, if our verb was "openas" (meaning
                                // that we used the Unknown key to do the execute) we always reset the verb to the default.
                                // If we do not do this, then we could fail the execute since "openas" is most likely not a
                                // supported verb of the application
                                _pszQueryVerb = NULL;
                            }
                        }

                        ILFree(pidlUnkFile);

                        _fAlreadyQueriedClassStore = TRUE;
                        _fClassStoreOnly = FALSE;
                    }

                } // CoGetClassInfo

            } // _szFile[0]
        }
        else
            tr = TRY_RETRYASYNC;
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::ShouldRWNCK() returning %d", tr);

    return tr;
}

TRYRESULT CShellExecute::_TryHooks(LPSHELLEXECUTEINFO pei)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;
    if (_UseHooks(pei->fMask))
    {
        //  REARCHITECT: the only client of this are URLs.
        //  if we change psfInternet to return IID_IQueryAssociations,
        //  then we can kill the urlexechook  (our only client)

        if (S_FALSE != TryShellExecuteHooks(pei))
        {
            //  either way we always exit.  should get TryShellhook to use SetLastError()
            _ReportHinst(pei->hInstApp);
            tr = TRY_STOP;;
        }
    }

    return tr;
}

void _PathStripTrailingDots(LPTSTR psz)
{
    // don't strip "." or ".."
    if (!PathIsDotOrDotDot(psz))
    {
        // remove any trailing dots
        TCHAR *pchLast = psz + lstrlen(psz) - 1;
        while (*pchLast == TEXT('.'))
        {
            *pchLast = 0;
            pchLast = CharPrev(psz, pchLast);
        }
    }
}

#define STR_PARSE_REQUIRE_REAL_NETWORK  L"Parse Require Real Network"
#define STR_PARSE_INTERNET_DONT_ESCAPE_SPACES   L"Parse Internet Dont Escape Spaces"

IBindCtx *CShellExecute::_PerfBindCtx()
{
    //
    //  180557 - make sure that we prefer the EXE to the folder - ZekeL - 9-SEP-2000
    //  this so that if both "D:\Setup" and "D:\Setup.exe" exist
    //  and the user types "D:\Setup" we will prefer to use "D:\Setup.exe"
    //  we also have to be careful not to send URLs down to SimpleIDList
    //  because of the weird results we get with the DavRedir
    //
    //  360353 - dont do resolve if we are passed the class key - ZekeL - 9-APR-2001
    //  if the caller passes us a key or class name then we must assume that 
    //  the item is already fully qualified.  specifically this can result in 
    //  a double resolve when doing an Open With....
    //
    //  206795 - dont use simple if the path is a root - ZekeL - 12-APR-2001
    //  specifically \\server\share needs this for printer shares with '.' to work.
    //  (eg \\printsvr\printer.first) this fails since a simple share will 
    //  be interpreted as SFGAO_FILESYSTEM always which will cause us to avoid
    //  the SHValidateUNC() which is what forces us to use the pidl for print shares.
    //  i think there are some similar issues with other shares that are not on the 
    //  default provider for the server (ie DAV shares).
    //
    IBindCtx *pbc = NULL;
    if (_fIsUrl)
    {
        //  403781 - avoid escaping spaces in URLs from ShellExec() - ZekeL - 25-May-2001
        //  this is because of removing the ShellExec hooks as the mechanism 
        //  for invoking URLs and switching to just using Parse/Invoke().
        //  however, the old code evidently avoided doing the UrlEscapeSpaces() 
        //  which the InternetNamespace typically does on parse.
        //  force xlate even though we are doing simple parse
        static BINDCTX_PARAM rgUrlParams[] = 
        { 
            { STR_PARSE_TRANSLATE_ALIASES, NULL},
            { STR_DONT_PARSE_RELATIVE, NULL},
            { STR_PARSE_INTERNET_DONT_ESCAPE_SPACES, NULL},
        };
        BindCtx_RegisterObjectParams(NULL, rgUrlParams, ARRAYSIZE(rgUrlParams), &pbc);
    }
    else if (!_fUseClass && !PathIsRoot(_szFile))
    {
        DWORD dwAttribs;
        if (PathFileExistsDefExtAndAttributes(_szFile, PFOPEX_DEFAULT | PFOPEX_OPTIONAL, &dwAttribs))
        {
            //  we found this with the extension.
            //  avoid hitting the disk again to do the parse
            WIN32_FIND_DATA wfd = {0};
            wfd.dwFileAttributes = dwAttribs;
            _PathStripTrailingDots(_szFile);
            IBindCtx *pbcFile;
            if (SUCCEEDED(SHCreateFileSysBindCtx(&wfd, &pbcFile)))
            {
                //  force xlate even though we are doing simple parse
                static BINDCTX_PARAM rgSimpleParams[] = 
                { 
                    { STR_PARSE_TRANSLATE_ALIASES, NULL},
                    { STR_DONT_PARSE_RELATIVE, NULL},
                    //{ STR_PARSE_REQUIRE_REAL_NETWORK, NULL},
                };

                BindCtx_RegisterObjectParams(pbcFile, rgSimpleParams, ARRAYSIZE(rgSimpleParams), &pbc);
                pbcFile->Release();
            }
        }
        else
        {
            static BINDCTX_PARAM rgDefaultParams[] = 
            {
                { STR_DONT_PARSE_RELATIVE, NULL},
            };
            BindCtx_RegisterObjectParams(NULL, rgDefaultParams, ARRAYSIZE(rgDefaultParams), &pbc);
        }
    }

    return pbc;
}        

TRYRESULT CShellExecute::_PerfPidl(LPCITEMIDLIST *ppidl)
{
    *ppidl = _lpID;
    if (!_lpID)
    {
        IBindCtx *pbc = _PerfBindCtx();
        HRESULT hr = SHParseDisplayName(_szFile, pbc, &_pidlFree, SFGAO_STORAGECAPMASK, &_sfgaoID);

        if (pbc)
            pbc->Release();
            
        if (FAILED(hr) && !pbc && UrlIs(_szFile, URLIS_FILEURL))
        {
            DWORD err = (HRESULT_FACILITY(hr) == FACILITY_WIN32) ? HRESULT_CODE(hr) : ERROR_FILE_NOT_FOUND;
            _ReportWin32(err);
            return TRY_STOP;
        }

        *ppidl = _lpID = _pidlFree;
    }
    else
    {
        _sfgaoID = SFGAO_STORAGECAPMASK;
        HRESULT hrT;
        if (*_szFile)
        {
            hrT = SHGetNameAndFlags(_lpID, 0, NULL, 0, &_sfgaoID);
        }
        else
        {
            hrT = SHGetNameAndFlags(_lpID, SHGDN_FORPARSING, _szFile, ARRAYSIZE(_szFile), &_sfgaoID);

            //  NTBUG#629947 - dont replace the path for the remote printers folder - ZekeL - 30-MAY-2002
            //  the remote printers pidl comes back with a path that looks like 
            //  \\server\::{GUID Remote Printers}, which tanks in _TryValidateUNC().
            //  so, lets ditch the name if it is not a stream, since
            //  we may need the path for zone checking files
            //
            if (SUCCEEDED(hrT) && !(_sfgaoID & SFGAO_STREAM))
                *_szFile = 0;
        }
                
        if (FAILED(hrT))
            _sfgaoID = 0;
    }
    return TRY_CONTINUE;
}

DWORD CShellExecute::_InvokeAppThreadProc()
{
    _fDDEWait = TRUE;
    _TryInvokeApplication(TRUE);
    Release();
    return 0;
}

DWORD WINAPI CShellExecute::s_InvokeAppThreadProc(void *pv)
{
    return ((CShellExecute *)pv)->_InvokeAppThreadProc();
}

TRYRESULT CShellExecute::_RetryAsync()
{
    if (_lpID && !_pidlFree)
        _lpID = _pidlFree = ILClone(_lpID);

    if (_lpParameters)
        _lpParameters = _pszAllocParams = StrDup(_lpParameters);

    if (_lpTitle)
        _lpTitle = _startup.lpTitle = _pszAllocTitle = StrDup(_lpTitle);

    _fAsync = TRUE;
    AddRef();
    if (!SHCreateThread(s_InvokeAppThreadProc, this, CTF_FREELIBANDEXIT | CTF_COINIT, NULL))
    {
        _ReportWin32(GetLastError());
        Release();
        return TRY_STOP;
    }
    return TRY_RETRYASYNC;
}

TRYRESULT CShellExecute::_TryInvokeApplication(BOOL fSync)
{
    TRYRESULT tr = TRY_CONTINUE_UNHANDLED;

    if (fSync)
        tr = _SetCmdTemplate(fSync);

    if (KEEPTRYING(tr))
    {
        // check for both the CacheFilename and URL being passed to us,
        // if this is the case, we need to check to see which one the App
        // wants us to pass to it.
        _SetFileAndUrl();

        tr = _TryExecDDE();

        // check to see if darwin is enabled on the machine
        if (KEEPTRYING(tr))
        {
            if (!fSync)
                tr = _SetCmdTemplate(fSync);

            if (KEEPTRYING(tr))
            {
                // At this point, the _szFile should have been determined one way
                // or another.
                ASSERT(_szFile[0] || _szCmdTemplate[0]);

                // do we have the necessary RegDB info to do an exec?

                _DoExecCommand();
                tr = TRY_STOP;
            }
        }

    }

    if (tr == TRY_RETRYASYNC)
    {
        //  install this on another thread
        tr = _RetryAsync();
    }

    return tr;
}

void CShellExecute::ExecuteNormal(LPSHELLEXECUTEINFO pei)
{

    SetAppStartingCursor(pei->hwnd, TRUE);

    _Init(pei);

    //
    //  Copy the specified directory in _szWorkingDir if the working
    // directory is specified; otherwise, get the current directory there.
    //
    _SetWorkingDir(pei->lpDirectory);

    //
    //  Copy the file name to _szFile, if it is specified. Then,
    // perform environment substitution.
    //
    _SetFile(pei->lpFile, pei->fMask & SEE_MASK_FILEANDURL);

    LPCITEMIDLIST pidl;
    if (STOPTRYING(_PerfPidl(&pidl)))
        goto Quit;

    //  If the specified filename is a UNC path, validate it now.
    if (STOPTRYING(_TryValidateUNC(_szFile, pei, pidl)))
        goto Quit;

    if (STOPTRYING(_TryHooks(pei)))
        goto Quit;

    if (STOPTRYING(_TryExecPidl(pei, pidl)))
        goto Quit;

    if (STOPTRYING(_VerifyExecTrust(pei)))
        goto Quit;

    // Is the class key provided?
    if (STOPTRYING(_InitAssociations(pei, pidl)))
        goto Quit;

    _TryInvokeApplication(_fDDEWait || (pei->fMask & SEE_MASK_NOCLOSEPROCESS));

Quit:

    //
    //  we should only see this if the registry is corrupted.
    //  but we still want to be able to open EXE's

    if (_err == ERROR_SUCCESS && UEMIsLoaded())
    {
        // skip the call if stuff isn't there yet.
        // the load is expensive (forces ole32.dll and browseui.dll in
        // and then pins browseui).

        // however we ran the app (exec, dde, etc.), we succeeded.  do our
        // best to guess the association etc. and log it.
        int i = GetUEMAssoc(_szFile, _szApplication, _lpID);
        TraceMsg(DM_MISC, "cse.e: GetUEMAssoc()=%d", i);
        UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_RUNASSOC, (LPARAM)i);
    }

    SetAppStartingCursor(pei->hwnd, FALSE);
}

DWORD CShellExecute::_FinalMapError(HINSTANCE UNALIGNED64 *phinst)
{
    if (_err != ERROR_SUCCESS)
    {
        // REVIEW: if errWin32 == ERROR_CANCELLED, we may want to
        // set hInstApp to 42 so people who don't check the return
        // code properly won't put up bogus messages. We should still
        // return FALSE. But this won't help everything and we should
        // really evangelize the proper use of ShellExecuteEx. In fact,
        // if we do want to do this, we should do it in ShellExecute
        // only. (This will force new people to do it right.)

        // Map FNF for drives to something slightly more sensible.
        if (_err == ERROR_FILE_NOT_FOUND && PathIsRoot(_szFile) &&
            !PathIsUNC(_szFile))
        {
            // NB CD-Rom drives with disk missing will hit this.
            if ((DriveType(DRIVEID(_szFile)) == DRIVE_CDROM) ||
                (DriveType(DRIVEID(_szFile)) == DRIVE_REMOVABLE))
                _err = ERROR_NOT_READY;
            else
                _err = ERROR_BAD_UNIT;
        }

        SetLastError(_err);

        if (phinst)
            *phinst = _MapWin32ErrToHINST(_err);

    }
    else if (phinst)
    {
        if (!_hInstance)
        {
            *phinst = (HINSTANCE) 42;
        }
        else
            *phinst = _hInstance;

        ASSERT(ISSHELLEXECSUCCEEDED(*phinst));
    }

    TraceMsg(TF_SHELLEXEC, "SHEX::FinalMapError() returning err = %d, hinst = %d", _err, _hInstance);

    return _err;
}

DWORD CShellExecute::Finalize(LPSHELLEXECUTEINFO pei)
{
    ASSERT(!_fAsync || !(pei->fMask & SEE_MASK_NOCLOSEPROCESS));

    if (!_fAsync
    && _pi.hProcess
    && _err == ERROR_SUCCESS
    && (pei->fMask & SEE_MASK_NOCLOSEPROCESS))
    {
        //
        //  change from win95 behavior - zekel 3-APR-98
        //  in win95 we would close the proces but return a handle.
        //  the handle was invalid of course, but some crazy app could be
        //  using this value to test for success.  i am assuming that they
        //  are using one of the other three ways to determine success,
        //  and we can follow the spec and return NULL if we close it.
        //
        //  PEIOUT - set the hProcess if they are going to use it.
        pei->hProcess = _pi.hProcess;
        _pi.hProcess = NULL;
    }

    //
    //  NOTE:  _FinalMapError() actually calls SetLastError() with our best error
    //  if any win32 apis are called after this, they can reset LastError!!
    //
    return _FinalMapError(&(pei->hInstApp));
}

//
//  Both the Reports return back TRUE if there was an error
//  or FALSE if it was a Success.
//
BOOL CShellExecute::_ReportWin32(DWORD err)
{
    ASSERT(!_err);
    TraceMsg(TF_SHELLEXEC, "SHEX::ReportWin32 reporting err = %d", err);

    _err = err;
    return (err != ERROR_SUCCESS);
}

BOOL CShellExecute::_ReportHinst(HINSTANCE hinst)
{
    ASSERT(!_hInstance);
    TraceMsg(TF_SHELLEXEC, "SHEX::ReportHinst reporting hinst = %d", hinst);
    if (ISSHELLEXECSUCCEEDED(hinst) || !hinst)
    {
        _hInstance = hinst;
        return FALSE;
    }
    else
        return _ReportWin32(_MapHINSTToWin32Err(hinst));
}

typedef struct {
    DWORD errWin32;
    UINT se_err;
} SHEXERR;

// one to one errs
//  ERROR_FILE_NOT_FOUND             SE_ERR_FNF              2       // file not found
//  ERROR_PATH_NOT_FOUND             SE_ERR_PNF              3       // path not found
//  ERROR_ACCESS_DENIED              SE_ERR_ACCESSDENIED     5       // access denied
//  ERROR_NOT_ENOUGH_MEMORY          SE_ERR_OOM              8       // out of memory
#define ISONE2ONE(e)   (e == SE_ERR_FNF || e == SE_ERR_PNF || e == SE_ERR_ACCESSDENIED || e == SE_ERR_OOM)

//  no win32 mapping SE_ERR_DDETIMEOUT               28
//  no win32 mapping SE_ERR_DDEBUSY                  30
//  but i dont see any places where this is returned.
//  before they became the win32 equivalent...ERROR_OUT_OF_PAPER or ERROR_READ_FAULT
//  now they become ERROR_DDE_FAIL.
//  but we wont preserve these errors in the pei->hInstApp
#define ISUNMAPPEDHINST(e)   (e == 28 || e == 30)

//  **WARNING** .  ORDER is IMPORTANT.
//  if there is more than one mapping for an error,
//  (like SE_ERR_PNF) then the first
const SHEXERR c_rgShexErrs[] = {
    {ERROR_SHARING_VIOLATION, SE_ERR_SHARE},
    {ERROR_OUTOFMEMORY, SE_ERR_OOM},
    {ERROR_BAD_PATHNAME,SE_ERR_PNF},
    {ERROR_BAD_NETPATH,SE_ERR_PNF},
    {ERROR_PATH_BUSY,SE_ERR_PNF},
    {ERROR_NO_NET_OR_BAD_PATH,SE_ERR_PNF},
    {ERROR_OLD_WIN_VERSION,10},
    {ERROR_APP_WRONG_OS,12},
    {ERROR_RMODE_APP,15},
    {ERROR_SINGLE_INSTANCE_APP,16},
    {ERROR_INVALID_DLL,20},
    {ERROR_NO_ASSOCIATION,SE_ERR_NOASSOC},
    {ERROR_DDE_FAIL,SE_ERR_DDEFAIL},
    {ERROR_DDE_FAIL,SE_ERR_DDEBUSY},
    {ERROR_DDE_FAIL,SE_ERR_DDETIMEOUT},
    {ERROR_DLL_NOT_FOUND,SE_ERR_DLLNOTFOUND}
};

DWORD CShellExecute::_MapHINSTToWin32Err(HINSTANCE hinst)
{
    DWORD errWin32 = 0;
    UINT_PTR se_err = (UINT_PTR) hinst;

    ASSERT(se_err);
    ASSERT(!ISSHELLEXECSUCCEEDED(se_err));

    // i actually handle these, but it used to be that these
    // became mutant win32s.  now they will be lost
    // i dont think these occur anymore
    AssertMsg(!ISUNMAPPEDHINST(se_err), TEXT("SHEX::COMPATIBILITY SE_ERR = %d, Get ZekeL!!!"), se_err);

    if (ISONE2ONE(se_err))
    {
        errWin32 = (DWORD) se_err;
    }
    else for (int i = 0; i < ARRAYSIZE(c_rgShexErrs) ; i++)
    {
        if (se_err == c_rgShexErrs[i].se_err)
        {
            errWin32= c_rgShexErrs[i].errWin32;
            break;
        }
    }

    ASSERT(errWin32);

    return errWin32;
}


HINSTANCE CShellExecute::_MapWin32ErrToHINST(UINT errWin32)
{
    ASSERT(errWin32);

    UINT se_err = 0;
    if (ISONE2ONE(errWin32))
    {
        se_err = errWin32;
    }
    else for (int i = 0; i < ARRAYSIZE(c_rgShexErrs) ; i++)
    {
        if (errWin32 == c_rgShexErrs[i].errWin32)
        {
            se_err = c_rgShexErrs[i].se_err;
            break;
        }
    }

    if (!se_err)
    {
        //  NOTE legacy error handling  - zekel - 20-NOV-97
        //  for any unhandled win32 errors, we default to ACCESS_DENIED
        se_err = SE_ERR_ACCESSDENIED;
    }

    return IntToHinst(se_err);
}


DWORD ShellExecuteNormal(LPSHELLEXECUTEINFO pei)
{
    DWORD err;
    TraceMsg(TF_SHELLEXEC, "ShellExecuteNormal Using CShellExecute");

    //  WARNING Dont use up Stack Space
    //  we allocate because of win16 stack issues
    //  and the shex is a big object
    CShellExecute *shex = new CShellExecute();

    if (shex)
    {
        shex->ExecuteNormal(pei);
        err = shex->Finalize(pei);
        shex->Release();
    }
    else
    {
        pei->hInstApp = (HINSTANCE)SE_ERR_OOM;
        err = ERROR_OUTOFMEMORY;
    }

    TraceMsg(TF_SHELLEXEC, "ShellExecuteNormal returning win32 = %d, hinst = %d", err, pei->hInstApp);

    return err;
}

BOOL CShellExecute::Init(PSHCREATEPROCESSINFO pscpi)
{
    TraceMsg(TF_SHELLEXEC, "SHEX::Init(pscpi)");

    _SetMask(pscpi->fMask);

    _lpParameters= pscpi->pszParameters;

    //  we always do "runas"
    _pszQueryVerb = _wszVerb;
    _cpt = pscpi->hUserToken ? CPT_ASUSER : CPT_WITHLOGON;

    if (pscpi->lpStartupInfo)
    {
        _nShow = pscpi->lpStartupInfo->wShowWindow;
        _startup = *(pscpi->lpStartupInfo);
    }
    else    // require startupinfo
        return !(_ReportWin32(ERROR_INVALID_PARAMETER));

    //
    //  Copy the specified directory in _szWorkingDir if the working
    // directory is specified; otherwise, get the current directory there.
    //
    _SetWorkingDir(pscpi->pszCurrentDirectory);

    //
    //  Copy the file name to _szFile, if it is specified. Then,
    // perform environment substitution.
    //
    _SetFile(pscpi->pszFile, FALSE);

    _pProcAttrs = pscpi->lpProcessAttributes;
    _pThreadAttrs = pscpi->lpThreadAttributes;
    _fInheritHandles = pscpi->bInheritHandles;
    _hUserToken = pscpi->hUserToken;
    //  createflags already inited by _SetMask() just
    //  add the users in.
    _dwCreateFlags |= pscpi->dwCreationFlags;
    _hwndParent = pscpi->hwnd;

    return TRUE;
}


void CShellExecute::ExecuteProcess(void)
{
    SetAppStartingCursor(_hwndParent, TRUE);

    //
    //  If the specified filename is a UNC path, validate it now.
    //
    if (STOPTRYING(_TryValidateUNC(_szFile, NULL, NULL)))
        goto Quit;

    LPCITEMIDLIST pidl;
    if (STOPTRYING(_Resolve(&pidl)))
        goto Quit;

    if (STOPTRYING(_InitAssociations(NULL, NULL)))
        goto Quit;

    // check to see if darwin is enabled on the machine
    if (STOPTRYING(_SetCmdTemplate(TRUE)))
        goto Quit;

    // At this point, the _szFile should have been determined one way
    // or another.
    ASSERT(_szFile[0] || _szCmdTemplate[0]);

    // do we have the necessary RegDB info to do an exec?

    _DoExecCommand();

Quit:

    if (_err == ERROR_SUCCESS && UEMIsLoaded())
    {
        int i;
        // skip the call if stuff isn't there yet.
        // the load is expensive (forces ole32.dll and browseui.dll in
        // and then pins browseui).

        // however we ran the app (exec, dde, etc.), we succeeded.  do our
        // best to guess the association etc. and log it.
        i = GetUEMAssoc(_szFile, _szApplication, NULL);
        TraceMsg(DM_MISC, "cse.e: GetUEMAssoc()=%d", i);
        UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_RUNASSOC, (LPARAM)i);
    }

    SetAppStartingCursor(_hwndParent, FALSE);

}

DWORD CShellExecute::Finalize(PSHCREATEPROCESSINFO pscpi)
{
    if (!_fAsync && _pi.hProcess)
    {
        if (!(pscpi->fMask & SEE_MASK_NOCLOSEPROCESS))
        {
            CloseHandle(_pi.hProcess);
            _pi.hProcess = NULL;
            CloseHandle(_pi.hThread);
            _pi.hThread = NULL;
        }

        if (_err == ERROR_SUCCESS
        && pscpi->lpProcessInformation)
        {
            *(pscpi->lpProcessInformation) = _pi;
        }

    }
    else if (pscpi->lpProcessInformation)
        ZeroMemory(pscpi->lpProcessInformation, sizeof(_pi));

    //
    //  NOTE:  _FinalMapError() actually calls SetLastError() with our best error
    //  if any win32 apis are called after this, they can reset LastError!!
    //
    return _FinalMapError(NULL);
}

SHSTDAPI_(BOOL) SHCreateProcessAsUserW(PSHCREATEPROCESSINFOW pscpi)
{
    DWORD err;
    TraceMsg(TF_SHELLEXEC, "SHCreateProcess using CShellExecute");

    //  WARNING Don't use up Stack Space
    //  we allocate because of win16 stack issues
    //  and the shex is a big object
    CShellExecute *pshex = new CShellExecute();

    if (pshex)
    {
        if (pshex->Init(pscpi))
            pshex->ExecuteProcess();

        err = pshex->Finalize(pscpi);

        pshex->Release();
    }
    else
        err = ERROR_OUTOFMEMORY;

    TraceMsg(TF_SHELLEXEC, "SHCreateProcess returning win32 = %d", err);

    if (err != ERROR_SUCCESS)
    {
        _DisplayShellExecError(pscpi->fMask, pscpi->hwnd, pscpi->pszFile, NULL, err);
        SetLastError(err);
    }

    return err == ERROR_SUCCESS;
}

HINSTANCE  APIENTRY WOWShellExecute(
    HWND  hwnd,
    LPCSTR lpOperation,
    LPCSTR lpFile,
    LPSTR lpParameters,
    LPCSTR lpDirectory,
    INT nShowCmd,
    void *lpfnCBWinExec)
{
   g_pfnWowShellExecCB = lpfnCBWinExec;

   if (!lpParameters)
       lpParameters = "";

   HINSTANCE hinstRet = RealShellExecuteExA(hwnd, lpOperation, lpFile, lpParameters,
      lpDirectory, NULL, "", NULL, (WORD)nShowCmd, NULL, 0);

   g_pfnWowShellExecCB = NULL;

   return hinstRet;
}

void _ShellExec_RunDLL(HWND hwnd, HINSTANCE hAppInstance, LPCTSTR pszCmdLine, int nCmdShow)
{
    TCHAR szQuotedCmdLine[MAX_PATH * 2];
    SHELLEXECUTEINFO ei = {0};
    ULONG fMask = SEE_MASK_FLAG_DDEWAIT;
    LPTSTR pszArgs;

    // Don't let empty strings through, they will endup doing something dumb
    // like opening a command prompt or the like
    if (!pszCmdLine || !*pszCmdLine)
        return;

    //
    //   the flags are prepended to the command line like:
    //   "?0x00000001?" "cmd line"
    //
    if (pszCmdLine[0] == TEXT('?'))
    {
        //  these are the fMask flags
        int i;
        if (StrToIntEx(++pszCmdLine, STIF_SUPPORT_HEX, &i))
        {
            fMask |= i;
        }

        pszCmdLine = StrChr(pszCmdLine, TEXT('?'));

        if (!pszCmdLine)
            return;

        pszCmdLine++;
    }

    // Gross, but if the process command fails, copy the command line to let
    // shell execute report the errors
        if (PathProcessCommand(pszCmdLine, szQuotedCmdLine, ARRAYSIZE(szQuotedCmdLine),
                           PPCF_ADDARGUMENTS|PPCF_FORCEQUALIFY) == -1)
        StrCpyN(szQuotedCmdLine, pszCmdLine, SIZECHARS(szQuotedCmdLine));

    pszArgs = PathGetArgs(szQuotedCmdLine);
    if (*pszArgs)
        *(pszArgs - 1) = 0; // Strip args

    PathUnquoteSpaces(szQuotedCmdLine);

    ei.cbSize          = sizeof(SHELLEXECUTEINFO);
    ei.hwnd            = hwnd;
    ei.lpFile          = szQuotedCmdLine;
    ei.lpParameters    = pszArgs;
    ei.nShow           = nCmdShow;
    ei.fMask           = fMask;

    //  if shellexec() fails we want to pass back the error.
    if (!ShellExecuteEx(&ei))
    {
        DWORD err = GetLastError();

        if (InRunDllProcess())
            ExitProcess(err);
    }
}

STDAPI_(void) ShellExec_RunDLLA(HWND hwnd, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    SHSTR str;
    if (SUCCEEDED(str.SetStr(pszCmdLine)))
        _ShellExec_RunDLL(hwnd, hAppInstance, str, nCmdShow);
}


STDAPI_(void) ShellExec_RunDLLW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow)
{
    SHSTR str;
    if (SUCCEEDED(str.SetStr(pszCmdLine)))
        _ShellExec_RunDLL(hwnd, hAppInstance, str, nCmdShow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\exedrop.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "ids.h"
#include "defview.h"
#include "datautil.h"
#include <cowsite.h>    // base class for IObjectWithSite
#include "idlcomm.h"

// shlexec.c
STDAPI_(BOOL) DoesAppWantUrl(LPCTSTR pszFullPathToApp);


// drop target impl for .exe files


class CExeDropTarget : public IDropTarget, IPersistFile, CObjectWithSite
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // IPersistFile
    STDMETHOD(IsDirty)(void);
    STDMETHOD(Load)(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD(Save)(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHOD(SaveCompleted)(LPCOLESTR pszFileName);
    STDMETHOD(GetCurFile)(LPOLESTR *ppszFileName);

    // IObjectWithSite
    // STDMETHOD(SetSite)(IUnknown *punkSite);
    // STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

    CExeDropTarget();

private:
    ~CExeDropTarget();
    void _FillSEIFromLinkSite(SHELLEXECUTEINFO *pei);
    void _CleanupSEIFromLinkSite(SHELLEXECUTEINFO *pei);

    LONG _cRef;
    DWORD _dwEffectLast;
    DWORD _grfKeyStateLast;
    TCHAR _szFile[MAX_PATH];
};

CExeDropTarget::CExeDropTarget() : _cRef(1)
{
}

CExeDropTarget::~CExeDropTarget()
{
}

STDMETHODIMP CExeDropTarget::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CExeDropTarget, IDropTarget),
        QITABENT(CExeDropTarget, IPersistFile), 
        QITABENTMULTI(CExeDropTarget, IPersist, IPersistFile),
        QITABENT(CExeDropTarget, IObjectWithSite),              // IID_IObjectWithSite
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CExeDropTarget::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CExeDropTarget::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CExeDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if ((S_OK == pdtobj->QueryGetData(&fmte)) ||
        (S_OK == DataObj_GetShellURL(pdtobj, NULL, NULL)))
    {
        *pdwEffect &= (DROPEFFECT_COPY | DROPEFFECT_LINK);
    }
    else
        *pdwEffect = 0;

    _dwEffectLast = *pdwEffect;
    _grfKeyStateLast = grfKeyState;
    return S_OK;
}

STDMETHODIMP CExeDropTarget::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = _dwEffectLast;
    _grfKeyStateLast = grfKeyState;
    return S_OK;
}

STDMETHODIMP CExeDropTarget::DragLeave()
{
    return S_OK;
}

//
//  See if we were created from a shortcut.  If so, then pull the exec
//  parameters from the shortcut.
//
void CExeDropTarget::_FillSEIFromLinkSite(SHELLEXECUTEINFO *pei)
{
    ASSERT(pei->lpParameters == NULL);
    ASSERT(pei->lpDirectory == NULL);

    IShellLink *psl;
    if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_LinkSite, IID_PPV_ARG(IShellLink, &psl))))
    {
        TCHAR szBuf[MAX_PATH];

        psl->GetShowCmd(&pei->nShow);

        // Hotkeys are annoying because IShellLink::GetHotkey uses a
        // WORD as the hotkey, but SHELLEXECUTEINFO uses a DWORD.

        WORD wHotkey;
        if (SUCCEEDED(psl->GetHotkey(&wHotkey)))
        {
            pei->dwHotKey = wHotkey;
            pei->fMask |= SEE_MASK_HOTKEY;
        }

        if (SUCCEEDED(psl->GetWorkingDirectory(szBuf, ARRAYSIZE(szBuf))) &&
            szBuf[0])
        {
            Str_SetPtr(const_cast<LPTSTR *>(&pei->lpDirectory), szBuf);
        }

        if (SUCCEEDED(psl->GetArguments(szBuf, ARRAYSIZE(szBuf))) &&
            szBuf[0])
        {
            Str_SetPtr(const_cast<LPTSTR *>(&pei->lpParameters), szBuf);
        }

        psl->Release();
    }

}

void CExeDropTarget::_CleanupSEIFromLinkSite(SHELLEXECUTEINFO *pei)
{
    Str_SetPtr(const_cast<LPTSTR *>(&pei->lpDirectory), NULL);
    Str_SetPtr(const_cast<LPTSTR *>(&pei->lpParameters), NULL);
}

BOOL GetAppDropTarget(LPCTSTR pszPath, CLSID *pclsid)
{
    TCHAR sz[MAX_PATH];

    // NOTE this assumes that this is a path to the exe
    // and not a command line
    PathToAppPathKey(pszPath, sz, ARRAYSIZE(sz));
    TCHAR szClsid[64];
    DWORD cb = sizeof(szClsid);
    return (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, sz, TEXT("DropTarget"), NULL, szClsid, &cb)) &&
            GUIDFromString(szClsid, pclsid);
}


STDMETHODIMP CExeDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    DWORD dwEffectPerformed = 0;

    if (!(_grfKeyStateLast & MK_LBUTTON))
    {
        HMENU hmenu = SHLoadPopupMenu(HINST_THISDLL, POPUP_DROPONEXE);
        if (hmenu)
        {
            HWND hwnd;
            IUnknown_GetWindow(_punkSite, &hwnd);

            UINT idCmd = SHTrackPopupMenu(hmenu, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                    pt.x, pt.y, 0, hwnd, NULL);
            DestroyMenu(hmenu);
            if (idCmd != DDIDM_COPY)
            {
                *pdwEffect = 0; // canceled
            }
        }
    }

    if (*pdwEffect)
    {
        CLSID clsidDropTarget;
        if (GetAppDropTarget(_szFile, &clsidDropTarget))
        {
            if (SUCCEEDED(SHSimulateDropOnClsid(clsidDropTarget, _punkSite, pdtobj)))
            {
                dwEffectPerformed = DROPEFFECT_COPY;  // what we did
            }
        }
        else
        {
            SHELLEXECUTEINFO ei = {
                sizeof(ei),
                    0, NULL, NULL, _szFile, NULL, NULL, SW_SHOWNORMAL, NULL 
            };
            
            _FillSEIFromLinkSite(&ei);
            
            LPCTSTR pszLinkParams = ei.lpParameters;
            
            FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            STGMEDIUM medium;
            HRESULT hr = pdtobj->GetData(&fmte, &medium);
            if (SUCCEEDED(hr))
            {
                TCHAR szPath[MAX_PATH];
                int cchParam = ei.lpParameters ? lstrlen(ei.lpParameters) + 1 : 0;
                BOOL fLFNAware = App_IsLFNAware(_szFile);
                
                for (UINT i = 0; DragQueryFile((HDROP)medium.hGlobal, i, szPath, ARRAYSIZE(szPath)); i++)
                {
                    if (fLFNAware)
                        PathQuoteSpaces(szPath);
                    else
                        GetShortPathName(szPath, szPath, ARRAYSIZE(szPath));
                    cchParam += lstrlen(szPath) + 2;    // space and NULL
                }
                
                if (cchParam)
                {
                    LPTSTR pszParam = (LPTSTR)LocalAlloc(LPTR, cchParam * sizeof(*pszParam));
                    if (pszParam)
                    {
                        // If the link had parameters, then put our filenames after
                        // the parameters (with an intervening space)
                        
                        if (ei.lpParameters)
                        {
                            StrCpyN(pszParam, ei.lpParameters, cchParam);
                            StrCatBuff(pszParam, c_szSpace, cchParam);
                        }
                        
                        for (i = 0; DragQueryFile((HDROP)medium.hGlobal, i, szPath, ARRAYSIZE(szPath)); i++)
                        {
                            if (fLFNAware)
                                PathQuoteSpaces(szPath);
                            else
                                GetShortPathName(szPath, szPath, ARRAYSIZE(szPath));
                            if (i > 0)
                                StrCatBuff(pszParam, c_szSpace, cchParam);
                            StrCatBuff(pszParam, szPath, cchParam);
                        }
                        
                        ei.lpParameters = pszParam;
                        
                        // all shellexec info comes from stuff thats in the dataobject or already on disk --
                        // no getting around it, and the args are quoted properly or put into short path names.
                        ShellExecuteEx(&ei);
                        
                        LocalFree((HLOCAL)pszParam);
                        
                        dwEffectPerformed = DROPEFFECT_COPY;  // what we did
                    }
                }
                ReleaseStgMedium(&medium);
            }
            else
            {
                LPCSTR pszURL;
                
                if (SUCCEEDED(DataObj_GetShellURL(pdtobj, &medium, &pszURL)))
                {
                    if (DoesAppWantUrl(_szFile))
                    {
                        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
                        SHAnsiToTChar(pszURL, szURL, ARRAYSIZE(szURL));
                        
                        ei.lpParameters = szURL;
                        
                        // all shellexec info comes from stuff thats in the dataobject or already on disk
                        ShellExecuteEx(&ei);
                        
                        dwEffectPerformed = DROPEFFECT_LINK;  // what we did
                    }
                    ReleaseStgMediumHGLOBAL(NULL, &medium);
                }
            }
            
            // The process of building the ShellExecuteEx parameters may have
            // messed up the ei.lpParameters, so put the original back so the
            // cleanup function won't get confused.
            ei.lpParameters = pszLinkParams;
            _CleanupSEIFromLinkSite(&ei);
        }
        
        *pdwEffect = dwEffectPerformed;
    }
    
    return S_OK;
}

STDMETHODIMP CExeDropTarget::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_ExeDropTarget;
    return S_OK;
}

STDMETHODIMP CExeDropTarget::IsDirty(void)
{
    return S_OK;        // no
}

STDMETHODIMP CExeDropTarget::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    SHUnicodeToTChar(pszFileName, _szFile, ARRAYSIZE(_szFile));
    return S_OK;
}

STDMETHODIMP CExeDropTarget::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return S_OK;
}

STDMETHODIMP CExeDropTarget::SaveCompleted(LPCOLESTR pszFileName)
{
    return S_OK;
}

STDMETHODIMP CExeDropTarget::GetCurFile(LPOLESTR *ppszFileName)
{
    *ppszFileName = NULL;
    return E_NOTIMPL;
}

STDAPI CExeDropTarget_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CExeDropTarget* pdt = new CExeDropTarget();
    if (pdt)
    {
        hr = pdt->QueryInterface(riid, ppv);
        pdt->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\expenv.c ===
/****************************************************************************/
/*                                                                          */
/*  enpenv.c -                                                              */
/*                                                                          */
/*      Routines for expanding environment strings                          */
/*                                                                          */
/****************************************************************************/

#include "shellprv.h"

//-------------------------------------------------------------------------
// The given string is parsed and all environment variables
// are expanded. If the expansion doesn't over fill the buffer
// then the length of the new string will be returned in the
// hiword and TRUE in the low word.  If the expansion would over
// fill the buffer then the original string is left unexpanded,
// the original length in the high word and FALSE in the low word.
// The length of the string is in bytes and excludes the terminating
// NULL.
//
// NOTE 1: This function must now handle environment variables in Quotes
//
// NOTE 2: There is no need for this API since NT has the equivalent APIs such
//       as ExpandEnvironmentStrings. But must keep it since it is a public
//       API in Win3.1.
//       Instead of doing all the work here, just call ExpandEnvironmentStrings.
//-------------------------------------------------------------------------

DWORD  APIENTRY DoEnvironmentSubstA(
   LPSTR pszSrc,    // The input string.
   UINT cchSrc)  // The limit of characters in the input string inc null.
{
    LPSTR pszExp;
    DWORD cchExp;
    BOOL fRet = FALSE;
        
    pszExp = (LPSTR)LocalAlloc(LPTR, cchSrc);
    if (pszExp)
    {
        cchExp = SHExpandEnvironmentStringsA(pszSrc, pszExp, cchSrc);
        if (cchExp)
        {
            HRESULT hr = StringCchCopyA(pszSrc, cchSrc, pszExp);
            if (SUCCEEDED(hr))
            {
                fRet = TRUE;
            }
        }
        LocalFree(pszExp);
    }

    if (fRet)
        return MAKELONG(cchExp,TRUE);
    else
        return MAKELONG(cchSrc,FALSE);
}

#ifdef UNICODE // on Win9x platform, shlunimp.c provides the implementation
DWORD  APIENTRY DoEnvironmentSubstW(
   LPWSTR pszSrc,    // The input string.
   UINT cchSrc)    // The limit of characters in the input string inc null.
{
    LPWSTR pszExp;
    DWORD cchExp;
    BOOL fRet = FALSE;
        
    pszExp = (LPWSTR)LocalAlloc(LPTR, cchSrc * sizeof(WCHAR));
    if (pszExp)
    {
        cchExp = SHExpandEnvironmentStringsW(pszSrc, pszExp, cchSrc);
        if (cchExp)
        {
            HRESULT hr = StringCchCopyW(pszSrc, cchSrc, pszExp);
            if (SUCCEEDED(hr))
            {
                fRet = TRUE;
            }
        }
        LocalFree(pszExp);
    }

    if (fRet)
        return MAKELONG(cchExp,TRUE);
    else
        return MAKELONG(cchSrc,FALSE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\extract.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "newres.h"

#define ICON_MAGIC      0
#define ICO_MAGIC1      1
#define CUR_MAGIC1      2
#define BMP_MAGIC       ((WORD)'B'+((WORD)'M'<<8))
#define ANI_MAGIC       ((WORD)'R'+((WORD)'I'<<8))
#define ANI_MAGIC1      ((WORD)'F'+((WORD)'F'<<8))
#define ANI_MAGIC4      ((WORD)'A'+((WORD)'C'<<8))
#define ANI_MAGIC5      ((WORD)'O'+((WORD)'N'<<8))
#define MZMAGIC         ((WORD)'M'+((WORD)'Z'<<8))
#define PEMAGIC         ((WORD)'P'+((WORD)'E'<<8))
#define LEMAGIC         ((WORD)'L'+((WORD)'E'<<8))

typedef struct new_exe          NEWEXE,      *LPNEWEXE;
typedef struct exe_hdr          EXEHDR,      *LPEXEHDR;
typedef struct rsrc_nameinfo    RESNAMEINFO, *LPRESNAMEINFO;
typedef struct rsrc_typeinfo    RESTYPEINFO, *LPRESTYPEINFO;
typedef struct new_rsrc         RESTABLE,    *LPRESTABLE;

#define RESOURCE_VA(x)        ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress)
#define RESOURCE_SIZE(x)      ((x)->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size)
#define NUMBER_OF_SECTIONS(x) ((x)->FileHeader.NumberOfSections)

#define FCC(c0,c1,c2,c3) ((DWORD)(c0)|((DWORD)(c1)<<8)|((DWORD)(c2)<<16)|((DWORD)(c3)<<24))

#define COM_FILE        FCC('.', 'c', 'o', 'm')
#define BAT_FILE        FCC('.', 'b', 'a', 't')
#define CMD_FILE        FCC('.', 'c', 'm', 'd')
#define PIF_FILE        FCC('.', 'p', 'i', 'f')
#define LNK_FILE        FCC('.', 'l', 'n', 'k')
#define ICO_FILE        FCC('.', 'i', 'c', 'o')
#define EXE_FILE        FCC('.', 'e', 'x', 'e')

/****************************************************************************
* extract a single icon from a exe file, or get the count.
*
* If nIconIndex != -1
*  Returns:
*      The handle of the icon, if successful.
*      0, if the file does not exist or an icon with the "nIconIndex"
*         does not exist.
*      1, if the given file is not an EXE or ICO file.
*
* If nIconIndex == -1
*  Returns:
*      The number of icons in the file if successful.
*      0, if the file has no icons or isn't an icon file.
*
****************************************************************************/

HICON WINAPI ExtractIcon(HINSTANCE hInst, LPCTSTR szFileName, UINT nIconIndex)
{
    HICON hIcon;
    
    if (nIconIndex == (UINT) -1)
        hIcon = (HICON)IntToPtr( ExtractIcons(szFileName, 0, 0, 0, NULL, NULL, 0, 0) );
    else
        ExtractIcons(szFileName, nIconIndex, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), &hIcon, NULL, 1, 0);
    
    return hIcon;
}

/****************************************************************************
*
*  in:
*       lpIconPath      path of thing to extract icon for (may be an exe
*                       or something that is associated)
*       lpiIcon         icon index to use
*
*       lpIconPath      filled in with the real path where the icon came from
*       lpiIcon         filled in with the real icon index
*
*  returns:
*
* note: if the caller is the shell it returns special icons
* from within the shell.dll
*
****************************************************************************/

HICON WINAPI ExtractAssociatedIcon(HINSTANCE hInst, LPTSTR lpIconPath, WORD *lpiIcon)
{
    HICON hIcon = ExtractIcon(hInst, lpIconPath, *lpiIcon);
    
    if (hIcon == NULL)
        hIcon = SHGetFileIcon(NULL, lpIconPath, 0, SHGFI_LARGEICON);
    if (hIcon == NULL)
    {
        *lpiIcon = IDI_DOCUMENT;
        GetModuleFileName(HINST_THISDLL, lpIconPath, 128);
        hIcon = LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(*lpiIcon));
    }
    
    return hIcon;
}


/****************************************************************************
*
*  extracts 1 or more icons from a file.
*
*  input:
*      szFileName          - EXE/DLL/ICO file to extract from
*      nIconIndex          - what icon to extract
*                              0 = first icon, 1=second icon, etc.
*                             -N = icon with id==N
*      phiconLarge         - place to return extracted icon(s)
*      phiconSmall         - place to return extracted icon(s) (small size)
*      nIcons              - number of icons to extract.
*
*  returns:
*      number of icons extracted, or the count of icons if phiconLarge==NULL
*
*  notes:
*      handles extraction from PE (Win32), NE (Win16), and ICO (Icon) files.
*      only Win16 3.x files are supported (not 2.x)
*
****************************************************************************/

UINT WINAPI ExtractIconExW(LPCWSTR szFileName, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons)
{
    return PrivateExtractIconExW( szFileName, nIconIndex, phiconLarge, phiconSmall, nIcons );
}

UINT WINAPI ExtractIconExA(LPCSTR szFileName, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons)
{
    return PrivateExtractIconExA( szFileName, nIconIndex, phiconLarge, phiconSmall, nIcons );
}

/****************************************************************************
*
*  extracts 1 or more icons from a file.
*
*  input:
*      szFileName          - EXE/DLL/ICO/CUR/ANI file to extract from
*      nIconIndex          - what icon to extract
*                              0 = first icon, 1=second icon, etc.
*                             -N = icon with id==N
*      cxIcon              - icon size wanted (if HIWORD != 0 two sizes...)
*      cyIcon              - icon size wanted (if HIWORD != 0 two sizes...)
*                            0,0 means extract at natural size.
*      phicon              - place to return extracted icon(s)
*      nIcons              - number of icons to extract.
*      flags               - LoadImage LR_* flags
*
*  returns:
*      if picon is NULL, number of icons in the file is returned.
*
*  notes:
*      handles extraction from PE (Win32), NE (Win16), ICO (Icon),
*      CUR (Cursor), ANI (Animated Cursor), and BMP (Bitmap) files.
*      only Win16 3.x files are supported (not 2.x)
*
*      cx/cyIcon are the size of the icon to extract, two sizes
*      can be extracted by putting size 1 in the loword and size 2 in the
*      hiword, ie MAKELONG(24, 48) would extract 24 and 48 size icons.
*      yea this is a hack. It is done so IExtractIcon::Extract
*      can be called by outside people with custom large/small icon
*      sizes that are not what the shell uses internaly.
*
****************************************************************************/

UINT WINAPI SHExtractIconsW(LPCWSTR wszFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
{
    return ExtractIcons(wszFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
}

UINT WINAPI ExtractIcons(LPCTSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
{
    return PrivateExtractIconsW( szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags );
}

DWORD HasExtension(LPCTSTR pszPath)
{
    LPCTSTR p = PathFindExtension(pszPath);
    
    //
    //
    // PERF: BobDay - We could make this EXTKEY based like the extension
    // matching stuff elsewhere.  EXTKEY is a QWORD value so UNICODE would fit.
    //
    if (*p == TEXT('.'))
    {
        WCHAR   szExt[5];
        
        lstrcpyn(szExt, p, ARRAYSIZE(szExt));
        
        if ( lstrcmpi(szExt,TEXT(".com")) == 0 ) return COM_FILE;
        if ( lstrcmpi(szExt,TEXT(".bat")) == 0 ) return BAT_FILE;
        if ( lstrcmpi(szExt,TEXT(".cmd")) == 0 ) return CMD_FILE;
        if ( lstrcmpi(szExt,TEXT(".pif")) == 0 ) return PIF_FILE;
        if ( lstrcmpi(szExt,TEXT(".lnk")) == 0 ) return LNK_FILE;
        if ( lstrcmpi(szExt,TEXT(".ico")) == 0 ) return ICO_FILE;
        if ( lstrcmpi(szExt,TEXT(".exe")) == 0 ) return EXE_FILE;
    }
    return 0;    
}


/****************************************************************************
* get the EXE type of the passed file (DOS, Win16, Win32)
*
*  returns:
*      0 = not a exe of any type.
*
*      if a windows app
*          LOWORD = NE or PE
*          HIWORD = windows version 3.0, 3.5, 4.0
*
*      if a DOS app (or a .com or batch file on non-NT)
*          LOWORD = MZ
*          HIWORD = 0
*
*      if a Win32 console app (or a batch file on NT)
*          LOWORD = PE
*          HIWORD = 0
*
*  this is so similar to the Win32 API GetBinaryType() too bad Win95
*  kernel does not support it.
*
****************************************************************************/

DWORD WINAPI GetExeType(LPCTSTR szFile)
{
    HANDLE      fh;
    DWORD       dw;
    struct exe_hdr exehdr = { 0 };
    struct new_exe newexe = { 0 };
    FILETIME ftAccess;
    DWORD dwRead;
    
    //
    //  check for special extensions, and fail quick
    //
    switch (HasExtension(szFile))
    {
    case COM_FILE:
        // handle the case like \\server.microsoft.com
        // PERF - Bobday - This does the same operation twice, we should really
        // make PathIsUNCServerShare return a code based on what it found...
        if (PathIsUNCServer(szFile) || PathIsUNCServerShare(szFile))
            return 0;
        return MAKELONG(MZMAGIC, 0);  // DOS exe
        
    case BAT_FILE:
    case CMD_FILE:
        return MAKELONG(PEMAGIC, 0);    // NT exe (pretend)
        
    case EXE_FILE:                   // we need to open it.
        break;
        
    default:
        return 0;                    // not a exe, or if it is we dont care
    }
    
    newexe.ne_expver = 0;
    
    fh = CreateFile(szFile, GENERIC_READ | FILE_WRITE_ATTRIBUTES,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        0, OPEN_EXISTING, 0, 0);
    
    if (fh == INVALID_HANDLE_VALUE)
    {
        //
        // We may be trying to get properties for a file on a volume where
        // we don't have write access, so try opening the file for read
        // only access.  This will mean we can't preserve the access
        // time (those calls will fail), but this is better than not returning
        // the exe type at all...
        //
        
        fh = CreateFile(szFile, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            0, OPEN_EXISTING, 0, 0);
        
        //
        // at this point if we get an INVALID_HANDLE_VALUE, we really
        // can't do much else, so now return a failure...
        //
        
        if (fh == INVALID_HANDLE_VALUE)
        {
            return 0;
        }
    }
    
    // preserve the access time
    
    if (GetFileTime(fh, NULL, &ftAccess, NULL))
        SetFileTime(fh, NULL, &ftAccess, NULL);
    
    if (!ReadFile(fh, &exehdr, sizeof(exehdr), &dwRead, NULL) ||
        (dwRead != sizeof(exehdr)))
        goto error;
    
    if (exehdr.e_magic != EMAGIC)
        goto error;
    
    SetFilePointer(fh, exehdr.e_lfanew, NULL, FILE_BEGIN);
    ReadFile(fh, &newexe, sizeof(newexe), &dwRead, NULL);
    
    if (newexe.ne_magic == PEMAGIC)
    {
        // read the SubsystemVersion
        SetFilePointer(fh, exehdr.e_lfanew+18*4, NULL, FILE_BEGIN);
        dw = 0;
        ReadFile(fh, &dw, sizeof(dw), &dwRead, NULL);
        newexe.ne_expver = LOBYTE(LOWORD(dw)) << 8 | LOBYTE(HIWORD(dw));
        
        // read the Subsystem
        SetFilePointer(fh, exehdr.e_lfanew+23*4, NULL, FILE_BEGIN);
        dw = 0;
        ReadFile(fh, &dw, sizeof(dw), &dwRead, NULL);
        
        // if it is not a Win32 GUI app return a version of 0
        if (LOWORD(dw) != 2) // IMAGE_SUBSYSTEM_WINDOWS_GUI
            newexe.ne_expver = 0;
        
        goto exit;
    }
    else if (newexe.ne_magic == LEMAGIC)
    {
        newexe.ne_magic = MZMAGIC;      // just a DOS exe
        newexe.ne_expver = 0;
    }
    else if (newexe.ne_magic == NEMAGIC)
    {
        //
        //  we found a 'NE' it still might not be a windows
        //  app, it could be.....
        //
        //      a OS/2 app      ne_exetyp==NE_OS2
        //      a DOS4 app      ne_exetyp==NE_DOS4
        //      a VxD           ne_exetyp==DEV386
        //
        //      only treat it as a Windows app if the exetype
        //      is NE_WINDOWS or NE_UNKNOWN
        //
        if (newexe.ne_exetyp != NE_WINDOWS && newexe.ne_exetyp != NE_UNKNOWN)
        {
            newexe.ne_magic = MZMAGIC;      // just a DOS exe
            newexe.ne_expver = 0;
        }
        
        //
        //  if could also have a bogus expected windows version
        //  (treat 0 as invalid)
        //
        if (newexe.ne_expver == 0)
        {
            newexe.ne_magic = MZMAGIC;      // just a DOS exe
            newexe.ne_expver = 0;
        }
    }
    else // if (newexe.ne_magic != NEMAGIC)
    {
        newexe.ne_magic = MZMAGIC;      // just a DOS exe
        newexe.ne_expver = 0;
    }
    
exit:
    CloseHandle(fh);
    return MAKELONG(newexe.ne_magic, newexe.ne_expver);
    
error:
    CloseHandle(fh);
    return 0;
}

#define M_llseek(fh, lOff, iOrg)            SetFilePointer((HANDLE)IntToPtr( fh ), lOff, NULL, (DWORD)iOrg)

#define MAGIC_ICON30            0
#define MAGIC_MARKZIBO          ((WORD)'M'+((WORD)'Z'<<8))

typedef struct new_exe          NEWEXEHDR;
typedef NEWEXEHDR               *PNEWEXEHDR;

#define SEEK_FROMZERO           0
#define SEEK_FROMCURRENT        1
#define SEEK_FROMEND            2
#define NSMOVE                  0x0010
#define VER                     0x0300

#define CCHICONPATHMAXLEN 128

typedef struct
{
    HANDLE hAppInst;
    HANDLE hFileName;
    HANDLE hIconList;
    INT    nIcons;
} EXTRACTICONINFO;

EXTRACTICONINFO ExtractIconInfo = {NULL, NULL, NULL, 0};

INT nIcons;

typedef struct 
{
    HICON hIcon;
    INT   iIconId;
} MYICONINFO;

HANDLE APIENTRY InternalExtractIconW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex, UINT nIcons);

HICON APIENTRY DuplicateIcon(HINSTANCE hInst, HICON hIcon)
{
    ICONINFO  IconInfo;
    
    if (!GetIconInfo(hIcon, &IconInfo))
        return NULL;
    hIcon = CreateIconIndirect(&IconInfo);
    DeleteObject(IconInfo.hbmMask);
    DeleteObject(IconInfo.hbmColor);
    
    UNREFERENCED_PARAMETER(hInst);
    return hIcon;
}

// This returns a pointer to the rsrc_nameinfo of the resource with the
// given index and type, if it is found, otherwise it returns NULL.

LPBYTE FindResWithIndex(LPBYTE lpResTable, INT iResIndex, LPBYTE lpResType)
{
    try 
    {
        LPRESTYPEINFO lpResTypeInfo = (LPRESTYPEINFO)(lpResTable + sizeof(WORD));
        
        while (lpResTypeInfo->rt_id) 
        {
            if ((lpResTypeInfo->rt_id & RSORDID) &&
                (MAKEINTRESOURCE(lpResTypeInfo->rt_id & ~RSORDID) == (LPTSTR)lpResType)) 
            {
                if (lpResTypeInfo->rt_nres > (WORD)iResIndex)
                    return((LPBYTE)(lpResTypeInfo+1) + iResIndex * sizeof(RESNAMEINFO));
                else
                    return NULL;
            }
            
            lpResTypeInfo = (LPRESTYPEINFO)((LPBYTE)(lpResTypeInfo+1) + lpResTypeInfo->rt_nres * sizeof(RESNAMEINFO));
        }
        return NULL;
    }
    except (EXCEPTION_EXECUTE_HANDLER) 
    {
        return NULL;
    }
}


/* This returns the index (1-relative) of the given resource-id
* in the resource table, if it is found, otherwise it returns NULL.
*/

INT GetResIndex(LPBYTE lpResTable, INT iResId, LPBYTE lpResType)
{
    WORD w;
    LPRESNAMEINFO lpResNameInfo;
    LPRESTYPEINFO lpResTypeInfo = (LPRESTYPEINFO)(lpResTable + sizeof(WORD));
    
    while (lpResTypeInfo->rt_id)
    {
        if ((lpResTypeInfo->rt_id & RSORDID) && (MAKEINTRESOURCE(lpResTypeInfo->rt_id & ~RSORDID) == (LPTSTR)lpResType))
        {
            lpResNameInfo = (LPRESNAMEINFO)(lpResTypeInfo+1);
            for (w=0; w < lpResTypeInfo->rt_nres; w++, lpResNameInfo++)
            {
                if ((lpResNameInfo->rn_id & RSORDID) && ((lpResNameInfo->rn_id & ~RSORDID) == iResId))
                    return(w+1);
            }
            return 0;
        }
        lpResTypeInfo = (LPRESTYPEINFO)((LPBYTE)(lpResTypeInfo+1) + lpResTypeInfo->rt_nres * sizeof(RESNAMEINFO));
    }
    return 0;
}


HANDLE SimpleLoadResource(HFILE fh, LPBYTE lpResTable, INT iResIndex, LPBYTE lpResType)
{
    INT      iShiftCount;
    HICON    hIcon;
    LPBYTE            lpIcon;
    DWORD             dwSize;
    DWORD             dwOffset;
    LPRESNAMEINFO     lpResPtr;
    
    /* The first 2 bytes in ResTable indicate the amount other values should be
    * shifted left.
    */
    iShiftCount = *((WORD *)lpResTable);
    
    lpResPtr = (LPRESNAMEINFO)FindResWithIndex(lpResTable, iResIndex, lpResType);
    
    if (!lpResPtr)
        return NULL;
    
    /* Left shift the offset to form a LONG. */
    dwOffset = MAKELONG(lpResPtr->rn_offset << iShiftCount, (lpResPtr->rn_offset) >> (16 - iShiftCount));
    dwSize = lpResPtr->rn_length << iShiftCount;
    
    if (M_llseek(fh, dwOffset, SEEK_FROMZERO) == -1L)
        return NULL;
    
    if (!(hIcon = GlobalAlloc(GMEM_ZEROINIT | GMEM_MOVEABLE, dwSize)))
        return NULL;
    
    if (!(lpIcon = GlobalLock(hIcon)))
        goto SLRErr1;
    
    if (_lread(fh, (LPVOID)lpIcon, dwSize) < dwSize)
        goto SLRErr2;
    
    GlobalUnlock(hIcon);
    return hIcon;
    
SLRErr2:
    GlobalUnlock(hIcon);
SLRErr1:
    GlobalFree(hIcon);
    return NULL;
}


VOID FreeIconList(HANDLE hIconList, int iKeepIcon)
{
    MYICONINFO *lpIconList;
    INT i;
    
    if (ExtractIconInfo.hIconList == hIconList) {
        ExtractIconInfo.hIconList = NULL;
    }
    if (NULL != (lpIconList = (MYICONINFO *)GlobalLock(hIconList))) {
        for (i = 0; i < ExtractIconInfo.nIcons; i++) {
            if (i != iKeepIcon) {
                DestroyIcon((lpIconList + i)->hIcon);
            }
        }
        GlobalUnlock(hIconList);
        GlobalFree(hIconList);
    }
}

VOID FreeExtractIconInfo(INT iKeepIcon)
{
    MYICONINFO *lpIconList;
    INT i;
    
    if (ExtractIconInfo.hIconList) {
        if (NULL != (lpIconList = (MYICONINFO *)GlobalLock(ExtractIconInfo.hIconList))) {
            for (i = 0; i < ExtractIconInfo.nIcons; i++) {
                if (i != iKeepIcon) {
                    DestroyIcon((lpIconList + i)->hIcon);
                }
            }
            GlobalUnlock(ExtractIconInfo.hIconList);
        }
        GlobalFree(ExtractIconInfo.hIconList);
        ExtractIconInfo.hIconList = NULL;
    }
    
    ExtractIconInfo.hAppInst = NULL;
    ExtractIconInfo.nIcons = 0;
    
    if (ExtractIconInfo.hFileName) {
        GlobalFree(ExtractIconInfo.hFileName);
        ExtractIconInfo.hFileName = NULL;
    }
}


HICON APIENTRY ExtractIconA(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex)
{
    if (lpszExeFileName) {
        LPWSTR lpszExeFileNameW;
        WORD wLen  = lstrlenA(lpszExeFileName) + 1;
        
        if (!(lpszExeFileNameW = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, (wLen * sizeof(WCHAR))))) {
            return NULL;
        } else {
            HICON hIcon;
            
            MultiByteToWideChar(CP_ACP, 0, lpszExeFileName, -1, lpszExeFileNameW, wLen-1);
            
            hIcon = ExtractIconW(hInst, lpszExeFileNameW, nIconIndex);
            
            LocalFree(lpszExeFileNameW);
            return hIcon;
            
        }
    } else {
        return NULL;
    }
}

// Returns a handle to a list of icons

HANDLE APIENTRY InternalExtractIconListW(HANDLE hInst, LPWSTR lpszExeFileName, LPINT lpnIcons)
{
    UINT cIcons, uiResult, i;
    UINT * lpIDs = NULL;
    HICON * lpIcons = NULL;
    HGLOBAL hIconInfo = NULL;
    MYICONINFO *lpIconInfo = NULL;
    
    
    //
    // Determine the number of icons
    //
    
    cIcons = PtrToUlong( ExtractIconW(hInst, lpszExeFileName, (UINT)-1));
    
    if (cIcons <= 0)
        return NULL;
    
    
    //
    // Allocate space for an array of UINT's and HICON's
    //
    
    lpIDs = GlobalAlloc(GPTR, cIcons * sizeof(UINT));
    if (!lpIDs) {
        goto IconList_Exit;
    }
    
    lpIcons = GlobalAlloc(GPTR, cIcons * sizeof(HICON));
    if (!lpIcons) {
        goto IconList_Exit;
    }
    
    
    //
    // Allocate space for the array of icons
    //
    
    hIconInfo = GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, cIcons * sizeof(MYICONINFO));
    if (!hIconInfo) {
        goto IconList_Exit;
    }
    
    
    //
    // This has to be GlobalLock'ed since the handle is going to
    // be passed back to the application.
    //
    
    lpIconInfo = GlobalLock(hIconInfo);
    if (!lpIconInfo) {
        goto IconList_Exit;
    }
    
    
    //
    // Call ExtractIcons to do the real work.
    //
    
    uiResult = ExtractIcons(lpszExeFileName,
        0,
        GetSystemMetrics(SM_CXICON),
        GetSystemMetrics(SM_CYICON),
        lpIcons,
        lpIDs,
        cIcons,
        0);
    
    if (uiResult <= 0) {
        goto IconList_Exit;
    }
    
    
    //
    // Loop through the icons and fill in the array.
    //
    
    for (i=0; i < cIcons; i++) {
        lpIconInfo[i].hIcon   = lpIcons[i];
        lpIconInfo[i].iIconId = lpIDs[i];
    }
    
    
    //
    // Unlock the array handle.
    //
    
    GlobalUnlock(hIconInfo);
    
    
    //
    // Clean up allocations
    //
    
    GlobalFree(lpIDs);
    GlobalFree(lpIcons);
    
    
    //
    // Success.
    //
    
    return hIconInfo;
    
    
IconList_Exit:
    
    //
    // Error case.  Clean up and return NULL
    //
    
    if (lpIconInfo)
        GlobalUnlock(hIconInfo);
    
    if (hIconInfo)
        GlobalFree(hIconInfo);
    
    if (lpIcons)
        GlobalFree(lpIcons);
    
    if (lpIDs)
        GlobalFree(lpIDs);
    
    return NULL;
}

HANDLE APIENTRY InternalExtractIconListA(HANDLE hInst, LPSTR lpszExeFileName, LPINT lpnIcons)
{
    return NULL;
}

/* ExtractVersionResource16W
* Retrieves a resource from win16 images.  Most of this code
* is stolen from ExtractIconResInfoW in ..\library\extract.c
*
* LPWSTR   lpwstrFilename - file to extract
* LPHANDLE lpData         - return buffer for handle, NULL if not needed
*
* Returns: size of buffer needed
*/

DWORD ExtractVersionResource16W(LPCWSTR  lpwstrFilename, LPHANDLE lphData)
{
    HFILE    fh;
    WORD     wMagic;
    
    INT       iTableSize;
    LPBYTE    lpResTable;
    DWORD     lOffset;
    HANDLE    hResTable;
    NEWEXEHDR NEHeader;
    HANDLE    hRes;
    DWORD     dwSize =0;
    
    //
    // Try to open the specified file.
    //
    
    fh = HandleToLong(CreateFileW(lpwstrFilename,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL));
    
    if (fh == HandleToLong(INVALID_HANDLE_VALUE)) {
        fh = HandleToLong(CreateFileW(lpwstrFilename,
            GENERIC_READ,
            0,
            NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    }
    
    if (fh == HandleToLong(INVALID_HANDLE_VALUE))
        return 0;
    
    //
    // Read the first two bytes in the file.
    //
    if (_lread(fh, (LPVOID)&wMagic, sizeof(wMagic)) != sizeof(wMagic))
        goto EIExit;
    
    switch (wMagic) {
    case MAGIC_MARKZIBO:
        
        //
        // Make sure that the file is in the NEW EXE format.
        //
        if (M_llseek(fh, (LONG)0x3C, SEEK_FROMZERO) == -1L)
            goto EIExit;
        
        if (_lread(fh, (LPVOID)&lOffset, sizeof(lOffset)) != sizeof(lOffset))
            goto EIExit;
        
        if (lOffset == 0L)
            goto EIExit;
        
        //
        // Read in the EXE header.
        //
        if (M_llseek(fh, lOffset, SEEK_FROMZERO) == -1L)
            goto EIExit;
        
        if (_lread(fh, (LPVOID)&NEHeader, sizeof(NEHeader)) != sizeof(NEHeader))
            goto EIExit;
        
        //
        // Is it a NEW EXE?
        //
        if (NE_MAGIC(NEHeader) != NEMAGIC)
            goto EIExit;
        
        if ((NE_EXETYP(NEHeader) != NE_WINDOWS) &&
            (NE_EXETYP(NEHeader) != NE_DEV386) &&
            (NE_EXETYP(NEHeader) != NE_UNKNOWN))  /* Some Win2.X apps have NE_UNKNOWN in this field */
            goto EIExit;
        
        //
        // Are there any resources?
        //
        if (NE_RSRCTAB(NEHeader) == NE_RESTAB(NEHeader))
            goto EIExit;
        
        //
        // Allocate space for the resource table.
        //
        iTableSize = NE_RESTAB(NEHeader) - NE_RSRCTAB(NEHeader);
        hResTable = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, (DWORD)iTableSize);
        
        if (!hResTable)
            goto EIExit;
        
        //
        // Lock down the resource table.
        lpResTable = GlobalLock(hResTable);
        
        if (!lpResTable) {
            GlobalFree(hResTable);
            goto EIExit;
        }
        
        //
        // Copy the resource table into memory.
        //
        if (M_llseek(fh,
            (LONG)(lOffset + NE_RSRCTAB(NEHeader)),
            SEEK_FROMZERO) == -1) {
            
            goto EIErrExit;
        }
        
        if (_lread(fh, (LPBYTE)lpResTable, iTableSize) != (DWORD)iTableSize)
            goto EIErrExit;
        
        //
        // Simply load the specified icon.
        //
        hRes = SimpleLoadResource(fh, lpResTable, 0, (LPBYTE)RT_VERSION);
        
        if (hRes) {
            dwSize = (DWORD) GlobalSize(hRes);
            
            if (lphData) {
                
                *lphData = hRes;
            } else {
                
                GlobalFree(hRes);
            }
        }
        
EIErrExit:
        GlobalUnlock(hResTable);
        GlobalFree(hResTable);
        break;
        
    }
EIExit:
    _lclose(fh);
    
    return dwSize;
}

/*  Returns the file's format: 2 for WIndows 2.X, 3 for WIndows 3.X,        */
/*                             0 if error.                                  */
/*  Returns the handle to the Icon resource corresponding to wIconIndex     */
/*  in lphIconRes, and the size of the resource in lpwSize.                 */
/*  This is used only by Progman which needs to save the icon resource      */
/*  itself in the .GRP files (the actual icon handle is not wanted).        */
/*                                                                          */
/*  08-04-91 JohanneC      Created.                                         */

WORD APIENTRY ExtractIconResInfoW(HANDLE hInst, LPWSTR lpszFileName, WORD wIconIndex, LPWORD lpwSize, LPHANDLE lphIconRes)
{
    HFILE    fh;
    WORD     wMagic;
    BOOL     bNewResFormat;
    HANDLE   hIconDir;         /* Icon directory */
    LPBYTE   lpIconDir;
    HICON    hIcon = NULL;
    BOOL     bFormatOK = FALSE;
    INT      nIconId;
    WCHAR    szFullPath[MAX_PATH];
    int      cchPath;
    
    /* Try to open the specified file. */
    /* Try to open the specified file. */
    cchPath = SearchPathW(NULL, lpszFileName, NULL, ARRAYSIZE(szFullPath), szFullPath, NULL);
    if (cchPath == 0 || cchPath >= MAX_PATH)
        return 0;
    
    fh = HandleToLong(CreateFileW((LPCWSTR)szFullPath, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    
    if (fh == HandleToLong(INVALID_HANDLE_VALUE)) {
        fh = HandleToLong(CreateFileW((LPCWSTR)szFullPath, GENERIC_READ, 0, NULL,
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));
    }
    
    if (fh == HandleToLong(INVALID_HANDLE_VALUE))
        return 0;
    
    /* Read the first two bytes in the file. */
    if (_lread(fh, (LPVOID)&wMagic, sizeof(wMagic)) != sizeof(wMagic))
        goto EIExit;
    
    switch (wMagic) {
    case MAGIC_ICON30:
        {
            INT           i;
            LPVOID        lpIcon;
            NEWHEADER     NewHeader;
            LPNEWHEADER   lpHeader;
            LPRESDIR      lpResDir;
            RESDIRDISK    ResDirDisk;
#define MAXICONS      10
            DWORD Offsets[MAXICONS];
            
            /* Only one icon per .ICO file. */
            if (wIconIndex) {
                break;
            }
            
            /* Read the header and check if it is a valid ICO file. */
            if (_lread(fh, ((LPBYTE)&NewHeader)+2, sizeof(NewHeader)-2) != sizeof(NewHeader)-2)
                goto EICleanup1;
            
            NewHeader.Reserved = MAGIC_ICON30;
            
            /* Check if the file is in correct format */
            if (NewHeader.ResType != 1)
                goto EICleanup1;
            
            /* Allocate enough space to create a Global Directory Resource. */
            hIconDir = GlobalAlloc(GHND, (LONG)(sizeof(NEWHEADER)+NewHeader.ResCount*sizeof(RESDIR)));
            if (hIconDir == NULL)
                goto EICleanup1;
            
            if ((lpHeader = (LPNEWHEADER)GlobalLock(hIconDir)) == NULL)
                goto EICleanup2;
            
            NewHeader.ResCount = (WORD)min((int)NewHeader.ResCount, MAXICONS);
            
            // fill in this structure for user
            
            *lpHeader = NewHeader;
            
            // read in the stuff from disk, transfer it to a memory structure
            // that user can deal with
            
            lpResDir = (LPRESDIR)(lpHeader + 1);
            for (i = 0; (WORD)i < NewHeader.ResCount; i++) {
                
                if (_lread(fh, (LPVOID)&ResDirDisk, sizeof(ResDirDisk)) < sizeof(RESDIR))
                    goto EICleanup3;
                
                Offsets[i] = ResDirDisk.Offset;
                
                *lpResDir = *((LPRESDIR)&ResDirDisk);
                lpResDir->idIcon = (WORD)(i+1);         // fill in the id
                
                lpResDir++;
            }
            
            /* Now that we have the Complete resource directory, let us find out the
            * suitable form of icon (that matches the current display driver).
            */
            lpIconDir = GlobalLock(hIconDir);
            if (!lpIconDir) {
                GlobalFree(hIconDir);
                goto EIErrExit;
            }
            wIconIndex = (WORD)(LookupIconIdFromDirectory(lpIconDir, TRUE) - 1);
            GlobalUnlock(hIconDir);
            lpResDir = (LPRESDIR)(lpHeader+1) + wIconIndex;
            
            /* Allocate memory for the Resource to be loaded. */
            if ((hIcon = GlobalAlloc(GMEM_ZEROINIT | GMEM_MOVEABLE, (DWORD)lpResDir->BytesInRes)) == NULL)
                goto EICleanup3;
            if ((lpIcon = GlobalLock(hIcon)) == NULL)
                goto EICleanup4;
            
            /* Seek to the correct place and read in the resource */
            if (M_llseek(fh, Offsets[wIconIndex], SEEK_FROMZERO) == -1L)
                goto EICleanup5;
            if (_lread(fh, (LPVOID)lpIcon, (DWORD)lpResDir->BytesInRes) < lpResDir->BytesInRes)
                goto EICleanup5;
            GlobalUnlock(hIcon);
            
            *lphIconRes = hIcon;
            *lpwSize = (WORD)lpResDir->BytesInRes;
            bFormatOK = TRUE;
            bNewResFormat = TRUE;
            goto EICleanup3;
            
EICleanup5:
            GlobalUnlock(hIcon);
EICleanup4:
            GlobalFree(hIcon);
            hIcon = (HICON)1;
EICleanup3:
            GlobalUnlock(hIconDir);
EICleanup2:
            GlobalFree(hIconDir);
EICleanup1:
            break;
        }
        
      case MAGIC_MARKZIBO:
          {
              INT           iTableSize;
              LPBYTE         lpResTable;
              DWORD         lOffset;
              HANDLE        hResTable;
              NEWEXEHDR     NEHeader;
              
              /* Make sure that the file is in the NEW EXE format. */
              if (M_llseek(fh, (LONG)0x3C, SEEK_FROMZERO) == -1L)
                  goto EIExit;
              if (_lread(fh, (LPVOID)&lOffset, sizeof(lOffset)) != sizeof(lOffset))
                  goto EIExit;
              if (lOffset == 0L)
                  goto EIExit;
              
              /* Read in the EXE header. */
              if (M_llseek(fh, lOffset, SEEK_FROMZERO) == -1L)
                  goto EIExit;
              if (_lread(fh, (LPVOID)&NEHeader, sizeof(NEHeader)) != sizeof(NEHeader))
                  goto EIExit;
              
              /* Is it a NEW EXE? */
              if (NE_MAGIC(NEHeader) != NEMAGIC)
                  goto EIExit;
              
              if ((NE_EXETYP(NEHeader) != NE_WINDOWS) &&
                  (NE_EXETYP(NEHeader) != NE_DEV386) &&
                  (NE_EXETYP(NEHeader) != NE_UNKNOWN))  /* Some Win2.X apps have NE_UNKNOWN in this field */
                  goto EIExit;
              
              hIcon = NULL;
              
              /* Are there any resources? */
              if (NE_RSRCTAB(NEHeader) == NE_RESTAB(NEHeader))
                  goto EIExit;
              
              /* Remember whether or not this is a Win3.0 EXE. */
              bNewResFormat = (NEHeader.ne_expver >= VER);
              
              /* Allocate space for the resource table. */
              iTableSize = NE_RESTAB(NEHeader) - NE_RSRCTAB(NEHeader);
              hResTable = GlobalAlloc(GMEM_ZEROINIT, (DWORD)iTableSize);
              if (!hResTable)
                  goto EIExit;
              
              /* Lock down the resource table. */
              lpResTable = GlobalLock(hResTable);
              if (!lpResTable) {
                  GlobalFree(hResTable);
                  goto EIExit;
              }
              
              /* Copy the resource table into memory. */
              if (M_llseek(fh, (LONG)(lOffset + NE_RSRCTAB(NEHeader)), SEEK_FROMZERO) == -1)
                  goto EIErrExit;
              if (_lread(fh, (LPBYTE)lpResTable, iTableSize) != (DWORD)iTableSize)
                  goto EIErrExit;
              
              
              /* Is this a Win3.0 EXE? */
              if (bNewResFormat) {
                  /* First, load the Icon directory. */
                  hIconDir = SimpleLoadResource(fh, lpResTable, (int)wIconIndex, (LPBYTE)RT_GROUP_ICON);
                  
                  if (!hIconDir)
                      goto EIErrExit;
                  lpIconDir = GlobalLock(hIconDir);
                  if (!lpIconDir) {
                      GlobalFree(hIconDir);
                      goto EIErrExit;
                  }
                  nIconId = LookupIconIdFromDirectory(lpIconDir, TRUE);
                  wIconIndex = (WORD)(GetResIndex(lpResTable, nIconId, (LPBYTE)RT_ICON) - 1);
                  GlobalUnlock(hIconDir);
                  /* We're finished with the icon directory. */
                  GlobalFree(hIconDir);
                  
                  
                  /* Now load the selected icon. */
                  *lphIconRes = SimpleLoadResource(fh, lpResTable, (int)wIconIndex, (LPBYTE)RT_ICON);
              }
              else {
                  /* Simply load the specified icon. */
                  *lphIconRes = SimpleLoadResource(fh, lpResTable, (int)wIconIndex, (LPBYTE)RT_ICON);
              }
              
              if (*lphIconRes) {
                  *lpwSize = (WORD)GlobalSize(*lphIconRes);
              }
              bFormatOK = TRUE;
              
EIErrExit:
              GlobalUnlock(hResTable);
              GlobalFree(hResTable);
              break;
          }
    }
EIExit:
    _lclose(fh);
    hInst;
    if (bFormatOK)
        return (WORD)(bNewResFormat ? 3 : 2);
    else
        return 0;
}

WORD APIENTRY ExtractIconResInfoA(HANDLE hInst, LPSTR lpszFileName, WORD wIconIndex, LPWORD lpwSize, LPHANDLE lphIconRes)
{
    if (lpszFileName) 
    {
        LPWSTR lpszFileNameW;
        WORD wLen = lstrlenA(lpszFileName) + 1;
        
        if (!(lpszFileNameW = (LPWSTR)LocalAlloc(LMEM_ZEROINIT, (wLen * sizeof(WCHAR))))) 
        {
            return 0;
        }
        else
        {
            WORD wRet;
            MultiByteToWideChar(CP_ACP, 0, lpszFileName, -1, lpszFileNameW, wLen - 1);
            wRet = ExtractIconResInfoW(hInst, lpszFileNameW, wIconIndex, lpwSize, lphIconRes);
            
            LocalFree(lpszFileNameW);
            return wRet;
        }
    }
    else 
    {
        return 0;
    }
}


//
// in:
//      lpIconPath      path of thing to extract icon for (may be an exe
//                      or something that is associated)
//      lpiIconIndex    icon index to use
//
// out:
//      lpIconPath      filled in with the real path where the icon came from
//      lpiIconIndex    filled in with the real icon index
//      lpiIconId       filled in with the icon id
//
// returns:
//      icon handle
//
// note: if the caller is progman it returns special icons from within progman
//
//

HICON APIENTRY ExtractAssociatedIconExW(HINSTANCE hInst, LPWSTR lpIconPath, LPWORD lpiIconIndex, LPWORD lpiIconId)
{
    WCHAR wszExePath[MAX_PATH];
    HICON hIcon;
    UINT idIcon = (UINT)-1;     // Don't know value
    BOOL fAssociated = FALSE;
    
    if ((INT)*lpiIconIndex == -1)
        return (HICON)NULL;
    
Retry:
    ExtractIcons(lpIconPath, *lpiIconIndex, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON),
        &hIcon, &idIcon, 1, 0);
    
    if (hIcon == NULL)
    {
        wszExePath[0] = TEXT('\0');
        
        FindExecutable(lpIconPath,NULL,wszExePath);
        
        //
        // If FindExecutable fails, or fAssociated
        // is true, or FindExecutable returns the
        // extact same filename it was looking for,
        // then issue the default icon from progman.
        //
        
        if (!*wszExePath || fAssociated ||
            (*wszExePath && (lstrcmpi(lpIconPath, wszExePath) == 0)))
        {
            LPTSTR lpId;
            WORD wDefIconId;
            HANDLE h;
            LPVOID p;
            //
            // Magic values from NT's old progman
            //
#define ITEMICON          7
#define DOSAPPICON        2
#define ITEMICONINDEX     6
#define DOSAPPICONINDEX   1
            
            if ( *wszExePath && (HasExtension(wszExePath) == 0) )
            {
                //
                // Generic Document icon processing
                //
                lpId = MAKEINTRESOURCE(ITEMICON);
                wDefIconId = ITEMICONINDEX;
            }
            else
            {
                //
                // Generic Program icon processing
                //
                lpId = MAKEINTRESOURCE(DOSAPPICON);
                wDefIconId = DOSAPPICONINDEX;
            }
            GetModuleFileName(hInst, lpIconPath, CCHICONPATHMAXLEN); // this API is exported, no cch param for us :(
            /*
            * Look up the icon id from the directory.
            */
            if (NULL != (h = FindResource(hInst, lpId, RT_GROUP_ICON))) {
                h = LoadResource(hInst, h);
                p = LockResource(h);
                *lpiIconId = (WORD)LookupIconIdFromDirectory(p, TRUE);
                UnlockResource(h);
                FreeResource(h);
            }
            *lpiIconIndex = wDefIconId;
            return LoadIcon(hInst, lpId);
        }
        SheRemoveQuotes(wszExePath);
        lstrcpyn(lpIconPath, wszExePath, CCHICONPATHMAXLEN); // this API is exported, no cch param for us :(
        fAssociated = TRUE;
        goto Retry;
    }
    
    *lpiIconId = (WORD) idIcon;    // Fill in with whatever we've found (or -1)
    
    return hIcon;
}


HICON APIENTRY ExtractAssociatedIconExA(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIconIndex, LPWORD lpiIconId)
{
    HICON hIcon = NULL;
    
    if (lpIconPath) 
    {
        BOOL fDefCharUsed;
        WCHAR IconPathW[MAX_PATH] = L"";
        
        MultiByteToWideChar(CP_ACP, 0, lpIconPath, -1 , (LPWSTR)IconPathW, ARRAYSIZE(IconPathW));
        hIcon = ExtractAssociatedIconExW(hInst, (LPWSTR)IconPathW, lpiIconIndex, lpiIconId);
        
        try 
        {
            WideCharToMultiByte(CP_ACP, 0, (LPWSTR)IconPathW, -1, lpIconPath, CCHICONPATHMAXLEN,
                NULL, &fDefCharUsed);
        }
        except(EXCEPTION_EXECUTE_HANDLER) 
        {
            hIcon = NULL;
        }
    }
    return hIcon;
}

//
// in:
//      lpIconPath      path of thing to extract icon for (may be an exe
//                      or something that is associated)
//      lpiIcon         icon index to use
//
// out:
//      lpIconPath      filled in with the real path where the icon came from
//      lpiIcon         filled in with the real icon index
//
// returns:
//      icon handle
//
// note: if the caller is progman it returns special icons from within progman
//
//

HICON APIENTRY ExtractAssociatedIconA(HINSTANCE hInst, LPSTR lpIconPath, LPWORD lpiIcon)
{
    HICON hIcon = NULL;
    
    if (lpIconPath) 
    {
        BOOL fDefCharUsed;
        WCHAR IconPathW[MAX_PATH] = L"";
        
        MultiByteToWideChar(CP_ACP, 0, lpIconPath, -1 , (LPWSTR)IconPathW, ARRAYSIZE(IconPathW));
        hIcon = ExtractAssociatedIconW(hInst, (LPWSTR)IconPathW, lpiIcon);
        
        try 
        {
            WideCharToMultiByte(CP_ACP, 0, (LPWSTR)IconPathW, -1, lpIconPath, CCHICONPATHMAXLEN,
                NULL, &fDefCharUsed);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            hIcon = NULL;
        }
    }
    return hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\executil.cpp ===
#include "shellprv.h"
#include "shlexec.h"
#include "netview.h"
extern "C" {
#include <badapps.h>
}
#include <htmlhelp.h>
#include "ole2dup.h"
#include <newexe.h>
#include "ids.h"

#define SAFE_DEBUGSTR(str)    ((str) ? (str) : "<NULL>")

HINSTANCE Window_GetInstance(HWND hwnd)
{
    DWORD idProcess;

    GetWindowThreadProcessId(hwnd, &idProcess);
    // HINSTANCEs are pointers valid only within
    // a single process, so 33 is returned to indicate success
    // as 0-32 are reserved for error.  (Actually 32 is supposed
    // to be a valid success return but some apps get it wrong.)

    return (HINSTANCE)(DWORD_PTR)(idProcess ? 33 : 0);
}

// Return TRUE if the window belongs to a 32bit or a Win4.0 app.
// NB We can't just check if it's a 32bit window
// since many apps use 16bit ddeml windows to communicate with the shell
// On NT we can.
BOOL Window_IsLFNAware(HWND hwnd)
{
    // 32-bit window
    return LOWORD(GetWindowLongPtr(hwnd,GWLP_HINSTANCE)) == 0;
}


#define COPYTODST(_szdst, _szend, _szsrc, _ulen, _ret) \
{ \
        UINT _utemp = _ulen; \
        if ((UINT)(_szend-_szdst) < _utemp + 1) { \
                return(_ret); \
        } \
        StrCpyN(_szdst, _szsrc, _utemp + 1); \
        _szdst += _utemp; \
}

/* Returns NULL if this is the last parm, pointer to next space otherwise
 */
LPTSTR _GetNextParm(LPCTSTR lpSrc, LPTSTR lpDst, UINT cchDst)
{
    LPCTSTR lpNextQuote, lpNextSpace;
    LPTSTR lpEnd = lpDst+cchDst-1;       // dec to account for trailing NULL
    BOOL fQuote;                        // quoted string?
    BOOL fDoubleQuote;                  // is this quote a double quote?

    while (*lpSrc == TEXT(' '))
        ++lpSrc;

    if (!*lpSrc)
        return(NULL);

    fQuote = (*lpSrc == TEXT('"'));
    if (fQuote)
        lpSrc++;   // skip leading quote

    for (;;)
    {
        lpNextQuote = StrChr(lpSrc, TEXT('"'));

        if (!fQuote)
        {
            // for an un-quoted string, copy all chars to first space/null

            lpNextSpace = StrChr(lpSrc, TEXT(' '));

            if (!lpNextSpace) // null before space! (end of string)
            {
                if (!lpNextQuote)
                {
                    // copy all chars to the null
                    if (lpDst)
                    {
                        COPYTODST(lpDst, lpEnd, lpSrc, lstrlen(lpSrc), NULL);
                    }
                    return NULL;
                }
                else
                {
                    // we have a quote to convert.  Fall through.
                }
            }
            else if (!lpNextQuote || lpNextSpace < lpNextQuote)
            {
                // copy all chars to the space
                if (lpDst)
                {
                    COPYTODST(lpDst, lpEnd, lpSrc, (UINT)(lpNextSpace-lpSrc), NULL);
                }
                return (LPTSTR)lpNextSpace;
            }
            else
            {
                // quote before space.  Fall through to convert quote.
            }
        }
        else if (!lpNextQuote)
        {
            // a quoted string without a terminating quote?  Illegal!
            ASSERT(0);
            return NULL;
        }

        // we have a potential quote to convert
        ASSERT(lpNextQuote);

        fDoubleQuote = *(lpNextQuote+1) == TEXT('"');
        if (fDoubleQuote)
            lpNextQuote++;      // so the quote is copied

        if (lpDst)
        {
            COPYTODST(lpDst, lpEnd, lpSrc, (UINT) (lpNextQuote-lpSrc), NULL);
        }

        lpSrc = lpNextQuote+1;

        if (!fDoubleQuote)
        {
            // we just copied the rest of this quoted string.  if this wasn't
            // quoted, it's an illegal string... treat the quote as a space.
            ASSERT(fQuote);
            return (LPTSTR)lpSrc;
        }
    }
}

#define PEMAGIC         ((WORD)'P'+((WORD)'E'<<8))

// Returns TRUE is app is LFN aware.
// This assumes all Win32 apps are LFN aware.

BOOL App_IsLFNAware(LPCTSTR pszFile)
{
    BOOL fRet = FALSE;
    
    // Assume Win 4.0 apps and Win32 apps are LFN aware.
    DWORD dw = GetExeType(pszFile);
    // TraceMsg(TF_SHELLEXEC, "s.aila: %s %s %x", pszFile, szFile, dw);
    if ((LOWORD(dw) == PEMAGIC) || ((LOWORD(dw) == NEMAGIC) && (HIWORD(dw) >= 0x0400)))
    {
        TCHAR sz[MAX_PATH];
        PathToAppPathKey(pszFile, sz, ARRAYSIZE(sz));
        
        fRet = (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, sz, TEXT("UseShortName"), NULL, NULL, NULL));
    }
    
    return fRet;
}

// apps can tag themselves in a way so we know we can pass an URL on the cmd
// line. this uses the existance of a value called "UseURL" under the
// App Paths key in the registry associated with the app that is passed in.

// pszPath is the path to the exe

BOOL DoesAppWantUrl(LPCTSTR pszPath)
{
    TCHAR sz[MAX_PATH];
    PathToAppPathKey(pszPath, sz, ARRAYSIZE(sz));
    return (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, sz, TEXT("UseURL"), NULL, NULL, NULL));
}

BOOL _AppIsLFNAware(LPCTSTR pszFile)
{
    TCHAR szFile[MAX_PATH];

    // Does it look like a DDE command?
    if (pszFile && *pszFile && (*pszFile != TEXT('[')))
    {
        // Nope - Hopefully just a regular old command %1 thing.
        lstrcpyn(szFile, pszFile, ARRAYSIZE(szFile));
	    LPTSTR pszArgs = PathGetArgs(szFile);
        if (*pszArgs)
            *(pszArgs - 1) = TEXT('\0');
        PathRemoveBlanks(szFile);   // remove any blanks that may be after the command
        PathUnquoteSpaces(szFile);
        return App_IsLFNAware(szFile);
    }
    return FALSE;
}

// in:
//      lpFile      exe name (used for %0 or %1 in replacement string)
//      lpFrom      string template to sub params and file into "excel.exe %1 %2 /n %3"
//      lpParams    parameter list "foo.txt bar.txt"
// out:
//      lpTo    output string with all parameters replaced
//
// supports:
//      %*      replace with all parameters
//      %0, %1  replace with file
//      %n      use nth parameter
//
// replace parameter placeholders (%1 %2 ... %n) with parameters
//
UINT ReplaceParameters(LPTSTR lpTo, UINT cchTo, LPCTSTR lpFile,
                       LPCTSTR lpFrom, LPCTSTR lpParms, int nShow, DWORD * pdwHotKey, BOOL fLFNAware,
                       LPCITEMIDLIST lpID, LPITEMIDLIST *ppidlGlobal)
{
    int i;
    TCHAR c;
    LPCTSTR lpT;
    TCHAR sz[MAX_PATH];
    BOOL fFirstParam = TRUE;
    LPTSTR lpEnd = lpTo + cchTo - 1;       // dec to allow trailing NULL
    LPTSTR pToOrig = lpTo;
    
    for (; *lpFrom; lpFrom++)
    {
        if (*lpFrom == TEXT('%'))
        {
            switch (*(++lpFrom))
            {
            case TEXT('~'): // Copy all parms starting with nth (n >= 2 and <= 9)
                c = *(++lpFrom);
                if (c >= TEXT('2') && c <= TEXT('9'))
                {
                    for (i = 2, lpT = lpParms; i < c-TEXT('0') && lpT; i++)
                    {
                        lpT = _GetNextParm(lpT, NULL, 0);
                    }
                    
                    if (lpT)
                    {
                        COPYTODST(lpTo, lpEnd, lpT, lstrlen(lpT), SE_ERR_ACCESSDENIED);
                    }
                }
                else
                {
                    lpFrom -= 2;            // Backup over %~ and pass through
                    goto NormalChar;
                }
                break;
                
            case TEXT('*'): // Copy all parms
                if (lpParms)
                {
                    COPYTODST(lpTo, lpEnd, lpParms, lstrlen(lpParms), SE_ERR_ACCESSDENIED);
                }
                break;
                
            case TEXT('0'):
            case TEXT('1'):
                // %0, %1, copy the file name
                // If the filename comes first then we don't need to convert it to
                // a shortname. If it appears anywhere else and the app is not LFN
                // aware then we must.
                if (!(fFirstParam || fLFNAware || _AppIsLFNAware(pToOrig)) &&
                    GetShortPathName(lpFile, sz, ARRAYSIZE(sz)) > 0)
                {
                    TraceMsg(TF_SHELLEXEC, "ShellExecuteEx: Getting short version of path.");
                    COPYTODST(lpTo, lpEnd, sz, lstrlen(sz), SE_ERR_ACCESSDENIED);
                }
                else
                {
                    TraceMsg(TF_SHELLEXEC, "ShellExecuteEx: Using long version of path.");
                    COPYTODST(lpTo, lpEnd, lpFile, lstrlen(lpFile), SE_ERR_ACCESSDENIED);
                }
                break;
                
            case TEXT('2'):
            case TEXT('3'):
            case TEXT('4'):
            case TEXT('5'):
            case TEXT('6'):
            case TEXT('7'):
            case TEXT('8'):
            case TEXT('9'):
                for (i = *lpFrom-TEXT('2'), lpT = lpParms; lpT; --i)
                {
                    if (i)
                        lpT = _GetNextParm(lpT, NULL, 0);
                    else
                    {
                        sz[0] = '\0'; // ensure a valid string, regardless of what happens within _GetNextParm
                        _GetNextParm(lpT, sz, ARRAYSIZE(sz));
                        COPYTODST(lpTo, lpEnd, sz, lstrlen(sz), SE_ERR_ACCESSDENIED);
                        break;
                    }
                }
                break;
                
            case TEXT('s'):
            case TEXT('S'):
                wnsprintf(sz, ARRAYSIZE(sz), TEXT("%ld"), nShow);
                COPYTODST(lpTo, lpEnd, sz, lstrlen(sz), SE_ERR_ACCESSDENIED);
                break;
                
            case TEXT('h'):
            case TEXT('H'):
                wnsprintf(sz, ARRAYSIZE(sz), TEXT("%X"), pdwHotKey ? *pdwHotKey : 0);
                COPYTODST(lpTo, lpEnd, sz, lstrlen(sz), SE_ERR_ACCESSDENIED);
                if (pdwHotKey)
                    *pdwHotKey = 0;
                break;
                
                // Note that a new global IDList is created for each
            case TEXT('i'):
            case TEXT('I'):
                // Note that a single global ID list is created and used over
                // again, so that it may be easily destroyed if anything
                // goes wrong
                if (ppidlGlobal)
                {
                    if (lpID && !*ppidlGlobal)
                    {
                        *ppidlGlobal = (LPITEMIDLIST)SHAllocShared(lpID,ILGetSize(lpID),GetCurrentProcessId());
                        if (!*ppidlGlobal)
                        {
                            return SE_ERR_OOM;
                        }
                    }
                    wnsprintf(sz, ARRAYSIZE(sz), TEXT(":%ld:%ld"), *ppidlGlobal, GetCurrentProcessId());
                }
                else
                {
                    StrCpyN(sz,TEXT(":0"), ARRAYSIZE(sz));
                }
                
                COPYTODST(lpTo, lpEnd, sz, lstrlen(sz), SE_ERR_ACCESSDENIED);
                break;
                
            case TEXT('l'):
            case TEXT('L'):
                // Like %1 only using the long name.
                // REVIEW UNDONE IANEL Remove the fFirstParam and fLFNAware stuff as soon as this
                // is up and running.
                TraceMsg(TF_SHELLEXEC, "ShellExecuteEx: Using long version of path.");
                COPYTODST(lpTo, lpEnd, lpFile, lstrlen(lpFile), SE_ERR_ACCESSDENIED);
                break;
                
            case TEXT('D'):
            case TEXT('d'):
                {
                    // %D gives the display name of an object.
                    if (lpID && SUCCEEDED(SHGetNameAndFlags(lpID, SHGDN_FORPARSING, sz, ARRAYSIZE(sz), NULL)))
                    {
                        COPYTODST(lpTo, lpEnd, sz, lstrlen(sz), SE_ERR_ACCESSDENIED);
                    }
                    else
                        return SE_ERR_ACCESSDENIED;
                    
                    break;
                }
                
            default:
                goto NormalChar;
              }
              // TraceMsg(TF_SHELLEXEC, "s.rp: Past first param (1).");
              fFirstParam = FALSE;
        }
        else
        {
NormalChar:
        // not a "%?" thing, just copy this to the destination
        
        if (lpEnd-lpTo < 2)
        {
            // Always check for room for DBCS char
            return(SE_ERR_ACCESSDENIED);
        }
        
        *lpTo++ = *lpFrom;
        // Special case for things like "%1" ie don't clear the first param flag
        // if we hit a dbl-quote.
        if (*lpFrom != TEXT('"'))
        {
            // TraceMsg(TF_SHELLEXEC, "s.rp: Past first param (2).");
            fFirstParam = FALSE;
        }
        else if (IsDBCSLeadByte(*lpFrom))
        {
            *lpTo++ = *(++lpFrom);
        }
        
        }
    }
    
    // We should always have enough room since we dec'ed cchTo when determining
    // lpEnd
    *lpTo = 0;
    
    // This means success
    return(0);
}

HWND ThreadID_GetVisibleWindow(DWORD dwID)
{
    HWND hwnd;
    for (hwnd = GetWindow(GetDesktopWindow(), GW_CHILD); hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        DWORD dwIDTmp = GetWindowThreadProcessId(hwnd, NULL);
        TraceMsg(TF_SHELLEXEC, "s.ti_gvw: Hwnd %x Thread ID %x.", hwnd, dwIDTmp);
        if (IsWindowVisible(hwnd) && (dwIDTmp == dwID))
        {
            TraceMsg(TF_SHELLEXEC, "s.ti_gvw: Found match %x.", hwnd);
            return hwnd;
        }
    }
    return NULL;
}

void ActivateHandler(HWND hwnd, DWORD_PTR dwHotKey)
{
    ASSERT(hwnd);
    hwnd = GetTopParentWindow(hwnd); // returns non-NULL for any non-NULL input
    HWND hwndT = GetLastActivePopup(hwnd); // returns non-NULL for any non-NULL input
    if (!IsWindowVisible(hwndT))
    {
        DWORD dwID = GetWindowThreadProcessId(hwnd, NULL);
        TraceMsg(TF_SHELLEXEC, "ActivateHandler: Hwnd %x Thread ID %x.", hwnd, dwID);
        ASSERT(dwID);
        // Find the first visible top level window owned by the
        // same guy that's handling the DDE conversation.
        hwnd = ThreadID_GetVisibleWindow(dwID);
        if (hwnd)
        {
            hwndT = GetLastActivePopup(hwnd);

            if (IsIconic(hwnd))
            {
                TraceMsg(TF_SHELLEXEC, "ActivateHandler: Window is iconic, restoring.");
                ShowWindow(hwnd,SW_RESTORE);
            }
            else
            {
                TraceMsg(TF_SHELLEXEC, "ActivateHandler: Window is normal, bringing to top.");
                BringWindowToTop(hwnd);
                if (hwndT && hwnd != hwndT)
                    BringWindowToTop(hwndT);

            }

            // set the hotkey
            if (dwHotKey) 
            {
                SendMessage(hwnd, WM_SETHOTKEY, dwHotKey, 0);
            }
        }
    }
}

BOOL FindExistingDrv(LPCTSTR pszUNCRoot, LPTSTR pszLocalName, DWORD cchLocalName)
{
    int iDrive;

    for (iDrive = 0; iDrive < 26; iDrive++)
    {
        if (IsRemoteDrive(iDrive))
        {
            TCHAR szDriveName[3];
            DWORD cb = MAX_PATH;
            szDriveName[0] = (TCHAR)iDrive + (TCHAR)TEXT('A');
            szDriveName[1] = TEXT(':');
            szDriveName[2] = 0;
            SHWNetGetConnection(szDriveName, pszLocalName, &cb);
            if (lstrcmpi(pszUNCRoot, pszLocalName) == 0)
            {
                StrCpyN(pszLocalName, szDriveName, cchLocalName);
                return(TRUE);
            }
        }
    }
    return(FALSE);
}

// Returns whether the given net path exists.  This fails for NON net paths.
//

BOOL NetPathExists(LPCTSTR lpszPath, DWORD *lpdwType)
{
    BOOL fResult = FALSE;
    NETRESOURCE nr;
    LPTSTR lpSystem;
    DWORD dwRes, dwSize = 1024;
    void * lpv;

    if (!lpszPath || !*lpszPath)
        return FALSE;

    lpv = (void *)LocalAlloc(LPTR, dwSize);
    if (!lpv)
        return FALSE;

TryWNetAgain:
    nr.dwScope = RESOURCE_GLOBALNET;
    nr.dwType = RESOURCETYPE_ANY;
    nr.dwDisplayType = 0;
    nr.lpLocalName = NULL;
    nr.lpRemoteName = (LPTSTR)lpszPath;
    nr.lpProvider = NULL;
    nr.lpComment = NULL;
    dwRes = WNetGetResourceInformation(&nr, lpv, &dwSize, &lpSystem);

    // If our buffer wasn't big enough, try a bigger buffer...
    if (dwRes == WN_MORE_DATA)
    {
        void * tmp = LocalReAlloc(lpv, dwSize, LMEM_MOVEABLE);
        if (!tmp)
        {
            LocalFree(lpv);
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        lpv = tmp;
        goto TryWNetAgain;
    }

    fResult = (dwRes == WN_SUCCESS);

    if (fResult && lpdwType)
        *lpdwType = ((LPNETRESOURCE)lpv)->dwType;

    LocalFree(lpv);

    return fResult;
}


HRESULT _CheckExistingNet(LPCTSTR pszFile, LPCTSTR pszRoot, BOOL fPrint)
{
    //
    // This used to be a call to GetFileAttributes(), but
    // GetFileAttributes() doesn't handle net paths very well.
    // However, we need to be careful, because other shell code
    // expects SHValidateUNC to return false for paths that point
    // to print shares.
    //
    HRESULT hr = S_FALSE;

    if (!PathIsRoot(pszFile))
    {
        // if we are checking for a printshare, then it must be a Root
        if (fPrint)
            hr = E_FAIL;
        else if (PathFileExists(pszFile))
            hr = S_OK;
    }

    if (S_FALSE == hr)
    {
        DWORD dwType;
        
        if (NetPathExists(pszRoot, &dwType))
        {
            if (fPrint ? dwType != RESOURCETYPE_PRINT : dwType == RESOURCETYPE_PRINT)
                hr = E_FAIL;
            else
                hr = S_OK;
        }
        else if (-1 != GetFileAttributes(pszRoot))
        {
            //
            // IE 4.01 SP1 QFE #104.  GetFileAttributes now called
            // as a last resort become some clients often fail when using
            // WNetGetResourceInformation.  For example, many NFS clients were
            // broken because of this.
            //
            hr = S_OK;
        }
    }

    if (hr == E_FAIL)
        SetLastError(ERROR_NOT_SUPPORTED);
        
    return hr;
}

HRESULT _CheckNetUse(HWND hwnd, LPTSTR pszShare, UINT fConnect, LPTSTR pszOut, DWORD cchOut)
{
    NETRESOURCE rc;
    DWORD dw, err;
    DWORD dwRedir = CONNECT_TEMPORARY;

    if (!(fConnect & VALIDATEUNC_NOUI))
        dwRedir |= CONNECT_INTERACTIVE;

    if (fConnect & VALIDATEUNC_CONNECT)
        dwRedir |= CONNECT_REDIRECT;

    // VALIDATE_PRINT happens only after a failed attempt to validate for
    // a file. That previous attempt will have given the option to
    // connect to other media -- don't do it here or the user will be
    // presented with the same dialog twice when the first one is cancelled.
    if (fConnect & VALIDATEUNC_PRINT)
        dwRedir |= CONNECT_CURRENT_MEDIA;

    rc.lpRemoteName = pszShare;
    rc.lpLocalName = NULL;
    rc.lpProvider = NULL;
    rc.dwType = (fConnect & VALIDATEUNC_PRINT) ? RESOURCETYPE_PRINT : RESOURCETYPE_DISK;

    err = WNetUseConnection(hwnd, &rc, NULL, NULL, dwRedir, pszOut, &cchOut, &dw);

    TraceMsg(TF_SHELLEXEC, "SHValidateUNC WNetUseConnection(%s) returned %x", pszShare, err);

    if (err)
    {
        SetLastError(err);
        return E_FAIL;
    }
    else if (fConnect & VALIDATEUNC_PRINT)        
    {
        //  just because WNetUse succeeded, doesnt mean 
        //  NetPathExists will.  if it fails then 
        //  we shouldnt succeed this call regardless
        //  because we are only interested in print shares.
        if (!NetPathExists(pszShare, &dw)
        || (dw != RESOURCETYPE_PRINT))
        {
            SetLastError(ERROR_NOT_SUPPORTED);
            return E_FAIL;
        }
    }

    return S_OK;
}

//
// SHValidateUNC
//
//  This function validates a UNC path by calling WNetAddConnection3.
//  It will make it possible for the user to type a remote (RNA) UNC
//  app/document name from Start->Run dialog.
//
//  fConnect    - flags controling what to do
//
//    VALIDATEUNC_NOUI                // dont bring up stinking UI!
//    VALIDATEUNC_CONNECT             // connect a drive letter
//    VALIDATEUNC_PRINT               // validate as print share instead of disk share
//
BOOL WINAPI SHValidateUNC(HWND hwndOwner, LPTSTR pszFile, UINT fConnect)
{
    HRESULT hr;
    TCHAR  szShare[MAX_PATH];
    BOOL fPrint = (fConnect & VALIDATEUNC_PRINT);
    UINT cchOrig = lstrlen(pszFile) + 1;

    ASSERT(PathIsUNC(pszFile));
    ASSERT((fConnect & ~VALIDATEUNC_VALID) == 0);
    ASSERT((fConnect & VALIDATEUNC_CONNECT) ? !fPrint : TRUE);

    lstrcpyn(szShare, pszFile, ARRAYSIZE(szShare));

    if (!PathStripToRoot(szShare))
    {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    if (fConnect & VALIDATEUNC_CONNECT)
        hr = S_FALSE;
    else
        hr = _CheckExistingNet(pszFile, szShare, fPrint);

    if (S_FALSE == hr)
    {
        TCHAR  szAccessName[MAX_PATH];

        if (!fPrint && FindExistingDrv(szShare, szAccessName, ARRAYSIZE(szAccessName)))
        {
            hr = S_OK;
        }
        else 
            hr = _CheckNetUse(hwndOwner, szShare, fConnect, szAccessName, SIZECHARS(szAccessName));


        if (S_OK == hr && !fPrint)
        {
            StrCatBuff(szAccessName, pszFile + lstrlen(szShare), ARRAYSIZE(szAccessName));
            // The name should only get shorter, so no need to check length
            lstrcpyn(pszFile, szAccessName, cchOrig);

            // Handle the root case
            if (cchOrig >= 4 && pszFile[2] == TEXT('\0'))
            {
                pszFile[2] = TEXT('\\');
                pszFile[3] = TEXT('\0');
            }

            hr = _CheckExistingNet(pszFile, szShare, FALSE);
        }
    }

    return (hr == S_OK);
}

HINSTANCE WINAPI RealShellExecuteExA(HWND hwnd, LPCSTR lpOp, LPCSTR lpFile,
                                   LPCSTR lpArgs, LPCSTR lpDir, LPSTR lpResult,
                                   LPCSTR lpTitle, LPSTR lpReserved,
                                   WORD nShowCmd, LPHANDLE lphProcess,
                                   DWORD dwFlags)
{
    SHELLEXECUTEINFOA sei = { sizeof(SHELLEXECUTEINFOA), SEE_MASK_FLAG_NO_UI|SEE_MASK_FORCENOIDLIST, hwnd, lpOp, lpFile, lpArgs, lpDir, nShowCmd, NULL};

    TraceMsg(TF_SHELLEXEC, "RealShellExecuteExA(%04X, %s, %s, %s, %s, %s, %s, %s, %d, %08lX, %d)",
                    hwnd, lpOp, lpFile, lpArgs, lpDir, lpResult, lpTitle,
                    lpReserved, nShowCmd, lphProcess, dwFlags);

    // Pass along the lpReserved parameter to the new process
    if (lpReserved)
    {
        sei.fMask |= SEE_MASK_RESERVED;
        sei.hInstApp = (HINSTANCE)lpReserved;
    }

    // Pass along the lpTitle parameter to the new process
    if (lpTitle)
    {
        sei.fMask |= SEE_MASK_HASTITLE;
        sei.lpClass = lpTitle;
    }

    // Pass along the SEPARATE_VDM flag
    if (dwFlags & EXEC_SEPARATE_VDM)
    {
        sei.fMask |= SEE_MASK_FLAG_SEPVDM;
    }

    // Pass along the NO_CONSOLE flag
    if (dwFlags & EXEC_NO_CONSOLE)
    {
        sei.fMask |= SEE_MASK_NO_CONSOLE;
    }

    if (lphProcess)
    {
        // Return the process handle
        sei.fMask |= SEE_MASK_NOCLOSEPROCESS;
        ShellExecuteExA(&sei);
        *lphProcess = sei.hProcess;
    }
    else
    {
        ShellExecuteExA(&sei);
    }

    return sei.hInstApp;
}

HINSTANCE WINAPI RealShellExecuteExW(HWND hwnd, LPCWSTR lpOp, LPCWSTR lpFile,
                                   LPCWSTR lpArgs, LPCWSTR lpDir, LPWSTR lpResult,
                                   LPCWSTR lpTitle, LPWSTR lpReserved,
                                   WORD nShowCmd, LPHANDLE lphProcess,
                                   DWORD dwFlags)
{
    SHELLEXECUTEINFOW sei = { sizeof(SHELLEXECUTEINFOW), SEE_MASK_FLAG_NO_UI|SEE_MASK_FORCENOIDLIST, hwnd, lpOp, lpFile, lpArgs, lpDir, nShowCmd, NULL};

    TraceMsg(TF_SHELLEXEC, "RealShellExecuteExW(%04X, %s, %s, %s, %s, %s, %s, %s, %d, %08lX, %d)",
                    hwnd, lpOp, lpFile, lpArgs, lpDir, lpResult, lpTitle,
                    lpReserved, nShowCmd, lphProcess, dwFlags);

    if (lpReserved)
    {
        sei.fMask |= SEE_MASK_RESERVED;
        sei.hInstApp = (HINSTANCE)lpReserved;
    }

    if (lpTitle)
    {
        sei.fMask |= SEE_MASK_HASTITLE;
        sei.lpClass = lpTitle;
    }

    if (dwFlags & EXEC_SEPARATE_VDM)
    {
        sei.fMask |= SEE_MASK_FLAG_SEPVDM;
    }

    if (dwFlags & EXEC_NO_CONSOLE)
    {
        sei.fMask |= SEE_MASK_NO_CONSOLE;
    }

    if (lphProcess)
    {
        // Return the process handle
        sei.fMask |= SEE_MASK_NOCLOSEPROCESS;
        ShellExecuteExW(&sei);
        *lphProcess = sei.hProcess;
    }
    else
    {
        ShellExecuteExW(&sei);
    }

    return sei.hInstApp;
}

HINSTANCE WINAPI RealShellExecuteA(HWND hwnd, LPCSTR lpOp, LPCSTR lpFile,
                                   LPCSTR lpArgs, LPCSTR lpDir, LPSTR lpResult,
                                   LPCSTR lpTitle, LPSTR lpReserved,
                                   WORD nShowCmd, LPHANDLE lphProcess)
{
    TraceMsg(TF_SHELLEXEC, "RealShellExecuteA(%04X, %s, %s, %s, %s, %s, %s, %s, %d, %08lX)",
                    hwnd, lpOp, lpFile, lpArgs, lpDir, lpResult, lpTitle,
                    lpReserved, nShowCmd, lphProcess);

    return RealShellExecuteExA(hwnd,lpOp,lpFile,lpArgs,lpDir,lpResult,lpTitle,lpReserved,nShowCmd,lphProcess,0);
}

HINSTANCE RealShellExecuteW(HWND hwnd, LPCWSTR lpOp, LPCWSTR lpFile,
                                   LPCWSTR lpArgs, LPCWSTR lpDir, LPWSTR lpResult,
                                   LPCWSTR lpTitle, LPWSTR lpReserved,
                                   WORD nShowCmd, LPHANDLE lphProcess)
{
    TraceMsg(TF_SHELLEXEC, "RealShellExecuteW(%04X, %s, %s, %s, %s, %s, %s, %s, %d, %08lX)",
                    hwnd, lpOp, lpFile, lpArgs, lpDir, lpResult, lpTitle,
                    lpReserved, nShowCmd, lphProcess);

    return RealShellExecuteExW(hwnd,lpOp,lpFile,lpArgs,lpDir,lpResult,lpTitle,lpReserved,nShowCmd,lphProcess,0);
}

HINSTANCE WINAPI ShellExecute(HWND hwnd, LPCTSTR lpOp, LPCTSTR lpFile, LPCTSTR lpArgs,
                               LPCTSTR lpDir, int nShowCmd)
{
    // NB The FORCENOIDLIST flag stops us from going through the ShellExecPidl()
    // code (for backwards compatability with progman).
    // DDEWAIT makes us synchronous, and gets around threads without
    // msg pumps and ones that are killed immediately after shellexec()
    
    SHELLEXECUTEINFO sei = { sizeof(SHELLEXECUTEINFO), 0, hwnd, lpOp, lpFile, lpArgs, lpDir, nShowCmd, NULL};
    ULONG fMask = SEE_MASK_FLAG_NO_UI|SEE_MASK_FORCENOIDLIST;
    if(!(SHGetAppCompatFlags(ACF_WIN95SHLEXEC) & ACF_WIN95SHLEXEC))
        fMask |= SEE_MASK_FLAG_DDEWAIT;
    sei.fMask = fMask;

    TraceMsg(TF_SHELLEXEC, "ShellExecute(%04X, %s, %s, %s, %s, %d)", hwnd, lpOp, lpFile, lpArgs, lpDir, nShowCmd);

    ShellExecuteEx(&sei);
    return sei.hInstApp;
}

HINSTANCE WINAPI ShellExecuteA(HWND hwnd, LPCSTR lpOp, LPCSTR lpFile, LPCSTR lpArgs,
                               LPCSTR lpDir, int nShowCmd)
{
    // NB The FORCENOIDLIST flag stops us from going through the ShellExecPidl()
    // code (for backwards compatability with progman).
    // DDEWAIT makes us synchronous, and gets around threads without
    // msg pumps and ones that are killed immediately after shellexec()
    SHELLEXECUTEINFOA sei = { sizeof(SHELLEXECUTEINFOA), 0, hwnd, lpOp, lpFile, lpArgs, lpDir, nShowCmd, NULL};
    ULONG fMask = SEE_MASK_FLAG_NO_UI|SEE_MASK_FORCENOIDLIST;
    if (!(SHGetAppCompatFlags(ACF_WIN95SHLEXEC) & ACF_WIN95SHLEXEC))
        fMask |= SEE_MASK_FLAG_DDEWAIT;
    sei.fMask = fMask;

    TraceMsg(TF_SHELLEXEC, "ShellExecuteA(%04X, %S, %S, %S, %S, %d)", hwnd,
        SAFE_DEBUGSTR(lpOp), SAFE_DEBUGSTR(lpFile), SAFE_DEBUGSTR(lpArgs),
        SAFE_DEBUGSTR(lpDir), nShowCmd);

    ShellExecuteExA(&sei);
    return sei.hInstApp;
}

// Returns TRUE if the specified app is listed under the specified key
STDAPI_(BOOL) IsNameListedUnderKey(LPCTSTR pszFileName, LPCTSTR pszKey)
{
    HKEY hkey;
    
    // Enum through the list of apps.
    
    if (RegOpenKeyEx(HKEY_CURRENT_USER, pszKey, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        TCHAR szValue[MAX_PATH], szData[MAX_PATH];
        DWORD dwType, cbData = sizeof(szData);
        DWORD cchValue = ARRAYSIZE(szValue);
        int iValue = 0;
        while (RegEnumValue(hkey, iValue, szValue, &cchValue, NULL, &dwType,
            (LPBYTE)szData, &cbData) == ERROR_SUCCESS)
        {
            if (lstrcmpi(szData, pszFileName) == 0)
            {
                RegCloseKey(hkey);
                return TRUE;
            }
            cbData = sizeof(szData);
            cchValue = ARRAYSIZE(szValue);
            iValue++;
        }
        RegCloseKey(hkey);
    }
    return FALSE;
}

#define REGSTR_PATH_POLICIES_EXPLORER REGSTR_PATH_POLICIES TEXT("\\Explorer\\RestrictRun")
#define REGSTR_PATH_POLICIES_EXPLORER_DISALLOW REGSTR_PATH_POLICIES TEXT("\\Explorer\\DisallowRun")

//----------------------------------------------------------------------------
// Returns TRUE if the specified app is not on the list of unrestricted apps.
BOOL RestrictedApp(LPCTSTR pszApp)
{
    LPTSTR pszFileName = PathFindFileName(pszApp);

    TraceMsg(TF_SHELLEXEC, "RestrictedApp: %s ", pszFileName);

    // Special cases:
    //     Apps you can always run.
    if (lstrcmpi(pszFileName, c_szRunDll) == 0)
        return FALSE;

    if (lstrcmpi(pszFileName, TEXT("systray.exe")) == 0)
        return FALSE;

    return !IsNameListedUnderKey(pszFileName, REGSTR_PATH_POLICIES_EXPLORER);
}

//----------------------------------------------------------------------------
// Returns TRUE if the specified app is on the list of disallowed apps.
// not much safety gained from filename checking.
BOOL DisallowedApp(LPCTSTR pszApp)
{
    LPTSTR pszFileName = PathFindFileName(pszApp);

    TraceMsg(TF_SHELLEXEC, "DisallowedApp: %s ", pszFileName);

    return IsNameListedUnderKey(pszFileName, REGSTR_PATH_POLICIES_EXPLORER_DISALLOW);
}

/*
 * Returns:
 *    S_OK or error.
 *    *phrHook is hook result if S_OK is returned, otherwise it is S_FALSE.
 */
HRESULT InvokeShellExecuteHook(REFGUID clsidHook, LPSHELLEXECUTEINFO pei, HRESULT *phrHook)
{
    *phrHook = S_FALSE;
    IUnknown *punk;
    HRESULT hr = SHExtCoCreateInstance(NULL, &clsidHook, NULL, IID_PPV_ARG(IUnknown, &punk));
    if (hr == S_OK)
    {
        IShellExecuteHook *pshexhk;
        hr = punk->QueryInterface(IID_PPV_ARG(IShellExecuteHook, &pshexhk));
        if (hr == S_OK)
        {
            *phrHook = pshexhk->Execute(pei);
            pshexhk->Release();
        }
        else
        {
            IShellExecuteHookA *pshexhkA;
            hr = punk->QueryInterface(IID_PPV_ARG(IShellExecuteHookA, &pshexhkA));
            if (SUCCEEDED(hr))
            {
                SHELLEXECUTEINFOA seia;
                UINT cchVerb = 0;
                UINT cchFile = 0;
                UINT cchParameters = 0;
                UINT cchDirectory  = 0;
                UINT cchClass = 0;
                LPSTR lpszBuffer;

                seia = *(SHELLEXECUTEINFOA*)pei;    // Copy all of the binary data

                if (pei->lpVerb)
                {
                    cchVerb = WideCharToMultiByte(CP_ACP,0,
                                                  pei->lpVerb, -1,
                                                  NULL, 0,
                                                  NULL, NULL) + 1;
                }

                if (pei->lpFile)
                    cchFile = WideCharToMultiByte(CP_ACP,0,
                                                  pei->lpFile, -1,
                                                  NULL, 0,
                                                  NULL, NULL)+1;

                if (pei->lpParameters)
                    cchParameters = WideCharToMultiByte(CP_ACP,0,
                                                        pei->lpParameters, -1,
                                                        NULL, 0,
                                                        NULL, NULL)+1;

                if (pei->lpDirectory)
                    cchDirectory = WideCharToMultiByte(CP_ACP,0,
                                                       pei->lpDirectory, -1,
                                                       NULL, 0,
                                                       NULL, NULL)+1;
                if (_UseClassName(pei->fMask) && pei->lpClass)
                    cchClass = WideCharToMultiByte(CP_ACP,0,
                                                   pei->lpClass, -1,
                                                   NULL, 0,
                                                   NULL, NULL)+1;

                lpszBuffer = (LPSTR) alloca(cchVerb+cchFile+cchParameters+cchDirectory+cchClass);

                seia.lpVerb = NULL;
                seia.lpFile = NULL;
                seia.lpParameters = NULL;
                seia.lpDirectory = NULL;
                seia.lpClass = NULL;

                //
                // Convert all of the strings to ANSI
                //
                if (pei->lpVerb)
                {
                    WideCharToMultiByte(CP_ACP, 0, pei->lpVerb, -1,
                                        lpszBuffer, cchVerb, NULL, NULL);
                    seia.lpVerb = lpszBuffer;
                    lpszBuffer += cchVerb;
                }
                if (pei->lpFile)
                {
                    WideCharToMultiByte(CP_ACP, 0, pei->lpFile, -1,
                                        lpszBuffer, cchFile, NULL, NULL);
                    seia.lpFile = lpszBuffer;
                    lpszBuffer += cchFile;
                }
                if (pei->lpParameters)
                {
                    WideCharToMultiByte(CP_ACP, 0,
                                        pei->lpParameters, -1,
                                        lpszBuffer, cchParameters, NULL, NULL);
                    seia.lpParameters = lpszBuffer;
                    lpszBuffer += cchParameters;
                }
                if (pei->lpDirectory)
                {
                    WideCharToMultiByte(CP_ACP, 0,
                                        pei->lpDirectory, -1,
                                        lpszBuffer, cchDirectory, NULL, NULL);
                    seia.lpDirectory = lpszBuffer;
                    lpszBuffer += cchDirectory;
                }
                if (_UseClassName(pei->fMask) && pei->lpClass)
                {
                    WideCharToMultiByte(CP_ACP, 0,
                                        pei->lpClass, -1,
                                        lpszBuffer, cchClass, NULL, NULL);
                    seia.lpClass = lpszBuffer;
                }

                *phrHook = pshexhkA->Execute(&seia);

                pei->hInstApp = seia.hInstApp;
                // hook may set hProcess (e.g. CURLExec creates dummy process
                // to signal IEAK that IE setup failed -- in browser only mode)
                pei->hProcess = seia.hProcess;

                pshexhkA->Release();
            }
        }
        punk->Release();
    }

    return(hr);
}

const TCHAR c_szShellExecuteHooks[] = REGSTR_PATH_EXPLORER TEXT("\\ShellExecuteHooks");

/*
 * Returns:
 *    S_OK     Execution handled by hook.  pei->hInstApp filled in.
 *    S_FALSE  Execution not handled by hook.  pei->hInstApp not filled in.
 *    E_...    Error during execution by hook.  pei->hInstApp filled in.
 */
HRESULT TryShellExecuteHooks(LPSHELLEXECUTEINFO pei)
{
    HRESULT hr = S_FALSE;
    HKEY hkeyHooks;

    // Enumerate the list of hooks.  A hook is registered as a GUID value of the
    // c_szShellExecuteHooks key.

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szShellExecuteHooks, 0, KEY_READ, &hkeyHooks)
        == ERROR_SUCCESS)
    {
        DWORD dwiValue;
        TCHAR szCLSID[GUIDSTR_MAX];
        DWORD cchCLSID;

        // Invoke each hook.  A hook returns S_FALSE if it does not handle the
        // exec.  Stop when a hook returns S_OK (handled) or an error.

        for (cchCLSID = ARRAYSIZE(szCLSID), dwiValue = 0;
             RegEnumValue(hkeyHooks, dwiValue, szCLSID, &cchCLSID, NULL,
                          NULL, NULL, NULL) == ERROR_SUCCESS;
             cchCLSID = ARRAYSIZE(szCLSID), dwiValue++)
        {
            CLSID clsidHook;

            if (SUCCEEDED(SHCLSIDFromString(szCLSID, &clsidHook)))
            {
                HRESULT hrHook;

                if (InvokeShellExecuteHook(clsidHook, pei, &hrHook) == S_OK &&
                    hrHook != S_FALSE)
                {
                    hr = hrHook;
                    break;
                }
            }
        }

        RegCloseKey(hkeyHooks);
    }

    ASSERT(hr == S_FALSE ||
           (hr == S_OK && ISSHELLEXECSUCCEEDED(pei->hInstApp)) ||
           (FAILED(hr) && ! ISSHELLEXECSUCCEEDED(pei->hInstApp)));

    return(hr);
}

BOOL InRunDllProcess(void)
{
    static BOOL s_fInRunDll = -1;

    if (-1 == s_fInRunDll)
    {
        TCHAR sz[MAX_PATH];
        s_fInRunDll = FALSE;
        if (GetModuleFileName(NULL, sz, SIZECHARS(sz)))
        {
            //  
            //  WARNING - rundll often seems to fail to add the DDEWAIT flag, and
            //  it often needs to since it is common to use rundll as a fire
            //  and forget process, and it exits too early.
            //
            // note: this changes DDE flags for any app with "rundll" in its name
            // shouldnt be a big deal from a security point of view.
            if (StrStrI(sz, TEXT("rundll")))
                s_fInRunDll = TRUE;
        }
    }

    return s_fInRunDll;
}

#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Validation function for SHELLEXECUTEINFO

*/
BOOL IsValidPSHELLEXECUTEINFO(LPSHELLEXECUTEINFO pei)
{
    //
    //  Note that we do *NOT* validate hInstApp, for several reasons.
    //
    //  1.  It is an OUT parameter, not an IN parameter.
    //  2.  It often contains an error code (see documentation).
    //  3.  Even when it contains an HINSTANCE, it's an HINSTANCE
    //      in another process, so we can't validate it anyway.
    //
    return (IS_VALID_WRITE_PTR(pei, SHELLEXECUTEINFO) &&
            IS_VALID_SIZE(pei->cbSize, sizeof(*pei)) &&
            (IsFlagSet(pei->fMask, SEE_MASK_FLAG_NO_UI) ||
             NULL == pei->hwnd ||
             IS_VALID_HANDLE(pei->hwnd, WND)) &&
            (NULL == pei->lpVerb || IS_VALID_STRING_PTR(pei->lpVerb, -1)) &&
            (NULL == pei->lpFile || IS_VALID_STRING_PTR(pei->lpFile, -1)) &&
            (NULL == pei->lpParameters || IS_VALID_STRING_PTR(pei->lpParameters, -1)) &&
            (NULL == pei->lpDirectory || IS_VALID_STRING_PTR(pei->lpDirectory, -1)) &&
            (IsFlagClear(pei->fMask, SEE_MASK_IDLIST) ||
             IsFlagSet(pei->fMask, SEE_MASK_INVOKEIDLIST) ||        // because SEE_MASK_IDLIST is part of SEE_MASK_INVOKEIDLIST this line will
             IS_VALID_PIDL((LPCITEMIDLIST)(pei->lpIDList))) &&      // defer to the next clause if the superset is true
            (IsFlagClear(pei->fMask, SEE_MASK_INVOKEIDLIST) ||
             NULL == pei->lpIDList ||
             IS_VALID_PIDL((LPCITEMIDLIST)(pei->lpIDList))) &&
            (!_UseClassName(pei->fMask) ||
             IS_VALID_STRING_PTR(pei->lpClass, -1)) &&
            (!_UseTitleName(pei->fMask) ||
             NULL == pei->lpClass ||
             IS_VALID_STRING_PTR(pei->lpClass, -1)) &&
            (!_UseClassKey(pei->fMask) ||
             IS_VALID_HANDLE(pei->hkeyClass, KEY)) &&
            (IsFlagClear(pei->fMask, SEE_MASK_ICON) ||
             IS_VALID_HANDLE(pei->hIcon, ICON)));
}

#endif // DEBUG

//
// ShellExecuteEx
//
// returns TRUE if the execute succeeded, in which case
//   hInstApp should be the hinstance of the app executed (>32)
//   NOTE: in some cases the HINSTANCE cannot (currently) be determined.
//   In these cases, hInstApp is set to 42.
//
// returns FALSE if the execute did not succeed, in which case
//   GetLastError will contain error information
//   For backwards compatibility, hInstApp will contain the
//     best SE_ERR_ error information (<=32) possible.
//

BOOL WINAPI ShellExecuteEx(LPSHELLEXECUTEINFO pei)
{
    DWORD err = NOERROR;

    // Don't overreact if CoInitializeEx fails; it just means we
    // can't do our shell hooks.
    HRESULT hrInit = SHCoInitialize();

    if (IS_VALID_STRUCT_PTR(pei, SHELLEXECUTEINFO) &&
        sizeof(*pei) == pei->cbSize)
    {
        // This internal bit prevents error message box reporting
        // when we recurse back into ShellExecuteEx
        ULONG ulOriginalMask = pei->fMask;
        pei->fMask |= SEE_MASK_FLAG_SHELLEXEC;
        if (SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"), TEXT("MaximizeApps"), 
            FALSE, FALSE)) //  && (GetSystemMetrics(SM_CYSCREEN)<=600))
        {
            switch (pei->nShow)
            {
            case SW_NORMAL:
            case SW_SHOW:
            case SW_RESTORE:
            case SW_SHOWDEFAULT:
                pei->nShow = SW_MAXIMIZE;
            }
        }

        if (!(pei->fMask & SEE_MASK_FLAG_DDEWAIT) && InRunDllProcess())
        {
            //  
            //  WARNING - rundll often seems to fail to add the DDEWAIT flag, and
            //  it often needs to since it is common to use rundll as a fire
            //  and forget process, and it exits too early.
            //
            pei->fMask |= (SEE_MASK_FLAG_DDEWAIT | SEE_MASK_WAITFORINPUTIDLE);
        }

        // ShellExecuteNormal does its own SetLastError
        err = ShellExecuteNormal(pei);

        // Mike's attempt to be consistent in error reporting:
        if (err != ERROR_SUCCESS)
        {
            // we shouldn't put up errors on dll's not found.
            // this is handled WITHIN shellexecuteNormal because
            // sometimes kernel will put up the message for us, and sometimes
            // we need to.  we've put the curtion at ShellExecuteNormal

            //  LEGACY - ERROR_RESTRICTED_APP was never mapped to a valid error - ZekeL 2001-FEB-14
            //  because we always called _ShellExecuteError() before
            //  resetting the mask to ulOriginalMask, we never mapped
            //  ERROR_RESTRICTED_APP (which is -1) to a valid code
            if (err != ERROR_DLL_NOT_FOUND &&
                err != ERROR_CANCELLED)
            {
                _ShellExecuteError(pei, NULL, err);
            }
        }

        pei->fMask = ulOriginalMask;
    }
    else
    {
        // Failed parameter validation
        pei->hInstApp = (HINSTANCE)SE_ERR_ACCESSDENIED;
        err =  ERROR_ACCESS_DENIED;
    }

    SHCoUninitialize(hrInit);

    if (err != ERROR_SUCCESS)
        SetLastError(err);
        
    return err == ERROR_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function:   ShellExecuteExA
//
//  Synopsis:   Thunks ANSI call to ShellExecuteA to ShellExecuteW
//
//  Arguments:  [pei] -- pointer to an ANSI SHELLEXECUTINFO struct
//
//  Returns:    BOOL success value
//
//  History:    2-04-95   bobday   Created
//              2-06-95   davepl   Changed to ConvertStrings
//
//  Notes:
//
//--------------------------------------------------------------------------

inline BOOL _ThunkClass(ULONG fMask)
{
    return (fMask & SEE_MASK_HASLINKNAME) 
        || (fMask & SEE_MASK_HASTITLE)
        || _UseClassName(fMask);
}

BOOL WINAPI ShellExecuteExA(LPSHELLEXECUTEINFOA pei)
{
    if (pei->cbSize != sizeof(SHELLEXECUTEINFOA))
    {
        pei->hInstApp = (HINSTANCE)SE_ERR_ACCESSDENIED;
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    SHELLEXECUTEINFOW seiw = {0};
    seiw.cbSize = sizeof(SHELLEXECUTEINFOW);
    seiw.fMask = pei->fMask;
    seiw.hwnd  = pei->hwnd;
    seiw.nShow = pei->nShow;

    if (_UseClassKey(pei->fMask))
        seiw.hkeyClass = pei->hkeyClass;

    if (pei->fMask & SEE_MASK_IDLIST)
        seiw.lpIDList = pei->lpIDList;

    if (pei->fMask & SEE_MASK_HOTKEY)
        seiw.dwHotKey = pei->dwHotKey;
    if (pei->fMask & SEE_MASK_ICON)
        seiw.hIcon = pei->hIcon;

    // Thunk the text fields as appropriate
    ThunkText *pThunkText = ConvertStrings(6,
                      pei->lpVerb,
                      pei->lpFile,
                      pei->lpParameters,
                      pei->lpDirectory,
                      _ThunkClass(pei->fMask) ? pei->lpClass : NULL,
                      (pei->fMask & SEE_MASK_RESERVED)  ? pei->hInstApp : NULL);

    if (NULL == pThunkText)
    {
        pei->hInstApp = (HINSTANCE)SE_ERR_OOM;
        return FALSE;
    }

    // Set our UNICODE text fields to point to the thunked strings
    seiw.lpVerb         = pThunkText->m_pStr[0];
    seiw.lpFile         = pThunkText->m_pStr[1];
    seiw.lpParameters   = pThunkText->m_pStr[2];
    seiw.lpDirectory    = pThunkText->m_pStr[3];
    seiw.lpClass        = pThunkText->m_pStr[4];
    seiw.hInstApp       = (HINSTANCE)pThunkText->m_pStr[5];

    // If we are passed the SEE_MASK_FILEANDURL flag, this means that
    // we have a lpFile parameter that has both the CacheFilename and the URL
    // (seperated by a single NULL, eg. "CacheFileName\0UrlName). We therefore
    // need to special case the thunking of pei->lpFile.
    LPWSTR pwszFileAndUrl = NULL;
    if (pei->fMask & SEE_MASK_FILEANDURL)
    {
        int iUrlLength;
        int iCacheFileLength = lstrlenW(pThunkText->m_pStr[1]);
        WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
        LPSTR pszUrlPart = (LPSTR)&pei->lpFile[iCacheFileLength + 1];


        if (IsBadStringPtrA(pszUrlPart, INTERNET_MAX_URL_LENGTH) || !PathIsURLA(pszUrlPart))
        {
            ASSERT(FALSE);
        }
        else
        {
            // we have a vaild URL, so thunk it
            iUrlLength = lstrlenA(pszUrlPart);

            DWORD cchFileAndUrl = iUrlLength + iCacheFileLength + 2;
            pwszFileAndUrl = (LPWSTR)LocalAlloc(LPTR, cchFileAndUrl * sizeof(WCHAR));
            if (!pwszFileAndUrl)
            {
                pei->hInstApp = (HINSTANCE)SE_ERR_OOM;
                return FALSE;
            }

            SHAnsiToUnicode(pszUrlPart, wszURL, ARRAYSIZE(wszURL));

            // construct the wide multi-string
            StrCpyNW(pwszFileAndUrl, pThunkText->m_pStr[1], cchFileAndUrl);
            StrCpyNW(&pwszFileAndUrl[iCacheFileLength + 1], wszURL, cchFileAndUrl - (iCacheFileLength + 1));
            seiw.lpFile = pwszFileAndUrl;
        }
    }

    // Call the real UNICODE ShellExecuteEx

    BOOL fRet = ShellExecuteEx(&seiw);

    pei->hInstApp = seiw.hInstApp;

    if (pei->fMask & SEE_MASK_NOCLOSEPROCESS)
    {
        pei->hProcess = seiw.hProcess;
    }

    LocalFree(pThunkText);
    if (pwszFileAndUrl)
        LocalFree(pwszFileAndUrl);

    return fRet;
}

// To display an error message appropriately, call this if ShellExecuteEx fails.
void _DisplayShellExecError(ULONG fMask, HWND hwnd, LPCTSTR pszFile, LPCTSTR pszTitle, DWORD dwErr)
{

    if (!(fMask & SEE_MASK_FLAG_NO_UI))
    {
        if (dwErr != ERROR_CANCELLED)
        {
            LPCTSTR pszHeader;
            UINT ids;

            // don't display "user cancelled", the user knows that already

            // make sure parent window is the foreground window
            if (hwnd)
                SetForegroundWindow(hwnd);

            if (pszTitle)
                pszHeader = pszTitle;
            else
                pszHeader = pszFile;

            // Use our messages when we can -- they're more descriptive
            switch (dwErr)
            {
            case 0:
            case ERROR_NOT_ENOUGH_MEMORY:
            case ERROR_OUTOFMEMORY:
                ids = IDS_LowMemError;
                break;

            case ERROR_FILE_NOT_FOUND:
                ids = IDS_RunFileNotFound;
                break;

            case ERROR_PATH_NOT_FOUND:
            case ERROR_BAD_PATHNAME:
                ids = IDS_PathNotFound;
                break;

            case ERROR_TOO_MANY_OPEN_FILES:
                ids = IDS_TooManyOpenFiles;
                break;

            case ERROR_ACCESS_DENIED:
                ids = IDS_RunAccessDenied;
                break;

            case ERROR_BAD_FORMAT:
                // NB CreateProcess, when execing a Win16 apps maps just about all of
                // these errors to BadFormat. Not very useful but there it is.
                ids = IDS_BadFormat;
                break;

            case ERROR_SHARING_VIOLATION:
                ids = IDS_ShareError;
                break;

            case ERROR_OLD_WIN_VERSION:
                ids = IDS_OldWindowsVer;
                break;

            case ERROR_APP_WRONG_OS:
                ids = IDS_OS2AppError;
                break;

            case ERROR_SINGLE_INSTANCE_APP:
                ids = IDS_MultipleDS;
                break;

            case ERROR_RMODE_APP:
                ids = IDS_RModeApp;
                break;

            case ERROR_INVALID_DLL:
                ids = IDS_InvalidDLL;
                break;

            case ERROR_NO_ASSOCIATION:
                ids = IDS_NoAssocError;
                break;

            case ERROR_DDE_FAIL:
                ids = IDS_DDEFailError;
                break;

            case ERROR_BAD_NET_NAME:
            case ERROR_SEM_TIMEOUT:
                ids = IDS_REASONS_BADNETNAME;
                break;
                
            //  LEGACY - ERROR_RESTRICTED_APP was never mapped to a valid error - ZekeL 2001-FEB-14
            //  because we always called _ShellExecuteError() before
            //  resetting the mask to ulOriginalMask, we never mapped
            //  ERROR_RESTRICTED_APP (which is -1) to a valid code
            case ERROR_RESTRICTED_APP:
                ids = IDS_RESTRICTIONS;
                // restrictions like to use IDS_RESTRICTIONSTITLE
                if (!pszTitle)
                    pszHeader = MAKEINTRESOURCE(IDS_RESTRICTIONSTITLE);
                break;


            // If we don't get a match, let the system handle it for us
            default:
                ids = 0;
                SHSysErrorMessageBox(
                    hwnd,
                    pszHeader,
                    IDS_SHLEXEC_ERROR,
                    dwErr,
                    pszFile,
                    MB_OK | MB_ICONSTOP);
                break;
            }

            if (ids)
            {
                ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(ids),
                        pszHeader, (ids == IDS_LowMemError)?
                        (MB_OK | MB_ICONSTOP | MB_SYSTEMMODAL):(MB_OK | MB_ICONSTOP),
                        pszFile);
            }
        }
    }

    SetLastError(dwErr); // The message box may have clobbered.

}

void _ShellExecuteError(LPSHELLEXECUTEINFO pei, LPCTSTR lpTitle, DWORD dwErr)
{
    ASSERT(!ISSHELLEXECSUCCEEDED(pei->hInstApp));

    // if dwErr not passed in, get it
    if (dwErr == 0)
        dwErr = GetLastError();

    _DisplayShellExecError(pei->fMask, pei->hwnd, pei->lpFile, lpTitle, dwErr);
}




//----------------------------------------------------------------------------
// Given a file name and directory, get the path to the execuatable that
// would be exec'd if you tried to ShellExecute this thing.
HINSTANCE WINAPI FindExecutable(LPCTSTR lpFile, LPCTSTR lpDirectory, LPTSTR lpResult)
{
    HINSTANCE hInstance = (HINSTANCE)42;    // assume success must be > 32
    TCHAR szOldDir[MAX_PATH];
    TCHAR szFile[MAX_PATH];
    LPCTSTR dirs[2];

    // Progman relies on lpResult being a ptr to an null string on error.
    *lpResult = TEXT('\0');
    GetCurrentDirectory(ARRAYSIZE(szOldDir), szOldDir);
    if (lpDirectory && *lpDirectory)
        SetCurrentDirectory(lpDirectory);
    else
        lpDirectory = szOldDir;     // needed for PathResolve()

    if (!GetShortPathName(lpFile, szFile, ARRAYSIZE(szFile))) {
        // if the lpFile is unqualified or bogus, let's use it down
        // in PathResolve.
        lstrcpyn(szFile, lpFile, ARRAYSIZE(szFile));
    }

    // get fully qualified path and add .exe extension if needed
    dirs[0] = (LPTSTR)lpDirectory;
    dirs[1] = NULL;
    if (!PathResolve(szFile, dirs, PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS | PRF_FIRSTDIRDEF))
    {
        // File doesn't exist, return file not found.
        hInstance = (HINSTANCE)SE_ERR_FNF;
        goto Exit;
    }

    TraceMsg(TF_SHELLEXEC, "FindExecutable: PathResolve -> %s", (LPCSTR)szFile);

    if (PathIsExe(szFile))
    {
        // public API, can't change to have cch.
        StrCpyN(lpResult, szFile, MAX_PATH);  // assumed length!
        goto Exit;
    }

    if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_EXECUTABLE, szFile, NULL, szFile, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szFile)))))
    {
        StrCpyN(lpResult, szFile, MAX_PATH);  // assumed length!
    }
    else
    {
        hInstance = (HINSTANCE)SE_ERR_NOASSOC;
    }

Exit:
    TraceMsg(TF_SHELLEXEC, "FindExec(%s) ==> %s", (LPTSTR)lpFile, (LPTSTR)lpResult);
    SetCurrentDirectory(szOldDir);
    return hInstance;
}

HINSTANCE WINAPI FindExecutableA(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult)
{
    HINSTANCE   hResult;
    WCHAR       wszResult[MAX_PATH];
    ThunkText * pThunkText = ConvertStrings(2, lpFile, lpDirectory);

    *lpResult = '\0';
    if (NULL == pThunkText)
    {
        return (HINSTANCE)SE_ERR_OOM;
    }

    hResult = FindExecutableW(pThunkText->m_pStr[0], pThunkText->m_pStr[1], wszResult);
    LocalFree(pThunkText);

    // FindExecutableW terminates wszResult for us, so this is safe
    // even if the above call fails

    // Thunk the output result string back to ANSI.  If the conversion fails,
    // or if the default char is used, we fail the API call.

    // public API, assume MAX_PATH
    if (0 == WideCharToMultiByte(CP_ACP, 0, wszResult, -1, lpResult, MAX_PATH, NULL, NULL))
    {
        SetLastError((DWORD)E_FAIL);
        return (HINSTANCE) SE_ERR_FNF;
    }

    return hResult;

}

//----------------------------------------------------------------------------
// Data structures for our wait for file open functions
//
typedef struct _WaitForItem * PWAITFORITEM;

typedef struct _WaitForItem
{
    DWORD           dwSize;
    DWORD           fOperation;    // Operation to perform
    PWAITFORITEM    pwfiNext;
    HANDLE          hEvent;         // Handle to event that was registered.
    UINT            iWaiting;       // Number of clients that are waiting.
    ITEMIDLIST      idlItem;        // pidl to wait for
} WAITFORITEM;

//
//  This is the form of the structure that is shoved into the shared memory
//  block.  It must be the 32-bit version for interoperability reasons.
//
typedef struct _WaitForItem32
{
    DWORD           dwSize;
    DWORD           fOperation;    // Operation to perform
    DWORD           NotUsed1;
    LONG            hEvent;        // Truncated event handle
    UINT            NotUsed2;
    ITEMIDLIST      idlItem;       // pidl to wait for
} WAITFORITEM32, *PWAITFORITEM32;

//
//  These macros enforce type safety so people are forced to use the
//  WAITFORITEM32 structure when accessing the shared memory block.
//
#define SHLockWaitForItem(h, pid) ((PWAITFORITEM32)SHLockShared(h, pid))

__inline void SHUnlockWaitForItem(PWAITFORITEM32 pwfi)
{
    SHUnlockShared(pwfi);
}

PWAITFORITEM g_pwfiHead = NULL;

HANDLE SHWaitOp_OperateInternal(DWORD fOperation, LPCITEMIDLIST pidlItem)
{
    PWAITFORITEM    pwfi;
    HANDLE  hEvent = (HANDLE)NULL;

    for (pwfi = g_pwfiHead; pwfi != NULL; pwfi = pwfi->pwfiNext)
    {
        if (ILIsEqual(&(pwfi->idlItem), pidlItem))
        {
            hEvent = pwfi->hEvent;
            break;
        }
    }

    if (fOperation & WFFO_ADD)
    {
        if (!pwfi)
        {
            UINT uSize;
            UINT uSizeIDList = 0;

            if (pidlItem)
                uSizeIDList = ILGetSize(pidlItem);

            uSize = sizeof(WAITFORITEM) + uSizeIDList;

            // Create an event to wait for
            hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

            if (hEvent)
                pwfi = (PWAITFORITEM)SHAlloc(uSize);

            if (pwfi)
            {
                pwfi->dwSize = uSize;
                // pwfi->fOperation = 0;       // Meaningless
                pwfi->hEvent = hEvent;
                pwfi->iWaiting = ((fOperation & WFFO_WAIT) != 0);

                memcpy(&(pwfi->idlItem), pidlItem, uSizeIDList);

                // now link it in
                pwfi->pwfiNext = g_pwfiHead;
                g_pwfiHead = pwfi;
            }
        }
    }

    if (pwfi)
    {
        if (fOperation & WFFO_WAIT)
            pwfi->iWaiting++;

        if (fOperation & WFFO_SIGNAL)
            SetEvent(hEvent);

        if (fOperation & WFFO_REMOVE)
            pwfi->iWaiting--;       // decrement in use count;

        // Only check removal case if not adding
        if ((fOperation & WFFO_ADD) == 0)
        {
            // Remove it if nobody waiting on it
            if (pwfi->iWaiting == 0)
            {
                if (g_pwfiHead == pwfi)
                    g_pwfiHead = pwfi->pwfiNext;
                else
                {
                    PWAITFORITEM pwfiT = g_pwfiHead;
                    while ((pwfiT != NULL) && (pwfiT->pwfiNext != pwfi))
                        pwfiT = pwfiT->pwfiNext;
                    ASSERT(pwfiT != NULL);
                    if (pwfiT != NULL)
                        pwfiT->pwfiNext = pwfi->pwfiNext;
                }

                // Close the handle
                CloseHandle(pwfi->hEvent);

                // Free the memory
                SHFree(pwfi);

                hEvent = NULL;          // NULL indicates nobody waiting... (for remove case)
            }
        }
    }

    return hEvent;
}

void SHWaitOp_Operate(HANDLE hWait, DWORD dwProcId)
{
    PWAITFORITEM32 pwfiFind = SHLockWaitForItem(hWait, dwProcId);
    if (pwfiFind)
    {
        pwfiFind->hEvent = HandleToLong(SHWaitOp_OperateInternal(pwfiFind->fOperation, &(pwfiFind->idlItem)));
        SHUnlockWaitForItem(pwfiFind);
    }
}

HANDLE SHWaitOp_Create(DWORD fOperation, LPCITEMIDLIST pidlItem, DWORD dwProcId)
{
    UINT    uSizeIDList = pidlItem ? ILGetSize(pidlItem) : 0;
    UINT    uSize = sizeof(WAITFORITEM32) + uSizeIDList;
    HANDLE hWaitOp = SHAllocShared(NULL, uSize, dwProcId);
    if (hWaitOp)
    {
        PWAITFORITEM32 pwfi = SHLockWaitForItem(hWaitOp,dwProcId);
        if (pwfi)
        {
            pwfi->dwSize = uSize;
            pwfi->fOperation = fOperation;
            pwfi->NotUsed1 = 0;
            pwfi->hEvent = HandleToLong((HANDLE)NULL);
            pwfi->NotUsed2 = 0;

            if (pidlItem)
                memcpy(&(pwfi->idlItem), pidlItem, uSizeIDList);

            SHUnlockWaitForItem(pwfi);
        }
        else
        {
            //  clean up
            SHFreeShared(hWaitOp, dwProcId);
            hWaitOp = NULL;
        }
    }

    return hWaitOp;
}

// This function allows the cabinet to wait for a
// file (in particular folders) to signal us that they are in an open state.
// This should take care of several synchronazation problems with the shell
// not knowing when a folder is in the process of being opened or not
//
STDAPI_(DWORD) SHWaitForFileToOpen(LPCITEMIDLIST pidl, UINT uOptions, DWORD dwTimeout)
{
    HWND    hwndShell;
    HANDLE  hWaitOp;
    HANDLE  hEvent = NULL;
    DWORD   dwProcIdSrc = GetCurrentProcessId();
    DWORD   dwReturn = WAIT_OBJECT_0; // we need a default

    hwndShell = GetShellWindow();

    if ((uOptions & (WFFO_WAIT | WFFO_ADD)) != 0)
    {
        if (hwndShell)
        {
            DWORD dwProcIdDst;
            GetWindowThreadProcessId(hwndShell, &dwProcIdDst);

            // Do just the add and/or wait portions
            hWaitOp = SHWaitOp_Create(uOptions & (WFFO_WAIT | WFFO_ADD), pidl, dwProcIdSrc);
            if (hWaitOp)
            {
                SendMessage(hwndShell, CWM_WAITOP, (WPARAM)hWaitOp, (LPARAM)dwProcIdSrc);

                // Now get the hEvent and convert to a local handle
                PWAITFORITEM32 pwfi = SHLockWaitForItem(hWaitOp, dwProcIdSrc);
                if (pwfi)
                {
                    hEvent = SHMapHandle(LongToHandle(pwfi->hEvent),dwProcIdDst, dwProcIdSrc, EVENT_ALL_ACCESS, 0);
                    SHUnlockWaitForItem(pwfi);
                }
                SHFreeShared(hWaitOp,dwProcIdSrc);
            }
        }
        else
        {
            // Do just the add and/or wait portions
            hEvent = SHWaitOp_OperateInternal(uOptions & (WFFO_WAIT | WFFO_ADD), pidl);
        }

        if (hEvent)
        {
            if (uOptions & WFFO_WAIT)
                dwReturn = SHProcessMessagesUntilEvent(NULL, hEvent, dwTimeout);

            if (hwndShell)          // Close the duplicated handle.
                CloseHandle(hEvent);
        }
    }

    if (uOptions & WFFO_REMOVE)
    {
        if (hwndShell)
        {
            hWaitOp = SHWaitOp_Create(WFFO_REMOVE, pidl, dwProcIdSrc);
            if (hWaitOp)
            {
                SendMessage(hwndShell, CWM_WAITOP, (WPARAM)hWaitOp, (LPARAM)dwProcIdSrc);
                SHFreeShared(hWaitOp,dwProcIdSrc);
            }
        }
        else
        {
            SHWaitOp_OperateInternal(WFFO_REMOVE, pidl);
        }
    }
    return dwReturn;
}


// Signals that the file is open
//
STDAPI_(BOOL) SignalFileOpen(LPCITEMIDLIST pidl)
{
    BOOL fResult = FALSE;
    HWND hwndShell = GetShellWindow();
    if (hwndShell)
    {
        PWAITFORITEM32 pwfi;
        DWORD dwProcId = GetCurrentProcessId();
        HANDLE  hWaitOp = SHWaitOp_Create(WFFO_SIGNAL, pidl, dwProcId);
        if (hWaitOp)
        {
            SendMessage(hwndShell, CWM_WAITOP, (WPARAM)hWaitOp, (LPARAM)dwProcId);

            // Now get the hEvent to determine return value...
            pwfi = SHLockWaitForItem(hWaitOp, dwProcId);
            if (pwfi)
            {
                fResult = (LongToHandle(pwfi->hEvent) != (HANDLE)NULL);
                SHUnlockWaitForItem(pwfi);
            }
            SHFreeShared(hWaitOp,dwProcId);
        }
    }
    else
    {
        fResult = (SHWaitOp_OperateInternal(WFFO_SIGNAL, pidl) == (HANDLE)NULL);
    }

    // Let everyone know that we opened something
    UINT uMsg = RegisterWindowMessage(SH_FILEOPENED);
    BroadcastSystemMessage(BSF_POSTMESSAGE, BSM_ALLCOMPONENTS, uMsg, NULL, NULL);

    return fResult;
}

//
// Checks to see if darwin is enabled.
//
BOOL IsDarwinEnabled()
{
    static BOOL s_fDarwinEnabled = TRUE;
    static BOOL s_fInit = FALSE;
    if (!s_fInit)
    {
        HKEY hkeyPolicy = 0;
        if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_POLICIES_EXPLORER, 0, KEY_READ, &hkeyPolicy) == ERROR_SUCCESS) 
        {
            if (SHQueryValueEx(hkeyPolicy, TEXT("DisableMSI"), NULL, NULL, NULL, NULL) == ERROR_SUCCESS)
            {
                s_fDarwinEnabled = FALSE;   // policy turns MSI off
            }
            RegCloseKey(hkeyPolicy);
        }
        s_fInit = TRUE;
    }
    return s_fDarwinEnabled;
}

// takes the darwin ID string from the registry, and calls darwin to get the
// full path to the application.
//
// IN:  pszDarwinDescriptor - this has the contents of the darwin key read out of the registry.
//                            it should contain a string like "[Darwin-ID-for-App] /switches".
//
// OUT: pszDarwinComand - the full path to the application to this buffer w/ switches.
//
STDAPI ParseDarwinID(LPTSTR pszDarwinDescriptor, LPTSTR pszDarwinCommand, DWORD cchDarwinCommand)
{
    DWORD dwError = CommandLineFromMsiDescriptor(pszDarwinDescriptor, pszDarwinCommand, &cchDarwinCommand);

    return HRESULT_FROM_WIN32(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fassoc.h ===
#ifndef FASSOC_H
#define FASSOC_H

STDAPI RevertLegacyVerb(LPCWSTR pszExt, LPCWSTR pszVerb);
STDAPI RevertLegacyClass(LPCWSTR pszExt);
STDAPI OpenHandlerKeyForExtension(LPCWSTR pszExt, LPCWSTR pszHandler, HKEY *phk);
STDAPI SHAssocEnumHandlers(LPCTSTR pszExtra, IEnumAssocHandlers **ppEnumHandler);

STDAPI CTaskEnumHKCR_Create(IRunnableTask **pptask);
STDAPI GetHandlerForBinary(LPCWSTR pszPath, LPWSTR pszHandler, DWORD cchHandler);

typedef enum
{
    UASET_CLEAR         = 0,
    UASET_APPLICATION,
    UASET_PROGID,
} UASET;

STDAPI UserAssocSet(UASET set, LPCWSTR pszExt, LPCWSTR pszSet);

//  helper class for using IAssocHandler
//  consumed by both fsassoc.cpp and openwith.cpp
class CAppInfo
{
public:
    CAppInfo(IAssocHandler *pah)
        : _pah(pah), _iIcon(-1)
    {
        _pah->AddRef();
    }

    ~CAppInfo()
    {
        if (_pszName)
            CoTaskMemFree(_pszName);
        if (_pszUIName)
            CoTaskMemFree(_pszUIName);

        _pah->Release();
    }

    BOOL Init()
    {
        return SUCCEEDED(_pah->GetName(&_pszName))
            && SUCCEEDED(_pah->GetUIName(&_pszUIName))
            && -1 != IconIndex();
    }
    
    IAssocHandler *Handler() { return _pah; }
    LPCWSTR Name() { return _pszName;}
    LPCWSTR UIName() { return _pszUIName;}
    int IconIndex()
    {
        CSmartCoTaskMem<WCHAR> pszIcon;
        int iIndex;
        if (_iIcon == -1 && SUCCEEDED(_pah->GetIconLocation(&pszIcon, &iIndex)))
        {
            _iIcon = Shell_GetCachedImageIndex(pszIcon, iIndex, 0);
            if (-1 == _iIcon)
            {
                _iIcon = Shell_GetCachedImageIndex(c_szShell32Dll, II_APPLICATION, 0);
            }
        }
        return _iIcon;
    }
            
protected:
    IAssocHandler *_pah;
    LPWSTR _pszName;
    LPWSTR _pszUIName;
    int _iIcon;
};

#endif //FASSOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fileenum.cpp ===
#include "shellprv.h"
#include "filefldr.h"
#include "recdocs.h"
#include "ids.h"
#include "mtpt.h"

class CFileSysEnum : public IEnumIDList
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IEnumIDList
    STDMETHOD(Next)(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)();
    STDMETHOD(Clone)(IEnumIDList **ppenum);
    
    CFileSysEnum(CFSFolder *pfsf, HWND hwnd, DWORD grfFlags);
    HRESULT Init();

private:
    ~CFileSysEnum();
    BOOL _FindNextFile();
    void _HideFiles();   // operates on _fd data

    LONG _cRef;

    CFSFolder *_pfsf;
    DWORD _grfFlags;
    HWND _hwnd;

    HANDLE _hfind;
    TCHAR _szFolder[MAX_PATH];
    BOOL _fMoreToEnum;
    WIN32_FIND_DATA _fd;
    int _cHiddenFiles;
    ULONGLONG _cbSize;

    IMruDataList *_pmruRecent;
    int _iIndexMRU;

    BOOL _fShowSuperHidden;
    BOOL _fIsRootDrive;
    BOOL _fIsCDFS;
};

CFileSysEnum::CFileSysEnum(CFSFolder *pfsf, HWND hwnd, DWORD grfFlags) : 
    _cRef(1), _pfsf(pfsf), _hwnd(hwnd), _grfFlags(grfFlags), _hfind(INVALID_HANDLE_VALUE)
{
    _fShowSuperHidden = ShowSuperHidden();

    _pfsf->AddRef();
}

CFileSysEnum::~CFileSysEnum()
{
    if (_hfind != INVALID_HANDLE_VALUE)
    {
        //  this handle can be the find file or MRU list in the case of RECENTDOCSDIR
        ATOMICRELEASE(_pmruRecent);
        FindClose(_hfind);

        _hfind = INVALID_HANDLE_VALUE;
    }
    _pfsf->Release();
}

HRESULT CFileSysEnum::Init()
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = _pfsf->_GetPath(_szFolder, ARRAYSIZE(_szFolder));

    if (SUCCEEDED(hr) && !PathIsUNC(_szFolder))
    {
        TCHAR szRoot[] = TEXT("A:\\");
        _fIsRootDrive = PathIsRoot(_szFolder);
        // For mapped net drives, register a change
        // notify alias for the corresponding UNC path.

        szRoot[0] = _szFolder[0];

        if (DRIVE_REMOTE == GetDriveType(szRoot))
        {
            MountPoint_RegisterChangeNotifyAlias(DRIVEID(_szFolder));
        }

        TCHAR szFileSystem[6];
        _fIsCDFS = (DRIVE_CDROM == GetDriveType(szRoot)) &&
                   GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, NULL, szFileSystem, ARRAYSIZE(szFileSystem)) &&
                   (StrCmpI(L"CDFS", szFileSystem) == 0);
    }

    if (SUCCEEDED(hr) &&
        PathCombine(szPath, _szFolder, c_szStarDotStar))
    {
        // let name mapper see the path/PIDL pair (for UNC root mapping)
        // skip the My Net Places entry when passing it to NPTRegisterNameToPidlTranslation.
        LPCITEMIDLIST pidlToMap = _pfsf->_pidlTarget ? _pfsf->_pidlTarget:_pfsf->_pidl;
        if (IsIDListInNameSpace(pidlToMap, &CLSID_NetworkPlaces))
        {
            NPTRegisterNameToPidlTranslation(_szFolder, _ILNext(pidlToMap));
        }

        if (_grfFlags == SHCONTF_FOLDERS)
        {
            // use mask to only find folders, mask is in the hi byte of dwFileAttributes
            // algorithm: (((attrib_on_disk & mask) ^ mask) == 0)
            // signature to tell SHFindFirstFileRetry() to use the attribs specified

            _fd.dwFileAttributes = (FILE_ATTRIBUTE_DIRECTORY << 8) |
                    FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY;
            _fd.dwReserved0 = 0x56504347;      
        }

        hr = SHFindFirstFileRetry(_hwnd, NULL, szPath, &_fd, &_hfind, SHPPFW_NONE);
        if (SUCCEEDED(hr))
        {
            _HideFiles();

            ASSERT(hr == S_OK ? (_hfind != INVALID_HANDLE_VALUE) : TRUE);

            _fMoreToEnum = (hr == S_OK);

            if (!(_grfFlags & SHCONTF_INCLUDEHIDDEN))
            {
                if (_pfsf->_IsCSIDL(CSIDL_RECENT))
                {
                    CreateRecentMRUList(&_pmruRecent);
                }
            }
            hr = S_OK;  // convert S_FALSE to S_OK to match ::EnumObjects() returns
        }
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
    {
        // Tracking target doesn't exist; return an empty enumerator
        _fMoreToEnum = FALSE;
        hr = S_OK;
    }
    else
    {
        // _GetPathForItem & PathCombine() fail when path is too long
        if (_hwnd)
        {
            ShellMessageBox(HINST_THISDLL, _hwnd, MAKEINTRESOURCE(IDS_ENUMERR_PATHTOOLONG),
                NULL, MB_OK | MB_ICONHAND);
        }

        // This error value tells callers that we have already displayed error UI so skip
        // displaying errors.
        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    return hr;
}

STDMETHODIMP CFileSysEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFileSysEnum, IEnumIDList),                        // IID_IEnumIDList
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFileSysEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFileSysEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

const LPCWSTR c_rgFilesToHideInRoot[] = 
{
    L"AUTOEXEC.BAT",    // case sensitive
    L"CONFIG.SYS",
    L"COMMAND.COM"
};

const LPCWSTR c_rgFilesToHideOnCDFS[] =
{
    L"thumbs.db",
    L"desktop.ini"
};

void CFileSysEnum::_HideFiles()
{
    // only do this if HIDDEN and SYSTEM attributes are not set on the file
    // (we assume if the file has these bits these files are setup properly)
    if (0 == (_fd.dwFileAttributes & (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY)))
    {
        // only do this for root drives
        if (_fIsRootDrive)
        {
            for (int i = 0; i < ARRAYSIZE(c_rgFilesToHideInRoot); i++)
            {
                // case sensitive to make it faster
                if (0 == StrCmpC(c_rgFilesToHideInRoot[i], _fd.cFileName))
                {
                    _fd.dwFileAttributes |= FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM;
                    break;
                }
            }
        }

        // only do this if we're on a normal CD filesystem
        if (_fIsCDFS)
        {
            for (int i = 0; i < ARRAYSIZE(c_rgFilesToHideOnCDFS); i++)
            {
                // dont share code from above since these can be upper or lower
                if (0 == StrCmpI(c_rgFilesToHideOnCDFS[i], _fd.cFileName))
                {
                    _fd.dwFileAttributes |= FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM;
                    break;
                }
            }
        }
    }
}

BOOL CFileSysEnum::_FindNextFile()
{
    BOOL fMoreToEnum = FALSE;

    if (_pmruRecent)
    {
        LPITEMIDLIST pidl;

        while (SUCCEEDED(RecentDocs_Enum(_pmruRecent, _iIndexMRU, &pidl)))
        {
            // confirm that the item stil exists in the file system, fill in the _fd data
            TCHAR szPath[MAX_PATH];
            HANDLE h;

            _pfsf->_GetPathForItem(_pfsf->_IsValidID(pidl), szPath, ARRAYSIZE(szPath));
            ILFree(pidl);

            h = FindFirstFile(szPath, &_fd);
            if (h != INVALID_HANDLE_VALUE)
            {
                fMoreToEnum = TRUE;
                _iIndexMRU++;
                FindClose(h);
                break;
            }
            else
            {
                //
                //  WARNING - if the list is corrupt we torch it - ZekeL 19-JUN-98
                //  we could do some special stuff, i guess, to weed out the bad
                //  items, but it seems simpler to just blow it away.
                //  the only reason this should happen is if somebody
                //  has been mushing around with RECENT directory directly,
                //  which they shouldnt do since it is hidden...
                //
                
                //  kill this invalid entry, and then try the same index again...
                _pmruRecent->Delete(_iIndexMRU);
            }
        }
    }
    else
    {
        fMoreToEnum = FindNextFile(_hfind, &_fd);
        _HideFiles();
    }

    return fMoreToEnum;
}

STDMETHODIMP CFileSysEnum::Next(ULONG celt, LPITEMIDLIST *ppidl, ULONG *pceltFetched)
{
    HRESULT hr;

    for (; _fMoreToEnum; _fMoreToEnum = _FindNextFile())
    {
        if (_fMoreToEnum == (BOOL)42)
            continue;   // we already processed the current item, skip it now

        if (PathIsDotOrDotDot(_fd.cFileName))
            continue;

        if (!(_grfFlags & SHCONTF_STORAGE))
        {
            if (_fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if (!(_grfFlags & SHCONTF_FOLDERS))
                    continue;   // item is folder but client does not want folders
            }
            else if (!(_grfFlags & SHCONTF_NONFOLDERS))
                continue;   // item is file, but client only wants folders

            // skip hidden and system things unconditionally, don't even count them
            if (!_fShowSuperHidden && IS_SYSTEM_HIDDEN(_fd.dwFileAttributes))
                continue;
        }

        _cbSize += MAKELONGLONG(_fd.nFileSizeLow, _fd.nFileSizeHigh);

        if (!(_grfFlags & (SHCONTF_INCLUDEHIDDEN | SHCONTF_STORAGE)) &&
             (_fd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN))
        {
            _cHiddenFiles++;
            continue;
        }
        break;
    }

    if (_fMoreToEnum)
    {
        hr = _pfsf->_CreateIDList(&_fd, NULL, ppidl);
        _fMoreToEnum = (BOOL)42;    // we have processed the current item, skip it next time
    }
    else
    {
        *ppidl = NULL;
        hr = S_FALSE; // no more items
        // completed the enum, stash some items back into the folder 
        // PERF ??: we could QueryService for the view callback at this point and
        // poke these in directly there instead of pushing these into the folder
        _pfsf->_cHiddenFiles = _cHiddenFiles;
        _pfsf->_cbSize = _cbSize;
    }

    if (pceltFetched)
        *pceltFetched = (hr == S_OK) ? 1 : 0;

    return hr;
}


STDMETHODIMP CFileSysEnum::Skip(ULONG celt) 
{
    return E_NOTIMPL;
}

STDMETHODIMP CFileSysEnum::Reset() 
{
    return S_OK;
}

STDMETHODIMP CFileSysEnum::Clone(IEnumIDList **ppenum) 
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDAPI CFSFolder_CreateEnum(CFSFolder *pfsf, HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    HRESULT hr;
    CFileSysEnum *penum = new CFileSysEnum(pfsf, hwnd, grfFlags);
    if (penum)
    {
        hr = penum->Init();
        if (SUCCEEDED(hr))
            hr = penum->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
        penum->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppenum = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\filefldr.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "ole2dup.h"
#include "copy.h"

#include <regstr.h>
#include <comcat.h>
#include <intshcut.h>
#include "_security.h"

#include "ovrlaymn.h"

#include "filefldr.h"
#include "drives.h"
#include "netview.h"

#include <filetype.h>
#include "shitemid.h"

#include "infotip.h"
#include "recdocs.h"
#include <idhidden.h>
#include "datautil.h"
#include "deskfldr.h"
#include "prop.h"           // COLUMN_INFO

#include <oledb.h>          // IFilter stuff
#include <query.h>
#include <ntquery.h>
#include <filterr.h>
#include <ciintf.h>

#include "folder.h"
#include "ids.h"
#include "category.h"
#include "stgenum.h"
#include "clsobj.h"
#include "stgutil.h"
#include "sfstorage.h"
#include "mtpt.h"

#include "defcm.h"

STDAPI CFolderInfoTip_CreateInstance(IUnknown *punkOutter, LPCTSTR pszFolder, REFIID riid, void **ppv);

#define SHCF_IS_BROWSABLE           (SHCF_IS_SHELLEXT | SHCF_IS_DOCOBJECT)

#define CSIDL_NORMAL    ((UINT)-2)  // has to not be -1

#define E_OFFLINE HRESULT_FROM_WIN32(ERROR_MEDIA_OFFLINE)

// File-scope pointer to a ShellIconOverlayManager
// Callers access this pointer through GetIconOverlayManager().
static IShellIconOverlayManager * g_psiom = NULL;

// #define FULL_DEBUG

TCHAR const c_szCLSIDSlash[] = TEXT("CLSID\\");
TCHAR const c_szShellOpenCmd[] = TEXT("shell\\open\\command");

TCHAR g_szFolderTypeName[32] = TEXT("");    // "Folder" 
TCHAR g_szFileTypeName[32] = TEXT("");      // "File"
TCHAR g_szFileTemplate[32] = TEXT("");      // "ext File"

enum
{
    FS_ICOL_NAME = 0,
    FS_ICOL_SIZE,
    FS_ICOL_TYPE,
    FS_ICOL_WRITETIME,
    FS_ICOL_CREATETIME,
    FS_ICOL_ACCESSTIME,
    FS_ICOL_ATTRIB,
    FS_ICOL_CSC_STATUS,
};

const COLUMN_INFO c_fs_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,            30, IDS_NAME_COL),
    DEFINE_COL_SIZE_ENTRY(SCID_SIZE,               IDS_SIZE_COL),
    DEFINE_COL_STR_ENTRY(SCID_TYPE,            20, IDS_TYPE_COL),
    DEFINE_COL_DATE_ENTRY(SCID_WRITETIME,          IDS_MODIFIED_COL),
    // these are off by default (don't have SHCOLSTATE_ONBYDEFAULT) set
    DEFINE_COL_ENTRY(SCID_CREATETIME, VT_DATE, LVCFMT_LEFT, 20, SHCOLSTATE_TYPE_DATE, IDS_EXCOL_CREATE),
    DEFINE_COL_ENTRY(SCID_ACCESSTIME, VT_DATE, LVCFMT_LEFT, 20, SHCOLSTATE_TYPE_DATE | SHCOLSTATE_SECONDARYUI, IDS_EXCOL_ACCESSTIME),
    DEFINE_COL_ENTRY(SCID_ATTRIBUTES, VT_LPWSTR, LVCFMT_LEFT, 10, SHCOLSTATE_TYPE_STR, IDS_ATTRIB_COL),
    DEFINE_COL_STR_DLG_ENTRY(SCID_CSC_STATUS, 10, IDS_CSC_STATUS),
};

//
// List of file attribute bit values.  The order (with respect
// to meaning) must match that of the characters in g_szAttributeChars[].
//
const DWORD g_adwAttributeBits[] =
{
    FILE_ATTRIBUTE_READONLY,
    FILE_ATTRIBUTE_HIDDEN,
    FILE_ATTRIBUTE_SYSTEM,
    FILE_ATTRIBUTE_ARCHIVE,
    FILE_ATTRIBUTE_COMPRESSED,
    FILE_ATTRIBUTE_ENCRYPTED,
    FILE_ATTRIBUTE_OFFLINE
};

//
// Buffer for characters that represent attributes in Details View attributes
// column.  Must provide room for 1 character for each bit a NUL.  The current 5
// represent Read-only, Archive, Compressed, Hidden and System in that order.
// This can't be const because we overwrite it using LoadString.
//
TCHAR g_szAttributeChars[ARRAYSIZE(g_adwAttributeBits) + 1] = { 0 } ;

// order here is important, first one found will terminate the search
const int c_csidlSpecial[] = {
    CSIDL_STARTMENU | TEST_SUBFOLDER,
    CSIDL_COMMON_STARTMENU | TEST_SUBFOLDER,
    CSIDL_RECENT,
    CSIDL_WINDOWS,
    CSIDL_SYSTEM,
    CSIDL_PERSONAL,
    CSIDL_FONTS
};

BOOL CFSFolder::_IsCSIDL(UINT csidl)
{
    BOOL bRet = (_csidl == csidl);
    if (!bRet)
    {
        TCHAR szPath[MAX_PATH];

        _GetPath(szPath, ARRAYSIZE(szPath));
        bRet = PathIsEqualOrSubFolder(MAKEINTRESOURCE(csidl), szPath);
        if (bRet)
            _csidl = csidl;
    }
    return bRet;
}

UINT CFSFolder::_GetCSIDL()
{
    // Cache the special folder ID, if it is not cached yet.
    if (_csidl == -1)
    {
        TCHAR szPath[MAX_PATH];

        _GetPath(szPath, ARRAYSIZE(szPath));

        // Always cache the real Csidl.
        _csidl = GetSpecialFolderID(szPath, c_csidlSpecial, ARRAYSIZE(c_csidlSpecial));         

        if (_csidl == -1)
        {
            _csidl = CSIDL_NORMAL;   // default
        }
    }

    return _csidl;
}

STDAPI_(LPCIDFOLDER) CFSFolder::_IsValidID(LPCITEMIDLIST pidl)
{

    if (pidl && pidl->mkid.cb && (((LPCIDFOLDER)pidl)->bFlags & SHID_GROUPMASK) == SHID_FS)
        return (LPCIDFOLDER)pidl;

    return NULL;
}

// folder.{guid} or file.{guid}
// system | readonly folder with desktop.ini and CLSID={guid} in the desktop.ini
// file.ext where ext corresponds to a shell extension (such as .cab/.zip)
// see _MarkAsJunction

inline BOOL CFSFolder::_IsJunction(LPCIDFOLDER pidf)
{
    return pidf->bFlags & SHID_JUNCTION;
}

inline BYTE CFSFolder::_GetType(LPCIDFOLDER pidf)
{ 
    return pidf->bFlags & SHID_FS_TYPEMASK; 
}

// this tests for old simple pidls that use SHID_FS
// typically this only happens with persisted pidls in upgrade scenarios (shortcuts in the start menu)
inline BOOL CFSFolder::_IsSimpleID(LPCIDFOLDER pidf)
{ 
    return _GetType(pidf) == SHID_FS; 
}

inline LPIDFOLDER CFSFolder::_FindLastID(LPCIDFOLDER pidf)
{
    return (LPIDFOLDER)ILFindLastID((LPITEMIDLIST)pidf); 
}

inline LPIDFOLDER CFSFolder::_Next(LPCIDFOLDER pidf)
{
    return (LPIDFOLDER)_ILNext((LPITEMIDLIST)pidf); 
}

// special marking for "All Users" items on the desktop (this is a hack to support the desktop
// folder delegating to the approprate shell folder and is not generally useful)

BOOL CFSFolder::_IsCommonItem(LPCITEMIDLIST pidl)
{
    if (pidl && pidl->mkid.cb && (((LPCIDFOLDER)pidl)->bFlags & (SHID_GROUPMASK | SHID_FS_COMMONITEM)) == SHID_FS_COMMONITEM)
        return TRUE;
    return FALSE;
}

// a win32 file (might be a shell extension .cab/.zip that behaves like a folder)
BOOL CFSFolder::_IsFile(LPCIDFOLDER pidf)
{
    BOOL bRet = _GetType(pidf) == SHID_FS_FILE || _GetType(pidf) == SHID_FS_FILEUNICODE;
    // if it's a file, it shouldn't be a folder.
    // if it's not a file, usually it's a folder -- except if the type is SHID_FS,
    // that's okay too because it's a simple pidl in a .lnk from a downlevel shell.
    ASSERT(bRet ? !_IsFolder(pidf) : (_IsFolder(pidf) || _IsSimpleID(pidf)));
    return bRet;
}

// it is a win32 file system folder (maybe a junction, maybe not)
BOOL CFSFolder::_IsFolder(LPCIDFOLDER pidf)
{
    BOOL bRet = _GetType(pidf) == SHID_FS_DIRECTORY || _GetType(pidf) == SHID_FS_DIRUNICODE;
    ASSERT(bRet ? (pidf->wAttrs & FILE_ATTRIBUTE_DIRECTORY) : !(pidf->wAttrs & FILE_ATTRIBUTE_DIRECTORY));
    return bRet;
}

// is it a file system folder that is not a junction
BOOL CFSFolder::_IsFileFolder(LPCIDFOLDER pidf)
{
    return _IsFolder(pidf) && !_IsJunction(pidf);
}

// non junction, but has the system or readonly bit (regular folder marked special for us)
BOOL CFSFolder::_IsSystemFolder(LPCIDFOLDER pidf)
{
    return _IsFileFolder(pidf) && (pidf->wAttrs & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY));
}

// this is a heuristic to determine if the IDList was created
// normally or with a simple bind context (null size/mod date)

BOOL CFSFolder::_IsReal(LPCIDFOLDER pidf)
{
    return pidf->dwSize || pidf->dateModified ? TRUE : FALSE;
}

DWORD CFSFolder::_GetUID(LPCIDFOLDER pidf)
{
    return pidf->dwSize + ((DWORD)pidf->dateModified << 8) + ((DWORD)pidf->timeModified << 12);
}

ULONGLONG CFSFolder::_Size(LPCIDFOLDER pidf)
{
    ULONGLONG cbSize = pidf->dwSize;
    if (cbSize == 0xFFFFFFFF)
    {
        HANDLE hfind;
        WIN32_FIND_DATA wfd = {0};
        TCHAR szPath[MAX_PATH];

        // Get the real size by asking the file system
        _GetPathForItem(pidf, szPath, ARRAYSIZE(szPath));

        if (SHFindFirstFileRetry(NULL, NULL, szPath, &wfd, &hfind, SHPPFW_NONE) != S_OK)
        {
            cbSize = 0;
        }
        else
        {
            FindClose(hfind);

            ULARGE_INTEGER uli;
            uli.LowPart = wfd.nFileSizeLow;
            uli.HighPart = wfd.nFileSizeHigh;

            cbSize = uli.QuadPart;
        }
    }
    return cbSize;
}

LPWSTR CFSFolder::_CopyName(LPCIDFOLDER pidf, LPWSTR pszName, UINT cchName)
{
    CFileSysItem fsi(pidf);
    return (LPWSTR) fsi.MayCopyFSName(TRUE, pszName, cchName);
}

BOOL CFSFolder::_ShowExtension(LPCIDFOLDER pidf)
{
    CFileSysItemString fsi(pidf);
    return fsi.ShowExtension(_DefaultShowExt());
}

BOOL CFSFolder::_DefaultShowExt()
{
    if (_tbDefShowExt == TRIBIT_UNDEFINED)
    {
        SHELLSTATE ss;
        SHGetSetSettings(&ss, SSF_SHOWEXTENSIONS, FALSE);
        _tbDefShowExt = ss.fShowExtensions ? TRIBIT_TRUE : TRIBIT_FALSE;
    }
    return _tbDefShowExt == TRIBIT_TRUE;
}

BOOL CFileSysItemString::ShowExtension(BOOL fDefaultShowExt)
{
    DWORD dwFlags = ClassFlags(FALSE);

    if (dwFlags & SHCF_NEVER_SHOW_EXT)
        return FALSE;

    if (fDefaultShowExt)
        return TRUE;

    return dwFlags & (SHCF_ALWAYS_SHOW_EXT | SHCF_UNKNOWN);
}

//
// return a pointer to the type name for the given PIDL
// the pointer is only valid while in a critical section
//
LPCTSTR CFSFolder::_GetTypeName(LPCIDFOLDER pidf)
{
    CFileSysItemString fsi(pidf);
    
    ASSERTCRITICAL

    LPCTSTR pszClassName = LookupFileClassName(fsi.Class());
    if (pszClassName == NULL)
    {
        WCHAR sz[80];
        IQueryAssociations *pqa;
        HRESULT hr = fsi.AssocCreate(NULL, FALSE, IID_PPV_ARG(IQueryAssociations, &pqa));
        if (SUCCEEDED(hr))
        {
            DWORD cch = ARRAYSIZE(sz);
            hr = pqa->GetString(0, ASSOCSTR_FRIENDLYDOCNAME, NULL, sz, &cch);
            if (SUCCEEDED(hr))
            {
                pszClassName = AddFileClassName(fsi.Class(), sz);
            }
            pqa->Release();
        }
    }

    return pszClassName;
}

//
// return the type name for the given PIDL
//
HRESULT CFSFolder::_GetTypeNameBuf(LPCIDFOLDER pidf, LPTSTR pszName, int cchNameMax)
{
    HRESULT hr = S_OK;
    
    ENTERCRITICAL;
    LPCTSTR pszSource = _GetTypeName(pidf);

    // pszSource will be NULL if the file does not have an extension.
    if (!pszSource)
    {
        pszSource = TEXT(""); // Terminate Buffer
        hr = E_FAIL;
    }

    StrCpyN(pszName, pszSource, cchNameMax);
    LEAVECRITICAL;
    
    return hr;
}

//
// Build a text string containing characters that represent attributes of a file.
// The attribute characters are assigned as follows:
// (R)eadonly, (H)idden, (S)ystem, (A)rchive, (H)idden.
//
void BuildAttributeString(DWORD dwAttributes, LPTSTR pszString, UINT nChars)
{
    // Make sure we have attribute chars to build this string out of
    if (!g_szAttributeChars[0])
        LoadString(HINST_THISDLL, IDS_ATTRIB_CHARS, g_szAttributeChars, ARRAYSIZE(g_szAttributeChars));

    // Make sure buffer is big enough to hold worst-case attributes
    ASSERT(nChars >= ARRAYSIZE(g_adwAttributeBits) + 1);

    for (int i = 0; i < ARRAYSIZE(g_adwAttributeBits); i++)
    {
        if (dwAttributes & g_adwAttributeBits[i])
            *pszString++ = g_szAttributeChars[i];
    }
    *pszString = 0;     // null terminate

}

// BryanSt: This doesn't work with FRAGMENTs.  We should return the path
// without the Fragment for backward compatibility and then callers that care,
// can later determine that and take care of it.
//

// in/out:
//      pszPath path to append pidf names to
// in:
//      pidf        relative pidl fragment

HRESULT CFSFolder::_AppendItemToPath(LPTSTR pszPath, DWORD cchPath, LPCIDFOLDER pidf)
{
    HRESULT hr = S_OK;
    LPTSTR pszPathCur = pszPath + lstrlen(pszPath);

    //  e want to do this, but we stil have broken code in SHGetPathFromIDList
    // ASSERT(_FindJunctionNext(pidf) == NULL);     // no extra goo please

    for (; SUCCEEDED(hr) && !ILIsEmpty((LPITEMIDLIST)pidf); pidf = _Next(pidf))
    {
        CFileSysItemString fsi(pidf);
        int cchName = lstrlen(fsi.FSName());    // store the length of szName, to avoid calculating it twice

        // mil 142338: handle bogus pidls that have multiple "C:"s in them
        // due to bad shortcut creation.
        if ((cchName == 2) && (fsi.FSName()[1] == TEXT(':')))
        {
            pszPathCur = pszPath;
        }
        else
        {
            // ASSERT(lstrlen(pszPath)+lstrlen(szName)+2 <= MAX_PATH);
            if (((pszPathCur - pszPath) + cchName + 2) > MAX_PATH)
            {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW); // FormatMessage = "The file name is too long"
                break;
            }

            LPTSTR pszTmp = CharPrev(pszPath, pszPathCur);
            if (*pszTmp != TEXT('\\'))
                *(pszPathCur++) = TEXT('\\');
        }

        StrCpyN(pszPathCur, fsi.FSName(), cchPath - (pszPathCur - pszPath));

        pszPathCur += cchName;
    }

    if (FAILED(hr))
        *pszPath = 0;

    return hr;
}

// get the file system folder path for this
//
// HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) is returned if we are a tracking
// folder that does not (yet) have a valid target.
HRESULT CFSFolder::_GetPath(LPTSTR pszPath, DWORD cchPath)
{
    HRESULT hr = E_FAIL;

    if (_csidlTrack >= 0)
    {
        hr = SHGetFolderPath(NULL, _csidlTrack | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, pszPath);
        if (hr == S_FALSE || FAILED(hr))
            hr = HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
    }
    else if (_pszPath)
    {
        hr = StringCchCopy(pszPath, cchPath, _pszPath);
    }
    else
    {
        if (_pidlTarget &&  
            SUCCEEDED(SHGetNameAndFlags(_pidlTarget, SHGDN_FORPARSING, pszPath, MAX_PATH, NULL)))
        {
            _pszPath = StrDup(pszPath); // remember this for next caller
            hr = S_OK;
        }
        else if (SUCCEEDED(SHGetNameAndFlags(_pidl, SHGDN_FORPARSING, pszPath, MAX_PATH, NULL)))
        {
            _pszPath = StrDup(pszPath); // remember this for next caller
            hr = S_OK;
        }
    }

    if (hr == S_OK && (0 == *pszPath))
        hr = E_FAIL; // old behavior was to fail if pszPath was empty
    return hr;
}


// Will fail (return FALSE) if not a mount point
BOOL CFSFolder::_GetMountingPointInfo(LPCIDFOLDER pidf, LPTSTR pszMountPoint, DWORD cchMountPoint)
{
    BOOL bRet = FALSE;
    // Is this a reparse point?
    if (FILE_ATTRIBUTE_REPARSE_POINT & pidf->wAttrs)
    {
        TCHAR szLocalMountPoint[MAX_PATH];

        if (SUCCEEDED(_GetPathForItem(pidf, szLocalMountPoint, ARRAYSIZE(szLocalMountPoint))))
        {
            int iDrive = PathGetDriveNumber(szLocalMountPoint);
            if (-1 != iDrive)
            {
                TCHAR szDrive[4];
                if (DRIVE_REMOTE != GetDriveType(PathBuildRoot(szDrive, iDrive)))
                {
                    TCHAR szVolumeName[50]; //50 according to doc
                    PathAddBackslash(szLocalMountPoint);

                    // Check if it is a mounting point
                    if (GetVolumeNameForVolumeMountPoint(szLocalMountPoint, szVolumeName,
                        ARRAYSIZE(szVolumeName)))
                    {
                        bRet = TRUE;

                        if (pszMountPoint && cchMountPoint)
                            StrCpyN(pszMountPoint, szLocalMountPoint, cchMountPoint);
                    }
                }
            }
        }
    }
    return bRet;
}

// in:
//      pidf    may be NULL, or multi level item to append to path for this folder
// out:
//      pszPath MAX_PATH buffer to receive the fully qualified file path for the item
//

HRESULT CFSFolder::_GetPathForItem(LPCIDFOLDER pidf, LPWSTR pszPath, DWORD cchPath)
{
    if (SUCCEEDED(_GetPath(pszPath, cchPath)))
    {
        if (pidf)
        {
            return _AppendItemToPath(pszPath, cchPath, pidf);
        }
        return S_OK;
    }
    return E_FAIL;
}


HRESULT CFSFolder::_GetPathForItems(LPCIDFOLDER pidfParent, LPCIDFOLDER pidfLast, LPTSTR pszPath, DWORD cchPath)
{
    HRESULT hr = _GetPathForItem(pidfParent ? pidfParent : pidfLast, pszPath, cchPath);
    if (SUCCEEDED(hr) && pidfParent)
        hr = _AppendItemToPath(pszPath, cchPath, pidfLast);

    return hr;
}


BOOL _GetIniPath(BOOL fCreate, LPCTSTR pszFolder, LPCTSTR pszProvider, LPTSTR pszPath)
{
    BOOL fExists = FALSE;
    
    PathCombine(pszPath, pszFolder, c_szDesktopIni);

    // CHECK for PathFileExists BEFORE calling to GetPrivateProfileString
    // because if the file isn't there (which is the majority of cases)
    // GetPrivateProfileString hits the disk twice looking for the file

    if (pszProvider && *pszProvider)
    {
        union {
            NETRESOURCE nr;
            TCHAR buf[512];
        } nrb;
        LPTSTR lpSystem;
        DWORD dwRes, dwSize = sizeof(nrb);

        nrb.nr.dwType = RESOURCETYPE_ANY;
        nrb.nr.lpRemoteName = pszPath;
        nrb.nr.lpProvider = (LPTSTR)pszProvider;    // const -> non const
        dwRes = WNetGetResourceInformation(&nrb.nr, &nrb, &dwSize, &lpSystem);

        fExists = (dwRes == WN_SUCCESS) || (dwRes == WN_MORE_DATA);
    }
    else
    {
        fExists = PathFileExists(pszPath);
    }

    if (fCreate && !fExists)
    {
        //  we need to touch this file first
        HANDLE h = CreateFile(pszPath, 0, FILE_SHARE_DELETE, NULL, CREATE_NEW, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM, NULL);
        if (INVALID_HANDLE_VALUE != h)
        {
            PathMakeSystemFolder(pszFolder);
            fExists = TRUE;
            CloseHandle(h);
        }
    }

    return fExists;
}

STDAPI_(BOOL) SetFolderString(BOOL fCreate, LPCTSTR pszFolder, LPCTSTR pszProvider, LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszData)
{
    TCHAR szPath[MAX_PATH];
    if (_GetIniPath(fCreate, pszFolder, pszProvider, szPath))
    {
        return SHSetIniStringUTF7(pszSection, pszKey, pszData, szPath);
    }
    return FALSE;
}

//
// This function retrieves the private profile strings from the desktop.ini file and
// return it through pszOut
//
// This function uses SHGetIniStringUTF7 to get the string, so it is valid
// to use SZ_CANBEUNICODE on the key name.

BOOL GetFolderStringEx(LPCTSTR pszFolder, LPCTSTR pszProvider, LPCTSTR pszSection, LPCTSTR pszKey, LPTSTR pszOut, int cch)
{
    BOOL fRet = FALSE;
    TCHAR szPath[MAX_PATH];

    if (_GetIniPath(FALSE, pszFolder, pszProvider, szPath))
    {
        TCHAR szTemp[INFOTIPSIZE];
        fRet = SHGetIniStringUTF7(pszSection, pszKey, szTemp, ARRAYSIZE(szTemp), szPath);
        if (fRet)
        {
            SHExpandEnvironmentStrings(szTemp, pszOut, cch);   // This could be a path, so expand the env vars in it
        }
    }
    return fRet;
}

int GetFolderInt(LPCTSTR pszFolder, LPCTSTR pszProvider, LPCTSTR pszSection, LPCTSTR pszKey, int iDefault)
{
    BOOL fRet = FALSE;
    TCHAR szPath[MAX_PATH];

    if (_GetIniPath(FALSE, pszFolder, pszProvider, szPath))
    {
        return GetPrivateProfileInt(pszSection, pszKey, iDefault, szPath);
    }
    return iDefault;
}
    
STDAPI_(BOOL) GetFolderString(LPCTSTR pszFolder, LPCTSTR pszProvider, LPTSTR pszOut, int cch, LPCTSTR pszKey)
{
    return GetFolderStringEx(pszFolder, pszProvider, STRINI_CLASSINFO, pszKey, pszOut, cch);
}

// This function retrieves the specifice GUID from desktop.ini file.
// replace this with property bag access on the folder
STDAPI_(BOOL) GetFolderGUID(LPCTSTR pszFolder, LPCTSTR pszProvider, CLSID* pclsid, LPCTSTR pszKey)
{
    TCHAR szCLSID[40];
    if (GetFolderString(pszFolder, pszProvider, szCLSID, ARRAYSIZE(szCLSID), pszKey))
    {
        return SUCCEEDED(SHCLSIDFromString(szCLSID, pclsid));
    }
    return FALSE;
}

//
// This function retrieves the correct CLSID from desktop.ini file.
//
BOOL _GetFolderCLSID(LPCTSTR pszFolder, LPCTSTR pszProvider, CLSID* pclsid)
{
    BOOL bFound = FALSE;
    WCHAR szPath[MAX_PATH];
    if (_GetIniPath(FALSE, pszFolder, pszProvider, szPath))
    {
        DWORD dwChars;
        WCHAR szSectionValue[1024];
        dwChars = GetPrivateProfileSection(STRINI_CLASSINFO, szSectionValue, ARRAYSIZE(szSectionValue), szPath);
        if (dwChars != (sizeof(szSectionValue) - 2) && (dwChars != 0))
        {
            static WCHAR *const c_rgpsz[] = {TEXT("CLSID2"),
                                             TEXT("CLSID"),
                                             TEXT("UICLSID")};
            int iFoundIndex = ARRAYSIZE(c_rgpsz);
            // We look for CLSID2, CLSID, then UICLSID, since there could be multiple kes in this section.
            // CLSID2 makes folders work on Win95 if the CLSID does not exist on the machine
            for (WCHAR *pNextKeyPointer = szSectionValue; *pNextKeyPointer; pNextKeyPointer += lstrlen(pNextKeyPointer) + 1)
            {
                PWCHAR pBuffer = pNextKeyPointer;
                PWCHAR pEqual  = StrChrW(pBuffer, L'=');
                if (pEqual && (*(pEqual+1) != L'\0'))
                {
                    *pEqual = L'\0';
                    for (int i = 0; i < ARRAYSIZE(c_rgpsz); i++)
                    {
                        if (StrCmpIC(c_rgpsz[i], pBuffer) == 0)
                        {
                            CLSID clsid;
                            if ((iFoundIndex < i) && bFound)
                            {
                                break;
                            }
                            pBuffer += lstrlen(pBuffer) + 1;
                            if (SUCCEEDED(SHCLSIDFromString(pBuffer, &clsid)))
                            {
                                if (i == ARRAYSIZE(c_rgpsz) - 1)
                                {
                                    // hack for "Temporary Internet Files"
                                    if (clsid == CLSID_CacheFolder)
                                    {
                                        *pclsid = CLSID_CacheFolder2;
                                        bFound = TRUE;
                                    }
                                }
                                else
                                {
                                    *pclsid = clsid;
                                    bFound = TRUE;
                                }
                                iFoundIndex = i;
                            }
                            break;
                        }
                    } // end of for
                } // end of if
            } //end of for
        }
    }

    return bFound;

}

LPTSTR PathFindCLSIDExtension(LPCTSTR pszFile, CLSID *pclsid)
{
    LPCTSTR pszExt = PathFindExtension(pszFile);

    ASSERT(pszExt);

    if (*pszExt == TEXT('.') && *(pszExt + 1) == TEXT('{') /* '}' */)
    {
        CLSID clsid;

        if (pclsid == NULL)
            pclsid = &clsid;

        if (SUCCEEDED(SHCLSIDFromString(pszExt + 1, pclsid)))
            return (LPTSTR)pszExt;      // const -> non const
    }
    return NULL;
}

//
// This function retrieves the CLSID from a filename
// file.{GUID}
//
BOOL _GetFileCLSID(LPCTSTR pszFile, CLSID* pclsid)
{
    return PathFindCLSIDExtension(pszFile, pclsid) != NULL;
}

// test pidf for properties that make make it a junction, mark it as a junction
// as needed, see _IsJunction usage

BOOL _ClsidExists(REFGUID clsid)
{
    HKEY hk;
    if (SUCCEEDED(SHRegGetCLSIDKey(clsid, NULL, FALSE, FALSE, &hk)))
    {
        RegCloseKey(hk);
        return TRUE;
    }
    return FALSE;
}

LPIDFOLDER CFSFolder::_MarkAsJunction(LPCIDFOLDER pidfSimpleParent, LPIDFOLDER pidf, LPCTSTR pszName)
{
    CLSID clsid;
    BOOL fJunction = FALSE;
    // check for a junction point, junctions are either
    // Folder.{guid} or File.{guid} both fall into this case
    if (_GetFileCLSID(pszName, &clsid))
    {
        fJunction = TRUE;
    }
    else if (_IsSystemFolder(pidf))
    {
        // system (read only or system bit) look for the desktop.ini in a folder
        TCHAR szPath[MAX_PATH];
        if (SUCCEEDED(_GetPathForItems(pidfSimpleParent, pidf, szPath, ARRAYSIZE(szPath))))
        {
            // CLSID2 makes folders work on Win95 if the CLSID does not exist on the machine
            if (_GetFolderCLSID(szPath, _pszNetProvider, &clsid))
            {
                fJunction = TRUE;
            }
        }
    }

    if (fJunction && _ClsidExists(clsid))
    {
        pidf->bFlags |= SHID_JUNCTION;
        pidf = (LPIDFOLDER) ILAppendHiddenClsid((LPITEMIDLIST)pidf, IDLHID_JUNCTION, &clsid);
    }

    return pidf;
}

BOOL CFSFolder::_GetJunctionClsid(LPCIDFOLDER pidf, CLSID *pclsid)
{
    CFileSysItemString fsi(pidf);
    return fsi.GetJunctionClsid(pclsid, TRUE);
}
    
BOOL CFileSysItemString::GetJunctionClsid(CLSID *pclsid, BOOL fShellExtOk)
{
    BOOL bRet = FALSE;
    *pclsid = CLSID_NULL;

    if (CFSFolder::_IsJunction(_pidf))
    {
        // if this is a junction point that was created with a hidden CLSID
        // then it should be stored with IDLHID_JUNCTION
        if (ILGetHiddenClsid((LPCITEMIDLIST)_pidf, IDLHID_JUNCTION, pclsid))
            bRet = TRUE;
        else
        {
            // it might be an oldstyle JUNCTION point that was persisted out or a ROOT_REGITEM
            if (SIL_GetType((LPITEMIDLIST)_pidf) == SHID_ROOT_REGITEM)
            {
                const UNALIGNED CLSID *pc = (UNALIGNED CLSID *)(((BYTE *)_pidf) + _pidf->cb - sizeof(CLSID));
                *pclsid = *pc;
                bRet = TRUE;
            }
        }
    }
    else if (fShellExtOk)
    {
        if (ClassFlags(FALSE) & SHCF_IS_SHELLEXT)
        {
            IAssociationArray *paa;
            //  must pass NULL for CFSFolder to avoid recursion
            if (SUCCEEDED(AssocCreate(NULL, FALSE, IID_PPV_ARG(IAssociationArray, &paa))))
            {
                CSmartCoTaskMem<WCHAR> spsz;
                if (SUCCEEDED(paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, AQS_CLSID, NULL, &spsz)))
                {
                    bRet = GUIDFromString(spsz, pclsid);
                }
                paa->Release();
            }
        }
    }
    else if (CFSFolder::_IsFolder(_pidf))
    {
        //  directory.{guid} is always of Class() {guid}
        bRet = _GetFileCLSID(FSName(), pclsid);
    }
        
    return bRet;
}

LPCWSTR CFileSysItemString::_Class()
{
    if (_pidf->cb == 0)      // ILIsEmpty()
    {
        // the desktop. Always use the "Folder" class.
        _pszClass = c_szFolderClass;
    }
    //  else if (ILGetHiddenString(IDLHID_TREATASCLASS))
    else
    {
        CLSID clsid;
        if (GetJunctionClsid(&clsid, FALSE))
        {
            // This is a junction point, get the CLSID from it.
            CSmartCoTaskMem<OLECHAR> spsz;
            if (SUCCEEDED(ProgIDFromCLSID(clsid, &spsz)))
            {
                StrCpyN(_sz, spsz, ARRAYSIZE(_sz));
            }
            else
                SHStringFromGUID(clsid, _sz , ARRAYSIZE(_sz));
            _fsin = FSINAME_CLASS;
        }
        else if (CFSFolder::_IsFolder(_pidf))
        {
            // This is a directory. Always use the "Directory" class.
            // This can also be a Drive id.
            _pszClass = TEXT("Directory");
        }
        else
        {
            // This is a file. Get the class based on the extension.
            LPCWSTR pszFile = FSName();
            LPCWSTR pszExt = PathFindExtension(pszFile);
            ASSERT(pszExt);
            ASSERT(!(_pidf->wAttrs & FILE_ATTRIBUTE_DIRECTORY));
            if (*pszExt == 0)
            {
                if (_pidf->wAttrs & FILE_ATTRIBUTE_SYSTEM)
                    _pszClass = TEXT(".sys");
                else
                    _pszClass = TEXT(".");
            }
            else if (pszFile == _sz)
            {
                //  we need the buffer to be setup correctly
                MoveMemory(_sz, pszExt, CbFromCchW(lstrlen(pszExt) + 1));
                _fsin = FSINAME_CLASS;
            }
            else
                _pszClass = pszExt;
        }
    }
    ASSERT(_pszClass || *_sz);
    return _pszClass ? _pszClass : _sz;
}

LPCWSTR CFileSysItemString::Class()
{
    if (!_pszClass)
    {
        if (!(_fsin & FSINAME_CLASS))
        {
            return _Class();
        }
        else
        {
            return _sz;
        }
    }
    return _pszClass;
}

CFSAssocEnumData::CFSAssocEnumData(BOOL fIsUnknown, CFSFolder *pfs, LPCIDFOLDER pidf) : _fIsUnknown(fIsUnknown)
{
    _fIsSystemFolder = pfs->_IsSystemFolder(pidf);
    pfs->_GetPathForItem(pidf, _szPath, ARRAYSIZE(_szPath));
    if (_fIsUnknown)
        _fIsUnknown = !(FILE_ATTRIBUTE_OFFLINE & pidf->wAttrs);
    else
    {
        if (CFSFolder::_IsFileFolder(pidf))
            _pidl = ILCombine(pfs->_GetIDList(), (LPCITEMIDLIST)pidf);
    }
}

LPCWSTR _GetDirectoryClass(LPCWSTR pszPath, LPCITEMIDLIST pidl, BOOL fIsSystemFolder);

BOOL CFSAssocEnumData::_Next(IAssociationElement **ppae)
{
    HRESULT hr = E_FAIL;
    if (_fIsUnknown)
    {
        CLSID clsid;
        hr = GetClassFile(_szPath, &clsid);
        if (SUCCEEDED(hr))
        {
            CSmartCoTaskMem<OLECHAR> spszProgid;
            hr = ProgIDFromCLSID(clsid, &spszProgid);
            if (SUCCEEDED(hr))
            {
                hr = AssocElemCreateForClass(&CLSID_AssocProgidElement, spszProgid, ppae);
            }

            if (FAILED(hr))
            {
                WCHAR sz[GUIDSTR_MAX];
                SHStringFromGUIDW(clsid, sz, ARRAYSIZE(sz));
                hr = AssocElemCreateForClass(&CLSID_AssocClsidElement, sz, ppae);
            }
        }
       
        if (FAILED(hr))
        {
            hr = AssocElemCreateForClass(&CLSID_AssocShellElement, L"Unknown", ppae);
        }

        _fIsUnknown = FALSE;
    }

    if (FAILED(hr) && _pidl)
    {
        PCWSTR psz = _GetDirectoryClass(_szPath, _pidl, _fIsSystemFolder);
        if (psz)
            hr = AssocElemCreateForClass(&CLSID_AssocSystemElement, psz, ppae);
        ILFree(_pidl);
        _pidl = NULL;
    }
    
    return SUCCEEDED(hr);
}


class CFSAssocEnumExtra : public CEnumAssociationElements
{
public:

protected:
    BOOL _Next(IAssociationElement **ppae);

protected:
};

BOOL CFSAssocEnumExtra::_Next(IAssociationElement **ppae)
{
    if (_cNext == 0)
    {
        // corel wp suite 7 relies on the fact that send to menu is hard coded
        // not an extension so do not insert it (and the similar items)
        if (!(SHGetAppCompatFlags(ACF_CONTEXTMENU) & ACF_CONTEXTMENU))
        {
            AssocElemCreateForClass(&CLSID_AssocShellElement, L"AllFilesystemObjects", ppae);
        }
    }

    return *ppae != NULL;
}

HRESULT CFileSysItemString::AssocCreate(CFSFolder *pfs, BOOL fForCtxMenu, REFIID riid, void **ppv)
{
    //  WARNING - the pfs keeps us from recursing.
    *ppv = NULL;
    IAssociationArrayInitialize *paai;
    HRESULT hr = ::AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IAssociationArrayInitialize, &paai));
    if (SUCCEEDED(hr))
    {
        //  the base class for directory's is always Folder
        ASSOCELEM_MASK base;
        if (CFSFolder::_IsFolder(_pidf))
            base = ASSOCELEM_BASEIS_FOLDER;
        else
        {
            //  for files it is always *
            base = ASSOCELEM_BASEIS_STAR;
            if (pfs)
            {
                CLSID clsid;
                if (GetJunctionClsid(&clsid, TRUE))
                {
                    //  but if this file is also a folder (like .zip and .cab)
                    //  then we should also use Folder
                    if (SHGetAttributesFromCLSID2(&clsid, 0, SFGAO_FOLDER) & SFGAO_FOLDER)
                        base |= ASSOCELEM_BASEIS_FOLDER;
                }
            }
        }
        
        hr = paai->InitClassElements(base, Class());
        if (SUCCEEDED(hr) && pfs)
        {
            BOOL fIsLink = fForCtxMenu && (_ClassFlags(paai, FALSE) & SHCF_IS_LINK);
            if (fIsLink)
            {
                //  we dont like to do everything for LINK, but 
                //  maybe we should be adding BASEIS_STAR?
                paai->FilterElements(ASSOCELEM_DEFAULT | ASSOCELEM_EXTRA);
            }

            IEnumAssociationElements *penum = new CFSAssocEnumExtra();
            if (penum)
            {
                paai->InsertElements(ASSOCELEM_EXTRA, penum);
                penum->Release();
            }

            if (!fIsLink)
            {
                penum = new CFSAssocEnumData(hr == S_FALSE, pfs, _pidf);
                if (penum)
                {
                    paai->InsertElements(ASSOCELEM_DATA | ASSOCELEMF_INCLUDE_SLOW, penum);
                    penum->Release();
                }
            }
        }

        if (SUCCEEDED(hr))
            hr = paai->QueryInterface(riid, ppv);
        paai->Release();
    }

    return hr;
}

HRESULT CFSFolder::_AssocCreate(LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    CFileSysItemString fsi(pidf);
    return fsi.AssocCreate(this, FALSE, riid, ppv);
}

//
//  Description: This simulates the ComponentCategoryManager
//  call which checks to see if a CLSID is a member of a CATID.
//
STDAPI_(BOOL) IsMemberOfCategory(IAssociationArray *paa, REFCATID rcatid)
{
    BOOL fRet = FALSE;
    CSmartCoTaskMem<WCHAR> spsz;
    if (SUCCEEDED(paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, AQS_CLSID, NULL, &spsz)))
    {
        TCHAR szKey[GUIDSTR_MAX * 4], szCATID[GUIDSTR_MAX];
        // Construct the registry key that detects if
        // a CLSID is a member of a CATID.
        SHStringFromGUID(rcatid, szCATID, ARRAYSIZE(szCATID));
        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("CLSID\\%s\\Implemented Categories\\%s"), spsz, szCATID);

        // See if it's there.
        fRet = SHRegSubKeyExists(HKEY_CLASSES_ROOT, szKey);
    }

    return fRet;
}


// get flags for a file class.
//
// given a FS PIDL returns a DWORD of flags, or 0 for error
//
//      SHCF_ICON_INDEX         this is this sys image index for per class
//      SHCF_ICON_PERINSTANCE   icons are per instance (one per file)
//      SHCF_ICON_DOCICON       icon is in shell\open\command (simulate doc icon)
//
//      SHCF_HAS_ICONHANDLER    set if class has a IExtractIcon handler
//
//      SHCF_UNKNOWN            set if extenstion is not registered
//
//      SHCF_IS_LINK            set if class is a link
//      SHCF_ALWAYS_SHOW_EXT    always show the extension
//      SHCF_NEVER_SHOW_EXT     never show the extension
//

DWORD CFSFolder::_GetClassFlags(LPCIDFOLDER pidf)
{
    CFileSysItemString fsi(pidf);
    return fsi.ClassFlags(FALSE);
}

void CFileSysItemString::_QueryIconIndex(IAssociationArray *paa)
{
    // check for the default icon under HKCU for this file extension.
    //  null out the icon index
    _dwClass &= ~SHCF_ICON_INDEX;
    PWSTR pszIcon;
    HRESULT hr = E_FAIL;
    if (paa)
    {
        // check for icon in ProgID
        // Then, check if the default icon is specified in OLE-style.
        hr = paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, AQS_DEFAULTICON, NULL, &pszIcon);
        if (SUCCEEDED(hr))
        {
            //  hijack these icons
            //  office XP has really ugly icons for images
            //  and ours are so beautiful...office wont mind
            static const struct 
            { 
                PCWSTR pszUgly; 
                PCWSTR pszPretty; 
            } s_hijack[] = 
            {
                { L"PEicons.exe,1",     L"shimgvw.dll,2" }, // PNG
                { L"PEicons.exe,4",     L"shimgvw.dll,2" }, // GIF
                { L"PEicons.exe,5",     L"shimgvw.dll,3" }, // JPEG
                { L"MSPVIEW.EXE,1",     L"shimgvw.dll,4" }, // TIF
                { L"wordicon.exe,8",    L"moricons.dll,-109"},  
                { L"xlicons.exe,13",    L"moricons.dll,-110"},  
                { L"accicons.exe,57",   L"moricons.dll,-111"},  
                { L"pptico.exe,6",      L"moricons.dll,-112"},  
                { L"fpicon.exe,2",      L"moricons.dll,-113"},  
            };
            PCWSTR pszName = PathFindFileName(pszIcon);
            for (int i = 0; i < ARRAYSIZE(s_hijack); i++)
            {
                if (0 == StrCmpIW(pszName, s_hijack[i].pszUgly))
                {
                    //  replace this ugly chicken
                    CoTaskMemFree(pszIcon);
                    hr = SHStrDupW(s_hijack[i].pszPretty, &pszIcon);
                    break;
                }
            }
        }
        else if (!CFSFolder::_IsFolder(_pidf))
        {
            hr = paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, AQVS_APPLICATION_PATH, NULL, &pszIcon);
            if (SUCCEEDED(hr))
                _dwClass |= SHCF_ICON_DOCICON;
        }
    }

    // Check if this is a per-instance icon

    if (SUCCEEDED(hr) && (lstrcmp(pszIcon, TEXT("%1")) == 0 ||
        lstrcmp(pszIcon, TEXT("\"%1\"")) == 0))
    {
        _dwClass &= ~SHCF_ICON_DOCICON;
        _dwClass |= SHCF_ICON_PERINSTANCE;
    }
    else 
    {
        int iIcon, iImage;
        if (SUCCEEDED(hr))
        {
            iIcon = PathParseIconLocation(pszIcon);
            iImage = Shell_GetCachedImageIndex(pszIcon, iIcon, _dwClass & SHCF_ICON_DOCICON ? GIL_SIMULATEDOC : 0);

            if (iImage == -1)
            {
                iIcon = _dwClass & SHCF_ICON_DOCICON ? II_DOCUMENT : II_DOCNOASSOC;
                iImage = Shell_GetCachedImageIndex(c_szShell32Dll, iIcon, 0);
            }
        }
        else
        {
            iIcon = CFSFolder::_IsFolder(_pidf) ? II_FOLDER : II_DOCNOASSOC;
            iImage = Shell_GetCachedImageIndex(c_szShell32Dll, iIcon, 0);
            _dwClass |= SHCF_ICON_DOCICON;   // make _dwClass non-zero
        }

        // Shell_GetCachedImageIndex can return -1 for failure cases. We
        // dont want to or -1 in, so check to make sure the index is valid.
        if ((iImage & ~SHCF_ICON_INDEX) == 0)
        {
            // no higher bits set so its ok to or the index in
            _dwClass |= iImage;
        }
    }

    if (SUCCEEDED(hr))
        CoTaskMemFree(pszIcon);
}    

#define ASSOCELEM_GETBITS   (ASSOCELEM_USER | ASSOCELEM_DEFAULT | ASSOCELEM_SYSTEM)
BOOL _IsKnown(IAssociationArray *paa)
{
    BOOL fRet = FALSE;
    CComPtr<IEnumAssociationElements> spenum;
    if (paa && SUCCEEDED(paa->EnumElements(ASSOCELEM_GETBITS, &spenum)))
    {
        CComPtr<IAssociationElement> spae;
        ULONG c;
        fRet = S_OK == spenum->Next(1, &spae, &c);
    }
    return fRet;
}

void CFileSysItemString::_QueryClassFlags(IAssociationArray *paa)
{
    // always hide extension for .{guid} junction points:
    // unless ShowSuperHidden() is on.  since this means the user wants to see system stuff
    if (!ShowSuperHidden() && _GetFileCLSID(FSName(), NULL))
        _dwClass = SHCF_NEVER_SHOW_EXT;
    else if (CFSFolder::_IsFolder(_pidf))
        _dwClass = SHCF_ALWAYS_SHOW_EXT;
    else
        _dwClass = 0;

    if (_IsKnown(paa))
    {
        // see what handlers exist
        if (SUCCEEDED(paa->QueryExists(ASSOCELEM_GETBITS, AQNS_SHELLEX_HANDLER, TEXT("IconHandler"))))
            _dwClass |= SHCF_HAS_ICONHANDLER;

        // check for browsability
        if (!(SHGetAppCompatFlags(ACF_DOCOBJECT) & ACF_DOCOBJECT))
        {
            if (SUCCEEDED(paa->QueryExists(ASSOCELEM_GETBITS, AQN_NAMED_VALUE, TEXT("DocObject")))
            || SUCCEEDED(paa->QueryExists(ASSOCELEM_GETBITS, AQN_NAMED_VALUE, TEXT("BrowseInPlace"))))
                _dwClass |= SHCF_IS_DOCOBJECT;
        }   
        
        if (IsMemberOfCategory(paa, CATID_BrowsableShellExt))
            _dwClass |= SHCF_IS_SHELLEXT;

        //  get attributes
        if (SUCCEEDED(paa->QueryExists(ASSOCELEM_GETBITS, AQN_NAMED_VALUE, TEXT("IsShortcut"))))
            _dwClass |= SHCF_IS_LINK;

        if (SUCCEEDED(paa->QueryExists(ASSOCELEM_GETBITS, AQN_NAMED_VALUE, TEXT("AlwaysShowExt"))))
            _dwClass |= SHCF_ALWAYS_SHOW_EXT;

        if (SUCCEEDED(paa->QueryExists(ASSOCELEM_GETBITS, AQN_NAMED_VALUE, TEXT("NeverShowExt"))))
            _dwClass |= SHCF_NEVER_SHOW_EXT;

        // figure out what type of icon this type of file uses.
        if (_dwClass & SHCF_HAS_ICONHANDLER)
        {
            _dwClass |= SHCF_ICON_PERINSTANCE;
        }
    }
    else
    {
        // unknown type - pick defaults and get out.
        _dwClass |= SHCF_UNKNOWN | SHCF_ALWAYS_SHOW_EXT;
    }
}

CFSFolder * GetFSFolderFromShellFolder(IShellFolder *psf)
{
    CFSFolder *pfs = NULL;
    if (psf)
        psf->QueryInterface(IID_INeedRealCFSFolder, (void **)&pfs);
    return pfs;
}

PERCEIVED GetPerceivedType(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    PERCEIVED gen = GEN_UNKNOWN;
    CFSFolder *pfsf = GetFSFolderFromShellFolder(psf);
    if (pfsf)
    {
        LPCIDFOLDER pidf = CFSFolder_IsValidID(pidl);
        if (pidf)
        {
            CFileSysItemString fsi(pidf);
            gen = fsi.PerceivedType();
        }
    }
    return gen;
}

const struct {
    PERCEIVED gen;
    LPCWSTR psz;
} c_rgPerceivedTypes[] = {
    {GEN_TEXT, L"text"},
    {GEN_IMAGE, L"image"},
    {GEN_AUDIO,  L"audio"},
    {GEN_VIDEO,  L"video"},
    {GEN_COMPRESSED, L"compressed"},
};

PERCEIVED CFileSysItemString::PerceivedType()
{
    // look up the file type in the cache.
    PERCEIVED gen = LookupFilePerceivedType(Class());
    if (gen == GEN_UNKNOWN)
    {
        WCHAR sz[40];
        DWORD cb = sizeof(sz);
        if (NOERROR == SHGetValueW(HKEY_CLASSES_ROOT, Class(), L"PerceivedType", NULL, sz, &cb))
        {
            gen = GEN_CUSTOM;
            for (int i = 0; i < ARRAYSIZE(c_rgPerceivedTypes); i++)
            {
                if (0 == StrCmpC(c_rgPerceivedTypes[i].psz, sz))
                {
                    gen = c_rgPerceivedTypes[i].gen;
                    break;
                }
            }
        }
        else if (CFSFolder::_IsFolder(_pidf))
        {
            gen = GEN_FOLDER;
        }
        else
        {
            gen = GEN_UNSPECIFIED;
        }

        AddFilePerceivedType(Class(), gen);
    }
    return gen;
}

BOOL _IsImageExt(PCWSTR psz);
 
BOOL CFileSysItemString::IsShimgvwImage()
{
    return _IsImageExt(Class());
}

DWORD CFileSysItemString::_ClassFlags(IUnknown *punkAssoc, BOOL fNeedsIconBits)
{
    // look up the file type in the cache.
    if (!_dwClass)
        _dwClass = LookupFileClass(Class());
    if (_dwClass)
    {
        if (!fNeedsIconBits || (_dwClass & SHCF_ICON_INDEX) != SHCF_ICON_INDEX)
            return _dwClass;    
    }

    IAssociationArray *paa;
    HRESULT hr;
    if (punkAssoc)
        hr = punkAssoc->QueryInterface(IID_PPV_ARG(IAssociationArray, &paa));
    else
        hr = AssocCreate(NULL, FALSE, IID_PPV_ARG(IAssociationArray, &paa));

    if (!_dwClass)
        _QueryClassFlags(paa);

    if (fNeedsIconBits && !(_dwClass & SHCF_ICON_PERINSTANCE))
        _QueryIconIndex(paa);
    else
    {
        //  set it to be not init'd
        _dwClass |= SHCF_ICON_INDEX;
    }

    if (SUCCEEDED(hr))
    {
        paa->Release();

        if (0 == _dwClass)
        {
            // If we hit this, the extension for this file type is incorrectly installed
            // and it will cause double clicking on such files to open the "Open With..."
            // file associatins dialog.
            //
            // IF YOU HIT THIS:
            // 1. Find the file type by checking szClass.
            // 2. Contact the person that installed that file type and have them fix
            //    the install to have an icon and an associated program.
            TraceMsg(TF_WARNING, "_GetClassFlags() has detected an improperly registered class: '%s'", Class());
        }
        
    }

    AddFileClass(Class(), _dwClass);

    return _dwClass;
}

//
// this function checks for flags in desktop.ini
//

#define GFF_DEFAULT_TO_FS          0x0001      // the shell-xtension permits FS as the default where it cannot load
#define GFF_ICON_FOR_ALL_FOLDERS   0x0002      // use the icon specified in the desktop.ini for all sub folders

BOOL CFSFolder::_GetFolderFlags(LPCIDFOLDER pidf, UINT *prgfFlags)
{
    TCHAR szPath[MAX_PATH];

    *prgfFlags = 0;

    if (FAILED(_GetPathForItem(pidf, szPath, ARRAYSIZE(szPath))))
        return FALSE;

    if (PathAppend(szPath, c_szDesktopIni))
    {
        if (GetPrivateProfileInt(STRINI_CLASSINFO, TEXT("DefaultToFS"), 1, szPath))
        {
            *prgfFlags |= GFF_DEFAULT_TO_FS;
        }
    }
    return TRUE;
}

//
// This funtion retrieves the ICONPATh from desktop.ini file.
// It takes a pidl as an input.
// NOTE: There is code in SHDOCVW--ReadIconLocation that does almost the same thing
// only that code looks in .URL files instead of desktop.ini
BOOL CFSFolder::_GetFolderIconPath(LPCIDFOLDER pidf, LPTSTR pszIcon, int cchMax, UINT *pIndex)
{
    TCHAR szPath[MAX_PATH], szIcon[MAX_PATH];
    BOOL fSuccess = FALSE;
    UINT iIndex;

    if (pszIcon == NULL)
    {
        pszIcon = szIcon;
        cchMax = ARRAYSIZE(szPath);
    }

    if (pIndex == NULL)
        pIndex = &iIndex;

    *pIndex = _GetDefaultFolderIcon();    // Default the index to II_FOLDER (default folder icon)

    if (SUCCEEDED(_GetPathForItem(pidf, szPath, ARRAYSIZE(szPath))))
    {
        if (GetFolderString(szPath, _pszNetProvider, pszIcon, cchMax, SZ_CANBEUNICODE TEXT("IconFile")))
        {
            // Fix the relative path
            PathCombine(pszIcon, szPath, pszIcon);
            fSuccess = PathFileExistsAndAttributes(pszIcon, NULL);
            if (fSuccess)
            {
                TCHAR szIndex[16];
                if (GetFolderString(szPath, _pszNetProvider, szIndex, ARRAYSIZE(szIndex), TEXT("IconIndex")))
                {
                    StrToIntEx(szIndex, 0, (int *)pIndex);
                }
            }
        }
    }

    return fSuccess;
}

// IDList factory
CFileSysItem::CFileSysItem(LPCIDFOLDER pidf)
    : _pidf(pidf), _pidp((PCIDPERSONALIZED)-1)
{
    _pidfx = (PCIDFOLDEREX) ILFindHiddenIDOn((LPCITEMIDLIST)pidf, IDLHID_IDFOLDEREX, FALSE);

    if (_pidfx && _pidfx->hid.wVersion < IDFX_V1)
        _pidfx = NULL;
}

BOOL CFileSysItem::_IsPersonalized()
{
    if (_pidp == (PCIDPERSONALIZED) -1)
    {
        _pidp = (PCIDPERSONALIZED) ILFindHiddenIDOn((LPCITEMIDLIST)_pidf, IDLHID_PERSONALIZED, FALSE);
        if (_pidp && 0 >= (signed short) _pidp->hid.wVersion)
            _pidp = NULL;
    }
    return _pidp != NULL;
}
        
CFileSysItemString::CFileSysItemString(LPCIDFOLDER pidf)
    : CFileSysItem(pidf), _pszFSName(NULL), _pszUIName(NULL), _pszClass(NULL), _dwClass(0), _fsin(FSINAME_NONE)
{
    *_sz = 0;
}

LPCWSTR CFileSysItemString::FSName()
{
    if (!_pszFSName)
    {
        if (!(_fsin & FSINAME_FS))
        {
            LPCWSTR psz = MayCopyFSName(FALSE, _sz, ARRAYSIZE(_sz));
            if (psz == _sz)
                _fsin = FSINAME_FS;
            else
                _pszFSName = psz;
        }
    }
    return _pszFSName ? _pszFSName : _sz;
}

LPCWSTR CFileSysItem::MayCopyFSName(BOOL fMustCopy, LPWSTR psz, DWORD cch)
{
    if (_pidfx)
    {
        LPNWSTR pnsz = UASTROFFW(_pidfx, _pidfx->offNameW);
        //  return back a pointer inside the pidfx
        //  if we can...
        if (fMustCopy || ((INT_PTR)pnsz & 1))
        {
            ualstrcpynW(psz, pnsz, cch);
        }
        else
            psz = (LPWSTR) pnsz;
    }
    else
    {
        if ((CFSFolder::_GetType(_pidf) & SHID_FS_UNICODE) == SHID_FS_UNICODE)
        {
            ualstrcpynW(psz, (LPCWSTR)_pidf->cFileName, cch);
        }
        else
        {
            MultiByteToWideChar(CP_ACP, 0, _pidf->cFileName, -1, psz, cch);
        }

    }
    return psz;
}

LPCSTR CFileSysItemString::AltName()
{
    UINT cbName;
    if (_pidfx)
    {
        //  we put the altname in cFileName
        cbName = 0;
    }
    else if ((CFSFolder::_GetType(_pidf) & SHID_FS_UNICODE) == SHID_FS_UNICODE)
    {
        cbName = (ualstrlenW((LPCWSTR)_pidf->cFileName) + 1) * sizeof(WCHAR);
    }
    else
    {
        cbName = lstrlenA(_pidf->cFileName) + 1;
    }

    return _pidf->cFileName + cbName;
}

LPCWSTR CFileSysItemString::UIName(CFSFolder *pfs)
{
    if (!_pszUIName)
    {
        if (!(_fsin & FSINAME_UI))
        {
            if (!_pidfx || !_LoadResource(pfs))
            {
                if (!ShowExtension(pfs->_DefaultShowExt()))
                {
                    //  we need to have a buffer
                    if (!(_fsin & FSINAME_FS))
                        MayCopyFSName(TRUE, _sz, ARRAYSIZE(_sz));

                    PathRemoveExtension(_sz);
                    //  lose the FSINAME_FS bit
                    _fsin = FSINAME_UI;
                }
                else
                {
                    //  the FSName and the UIName are the same
                    if (_sz == FSName())
                    {
                        //  the FSName and the UIName are the same
                        //  pidl is unaligned so the buffer gets double work
                        _fsin = FSINAME_FSUI;
                    }
                    else
                    {
                        //  and we are aligned so we can use the same name
                        //  directories are often this way.
                        _pszUIName = _pszFSName;
                    }
                }
            }
        }
    }
    return _pszUIName ? _pszUIName : _sz;
}

BOOL CFileSysItemString::_ResourceName(LPWSTR psz, DWORD cch, BOOL fIsMine)
{
    BOOL fRet = FALSE;
    if (_IsPersonalized())
    {
        int ids = _GetPersonalizedRes((int)_pidp->hid.wVersion, fIsMine);
        if (ids != -1)
        {
            wnsprintf(psz, cch, L"@shell32.dll,-%d", ids);
            fRet = TRUE;
        }
    }
    else if (_pidfx && _pidfx->offResourceA)
    {
        SHAnsiToUnicode(UASTROFFA(_pidfx, _pidfx->offResourceA), psz, cch);
        fRet = TRUE;
    }
    return fRet;        
}

LPCWSTR CFileSysItemString::ResourceName()
{
    if (!(_fsin & FSINAME_RESOURCE))
    {
        if (!_ResourceName(_sz, ARRAYSIZE(_sz), FALSE))
            *_sz = 0;
    }
    _fsin = FSINAME_RESOURCE;
    return _sz;
}
HRESULT CFileSysItemString::GetFindDataSimple(WIN32_FIND_DATAW *pfd)
{
    ZeroMemory(pfd, sizeof(*pfd));

    // Note that COFSFolder doesn't provide any times _but_ COFSFolder
    DosDateTimeToFileTime(_pidf->dateModified, _pidf->timeModified, &pfd->ftLastWriteTime);
    pfd->dwFileAttributes = _pidf->wAttrs;
    pfd->nFileSizeLow = _pidf->dwSize;

    StrCpyN(pfd->cFileName, FSName(), ARRAYSIZE(pfd->cFileName));
    SHAnsiToUnicode(AltName(), pfd->cAlternateFileName, ARRAYSIZE(pfd->cAlternateFileName));

    if (_pidfx)
    {
        DosDateTimeToFileTime(_pidfx->dsCreate.wDate, _pidfx->dsCreate.wTime, &pfd->ftCreationTime);
        DosDateTimeToFileTime(_pidfx->dsAccess.wDate, _pidfx->dsAccess.wTime, &pfd->ftLastAccessTime);
    }

    return S_OK;
}

HRESULT CFileSysItemString::GetFindData(WIN32_FIND_DATAW *pfd)
{
    HRESULT hr;
    // if its a simple ID, there's no data in it
    if (CFSFolder::_IsReal(_pidf))
    {
        hr = GetFindDataSimple(pfd);
    }
    else
    {
        ZeroMemory(pfd, sizeof(*pfd));
        hr = E_INVALIDARG;
    }
    return hr;
}

typedef struct
{
    int csidl;
    int idsMine;
    int idsTheirs;
} PERSONALIZEDNAME;

int CFileSysItemString::_GetPersonalizedRes(int csidl, BOOL fIsMine)
{
static const PERSONALIZEDNAME s_pnames[] = 
    {
        { CSIDL_PERSONAL, -1, IDS_LOCALGDN_FLD_THEIRDOCUMENTS},
        { CSIDL_MYPICTURES, IDS_LOCALGDN_FLD_MYPICTURES, IDS_LOCALGDN_FLD_THEIRPICTURES},
        { CSIDL_MYMUSIC, IDS_LOCALGDN_FLD_MYMUSIC, IDS_LOCALGDN_FLD_THEIRMUSIC},
        { CSIDL_MYVIDEO, IDS_LOCALGDN_FLD_MYVIDEOS, IDS_LOCALGDN_FLD_THEIRVIDEOS},
    };

    for (int i = 0; i < ARRAYSIZE(s_pnames); i++)
    {
        if (s_pnames[i].csidl == csidl)
        {
            return fIsMine ? s_pnames[i].idsMine : s_pnames[i].idsTheirs;
        }
    }
    AssertMsg(FALSE, TEXT("Personalized Resource not in table"));
    return -1;
}

TRIBIT CFileSysItem::_IsMine(CFSFolder *pfs)
{
    TRIBIT tb = TRIBIT_UNDEFINED;
    if (_IsPersonalized())
    {
        WCHAR szPath[MAX_PATH];
        if (SUCCEEDED(SHGetFolderPath(NULL, (int)_pidp->hid.wVersion | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath)))
        {
            WCHAR szThis[MAX_PATH];
            if (SUCCEEDED(pfs->_GetPathForItem(_pidf, szThis, ARRAYSIZE(szThis))))
            {
                //  if they match then its ours
                //  if they dont then it still personalized (theirs)
                if (0 == StrCmpI(szThis, szPath))
                    tb = TRIBIT_TRUE;
                else
                {
                    tb = TRIBIT_FALSE;
                }
            }
        }
    }
    return tb;
}

void CFileSysItemString::_FormatTheirs(LPCWSTR pszFormat)
{
    WCHAR szOwner[UNLEN];
    ualstrcpynW(szOwner, _pidp->szUserName, ARRAYSIZE(szOwner));
    if (!IsOS(OS_DOMAINMEMBER))
    {
        //  maybe we should do caching here???
        //  pfs->GetUserName(szOwner, szOwner, ARRAYSIZE(szOwner));
        USER_INFO_10 *pui;
        if (NERR_Success == NetUserGetInfo(NULL, szOwner, 10, (LPBYTE*)&pui))
        {
            LPTSTR pszName = (*pui->usri10_full_name) ? pui->usri10_full_name: pui->usri10_name;
            if (*pszName)
            {
                StrCpyN(szOwner, pszName, ARRAYSIZE(szOwner));
            }
            NetApiBufferFree(pui);
        }
    }
    wnsprintf(_sz, ARRAYSIZE(_sz), pszFormat, szOwner);
}

BOOL CFileSysItemString::_LoadResource(CFSFolder *pfs)
{
    WCHAR szResource[MAX_PATH];
    BOOL fRet = FALSE;
    TRIBIT tbIsMine = _IsMine(pfs);
    if (_ResourceName(szResource, ARRAYSIZE(szResource), tbIsMine == TRIBIT_TRUE))
    {
        DWORD cb = sizeof(_sz);
        //  first check the registry for overrides
        if (S_OK == SKGetValueW(SHELLKEY_HKCU_SHELL, L"LocalizedResourceName", szResource, NULL, _sz, &cb)
              && *_sz)
        {
            fRet = TRUE;
        }
        else if (szResource[0] == TEXT('@'))
        {
            //  it does caching for us
            fRet = SUCCEEDED(SHLoadIndirectString(szResource, _sz, ARRAYSIZE(_sz), NULL));
            //  If the call fails, this means that the
            //  localized string belongs to a DLL that has been uninstalled.
            //  Just return the failure code so we act as if the MUI string
            //  isn't there.  (Don't show the user "@DLLNAME.DLL,-5" as the
            //  name!)
            if (fRet && tbIsMine == TRIBIT_FALSE)
            {
                //  reuse szResource as the format string
                StrCpyN(szResource, _sz, ARRAYSIZE(szResource));
                _FormatTheirs(szResource);
            }
        }
    }
    
    if (fRet)
        _fsin = FSINAME_UI;

    ASSERT(!_fsin || *_sz);

    return fRet;
}

BOOL CFileSysItem::CantRename(CFSFolder *pfs)
{
    //  BOOL fRest = SHRestricted(REST_NORENAMELOCALIZED);
    if (_IsPersonalized())
    {
        if (!_IsMine(pfs))
            return TRUE;

        // return fRest;
    }
    else if (_pidfx && _pidfx->offResourceA)
    {
        //  return fRest;
    }
    return FALSE;
}

UINT _CopyResource(LPWSTR pszSrc, LPSTR pszRes, UINT cchRes)
{
    ASSERT(*pszSrc == L'@');
    LPWSTR pszS32 = StrStrIW(pszSrc, L"shell32.dll");
    if (pszS32)
    {
        *(--pszS32) = L'@';
        pszSrc = pszS32;
    }
        
    return SHUnicodeToAnsi(pszSrc, pszRes, cchRes);
}

UINT CFSFolder::_GetItemExStrings(LPCIDFOLDER pidfSimpleParent, const WIN32_FIND_DATA *pfd, EXSTRINGS *pxs)
{
    UINT cbRet = 0;
    TCHAR szTemp[MAX_PATH];
    if ((pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    && (pfd->dwFileAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY)))
    {
        if (SUCCEEDED(_GetPathForItem(pidfSimpleParent, szTemp, ARRAYSIZE(szTemp))))
        {
            PathAppend(szTemp, pfd->cFileName);
            if (GetFolderStringEx(szTemp, _pszNetProvider, L"DeleteOnCopy", SZ_CANBEUNICODE TEXT("Owner"), pxs->idp.szUserName, ARRAYSIZE(pxs->idp.szUserName)))
            {
                pxs->idp.hid.cb = sizeof(pxs->idp.hid) + CbFromCchW(lstrlenW(pxs->idp.szUserName) + 1);
                pxs->idp.hid.id = IDLHID_PERSONALIZED;
                WCHAR szFile[MAX_PATH];
                if (GetFolderStringEx(szTemp, _pszNetProvider, L"DeleteOnCopy", SZ_CANBEUNICODE TEXT("PersonalizedName"), szFile, ARRAYSIZE(szFile)))
                {
                    if (0 == StrCmpI(pfd->cFileName, szFile))
                        pxs->idp.hid.wVersion = (WORD) GetFolderInt(szTemp, _pszNetProvider, L"DeleteOnCopy", TEXT("Personalized"), -1);
                }
            }
            else if (GetFolderString(szTemp, _pszNetProvider, szTemp, ARRAYSIZE(szTemp), TEXT("LocalizedResourceName")))
            {
                pxs->cbResource = _CopyResource(szTemp, pxs->szResource, ARRAYSIZE(pxs->szResource));
                cbRet += pxs->cbResource;
            }
            
        }
    }
    else if (!pidfSimpleParent && _IsSelfSystemFolder())
    {
        if (_HasLocalizedFileNames() && SUCCEEDED(_GetPath(szTemp, ARRAYSIZE(szTemp))))
        {
            if (GetFolderStringEx(szTemp, _pszNetProvider, TEXT("LocalizedFileNames"), pfd->cFileName, szTemp, ARRAYSIZE(szTemp)))
            {
                pxs->cbResource = _CopyResource(szTemp, pxs->szResource, ARRAYSIZE(pxs->szResource));
                cbRet += pxs->cbResource;
            }
        }
    }    

    return cbRet;
}

BOOL _PrepIDFName(const WIN32_FIND_DATA *pfd, LPSTR psz, DWORD cch, const void **ppvName, UINT *pcbName)
{
    //  the normal case:
    //  the altname should only not be filled in
    //  in the case of the name being a shortname (ASCII)
    LPCWSTR pwsz = *pfd->cAlternateFileName && !(SHGetAppCompatFlags(ACF_FORCELFNIDLIST) & ACF_FORCELFNIDLIST)
        ? pfd->cAlternateFileName : pfd->cFileName;
    
    if (DoesStringRoundTrip(pwsz, psz, cch))
    {
        *pcbName = lstrlenA(psz) + 1;
        *ppvName = psz;
    }
    else
    {
        *pcbName = CbFromCchW(lstrlenW(pwsz) + 1);
        *ppvName = pfd->cFileName;
    }

    return *ppvName != psz;
}

HRESULT CFSFolder::_CreateIDList(const WIN32_FIND_DATA *pfd, LPCIDFOLDER pidfSimpleParent, LPITEMIDLIST *ppidl)
{
    //  for the idf
    CHAR szNameIDF[MAX_PATH];
    UINT cbNameIDF;
    const void *pvNameIDF;
    BOOL fNeedsUnicode = _PrepIDFName(pfd, szNameIDF, ARRAYSIZE(szNameIDF), &pvNameIDF, &cbNameIDF);
    UINT cbIDF = FIELD_OFFSET(IDFOLDER, cFileName) + cbNameIDF;
    ASSERT(*((char *)pvNameIDF));

    //  for the idfx
    UINT cbNameIDFX = CbFromCchW(lstrlenW(pfd->cFileName) + 1);
    EXSTRINGS xs = {0};
    UINT cbIDFX = sizeof(IDFOLDEREX) + cbNameIDFX + _GetItemExStrings(pidfSimpleParent, pfd, &xs);

    //  try to align these babies
    cbIDF = ROUNDUP(cbIDF, 2);
    cbIDFX = ROUNDUP(cbIDFX, 2);
    //  ILCreateWithHidden() fills in the cb values
    LPIDFOLDER pidf = (LPIDFOLDER)ILCreateWithHidden(cbIDF, cbIDFX);
    if (pidf)
    {
        //  initialize the idf
        // tag files > 4G so we can do a full find first when we need to know the real size
        pidf->dwSize = pfd->nFileSizeHigh ? 0xFFFFFFFF : pfd->nFileSizeLow;
        pidf->wAttrs = (WORD)pfd->dwFileAttributes;

        // Since the idf entry is not aligned, we cannot just send the address
        // of one of its members blindly into FileTimeToDosDateTime.
        WORD date, time;
        if (FileTimeToDosDateTime(&pfd->ftLastWriteTime, &date, &time))
        {
            *((UNALIGNED WORD *)&pidf->dateModified) = date;
            *((UNALIGNED WORD *)&pidf->timeModified) = time;
        }

        //  copy the short name
        memcpy(pidf->cFileName, pvNameIDF, cbNameIDF);

        //  setup bFlags
        pidf->bFlags = pfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ? SHID_FS_DIRECTORY : SHID_FS_FILE;
        if (CSIDL_COMMON_DESKTOPDIRECTORY == _csidlTrack)
            pidf->bFlags |= SHID_FS_COMMONITEM;

        if (fNeedsUnicode)
            pidf->bFlags |= SHID_FS_UNICODE;
            
        //  now initialize the hidden idfx
        PIDFOLDEREX pidfx = (PIDFOLDEREX) _ILSkip((LPITEMIDLIST)pidf, cbIDF);
        pidfx->hid.id = IDLHID_IDFOLDEREX;
        pidfx->hid.wVersion = IDFX_CV;

        if (FileTimeToDosDateTime(&pfd->ftCreationTime, &date, &time))
        {
            pidfx->dsCreate.wDate = date;
            pidfx->dsCreate.wTime = time;
        }
        if (FileTimeToDosDateTime(&pfd->ftLastAccessTime, &date, &time))
        {
            pidfx->dsAccess.wDate = date;
            pidfx->dsAccess.wTime = time;
        }

        //  append the strings
        pidfx->offNameW = (USHORT) sizeof(IDFOLDEREX);
        ualstrcpyW(UASTROFFW(pidfx, pidfx->offNameW), pfd->cFileName);
        USHORT offNext = (USHORT) sizeof(IDFOLDEREX) + cbNameIDFX;
        if (xs.cbResource)
        {
            pidfx->offResourceA = offNext;
            ualstrcpyA(UASTROFFA(pidfx, pidfx->offResourceA), xs.szResource);
            //  offNext += (USHORT) xs.cbResource; if we have more offsets...
        }
        
        pidf = _MarkAsJunction(pidfSimpleParent, pidf, pfd->cFileName);

        if (pidf && xs.idp.hid.cb)
            pidf = (LPIDFOLDER) ILAppendHiddenID((LPITEMIDLIST)pidf, &xs.idp.hid);
    }

    *ppidl = (LPITEMIDLIST)pidf;
    return *ppidl != NULL ? S_OK : E_OUTOFMEMORY;
}

BOOL _ValidPathSegment(LPCTSTR pszSegment)
{
    if (*pszSegment && !PathIsDotOrDotDot(pszSegment))
    {
        for (LPCTSTR psz = pszSegment; *psz; psz = CharNext(psz))
        {
            if (!PathIsValidChar(*psz, PIVC_LFN_NAME))
                return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}



// used to parse up file path like strings:
//      "folder\folder\file.txt"
//      "file.txt"
//
// in/out:
//      *ppszIn   in: pointer to start of the buffer, 
//                output: advanced to next location, NULL on last segment
// out:
//      *pszSegment NULL if nothing left
//
// returns:
//      S_OK            got a segment
//      S_FALSE         loop done, *pszSegment emtpy
//      E_INVALIDARG    invalid input "", "\foo", "\\foo", "foo\\bar", "?<>*" chars in seg
 
HRESULT _NextSegment(LPCWSTR *ppszIn, LPTSTR pszSegment, UINT cchSegment, BOOL bValidate)
{
    HRESULT hr;

    *pszSegment = 0;

    if (*ppszIn)
    {
        // WARNING!  Do not use StrPBrkW(*ppszIn, L"\\/"), because
        // Trident passes fully-qualified URLs to
        // SHGetFileInfo(USEFILEATTRIBUTES) and relies on the fact that
        // we won't choke on the embedded "//" in "http://".

        LPWSTR pszSlash = StrChrW(*ppszIn, L'\\');
        if (pszSlash)
        {
            if (pszSlash > *ppszIn) // make sure well formed (no dbl slashes)
            {
                OleStrToStrN(pszSegment, cchSegment, *ppszIn, (int)(pszSlash - *ppszIn));

                //  make sure that there is another segment to return
                if (!*(++pszSlash))
                    pszSlash = NULL;
                hr = S_OK;       
            }
            else
            {
                pszSlash = NULL;
                hr = E_INVALIDARG;    // bad input
            }
        }
        else
        {
            SHUnicodeToTChar(*ppszIn, pszSegment, cchSegment);
            hr = S_OK;       
        }
        *ppszIn = pszSlash;

        if (hr == S_OK && bValidate && !_ValidPathSegment(pszSegment))
        {
            *pszSegment = 0;
            hr = E_INVALIDARG;
        }
    }
    else
        hr = S_FALSE;     // done with loop

    return hr;
}

//  this makes a fake wfd and then uses the normal
//  FillIDFolder as if it were a real found path.

HRESULT CFSFolder::_ParseSimple(LPCWSTR pszPath, const WIN32_FIND_DATA *pfdLast, LPITEMIDLIST *ppidl)
{
    WIN32_FIND_DATA wfd = {0};
    HRESULT hr = S_OK;

    *ppidl = NULL;

    ASSERT(*pszPath);
    
    while (SUCCEEDED(hr) && (S_OK == (hr = _NextSegment((LPCWSTR *)&pszPath, wfd.cFileName, ARRAYSIZE(wfd.cFileName), FALSE))))
    {
        LPITEMIDLIST pidl;

        if (pszPath)
        {
            // internal componets must be folders
            wfd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
        }
        else
        {
            // last segment takes the find data from that passed in
            // copy everything except the cFileName field
            memcpy(&wfd, pfdLast, FIELD_OFFSET(WIN32_FIND_DATA, cFileName));
            StrCpyN(wfd.cAlternateFileName, pfdLast->cAlternateFileName, ARRAYSIZE(wfd.cAlternateFileName));
        }

        hr = _CreateIDList(&wfd, (LPCIDFOLDER)*ppidl, &pidl);
        if (SUCCEEDED(hr))
            hr = SHILAppend(pidl, ppidl);
    }

    if (FAILED(hr))
    {
        if (*ppidl)
        {
            ILFree(*ppidl);
            *ppidl = NULL;
        }
    }
    else
        hr = S_OK;      // pin all success to S_OK
    return hr;
}


HRESULT _CheckPortName(LPCTSTR pszName)
{
    if (PathIsInvalid(pszName))
        return HRESULT_FROM_WIN32(ERROR_BAD_DEVICE);
    else
        return S_OK;
}

class CFindFirstWithTimeout
{
public:
    CFindFirstWithTimeout(LPCTSTR pszPath, DWORD dwTicksToAllow);
    HRESULT FindFirstWithTimeout(WIN32_FIND_DATA *pfd);

    ULONG AddRef();
    ULONG Release();

private:
    static DWORD WINAPI _FindFistThreadProc(void *pv);

    LONG _cRef;
    DWORD _dwTicksToAllow;
    TCHAR _szPath[MAX_PATH];
    WIN32_FIND_DATA _fd;
};

CFindFirstWithTimeout::CFindFirstWithTimeout(LPCTSTR pszPath, DWORD dwTicksToAllow) : _cRef(1), _dwTicksToAllow(dwTicksToAllow)
{
    lstrcpyn(_szPath, pszPath, ARRAYSIZE(_szPath));
}

ULONG CFindFirstWithTimeout::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFindFirstWithTimeout::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

DWORD CFindFirstWithTimeout::_FindFistThreadProc(void *pv)
{
    CFindFirstWithTimeout *pffwt = (CFindFirstWithTimeout *)pv;
    
    HRESULT hr = SHFindFirstFileRetry(NULL, NULL, pffwt->_szPath, &pffwt->_fd, NULL, SHPPFW_NONE);
    
    pffwt->Release();
    return hr;          // retrieved via GetExitCodeThread()
}

HRESULT CFindFirstWithTimeout::FindFirstWithTimeout(WIN32_FIND_DATA *pfd)
{
    HRESULT hr;

    AddRef();   // ref for the thread

    DWORD dwID;
    HANDLE hThread = CreateThread(NULL, 0, _FindFistThreadProc, this, 0, &dwID);
    if (hThread)
    {
        // assume timeout...
        hr = HRESULT_FROM_WIN32(ERROR_TIMEOUT); // timeout return value

        if (WAIT_OBJECT_0 == WaitForSingleObject(hThread, _dwTicksToAllow))
        {
            // thread finished with an HRESULT for us
            DWORD dw;
            if (GetExitCodeThread(hThread, &dw))
            {
                *pfd = _fd;
                hr = dw;    // HRESULT returned by _FindFistThreadProc
            }
        }
        CloseHandle(hThread);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        Release();  // thread create failed, remove that ref
    }
    return hr;
}

HRESULT SHFindFirstFileWithTimeout(LPCTSTR pszPath, DWORD dwTicksToAllow, WIN32_FIND_DATA *pfd)
{
    HRESULT hr;

    CFindFirstWithTimeout *pffwt = new CFindFirstWithTimeout(pszPath, dwTicksToAllow);
    if (pffwt)
    {
        hr = pffwt->FindFirstWithTimeout(pfd);
        pffwt->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CFSFolder::_FindDataFromName(LPCTSTR pszName, DWORD dwAttribs, IBindCtx *pbc, WIN32_FIND_DATA **ppfd)
{
    *ppfd = NULL;

    HRESULT hr = _CheckPortName(pszName);
    if (SUCCEEDED(hr))
    {    
        hr = SHLocalAlloc(sizeof(**ppfd), ppfd);
        if (SUCCEEDED(hr))
        {
            if (-1 == dwAttribs)
            {
                TCHAR szPath[MAX_PATH];
                hr = _GetPath(szPath, ARRAYSIZE(szPath));
                if (SUCCEEDED(hr))
                {
                    PathAppend(szPath, pszName);

                    DWORD dwTicksToAllow;
                    if (SUCCEEDED(BindCtx_GetTimeoutDelta(pbc, &dwTicksToAllow)) && PathIsNetworkPath(szPath))
                    {
                        hr = SHFindFirstFileWithTimeout(szPath, dwTicksToAllow, *ppfd);
                    }
                    else
                    {
                        hr = SHFindFirstFileRetry(NULL, NULL, szPath, *ppfd, NULL, SHPPFW_NONE);
                    }
                }
            }
            else
            {
                //  make a simple one up
                StrCpyN((*ppfd)->cFileName, pszName, ARRAYSIZE((*ppfd)->cFileName));
                (*ppfd)->dwFileAttributes = dwAttribs;
            }
            if (FAILED(hr))
            {
                LocalFree(*ppfd);
                *ppfd = NULL;
            }
        }
    }

    ASSERT(SUCCEEDED(hr) ? NULL != *ppfd : NULL == *ppfd);
    return hr;
}

//
// This function returns a relative pidl for the specified file/folder
//
HRESULT CFSFolder::_CreateIDListFromName(LPCTSTR pszName, DWORD dwAttribs, IBindCtx *pbc, LPITEMIDLIST *ppidl)
{
    WIN32_FIND_DATA *pfd;
    HRESULT hr = _FindDataFromName(pszName, dwAttribs, pbc, &pfd);
    if (SUCCEEDED(hr))
    {
        hr = _CreateIDList(pfd, NULL, ppidl);
        LocalFree(pfd);
    }
    else
        *ppidl = NULL;

    return hr;
}

// used to detect if a name is a folder. this is used in the case that the
// security for this folders parent is set so you can't enum it's contents

BOOL CFSFolder::_CanSeeInThere(LPCTSTR pszName)
{
    TCHAR szPath[MAX_PATH];
    if (SUCCEEDED(_GetPath(szPath, ARRAYSIZE(szPath))))
    {
        HANDLE hfind;
        WIN32_FIND_DATA fd;

        PathAppend(szPath, pszName);
        PathAppend(szPath, TEXT("*.*"));

        hfind = FindFirstFile(szPath, &fd);
        if (hfind != INVALID_HANDLE_VALUE)
            FindClose(hfind);
        return hfind != INVALID_HANDLE_VALUE;
    }
    return FALSE;
}

HRESULT CFSFolder::v_InternalQueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CFSFolder, IShellFolder, IShellFolder2),
        QITABENT(CFSFolder, IShellFolder2),
        QITABENT(CFSFolder, IShellIconOverlay),
        QITABENT(CFSFolder, IShellIcon),
        QITABENTMULTI(CFSFolder, IPersist, IPersistFolder3),
        QITABENTMULTI(CFSFolder, IPersistFolder, IPersistFolder3),
        QITABENTMULTI(CFSFolder, IPersistFolder2, IPersistFolder3),
        QITABENT(CFSFolder, IPersistFolder3),
        QITABENT(CFSFolder, IStorage),
        QITABENT(CFSFolder, IPropertySetStorage),
        QITABENT(CFSFolder, IItemNameLimits),
        QITABENT(CFSFolder, IContextMenuCB),
        QITABENT(CFSFolder, ISetFolderEnumRestriction),
        QITABENT(CFSFolder, IOleCommandTarget),
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr))
    {
        if (IsEqualIID(IID_INeedRealCFSFolder, riid))
        {
            *ppv = this;                // not ref counted
            hr = S_OK;
        }
        else if (IsEqualIID(riid, IID_IPersistFreeThreadedObject))
        {
            if (_GetInner() == _GetOuter()) // not aggregated
            {
                hr = QueryInterface(IID_IPersist, ppv);
            }
            else
            {
                hr = E_NOINTERFACE;
            }
        }
    }
    return hr;
}

// briefcase and file system folder call to reset data

HRESULT CFSFolder::_Reset()
{
    _DestroyColHandlers();

    if (_pidl)
    {
        ILFree(_pidl);
        _pidl = NULL;
    }

    if (_pidlTarget)
    {
        ILFree(_pidlTarget);
        _pidlTarget = NULL;   
    }

    if (_pszPath)
    {
        LocalFree(_pszPath);
        _pszPath = NULL;
    }

    if (_pszNetProvider)
    {
        LocalFree(_pszNetProvider);
        _pszNetProvider = NULL;
    }

    _csidl = -1;
    _dwAttributes = -1;

    _csidlTrack = -1;

    ATOMICRELEASE(_pstg);
    return S_OK;
}

#define INVALID_PATHSPEED   (-100)

CFSFolder::CFSFolder(IUnknown *punkOuter) : CAggregatedUnknown(punkOuter)
{
    _csidl = -1;
    _iFolderIcon = -1;
    _dwAttributes = -1;
    _csidlTrack = -1;
    _nFolderType = FVCBFT_DOCUMENTS;
    _bSlowPath = INVALID_PATHSPEED; // some non-common value
                                    // Note: BOOL is not bool
    _tbOfflineCSC = TRIBIT_UNDEFINED;

    DllAddRef();
}

CFSFolder::~CFSFolder()
{
    _Reset();
    DllRelease();
}

// we need to fail relative type paths since we use PathCombine
// and we don't want that and the Win32 APIs to give us relative path behavior
// ShellExecute() depends on this so it falls back and resolves the relative paths itself

HRESULT CFSFolder::ParseDisplayName(HWND hwnd, IBindCtx *pbc, WCHAR *pszName, ULONG *pchEaten, 
                                    LPITEMIDLIST *ppidl, DWORD *pdwAttributes)
{
    HRESULT hr;
    WIN32_FIND_DATA *pfd;

    if (!ppidl)
        return E_INVALIDARG;
    *ppidl = NULL;   // assume error
    if (pszName == NULL)
        return E_INVALIDARG;

    if (S_OK == SHIsFileSysBindCtx(pbc, &pfd))
    {
        hr = _ParseSimple(pszName, pfd, ppidl);
        if (SUCCEEDED(hr) && pdwAttributes && *pdwAttributes)
        {
            // while strictly not a legit thing to do here, we
            // pass the last IDList because 1) this is a simple IDList
            // 2) we hope that callers don't ask for bits that
            // require a full path to be valid inside the impl of
            // ::GetAttributesOf()
            LPCITEMIDLIST pidlLast = ILFindLastID(*ppidl);  
            GetAttributesOf(1, &pidlLast, pdwAttributes);
        }
        LocalFree(pfd);
    }
    else
    {
        DWORD cchNext = lstrlen(pszName) + 1;
        WCHAR *pszNext = (WCHAR *)alloca(CbFromCchW(cchNext));

        hr = _NextSegment((LPCWSTR *)&pszName, pszNext, cchNext, TRUE);
        if (SUCCEEDED(hr))
        {
            hr = _CreateIDListFromName(pszNext, -1, pbc, ppidl);

            if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            {
                // security "List folder contents" may be disabled for
                // this items parent. so see if this is really there
                if (pszName || _CanSeeInThere(pszNext))
                {
                    hr = _CreateIDListFromName(pszNext, FILE_ATTRIBUTE_DIRECTORY, pbc, ppidl);
                }
            }
            else if (((hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)) || (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))) && 
                     (pszName == NULL) && 
                     (BindCtx_GetMode(pbc, 0) & STGM_CREATE) &&
                     !_fDontForceCreate)
            {
                // create a pidl to something that doesnt exist.
                hr = _CreateIDListFromName(pszNext, FILE_ATTRIBUTE_NORMAL, pbc, ppidl);
            }

            if (SUCCEEDED(hr))
            {
                if (pszName) // more stuff to parse?
                {
                    IShellFolder *psfFolder;
                    hr = BindToObject(*ppidl, pbc, IID_PPV_ARG(IShellFolder, &psfFolder));
                    if (SUCCEEDED(hr))
                    {
                        ULONG chEaten;
                        LPITEMIDLIST pidlNext;

                        hr = psfFolder->ParseDisplayName(hwnd, pbc, 
                            pszName, &chEaten, &pidlNext, pdwAttributes);
                        if (SUCCEEDED(hr))
                        {
                            hr = SHILAppend(pidlNext, ppidl);
                        }
                        psfFolder->Release();
                    }
                }
                else
                {
                    if (pdwAttributes && *pdwAttributes)
                        GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, pdwAttributes);
                }
            }
        }
    }

    if (FAILED(hr) && *ppidl)
    {
        // This is needed if psfFolder->ParseDisplayName() or BindToObject()
        // fails because the pidl is already allocated.
        ILFree(*ppidl);
        *ppidl = NULL;
    }
    ASSERT(SUCCEEDED(hr) ? (*ppidl != NULL) : (*ppidl == NULL));

    // display this only as a warning, this can get hit during mergfldr or IStorage::Create probes
    if (FAILED(hr))
        TraceMsg(TF_WARNING, "CFSFolder::ParseDisplayName(), hr:%x %ls", hr, pszName);
    return hr;
}

STDAPI InitFileFolderClassNames(void)
{
    if (g_szFileTemplate[0] == 0)    // test last one to avoid race
    {
        LoadString(HINST_THISDLL, IDS_FOLDERTYPENAME, g_szFolderTypeName,  ARRAYSIZE(g_szFolderTypeName));
        LoadString(HINST_THISDLL, IDS_FILETYPENAME, g_szFileTypeName, ARRAYSIZE(g_szFileTypeName));
        LoadString(HINST_THISDLL, IDS_EXTTYPETEMPLATE, g_szFileTemplate, ARRAYSIZE(g_szFileTemplate));
    }
    return S_OK;
}

HRESULT CFSFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    InitFileFolderClassNames();
    grfFlags |= _dwEnumRequired;
    grfFlags &= ~_dwEnumForbidden;

    return CFSFolder_CreateEnum(this, hwnd, grfFlags, ppenum);
}

HRESULT CFSFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    // MIL 117282 - Enroute Imaging QuickStitch depends on pre-Jan'97 behavior of us
    // *not* nulling ppv out on !_IsValidID(pidl).  (They pass in a perfectly valid
    // IShellFolder* interfacing asking for IID_IShellFolder on the empty PIDL.)
    //
    if (!(SHGetAppCompatFlags(ACF_WIN95BINDTOOBJECT) & ACF_WIN95BINDTOOBJECT))
        *ppv = NULL;

    HRESULT hr;
    LPCIDFOLDER pidf = _IsValidID(pidl);
    if (pidf)
    {
        LPCITEMIDLIST pidlRight;
        LPIDFOLDER pidfBind;

        hr = _GetJunctionForBind(pidf, &pidfBind, &pidlRight);
        if (SUCCEEDED(hr))
        {
            if (hr == S_OK)
            {
                IShellFolder *psfJunction;
                hr = _Bind(pbc, pidfBind, IID_PPV_ARG(IShellFolder, &psfJunction));
                if (SUCCEEDED(hr))
                {
                    // now bind to the stuff below the junction point
                    hr = psfJunction->BindToObject(pidlRight, pbc, riid, ppv);
                    psfJunction->Release();
                }
                ILFree((LPITEMIDLIST)pidfBind);
            }
            else
            {
                ASSERT(pidfBind == NULL);
                hr = _Bind(pbc, pidf, riid, ppv);
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
        TraceMsg(TF_WARNING, "CFSFolder::BindToObject(), hr:%x bad PIDL %s", hr, DumpPidl(pidl));
    }
    return hr;
}

HRESULT CFSFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

HRESULT CFSFolder::_CheckDriveRestriction(HWND hwnd, REFIID riid)
{
    HRESULT hr = S_OK;
    DWORD dwRest = SHRestricted(REST_NOVIEWONDRIVE);
    if (dwRest)
    {
        TCHAR szPath[MAX_PATH];

        hr = _GetPath(szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            int iDrive = PathGetDriveNumber(szPath);
            if (iDrive != -1)
            {
                // is the drive restricted
                if (dwRest & (1 << iDrive))
                {
                    // don't show the error message on droptarget -- just fail silently
                    if (hwnd && !IsEqualIID(riid, IID_IDropTarget))
                    {
                        ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_RESTRICTIONS),
                                        MAKEINTRESOURCE(IDS_RESTRICTIONSTITLE), MB_OK | MB_ICONSTOP);
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // user saw the error
                    }
                    else
                        hr = E_ACCESSDENIED;
                }
            }
        }
    }
    return hr;
}

HRESULT CFSFolder::_CreateUIHandler(REFIID riid, void **ppv)
{
    HRESULT hr;

    // Cache the view CLSID if not cached.
    if (!_fCachedCLSID)
    {
        if (_IsSelfSystemFolder())
        {
            TCHAR szPath[MAX_PATH];
            if (SUCCEEDED(_GetPath(szPath, ARRAYSIZE(szPath))))
                _fHasCLSID = GetFolderGUID(szPath, _pszNetProvider, &_clsidView, TEXT("UICLSID"));
            _fCachedCLSID = TRUE;
        }
    }

    // Use the handler if it exists
    if (_fHasCLSID)
    {
        IPersistFolder *ppf;
        hr = SHExtCoCreateInstance(NULL, &_clsidView, NULL, IID_PPV_ARG(IPersistFolder, &ppf));
        if (SUCCEEDED(hr))
        {
            hr = ppf->Initialize(_pidl);
            if (FAILED(hr) && _pidlTarget)
            {
                // It may have failed because the _pidl is an alias (not a file folder). if so try
                // again with _pidlTarget (that will be a file system folder)
                // this was required for the Fonts FolderShortcut in the ControlPanel (stephstm)

                hr = ppf->Initialize(_pidlTarget);
            }

            if (SUCCEEDED(hr))
                hr = ppf->QueryInterface(riid, ppv);
            ppf->Release();
        }
    }
    else
        hr = E_FAIL;        // no handler
    return hr;
}

HRESULT CFSFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellView) || 
        IsEqualIID(riid, IID_IDropTarget))
    {
        hr = _CheckDriveRestriction(hwnd, riid);
        if (SUCCEEDED(hr))
        {
            hr = _CreateUIHandler(riid, ppv);
            if (FAILED(hr))
            {
                if (IsEqualIID(riid, IID_IDropTarget))
                {
                    hr = CFSDropTarget_CreateInstance(this, hwnd, (IDropTarget **)ppv);
                }
                else
                {
                    SFV_CREATE csfv = { sizeof(csfv), 0 };

                    hr = QueryInterface(IID_PPV_ARG(IShellFolder, &csfv.pshf));
                    if (SUCCEEDED(hr))
                    {
                        CFSFolderCallback_Create(this, &csfv.psfvcb);

                        hr = SHCreateShellFolderView(&csfv, (IShellView **)ppv);

                        if (csfv.psfvcb)
                            csfv.psfvcb->Release();

                        csfv.pshf->Release();
                    }
                }
            }
        }
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        // do background menu.
        IShellFolder *psfToPass;        // May be an Aggregate...
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfToPass));
        if (SUCCEEDED(hr))
        {
            LPCITEMIDLIST pidlMenuTarget = (_pidlTarget ? _pidlTarget : _pidl);
            HKEY hkNoFiles;
            UINT nKeys;

            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, L"Directory\\Background", 0, MAXIMUM_ALLOWED, &hkNoFiles))
            {
                nKeys = 1;
            }
            else
            {
                hkNoFiles = NULL;
                nKeys = 0;
            }

            IContextMenuCB *pcmcb = new CDefBackgroundMenuCB(pidlMenuTarget);
            if (pcmcb) 
            {
                hr = CDefFolderMenu_Create2Ex(pidlMenuTarget, hwnd, 0, NULL, psfToPass, pcmcb, 
                                              nKeys, &hkNoFiles, (IContextMenu **)ppv);
                pcmcb->Release();
            }
            psfToPass->Release();
            if (hkNoFiles)                          // CDefFolderMenu_Create can handle NULL ok
                RegCloseKey(hkNoFiles);
        }
    }
    else if (IsEqualIID(riid, IID_ICategoryProvider))
    {
        HKEY hk = NULL;
        RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Directory\\shellex\\Category"), &hk);
        hr = CCategoryProvider_Create(NULL, NULL, hk, NULL, this, riid, ppv);
        if (hk)
            RegCloseKey(hk);
    }
    else
    {
        ASSERT(*ppv == NULL);
        hr = E_NOINTERFACE;
    }
    return hr;
}

#define LOGICALXOR(a, b) (((a) && !(b)) || (!(a) && (b)))

HRESULT CFSFolder::_CompareNames(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2, BOOL fCaseSensitive, BOOL fCanonical)
{
    CFileSysItemString fsi1(pidf1), fsi2(pidf2);

    int iRet = StrCmpICW(fsi1.FSName(), fsi2.FSName());

    if (iRet)
    {
        // 
        //  additional check for identity using the 8.3 or AltName()
        //  if we are then the identity compare is better based off
        //  the AltName() which should be the same regardless of 
        //  platform or CP.
        //
        if (LOGICALXOR(fsi1.IsLegacy(), fsi2.IsLegacy()))
        {
            if (lstrcmpiA(fsi1.AltName(), fsi2.AltName()) == 0)
                iRet = 0;
        }

        if (iRet && !fCanonical)
        {
            //  they are definitely not the same item
            // Sort it based on the primary (long) name -- ignore case.
            int iUI = StrCmpLogicalRestricted(fsi1.UIName(this), fsi2.UIName(this));

            //  if they are the same we might want case sensitive instead
            if (iUI == 0 && fCaseSensitive)
            {
                iUI = ustrcmp(fsi1.UIName(this), fsi2.UIName(this));
            }

            if (iUI)
                iRet = iUI;
        }
    }
    
    return ResultFromShort((short)iRet);
}

HRESULT CFSFolder::_CompareFileTypes(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    short result;

    ENTERCRITICAL;
    LPCTSTR psz1 = _GetTypeName(pidf1);
    if (!psz1)
        psz1 = TEXT("");

    LPCTSTR psz2 = _GetTypeName(pidf2);
    if (!psz2)
        psz2 = TEXT("");

    if (psz1 != psz2)
        result = (short) ustrcmpi(psz1, psz2);
    else
        result = 0;

    LEAVECRITICAL;

    return ResultFromShort(result);
}

HRESULT CFSFolder::_CompareModifiedDate(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    if ((DWORD)MAKELONG(pidf1->timeModified, pidf1->dateModified) <
        (DWORD)MAKELONG(pidf2->timeModified, pidf2->dateModified))
    {
        return ResultFromShort(-1);
    }
    if ((DWORD)MAKELONG(pidf1->timeModified, pidf1->dateModified) >
        (DWORD)MAKELONG(pidf2->timeModified, pidf2->dateModified))
    {
        return ResultFromShort(1);
    }

    return ResultFromShort(0);
}

HRESULT CFSFolder::_CompareCreateTime(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    WIN32_FIND_DATAW wfd1, wfd2;

    if (SUCCEEDED(_FindDataFromIDFolder(pidf1, &wfd1, FALSE)) && SUCCEEDED(_FindDataFromIDFolder(pidf2, &wfd2, FALSE)))
    {
        return ResultFromShort(CompareFileTime(&wfd1.ftCreationTime, &wfd2.ftCreationTime));
    }

    return ResultFromShort(0);
}

HRESULT CFSFolder::_CompareAccessTime(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    WIN32_FIND_DATAW wfd1, wfd2;

    if (SUCCEEDED(_FindDataFromIDFolder(pidf1, &wfd1, FALSE)) && SUCCEEDED(_FindDataFromIDFolder(pidf2, &wfd2, FALSE)))
    {
        return ResultFromShort(CompareFileTime(&wfd1.ftLastAccessTime, &wfd2.ftLastAccessTime));
    }

    return ResultFromShort(0);
}

HRESULT CFSFolder::_CompareAttribs(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    const DWORD mask = FILE_ATTRIBUTE_READONLY  |
                       FILE_ATTRIBUTE_HIDDEN    |
                       FILE_ATTRIBUTE_SYSTEM    |
                       FILE_ATTRIBUTE_ARCHIVE   |
                       FILE_ATTRIBUTE_COMPRESSED|
                       FILE_ATTRIBUTE_ENCRYPTED |
                       FILE_ATTRIBUTE_OFFLINE;

    // Calculate value of desired bits in attribute DWORD.
    DWORD dwValueA = pidf1->wAttrs & mask;
    DWORD dwValueB = pidf2->wAttrs & mask;

    if (dwValueA != dwValueB)
    {
        // If the values are not equal,
        // sort alphabetically based on string representation.
        TCHAR szTempA[ARRAYSIZE(g_adwAttributeBits) + 1];
        TCHAR szTempB[ARRAYSIZE(g_adwAttributeBits) + 1];

        // Create attribute string for objects A and B.
        BuildAttributeString(pidf1->wAttrs, szTempA, ARRAYSIZE(szTempA));
        BuildAttributeString(pidf2->wAttrs, szTempB, ARRAYSIZE(szTempB));

        // Compare attribute strings and determine difference.
        int diff = ustrcmp(szTempA, szTempB);

        if (diff > 0)
           return ResultFromShort(1);
        if (diff < 0)
           return ResultFromShort(-1);
    }
    return ResultFromShort(0);
}

HRESULT CFSFolder::_CompareFolderness(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    if (_IsReal(pidf1) && _IsReal(pidf2))
    {
        // Always put the folders first
        if (_IsFolder(pidf1))
        {
            if (!_IsFolder(pidf2))
                return ResultFromShort(-1);
        }
        else if (_IsFolder(pidf2))
            return ResultFromShort(1);
    }
    return ResultFromShort(0);    // same
}

HRESULT CFSFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr;
    LPCIDFOLDER pidf1 = _IsValidID(pidl1);
    LPCIDFOLDER pidf2 = _IsValidID(pidl2);

    if (!pidf1 || !pidf2)
    {
        // ASSERT(0);      // we hit this often... who is the bad guy?
        return E_INVALIDARG;
    }

    hr = _CompareFolderness(pidf1, pidf2);
    if (hr != ResultFromShort(0))
        return hr;

    // SHCIDS_ALLFIELDS means to compare absolutely, ie: even if only filetimes
    // are different, we rule file pidls to be different
    int iColumn = ((DWORD)lParam & SHCIDS_COLUMNMASK);

    switch (iColumn)
    {
    case FS_ICOL_SIZE:
        {
            ULONGLONG ull1 = _Size(pidf1);
            ULONGLONG ull2 = _Size(pidf2);

            if (ull1 < ull2)
                return ResultFromShort(-1);
            if (ull1 > ull2)
                return ResultFromShort(1);
        }
        goto DoDefault;

    case FS_ICOL_TYPE:
        hr = _CompareFileTypes(pidf1, pidf2);
        if (!hr)
            goto DoDefault;
        break;

    case FS_ICOL_WRITETIME:
        hr = _CompareModifiedDate(pidf1, pidf2);
        if (!hr)
            goto DoDefault;
        break;

    case FS_ICOL_NAME:
        hr = _CompareNames(pidf1, pidf2, TRUE, BOOLIFY((SHCIDS_CANONICALONLY & lParam)));
        if (hr == ResultFromShort(0))
        {
            // pidl1 is not simple
            hr = ILCompareRelIDs(this, pidl1, pidl2, lParam);
            goto DoDefaultModification;
        }
        break;

    case FS_ICOL_CREATETIME:
        hr = _CompareCreateTime(pidf1, pidf2);
        if (!hr)
            goto DoDefault;
        break;

    case FS_ICOL_ACCESSTIME:
        hr = _CompareAccessTime(pidf1, pidf2);
        if (!hr)
            goto DoDefault;
        break;

    case FS_ICOL_ATTRIB:
        hr = _CompareAttribs(pidf1, pidf2);
        if (hr)
            return hr;

        goto DoDefault;

    default:
        iColumn -= ARRAYSIZE(c_fs_cols);

        // 99/03/24 #295631 vtan: If not one of the standard columns then
        // it's probably an extended column. Make a check for dates.

        // 99/05/18 #341468 vtan: But also fail if it is an extended column
        // because this implementation of IShellFolder::CompareIDs only
        // understands basic file system columns and extended date columns.

        if (iColumn >= 0) 
        {
            hr = _CompareExtendedProp(iColumn, pidf1, pidf2);
            if (hr)
                return hr;
        }
DoDefault:
        hr = _CompareNames(pidf1, pidf2, FALSE, BOOLIFY((SHCIDS_CANONICALONLY & lParam)));
    }

DoDefaultModification:

    // If they were equal so far, but the caller wants SHCIDS_ALLFIELDS,
    // then look closer.
    if ((S_OK == hr) && (lParam & SHCIDS_ALLFIELDS)) 
    {
        // Must sort by modified date to pick up any file changes!
        hr = _CompareModifiedDate(pidf1, pidf2);
        if (!hr)
            hr = _CompareAttribs(pidf1, pidf2);
    }

    return hr;
}

// test to see if this folder object is a net folder

BOOL CFSFolder::_IsNetPath()
{
    BOOL fRemote = FALSE;       // assume no
    TCHAR szPath[MAX_PATH];
    if (SUCCEEDED(_GetPath(szPath, ARRAYSIZE(szPath))))
    {
        fRemote = PathIsRemote(szPath);
    }
    return fRemote;
}

BOOL _CanRenameFolder(LPCTSTR pszFolder)
{
    static const UINT c_aiNoRenameFolders[] = {
        CSIDL_WINDOWS, 
        CSIDL_SYSTEM, 
        CSIDL_PROGRAM_FILES, 
        CSIDL_FONTS, 
    };
    return !PathIsOneOf(pszFolder, c_aiNoRenameFolders, ARRAYSIZE(c_aiNoRenameFolders));
}

STDAPI_(LPCIDFOLDER) CFSFolder::_IsValidIDHack(LPCITEMIDLIST pidl)
{
    if (!(ACF_NOVALIDATEFSIDS & SHGetAppCompatFlags(ACF_NOVALIDATEFSIDS)))
    {
        return _IsValidID(pidl);
    }
    else if (pidl)
    {
        //  old behavior was that we didnt validate, we just
        //  looked for the last id and casted it
        return (LPCIDFOLDER)ILFindLastID(pidl);
    }
    return NULL;
}

#define SFGAO_NOT_RECENT    (SFGAO_CANRENAME | SFGAO_CANLINK)
#define SFGAO_REQ_MASK      (SFGAO_HASSUBFOLDER | SFGAO_FILESYSANCESTOR | SFGAO_FOLDER | SFGAO_DROPTARGET | SFGAO_LINK | SFGAO_STREAM | SFGAO_STORAGEANCESTOR | SFGAO_STORAGE | SFGAO_READONLY)

HRESULT CFSFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut)
{
    LPCIDFOLDER pidf = cidl ? _IsValidIDHack(apidl[0]) : NULL;

    ULONG rgfOut = SFGAO_CANDELETE | SFGAO_CANMOVE | SFGAO_CANCOPY | SFGAO_HASPROPSHEET
                    | SFGAO_FILESYSTEM | SFGAO_DROPTARGET | SFGAO_CANRENAME | SFGAO_CANLINK;

    ASSERT(cidl ? apidl[0] == ILFindLastID(apidl[0]) : TRUE); // should be single level IDs only
    ASSERT(cidl ? BOOLFROMPTR(pidf) : TRUE); // should always be FS PIDLs

    //  the RECENT folder doesnt like items in it renamed or linked to.
    if ((*prgfInOut & (SFGAO_NOT_RECENT)) && _IsCSIDL(CSIDL_RECENT))
    {
        rgfOut &= ~SFGAO_NOT_RECENT;
    }
        
    if (cidl == 1 && pidf)
    {
        CFileSysItemString fsi(pidf);
        TCHAR szPath[MAX_PATH];

        if (*prgfInOut & (SFGAO_VALIDATE | SFGAO_CANRENAME | SFGAO_REMOVABLE | SFGAO_SHARE))
        {
            HRESULT hr = _GetPathForItem(pidf, szPath, ARRAYSIZE(szPath));
            if (FAILED(hr))
                return hr;
        }
        else
        {
            // just in case -- if somebody else needs the path they should add to the check above
            szPath[0] = 0;
        }

        if (*prgfInOut & SFGAO_VALIDATE)
        {
            DWORD dwAttribs;
            if (!PathFileExistsAndAttributes(szPath, &dwAttribs))
                return E_FAIL;

            // Tell the extended columns to update when someone request validation of a pidl
            // This allows a client of the shell folder who uses extended columns without a
            // view to force an update on stale information (i.e. Start Menu with InfoTips)
            // - lamadio 6.11.99
            _bUpdateExtendedCols = TRUE;

            // hackhack.  if they pass in validate, we party into it and update
            // the attribs
            if (!IsBadWritePtr((void *)&pidf->wAttrs, sizeof(pidf->wAttrs)))
                ((LPIDFOLDER)pidf)->wAttrs = (WORD)dwAttribs;
        }

        if (*prgfInOut & SFGAO_COMPRESSED)
        {
            if (pidf->wAttrs & FILE_ATTRIBUTE_COMPRESSED)
            {
                rgfOut |= SFGAO_COMPRESSED;
            }
        }

        if (*prgfInOut & SFGAO_ENCRYPTED)
        {
            if (pidf->wAttrs & FILE_ATTRIBUTE_ENCRYPTED)
            {
                rgfOut |= SFGAO_ENCRYPTED;
            }
        }

        if (*prgfInOut & SFGAO_READONLY)
        {
            if ((pidf->wAttrs & FILE_ATTRIBUTE_READONLY) && !(pidf->wAttrs & FILE_ATTRIBUTE_DIRECTORY))
            {
                rgfOut |= SFGAO_READONLY;
            }
        }

        if (*prgfInOut & SFGAO_HIDDEN)
        {
            if (pidf->wAttrs & FILE_ATTRIBUTE_HIDDEN)
            {
                rgfOut |= SFGAO_HIDDEN;
            }
        }

        if (*prgfInOut & SFGAO_NONENUMERATED)
        {
            if (IsSuperHidden(pidf->wAttrs))
            {
                // mark superhidden as nonenumerated, IsSuperHidden checks current settings
                rgfOut |= SFGAO_NONENUMERATED;
            }
            else if (pidf->wAttrs & FILE_ATTRIBUTE_HIDDEN)
            {
                // mark normal hidden as nonenumerated if necessary
                SHELLSTATE ss;
                SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);
                if (!ss.fShowAllObjects)
                {
                    rgfOut |= SFGAO_NONENUMERATED;
                }
            }
        }

        if (*prgfInOut & SFGAO_ISSLOW)
        {
            // "offline" implies slow
            if (_IsOffline(pidf) || _IsSlowPath())
            {
                rgfOut |= SFGAO_ISSLOW;
            }
        }

        if (_IsFolder(pidf))
        {
            rgfOut |= SFGAO_FOLDER | SFGAO_STORAGE | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR;
            if ((*prgfInOut & SFGAO_CANRENAME) && (fsi.CantRename(this) || !_CanRenameFolder(szPath)))
                rgfOut &= ~SFGAO_CANRENAME;

            if ((*prgfInOut & SFGAO_REMOVABLE) && PathIsRemovable(szPath))
            {
                rgfOut |= SFGAO_REMOVABLE;
            }

            if ((*prgfInOut & SFGAO_SHARE) && IsShared(szPath, FALSE))
            {
                rgfOut |= SFGAO_SHARE;
            }
        }
        else
        {
            rgfOut |= SFGAO_STREAM;
        }

        if (*prgfInOut & SFGAO_LINK)
        {
            DWORD dwFlags = fsi.ClassFlags(FALSE);
            if (dwFlags & SHCF_IS_LINK)
            {
                rgfOut |= SFGAO_LINK;
            }
        }

        CLSID clsid;
        if (fsi.GetJunctionClsid(&clsid, TRUE))
        {
            // NOTE: here we are always including SFGAO_FILESYSTEM. this was not the original
            // shell behavior. but since these things will succeeded on SHGetPathFromIDList()
            // it is the right thing to do. to filter out SFGAO_FOLDER things that might 
            // have files in them use SFGAO_FILESYSANCESTOR.
            //
            // clear out the things we want the extension to be able to optionally have
            rgfOut &= ~(SFGAO_DROPTARGET | SFGAO_STORAGE | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR);

            // let folder shortcuts yank the folder bit too for bad apps.
            if (IsEqualGUID(clsid, CLSID_FolderShortcut) &&
                (SHGetAppCompatFlags(ACF_STRIPFOLDERBIT) & ACF_STRIPFOLDERBIT))
            {
                rgfOut &= ~SFGAO_FOLDER;
            }

            // and let him add some bits in
            rgfOut |= SHGetAttributesFromCLSID2(&clsid, SFGAO_HASSUBFOLDER, SFGAO_REQ_MASK) & SFGAO_REQ_MASK;
            
            // Mill #123708
            // prevent zips, cabs and other files with SFGAO_FOLDER set
            // from being treated like folders inside bad file open dialogs.
            if (!(pidf->wAttrs & FILE_ATTRIBUTE_DIRECTORY) &&
                (SHGetAppCompatFlags (ACF_STRIPFOLDERBIT) & ACF_STRIPFOLDERBIT))
            {
                rgfOut &= ~SFGAO_FOLDER;
            }

            // Check if this folder needs File System Ancestor bit
            if ((rgfOut & SFGAO_FOLDER) && !(rgfOut & SFGAO_FILESYSANCESTOR)
            && SHGetObjectCompatFlags(NULL, &clsid) & OBJCOMPATF_NEEDSFILESYSANCESTOR)
            {
                rgfOut |= SFGAO_FILESYSANCESTOR;
            }
        }

        // it can only have subfolders if we've first found it's a folder
        if ((rgfOut & SFGAO_FOLDER) && (*prgfInOut & SFGAO_HASSUBFOLDER))
        {
            if (pidf->wAttrs & FILE_ATTRIBUTE_REPARSE_POINT)
            {
                rgfOut |= SFGAO_HASSUBFOLDER;   // DFS junction, local mount point, assume sub folders
            }
            else if (_IsNetPath())
            {
                // it would be nice to not assume this. this messes up
                // home net cases where we get the "+" wrong
                rgfOut |= SFGAO_HASSUBFOLDER;   // assume yes because these are slow
            }
            else if (!(rgfOut & SFGAO_HASSUBFOLDER))
            {
                IShellFolder *psf;
                if (SUCCEEDED(_Bind(NULL, pidf, IID_PPV_ARG(IShellFolder, &psf))))
                {
                    IEnumIDList *peunk;
                    if (S_OK == psf->EnumObjects(NULL, SHCONTF_FOLDERS, &peunk))
                    {
                        LPITEMIDLIST pidlT;
                        if (peunk->Next(1, &pidlT, NULL) == S_OK)
                        {
                            rgfOut |= SFGAO_HASSUBFOLDER;
                            SHFree(pidlT);
                        }
                        peunk->Release();
                    }
                    psf->Release();
                }
            }
        }

        if (*prgfInOut & SFGAO_GHOSTED)
        {
            if (pidf->wAttrs & FILE_ATTRIBUTE_HIDDEN)
                rgfOut |= SFGAO_GHOSTED;
        }

        if ((*prgfInOut & SFGAO_BROWSABLE) &&
            (_IsFile(pidf)) &&
            (fsi.ClassFlags(FALSE) & SHCF_IS_BROWSABLE))
        {
            rgfOut |= SFGAO_BROWSABLE;
        }
    }

    *prgfInOut = rgfOut;
    return S_OK;
}

// load handler for an item based on the handler type:
//     DropHandler, IconHandler, etc.
// in:
//      pidf            type of this object specifies the type of handler - can be multilevel
//      pszHandlerType  handler type name "DropTarget", may be NULL
//      riid            interface to talk on
// out:
//      ppv             output object
//
HRESULT CFSFolder::_LoadHandler(LPCIDFOLDER pidf, DWORD grfMode, LPCTSTR pszHandlerType, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;    
    TCHAR szIID[40];

    ASSERT(_FindJunctionNext(pidf) == NULL);     // no extra non file sys goo please

    *ppv = NULL;

    // empty handler type, use the stringized IID as the handler name
    if (NULL == pszHandlerType)
    {
        szIID[0] = 0;
        SHStringFromGUID(riid, szIID, ARRAYSIZE(szIID));
        pszHandlerType = szIID;
    }

    CFileSysItemString fsi(_FindLastID(pidf));
    IAssociationArray *paa;
    hr = fsi.AssocCreate(this, FALSE, IID_PPV_ARG(IAssociationArray, &paa));    
    if (SUCCEEDED(hr))
    {
        CSmartCoTaskMem<WCHAR> spszClsid;
        hr = paa->QueryString(ASSOCELEM_MASK_QUERYNORMAL, AQNS_SHELLEX_HANDLER, pszHandlerType, &spszClsid);
        if (SUCCEEDED(hr))
        {
            hr = _HandlerCreateInstance(pidf, spszClsid, grfMode, riid, ppv);
        }
        paa->Release();
    }
    return hr;
}

HRESULT CFSFolder::_HandlerCreateInstance(LPCIDFOLDER pidf, PCWSTR pszClsid, DWORD grfMode, REFIID riid, void **ppv)
{
    IPersistFile *ppf;
    HRESULT hr = SHExtCoCreateInstance(pszClsid, NULL, NULL, IID_PPV_ARG(IPersistFile, &ppf));
    if (SUCCEEDED(hr))
    {
        WCHAR wszPath[MAX_PATH];
        hr = _GetPathForItem(pidf, wszPath, ARRAYSIZE(wszPath));
        if (SUCCEEDED(hr))
        {
            hr = ppf->Load(wszPath, grfMode);
            if (SUCCEEDED(hr))
            {
                hr = ppf->QueryInterface(riid, ppv);
            }
        }
        ppf->Release();
    }
    return hr;
}

HRESULT CFSFolder::_CreateShimgvwExtractor(LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    CFileSysItemString fsi(pidf);
    if (fsi.IsShimgvwImage())
    {
        //  cocreate CLSID_GdiThumbnailExtractor implemented in shimgvw.dll
        hr = _HandlerCreateInstance(pidf, L"{3F30C968-480A-4C6C-862D-EFC0897BB84B}", STGM_READ, riid, ppv);
    }
    return hr;
}

int CFSFolder::_GetDefaultFolderIcon()
{
    int iIcon = II_FOLDER;
    UINT csidlFolder = _GetCSIDL();

    // We're removing the icon distinction between per user and common folders.
    switch (csidlFolder)
    {
    case CSIDL_STARTMENU:
    case CSIDL_COMMON_STARTMENU:
    case CSIDL_PROGRAMS:
    case CSIDL_COMMON_PROGRAMS:
        iIcon = II_STSPROGS;
        break;
    }

    return iIcon;
}

DWORD CFSFolder::_Attributes()
{
    if (_dwAttributes == -1)
    {
        TCHAR szPath[MAX_PATH];

        if (SUCCEEDED(_GetPath(szPath, ARRAYSIZE(szPath))))
            _dwAttributes = GetFileAttributes(szPath);
        if (_dwAttributes == -1)
            _dwAttributes = FILE_ATTRIBUTE_DIRECTORY;     // assume this on failure
    }
    return _dwAttributes;
}

// non junction, but has the system or readonly bit (regular folder marked special for us)
BOOL CFSFolder::_IsSelfSystemFolder()
{
    return (_Attributes() & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY));
}

// Determine if there is a LocalizedFileName section in our desktop.ini file
BOOL CFSFolder::_HasLocalizedFileNames()
{
    if (_tbHasLocalizedFileNamesSection == TRIBIT_UNDEFINED)
    {
        TCHAR szPath[MAX_PATH];
        TCHAR szName[MAX_PATH];
        TCHAR szBuf[4];

        _GetPath(szPath, ARRAYSIZE(szPath));

        if (_GetIniPath(FALSE, szPath, _pszNetProvider, szName) && 
            GetPrivateProfileSection(TEXT("LocalizedFileNames"), szBuf, sizeof(szBuf)/sizeof(TCHAR), szName) > 0)
            _tbHasLocalizedFileNamesSection = TRIBIT_TRUE;
        else
            _tbHasLocalizedFileNamesSection = TRIBIT_FALSE;
    }
    return (_tbHasLocalizedFileNamesSection == TRIBIT_TRUE);
}


// This function creates a default IExtractIcon object for either
// a file or a junction point. We should not supposed to call this function
// for a non-junction point directory (we don't want to hit the disk!).

HRESULT CFSFolder::_CreateDefExtIcon(LPCIDFOLDER pidf, REFIID riid, void **ppxicon)
{
    HRESULT hr = E_OUTOFMEMORY;

    // WARNING: don't replace this if-statement with _IsFolder(pidf))!!!
    // otherwise all junctions (like briefcase) will get the Folder icon.
    //
    if (_IsFileFolder(pidf))
    {
        hr = _CreateFileFolderDefExtIcon(pidf, riid, ppxicon);
    }
    else
    {
        //  not a folder, get IExtractIcon and extract it.
        //  (might be a ds folder)
        CFileSysItemString fsi(pidf);
        DWORD shcf = fsi.ClassFlags(TRUE);
        //  right now we block all per-instance icons if pidf is offline.
        //  but in the future we might want to enable offline awareness to per-instance icons.
        if ((shcf & SHCF_ICON_PERINSTANCE) && (!_IsOffline(pidf)))
        {
            hr = _CreatePerInstanceDefExtIcon(pidf, shcf, riid, ppxicon);
        }
        else
        {
            hr = _CreatePerClassDefExtIcon(pidf, shcf, riid, ppxicon);
        }
    }
    return hr;
}

HRESULT CFSFolder::_CreateFileFolderDefExtIcon(LPCIDFOLDER pidf, REFIID riid, void **ppxicon)
{
    ASSERT(_IsFileFolder(pidf)); // Sanity check.  Reference comments in _CreateDefExtIcon().

    WCHAR wszModule[MAX_PATH];
    UINT  iIcon;
    UINT  iIconOpen;
    UINT  uFlags;

    WCHAR wszPath[MAX_PATH];
    if (_GetMountingPointInfo(pidf, wszPath, ARRAYSIZE(wszPath)))
    {
        // We want same icon for open and close mount point (kind of drive)
        iIcon           = GetMountedVolumeIcon(wszPath, wszModule, ARRAYSIZE(wszModule));
        iIconOpen       = iIcon;
        uFlags          = GIL_PERCLASS;
    }
    else if (_IsSystemFolder(pidf) && _GetFolderIconPath(pidf, wszModule, ARRAYSIZE(wszModule), &iIcon))
    {
        iIconOpen       = iIcon;
        uFlags          = GIL_PERINSTANCE;
    }
    else
    {
        wszModule[0]    = 0;
        iIcon           = _GetDefaultFolderIcon();
        iIconOpen       = II_FOLDEROPEN;
        uFlags          = GIL_PERCLASS;
    }

    return SHCreateDefExtIcon(wszModule, iIcon, iIconOpen, uFlags, II_FOLDER, riid, ppxicon);
}

HRESULT CFSFolder::_CreatePerInstanceDefExtIcon(LPCIDFOLDER pidf, DWORD shcf, REFIID riid, void **ppxicon)
{
    HRESULT hr;

    ASSERT(shcf & SHCF_ICON_PERINSTANCE);
    ASSERT(!_IsOffline(pidf)); // Sanity check.  Currently we block ALL
                               // per-instance icons if pidf is offline.

    if (shcf & SHCF_HAS_ICONHANDLER)
    {
        IUnknown *punk;
        hr = _LoadHandler(pidf, STGM_READ, TEXT("IconHandler"), IID_PPV_ARG(IUnknown, &punk));
        if (SUCCEEDED(hr))
        {
            hr = punk->QueryInterface(riid, ppxicon);
            punk->Release();
        }
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        hr = _GetPathForItem(pidf, szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            DWORD uid = _GetUID(pidf);
            hr = SHCreateDefExtIcon(szPath, uid, uid, GIL_PERINSTANCE | GIL_NOTFILENAME, -1, riid, ppxicon);
        }
    }

    if (FAILED(hr))
    {
        *ppxicon = NULL;
    }

    return hr;
}

HRESULT CFSFolder::_CreatePerClassDefExtIcon(LPCIDFOLDER pidf, DWORD shcf, REFIID riid, void **ppxicon)
{
    UINT iIcon = (shcf & SHCF_ICON_INDEX);
    if (II_FOLDER == iIcon)
    {
        iIcon = _GetDefaultFolderIcon();
    }
    return SHCreateDefExtIcon(c_szStar, iIcon, iIcon, GIL_PERCLASS | GIL_NOTFILENAME, -1, riid, ppxicon);
}

DWORD CALLBACK CFSFolder::_PropertiesThread(void *pv)
{
    PROPSTUFF * pps = (PROPSTUFF *)pv;
    STGMEDIUM medium;
    ULONG_PTR dwCookie = 0;
    ActivateActCtx(NULL, &dwCookie);
    LPIDA pida = DataObj_GetHIDA(pps->pdtobj, &medium);
    if (pida)
    {
        LPITEMIDLIST pidl = IDA_ILClone(pida, 0);
        if (pidl)
        {
            TCHAR szPath[MAX_PATH];
            LPTSTR pszCaption;
            HKEY rgKeys[MAX_ASSOC_KEYS] = {0};
            DWORD cKeys = SHGetAssocKeysForIDList(pidl, rgKeys, ARRAYSIZE(rgKeys));

            // REVIEW: psb?
            pszCaption = SHGetCaption(medium.hGlobal);
            SHOpenPropSheet(pszCaption, rgKeys, cKeys,
                                &CLSID_ShellFileDefExt, pps->pdtobj, NULL, pps->pStartPage);
            if (pszCaption)
                SHFree(pszCaption);

            SHRegCloseKeys(rgKeys, cKeys);

            if (SHGetPathFromIDList(pidl, szPath))
            {
                if (lstrcmpi(PathFindExtension(szPath), TEXT(".pif")) == 0)
                {
                    DebugMsg(TF_FSTREE, TEXT("cSHCNRF_pt: DOS properties done, generating event."));
                    SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, pidl, NULL);
                }
            }

            ILFree(pidl);
        }

        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return 0;
}



//
// Display a property sheet for a set of files.
// The data object supplied must provide the "Shell IDList Array"
// clipboard format.
// The dwFlags argument is provided for future expansion.  It is
// currently unused.
//
STDAPI SHMultiFileProperties(IDataObject *pdtobj, DWORD dwFlags)
{
    return SHLaunchPropSheet(CFSFolder::_PropertiesThread, pdtobj, 0, NULL, NULL);
}

// fMask is from CMIC_MASK_*
STDAPI CFSFolder_CreateLinks(HWND hwnd, IShellFolder *psf, IDataObject *pdtobj, LPCTSTR pszDir, DWORD fMask)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetIDListFromUnk(psf, &pidl);
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];

        if (SHGetPathFromIDList(pidl, szPath))
        {
            UINT fCreateLinkFlags;
            int cItems = DataObj_GetHIDACount(pdtobj);
            LPITEMIDLIST *ppidl = (LPITEMIDLIST *)LocalAlloc(LPTR, sizeof(LPITEMIDLIST) * cItems);
            // passing ppidl == NULL is correct in failure case

            if ((pszDir == NULL) || (lstrcmpi(pszDir, szPath) == 0))
            {
                // create the link in the current folder
                fCreateLinkFlags = SHCL_USETEMPLATE;
            }
            else
            {
                // this is a sys menu, ask to create on desktop
                fCreateLinkFlags = SHCL_USETEMPLATE | SHCL_USEDESKTOP;
                if (!(fMask & CMIC_MASK_FLAG_NO_UI))
                {
                    fCreateLinkFlags |= SHCL_CONFIRM;
                }
            }

            hr = SHCreateLinks(hwnd, szPath, pdtobj, fCreateLinkFlags, ppidl);

            if (ppidl)
            {
                // select those objects;
                HWND hwndSelect = ShellFolderViewWindow(hwnd);

                // select the new links, but on the first one deselect all other selected things

                for (int i = 0; i < cItems; i++)
                {
                    if (ppidl[i])
                    {
                        SendMessage(hwndSelect, SVM_SELECTITEM,
                            i == 0 ? SVSI_SELECT | SVSI_ENSUREVISIBLE | SVSI_DESELECTOTHERS | SVSI_FOCUSED :
                                     SVSI_SELECT,
                            (LPARAM)ILFindLastID(ppidl[i]));
                        ILFree(ppidl[i]);
                    }
                }
                LocalFree((HLOCAL)ppidl);
            }
        }
        else
        {
            hr = E_FAIL;
        }
        ILFree(pidl);
    }
    return hr;
}

// Parameter to the "Delete" thread.
//
typedef struct {
    IDataObject     *pDataObj;      // null on entry to thread proc
    IStream         *pstmDataObj;   // marshalled data object
    HWND            hwndOwner;
    UINT            uFlags;
    UINT            fOptions;
} FSDELTHREADPARAM;

void FreeFSDELThreadParam(FSDELTHREADPARAM * pfsthp)
{
    ATOMICRELEASE(pfsthp->pDataObj);
    ATOMICRELEASE(pfsthp->pstmDataObj);
    LocalFree(pfsthp);
}

DWORD CALLBACK FileDeleteThreadProc(void *pv)
{
    FSDELTHREADPARAM *pfsthp = (FSDELTHREADPARAM *)pv;

    CoGetInterfaceAndReleaseStream(pfsthp->pstmDataObj, IID_PPV_ARG(IDataObject, &pfsthp->pDataObj));
    pfsthp->pstmDataObj = NULL;

    if (pfsthp->pDataObj)
        DeleteFilesInDataObject(pfsthp->hwndOwner, pfsthp->uFlags, pfsthp->pDataObj, pfsthp->fOptions);

    FreeFSDELThreadParam(pfsthp);

    return 0;
}

//
// IContextMenuCB
// right click context menu for items handler
//
// Returns:
//      S_OK, if successfully processed.
//      S_FALSE, if default code should be used.
//
STDMETHODIMP CFSFolder::CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg) 
    {
    case DFM_MERGECONTEXTMENU:
        if (!(wParam & CMF_VERBSONLY))
        {
            LPQCMINFO pqcm = (LPQCMINFO)lParam;

            // corel relies on the hard coded send to menu so we give them one
            BOOL bCorelSuite7Hack = (SHGetAppCompatFlags(ACF_CONTEXTMENU) & ACF_CONTEXTMENU);
            if (bCorelSuite7Hack)
            {
                CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_FSVIEW_ITEM_COREL7_HACK, 0, pqcm);
            }
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_INVOKECOMMANDEX:
        {
            DFMICS *pdfmics = (DFMICS *)lParam;
            switch (wParam)
            {
            case DFM_CMD_DELETE:

                // try not to do delete on the UI thread
                // with System Restore it may be slow
                //
                // NOTE: we need to test to make sure this is acceptable as the data
                // object may have come from a data object extension, for example a
                // scrap file. but that is a very rare case (DataObj_CanGoAsync() will almost always
                // return true).

                hr = E_FAIL;
                if ((pdfmics->fMask & CMIC_MASK_ASYNCOK) && DataObj_CanGoAsync(pdtobj))
                {
                    FSDELTHREADPARAM *pfsthp;
                    hr = SHLocalAlloc(sizeof(*pfsthp), &pfsthp);
                    if (SUCCEEDED(hr))
                    {
                        hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdtobj, &pfsthp->pstmDataObj);
                        if (SUCCEEDED(hr))
                        {
                            pfsthp->hwndOwner = hwnd;
                            pfsthp->uFlags = pdfmics->fMask;
                            //  dont allow undo in the recent folder.
                            pfsthp->fOptions = _IsCSIDL(CSIDL_RECENT) ? SD_NOUNDO : 0;

                            // create another thread to avoid blocking the source thread.
                            if (!SHCreateThread(FileDeleteThreadProc, pfsthp, CTF_COINIT, NULL))
                            {
                                hr = E_FAIL;
                            }
                        }

                        if (FAILED(hr))
                        {
                            FreeFSDELThreadParam(pfsthp);  // cleanup
                        }
                    }
                }

                if (S_OK != hr)
                {
                    // could not go async, do it sync here
                    // dont allow undo in the recent folder.
                    hr = DeleteFilesInDataObject(hwnd, pdfmics->fMask, pdtobj,
                        _IsCSIDL(CSIDL_RECENT) ? SD_NOUNDO : 0);
                }
            
                break;

            case DFM_CMD_LINK:
                hr = CFSFolder_CreateLinks(hwnd, psf, pdtobj, (LPCTSTR)pdfmics->lParam, pdfmics->fMask);
                break;

            case DFM_CMD_PROPERTIES:
                hr = SHLaunchPropSheet(_PropertiesThread, pdtobj, (LPCTSTR)pdfmics->lParam, NULL, _pidl);
                break;

            default:
                // This is common menu items, use the default code.
                hr = S_FALSE;
                break;
            }
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}

HRESULT CFSFolder::_CreateContextMenu(HWND hwnd, LPCIDFOLDER pidf, LPCITEMIDLIST *apidl, UINT cidl, IContextMenu **ppcm)
{
    //  we need a key for each
    //  1. UserCustomized
    //  2. default Progid
    //  3. SFA\.ext
    //  4. SFA\PerceivedType
    //  5. * or Folder
    //  6. AllFileSystemObjects
    //  (?? 7. maybe pszProvider ??)
    IAssociationArray *paa;
    CFileSysItemString fsi(pidf);
    fsi.AssocCreate(this, TRUE, IID_PPV_ARG(IAssociationArray, &paa));

    IShellFolder *psfToPass;        // May be an Aggregate...
    HRESULT hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfToPass));
    if (SUCCEEDED(hr))
    {
        DEFCONTEXTMENU dcm = {
            hwnd,
            SAFECAST(this, IContextMenuCB *),
            _pidl,
            psfToPass,
            cidl,
            apidl,
            paa,
            0,
            NULL};

        hr = CreateDefaultContextMenu(&dcm, ppcm);
        psfToPass->Release();
    }

    if (paa)
        paa->Release();

    return hr;
}

HRESULT CFileFolderIconManager_Create(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv);


HRESULT CFSFolder::GetUIObjectOf(HWND hwnd,
                                 UINT cidl,
                                 LPCITEMIDLIST *apidl,
                                 REFIID riid,
                                 UINT * /* prgfInOut */,
                                 void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    LPCIDFOLDER pidf = cidl ? _IsValidID(apidl[0]) : NULL;

    *ppv = NULL;

    if (pidf)
    {
        typedef HRESULT (CFSFolder::*PFNGETUIOBJECTOFHELPER)(HWND, LPCITEMIDLIST *, UINT, LPCIDFOLDER, REFIID, void **);

        static const struct {
            const IID *             piid;
            PFNGETUIOBJECTOFHELPER  pfnHelper;
            BOOL                    bOfflineSafe;
        } c_IIDMap[] = {
            { &IID_IContextMenu,        &CFSFolder::_GetContextMenu,        TRUE    },
            { &IID_IDataObject,         &CFSFolder::_GetDataObject,         TRUE    },
            { &IID_IDropTarget,         &CFSFolder::_GetDropTarget,         TRUE    },
            { &IID_IQueryAssociations,  &CFSFolder::_GetAssoc,              TRUE    },
            { &IID_IAssociationArray,   &CFSFolder::_GetAssoc,              TRUE    },
            { &IID_IExtractIconA,       &CFSFolder::_GetExtractIcon,        TRUE    },
            { &IID_IExtractIconW,       &CFSFolder::_GetExtractIcon,        TRUE    },
            { &IID_ICustomIconManager,  &CFSFolder::_GetCustomIconManager,  FALSE   },
            { &IID_IExtractImage,       &CFSFolder::_GetExtractImage,       FALSE   },
            { &IID_IExtractLogo,        &CFSFolder::_GetExtractLogo,        FALSE   },
            { &IID_IQueryInfo,          &CFSFolder::_GetQueryInfo,          TRUE    },
        };

        BOOL bHandled = FALSE;

        for (size_t i = 0; i < ARRAYSIZE(c_IIDMap); i++)
        {
            if (IsEqualIID(*c_IIDMap[i].piid, riid))
            {
                hr = !_IsOffline(pidf) || c_IIDMap[i].bOfflineSafe ? (this->*(c_IIDMap[i].pfnHelper))(hwnd, apidl, cidl, pidf, riid, ppv) : E_OFFLINE;
                bHandled = TRUE;
                break;
            }
        }

        if (!bHandled)
        {
            if (_IsOffline(pidf))
            {
                hr = E_OFFLINE;
            }
            else
            {
                hr = _LoadHandler(pidf, STGM_READ, NULL, riid, ppv);
            }
        }
    }
    else
    {
        if (IsEqualIID(riid, IID_IDataObject) && cidl > 0)
        {
            hr = SHCreateFileDataObject(_pidl, cidl, apidl, NULL, (IDataObject **)ppv);
        }
    }

    return hr;
}

// GetUIObjectOf() helper.
HRESULT CFSFolder::_GetContextMenu(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    return _CreateContextMenu(hwnd, pidf, apidl, cidl, (IContextMenu **)ppv);
}

// GetUIObjectOf() helper.
HRESULT CFSFolder::_GetDataObject(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    ASSERT(cidl > 0); // Sanity check.

    IDataObject *pdtInner = NULL;
    if (cidl == 1)
    {
        _LoadHandler(pidf, STGM_READ, TEXT("DataHandler"), IID_PPV_ARG(IDataObject, &pdtInner));
    }
    HRESULT hr = SHCreateFileDataObject(_pidl, cidl, apidl, pdtInner, (IDataObject **)ppv);
    if (pdtInner)
        pdtInner->Release();
    return hr;
}

// GetUIObjectOf() helper.
HRESULT CFSFolder::_GetDropTarget(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    HRESULT hr;

    CLSID clsid;
    if (_IsFolder(pidf) || (_GetJunctionClsid(pidf, &clsid) && !SHQueryShellFolderValue(&clsid, L"UseDropHandler")))
    {
        IShellFolder *psfT;
        hr = BindToObject(apidl[0], NULL, IID_PPV_ARG(IShellFolder, &psfT));
        if (SUCCEEDED(hr))
        {
            hr = psfT->CreateViewObject(hwnd, riid, ppv);
            psfT->Release();
        }
    }
    else
    {
        // old code supported absolute PIDLs here. that was bogus...
        ASSERT(ILIsEmpty(apidl[0]) || (ILFindLastID(apidl[0]) == apidl[0]));
        ASSERT(_IsFile(pidf) || _IsSimpleID(pidf));

        hr = _LoadHandler(pidf, STGM_READ, TEXT("DropHandler"), riid, ppv);
    }

    return hr;
}

// GetUIObjectOf() helper.
HRESULT CFSFolder::_GetAssoc(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    return _AssocCreate(pidf, riid, ppv);
}

// GetUIObjectOf() helper.
HRESULT CFSFolder::_GetExtractIcon(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    return _CreateDefExtIcon(pidf, riid, ppv);
}

// GetUIObjectOf() helper.
HRESULT CFSFolder::_GetCustomIconManager(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    HRESULT hr;

    if (_IsFileFolder(pidf))
    {
        TCHAR szItemPath[MAX_PATH];
        szItemPath[0] = NULL;
        hr = _GetPath(szItemPath, ARRAYSIZE(szItemPath));
        if (SUCCEEDED(hr))
        {
            // No support in ICustomIconManager for remote shares.
            if (PathIsNetworkPath(szItemPath))
            {
                hr = E_NOTIMPL;
            }
            else
            {
                hr = CFileFolderIconManager_Create(this, (LPCITEMIDLIST)pidf, riid, ppv);
            }
        }
    }
    else
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

// GetUIObjectOf() helper.
HRESULT CFSFolder::_GetExtractImage(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    //  too many people bogusly register extractors that
    //  dont work as well as ours for images
    //  we hard code our list of supported types.
    HRESULT hr = _CreateShimgvwExtractor(pidf, riid, ppv);

    if (FAILED(hr))
    {
        hr = _LoadHandler(pidf, STGM_READ, NULL, riid, ppv);
    }
    
    if (FAILED(hr) && _IsFileFolder(pidf))
    {
        // default handler type, use the IID_ as the key to open for the handler
        // if it is an image extractor, then check to see if it is a per-folder logo...
        hr = CFolderExtractImage_Create(this, (LPCITEMIDLIST)pidf, riid, ppv);
    }

    return hr;
}

// GetUIObjectOf() helper.
HRESULT CFSFolder::_GetExtractLogo(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    HRESULT hr = _LoadHandler(pidf, STGM_READ, NULL, riid, ppv);
    if (FAILED(hr) && _IsFileFolder(pidf))
    {
        // default handler type, use the IID_ as the key to open for the handler
        // if it is an image extractor, then check to see if it is a per-folder logo...
        hr = CFolderExtractImage_Create(this, (LPCITEMIDLIST)pidf, riid, ppv);
    }
    return hr;
}

// GetUIObjectOf() helper.
HRESULT CFSFolder::_GetQueryInfo(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    HRESULT hr = _IsOffline(pidf) ? E_OFFLINE : _LoadHandler(pidf, STGM_READ, NULL, riid, ppv);
    if (FAILED(hr))
    {
        // Generate infotip...

        IQueryAssociations *pqa;
        hr = GetUIObjectOf(hwnd, cidl, apidl, IID_PPV_ARG_NULL(IQueryAssociations, &pqa));
        if (SUCCEEDED(hr))
        {
            // If we are looking at a folder over a slow connection,
            // show only quickly accessible properties
            ASSOCSTR assocstr = _IsSlowPath() || _IsOffline(pidf) ? ASSOCSTR_QUICKTIP : ASSOCSTR_INFOTIP;

            WCHAR wszText[INFOTIPSIZE];
            hr = pqa->GetString(0, assocstr, NULL, wszText, (DWORD *)MAKEINTRESOURCE(ARRAYSIZE(wszText)));
            if (SUCCEEDED(hr))
            {
                hr = CreateInfoTipFromItem(SAFECAST(this, IShellFolder2 *), (LPCITEMIDLIST)pidf, wszText, riid, ppv);
                if (SUCCEEDED(hr) && _IsFileFolder(pidf))
                {
                    IUnknown *punk = (IUnknown *)*ppv;
                    *ppv = NULL;
                    WCHAR szPath[MAX_PATH];
                    hr = _GetPathForItem(pidf, szPath, ARRAYSIZE(szPath));
                    if (SUCCEEDED(hr))
                        hr = CFolderInfoTip_CreateInstance(punk, szPath, riid, ppv);
                    punk->Release();
                }
            }
            pqa->Release();
        }
    }
    return hr;
}

HRESULT CFSFolder::GetDefaultSearchGUID(GUID *pGuid)
{
    return E_NOTIMPL;
}

HRESULT CFSFolder::EnumSearches(IEnumExtraSearch **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

LPCIDFOLDER CFSFolder::_FindJunction(LPCIDFOLDER pidf)
{
    for (; pidf->cb; pidf = _Next(pidf))
    {
        if (_IsJunction(pidf))
            return pidf;        // true junction (folder.{guid} folder\desktop.ini)

        if (_IsFile(pidf))
        {
            DWORD dwFlags = _GetClassFlags(pidf);
            if (dwFlags & (SHCF_IS_BROWSABLE | SHCF_IS_SHELLEXT))
                return pidf;    // browsable file (.HTM)
        }
    }

    return NULL;
}

// return IDLIST of item just past the junction point (if there is one)
// if there's no next pointer, return NULL.

LPCITEMIDLIST CFSFolder::_FindJunctionNext(LPCIDFOLDER pidf)
{
    pidf = _FindJunction(pidf);
    if (pidf)
    {
        // cast here represents the fact that this data is opaque
        LPCITEMIDLIST pidl = (LPCITEMIDLIST)_Next(pidf);
        if (!ILIsEmpty(pidl))
            return pidl;        // first item past junction
    }
    return NULL;
}

void CFSFolder::_UpdateItem(LPCIDFOLDER pidf)
{
    LPITEMIDLIST pidlAbs = ILCombine(_pidl, (LPCITEMIDLIST)pidf);
    if (pidlAbs)
    {
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_FLUSH | SHCNF_IDLIST, pidlAbs, NULL);
        ILFree(pidlAbs);
    }
}

HRESULT CFSFolder::_SetLocalizedDisplayName(LPCIDFOLDER pidf, LPCWSTR pszName)
{
    HRESULT hr = E_FAIL;
    WCHAR sz[MAX_PATH];
    CFileSysItemString fsi(pidf);
    if (*pszName == TEXT('@') && SUCCEEDED(SHLoadIndirectString(pszName, sz, ARRAYSIZE(sz), NULL)))
    {
        TCHAR szPath[MAX_PATH];
        //
        //  this is a localized resource.  
        //  save this off as the items UI name.
        //
        if (_IsFolder(pidf))
        {
            if (SUCCEEDED(_GetPathForItem(pidf, szPath, ARRAYSIZE(szPath)))
            && SetFolderString(TRUE, szPath, _pszNetProvider, STRINI_CLASSINFO, TEXT("LocalizedResourceName"), pszName))
            {
                //  we need to insure the bits are set for MUI on upgraded users
                //  PathMakeSystemFolder(szPath);
                hr = S_OK;
            }
        }
        else
        {
            _GetPath(szPath, ARRAYSIZE(szPath));
            if (SetFolderString(TRUE, szPath, _pszNetProvider, TEXT("LocalizedFileNames"), fsi.FSName(), pszName))
                hr = S_OK;
        }
    }
    else 
    {
        if (fsi.HasResourceName())
        {
            if (*pszName)
            {
                DWORD cb = CbFromCch(lstrlen(pszName)+1);
                //  set the registry overrides
                if (S_OK == SKSetValueW(SHELLKEY_HKCU_SHELL, L"LocalizedResourceName", fsi.ResourceName(), REG_SZ, pszName, cb))
                {
                    hr = S_OK;
                }
            }
            else 
            {
                SKDeleteValue(SHELLKEY_HKCU_SHELL, L"LocalizedResourceName", fsi.ResourceName());            
                hr = S_OK;
            }
        }
    }
    
    if (SUCCEEDED(hr))
        _UpdateItem(pidf);

    return hr;
}

HRESULT CFSFolder::_NormalGetDisplayNameOf(LPCIDFOLDER pidf, STRRET *pStrRet)
{
    //
    //  WARNING - Some apps (e.g., Norton Uninstall Deluxe)
    //  don't handle STRRET_WSTR properly.  NT4's shell32
    //  returned STRRET_WSTR only if it had no choice, so these apps
    //  seemed to run just fine on NT as long as you never had any
    //  UNICODE filenames.  We must preserve the NT4 behavior or
    //  these buggy apps start blowing chunks.
    //
    //  if this is still important, we will apphack these guys
    CFileSysItemString fsi(pidf);
    if (SHGetAppCompatFlags(ACF_ANSIDISPLAYNAMES) & ACF_ANSIDISPLAYNAMES)
    {
        pStrRet->uType = STRRET_CSTR;
        SHUnicodeToAnsi(fsi.UIName(this), pStrRet->cStr, ARRAYSIZE(pStrRet->cStr));
        return S_OK;
    }
    return StringToStrRet(fsi.UIName(this), pStrRet);
}

HRESULT CFSFolder::_NormalDisplayName(LPCIDFOLDER pidf, LPTSTR psz, UINT cch)
{
    CFileSysItemString fsi(pidf);
    StrCpyN(psz, fsi.UIName(this), cch);
    return S_OK;
}

HRESULT CFSFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, LPSTRRET pStrRet)
{
    HRESULT hr = S_FALSE;
    LPCIDFOLDER pidf = _IsValidID(pidl);
    if (pidf)
    {
        TCHAR szPath[MAX_PATH];
        LPCITEMIDLIST pidlNext = _ILNext(pidl);

        if (dwFlags & SHGDN_FORPARSING)
        {
            if (dwFlags & SHGDN_INFOLDER)
            {
                _CopyName(pidf, szPath, ARRAYSIZE(szPath));
                if (dwFlags & SHGDN_FORADDRESSBAR)
                {
                    LPTSTR pszExt = PathFindCLSIDExtension(szPath, NULL);
                    if (pszExt)
                        *pszExt = 0;
                }

                if (ILIsEmpty(pidlNext))    // single level idlist
                    hr = StringToStrRet(szPath, pStrRet);
                else
                    hr = ILGetRelDisplayName(this, pStrRet, pidl, szPath, MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_BACKSLASH), dwFlags);
            }
            else
            {
                LPIDFOLDER pidfBind;
                LPCITEMIDLIST pidlRight;

                hr = _GetJunctionForBind(pidf, &pidfBind, &pidlRight);
                if (SUCCEEDED(hr))
                {
                    if (hr == S_OK)
                    {
                        IShellFolder *psfJctn;
                        hr = _Bind(NULL, pidfBind, IID_PPV_ARG(IShellFolder, &psfJctn));
                        if (SUCCEEDED(hr))
                        {
                            hr = psfJctn->GetDisplayNameOf(pidlRight, dwFlags, pStrRet);
                            psfJctn->Release();
                        }
                        ILFree((LPITEMIDLIST)pidfBind);
                    }
                    else
                    {
                        hr = _GetPathForItem(pidf, szPath, ARRAYSIZE(szPath));
                        if (SUCCEEDED(hr))
                        {
                            if (dwFlags & SHGDN_FORADDRESSBAR)
                            {
                                LPTSTR pszExt = PathFindCLSIDExtension(szPath, NULL);
                                if (pszExt)
                                    *pszExt = 0;
                            }
                            hr = StringToStrRet(szPath, pStrRet);
                        }
                    }
                }
            }
        }
        else if (_IsCSIDL(CSIDL_RECENT) && 
                 SUCCEEDED(RecentDocs_GetDisplayName((LPCITEMIDLIST)pidf, szPath, SIZECHARS(szPath))))
        {
            LPITEMIDLIST pidlRecent;
            WIN32_FIND_DATA wfd = {0};

            StrCpyN(wfd.cFileName, szPath, SIZECHARS(wfd.cFileName));

            if (SUCCEEDED(_CreateIDList(&wfd, NULL, &pidlRecent)))
            {
                hr = _NormalGetDisplayNameOf((LPCIDFOLDER)pidlRecent, pStrRet);
                ILFree(pidlRecent);
            }
                        
        }
        else
        {
            ASSERT(ILIsEmpty(pidlNext));    // this variation should be single level

            hr = _NormalGetDisplayNameOf(pidf, pStrRet);
        }
    }
    else
    {
        if (IsSelf(1, &pidl) && 
            ((dwFlags & (SHGDN_FORADDRESSBAR | SHGDN_INFOLDER | SHGDN_FORPARSING)) == SHGDN_FORPARSING))
        {
            TCHAR szPath[MAX_PATH];
            hr = _GetPath(szPath, ARRAYSIZE(szPath));
            if (SUCCEEDED(hr))
                hr = StringToStrRet(szPath, pStrRet);
        }
        else
        {
            hr = E_INVALIDARG;
            TraceMsg(TF_WARNING, "CFSFolder::GetDisplayNameOf() failing on PIDL %s", DumpPidl(pidl));
        }
    }
    return hr;
}

void DoSmartQuotes(LPTSTR pszName)
{
    LPTSTR pszFirst = StrChr(pszName, TEXT('"'));
    if (pszFirst)
    {
        LPTSTR pszSecond = StrChr(pszFirst + 1, TEXT('"'));
        if (pszSecond)
        {
            if (NULL == StrChr(pszSecond + 1, TEXT('"')))
            {
                *pszFirst  = 0x201C;    // left double quotation
                *pszSecond = 0x201D;    // right double quotation
            }
        }
    }
}

HRESULT _PrepareNameForRename(LPTSTR pszName)
{
    if (*pszName)
    {
        HRESULT hr = _CheckPortName(pszName);
        if (SUCCEEDED(hr))
        {
            DoSmartQuotes(pszName);
        }
        return hr;
    }
    // avoid a bogus error msg with blank name (treat as user cancel)
    return HRESULT_FROM_WIN32(ERROR_CANCELLED);
}

HRESULT CFSFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, 
                             DWORD dwFlags, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_INVALIDARG;

    if (ppidl) 
        *ppidl = NULL;

    LPCIDFOLDER pidf = _IsValidID(pidl);
    if (pidf)
    {
        CFileSysItemString fsi(pidf);
        TCHAR szNewName[MAX_PATH];

        SHUnicodeToTChar(pszName, szNewName, ARRAYSIZE(szNewName));

        PathRemoveBlanks(szNewName);    // leading and trailing blanks

        if (dwFlags == SHGDN_NORMAL || dwFlags == SHGDN_INFOLDER)
        {
            hr = _SetLocalizedDisplayName(pidf, pszName);

            if (SUCCEEDED(hr))
            {
                // Return the new pidl if ppidl is specified.
                if (ppidl)
                    return _CreateIDListFromName(fsi.FSName(), -1, NULL, ppidl);
            }
            else if (*pszName == TEXT('@') && PathParseIconLocation(szNewName + 1))
            {
                // this is a localized string (eg "@C:\WINNT\System32\shell32.dll,-3")
                // so do not go on and try to call SHRenameFileEx 
                return hr;
            }
        }

        if (FAILED(hr))
        {
            hr = _PrepareNameForRename(szNewName);
            if (SUCCEEDED(hr))
            {
                TCHAR szDir[MAX_PATH], szOldName[MAX_PATH];
                _CopyName(pidf, szOldName, ARRAYSIZE(szOldName));

                // If the extension is hidden
                if (!(dwFlags & SHGDN_FORPARSING) && !fsi.ShowExtension(_DefaultShowExt()))
                {
                    // copy it from the old name
                    StrCatBuff(szNewName, PathFindExtension(szOldName), ARRAYSIZE(szNewName));
                }

                hr = _GetPath(szDir, ARRAYSIZE(szDir));
                if (SUCCEEDED(hr))
                {
                    UINT cchDirLen = lstrlen(szDir);

                    // There are cases where the old name exceeded the maximum path, which
                    // would give a bogus error message.  To avoid this we should check for
                    // this case and see if using the short name for the file might get
                    // around this...
                    //
                    if (cchDirLen + lstrlen(szOldName) + 2 > MAX_PATH)
                    {
                        if (cchDirLen + lstrlenA(fsi.AltName()) + 2 <= MAX_PATH)
                            SHAnsiToTChar(fsi.AltName(), szOldName, ARRAYSIZE(szOldName));
                    }

                    // do a binary compare, locale insenstive compare to avoid mappings of
                    // single chars into multiple and the reverse. specifically german
                    // sharp-S and "ss"

                    if (StrCmpC(szOldName, szNewName) == 0)
                    {
                        // when the before and after strings are identical we're okay with that.
                        // SHRenameFileEx would return -1 in that case -- we check here to save
                        // some stack.
                        hr = S_OK;
                    }
                    else
                    {
                        //  We need to impl ::SetSite() and pass it to SHRenameFile
                        //  to go modal if we display UI.

                        int iRes = SHRenameFileEx(hwnd, NULL, szDir, szOldName, szNewName);
                        hr = HRESULT_FROM_WIN32(iRes);
                    }
                    if (SUCCEEDED(hr) && ppidl)
                    {
                        // Return the new pidl if ppidl is specified.
                        hr = _CreateIDListFromName(szNewName, -1, NULL, ppidl);
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT CFSFolder::_FindDataFromIDFolder(LPCIDFOLDER pidf, WIN32_FIND_DATAW *pfd, BOOL fAllowSimplePid)
{
    HRESULT hr;

    CFileSysItemString fsi(pidf);
    if (!fAllowSimplePid)
    {
        hr = fsi.GetFindData(pfd);
    }
    else
    {
        hr = fsi.GetFindDataSimple(pfd);
    }

    return hr;
}


/***

To avoid registry explosion, each pidl is passed to each handler.

    HKCR\Folder\ColumnHandlers
      <clsid>
        "" = "Docfile handler"
      <clsid>
        "" = "Imagefile handler"

***/

void CFSFolder::_DestroyColHandlers()
{
    if (_hdsaColHandlers)
    {
        for (int i = 0; i < DSA_GetItemCount(_hdsaColHandlers); i++)
        {
            COLUMNLISTENTRY *pcle = (COLUMNLISTENTRY *)DSA_GetItemPtr(_hdsaColHandlers, i);
            if (pcle->pcp)
                pcle->pcp->Release();
        }
        DSA_Destroy(_hdsaColHandlers);
        _hdsaColHandlers = NULL;
    }
}

// returns the n'th handler for a given column
BOOL CFSFolder::_FindColHandler(UINT iCol, UINT iN, COLUMNLISTENTRY *pcle)
{
    for (int i = 0; i < DSA_GetItemCount(_hdsaColHandlers); i++)
    {
        COLUMNLISTENTRY *pcleWalk = (COLUMNLISTENTRY *)DSA_GetItemPtr(_hdsaColHandlers, i);
        if (pcleWalk->iColumnId == iCol)
        {
            if (iN-- == 0)
            {
                *pcle = *pcleWalk;
                return TRUE;
            }
        }
    }
    return FALSE;
}

HRESULT CFSFolder::_LoadColumnHandlers()
{
    //  Have we been here?
    if (NULL != _hdsaColHandlers)
        return S_OK;   // nothing to do.
    
    ASSERT(0 == _dwColCount);

    SHCOLUMNINIT shci = {0};
    //  retrieve folder path for provider init
    HRESULT hr = _GetPathForItem(NULL, shci.wszFolder, ARRAYSIZE(shci.wszFolder));
    if (SUCCEEDED(hr))
    {
        _hdsaColHandlers = DSA_Create(sizeof(COLUMNLISTENTRY), 5);
        if (_hdsaColHandlers)
        {        
            int iUniqueColumnCount = 0;
            HKEY hkCH;
            // Enumerate HKCR\Folder\Shellex\ColumnProviders
            // note: this really should have been "Directory", not "Folder"
            if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Folder\\shellex\\ColumnHandlers"), &hkCH))
            {
                TCHAR szHandlerCLSID[GUIDSTR_MAX];
                int iHandler = 0;

                while (ERROR_SUCCESS == RegEnumKey(hkCH, iHandler++, szHandlerCLSID, ARRAYSIZE(szHandlerCLSID)))
                {
                    CLSID clsid;
                    IColumnProvider *pcp;

                    if (SUCCEEDED(SHCLSIDFromString(szHandlerCLSID, &clsid)) && 
                        SUCCEEDED(SHExtCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IColumnProvider, &pcp))))
                    {
                        if (SUCCEEDED(pcp->Initialize(&shci)))
                        {
                            int iCol = 0;
                            COLUMNLISTENTRY cle;

                            cle.pcp = pcp;
                            while (S_OK == pcp->GetColumnInfo(iCol++, &cle.shci))
                            {
                                cle.pcp->AddRef();
                                cle.iColumnId = iUniqueColumnCount++;

                                // Check if there's already a handler for this column ID,
                                for (int i = 0; i < DSA_GetItemCount(_hdsaColHandlers); i++)
                                {
                                    COLUMNLISTENTRY *pcleLoop = (COLUMNLISTENTRY *)DSA_GetItemPtr(_hdsaColHandlers, i);
                                    if (IsEqualSCID(pcleLoop->shci.scid, cle.shci.scid))
                                    {
                                        cle.iColumnId = pcleLoop->iColumnId;    // set the iColumnId to the same as the first one
                                        iUniqueColumnCount--; // so our count stays right
                                        break;
                                    }
                                }
                                DSA_AppendItem(_hdsaColHandlers, &cle);
                            }
                        }
                        pcp->Release();
                    }
                }
                RegCloseKey(hkCH);
            }

            // Sanity check
            if (!DSA_GetItemCount(_hdsaColHandlers))
            {
                // DSA_Destroy(*phdsa);
                ASSERT(iUniqueColumnCount==0);
                iUniqueColumnCount = 0;
            }
            _dwColCount = (DWORD)iUniqueColumnCount;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

//  Initializes a SHCOLUMNDATA block.
HRESULT CFSFolder::_InitColData(LPCIDFOLDER pidf, SHCOLUMNDATA* pscd)
{
    ZeroMemory(pscd, sizeof(*pscd));

    HRESULT hr = _GetPathForItem(pidf, pscd->wszFile, ARRAYSIZE(pscd->wszFile));
    if (SUCCEEDED(hr))
    {
        pscd->pwszExt = PathFindExtensionW(pscd->wszFile);
        pscd->dwFileAttributes = pidf->wAttrs;

        if (FILE_ATTRIBUTE_OFFLINE & pscd->dwFileAttributes)
            hr = E_FAIL;
        else if (_bUpdateExtendedCols)
        {
            // set the dwFlags member to tell the col handler to
            // not take data from it's cache
            pscd->dwFlags = SHCDF_UPDATEITEM;
            _bUpdateExtendedCols = FALSE;   // only do this once!
        }
    }
    return hr;
}

// Note:
//  Setting _tbOfflineCSC = TRIBIT_UNDEFINED will retest the connection (good for a refresh).
//  Setting _tbOfflineCSC = { other } will use a little cache hooey for perf.
//
// Return:
//  TRUE    pidl is offline
//  FALSE   otherwise
//
BOOL CFSFolder::_IsOfflineCSC(LPCIDFOLDER pidf)
{
    TCHAR szPath[MAX_PATH];

    // Update local cached answer for _pidl (folder).
    if (_tbOfflineCSC == TRIBIT_UNDEFINED)
    {
        if (SUCCEEDED(_GetPath(szPath, ARRAYSIZE(szPath))) && _IsOfflineCSC(szPath))
            _tbOfflineCSC = TRIBIT_TRUE;
        else
            _tbOfflineCSC = TRIBIT_FALSE;
    }
    ASSERT(_tbOfflineCSC != TRIBIT_UNDEFINED);

    // Calculate answer for pidl.
    BOOL bIsOffline;
    if (_tbOfflineCSC == TRIBIT_TRUE)
        bIsOffline = TRUE;
    else
    {
        bIsOffline = _IsFolder(pidf) && SUCCEEDED(_GetPathForItem(pidf, szPath, ARRAYSIZE(szPath))) && _IsOfflineCSC(szPath);
    }

    return bIsOffline;
}

// Make sure we have a UNC \\server\share path.  Do this before checking
// whether CSC is enabled, to avoid loading CSCDLL.DLL unless absolutely
// necessary.

BOOL CFSFolder::_IsOfflineCSC(LPCTSTR pszPath)
{
    BOOL bUNC = FALSE;
    TCHAR szUNC[MAX_PATH];
    szUNC[0] = 0;

    if (PathIsUNC(pszPath))
    {
        StrCpyN(szUNC, pszPath, ARRAYSIZE(szUNC));
    }
    else if (pszPath[1] == TEXT(':'))
    {
        TCHAR szLocalName[3] = { pszPath[0], pszPath[1], TEXT('\0') };

        // Call GetDriveType() before WNetGetConnection(), to
        // avoid loading MPR.DLL unless absolutely necessary.
        if (DRIVE_REMOTE == GetDriveType(szLocalName))
        {
            // ignore return, szUNC filled in on success
            DWORD cch = ARRAYSIZE(szUNC);
            WNetGetConnection(szLocalName, szUNC, &cch);
        }
    }

    return szUNC[0] && 
           PathStripToRoot(szUNC) &&
           (GetOfflineShareStatus(szUNC) == OFS_OFFLINE);
}

HRESULT CFSFolder::_ExtendedColumn(LPCIDFOLDER pidf, UINT iColumn, SHELLDETAILS *pDetails)
{
    HRESULT hr = _LoadColumnHandlers();
    if (SUCCEEDED(hr))
    {
        if (iColumn < _dwColCount)
        {
            if (NULL == pidf)
            {
                COLUMNLISTENTRY cle;
                if (_FindColHandler(iColumn, 0, &cle))
                {
                    pDetails->fmt = cle.shci.fmt;
                    pDetails->cxChar = cle.shci.cChars;
                    hr = StringToStrRet(cle.shci.wszTitle, &pDetails->str);
                }
                else
                {
                    hr = E_NOTIMPL;
                }
            }
            else
            {
                SHCOLUMNDATA shcd;
                hr = _InitColData(pidf, &shcd);
                if (SUCCEEDED(hr))
                {
                    hr = E_FAIL;    // loop below will try to reset this

                    // loop through all the column providers, breaking when one succeeds
                    COLUMNLISTENTRY cle;
                    for (int iTry = 0; _FindColHandler(iColumn, iTry, &cle); iTry++)
                    {
                        VARIANT var = {0};

                        hr = cle.pcp->GetItemData(&cle.shci.scid, &shcd, &var);
                        if (SUCCEEDED(hr))
                        {
                            if (S_OK == hr)
                            {
                                PROPERTYUI_FORMAT_FLAGS puiff = PUIFFDF_DEFAULT;
                                if (pDetails->fmt == LVCFMT_RIGHT_TO_LEFT)
                                {
                                    puiff = PUIFFDF_RIGHTTOLEFT;
                                }

                                TCHAR szTemp[MAX_PATH];
                                hr = SHFormatForDisplay(cle.shci.scid.fmtid,
                                                        cle.shci.scid.pid,
                                                        (PROPVARIANT*)&var,
                                                        puiff,
                                                        szTemp,
                                                        ARRAYSIZE(szTemp));
                                if (SUCCEEDED(hr))
                                {
                                    hr = StringToStrRet(szTemp, &pDetails->str);
                                }

                                VariantClear(&var);
                                break;
                            }
                            VariantClear(&var);
                        }
                    }

                    // if we failed to find a value here return empty success so we don't
                    // endlessly pester all column handlers for this column/item.
                    if (S_OK != hr)
                    {
                        pDetails->str.uType = STRRET_CSTR;
                        pDetails->str.cStr[0] = 0;
                        hr = S_FALSE; 
                    }
                }
            }
        }
        else
            hr = E_NOTIMPL; // the bogus return value defview expects...
    }

    return hr;
}

HRESULT CFSFolder::_CompareExtendedProp(int iColumn, LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    HRESULT hr = _LoadColumnHandlers();
    if (SUCCEEDED(hr))
    {
        if ((DWORD)iColumn < _dwColCount)
        {
            COLUMNLISTENTRY cle;
            if (_FindColHandler(iColumn, 0, &cle))
            {
                int iRet = CompareBySCID(this, &cle.shci.scid, (LPCITEMIDLIST)pidf1, (LPCITEMIDLIST)pidf2);
                hr = ResultFromShort(iRet);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CFSFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
{
    LPCIDFOLDER pidf = _IsValidID(pidl);

    pDetails->str.uType = STRRET_CSTR;
    pDetails->str.cStr[0] = 0;

    if (iColumn >= ARRAYSIZE(c_fs_cols))
    {
        if (_IsOffline(pidf))
        {
            return E_OFFLINE;
        }
        else
        {
            return _ExtendedColumn(pidf, iColumn - ARRAYSIZE(c_fs_cols), pDetails);
        }
    }

    if (!pidf)
    {
        return GetDetailsOfInfo(c_fs_cols, ARRAYSIZE(c_fs_cols), iColumn, pDetails);
    }

    TCHAR szTemp[MAX_PATH];
    szTemp[0] = 0;

    switch (iColumn)
    {
    case FS_ICOL_NAME:
        _NormalDisplayName(pidf, szTemp, ARRAYSIZE(szTemp));
        break;

    case FS_ICOL_SIZE:
        if (!_IsFolder(pidf))
        {
            ULONGLONG cbSize = _Size(pidf);
            StrFormatKBSize(cbSize, szTemp, ARRAYSIZE(szTemp));
        }
        break;

    case FS_ICOL_TYPE:
        _GetTypeNameBuf(pidf, szTemp, ARRAYSIZE(szTemp));
        break;

    case FS_ICOL_WRITETIME:
        DosTimeToDateTimeString(pidf->dateModified, pidf->timeModified, szTemp, ARRAYSIZE(szTemp), pDetails->fmt & LVCFMT_DIRECTION_MASK);
        break;

    case FS_ICOL_CREATETIME:
    case FS_ICOL_ACCESSTIME:
        {
            WIN32_FIND_DATAW wfd;
            if (SUCCEEDED(_FindDataFromIDFolder(pidf, &wfd, FALSE)))
            {
                DWORD dwFlags = FDTF_DEFAULT;

                switch (pDetails->fmt)
                {
                case LVCFMT_LEFT_TO_RIGHT:
                    dwFlags |= FDTF_LTRDATE;
                    break;

                case LVCFMT_RIGHT_TO_LEFT:
                    dwFlags |= FDTF_RTLDATE;
                    break;
                }
                FILETIME ft = (iColumn == FS_ICOL_CREATETIME) ? wfd.ftCreationTime : wfd.ftLastAccessTime;
                SHFormatDateTime(&ft, &dwFlags, szTemp, ARRAYSIZE(szTemp));
            }
        }
        break;

    case FS_ICOL_ATTRIB:
        BuildAttributeString(pidf->wAttrs, szTemp, ARRAYSIZE(szTemp));
        break;

    case FS_ICOL_CSC_STATUS:
        LoadString(HINST_THISDLL, _IsOfflineCSC(pidf) ? IDS_CSC_STATUS_OFFLINE : IDS_CSC_STATUS_ONLINE, szTemp, ARRAYSIZE(szTemp)); 
        break;
    }
    return StringToStrRet(szTemp, &pDetails->str);
}

HRESULT CFSFolder::_GetIntroText(LPCIDFOLDER pidf, WCHAR* pwszIntroText, UINT cchIntroText)
{
    HRESULT hr = E_FAIL;
    
    TCHAR szPath[MAX_PATH];
    if (SUCCEEDED(_GetPathForItem(pidf, szPath, ARRAYSIZE(szPath))))
    {
        // Keep the order in csidlIntroText and IntroTextCSIDLFolders, the same
        static const int csidlIntroText[] = {
            CSIDL_STARTMENU,
            CSIDL_COMMON_DOCUMENTS,
            CSIDL_COMMON_PICTURES,
            CSIDL_COMMON_MUSIC
        };
        UINT csidl = GetSpecialFolderID(szPath, csidlIntroText, ARRAYSIZE(csidlIntroText));         
        if (csidl != -1)
        {
            // Keep the order in csidlIntroText and IntroTextCSIDLFolders, the same
            static struct
            {
                UINT csidl;
                UINT resid;
            } IntroTextCSIDLFolders[] = { {CSIDL_STARTMENU,         IDS_INTRO_STARTMENU},
                                          {CSIDL_COMMON_DOCUMENTS,  IDS_INTRO_SHAREDDOCS},
                                          {CSIDL_COMMON_PICTURES,   IDS_INTRO_SHAREDPICTURES},
                                          {CSIDL_COMMON_MUSIC,      IDS_INTRO_SHAREDMUSIC} };

            UINT residIntroText = 0;
            for (int i = 0; i < ARRAYSIZE(IntroTextCSIDLFolders); i++)
            {
                if (IntroTextCSIDLFolders[i].csidl == csidl)
                {
                    residIntroText = IntroTextCSIDLFolders[i].resid;
                    break;
                }
            }
            
            if (residIntroText)
            {
                if (LoadString(HINST_THISDLL, residIntroText, pwszIntroText, cchIntroText))
                {
                    hr = S_OK;
                }
            }
        }
    }
    return hr;
}

DEFINE_SCID(SCID_HTMLINFOTIPFILE, PSGUID_MISC, PID_HTMLINFOTIPFILE);

BOOL GetShellClassInfoHTMLInfoTipFile(LPCTSTR pszPath, LPTSTR pszBuffer, DWORD cchBuffer)
{
    HRESULT hr;

    TCHAR szHTMLInfoTipFile[MAX_PATH];
    if (GetShellClassInfo(pszPath, TEXT("HTMLInfoTipFile"), szHTMLInfoTipFile, ARRAYSIZE(szHTMLInfoTipFile)))
    {
        LPTSTR psz = szHTMLInfoTipFile;

        if (StrCmpNI(TEXT("file://"), psz, 7) == 0) // ARRAYSIZE(TEXT("file://"))
        {
            psz += 7;   // ARRAYSIZE(TEXT("file://"))
        }

        if (NULL != PathCombine(psz, pszPath, psz))
        {
            hr = StringCchCopy(pszBuffer, cchBuffer, psz);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}


// These next functions are for the shell OM script support

HRESULT CFSFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    BOOL fFound;
    HRESULT hr = AssocGetDetailsOfSCID(this, pidl, pscid, pv, &fFound);
    LPCIDFOLDER pidf = _IsValidID(pidl);
    if (FAILED(hr) && !fFound && pidf)
    {
        typedef HRESULT (CFSFolder::*PFNGETDETAILSEXHELPER)(LPCIDFOLDER, LPCSHCOLUMNID, VARIANT *);

        static const struct {
            LPCSHCOLUMNID           pscid;
            PFNGETDETAILSEXHELPER   pfnHelper;
            BOOL                    bOfflineSafe;
        } c_SCIDMap[] = {
            { &SCID_FINDDATA,               &CFSFolder::_GetFindData,               TRUE    },
            { &SCID_SIZE,                   &CFSFolder::_GetSize,                   TRUE    },
            { &SCID_FREESPACE,              &CFSFolder::_GetFreeSpace,              TRUE    },
            { &SCID_WRITETIME,              &CFSFolder::_GetLastWriteTime,          TRUE    },
            { &SCID_CREATETIME,             &CFSFolder::_GetCreateTime,             TRUE    },
            { &SCID_ACCESSTIME,             &CFSFolder::_GetLastAccessTime,         TRUE    },
            { &SCID_DIRECTORY,              &CFSFolder::_GetDirectory,              TRUE    },
            { &SCID_ATTRIBUTES_DESCRIPTION, &CFSFolder::_GetAttributesDescription,  TRUE    },
            { &SCID_DESCRIPTIONID,          &CFSFolder::_GetDescriptionId,          TRUE    },
            { &SCID_LINKTARGET,             &CFSFolder::_GetLinkTarget,             TRUE    },
            { &SCID_CSC_STATUS,             &CFSFolder::_GetCSCStatus,              TRUE    },
            { &SCID_COMPUTERNAME,           &CFSFolder::_GetComputerName,           TRUE    },
            { &SCID_NETWORKLOCATION,        &CFSFolder::_GetNetworkLocation,        TRUE    },
            { &SCID_Comment,                &CFSFolder::_GetInfotip,                TRUE    },
            { &SCID_HTMLINFOTIPFILE,        &CFSFolder::_GetHtmlInfotipFile,        FALSE   },
            { &SCID_FolderIntroText,        &CFSFolder::_GetFolderIntroText,        TRUE    },
        };

        BOOL bHandled = FALSE;

        for (size_t i = 0; i < ARRAYSIZE(c_SCIDMap); i++)
        {
            if (IsEqualSCID(*c_SCIDMap[i].pscid, *pscid))
            {
                if (!_IsOffline(pidf) || c_SCIDMap[i].bOfflineSafe)
                {
                    hr = (this->*(c_SCIDMap[i].pfnHelper))(pidf, pscid, pv);
                    bHandled = SUCCEEDED(hr);
                }
                else
                {
                    hr = E_OFFLINE;
                    bHandled = TRUE;
                }
                break;
            }
        }

        if (!bHandled) // defer to column handlers
        {
            int iCol = FindSCID(c_fs_cols, ARRAYSIZE(c_fs_cols), pscid);
            if (iCol >= 0)
            {
                SHELLDETAILS sd;
                hr = GetDetailsOf(pidl, iCol, &sd); // _IsOffline() aware
                if (SUCCEEDED(hr))
                {
                    hr = InitVariantFromStrRet(&sd.str, pidl, pv);
                }
            }
            else
            {
                if (_IsOffline(pidf))
                {
                    hr = E_OFFLINE;
                }
                else
                {
                    hr = _LoadColumnHandlers();
                    if (SUCCEEDED(hr))
                    {
                        hr = E_FAIL;
                        for (int i = 0; i < DSA_GetItemCount(_hdsaColHandlers); i++)
                        {
                            COLUMNLISTENTRY *pcle = (COLUMNLISTENTRY *)DSA_GetItemPtr(_hdsaColHandlers, i);

                            if (IsEqualSCID(*pscid, pcle->shci.scid))
                            {
                                SHCOLUMNDATA shcd;
                                hr = _InitColData(pidf, &shcd);
                                if (SUCCEEDED(hr))
                                {
                                    hr = pcle->pcp->GetItemData(pscid, &shcd, pv);
                                    if (S_OK == hr)
                                        break;
                                    else if (SUCCEEDED(hr))
                                        VariantClear(pv);
                                }
                                else
                                    break;
                            }
                        }
                    }
                }
            }
        }
    }

    return hr;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetFindData(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    WIN32_FIND_DATAW wfd;
    HRESULT hr = _FindDataFromIDFolder(pidf, &wfd, TRUE);
    if (SUCCEEDED(hr))
    {
        hr = InitVariantFromBuffer(pv, &wfd, sizeof(wfd));
    }
    return hr;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetDescriptionId(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    SHDESCRIPTIONID did = {0};
    switch (((SIL_GetType((LPCITEMIDLIST)pidf) & SHID_TYPEMASK) & ~(SHID_FS_UNICODE | SHID_FS_COMMONITEM)) | SHID_FS)
    {
    case SHID_FS_FILE:      did.dwDescriptionId = SHDID_FS_FILE;      break;
    case SHID_FS_DIRECTORY: did.dwDescriptionId = SHDID_FS_DIRECTORY; break;
    default:                did.dwDescriptionId = SHDID_FS_OTHER;     break;
    }
    _GetJunctionClsid(pidf, &did.clsid);

    return InitVariantFromBuffer(pv, &did, sizeof(did));
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetFolderIntroText(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    WCHAR wszIntroText[INFOTIPSIZE];
    HRESULT hr = _GetIntroText(pidf, wszIntroText, ARRAYSIZE(wszIntroText));
    if (SUCCEEDED(hr))
    {
        hr = InitVariantFromStr(pv, wszIntroText);
    }
    return hr;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetSize(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    TCHAR szMountPoint[MAX_PATH];

    // In case we fail
    pv->ullVal = 0;
    pv->vt = VT_UI8;

    if (_GetMountingPointInfo(pidf, szMountPoint, ARRAYSIZE(szMountPoint)))
    {
        ULARGE_INTEGER uliFreeToCaller, uliTotal, uliTotalFree;

        if (SHGetDiskFreeSpaceExW(szMountPoint, &uliFreeToCaller, &uliTotal, &uliTotalFree))
        {
            pv->ullVal = uliTotal.QuadPart;
        }
    }
    else
    {
        pv->ullVal = _Size(pidf);   // note, size for folder is 0
        pv->vt = VT_UI8;
    }

    return S_OK;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetFreeSpace(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    HRESULT hr = E_FAIL;

    TCHAR szMountPoint[MAX_PATH];
    if (_GetMountingPointInfo(pidf, szMountPoint, ARRAYSIZE(szMountPoint)))
    {
        ULARGE_INTEGER uliFreeToCaller, uliTotal, uliTotalFree;

        if (SHGetDiskFreeSpaceExW(szMountPoint, &uliFreeToCaller, &uliTotal, &uliTotalFree))
        {
            pv->ullVal = uliFreeToCaller.QuadPart;
            pv->vt = VT_UI8;
            hr = S_OK;
        }
    }

    return hr;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetLastWriteTime(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    WIN32_FIND_DATAW wfd;
    HRESULT hr = _FindDataFromIDFolder(pidf, &wfd, FALSE);
    if (SUCCEEDED(hr))
    {
        hr = InitVariantFromFileTime(&wfd.ftLastWriteTime, pv);
    }
    return hr;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetCreateTime(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    WIN32_FIND_DATAW wfd;
    HRESULT hr = _FindDataFromIDFolder(pidf, &wfd, FALSE);
    if (SUCCEEDED(hr))
    {
        hr = InitVariantFromFileTime(&wfd.ftCreationTime, pv);
    }
    return hr;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetLastAccessTime(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    WIN32_FIND_DATAW wfd;
    HRESULT hr = _FindDataFromIDFolder(pidf, &wfd, FALSE);
    if (SUCCEEDED(hr))
    {
        hr = InitVariantFromFileTime(&wfd.ftLastAccessTime, pv);
    }
    return hr;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetDirectory(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    TCHAR szTemp[MAX_PATH];
    HRESULT hr = _GetPath(szTemp, ARRAYSIZE(szTemp));
    if (SUCCEEDED(hr))
    {
        hr = InitVariantFromStr(pv, szTemp);
    }
    return hr;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetInfotip(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    HRESULT hr = E_FAIL;

    if (_IsSystemFolder(pidf))
    {
        WCHAR wszPath[MAX_PATH];
        hr = _GetPathForItem(pidf, wszPath, ARRAYSIZE(wszPath));
        if (SUCCEEDED(hr))
        {
            WCHAR wszInfotip[INFOTIPSIZE];
            hr = GetShellClassInfoInfoTip(wszPath, wszInfotip, ARRAYSIZE(wszInfotip));
            if (SUCCEEDED(hr))
            {
                hr = InitVariantFromStr(pv, wszInfotip);
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetHtmlInfotipFile(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    HRESULT hr = E_FAIL;

    if (_IsSystemFolder(pidf))
    {
        WCHAR wszPath[MAX_PATH];
        hr = _GetPathForItem(pidf, wszPath, ARRAYSIZE(wszPath));
        if (SUCCEEDED(hr))
        {
            WCHAR wszFilePath[MAX_PATH];
            if (GetShellClassInfoHTMLInfoTipFile(wszPath, wszFilePath, ARRAYSIZE(wszFilePath)))
            {
                hr = InitVariantFromStr(pv, wszFilePath);
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetAttributesDescription(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    static WCHAR szR[32] = {0}; // read-only
    static WCHAR szH[32] = {0}; // hidden
    static WCHAR szS[32] = {0}; // system
    static WCHAR szC[32] = {0}; // compressed
    static WCHAR szE[32] = {0}; // encrypted
    static WCHAR szO[32] = {0}; // offline
    WCHAR szAttributes[256] = {0};
    size_t cchAttributes = ARRAYSIZE(szAttributes);
    BOOL bIsFolder = _IsFolder(pidf);

    //
    // Initialize cached values once 'n only once.
    //

    if (!szR[0])
    {
        ASSERT(!szH[0] && !szS[0] && !szC[0] && !szE[0] && !szO[0]);
        LoadString(HINST_THISDLL, IDS_ATTRIBUTE_READONLY,   szR, ARRAYSIZE(szR));
        LoadString(HINST_THISDLL, IDS_ATTRIBUTE_HIDDEN,     szH, ARRAYSIZE(szH));
        LoadString(HINST_THISDLL, IDS_ATTRIBUTE_SYSTEM,     szS, ARRAYSIZE(szS));
        LoadString(HINST_THISDLL, IDS_ATTRIBUTE_COMPRESSED, szC, ARRAYSIZE(szC));
        LoadString(HINST_THISDLL, IDS_ATTRIBUTE_ENCRYPTED,  szE, ARRAYSIZE(szE));
        LoadString(HINST_THISDLL, IDS_ATTRIBUTE_OFFLINE,    szO, ARRAYSIZE(szO));
    }
    else
    {
        ASSERT(szH[0] && szS[0] && szC[0] && szE[0] && szO[0]);
    }

    //
    // Create attribute description string.
    //

    // read-only
    if ((pidf->wAttrs & FILE_ATTRIBUTE_READONLY) && !bIsFolder)
        _GetAttributesDescriptionBuilder(szAttributes, cchAttributes, szR);

    // hidden
    if (pidf->wAttrs & FILE_ATTRIBUTE_HIDDEN)
        _GetAttributesDescriptionBuilder(szAttributes, cchAttributes, szH);

    // system
    if ((pidf->wAttrs & FILE_ATTRIBUTE_SYSTEM) && !bIsFolder)
        _GetAttributesDescriptionBuilder(szAttributes, cchAttributes, szS);

    // archive
    //  By design, archive is not exposed as an attribute description.  It is
    //  used by "backup applications" and in general is a loose convention no
    //  one really cares about (chrisg).  The decision to hide archive stems
    //  from a desire to keep the Details pane free of useless gargabe.  Note
    //  that in Windows 2000, archive was not exposed through the web view.

    // compressed
    if (pidf->wAttrs & FILE_ATTRIBUTE_COMPRESSED)
        _GetAttributesDescriptionBuilder(szAttributes, cchAttributes, szC);

    // encrypted
    if (pidf->wAttrs & FILE_ATTRIBUTE_ENCRYPTED)
        _GetAttributesDescriptionBuilder(szAttributes, cchAttributes, szE);

    // offline
    if (pidf->wAttrs & FILE_ATTRIBUTE_OFFLINE)
        _GetAttributesDescriptionBuilder(szAttributes, cchAttributes, szO);

    return InitVariantFromStr(pv, szAttributes);
}
HRESULT CFSFolder::_GetAttributesDescriptionBuilder(LPWSTR szAttributes, size_t cchAttributes, LPWSTR szAttribute)
{
    static WCHAR szDelimiter[4] = {0};

    // Initialize cached delimiter once 'n only once.
    if (!szDelimiter[0])
    {
        LoadString(HINST_THISDLL, IDS_COMMASPACE, szDelimiter, ARRAYSIZE(szDelimiter));
    }

    // Build attribute description.
    if (!szAttributes[0])
    {
        StrNCpy(szAttributes, szAttribute, cchAttributes);
    }
    else
    {
        StrCatBuff(szAttributes, szDelimiter, cchAttributes);
        StrCatBuff(szAttributes, szAttribute, cchAttributes);
    }

    return S_OK;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetLinkTarget(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    IShellLink *psl;
    HRESULT hr = GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&pidf, IID_PPV_ARG_NULL(IShellLink, &psl));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlTarget;
        hr = psl->GetIDList(&pidlTarget);
        if (SUCCEEDED(hr))
        {
            WCHAR szPath[MAX_PATH];
            hr = SHGetNameAndFlags(pidlTarget, SHGDN_FORADDRESSBAR | SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL);
            if (SUCCEEDED(hr))
            {
                hr = InitVariantFromStr(pv, szPath);
            }
            ILFree(pidlTarget);
        }
        psl->Release();
    }
    return hr;
}


// GetDetailsEx() helper.
HRESULT CFSFolder::_GetNetworkLocation(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST)pidf;

    IShellLink *psl;
    HRESULT hr = GetUIObjectOf(NULL, 1, &pidl, IID_PPV_ARG_NULL(IShellLink, &psl));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlTarget;
        hr = psl->GetIDList(&pidlTarget);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            hr = SHGetNameAndFlags(pidlTarget, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL);
            if (SUCCEEDED(hr))
            {
                DWORD dwZone;
                hr = GetZoneFromUrl(szPath, NULL, &dwZone);
                if (SUCCEEDED(hr))
                {
                    TCHAR szBuffer[MAX_PATH];
                    switch (dwZone)
                    {
                        case URLZONE_LOCAL_MACHINE:
                        case URLZONE_INTRANET:
                           LoadString(g_hinst, IDS_NETLOC_LOCALNETWORK, szBuffer, ARRAYSIZE(szBuffer));
                           hr = InitVariantFromStr(pv, szBuffer);
                           break;

                        case URLZONE_INTERNET:
                           LoadString(g_hinst, IDS_NETLOC_INTERNET, szBuffer, ARRAYSIZE(szBuffer));
                           hr = InitVariantFromStr(pv, szBuffer);
                           break;

                        default:
                           hr = S_FALSE;
                           break;
                    }
                }
            }
            ILFree(pidlTarget);
        }       
        psl->Release();
    }
    return hr;
}

// GetDetailsEx() helper.
HRESULT CFSFolder::_GetComputerName(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    LPCITEMIDLIST pidl = (LPCITEMIDLIST)pidf;

    IShellLink *psl;
    HRESULT hr = GetUIObjectOf(NULL, 1, &pidl, IID_PPV_ARG_NULL(IShellLink, &psl));
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlTarget;
        hr = psl->GetIDList(&pidlTarget);
        if (SUCCEEDED(hr))
        {
            WCHAR szPath[MAX_PATH];
            if (SUCCEEDED(SHGetNameAndFlags(pidlTarget, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
            {
                if (PathIsURL(szPath))
                {
                    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH + 1];

                    URL_COMPONENTS urlComps = {0};
                    urlComps.dwStructSize = sizeof(urlComps);
                    urlComps.lpszHostName = szServer;
                    urlComps.dwHostNameLength = ARRAYSIZE(szServer);

                    BOOL fResult = InternetCrackUrl(szPath, 0, ICU_DECODE, &urlComps);
                    if (fResult)
                    {
                        hr = InitVariantFromStr(pv, szServer);   
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
                else if (PathIsUNC(szPath))
                {
                    hr = _GetComputerName_FromPath(szPath, pv);
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else
            {
                hr = E_FAIL;
            }
            ILFree(pidlTarget);
        }
        psl->Release();
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        hr = _GetPath(szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            hr = _GetComputerName_FromPath(szPath, pv);
        }
    }
    
    if (FAILED(hr))
    {
        WCHAR sz[MAX_PATH];
        LoadString(HINST_THISDLL, IDS_UNKNOWNGROUP, sz, ARRAYSIZE(sz));
        hr = InitVariantFromStr(pv, sz);
    }

    return hr;
}

HRESULT CFSFolder::_GetComputerName_FromPath(PCWSTR pwszPath, VARIANT *pv)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = StringCchCopy(szPath, ARRAYSIZE(szPath), pwszPath);
    if (SUCCEEDED(hr))
    {
        PathStripToRoot(szPath);

        if (PathIsUNC(szPath))
        {
            hr = _GetComputerName_FromUNC(szPath, pv);
        }
        else
        {
            CMountPoint* pMtPt = CMountPoint::GetMountPoint(szPath, FALSE);
            if (pMtPt)
            {
                if (pMtPt->IsRemote())
                {
                    WCHAR szRemotePath[MAX_PATH];
                    hr = pMtPt->GetRemotePath(szRemotePath, ARRAYSIZE(szRemotePath));
                    if (SUCCEEDED(hr))
                    {
                        hr = _GetComputerName_FromPath(szRemotePath, pv);
                    }
                }
                else
                {
                    WCHAR sz[MAX_PATH];
                    LoadString(HINST_THISDLL, IDS_THISCOMPUTERGROUP, sz, ARRAYSIZE(sz));
                    hr = InitVariantFromStr(pv, sz);
                }
                pMtPt->Release();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

HRESULT CFSFolder::_GetComputerName_FromUNC(PWSTR pwszPath, VARIANT *pv)
{
    // strip to "\\server"
    PWSTR psz = pwszPath;
    while (*psz && *psz==L'\\')
        psz++;
    while (*psz && *psz!=L'\\')
        psz++;
    *psz = NULL;

    LPITEMIDLIST pidl;
    HRESULT hr = SHParseDisplayName(pwszPath, NULL, &pidl, 0, NULL);
    if (SUCCEEDED(hr))
    {
        WCHAR szName[MAX_PATH];
        hr = SHGetNameAndFlagsW(pidl, SHGDN_INFOLDER, szName, ARRAYSIZE(szName), NULL);
        if (SUCCEEDED(hr))
        {
            hr = InitVariantFromStr(pv, szName);
        }

        ILFree(pidl);
    }

    return hr;
}

            
// GetDetailsEx() helper.
HRESULT CFSFolder::_GetCSCStatus(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv)
{
    HRESULT hr;

    // Note:
    //  Only display the status in the Details task pane if it is "Offline".

    if (_IsOfflineCSC(pidf))
    {
        WCHAR wszStatus[MAX_PATH];
        if (LoadString(HINST_THISDLL, IDS_CSC_STATUS_OFFLINE, wszStatus, ARRAYSIZE(wszStatus)))
        {
            hr = InitVariantFromStr(pv, wszStatus);
        }
        else
        {
            hr = ResultFromLastError();
        }
    }
    else
    {
        VariantInit(pv);
        pv->vt = VT_NULL;
        hr = S_OK;
    }

    return hr;
}

HRESULT CFSFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    return E_NOTIMPL;
}

#define FVCBFT_MUSICFOLDER(ft)  (FVCBFT_MUSIC == ft || FVCBFT_MYMUSIC == ft || FVCBFT_MUSICARTIST == ft || FVCBFT_MUSICALBUM == ft)

void CFSFolder::_AdjustDefShowColumn(UINT iColumn, DWORD *pdwState)
{

    if (FVCBFT_MUSICFOLDER(_nFolderType))
    {
        // hide LastModified date by default for music folders
        if (iColumn == FS_ICOL_WRITETIME)
        {
            *pdwState &= ~SHCOLSTATE_ONBYDEFAULT;
        }
    }
    else
    {
        // Turn on attributes by default for nonmusic folders in ServerAdmin mode
        if (iColumn == FS_ICOL_ATTRIB && IsOS(OS_SERVERADMINUI))
        {
            *pdwState |= SHCOLSTATE_ONBYDEFAULT;
        }
    }
}

BOOL CFSFolder::_ShouldShowExtendedColumn(const SHCOLUMNID* pscid)
{
    BOOL fRet;

    switch(_nFolderType)
    {
    case FVCBFT_PICTURES:
    case FVCBFT_MYPICTURES:
    case FVCBFT_PHOTOALBUM:
        fRet = (IsEqualSCID(*pscid, SCID_WhenTaken) || IsEqualSCID(*pscid, SCID_ImageDimensions));
        break;

    case FVCBFT_MUSIC:
    case FVCBFT_MYMUSIC:
    case FVCBFT_MUSICARTIST:
    case FVCBFT_MUSICALBUM:
        fRet = (IsEqualSCID(*pscid, SCID_MUSIC_Artist) || IsEqualSCID(*pscid, SCID_MUSIC_Year)  ||
                IsEqualSCID(*pscid, SCID_MUSIC_Album)  || IsEqualSCID(*pscid, SCID_MUSIC_Track) ||
                IsEqualSCID(*pscid, SCID_AUDIO_Duration));
        break;

    case FVCBFT_VIDEOS:
    case FVCBFT_MYVIDEOS:
    case FVCBFT_VIDEOALBUM:
        fRet = (IsEqualSCID(*pscid, SCID_AUDIO_Duration) || IsEqualSCID(*pscid, SCID_ImageDimensions));
        break;

    default:
        fRet = FALSE;
        break;
    }

    return fRet;
}

HRESULT CFSFolder::GetDefaultColumnState(UINT iColumn, DWORD *pdwState)
{
    HRESULT hr = S_OK;

    *pdwState = 0;

    if (iColumn < ARRAYSIZE(c_fs_cols))
    {
        *pdwState = c_fs_cols[iColumn].csFlags;

        _AdjustDefShowColumn(iColumn, pdwState);
    }
    else
    {
        iColumn -= ARRAYSIZE(c_fs_cols);
        hr = _LoadColumnHandlers();
        if (SUCCEEDED(hr))
        {
            hr = E_INVALIDARG;
            if (iColumn < _dwColCount)
            {
                COLUMNLISTENTRY cle;

                if (_FindColHandler(iColumn, 0, &cle))
                {
                    *pdwState |= (cle.shci.csFlags | SHCOLSTATE_EXTENDED | SHCOLSTATE_SLOW);
                    if (_ShouldShowExtendedColumn(&cle.shci.scid))
                    {
                        *pdwState |= SHCOLSTATE_ONBYDEFAULT;
                    }
                    else
                    {
                        *pdwState &= ~SHCOLSTATE_ONBYDEFAULT;    // strip this one
                    }
                    hr = S_OK;
                }
            }
        }
    }
    return hr;
}

HRESULT CFSFolder::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    HRESULT hr = MapColumnToSCIDImpl(c_fs_cols, ARRAYSIZE(c_fs_cols), iColumn, pscid);
    if (hr != S_OK)
    {
        COLUMNLISTENTRY cle;
        if (SUCCEEDED(_LoadColumnHandlers()))
        {
            iColumn -= ARRAYSIZE(c_fs_cols);

            if (_FindColHandler(iColumn, 0, &cle))
            {
                *pscid = cle.shci.scid;
                hr = S_OK;
            }
        }
    }
    return hr;
}

HRESULT CFSFolder::_MapSCIDToColumn(const SHCOLUMNID* pscid, UINT* puCol)
{
    HRESULT hr;

    int iCol = FindSCID(c_fs_cols, ARRAYSIZE(c_fs_cols), pscid);
    if (iCol >= 0)
    {
        *puCol = iCol;
        hr = S_OK;
    }
    else
    {
        hr = _LoadColumnHandlers();
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
            for (int i = 0; i < DSA_GetItemCount(_hdsaColHandlers); i++)
            {
                COLUMNLISTENTRY *pcle = (COLUMNLISTENTRY *)DSA_GetItemPtr(_hdsaColHandlers, i);

                if (IsEqualSCID(*pscid, pcle->shci.scid))
                {
                    *puCol = pcle->iColumnId;
                    hr = S_OK;
                    break;
                }
            }
        }

    }

    return hr;
}

//
// N ways to get a clasid for an item
//
BOOL CFSFolder::_GetBindCLSID(IBindCtx *pbc, LPCIDFOLDER pidf, CLSID *pclsid)
{
    CFileSysItemString fsi(pidf);
    DWORD dwClassFlags = fsi.ClassFlags(FALSE);
    if (dwClassFlags & SHCF_IS_DOCOBJECT)
    {
        *pclsid = CLSID_CDocObjectFolder;
    }
    else if (fsi.GetJunctionClsid(pclsid, TRUE))
    {
        // *pclsid has the value

        // HACK: CLSID_Briefcase is use to identify the briefcase
        // but it's InProcServer is syncui.dll. we need to map that CLSID
        // to the object implemented in shell32 (CLSID_BriefcaseFolder)
        // ZEKELTODO - why isnt this a COM "TreatAs"?
        if (IsEqualCLSID(*pclsid, CLSID_Briefcase))
            *pclsid = CLSID_BriefcaseFolder;
    }
    else if (!IsEqualCLSID(CLSID_NULL, _clsidBind))
    {
        *pclsid = _clsidBind;  // briefcase forces all children this way
    }
    else
    {
        return FALSE;   // do normal binding
    }

    // TRUE -> special binding, FALSE -> normal file system binding
    return !SHSkipJunctionBinding(pbc, pclsid);
}


// initalize shell folder handlers
// in:
//      pidf  multi level file system pidl
//
// in/out:
//      *ppunk
//
// note: on failure this frees *ppunk 

HRESULT CFSFolder::_InitFolder(IBindCtx *pbc, LPCIDFOLDER pidf, IUnknown **ppunk)
{
    ASSERT(_FindJunctionNext(pidf) == NULL);     // no extra goo please
            
    LPITEMIDLIST pidlInit;
    HRESULT hr = SHILCombine(_pidl, (LPITEMIDLIST)pidf, &pidlInit);
    if (SUCCEEDED(hr))
    {
        IPersistFolder3 *ppf3;
        hr = (*ppunk)->QueryInterface(IID_PPV_ARG(IPersistFolder3, &ppf3));
        if (SUCCEEDED(hr))
        {
            PERSIST_FOLDER_TARGET_INFO pfti = {0};

            if (_csidlTrack >= 0)
            {
                // SHGetSpecialFolderlocation will return error if the target
                // doesn't exist (which is good, since that means there's
                // nothing to bind to).
                LPITEMIDLIST pidl;
                hr = SHGetSpecialFolderLocation(NULL, _csidlTrack, &pidl);
                if (SUCCEEDED(hr))
                {
                    hr = SHILCombine(pidl, (LPITEMIDLIST)pidf, &pfti.pidlTargetFolder);
                    ILFree(pidl);
                }
            }
            else if (_pidlTarget)
                hr = SHILCombine(_pidlTarget, (LPITEMIDLIST)pidf, &pfti.pidlTargetFolder);

            if (SUCCEEDED(hr))
            {
                hr = _GetPathForItem(pidf, pfti.szTargetParsingName, ARRAYSIZE(pfti.szTargetParsingName));
                if (SUCCEEDED(hr))
                {
                    if (_pszNetProvider)
                        SHTCharToUnicode(_pszNetProvider, pfti.szNetworkProvider, ARRAYSIZE(pfti.szNetworkProvider));

                    pfti.dwAttributes = _FindLastID(pidf)->wAttrs;
                    pfti.csidl = -1;

                    hr = ppf3->InitializeEx(pbc, pidlInit, &pfti);
                }
                ILFree(pfti.pidlTargetFolder);
            }
            ppf3->Release();
        }
        else
        {
            IPersistFolder *ppf;
            hr = (*ppunk)->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf));
            if (SUCCEEDED(hr))
            {
                hr = ppf->Initialize(pidlInit);
                ppf->Release();

                if (hr == E_NOTIMPL)  // map E_NOTIMPL into success, the folder does not care
                    hr = S_OK;
            }
        }
        ILFree(pidlInit);
    }

    if (FAILED(hr))
    {
        ((IUnknown *)*ppunk)->Release();
        *ppunk = NULL;
    }

    return hr;
}


CFSFolderPropertyBag::CFSFolderPropertyBag(CFSFolder *pFSFolder, DWORD grfMode) : 
    _cRef(1), _grfMode(grfMode), _pFSFolder(pFSFolder)
{
    _pFSFolder->AddRef();
}

CFSFolderPropertyBag::~CFSFolderPropertyBag()
{
    _pFSFolder->Release();

    // Release all the property bags
    for (int i = 0; i < ARRAYSIZE(_pPropertyBags); i++)
    {
        if (_pPropertyBags[i])
        {
            _pPropertyBags[i]->Release();
        }
    }
}

STDMETHODIMP CFSFolderPropertyBag::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFSFolderPropertyBag, IPropertyBag),       // IID_IPropertyBag
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}
    
STDMETHODIMP_(ULONG) CFSFolderPropertyBag::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFSFolderPropertyBag::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CFSFolderPropertyBag::_Init(LPCIDFOLDER pidfLast)
{
    TCHAR szFolderPath[MAX_PATH];
    HRESULT hr = _pFSFolder->_GetPathForItem(pidfLast, szFolderPath, ARRAYSIZE(szFolderPath));
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        if (_GetIniPath((_grfMode == STGM_WRITE) || (_grfMode == STGM_READWRITE), szFolderPath, NULL, szPath))
        {
            // This is a customized folder (likely).
            // Get an IPropertyBag on it's desktop.ini.
            if (SUCCEEDED(SHCreatePropertyBagOnProfileSection(szPath, STRINI_CLASSINFO, _grfMode,
                IID_PPV_ARG(IPropertyBag, &_pPropertyBags[INDEX_PROPERTYBAG_DESKTOPINI]))))
            {
                TCHAR szFolderType[128];
                if (SUCCEEDED(SHPropertyBag_ReadStr(_pPropertyBags[INDEX_PROPERTYBAG_DESKTOPINI], 
                    L"FolderType", szFolderType, ARRAYSIZE(szFolderType))))
                {
                    TCHAR szRegPath[256];

                    StrCpyN(szRegPath, REGSTR_PATH_EXPLORER L"\\FolderClasses\\", ARRAYSIZE(szRegPath));
                    StrCatN(szRegPath, szFolderType, ARRAYSIZE(szRegPath));
                    SHCreatePropertyBagOnRegKey(HKEY_CURRENT_USER, szRegPath,
                            _grfMode, IID_PPV_ARG(IPropertyBag, &_pPropertyBags[INDEX_PROPERTYBAG_HKCU]));
                    SHCreatePropertyBagOnRegKey(HKEY_LOCAL_MACHINE, szRegPath,
                            _grfMode, IID_PPV_ARG(IPropertyBag, &_pPropertyBags[INDEX_PROPERTYBAG_HKLM]));
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CFSFolderPropertyBag::Read(LPCOLESTR pszPropName, VARIANT *pvar, IErrorLog *pErrorLog)
{
    // We first try reading HKCU\RegKeySpecifiedInDesktopIniForTheFolder,
    // then HKLM\RegKeySpecifiedInDesktopIniForTheFolder and finally
    // the desktop.ini
    HRESULT hr = E_FAIL;
    for (int i = 0; FAILED(hr) && (i < ARRAYSIZE(_pPropertyBags)); i++)
    {
        if (_pPropertyBags[i])
        {
            hr = _pPropertyBags[i]->Read(pszPropName, pvar, pErrorLog);
        }
    }
    return hr;
}

HRESULT CFSFolderPropertyBag::Write(LPCOLESTR pszPropName, VARIANT *pvar)
{
    // We first try writing to HKCU\RegKeySpecifiedInDesktopIniForTheFolder,
    // then to HKLM\RegKeySpecifiedInDesktopIniForTheFolder and finally
    // to desktop.ini
    HRESULT hr = E_FAIL;
    for (int i = 0; FAILED(hr) && (i < ARRAYSIZE(_pPropertyBags)); i++)
    {
        if (_pPropertyBags[i])
        {
            hr = _pPropertyBags[i]->Write(pszPropName, pvar);
        }
    }
    return hr;
}

// pidfLast can be NULL, if so create the bag on this folder
HRESULT CFSFolder::_CreateFolderPropertyBag(DWORD grfMode, LPCIDFOLDER pidfLast, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr;
    CFSFolderPropertyBag *pbag = new CFSFolderPropertyBag(this, grfMode);
    if (pbag)
    {
        hr = pbag->_Init(pidfLast);
        if (SUCCEEDED(hr))
        {
            hr = pbag->QueryInterface(riid, ppv);
        }

        pbag->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

//
// pidfLast and pszIniPath can be NULL.
// If not NULL, pidfLast is an IN param - specifies the relative pidl of a subfolder
// inside the CFSFolder object.
// If not NULL, pszIniPath is an OUT param (pointer to a buffer atleast MAX_PATH long)
// - receives the path to desktop.ini
//
BOOL CFSFolder::_CheckDefaultIni(LPCIDFOLDER pidfLast, LPTSTR pszIniPath, DWORD cchIniPath)
{
    BOOL fForceIni = FALSE;

    TCHAR szPath[MAX_PATH];
    if (!pszIniPath)
    {
        pszIniPath = szPath;
        cchIniPath = ARRAYSIZE(szPath);
    }

    HRESULT hr = _GetPathForItem(pidfLast, pszIniPath, cchIniPath);

    if (SUCCEEDED(hr) && PathIsRoot(pszIniPath))
    {   // Desktop.ini has to be checked for the root folders
        // even if the RO or SYSTEM bits are not set on them
        fForceIni = TRUE;
    }
    else
    {
        UINT csidl;
        if (!pidfLast)
        {
            csidl = _GetCSIDL();    // Get the cached value for the current folder
        }
        else
        {   // For subfolders, we don't have any cached values. So, compute.
            _csidl = GetSpecialFolderID(pszIniPath, c_csidlSpecial, ARRAYSIZE(c_csidlSpecial));
        }
        
        switch (csidl)
        {   // Desktop.ini has to be checked for the following special folders
            // even if the RO or SYSTEM bits are not set on them
        case CSIDL_SYSTEM:
        case CSIDL_WINDOWS:
        case CSIDL_PERSONAL:
            fForceIni = TRUE;
            break;
        }
    }
    
    if (!fForceIni)
    {   // Is the RO or SYSTEM bit set?
        fForceIni = (_Attributes() & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM));
    }

    // Append desktop.ini to the path
    if (SUCCEEDED(hr))
    {
        PathAppend(pszIniPath, c_szDesktopIni);
    }
    
    return fForceIni;
}

LPCTSTR CFSFolder::_BindHandlerName(REFIID riid)
{
    LPCTSTR pszHandler = NULL;
    if (IsEqualIID(riid, IID_IPropertySetStorage))
        pszHandler = TEXT("PropertyHandler");
    else if (IsEqualIID(riid, IID_IStorage))
        pszHandler = TEXT("StorageHandler");

    return pszHandler;
}

const CLSID CLSID_CTextIFilter = {
    0xc1243ca0,
    0xbf96,
    0x11cd,
    { 0xb5, 0x79, 0x08, 0x00, 0x2b, 0x30, 0xbf, 0xeb }};

HRESULT LoadIFilterWithTextFallback(
    WCHAR const *pwcsPath,
    IUnknown *pUnkOuter,
    void **ppIUnk)
{
    HRESULT hr = LoadIFilter(pwcsPath, pUnkOuter, ppIUnk);

    if (FAILED(hr))
    {
        DWORD dwFilterUnknown = 0;
        DWORD cb = sizeof(dwFilterUnknown);
        SHGetValue(HKEY_LOCAL_MACHINE, TEXT("SYSTEM\\CurrentControlSet\\Control\\ContentIndex"),
                        TEXT("FilterFilesWithUnknownExtensions"), NULL, &dwFilterUnknown, &cb);
        if (dwFilterUnknown != 0)
        {
            IPersistFile *ppf;
            hr = CoCreateInstance(CLSID_CTextIFilter, pUnkOuter, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                hr = ppf->Load(pwcsPath, STGM_READ);
                if (SUCCEEDED(hr))
                {
                    hr = ppf->QueryInterface(IID_IFilter, ppIUnk);
                }
                ppf->Release();
            }
        }
    }
    return hr;
}


//  pidf - multi level file system only item 
HRESULT CFSFolder::_Bind(LPBC pbc, LPCIDFOLDER pidf, REFIID riid, void **ppv)
{
    ASSERT(_FindJunctionNext(pidf) == NULL);     // no extra non file sys goo please

    *ppv = NULL;

    HRESULT hr;
    CLSID clsid;
    LPCIDFOLDER pidfLast = _FindLastID(pidf);

    if (_GetBindCLSID(pbc, pidfLast, &clsid))
    {
        hr = SHExtCoCreateInstance(NULL, &clsid, NULL, riid, ppv);

        if (SUCCEEDED(hr))
            hr = _InitFolder(pbc, pidf, (IUnknown **)ppv);

        if (FAILED(hr) && (E_NOINTERFACE != hr) && _IsFolder(pidfLast))
        {
            // the IShellFolder extension failed to load (might not be installed
            // on this machine), so check if we should fall back to default to CFSFolder
            UINT dwFlags;
            if (_GetFolderFlags(pidf, &dwFlags) && (dwFlags & GFF_DEFAULT_TO_FS))
            {
                hr = CFSFolder_CreateInstance(NULL, riid, ppv);
                if (SUCCEEDED(hr))
                    hr = _InitFolder(pbc, pidf, (IUnknown **)ppv);
            }
        }
    }
    else if (_IsFolder(pidfLast) || _IsSimpleID(pidfLast))
    {
        hr = CFSFolder_CreateInstance(NULL, riid, ppv);
        if (SUCCEEDED(hr))
            hr = _InitFolder(pbc, pidf, (IUnknown **)ppv);
    }
    else
        hr = E_FAIL;

    if (FAILED(hr))
    {
        // this handler has a string version
        DWORD grfMode = BindCtx_GetMode(pbc, STGM_READ | STGM_SHARE_DENY_WRITE);
        LPCTSTR pszHandler = _BindHandlerName(riid);

        hr = _LoadHandler(pidf, grfMode, pszHandler, riid, ppv);
        if (FAILED(hr))
        {
            WCHAR wszPath[MAX_PATH];
            if (SUCCEEDED(_GetPathForItem(pidf, wszPath, ARRAYSIZE(wszPath))))
            {
                if (IsEqualIID(riid, IID_IStream) && _IsFile(pidfLast))
                {
                    hr = SHCreateStreamOnFileEx(wszPath, grfMode, FILE_ATTRIBUTE_NORMAL, FALSE, NULL, (IStream **)ppv);
                }
                else if (IsEqualIID(riid, IID_IPropertyBag) && _IsFolder(pidfLast))
                {
                    hr = _CreateFolderPropertyBag(grfMode, pidf, riid, ppv);
                }
                else if (IsEqualIID(riid, IID_IPropertySetStorage))
                {
                    // this is questionable at best. the caller
                    // should be filtering offline files, not this code.
                    // legacy support, I don't think anyone depends on this
                    // avoid offline files...
                    if (FILE_ATTRIBUTE_OFFLINE & pidf->wAttrs)
                        hr = STG_E_INVALIDFUNCTION; 
                    else
                    {
                        hr = StgOpenStorageEx(wszPath, grfMode, STGFMT_ANY, 0, NULL, NULL, riid, ppv);
                    }
                }
                else if (IsEqualIID(riid, IID_IMoniker))
                {
                    hr = CreateFileMoniker(wszPath, (IMoniker **)ppv);
                }
                else if (IsEqualIID(riid, IID_IFilter))
                {
                    hr = LoadIFilterWithTextFallback(wszPath, NULL, ppv);
                }
            }
        }
    }

    ASSERT((SUCCEEDED(hr) && *ppv) || (FAILED(hr) && (NULL == *ppv)));   // Assert hr is consistent w/out param.
    return hr;
}

// returns:
//      *ppidfBind - multi level file system pidl part (must free this on S_OK return)
//      *ppidlRight - non file system part of pidl, continue bind down to this
//
//  S_OK
//      *ppidfBind needs to be freed
//  S_FALSE
//      pidf is a multi level file system only, bind to him
//  FAILED()    out of meory errors

HRESULT CFSFolder::_GetJunctionForBind(LPCIDFOLDER pidf, LPIDFOLDER *ppidfBind, LPCITEMIDLIST *ppidlRight)
{
    *ppidfBind = NULL;

    *ppidlRight = _FindJunctionNext(pidf);
    if (*ppidlRight)
    {
        *ppidfBind = (LPIDFOLDER)ILClone((LPITEMIDLIST)pidf);
        if (*ppidfBind)
        {
            // remove the part below the junction point
            _ILSkip(*ppidfBind, (ULONG)((ULONG_PTR)*ppidlRight - (ULONG_PTR)pidf))->mkid.cb = 0;
            return S_OK;
        }
        return E_OUTOFMEMORY;
    }
    return S_FALSE; // nothing interesting
}

HRESULT CFSFolder::GetIconOf(LPCITEMIDLIST pidl, UINT flags, int *piIndex)
{
    LPCIDFOLDER pidf = _IsValidID(pidl);
    if (pidf)
    {
        CFileSysItemString fsi(pidf);
        DWORD dwFlags;
        int iIcon = -1;

        // WARNING: don't include junctions (_IsFileFolder(pidf))
        // so junctions like briefcase get their own cusotm icon.
        //
        if (_IsFileFolder(pidf))
        {
            TCHAR szMountPoint[MAX_PATH];
            TCHAR szModule[MAX_PATH];

            iIcon = II_FOLDER;
            if (_GetMountingPointInfo(pidf, szMountPoint, ARRAYSIZE(szMountPoint)))
            {
                iIcon = GetMountedVolumeIcon(szMountPoint, szModule, ARRAYSIZE(szModule));

                *piIndex = Shell_GetCachedImageIndex(szModule[0] ? szModule : c_szShell32Dll, iIcon, 0);
                return S_OK;
            }
            else
            {
                if (!_IsSystemFolder(pidf) && (_GetCSIDL() == CSIDL_NORMAL))
                {
                    if (flags & GIL_OPENICON)
                        iIcon = II_FOLDEROPEN;
                    else
                        iIcon = II_FOLDER;

                    *piIndex = Shell_GetCachedImageIndex(c_szShell32Dll, iIcon, 0);
                    return S_OK;
                }
                iIcon = II_FOLDER;
                dwFlags = SHCF_ICON_PERINSTANCE;
            }
        }
        else
            dwFlags = fsi.ClassFlags(TRUE);

        // the icon is per-instance, try to look it up
        if (dwFlags & SHCF_ICON_PERINSTANCE)
        {
            TCHAR szFullPath[MAX_PATH];
            DWORD uid = _GetUID(pidf);    // get a unique identifier for this file.

            if (uid == 0)
                return S_FALSE;

            if (FAILED(_GetPathForItem(pidf, szFullPath, ARRAYSIZE(szFullPath))))
            {
                // fall back to the relative name if we can't get the full path
                lstrcpyn(szFullPath, fsi.FSName(), ARRAYSIZE(szFullPath));
            }

            *piIndex = LookupIconIndex(szFullPath, uid, flags | GIL_NOTFILENAME);

            if (*piIndex != -1)
                return S_OK;

            //  async extract (GIL_ASYNC) support
            //
            //  we cant find the icon in the icon cache, we need to do real work
            //  to get the icon.  if the caller specified GIL_ASYNC
            //  dont do the work, return E_PENDING forcing the caller to call
            //  back later to get the real icon.
            //
            //  when returing E_PENDING we must fill in a default icon index
            if (flags & GIL_ASYNC)
            {
                // come up with a default icon and return E_PENDING
                if (_IsFolder(pidf))
                    iIcon = II_FOLDER;
                else if (!(dwFlags & SHCF_HAS_ICONHANDLER) && PathIsExe(fsi.FSName()))
                    iIcon = II_APPLICATION;
                else
                    iIcon = II_DOCNOASSOC;

                *piIndex = Shell_GetCachedImageIndex(c_szShell32Dll, iIcon, 0);

                TraceMsg(TF_IMAGE, "Shell_GetCachedImageIndex(%d) returned = %d", iIcon, *piIndex);

                return E_PENDING;   // we will be called back later for the real one
            }

            // If this is a folder, see if this folder has Per-Instance folder icon
            // we do this here because it's too expensive to open a desktop.ini
            // file and see what's in there. Most of the cases we will just hit
            // the above cases
            if (_IsSystemFolder(pidf))
            {
                if (!_GetFolderIconPath(pidf, NULL, 0, NULL))
                {
                    // Note: the iIcon value has already been computed at the start of this funciton
                    ASSERT(iIcon != -1);
                    *piIndex = Shell_GetCachedImageIndex(c_szShell32Dll, iIcon, 0);
                    return S_OK;
                }
            }

            //
            // look up icon using IExtractIcon, this will load handler iff needed
            // by calling ::GetUIObjectOf
            //
            IShellFolder *psf;
            HRESULT hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                hr = SHGetIconFromPIDL(psf, NULL, (LPCITEMIDLIST)pidf, flags, piIndex);
                psf->Release();
            }

            //
            // remember this perinstance icon in the cache so we dont
            // need to load the handler again.
            //
            // SHGetIconFromPIDL will always return a valid image index
            // (it may default to a standard one) but it will fail
            // if the file cant be accessed or some other sort of error.
            // we dont want to cache in this case.
            //
            if (*piIndex != -1 && SUCCEEDED(hr) && (dwFlags & SHCF_HAS_ICONHANDLER))
            {
                int iIndexRetry;

                ENTERCRITICAL;

                //
                // Inside the critical section, make sure the icon isn't already
                // loaded, and if its not, then add it.
                //
                iIndexRetry = LookupIconIndex(szFullPath, uid, flags | GIL_NOTFILENAME);
                if (iIndexRetry == -1)
                {
                    AddToIconTable(szFullPath, uid, flags | GIL_NOTFILENAME, *piIndex);
                }

                LEAVECRITICAL;
            }

            return *piIndex == -1 ? S_FALSE : S_OK;
        }

        // icon is per-class dwFlags has the image index
        *piIndex = (dwFlags & SHCF_ICON_INDEX);
        return S_OK;
    }
    else
    {
        ASSERT(ILIsEmpty(pidl) || SIL_GetType(pidl) == SHID_ROOT_REGITEM); // regitems gives us these
        return S_FALSE;
    }
}

HANDLE g_hOverlayMgrCounter = NULL;   // Global count of Overlay Manager changes.
int g_lOverlayMgrPerProcessCount = 0; // Per process count of Overlay Manager changes.

//
// Use this function to obtain address of the singleton icon overlay manager.
// If the function succeeds, caller is responsible for calling Release() through
// the returned interface pointer.
// The function ensures that the manager is initialized and up to date.
//
STDAPI GetIconOverlayManager(IShellIconOverlayManager **ppsiom)
{
    HRESULT hr = E_FAIL;

    if (IconOverlayManagerInit())
    { 
        //
        // Is a critsec for g_psiom required here you ask?
        //
        // No.  The first call to IconOverlayInit in any process creates
        // the overlay manager object and initializes g_psiom.  This creation
        // contributes 1 to the object's ref count.  Subsequent calls to
        // GetIconOverlayManager add to the ref count and the caller is
        // responsible for decrementing the count through Release().
        // The original ref count of 1 is not removed until 
        // IconOverlayManagerTerminate is called which happens only
        // during PROCESS_DETACH.  Therefore, the manager referenced by g_psiom
        // in this code block will always be valid and a critsec is not
        // required.
        //

        //
        // ID for the global overlay manager counter.
        //
        static const GUID GUID_Counter = { /* 090851a5-eb96-11d2-8be4-00c04fa31a66 */
                                           0x090851a5,
                                           0xeb96,
                                           0x11d2,
                                           {0x8b, 0xe4, 0x00, 0xc0, 0x4f, 0xa3, 0x1a, 0x66}
                                         };
    
        g_psiom->AddRef();
    
        HANDLE hCounter = SHGetCachedGlobalCounter(&g_hOverlayMgrCounter, &GUID_Counter);
        long lGlobalCount = SHGlobalCounterGetValue(hCounter);

        if (lGlobalCount != g_lOverlayMgrPerProcessCount)
        {
            //
            // Per-process counter is out of sync with the global counter.
            // This means someone called SHLoadNonloadedIconOverlayIdentifiers
            // so we must load any non-loaded identifiers from the registry.
            //
            g_psiom->LoadNonloadedOverlayIdentifiers();
            g_lOverlayMgrPerProcessCount = lGlobalCount;
        }
        *ppsiom = g_psiom;
        hr = S_OK;
    }
    return hr;
}

BOOL IconOverlayManagerInit()
{
    if (!g_psiom)
    {
        IShellIconOverlayManager* psiom;
        if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_CFSIconOverlayManager, NULL, IID_PPV_ARG(IShellIconOverlayManager, &psiom))))
        {
            if (SHInterlockedCompareExchange((void **)&g_psiom, psiom, 0))
                psiom->Release();
        }
    }
    return BOOLFROMPTR(g_psiom);
}

void IconOverlayManagerTerminate()
{
    ASSERTDLLENTRY;      // does not require a critical section

    IShellIconOverlayManager *psiom = (IShellIconOverlayManager *)InterlockedExchangePointer((void **)&g_psiom, 0);
    if (psiom)
        psiom->Release();

    if (NULL != g_hOverlayMgrCounter)
    {
        CloseHandle(g_hOverlayMgrCounter);
        g_hOverlayMgrCounter = NULL;
    }
}


STDAPI SHLoadNonloadedIconOverlayIdentifiers(void)
{
    //
    // This will cause the next call GetIconOverlayManager() call in each process
    // to load any non-loaded icon overlay identifiers.
    //
    if (g_hOverlayMgrCounter)
        SHGlobalCounterIncrement(g_hOverlayMgrCounter);

    return S_OK;
}


HRESULT CFSFolder::_GetOverlayInfo(LPCITEMIDLIST pidl, int * pIndex, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;
    LPCIDFOLDER pidf = _IsValidID(pidl);

    *pIndex = 0;
    
    if (!pidf)
    {
        ASSERT(SIL_GetType(pidl) != SHID_ROOT_REGITEM); // CRegFolder should have handled it
        return S_FALSE;
    }

    ASSERT(pidl == ILFindLastID(pidl));

    if (IconOverlayManagerInit())
    {
        int iReservedID = -1;
        WCHAR wszPath[MAX_PATH];

        hr = _GetPathForItem(pidf, wszPath, ARRAYSIZE(wszPath));
        if (SUCCEEDED(hr))
        {
            IShellIconOverlayManager *psiom;
            // The order of the "if" statements here is significant

            if (_IsFile(pidf) && (_GetClassFlags(pidf) & SHCF_IS_LINK))
                iReservedID = SIOM_RESERVED_LINK;
            else
            {
                if (_IsFolder(pidf) && (IsShared(wszPath, FALSE)))
                    iReservedID = SIOM_RESERVED_SHARED;
                else if (FILE_ATTRIBUTE_OFFLINE & pidf->wAttrs)
                    iReservedID = SIOM_RESERVED_SLOWFILE;
            }

            hr = GetIconOverlayManager(&psiom);
            if (SUCCEEDED(hr))
            {
                if (iReservedID != -1)
                    hr = psiom->GetReservedOverlayInfo(wszPath, pidf->wAttrs, pIndex, dwFlags, iReservedID);
                else
                    hr = psiom->GetFileOverlayInfo(wszPath, pidf->wAttrs, pIndex, dwFlags);

                psiom->Release();
            }
        }
    }
    return hr;
}

HRESULT CFSFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int * pIndex)
{
    HRESULT hr = E_INVALIDARG;
    ASSERT(pIndex);
    if (pIndex)
        hr = (*pIndex == OI_ASYNC) ? E_PENDING :
               _GetOverlayInfo(pidl, pIndex, SIOM_OVERLAYINDEX);

    return hr;
}

HRESULT CFSFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int * pIconIndex)
{
    return _GetOverlayInfo(pidl, pIconIndex, SIOM_ICONINDEX);
}


// CFSFolder : IPersist, IPersistFolder, IPersistFolder2, IPersistFolderAlias Members

HRESULT CFSFolder::GetClassID(CLSID *pclsid)
{
    if (!IsEqualCLSID(_clsidBind, CLSID_NULL))
    {
        *pclsid = _clsidBind;
    }
    else
    {
        *pclsid = CLSID_ShellFSFolder;
    }
    return S_OK;
}

HRESULT CFSFolder::Initialize(LPCITEMIDLIST pidl)
{
    _Reset();
    return SHILClone(pidl, &_pidl);
}

HRESULT CFSFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    return GetCurFolderImpl(_pidl, ppidl);
}

LPTSTR StrDupUnicode(const WCHAR *pwsz)
{
    if (*pwsz)
    {
        return StrDupW(pwsz);
    }
    return NULL;
}


HRESULT CFSFolder::_SetStgMode(DWORD grfFlags)
{
    HRESULT hr = S_OK;

    if (grfFlags & STGM_TRANSACTED)
        hr = E_INVALIDARG;

    if (SUCCEEDED(hr))
        _grfFlags = grfFlags;

    return hr;
}


HRESULT CFSFolder::InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, 
                                const PERSIST_FOLDER_TARGET_INFO *pfti)
{
    HRESULT hr = Initialize(pidlRoot);
    if (SUCCEEDED(hr))
    {
        if (pfti)
        {
            _dwAttributes = pfti->dwAttributes;
            if (pfti->pidlTargetFolder ||
                pfti->szTargetParsingName[0] ||
                (pfti->csidl != -1))
            {

                if ((pfti->csidl != -1) && (pfti->csidl & CSIDL_FLAG_PFTI_TRACKTARGET))
                {
                    //  For tracking target, all other fields must be null.
                    if (!pfti->pidlTargetFolder &&
                        !pfti->szTargetParsingName[0] &&
                        !pfti->szNetworkProvider[0])
                    {
                        _csidlTrack = pfti->csidl & (~CSIDL_FLAG_MASK | CSIDL_FLAG_CREATE);
                    }
                    else
                    {
                        hr = E_INVALIDARG;
                    }
                }
                else
                {
                    _pidlTarget = ILClone(pfti->pidlTargetFolder);  // on NULL returns NULL
                    _pszPath = StrDupUnicode(pfti->szTargetParsingName);
                    _pszNetProvider = StrDupUnicode(pfti->szNetworkProvider);
                    if (pfti->csidl != -1)
                        _csidl = pfti->csidl & (~CSIDL_FLAG_MASK | CSIDL_FLAG_CREATE);
                }
            }
        }
        if (SUCCEEDED(hr))
        {
            hr = _SetStgMode(BindCtx_GetMode(pbc, STGM_READ | STGM_SHARE_DENY_WRITE));
        }
        if (SUCCEEDED(hr) && pbc)
        {
            _fDontForceCreate = BindCtx_ContainsObject(pbc, STR_DONT_FORCE_CREATE);
        }
    }
    return hr;
}

HRESULT CFSFolder::GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *pfti)
{
    HRESULT hr = S_OK;
    ZeroMemory(pfti, sizeof(*pfti)); 

    _GetPathForItem(NULL, pfti->szTargetParsingName, ARRAYSIZE(pfti->szTargetParsingName));
    if (_pidlTarget)
        hr = SHILClone(_pidlTarget, &pfti->pidlTargetFolder);
    if (_pszNetProvider)
        SHTCharToUnicode(_pszNetProvider, pfti->szNetworkProvider, ARRAYSIZE(pfti->szNetworkProvider));

    pfti->dwAttributes = _dwAttributes;
    if (_csidlTrack >= 0)
        pfti->csidl = _csidlTrack | CSIDL_FLAG_PFTI_TRACKTARGET;
    else
        pfti->csidl = _GetCSIDL();

    return hr;
}

STDAPI CFSFolder_CreateFolder(IUnknown *punkOuter, LPBC pbc, LPCITEMIDLIST pidl, 
                              const PERSIST_FOLDER_TARGET_INFO *pfti, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr;
    CFSFolder *pfolder = new CFSFolder(punkOuter);
    if (pfolder)
    {
        hr = pfolder->InitializeEx(pbc, pidl, pfti);
        if (SUCCEEDED(hr))
            hr = pfolder->_GetInner()->QueryInterface(riid, ppv);
        pfolder->_GetInner()->Release();
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

// COM object creation entry point for CLSID_ShellFSFolder
STDAPI CFSFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return CFSFolder_CreateFolder(punkOuter, NULL, &c_idlDesktop, NULL, riid, ppv);
}

BOOL CFSFolder::_IsSlowPath()
{
    if (_bSlowPath == INVALID_PATHSPEED)
    {
        TCHAR szPath[MAX_PATH];
        _GetPath(szPath, ARRAYSIZE(szPath));
        _bSlowPath = PathIsSlow(szPath, _Attributes()) ? TRUE : FALSE;
    }
    return _bSlowPath;
}

//
// Call the shell file operation code to delete recursively the given directory,
// don't show any UI.
//

HRESULT CFSFolder::_Delete(LPCWSTR pszFile)
{
    SHFILEOPSTRUCT fos = { 0 };
    TCHAR szFile[MAX_PATH + 1];

    SHUnicodeToTChar(pszFile, szFile, MAX_PATH);

    // szFile is a double-zero terminated list of files.
    // we can't just zero-init the szFile string to start with,
    // since in debug SHUnicodeToTChar will bonk the uncopied part
    // of the string with noise.
    szFile[lstrlen(szFile) + 1] = 0;

    fos.wFunc = FO_DELETE;
    fos.pFrom = szFile;
    fos.fFlags = FOF_NOCONFIRMATION | FOF_SILENT;

    return SHFileOperation(&fos) ? E_FAIL : S_OK;
}

//
// Do a path combine thunking accordingly
//

HRESULT CFSFolder::_GetFullPath(LPCWSTR pszRelPath, LPWSTR pszFull)
{
    WCHAR szPath[MAX_PATH];
    _GetPathForItem(NULL, szPath, ARRAYSIZE(szPath));
    PathCombineW(pszFull, szPath, pszRelPath);
    return S_OK;    // for now
}

HRESULT _FileExists(LPCWSTR pszPath, DWORD *pdwAttribs)
{
    return PathFileExistsAndAttributesW(pszPath, pdwAttribs) ? S_OK : STG_E_FILENOTFOUND;
}

// IStorage

STDMETHODIMP CFSFolder::CreateStream(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStream **ppstm)
{
    HRESULT hr = _OpenCreateStream(pwcsName, grfMode, ppstm, TRUE);
    if (SUCCEEDED(hr))
    {
        WCHAR szFullPath[MAX_PATH];
        _GetFullPath(pwcsName, szFullPath);
        SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szFullPath, NULL);
    }
    return hr;
}

STDMETHODIMP CFSFolder::OpenStream(LPCWSTR pwcsName, void *res1, DWORD grfMode, DWORD res2, IStream **ppstm)
{
    return _OpenCreateStream(pwcsName, grfMode, ppstm, FALSE);
}


HRESULT CFSFolder::_OpenCreateStream(LPCWSTR pwcsName, DWORD grfMode, IStream **ppstm, BOOL fCreate)
{
    *ppstm = NULL;

    if (!pwcsName)
        return STG_E_INVALIDPARAMETER;

    WCHAR szFullPath[MAX_PATH];
    _GetFullPath(pwcsName, szFullPath);

    HRESULT hr = SHCreateStreamOnFileEx(szFullPath, grfMode, FILE_ATTRIBUTE_NORMAL, fCreate, NULL, ppstm);

    return MapWin32ErrorToSTG(hr);
}


STDMETHODIMP CFSFolder::CreateStorage(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStorage **ppstg)
{
    return _OpenCreateStorage(pwcsName, grfMode, ppstg, TRUE);
}

STDMETHODIMP CFSFolder::OpenStorage(LPCWSTR pwcsName, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD res, IStorage **ppstg)
{
    return _OpenCreateStorage(pwcsName, grfMode, ppstg, FALSE);
}

HRESULT CFSFolder::_OpenCreateStorage(LPCWSTR pwcsName, DWORD grfMode, IStorage **ppstg, BOOL fCreate)
{
    *ppstg = NULL;

    if (!pwcsName)
        return STG_E_INVALIDPARAMETER;

    if (grfMode &
        ~(STGM_READ             |
          STGM_WRITE            |
          STGM_READWRITE        |
          STGM_SHARE_DENY_NONE  |
          STGM_SHARE_DENY_READ  |
          STGM_SHARE_DENY_WRITE |
          STGM_SHARE_EXCLUSIVE  |
          STGM_CREATE        ))
    {
        return STG_E_INVALIDPARAMETER;
    }
    
    // if the storage doesn't exist then lets create it, then drop into the
    // open storage to do the right thing.

    WCHAR szFullPath[MAX_PATH];
    _GetFullPath(pwcsName, szFullPath);

    DWORD dwAttributes;
    HRESULT hr = _FileExists(szFullPath, &dwAttributes);
    if (SUCCEEDED(hr))
    {
        if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            if (fCreate)
            {
                // an object exists, we must fail grfMode == STGM_FAILIFTHERE, or
                // the object that exists is not a directory.  
                //        
                // if the STGM_CREATE flag is set and the object exists we will
                // delete the existing storage.

                // Check to make sure only one existence flag is specified
                // FAILIFTHERE is zero so it can't be checked
                if (STGM_FAILIFTHERE == (grfMode & (STGM_CREATE | STGM_CONVERT)))
                    hr = STG_E_FILEALREADYEXISTS;
                else if (grfMode & STGM_CREATE)
                {
                    // If they have not passed STGM_FAILIFTHERE, we'll replace an existing
                    // folder even if its readonly or system.  Its up to the caller to make
                    // such filesystem-dependant checks first if they want to prevent that,
                    // as there's no way to pass information about whether we should or not
                    // down into CreateStorage

                    if (dwAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY))
                        SetFileAttributes(szFullPath, dwAttributes & ~(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY));

                    hr = _Delete(szFullPath);

                    //
                    // I don't trust the result from SHFileOperation, so I consider success
                    // to be iff the directory is -gone-
                    //

                    if (FAILED(_FileExists(szFullPath, &dwAttributes)))
                    {
                        DWORD err = SHCreateDirectoryExW(NULL, szFullPath, NULL); 
                        hr = HRESULT_FROM_WIN32(err);
                    }
                    else
                    {
                        // We couldn't remove the existing directory, so return an error,
                        // using what _Delete() said or, it if didn't return an error, E_FAIL

                        return (FAILED(hr) ? hr : E_FAIL);
                    }
                }
                else
                    hr = STG_E_INVALIDPARAMETER;
            }
        }
        else
            hr = E_FAIL;    // a file, not a folder!
    }
    else
    {
        // the object doesn't exist, and they have not set the STGM_CREATE, nor
        // is this a ::CreateStorage call.
        hr = STG_E_FILENOTFOUND;

        if (fCreate)
        {
            DWORD err = SHCreateDirectoryExW(NULL, szFullPath, NULL); 
            hr = HRESULT_FROM_WIN32(err);
        }
    }

    // create a directory (we assume this will always succeed)

    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;
        hr = ParseDisplayName(NULL, NULL, (LPWSTR)pwcsName, NULL, &pidl, NULL); // const -> non const
        if (SUCCEEDED(hr))
        {
            hr = BindToObject(pidl, NULL, IID_PPV_ARG(IStorage, ppstg));
            ILFree(pidl);
        }
    }

    return hr;
}

STDMETHODIMP CFSFolder::CopyTo(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest)
{
    return E_NOTIMPL;
}

// CFSFolder::MoveElementTo
//
// Copies or moves a source file (stream) to a destination storage.  The stream
// itself, in this case our filestream object, does the actual work of moving
// the data around.

STDMETHODIMP CFSFolder::MoveElementTo(LPCWSTR pwcsName, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags)
{
    return StgMoveElementTo(SAFECAST(this, IShellFolder *), SAFECAST(this, IStorage *), pwcsName, pstgDest, pwcsNewName, grfFlags);
}

STDMETHODIMP CFSFolder::Commit(DWORD grfCommitFlags)
{
    return S_OK;        // changes are commited as we go, so return S_OK;
}

STDMETHODIMP CFSFolder::Revert()
{
    return E_NOTIMPL;   // changes are commited as we go, so cannot implement this.
}

STDMETHODIMP CFSFolder::EnumElements(DWORD res1, void *res2, DWORD res3, IEnumSTATSTG **ppenum)
{
    HRESULT hr;
    CFSFolderEnumSTATSTG *penum = new CFSFolderEnumSTATSTG(this);
    if (penum)
    {
        *ppenum = (IEnumSTATSTG *) penum;
        hr = S_OK;
    }
    else
    {
        *ppenum = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CFSFolder::DestroyElement(LPCWSTR pwcsName)
{
    if (!pwcsName)
        return STG_E_INVALIDPARAMETER;

    WCHAR szFullPath[MAX_PATH];
    _GetFullPath(pwcsName, szFullPath);

    return _Delete(szFullPath);
}

STDMETHODIMP CFSFolder::RenameElement(LPCWSTR pwcsOldName, LPCWSTR pwcsNewName)
{
    if (!pwcsOldName || !pwcsNewName)
        return STG_E_INVALIDPARAMETER;

    WCHAR szOldPath[MAX_PATH];
    _GetFullPath(pwcsOldName, szOldPath);

    HRESULT hr = _FileExists(szOldPath, NULL);
    if (SUCCEEDED(hr))
    {
        WCHAR szNewPath[MAX_PATH];
        _GetFullPath(pwcsNewName, szNewPath);

        hr = _FileExists(szNewPath, NULL);
        if (FAILED(hr))
        {
            if (MoveFileW(szOldPath, szNewPath))
                hr = S_OK;
            else
                hr = E_FAIL;
        }
        else
            hr = STG_E_FILEALREADYEXISTS;
    }
    return hr;
}

STDMETHODIMP CFSFolder::SetElementTimes(LPCWSTR pwcsName, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime)
{
    if (!pwcsName)
        return STG_E_INVALIDPARAMETER;

    WCHAR szFullPath[MAX_PATH];
    _GetFullPath(pwcsName, szFullPath);

    HRESULT hr = S_OK;
    HANDLE hFile = CreateFileW(szFullPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        if (!SetFileTime(hFile, pctime, patime, pmtime))
            hr = HRESULT_FROM_WIN32(GetLastError());

        CloseHandle(hFile);
    }
    else
    {
        hr = STG_E_FILENOTFOUND;
    }

    return hr;
}

STDMETHODIMP CFSFolder::SetClass(REFCLSID clsid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFSFolder::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFSFolder::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    HRESULT hr = E_FAIL;

    ZeroMemory(pstatstg, sizeof(*pstatstg));  // per COM conventions

    TCHAR szPath[MAX_PATH];
    _GetPath(szPath, ARRAYSIZE(szPath));

    HANDLE hFile = CreateFile(szPath, FILE_READ_ATTRIBUTES,
                        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_BACKUP_SEMANTICS, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        BY_HANDLE_FILE_INFORMATION bhfi;
    
        if (GetFileInformationByHandle(hFile, &bhfi))
        {
            ASSERT(bhfi.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
            pstatstg->type = STGTY_STORAGE;

            pstatstg->mtime = bhfi.ftLastWriteTime;
            pstatstg->ctime = bhfi.ftCreationTime;
            pstatstg->atime = bhfi.ftLastAccessTime;

            pstatstg->cbSize.HighPart = bhfi.nFileSizeHigh;
            pstatstg->cbSize.LowPart = bhfi.nFileSizeLow;

            pstatstg->grfMode = _grfFlags;

            pstatstg->reserved = bhfi.dwFileAttributes;

            hr = S_OK;
            if (!(grfStatFlag & STATFLAG_NONAME))
            {
                hr = SHStrDup(PathFindFileName(szPath), &pstatstg->pwcsName);
            }
        }
        CloseHandle(hFile);
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());
    return hr;
}

// ITransferDest

STDMETHODIMP CFSFolder::Advise(ITransferAdviseSink *pAdvise, DWORD *pdwCookie)
{
    if (_pAdvise)
        return E_FAIL;

    _pAdvise = pAdvise;
    _pAdvise->AddRef();

    if (pdwCookie)
        *pdwCookie = 1;

    return S_OK;
}

STDMETHODIMP CFSFolder::Unadvise(DWORD dwCookie)
{
    if (1 != dwCookie)
        return E_INVALIDARG;

    if (_pAdvise)
    {
        ATOMICRELEASE(_pAdvise);
        return S_OK;
    }

    return S_FALSE;
}

STDMETHODIMP CFSFolder::OpenElement(const WCHAR *pwcsName, STGXMODE grfMode, DWORD *pdwType, REFIID riid, void **ppunk)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFSFolder::CreateElement(const WCHAR *pwcsName, IShellItem *psiTemplate, STGXMODE grfMode, DWORD dwType, REFIID riid, void **ppunk)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFSFolder::MoveElement(IShellItem *psiItem, WCHAR *pwcsNewName, STGXMOVE grfOptions)
{
    return E_NOTIMPL;
}

STDMETHODIMP CFSFolder::DestroyElement(const WCHAR * pwcsName, STGXDESTROY grfOptions)
{
    return E_NOTIMPL;
}

STDAPI SHCreatePropStgOnFolder(LPCTSTR pszFolder, DWORD grfMode, IPropertySetStorage **ppss);

HRESULT CFSFolder::_LoadPropHandler()
{
    HRESULT hr = S_OK;
    if (_pstg)
    {
        hr = S_OK;
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        _GetPath(szPath, ARRAYSIZE(szPath));
        hr = StgOpenStorageOnFolder(szPath, _grfFlags, IID_PPV_ARG(IPropertySetStorage, &_pstg));
        // if (FAILED(hr))
        //    hr = SHCreatePropStgOnFolder(szPath, _grfFlags, &_pstg);
    }
    return hr;
}

STDMETHODIMP CFSFolder::Create(REFFMTID fmtid, const CLSID *pclsid, DWORD grfFlags, 
                               DWORD grfMode, IPropertyStorage **pppropstg)
{
    HRESULT hr = _LoadPropHandler();
    if (SUCCEEDED(hr))
        hr = _pstg->Create(fmtid, pclsid, grfFlags, grfMode, pppropstg);
    return hr;
}

STDMETHODIMP CFSFolder::Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage **pppropstg)
{
    HRESULT hr = _LoadPropHandler();
    if (SUCCEEDED(hr))
        hr = _pstg->Open(fmtid, grfMode, pppropstg);
    return hr;
}

STDMETHODIMP CFSFolder::Delete(REFFMTID fmtid)
{
    HRESULT hr = _LoadPropHandler();
    if (SUCCEEDED(hr))
        hr = _pstg->Delete(fmtid);
    return hr;
}

STDMETHODIMP CFSFolder::Enum(IEnumSTATPROPSETSTG ** ppenum)
{
    HRESULT hr = _LoadPropHandler();
    if (SUCCEEDED(hr))
        hr = _pstg->Enum(ppenum);
    return hr;
}

// IItemNameLimits methods

#define INVALID_NAME_CHARS      L"\\/:*?\"<>|"
STDMETHODIMP CFSFolder::GetValidCharacters(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars)
{
    *ppwszValidChars = NULL;
    return SHStrDup(INVALID_NAME_CHARS, ppwszInvalidChars);
}

STDMETHODIMP CFSFolder::GetMaxLength(LPCWSTR pszName, int *piMaxNameLen)
{
    TCHAR szPath[MAX_PATH];
    BOOL fShowExtension = _DefaultShowExt();
    LPITEMIDLIST pidl;

    StrCpyN(szPath, pszName, ARRAYSIZE(szPath));
    HRESULT hr = ParseDisplayName(NULL, NULL, szPath, NULL, &pidl, NULL);
    if (SUCCEEDED(hr))
    {
        LPCIDFOLDER pidf = _IsValidID(pidl);
        if (pidf)
        {
            fShowExtension = _ShowExtension(pidf);
        }
        ILFree(pidl);
    }

    hr = _GetPath(szPath, ARRAYSIZE(szPath));
    if (SUCCEEDED(hr))
    {
        if (PathAppend(szPath, pszName))
            hr = GetCCHMaxFromPath(szPath, (UINT *)piMaxNameLen, fShowExtension);
        else
            hr = E_FAIL;
    }
    return hr;
}


// ISetFolderEnumRestriction methods

STDMETHODIMP CFSFolder::SetEnumRestriction(DWORD dwRequired, DWORD dwForbidden)
{
    _dwEnumRequired = dwRequired;
    _dwEnumForbidden = dwForbidden;
    return S_OK;
}

// IOleCommandTarget stuff 
STDMETHODIMP CFSFolder::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;
    if (pguidCmdGroup == NULL)
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            // ONLY say that we support the stuff we support in ::OnExec
            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_REFRESH:
                rgCmds[i].cmdf = OLECMDF_ENABLED;
                break;

            default:
                rgCmds[i].cmdf = 0;
                break;
            }
            hr = S_OK;
        }
    }
    return hr;
}

STDMETHODIMP CFSFolder::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup == NULL)
    {
        switch (nCmdID)
        {
        case OLECMDID_REFRESH:
            _dwAttributes = -1;
            _bUpdateExtendedCols = TRUE;
            _tbDefShowExt = TRIBIT_UNDEFINED;
            _tbOfflineCSC = TRIBIT_UNDEFINED;
            hr = S_OK;
            break;
        }
    }
    return hr;
}

// global hook in the SHChangeNotify() dispatcher. note we get all change notifies
// here so be careful!
STDAPI CFSFolder_IconEvent(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra)
{
    switch (lEvent)
    {
    case SHCNE_ASSOCCHANGED:
        {
            FlushFileClass();   // flush them all
            HWND hwnd = GetDesktopWindow();
            if (IsWindow(hwnd))
                PostMessage(hwnd, DTM_SETUPAPPRAN, 0, 0);
        }
        break;
    }
    return S_OK;
}

//
//  317617 - Hacky update for the icon cache - ZekeL - 19-APR-2001
//  this is for defview to invalidate icon indeces that are indirected
//  specifically if you have a LNK file and its target changes icons
//  (like a CD will), then the LNK is updated by defview processing the 
//  SHCNE_UPDATEIMAGE and noticing that one of its items also matches
//  this image index.
//  
//  the righteous fix is to make SCN call into the fileicon cache
//  and reverse lookup any entries that match the icon index and invalidate
//  them.  that way we wouldnt miss anything.
//
STDAPI_(void) CFSFolder_UpdateIcon(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    LPCIDFOLDER pidf = CFSFolder::_IsValidID(pidl);
    if (pidf)
    {
        TCHAR szName[MAX_PATH];
        if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_FORPARSING, szName, ARRAYSIZE(szName))))
        {
            RemoveFromIconTable(szName);
        }
    }
}
        

// ugly wrappers for external clients, remove these as possible


STDAPI CFSFolder_CompareNames(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2)
{
    CFileSysItemString fsi1(pidf1), fsi2(pidf2);
    return ResultFromShort((short)lstrcmpi(fsi1.FSName(), fsi2.FSName()));
}

STDAPI_(DWORD) CFSFolder_PropertiesThread(void *pv)
{
    return CFSFolder::_PropertiesThread(pv);
}

STDAPI_(LPCIDFOLDER) CFSFolder_IsValidID(LPCITEMIDLIST pidl)
{
    return CFSFolder::_IsValidID(pidl);
}

STDAPI_(BOOL) CFSFolder_IsCommonItem(LPCITEMIDLIST pidl)
{
    return CFSFolder::_IsCommonItem(pidl);
}

CFSIconManager::CFSIconManager()
{
    _wszPath[0] = NULL;
    _cRef = 1;
}

HRESULT CFSIconManager::_Init(LPCITEMIDLIST pidl, IShellFolder *psf)
{
    HRESULT hr = S_OK;

    if ((psf == NULL) || (pidl == NULL))
        hr = E_INVALIDARG;

    if (SUCCEEDED(hr))
        hr = DisplayNameOf(psf, pidl, SHGDN_FORPARSING, _wszPath, ARRAYSIZE(_wszPath));
    return hr;
}

HRESULT CFSIconManager::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CFSIconManager, ICustomIconManager),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CFSIconManager::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFSIconManager::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}


STDMETHODIMP CFSIconManager::GetDefaultIconHandle(HICON *phIcon)
{
    HRESULT hr = S_OK;

    if (phIcon == NULL)
        hr = E_INVALIDARG;
        
    if (SUCCEEDED(hr))
    {
        WCHAR szCustomizedIconPath[MAX_PATH];
        int nCustomizedIconIndex;
        *phIcon = NULL;
        if (SUCCEEDED(hr = GetIcon(szCustomizedIconPath, ARRAYSIZE(szCustomizedIconPath), &nCustomizedIconIndex)))
        {
            _SetDefaultIconEx(FALSE);
        }
        SHFILEINFOW sfiw;
        if (SHGetFileInfoW(_wszPath, 0, &sfiw, sizeof(sfiw), SHGFI_ICON | SHGFI_LARGEICON))
        {
            *phIcon = sfiw.hIcon;
            hr = S_OK;
        }
        else
            hr = E_FAIL;

        if (szCustomizedIconPath[0] != NULL)
            _SetIconEx(szCustomizedIconPath, nCustomizedIconIndex, FALSE);
    }

    return hr;
}

STDMETHODIMP CFSIconManager::SetIcon(LPCWSTR pwszIconPath, int iIcon)
{
    return _SetIconEx(pwszIconPath, iIcon, TRUE);
}

STDMETHODIMP CFSIconManager::SetDefaultIcon()
{
    return _SetDefaultIconEx(TRUE);
}

HRESULT CFileFolderIconManager_Create(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    *ppv = NULL;
    CFileFolderIconManager *pffim = new CFileFolderIconManager;
    if (pffim)
    {
        hr =  pffim->_Init(pidl, psf);  
        if (SUCCEEDED(hr))
            hr = pffim->QueryInterface(riid, ppv);
        pffim->Release();
    }
    else
    {       
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CFileFolderIconManager::_SetIconEx(LPCWSTR pwszIconPath, int iIcon, BOOL fChangeNotify)
{
    HRESULT hr = S_OK;
    WCHAR wszExpandedIconPath[MAX_PATH];
    if (SHExpandEnvironmentStrings(pwszIconPath, wszExpandedIconPath, ARRAYSIZE(wszExpandedIconPath)) == 0)
        hr = E_FAIL;

    if (SUCCEEDED(hr))
    {
        SHFOLDERCUSTOMSETTINGS fcs;
        ZeroMemory(&fcs, sizeof(fcs));
        fcs.dwSize = sizeof(fcs);
        fcs.dwMask = FCSM_ICONFILE;
        fcs.pszIconFile = (LPWSTR) wszExpandedIconPath;
        fcs.cchIconFile = ARRAYSIZE(wszExpandedIconPath);
        fcs.iIconIndex = iIcon;

        hr = SHGetSetFolderCustomSettings(&fcs, _wszPath, FCS_FORCEWRITE);

        if (SUCCEEDED(hr) && fChangeNotify)
        {
        /*
            // Work Around - We need to pump a image change message for the folder icon change.
            // The right way is the following. But for some reason, the shell views which 
            // display the folder, don't update there images. So as a work around, we pump a
            // SHCNE_RENAMEFOLDER message. This works!. 
        
            SHFILEINFO sfi;
            if (SHGetFileInfo(pfpsp->szPath, 0, &sfi, sizeof(sfi), SHGFI_ICONLOCATION))
            {
                int iIconIndex = Shell_GetCachedImageIndex(sfi.szDisplayName, sfi.iIcon, 0);
                SHUpdateImage(PathFindFileName(sfi.szDisplayName), sfi.iIcon, 0, iIconIndex);
            }
        */
            SHChangeNotify(SHCNE_RENAMEFOLDER, SHCNF_PATH, _wszPath, _wszPath);
        }            
    }
    return hr;
}

STDMETHODIMP CFileFolderIconManager::_SetDefaultIconEx(BOOL fChangeNotify)
{
    HRESULT hr = E_FAIL;
    SHFOLDERCUSTOMSETTINGS fcs;
    
    ZeroMemory(&fcs, sizeof(fcs));
    fcs.dwSize = sizeof(fcs);
    fcs.dwMask = FCSM_ICONFILE;    
    fcs.pszIconFile = NULL;
    fcs.cchIconFile = 0;
    fcs.iIconIndex = 0;

    hr = SHGetSetFolderCustomSettings(&fcs, _wszPath, FCS_FORCEWRITE);

    if (SUCCEEDED(hr) && fChangeNotify)
    {
    /*
        // Work Around - We need to pump a image change message for the folder icon change.
        // The right way is the following. But for some reason, the shell views which 
        // display the folder, don't update there images. So as a work around, we pump a
        // SHCNE_RENAMEFOLDER message. This works!. 

        SHFILEINFO sfi;
        if (SHGetFileInfo(pfpsp->szPath, 0, &sfi, sizeof(sfi), SHGFI_ICONLOCATION))
        {
            int iIconIndex = Shell_GetCachedImageIndex(sfi.szDisplayName, sfi.iIcon, 0);
            SHUpdateImage(PathFindFileName(sfi.szDisplayName), sfi.iIcon, 0, iIconIndex);
        }
    */
        SHChangeNotify(SHCNE_RENAMEFOLDER, SHCNF_PATH, _wszPath, _wszPath);
    }
    return hr;
}

HRESULT CFileFolderIconManager::GetIcon(LPWSTR pszIconPath, int cchszIconPath, int *piIconIndex)
{
    HRESULT hr = S_OK;
    if ((pszIconPath == NULL) || (cchszIconPath < MAX_PATH) || (piIconIndex == NULL))
        hr = E_INVALIDARG;
        
    if (SUCCEEDED(hr))
    {
        SHFOLDERCUSTOMSETTINGS fcs;
        ZeroMemory(&fcs, sizeof(fcs));
        fcs.dwSize = sizeof(fcs);
        fcs.dwMask = FCSM_ICONFILE;  
        fcs.pszIconFile = pszIconPath;
        fcs.cchIconFile = cchszIconPath;

        hr = SHGetSetFolderCustomSettings(&fcs, _wszPath, FCS_READ);   
        if (SUCCEEDED(hr))
        {
            *piIconIndex = fcs.iIconIndex;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fileop.h ===
//----------------------------------------------------------------------------
// Exports from fileop.
//----------------------------------------------------------------------------

BOOL  ExtendedCreate(LPTSTR pName, DWORD dwFileAttributes, HFILE *pfh);
void  SetDateTime(HFILE fh, WORD wDate, WORD wTime);

#ifdef WIN32
#define SetFileRaw(fh)
#define IsSerialDevice(fh) FALSE
#else
void  SetFileRaw(HFILE fh);
BOOL  IsSerialDevice(HFILE fh);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fassoc.cpp ===
//
//  fassoc.cpp
//
//     IQueryAssociations shell implementations
//
// New storage - move this to a simple database if possible
// 
//  ****************************** User Customizations ********************************
//
// HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts    
//      |
//      |+ ".ext"  // the extension that has been customized
//      |   |- "Application" = "UserNotepad.AnyCo.1"
//      |   |+ "OpenWithList"   //  MRU for the Open With ctx menu
//      |
//    _ ...
//
//
//  ****************************** NoRoam Store **************************
//
// HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\NoRoam    
//      |
//      |+ ".ext"  (the extension that has been customized)
//      |   |- Application = "UserNotepad.AnyCo.1"
//      |
//    _ ...
//
// ***************************** Handlers **************************************
// (store detailed per handler file association info)
//
// HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\NoRoam\Associations
//    |


#include "shellprv.h"
#include <shpriv.h>
#include "clsobj.h"
#include <shstr.h>
#include <msi.h>
#include "fassoc.h"
#include <runtask.h>

inline BOOL _PathAppend(LPCTSTR pszBase, LPCTSTR pszAppend, LPTSTR pszOut, DWORD cchOut)
{
    return SUCCEEDED(StringCchPrintf(pszOut, cchOut, TEXT("%s\\%s"), pszBase, pszAppend));
}

STDAPI UserAssocSet(UASET set, LPCWSTR pszExt, LPCWSTR pszSet)
{
    HKEY hk = SHGetShellKey(SHELLKEY_HKCU_FILEEXTS, pszExt, TRUE);
    if (hk)
    {
        //  we should always clear
        SHDeleteValue(hk, NULL, L"Application");
        SHDeleteValue(hk, NULL, L"Progid");

        switch (set)
        {
        case UASET_APPLICATION:
            SHSetValue(hk, NULL, L"Application", REG_SZ, pszSet, CbFromCch(lstrlen(pszSet)+1));
            break;

        case UASET_PROGID:
            SHSetValue(hk, NULL, L"Progid", REG_SZ, pszSet, CbFromCch(lstrlen(pszSet)+1));
            break;
        }
        RegCloseKey(hk);
        return S_OK;
    }
    return HRESULT_FROM_WIN32(GetLastError());
}

void _MakeApplicationsKey(LPCTSTR pszApp, LPTSTR pszKey, DWORD cchKey)
{
    if (_PathAppend(TEXT("Applications"), pszApp, pszKey, cchKey))
    {
        // Currently we will only look up .EXE if an extension is not
        // specified
        if (*PathFindExtension(pszApp) == 0)
        {
            StrCatBuff(pszKey, TEXT(".exe"), cchKey);
        }
    }
}

DWORD _OpenApplicationKey(LPCWSTR pszApp, HKEY *phk, BOOL fCheckCommand = FALSE)
{
    //  look direct
    //  then try indirecting
    //  then try appending .exe
    WCHAR sz[MAX_PATH];
    _MakeApplicationsKey(pszApp, sz, ARRAYSIZE(sz));
    DWORD err = RegOpenKeyEx(HKEY_CLASSES_ROOT, sz, 0, MAXIMUM_ALLOWED, phk);
    if (err == ERROR_SUCCESS && fCheckCommand)
    {
        DWORD cch;
        if (ERROR_SUCCESS == SHQueryValueEx(*phk, TEXT("NoOpenWith"), NULL, NULL, NULL, NULL)
        || FAILED(AssocQueryStringByKey(0, ASSOCSTR_COMMAND, *phk, NULL, NULL, &cch)))
        {
            err = ERROR_ACCESS_DENIED;
            RegCloseKey(*phk);
            *phk = NULL;
        }
    }
    return err;
}

class CVersion
{
public:
    CVersion(LPCWSTR psz) : _pVer(0), _hrInit(S_FALSE) { StrCpyNW(_szPath, psz, ARRAYSIZE(_szPath)); }
    ~CVersion() { if (_pVer) LocalFree(_pVer); }

private:
    WCHAR _szPath[MAX_PATH];
    void *_pVer;
    HRESULT _hrInit;
};

typedef struct
{
    WORD wLanguage;
    WORD wCodePage;
} XLATE;

const static XLATE s_px[] =
{
    { 0, 0x04B0 }, // MLGetUILanguage, CP_UNICODE
    { 0, 0x04E4 }, // MLGetUILanguage, CP_USASCII
    { 0, 0x0000 }, // MLGetUILanguage, NULL
    { 0x0409, 0x04B0 }, // English, CP_UNICODE
    { 0x0409, 0x04E4 }, // English, CP_USASCII
    { 0x0409, 0x0000 }, // English, NULL
//    { 0x041D, 0x04B0 }, // Swedish, CP_UNICODE
//    { 0x0407, 0x04E4 }, // German, CP_USASCII
};

HKEY _OpenSystemFileAssociationsKey(LPCWSTR pszExt)
{
    WCHAR sz[MAX_PATH] = L"SystemFileAssociations\\";
    StrCatBuff(sz, pszExt, ARRAYSIZE(sz));
    HKEY hk = NULL;
    if (NOERROR != RegOpenKeyEx(HKEY_CLASSES_ROOT, sz, 0, MAXIMUM_ALLOWED, &hk))
    {
        DWORD cb = sizeof(sz) - sizeof(L"SystemFileAssociations\\");
        if (NOERROR == SHGetValue(HKEY_CLASSES_ROOT, pszExt, L"PerceivedType", NULL, sz+ARRAYSIZE(L"SystemFileAssociations\\")-1, &cb))
        {
            //  if (PerceivedType != System)
            RegOpenKeyEx(HKEY_CLASSES_ROOT, sz, 0, MAXIMUM_ALLOWED, &hk);
        }
    }
    return hk;
}

BOOL _IsSystemFileAssociations(LPCWSTR pszExt)
{
    HKEY hk = _OpenSystemFileAssociationsKey(pszExt);
    if (hk)
        RegCloseKey(hk);
        
    return hk != NULL;
}

class CTaskEnumHKCR : public CRunnableTask
{
public:
    CTaskEnumHKCR() : CRunnableTask(RTF_DEFAULT) {}
    // *** pure virtuals ***
    virtual STDMETHODIMP RunInitRT(void);

private:
    virtual ~CTaskEnumHKCR() {}
    
    void _AddFromHKCR();

};

void _AddProgidForExt(LPCWSTR pszExt)
{
    WCHAR szNew[MAX_PATH];
    DWORD cb = sizeof(szNew);
    if (NOERROR == SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szNew, &cb))
    {
        WCHAR sz[MAX_PATH];
        wnsprintf(sz, ARRAYSIZE(sz), L"%s\\OpenWithProgids", pszExt);
        SKSetValue(SHELLKEY_HKCU_FILEEXTS, sz, szNew, REG_NONE, NULL, NULL);
    }
}
    
#define IsExtension(s)   (*(s) == TEXT('.'))

void CTaskEnumHKCR::_AddFromHKCR()
{
    int i;
    TCHAR szClass[MAX_PATH];   
    BOOL fInExtensions = FALSE;

    for (i = 0; RegEnumKey(HKEY_CLASSES_ROOT, i, szClass, ARRAYSIZE(szClass)) == ERROR_SUCCESS; i++)
    {
        //  UNDOCUMENTED feature.  the enum is sorted,
        //  so we can just restrict ourselves to extensions 
        //  for perf and fun!
        if (fInExtensions)
        {
            if (!IsExtension(szClass))
                break;
        }
        else if (IsExtension(szClass))
        {
            fInExtensions = TRUE;
        }
        else
            continue;

        if (_IsSystemFileAssociations(szClass))
        {
            _AddProgidForExt(szClass);
        }
    }
}

HRESULT CTaskEnumHKCR::RunInitRT()
{
    //  delete something??
    _AddFromHKCR();
    return S_OK;
}

STDAPI CTaskEnumHKCR_Create(IRunnableTask **pptask)
{
    CTaskEnumHKCR *pteh = new CTaskEnumHKCR();
    if (pteh)
    {
        HRESULT hr = pteh->QueryInterface(IID_PPV_ARG(IRunnableTask, pptask));
        pteh->Release();
        return hr;
    }
    *pptask = NULL;
    return E_OUTOFMEMORY;
}
typedef enum
{
    AHTYPE_USER_APPLICATION     = -2,
    AHTYPE_ANY_APPLICATION      = -1,
    AHTYPE_UNDEFINED            = 0,
    AHTYPE_CURRENTDEFAULT,
    AHTYPE_PROGID,
    AHTYPE_APPLICATION,
} AHTYPE;

class CAssocHandler : public IAssocHandler
{
public:
    CAssocHandler() : _cRef(1) {}
    BOOL Init(AHTYPE type, LPCWSTR pszExt, LPCWSTR pszInit);
    
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IAssocHandler methods
    STDMETHODIMP GetName(LPWSTR *ppsz);
    STDMETHODIMP GetUIName(LPWSTR *ppsz);
    STDMETHODIMP GetIconLocation(LPWSTR *ppszPath, int *pIndex);
    STDMETHODIMP IsRecommended() { return _type > AHTYPE_UNDEFINED ? S_OK : S_FALSE; }
    STDMETHODIMP MakeDefault(LPCWSTR pszDescription);
    STDMETHODIMP Exec(HWND hwnd, LPCWSTR pszFile);
    STDMETHODIMP Invoke(void *pici, PCWSTR pszFile);

protected: // methods
    ~CAssocHandler();
    
    HRESULT _Exec(SHELLEXECUTEINFO *pei);
    BOOL _IsNewAssociation();
    void _GenerateAssociateNotify();
    HRESULT _InitKey();
    void _RegisterOWL();

protected: // members
    ULONG _cRef;
    IQueryAssociations *_pqa;
    HKEY _hk;
    ASSOCF _flags;
    AHTYPE _type;
    LPWSTR _pszExt;
    LPWSTR _pszInit;
    BOOL _fRegistered;
};

STDAPI CAssocHandler::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
    QITABENT(CAssocHandler, IAssocHandler),
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDAPI_(ULONG) CAssocHandler::AddRef()
{
   return ++_cRef;
}

STDAPI_(ULONG) CAssocHandler::Release()
{
    if (--_cRef > 0)
        return _cRef;

    delete this;
    return 0;    
}

BOOL _InList(LPCWSTR pszList, LPCWSTR pszExt, WORD chDelim)
{
    LPCWSTR pszMatch = StrStrI(pszList, pszExt);
    while (pszMatch)
    {
        LPCWSTR pszNext = (pszMatch+lstrlen(pszExt));
        if (chDelim == *pszNext || !*pszNext)
            return TRUE;
        pszMatch = StrStrI(pszNext+1, pszExt);
    }
    return FALSE;
}

// Create a new class key, and set its shell\open\command
BOOL _CreateApplicationKey(LPCTSTR pszPath)
{
    DWORD err = ERROR_FILE_NOT_FOUND;
    if (PathFileExistsAndAttributes(pszPath, NULL))
    {
        WCHAR szKey[MAX_PATH];
        WCHAR szCmd[MAX_PATH * 2];
        wnsprintf(szKey, ARRAYSIZE(szKey), L"Software\\Classes\\Applications\\%s\\shell\\open\\command", PathFindFileName(pszPath));
        //  if it is not an LFN app, pass unquoted args.
        wnsprintf(szCmd, ARRAYSIZE(szCmd), App_IsLFNAware(pszPath) ? L"\"%s\" \"%%1\"" : L"\"%s\" %%1", pszPath);
        err = SHSetValue(HKEY_CURRENT_USER, szKey, NULL, REG_SZ, szCmd, CbFromCchW(lstrlen(szCmd)+1));
    }
    return ERROR_SUCCESS == err;
}

BOOL CAssocHandler::Init(AHTYPE type, LPCWSTR pszExt, LPCWSTR pszInit)
{
    BOOL fRet = FALSE;
    _type = type;
    _pszExt = StrDup(pszExt);

    if (pszInit)
        _pszInit = StrDup(PathFindFileName(pszInit));

    if (_pszExt && (_pszInit || !pszInit))
    {
        if (SUCCEEDED(AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &_pqa))))
        {
            HKEY hk = NULL;
            _flags = ASSOCF_IGNOREBASECLASS;
            switch (type)
            {
            case AHTYPE_CURRENTDEFAULT:
                _flags |= ASSOCF_NOUSERSETTINGS;
                pszInit = pszExt;
                break;

            case AHTYPE_USER_APPLICATION:
            case AHTYPE_APPLICATION:
            case AHTYPE_ANY_APPLICATION:
                _OpenApplicationKey(_pszInit, &hk, TRUE);
                if (hk)
                {
                    if (type == AHTYPE_APPLICATION)
                    {
                        //  check if this type is supported
                        HKEY hkTypes;
                        if (ERROR_SUCCESS == RegOpenKeyEx(hk, TEXT("SupportedTypes"), 0, MAXIMUM_ALLOWED, &hkTypes))
                        {
                            //  the app only supports specific types
                            if (ERROR_SUCCESS != SHQueryValueEx(hkTypes, _pszExt, NULL, NULL, NULL, NULL))
                            {
                                //  this type is not supported
                                //  so it will be relegated to the not recommended list
                                RegCloseKey(hk);
                                hk = NULL;
                            }
                            RegCloseKey(hkTypes);
                        }
                    }
                }
                else if (type == AHTYPE_USER_APPLICATION)
                {
                    //  need to make up a key
                    if (_CreateApplicationKey(pszInit))
                        _OpenApplicationKey(_pszInit, &hk);
                }

                pszInit = NULL;
                _flags |= ASSOCF_INIT_BYEXENAME;
                break;

            case AHTYPE_PROGID:
            default:
                // _flags |= ...;
                break;
            }

            if (hk || pszInit)
            {
                if (SUCCEEDED(_pqa->Init(_flags, pszInit , hk, NULL)))
                {
                    WCHAR szExe[MAX_PATH];
                    DWORD cchExe = ARRAYSIZE(szExe);
                    //  we want to make sure there is something at the other end
                    fRet = SUCCEEDED(_pqa->GetString(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, NULL, szExe, &cchExe));
                    //  however, if the EXE has been marked as superhidden, 
                    //  then the consent decree UI has hidden the app
                    //  and it should not show up under the open with either
                    if (fRet)
                    {
                        fRet = !(IS_SYSTEM_HIDDEN(GetFileAttributes(szExe)));
                    }
                }
            }

            if (hk)
                RegCloseKey(hk);
        }
    }
    return fRet;
}
    

CAssocHandler::~CAssocHandler()
{
    if (_pqa)
        _pqa->Release();
    if (_pszExt)
        LocalFree(_pszExt);
    if (_pszInit)
        LocalFree(_pszInit);
    if (_hk)
        RegCloseKey(_hk);
}
HRESULT CAssocHandler::GetName(LPWSTR *ppsz)
{
    WCHAR sz[MAX_PATH];
    DWORD cch = ARRAYSIZE(sz);
    HRESULT hr = _pqa->GetString(_flags | ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, NULL, sz, &cch);
    if (SUCCEEDED(hr))
    {
        hr = SHStrDup(sz, ppsz);
    }
    return hr;
}

HRESULT CAssocHandler::GetUIName(LPWSTR *ppsz)
{
    WCHAR sz[MAX_PATH];
    DWORD cch = ARRAYSIZE(sz);
    HRESULT hr = _pqa->GetString(_flags | ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, NULL, sz, &cch);
    if (SUCCEEDED(hr))
    {
        hr = SHStrDup(sz, ppsz);
    }
    return hr;
}
HRESULT CAssocHandler::GetIconLocation(LPWSTR *ppszPath, int *pIndex)
{
//    HRESULT hr = _pqa->GetString(0, ASSOCSTR_DEFAULTAPPICON, NULL, psz, &cchT);
//    if (FAILED(hr))
    
    WCHAR sz[MAX_PATH];
    DWORD cch = ARRAYSIZE(sz);
    HRESULT hr = _pqa->GetString(_flags | ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, NULL, sz, &cch);
    if (SUCCEEDED(hr))
    {
        hr = SHStrDup(sz, ppszPath);
        if (*ppszPath)
        {
            *pIndex = PathParseIconLocation(*ppszPath);
        }
    }
    return hr;
}

STDAPI OpenWithListRegister(DWORD dwFlags, LPCTSTR pszExt, LPCTSTR pszVerb, HKEY hkProgid);

HRESULT CAssocHandler::_InitKey()
{
    if (!_hk)
    {
        return _pqa->GetKey(_flags, ASSOCKEY_SHELLEXECCLASS, NULL, &_hk);
    }
    return S_OK;
}

void CAssocHandler::_RegisterOWL()
{
    if (!_fRegistered && SUCCEEDED(_InitKey()))
    {
        OpenWithListRegister(0, _pszExt, NULL, _hk);
        _fRegistered = TRUE;
    }
}

HRESULT CAssocHandler::Exec(HWND hwnd, LPCWSTR pszFile)
{
    SHELLEXECUTEINFO ei = {0};    
    ei.cbSize = sizeof(ei);
    ei.hwnd = hwnd;
    ei.lpFile = pszFile;
    ei.nShow = SW_NORMAL;
    
    return _Exec(&ei);
}

HRESULT CAssocHandler::_Exec(SHELLEXECUTEINFO *pei)
{
    HRESULT hr = _InitKey();
    if (SUCCEEDED(hr))
    {
        pei->hkeyClass = _hk;
        pei->fMask |= SEE_MASK_CLASSKEY;
        
        if (ShellExecuteEx(pei))
        {
            _RegisterOWL();
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    return hr;
}

HRESULT CAssocHandler::Invoke(void *pici, PCWSTR pszFile)
{
    SHELLEXECUTEINFO ei;    
    HRESULT hr = ICIX2SEI((CMINVOKECOMMANDINFOEX *)pici, &ei);
    ei.lpFile = pszFile;
    if (SUCCEEDED(hr))
        hr = _Exec(&ei);

    return hr;
}

BOOL CAssocHandler::_IsNewAssociation()
{
    BOOL fRet = TRUE;
    WCHAR szOld[MAX_PATH];
    WCHAR szNew[MAX_PATH];
    if (SUCCEEDED(AssocQueryString(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, _pszExt, NULL, szOld, (LPDWORD)MAKEINTRESOURCE(ARRAYSIZE(szOld))))
    && SUCCEEDED(_pqa->GetString(ASSOCF_VERIFY | _flags, ASSOCSTR_EXECUTABLE, NULL, szNew, (LPDWORD)MAKEINTRESOURCE(ARRAYSIZE(szNew))))
    && (0 == lstrcmpi(szNew, szOld)))
    {
        //
        //  these have the same executable, trust 
        //  that when the exe installed itself, it did
        //  it correctly, and we dont need to overwrite 
        //  their associations with themselves :)
        //
        fRet = FALSE;
    }

    return fRet;
}

//
// This is a real hack, but for now we generate an idlist that looks
// something like: C:\*.ext which is the extension for the IDList.
// We use the simple IDList as to not hit the disk...
//
void CAssocHandler::_GenerateAssociateNotify()
{
    TCHAR szFakePath[MAX_PATH];
    LPITEMIDLIST pidl;

    GetWindowsDirectory(szFakePath, ARRAYSIZE(szFakePath));

    szFakePath[3] = L'*';
    StrCpyN(szFakePath + 4, _pszExt, ARRAYSIZE(szFakePath) - 4);            // "C:\*.foo"
    pidl = SHSimpleIDListFromPath(szFakePath);
    if (pidl)
    {
        // Now call off to the notify function.
        SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, pidl, NULL);
        ILFree(pidl);
    }
}

// return true if ok to continue
HRESULT CAssocHandler::MakeDefault(LPCWSTR pszDesc)
{
    HRESULT hr = E_FAIL;
    //  if the user is choosing the existing association
    //  or if we werent able to setup an Application ,
    //  then we want to leave it alone,     
    BOOL fForceUserCustomised = (AHTYPE_CURRENTDEFAULT == _type && S_FALSE == _pqa->GetData(0, ASSOCDATA_HASPERUSERASSOC, NULL, NULL, NULL));
    if (fForceUserCustomised || _IsNewAssociation())
    {
        switch (_type)
        {
        case AHTYPE_CURRENTDEFAULT:
            //  if it is reverting to the machine default
            //  then we want to eliminate the user association
            if (!fForceUserCustomised || !_pszInit)
            {
                hr = UserAssocSet(UASET_CLEAR, _pszExt, NULL);
                break;
            }
            //  else fall through to AHTYPE_PROGID
            //  this supports overriding shimgvw's (and others?)
            //  dynamic contextmenu

        case AHTYPE_PROGID:
            hr = UserAssocSet(UASET_PROGID, _pszExt, _pszInit);
            break;

        case AHTYPE_APPLICATION:
        case AHTYPE_ANY_APPLICATION:
        case AHTYPE_USER_APPLICATION:
            //  if there is a current association 
            //  then we just customize the user portion
            //  otherwise we update 
            if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, _pszExt, NULL, NULL, NULL, NULL))
            {
                // we don't overwrite the existing association under HKCR,
                // instead, we put it under HKCU. So now shell knows the new association
                // but third party software that mimics shell or does not use ShellExecute
                // will still use the old association in HKCR, which may confuse users.
                hr = UserAssocSet(UASET_APPLICATION, _pszExt, _pszInit);
            }
            else
            {
                if (SUCCEEDED(_InitKey()))
                {
                    //  there is no current progid
                    ASSERT(lstrlen(_pszExt) > 1); // because we always skip the "." below
                    WCHAR wszProgid[MAX_PATH];
                    WCHAR szExts[MAX_PATH];
                    int iLast = StrCatChainW(szExts, ARRAYSIZE(szExts) -1, 0, _pszExt);
                    //  double null term
                    szExts[++iLast] = 0;
                    wnsprintfW(wszProgid, ARRAYSIZE(wszProgid), L"%ls_auto_file", _pszExt+1);
                    HKEY hkDst;
                    ASSOCPROGID apid = {sizeof(apid), wszProgid, pszDesc, NULL, NULL, szExts};
                    if (SUCCEEDED(AssocMakeProgid(0, _pszInit, &apid, &hkDst)))
                    {
                        hr = AssocCopyVerbs(_hk, hkDst);
                        RegCloseKey(hkDst);
                    }
                }
            }
        }

        _GenerateAssociateNotify();
        _RegisterOWL();
    }
    

    //  if the application already
    //  existed, then it will
    //  return S_FALSE;
    return (S_OK == hr);
}

HRESULT _CreateAssocHandler(AHTYPE type, LPCWSTR pszExt, LPCWSTR pszInit, IAssocHandler **ppah)
{
    CAssocHandler *pah = new CAssocHandler();
    if (pah)
    {
        if (pah->Init(type, pszExt, pszInit))
        {
            *ppah = pah;
            return S_OK;
        }
        else
            pah->Release();
    }
    return E_FAIL;
}

STDAPI SHCreateAssocHandler(LPCWSTR pszExt, LPCWSTR pszApp, IAssocHandler **ppah)
{
    //  path to app/handler
    return _CreateAssocHandler(pszApp ? AHTYPE_USER_APPLICATION : AHTYPE_CURRENTDEFAULT, pszExt, pszApp, ppah);
}

#define SZOPENWITHLIST                  TEXT("OpenWithList")
#define REGSTR_PATH_EXPLORER_FILEEXTS   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts")
#define _OpenWithListMaxItems()         10

class CMRUEnumHandlers 
{
public:
    CMRUEnumHandlers() : _index(0) {}
    ~CMRUEnumHandlers() { FreeMRUList(_hmru);}

    BOOL Init(LPCWSTR pszExt);
    BOOL Next();
    LPCWSTR Curr() { return _szHandler;}

protected:
    HANDLE _hmru;
    int _index;
    WCHAR _szHandler[MAX_PATH];
};

BOOL CMRUEnumHandlers::Init(LPCWSTR pszExt)
{
    TCHAR szSubKey[MAX_PATH];
    //  Build up the subkey string.
    wnsprintf(szSubKey, SIZECHARS(szSubKey), TEXT("%s\\%s\\%s"), REGSTR_PATH_EXPLORER_FILEEXTS, pszExt, SZOPENWITHLIST);

    MRUINFO mi = {sizeof(mi), _OpenWithListMaxItems(), 0, HKEY_CURRENT_USER, szSubKey, NULL};

    _hmru = CreateMRUList(&mi);
    return (_hmru != NULL);
}

BOOL CMRUEnumHandlers::Next()
{
    ASSERT(_hmru);
    return (-1 != EnumMRUListW(_hmru, _index++, _szHandler, ARRAYSIZE(_szHandler)));
}

typedef struct OPENWITHLIST
{
    HKEY hk;
    DWORD dw;
    AHTYPE type;
} OWL;
class CEnumHandlers : public IEnumAssocHandlers
{
    friend HRESULT SHAssocEnumHandlers(LPCTSTR pszExtra, IEnumAssocHandlers **ppEnumHandler);

public:
    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IEnumAssocHandlers methods
    STDMETHODIMP Next(ULONG celt, IAssocHandler **rgelt, ULONG *pcelt);

protected:  // methods
    // Constructor & Destructor
    CEnumHandlers() : _cRef(1) {}
    ~CEnumHandlers();

    BOOL Init(LPCWSTR pszExt);
    
    BOOL _NextDefault(IAssocHandler **ppah);
    BOOL _NextHandler(HKEY hk, DWORD *pdw, BOOL fOpenWith, IAssocHandler **ppah);
    BOOL _NextProgid(HKEY *phk, DWORD *pdw, IAssocHandler **ppah);
    BOOL _NextMru(IAssocHandler **ppah);
    BOOL _NextOpenWithList(OWL *powl, IAssocHandler **ppah);

protected:  // members
    int _cRef;
    LPWSTR _pszExt;
    HKEY _hkProgids;
    DWORD _dwProgids;
    HKEY _hkUserProgids;
    DWORD _dwUserProgids;
    CMRUEnumHandlers _mru;
    BOOL _fMruReady;
    OWL _owlExt;
    OWL _owlType;
    OWL _owlAny;
    BOOL _fCheckedDefault;
};

BOOL CEnumHandlers::Init(LPCWSTR pszExt)
{
    _AddProgidForExt(pszExt);
    _pszExt = StrDup(pszExt);
    if (_pszExt)
    {
        //  known progids
        WCHAR szKey[MAX_PATH];
        wnsprintf(szKey, ARRAYSIZE(szKey), L"%s\\OpenWithProgids", pszExt);
        RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, MAXIMUM_ALLOWED, &_hkProgids);
        _hkUserProgids = SHGetShellKey(SHELLKEY_HKCU_FILEEXTS, szKey, FALSE);
        //  user's MRU
        _fMruReady = _mru.Init(pszExt);
        
        //  HKCR\.ext\OpenWithList
        wnsprintf(szKey, ARRAYSIZE(szKey), L"%s\\OpenWithList", pszExt);
        RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, MAXIMUM_ALLOWED, &_owlExt.hk);
        _owlExt.type = AHTYPE_APPLICATION;

        WCHAR sz[40];
        DWORD cb = sizeof(sz);
        if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, pszExt, L"PerceivedType", NULL, sz, &cb))
        {
            //  HKCR\SystemFileAssociations\type\OpenWithList
            wnsprintf(szKey, ARRAYSIZE(szKey), L"SystemFileAssociations\\%s\\OpenWithList", sz);
            RegOpenKeyEx(HKEY_CLASSES_ROOT, szKey, 0, MAXIMUM_ALLOWED, &_owlType.hk);
        }
        else
        {
            ASSERT(_owlType.hk == NULL);
        }
        _owlType.type = AHTYPE_APPLICATION;

        //  always append anytype to the end
        RegOpenKeyEx(HKEY_CLASSES_ROOT, L"Applications", 0, MAXIMUM_ALLOWED, &_owlAny.hk);
        _owlAny.type = AHTYPE_ANY_APPLICATION;

        return TRUE;
    }
    return FALSE;
}

//
//  CEnumHandlers implementation
//
CEnumHandlers::~CEnumHandlers()
{
    if (_pszExt)
        LocalFree(_pszExt);

    if (_hkProgids)
        RegCloseKey(_hkProgids);

    if (_hkUserProgids)
        RegCloseKey(_hkUserProgids);
        
    if (_owlExt.hk)
        RegCloseKey(_owlExt.hk);
    if (_owlType.hk)
        RegCloseKey(_owlType.hk);
    if (_owlAny.hk)
        RegCloseKey(_owlAny.hk);
}

STDAPI CEnumHandlers::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
    QITABENT(CEnumHandlers, IEnumAssocHandlers),
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDAPI_(ULONG) CEnumHandlers::AddRef()
{
   return ++_cRef;
}

STDAPI_(ULONG) CEnumHandlers::Release()
{
    if (--_cRef > 0)
        return _cRef;

    delete this;
    return 0;    
}

BOOL CEnumHandlers::_NextDefault(IAssocHandler **ppah)
{
    BOOL fRet = FALSE;
    if (!_fCheckedDefault && _pszExt)
    {
        WCHAR sz[MAX_PATH];
        DWORD cb = sizeof(sz);
        //  pass the progid if we have it
        if (ERROR_SUCCESS != SHGetValue(HKEY_CLASSES_ROOT, _pszExt, NULL, NULL, sz, &cb))
            *sz = 0;

        fRet = SUCCEEDED(_CreateAssocHandler(AHTYPE_CURRENTDEFAULT, _pszExt, *sz ? sz : NULL, ppah));
        _fCheckedDefault = TRUE;
    }
    return fRet;
}

BOOL CEnumHandlers::_NextProgid(HKEY *phk, DWORD *pdw, IAssocHandler **ppah)
{
    BOOL fRet = FALSE;
    while (*phk && !fRet)
    {
        TCHAR szProgid[MAX_PATH];
        DWORD cchProgid = ARRAYSIZE(szProgid);
        DWORD err = RegEnumValue(*phk, *pdw, szProgid, &cchProgid, NULL, NULL, NULL, NULL);

        if (ERROR_SUCCESS == err)        
        {
            fRet = SUCCEEDED(_CreateAssocHandler(AHTYPE_PROGID, _pszExt, szProgid, ppah));
            (*pdw)++;
        }
        else
        {
            RegCloseKey(*phk);
            *phk = NULL;
        }
    }
        
    return fRet;
}

BOOL CEnumHandlers::_NextMru(IAssocHandler **ppah)
{
    BOOL fRet = FALSE;
    while (_fMruReady && !fRet)
    {
        if (_mru.Next())
        {
            fRet = SUCCEEDED(_CreateAssocHandler(AHTYPE_APPLICATION, _pszExt, _mru.Curr(), ppah));
        }
        else
        {
            _fMruReady = FALSE;
        }
    }
    return fRet;
}


BOOL CEnumHandlers::_NextOpenWithList(OWL *powl, IAssocHandler **ppah)
{
    BOOL fRet = FALSE;
    while (powl->hk && !fRet)
    {
        TCHAR szHandler[MAX_PATH];
        DWORD cchHandler = ARRAYSIZE(szHandler);
        DWORD err = RegEnumKeyEx(powl->hk, powl->dw, szHandler, &cchHandler, NULL, NULL, NULL, NULL);

        if (err == ERROR_SUCCESS)
        {
            (powl->dw)++;
            fRet = SUCCEEDED(_CreateAssocHandler(powl->type, _pszExt, szHandler, ppah));
        }
        else
        {
            RegCloseKey(powl->hk);
            powl->hk = NULL;
        }
    }
    return fRet;
}

STDAPI CEnumHandlers::Next(ULONG celt, IAssocHandler **rgelt, ULONG *pcelt)
{
    UINT cNum = 0;
    ZeroMemory(rgelt, sizeof(rgelt[0])*celt);
    while (cNum < celt && _NextDefault(&rgelt[cNum]))
    {
        cNum++;
    }

    while (cNum < celt && _NextProgid(&_hkProgids, &_dwProgids, &rgelt[cNum]))
    {
        cNum++;
    }

    while (cNum < celt && _NextProgid(&_hkUserProgids, &_dwUserProgids, &rgelt[cNum]))
    {
        cNum++;
    }

    while (cNum < celt && _NextMru(&rgelt[cNum]))
    {
        cNum++;
    }

    while (cNum < celt && _NextOpenWithList(&_owlExt, &rgelt[cNum]))
    {
        cNum++;
    }

    while (cNum < celt && _NextOpenWithList(&_owlType, &rgelt[cNum]))
    {
        cNum++;
    }

    while (cNum < celt && _NextOpenWithList(&_owlAny, &rgelt[cNum]))
    {
        cNum++;
    }

    if (pcelt)
       *pcelt = cNum;

    return (0 < cNum) ? S_OK: S_FALSE;
}

//
// pszExtra:    NULL    - enumerate all handlers
//              .xxx    - enumerate handlers by file extension (we might internally map to content type)
//              Others  - not currently supported
//
STDAPI SHAssocEnumHandlers(LPCTSTR pszExt, IEnumAssocHandlers **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    CEnumHandlers *penum = new CEnumHandlers();

    *ppenum = NULL;

    if (penum)
    {
        if (penum->Init(pszExt))
        {
            *ppenum = penum;
            hr = S_OK;
        }
        else
            penum->Release();
    }
    return hr;
}

   
STDAPI_(BOOL) IsPathInOpenWithKillList(LPCTSTR pszPath)
{
    // return TRUE for invalid path
    if (!pszPath || !*pszPath)
        return TRUE;

    // get file name
    BOOL fRet = FALSE;
    LPCTSTR pchFile = PathFindFileName(pszPath);
    HKEY hkey;

    //  maybe should use full path for better resolution
    if (ERROR_SUCCESS == _OpenApplicationKey(pchFile, &hkey))
    {
        //  just check for the existence of the value....
        if (ERROR_SUCCESS == SHQueryValueEx(hkey, TEXT("NoOpenWith"), NULL, NULL, NULL, NULL))
        {
            fRet = TRUE;
        }

        RegCloseKey(hkey);
    }

    LPWSTR pszKillList;
    if (!fRet && SUCCEEDED(SKAllocValue(SHELLKEY_HKLM_EXPLORER, L"FileAssociation", TEXT("KillList"), NULL, (void **)&pszKillList, NULL)))
    {
        fRet = _InList(pszKillList, pchFile, L';');
        LocalFree(pszKillList);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\filetype.cpp ===
#include "shellprv.h"

#include "filetype.h"
#include "ftprop.h"
#include "ids.h"

HRESULT CreateFileTypePage(HPROPSHEETPAGE *phpsp)
{
    *phpsp = NULL;

    HRESULT hr;
    CFTPropDlg* pPropDlg = new CFTPropDlg();            
    if (pPropDlg)
    {
        PROPSHEETPAGE psp;

        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;
        psp.hInstance   = g_hinst;
        psp.pfnCallback = CFTDlg::BaseDlgPropSheetCallback;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_FILETYPEOPTIONS);
        psp.pfnDlgProc  = CFTDlg::BaseDlgWndProc;
        psp.lParam = (LPARAM)pPropDlg;

        *phpsp = CreatePropertySheetPage(&psp);
        
        if (*phpsp)
        {
            pPropDlg->AddRef();
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
        pPropDlg->Release();            
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    return hr;
}

class CFileTypes : public IShellPropSheetExt
{
public:
    CFileTypes() : _cRef(1) {}

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IShellPropSheetExt
    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pReplacePageFunc, LPARAM lParam);

private:    
    LONG _cRef;
};


STDMETHODIMP CFileTypes::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CFileTypes, IShellPropSheetExt),          // IID_IShellPropSheetExt
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CFileTypes::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFileTypes::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IShellPropSheetExt::AddPages
STDMETHODIMP CFileTypes::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    HPROPSHEETPAGE hpsp;
    
    // Make sure the FileIconTable is init properly.  If brought in
    // by inetcpl we need to set this true...
    FileIconInit(TRUE);
    
    // We need to run the unicode version on NT, to avoid all bugs
    // that occur with the ANSI version (due to unicode-to-ansi 
    // conversions of file names).
    
    HRESULT hr = CreateFileTypePage(&hpsp);
    if (SUCCEEDED(hr) && !pfnAddPage(hpsp, lParam))
    {
        DestroyPropertySheetPage(hpsp);
        hr = E_FAIL;
    }
    
    return hr;
}

// IShellPropSheetExt::ReplacePage
STDMETHODIMP CFileTypes::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam)
{
    HRESULT hr = E_NOTIMPL;

    if (EXPPS_FILETYPES == uPageID)
    {
        HPROPSHEETPAGE hpsp;
        
        // We need to run the unicode version on NT, to avoid all bugs
        // that occur with the ANSI version (due to unicode-to-ansi 
        // conversions of file names).
        
        hr = CreateFileTypePage(&hpsp);
        if (SUCCEEDED(hr) && !pfnReplaceWith(hpsp, lParam))
        {
            hr = E_FAIL;
        }
    }
    
    return hr;
}

STDAPI CFileTypes_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;   
    CFileTypes * pft = new CFileTypes;
    if (pft)
    {
        hr = pft->QueryInterface(riid, ppv);
        pft->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\filefldr.h ===
#include "fstreex.h"    // public stuff
#include "filetbl.h"
#include <caggunk.h>
#include <idhidden.h>
#include "lmcons.h"
#include "pidl.h"
#include <enumt.h>

class CFSDropTarget;
class CFSFolderViewCB;
class CFileSysEnum;
class CFSFolderEnumSTATSTG;
class CFSFolder;
class CFileSysItemString;

#define INDEX_PROPERTYBAG_HKCU          0
#define INDEX_PROPERTYBAG_HKLM          1
#define INDEX_PROPERTYBAG_DESKTOPINI    2

class CFSFolderPropertyBag : public IPropertyBag
{
    friend CFSFolder;
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR pszPropName, VARIANT *pVar, IErrorLog *pErrorLog);
    STDMETHODIMP Write(LPCOLESTR pszPropName, VARIANT *pVar);

protected:
    CFSFolderPropertyBag(CFSFolder *pff, DWORD grfMode);
    HRESULT _Init(LPCIDFOLDER pidfLast);

private:
    virtual ~CFSFolderPropertyBag();

    LONG _cRef;
    DWORD _grfMode;
    CFSFolder* _pFSFolder;
    IPropertyBag* _pPropertyBags[3];
};

#define UASTROFFW(pfsi, cb) (LPNWSTR)(((LPBYTE)(pfsi)) + (cb))
#define UASTROFFA(pfsi, cb) (LPSTR)(((LPBYTE)(pfsi)) + (cb))

// This enum is simply an index into c_rgFolderType and c_wvContent (TODO: merge these),
// therefore this *is* the Folder Type:
typedef enum {
    FVCBFT_NOTSPECIFIED = -1,
    FVCBFT_DOCUMENTS = 0,   // "0" is default until otherwise specified
    FVCBFT_MYDOCUMENTS,
    FVCBFT_PICTURES,
    FVCBFT_MYPICTURES,
    FVCBFT_PHOTOALBUM,
    FVCBFT_MUSIC,
    FVCBFT_MYMUSIC,
    FVCBFT_MUSICARTIST,
    FVCBFT_MUSICALBUM,
    FVCBFT_VIDEOS,
    FVCBFT_MYVIDEOS,
    FVCBFT_VIDEOALBUM,
    FVCBFT_USELEGACYHTT,
    FVCBFT_COMMONDOCUMENTS,
    FVCBFT_NUM_FOLDERTYPES
} FVCBFOLDERTYPE;


typedef enum
{
    FSINAME_NONE        = 0x0000,
    FSINAME_FS          = 0x0001,
    FSINAME_UI          = 0x0002,
    FSINAME_FSUI        = 0x0003,
    FSINAME_RESOURCE    = 0x0004,
    FSINAME_CLASS       = 0x0008,
} FSINAME;

class CFileSysItem
{
public:
    CFileSysItem(LPCIDFOLDER pidf);
    BOOL HasResourceName() { return ((_pidfx && _pidfx->offResourceA)); }
    BOOL IsLegacy() { return _pidfx == NULL; }
    BOOL CantRename(CFSFolder *pfs);
    LPCWSTR MayCopyFSName(BOOL fMustCopy, LPWSTR psz, DWORD cch);
    LPCWSTR MayCopyClassName(BOOL fMustCopy, LPTSTR pszClass, UINT cch);

protected:  // methods
    TRIBIT _IsMine(CFSFolder *pfs);
    BOOL _IsPersonalized();

protected:  // members
    LPCIDFOLDER _pidf;
    PCIDFOLDEREX _pidfx;
    PCIDPERSONALIZED _pidp;
};

class CFileSysItemString : public CFileSysItem
{
public:
    CFileSysItemString(LPCIDFOLDER pidf);
    LPCWSTR FSName();
    LPCSTR AltName();
    LPCWSTR UIName(CFSFolder *pfs);
    LPCWSTR ResourceName();
    LPCWSTR Class();
    HRESULT GetFindData(WIN32_FIND_DATAW *pfd);
    HRESULT GetFindDataSimple(WIN32_FIND_DATAW *pfd);
    BOOL ShowExtension(BOOL fDefShowExt);
    PERCEIVED PerceivedType();
    BOOL IsShimgvwImage();
    BOOL GetJunctionClsid(CLSID *pclsid, BOOL fShellExtOk);
    HRESULT AssocCreate(CFSFolder *pfs, BOOL fForCtxMenu, REFIID riid, void **ppv);
    DWORD ClassFlags(BOOL fNeedsIconBits) 
        { return _ClassFlags(NULL, fNeedsIconBits); }
    
protected:  // methods
    BOOL _LoadResource(CFSFolder *pfs);
    BOOL _MakePossessiveName(LPCWSTR pszFormat);
    int _GetPersonalizedRes(int csidl, BOOL fIsMine);
    void _FormatTheirs(LPCWSTR pszFormat);
    BOOL _ResourceName(LPWSTR psz, DWORD cch, BOOL fIsTheirs);
    LPCWSTR _Class();
    DWORD _ClassFlags(IUnknown *punkAssoc, BOOL fNeedsIconBits);
    void _QueryClassFlags(IAssociationArray *paa);
    void _QueryIconIndex(IAssociationArray *paa);

protected:  // members
    LPCWSTR _pszFSName;     // points inside the pidfx
    LPCWSTR _pszUIName;     // points inside the pidfx
    LPCWSTR _pszClass;      // points inside the pidfx
    DWORD _dwClass;
    FSINAME _fsin;
    WCHAR _sz[MAX_PATH];
};

class CFSAssocEnumData : public CEnumAssociationElements 
{
public:
    CFSAssocEnumData(BOOL fIsUnknown, CFSFolder *pfs, LPCIDFOLDER pidf);
    ~CFSAssocEnumData() { if (_pidl) ILFree(_pidl); }
    
protected:
    virtual BOOL _Next(IAssociationElement **ppae);
    
protected:
    BOOL _fIsUnknown;
    BOOL _fIsSystemFolder;
    WCHAR _szPath[MAX_PATH];
    LPITEMIDLIST _pidl;
};


// This struct is used for caching the column info
typedef struct {
    SHCOLUMNINFO shci;
    IColumnProvider *pcp;
    UINT iColumnId;  // This is the 'real' column number, think of it as an index to the scid, which can be provided multiple times
                     //  ie 3 column handlers each provide the same 5 cols, this goes from 0-4
} COLUMNLISTENTRY;

typedef struct
{
    UINT cbResource;
    CHAR szResource[MAX_PATH];
    IDPERSONALIZED idp;
} EXSTRINGS;

STDAPI_(BOOL) SetFolderString(BOOL fCreate, LPCTSTR pszFolder, LPCTSTR pszProvider, LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszData);
STDAPI_(BOOL) GetFolderString(LPCTSTR pszFolder, LPCTSTR pszProvider, LPTSTR pszOut, int cch, LPCTSTR pszKey);

STDAPI SHMultiFileProperties(IDataObject *pdtobj, DWORD dwFlags);
STDAPI CFSFolder_CreateLinks(HWND hwnd, IShellFolder *psf, IDataObject *pdtobj, LPCTSTR pszDir, DWORD fMask);
STDAPI CFSFolder_IconEvent(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);
STDAPI_(void) CFSFolder_UpdateIcon(IShellFolder *psf, LPCITEMIDLIST pidl);

class CFSFolder : public CAggregatedUnknown,
                  public IShellFolder2,
                  public IShellIcon,
                  public IShellIconOverlay,
                  public IPersistFolder3,
                  public IStorage,
                  public ITransferDest,
                  public IPropertySetStorage,
                  public IItemNameLimits,
                  public IContextMenuCB,
                  public ISetFolderEnumRestriction,
                  public IOleCommandTarget
{
    friend CFSFolderViewCB;
    friend CFSDropTarget;
    friend CFileSysEnum;
    friend CFSFolderEnumSTATSTG;
    friend CFSFolderPropertyBag;
    friend CFileSysItem;
    friend CFileSysItemString;
    friend CFSAssocEnumData;
    
    // these are evil, get rid of as many of these as possible
    friend HRESULT SHMultiFileProperties(IDataObject *pdtobj, DWORD dwFlags);
    friend HRESULT CFSFolder_CreateLinks(HWND hwnd, IShellFolder *psf, IDataObject *pdtobj, LPCTSTR pszDir, DWORD fMask);
    friend HRESULT CFSFolder_IconEvent(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);
    friend void CFSFolder_UpdateIcon(IShellFolder *psf, LPCITEMIDLIST pidl);
    friend HRESULT CFSFolder_CompareNames(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    friend DWORD CFSFolder_PropertiesThread(void *pv);
    friend HRESULT CFSFolder_CreateFolder(IUnknown *punkOuter, LPBC pbc, LPCITEMIDLIST pidl, 
                              const PERSIST_FOLDER_TARGET_INFO *pf, REFIID riid, void **ppv);
    friend LPCIDFOLDER CFSFolder_IsValidID(LPCITEMIDLIST pidl);
    friend BOOL CFSFolder_IsCommonItem(LPCITEMIDLIST pidl);

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv) { return CAggregatedUnknown::QueryInterface(riid, ppv); };
    STDMETHODIMP_(ULONG) AddRef(void)   { return CAggregatedUnknown::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void)  { return CAggregatedUnknown::Release(); };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszName, ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwndOwner, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST * ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid);

    // IPersist
    STDMETHODIMP GetClassID(LPCLSID lpClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);

    // IPersistFolder3
    STDMETHODIMP InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *pfti);
    STDMETHODIMP GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *pfti);

    // IShellIcon methods
    STDMETHODIMP GetIconOf(LPCITEMIDLIST pidl, UINT flags, int *piIndex);

    // IShellIconOverlay methods
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int * pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int * pIndex);

    // IStorage
    STDMETHODIMP CreateStream(LPCWSTR pszRel, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStream **ppstm);
    STDMETHODIMP OpenStream(LPCWSTR pszRel, VOID *reserved1, DWORD grfMode, DWORD reserved2, IStream **ppstm);                
    STDMETHODIMP CreateStorage(LPCWSTR pszRel, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStorage **ppstg);        
    STDMETHODIMP OpenStorage(LPCWSTR pszRel, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage **ppstg);;
    STDMETHODIMP CopyTo(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest);        
    STDMETHODIMP MoveElementTo(LPCWSTR pszRel, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags);        
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP EnumElements(DWORD reserved1, void *reserved2, DWORD reserved3, IEnumSTATSTG **ppenum);        
    STDMETHODIMP DestroyElement(LPCWSTR pszRel);        
    STDMETHODIMP RenameElement(LPCWSTR pwcsOldName, LPCWSTR pwcsNewName);        
    STDMETHODIMP SetElementTimes(LPCWSTR pszRel, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime);
    STDMETHODIMP SetClass(REFCLSID clsid);        
    STDMETHODIMP SetStateBits(DWORD grfStateBits, DWORD grfMask);        
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);

    // ITransferDest
    STDMETHODIMP Advise(ITransferAdviseSink *pAdvise, DWORD *pdwCookie);
    STDMETHODIMP Unadvise(DWORD dwCookie);
    STDMETHODIMP OpenElement(const WCHAR *pwcsName, STGXMODE grfMode, DWORD *pdwType, REFIID riid, void **ppunk);
    STDMETHODIMP CreateElement(const WCHAR *pwcsName, IShellItem *psiTemplate, STGXMODE grfMode, DWORD dwType, REFIID riid, void **ppunk);
    STDMETHODIMP MoveElement(IShellItem *psiItem, WCHAR  *pwcsNewName, STGXMOVE grfOptions);
    STDMETHODIMP DestroyElement(const WCHAR *pwcsName, STGXDESTROY grfOptions);

    // IPropertySetStorage methods
    STDMETHODIMP Create(REFFMTID fmtid, const CLSID * pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Delete(REFFMTID fmtid);
    STDMETHODIMP Enum(IEnumSTATPROPSETSTG** ppenum);

    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IItemNameLimits
    STDMETHODIMP GetValidCharacters(LPWSTR *ppwszValidChars, LPWSTR *ppwszInvalidChars);
    STDMETHODIMP GetMaxLength(LPCWSTR pszName, int *piMaxNameLen);

    // ISetFolderEnumRestriction
    STDMETHODIMP SetEnumRestriction(DWORD dwRequired, DWORD dwForbidden);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    CFSFolder(IUnknown *punkOuter);

protected:
    LPCITEMIDLIST _GetIDList() { return _pidl; };

    HRESULT v_InternalQueryInterface(REFIID riid, void **ppv);
    virtual ~CFSFolder();

    HRESULT _GetPathForItems(LPCIDFOLDER pidfParent, LPCIDFOLDER pidfLast, LPTSTR pszPath, DWORD cchPath);
    HRESULT _GetPathForItem(LPCIDFOLDER pidf, LPWSTR pszPath, DWORD cchPath);
    HRESULT _GetPath(PTSTR pszPath, DWORD cchPath);
    static HRESULT _GetAltDisplayName(LPCIDFOLDER pidf, LPTSTR pszName, DWORD cchName);
    static HRESULT _MakePossessiveName(LPCTSTR pszFile, LPCTSTR pszOwner, LPTSTR pszBuffer, INT cchBuffer);
    HRESULT _GetUsersDisplayName(LPCTSTR pszOwner, LPTSTR pszBuffer, INT cchBuffer);
    HRESULT _SetLocalizedDisplayName(LPCIDFOLDER pidf, LPCTSTR pszName);
    void _UpdateItem(LPCIDFOLDER pidf);

    DWORD _Attributes();
    UINT _GetCSIDL();
    BOOL _IsCSIDL(UINT csidl);
    UINT _GetItemExStrings(LPCIDFOLDER pidfSimpleParent, const WIN32_FIND_DATA *pfd, EXSTRINGS *pxs);
    HRESULT _CreateIDList(const WIN32_FIND_DATA *pfd, LPCIDFOLDER pidfSimpleParent, LPITEMIDLIST *ppidl);
    HRESULT _Properties(LPCITEMIDLIST pidlParent, IDataObject *pdtobj, LPCTSTR pStartPage);
    HRESULT _Reset();
    HRESULT _CreateInstance(HWND hwnd, IDropTarget** ppdt);
    HRESULT _CreateEnum(IUnknown *punk, HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum);
    HRESULT _GetJunctionForBind(LPCIDFOLDER pidf, LPIDFOLDER *ppidfBind, LPCITEMIDLIST *ppidlRight);
    LPCTSTR _BindHandlerName(REFIID riid);
    HRESULT _Bind(LPBC pbc, LPCIDFOLDER pidf, REFIID riid, void **ppv);
    HRESULT _LoadHandler(LPCIDFOLDER pidf, DWORD grfMode, LPCTSTR pszHandlerType, REFIID riid, void **ppv);
    HRESULT _HandlerCreateInstance(LPCIDFOLDER pidf, PCWSTR pszClsid, DWORD grfMode, REFIID riid, void **ppv);
    HRESULT _CreateShimgvwExtractor(LPCIDFOLDER pidf, REFIID riid, void **ppv);
    BOOL _IsSlowPath();
    HRESULT _GetToolTipForItem(LPCIDFOLDER pidf, REFIID riid, void **ppv);
    HRESULT _GetIntroText(LPCIDFOLDER pidf, WCHAR* pwszIntroText, UINT cchIntroText);

    // GetUIObjectOf() helpers.
    HRESULT _GetContextMenu(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv);
    HRESULT _GetDataObject(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv);
    HRESULT _GetDropTarget(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv);
    HRESULT _GetAssoc(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv);
    HRESULT _GetExtractIcon(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv);
    HRESULT _GetCustomIconManager(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv);
    HRESULT _GetExtractImage(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv);
    HRESULT _GetExtractLogo(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv);
    HRESULT _GetQueryInfo(HWND hwnd, LPCITEMIDLIST *apidl, UINT cidl, LPCIDFOLDER pidf, REFIID riid, void **ppv);

    // GetDetailsEx() helpers.
    HRESULT _GetFindData(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetDescriptionId(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetFolderIntroText(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetSize(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetFreeSpace(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetLastWriteTime(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetCreateTime(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetLastAccessTime(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetDirectory(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetInfotip(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetHtmlInfotipFile(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetAttributesDescription(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetAttributesDescriptionBuilder(LPWSTR szAttributes, size_t cchAttributes, LPWSTR szAttribute);
    HRESULT _GetLinkTarget(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetNetworkLocation(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetComputerName(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);
    HRESULT _GetComputerName_FromPath(PCWSTR pwszPath, VARIANT *pv);
    HRESULT _GetComputerName_FromUNC(PWSTR pwszPath, VARIANT *pv);
    HRESULT _GetCSCStatus(LPCIDFOLDER pidf, LPCSHCOLUMNID pscid, VARIANT *pv);

    BOOL _GetFolderFlags(LPCIDFOLDER pidf, UINT *prgfFlags);
    BOOL _GetFolderIconPath(LPCIDFOLDER pidf, LPTSTR pszIcon, int cchMax, UINT *pIndex);
    static DWORD   CALLBACK _PropertiesThread(void *pv);
    static DWORD _GetClassFlags(LPCIDFOLDER pidf);
    UINT _GetContextMenuKeys(LPCIDFOLDER pidf, HKEY *aKeys, UINT cKeys, IAssociationArray **ppaa);
    BOOL _CheckDefaultIni(LPCIDFOLDER pidfLast, LPTSTR pszIniPath, DWORD cchIniPath);

    HRESULT _CompareExtendedProp(int iColumn, LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    static HRESULT _CompareModifiedDate(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    static HRESULT _CompareCreateTime(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    static HRESULT _CompareAccessTime(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    static HRESULT _CompareAttribs(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    static HRESULT _CompareFileTypes(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);
    HRESULT _CompareNames(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2, BOOL fCaseSensitive, BOOL fCanonical);
    static HRESULT _CompareFolderness(LPCIDFOLDER pidf1, LPCIDFOLDER pidf2);

    BOOL _DefaultShowExt();
    BOOL _ShowExtension(LPCIDFOLDER pidf);
    static HRESULT _GetClassKey(LPCIDFOLDER pidf, HKEY *phkeyProgID);

    // file system, non junction point folder
    static BOOL _IsJunction(LPCIDFOLDER pidf);
    static BYTE _GetType(LPCIDFOLDER pidf);
    static BOOL _IsSimpleID(LPCIDFOLDER pidf);
    static LPIDFOLDER _FindLastID(LPCIDFOLDER pidf);
    static LPIDFOLDER _Next(LPCIDFOLDER pidf);
    static LPCIDFOLDER _IsValidID(LPCITEMIDLIST pidl);
    static LPCIDFOLDER _IsValidIDHack(LPCITEMIDLIST pidl);
    static BOOL _IsCommonItem(LPCITEMIDLIST pidl);

    static BOOL _IsFile(LPCIDFOLDER pidf);
    static BOOL _IsFolder(LPCIDFOLDER pidf);
    static BOOL _IsFileFolder(LPCIDFOLDER pidf);
    static BOOL _IsSystemFolder(LPCIDFOLDER pidf);
    static BOOL _IsReal(LPCIDFOLDER pidf);

    BOOL _IsSelfSystemFolder();
    BOOL _HasLocalizedFileNames();

    static BOOL _IsOffline(LPCIDFOLDER pidf) { return pidf && (pidf->wAttrs & FILE_ATTRIBUTE_OFFLINE); }
    BOOL _IsOfflineCSC(LPCIDFOLDER pidf);
    BOOL _IsOfflineCSC(LPCTSTR pszPath);

    HRESULT _InitFolder(IBindCtx *pbc, LPCIDFOLDER pidf, IUnknown **ppunk);
    BOOL _GetMountingPointInfo(LPCIDFOLDER pidf, LPTSTR pszMountPoint, DWORD cchMountPoint);
    HRESULT _CreateContextMenu(HWND hwnd, LPCIDFOLDER pidf, LPCITEMIDLIST *apidl, UINT cidl, IContextMenu **ppcm);
    HRESULT _AssocCreate(LPCIDFOLDER pidf, REFIID riid, void **ppv);
    static BOOL _GetJunctionClsid(LPCIDFOLDER pidf, CLSID *pclsidRet);
    static LPCTSTR _GetTypeName(LPCIDFOLDER pidf);
    static HRESULT _GetTypeNameBuf(LPCIDFOLDER pidf, LPTSTR pszName, int cchNameMax);
    static LPWSTR _CopyName(LPCIDFOLDER pidf, LPWSTR pszName, UINT cchName);
    static int _CopyUIName(LPCIDFOLDER pidf, LPTSTR pszName, UINT cchName);
    static HRESULT _AppendItemToPath(PTSTR pszPath, DWORD cchPath, LPCIDFOLDER pidl);
    static LPTSTR _CopyAltName(LPCIDFOLDER pidf, LPTSTR pszName, UINT cchName);
    static LPCSTR _GetAltName(LPCIDFOLDER pidf);
    static HRESULT _FindDataFromIDFolder(LPCIDFOLDER pidf, WIN32_FIND_DATAW *pfd, BOOL fAllowSimplePid);
    static DWORD _GetUID(LPCIDFOLDER pidf);
    static LPCIDFOLDER _FindJunction(LPCIDFOLDER pidf);
    static LPCITEMIDLIST _FindJunctionNext(LPCIDFOLDER pidf);

    ULONGLONG _Size(LPCIDFOLDER pidf);
    HRESULT _NormalGetDisplayNameOf(LPCIDFOLDER pidf, STRRET *pStrRet);
    HRESULT _NormalDisplayName(LPCIDFOLDER pidf, LPWSTR psz, UINT cch);
    BOOL _GetBindCLSID(IBindCtx *pbc, LPCIDFOLDER pidf, CLSID *pclsid);
    HRESULT _InitColData(LPCIDFOLDER pidf, SHCOLUMNDATA* pscd);
    LPIDFOLDER _MarkAsJunction(LPCIDFOLDER pidfSimpleParent, LPIDFOLDER pidf, LPCTSTR pszName);
    HRESULT _CreateIDListFromName(LPCTSTR pszName, DWORD dwAttribs, IBindCtx *pbc, LPITEMIDLIST *ppidl);
    BOOL _CanSeeInThere(LPCTSTR pszName);
    HRESULT _ParseSimple(LPCWSTR pszPath, const WIN32_FIND_DATA *pfdLast, LPITEMIDLIST *ppidl);
    HRESULT _FindDataFromName(LPCTSTR pszName, DWORD dwAttribs, IBindCtx *pbc, WIN32_FIND_DATA **ppfd);
    HRESULT _CheckDriveRestriction(HWND hwnd, REFIID riid);
    HRESULT _CreateUIHandler(REFIID riid, void **ppv);
    BOOL _IsNetPath();
    int _GetDefaultFolderIcon();
    HRESULT _CreateDefExtIcon(LPCIDFOLDER pidf, REFIID riid, void **ppxicon);
    HRESULT _CreateFileFolderDefExtIcon(LPCIDFOLDER pidf, REFIID riid, void **ppxicon);
    HRESULT _CreatePerInstanceDefExtIcon(LPCIDFOLDER pidf, DWORD shcf, REFIID riid, void **ppxicon);
    HRESULT _CreatePerClassDefExtIcon(LPCIDFOLDER pidf, DWORD shcf, REFIID riid, void **ppxicon);

    BOOL _FindColHandler(UINT iCol, UINT iN, COLUMNLISTENTRY *pcle);
    void _AdjustDefShowColumn(UINT iColumn, DWORD *pdwState);
    BOOL _ShouldShowExtendedColumn(const SHCOLUMNID* pscid);
    HRESULT _MapSCIDToColumn(const SHCOLUMNID* pscid, UINT* puCol);
    HRESULT _ExtendedColumn(LPCIDFOLDER pidf, UINT iColumn, SHELLDETAILS *pDetails);
    HRESULT _LoadColumnHandlers();
    HRESULT _GetOverlayInfo(LPCITEMIDLIST pidl, int * pIndex, DWORD dwFlags);
    void _DestroyColHandlers();

    HRESULT _GetFullPath(LPCWSTR pszRelPath, LPWSTR pszFull);
    HRESULT _Delete(LPCWSTR pszFile);
    HRESULT _OpenCreateStorage(LPCWSTR pwcsName, DWORD grfMode, IStorage **ppstg, BOOL fCreate);
    HRESULT _OpenCreateStream(LPCWSTR pwcsName, DWORD grfMode, IStream **ppstm, BOOL fCreate);
    HRESULT _SetStgMode(DWORD grfMode);

    HRESULT _LoadPropHandler();

    HRESULT _CreateFolderPropertyBag(DWORD grfMode, LPCIDFOLDER pidfLast, REFIID riid, void **ppv);

    HRESULT _GetPropertyUI();

    LPITEMIDLIST        _pidl;                  // Absolute IDList (location in the name space)
    LPITEMIDLIST        _pidlTarget;            // Absolute IDList for folder target (location in namespace to enumerate)
                                                // WARNING: _csidlTrack overrides _pidlTarget
    LPTSTR              _pszPath;               // file system path (may be different from _pidl)
    LPTSTR              _pszNetProvider;        // network provider (for net calls we may need to make)

    CLSID               _clsidBind;             // use CLSID_NULL for normal case

    int                 _cHiddenFiles;          // view callback and enumerator share these
    ULONGLONG           _cbSize;

    UINT                _csidl;                 // CSIDL_ value of this folder (if known)
    DWORD               _dwAttributes;          // attributes of this folder (if known)
    int                 _csidlTrack;            // CSIDL_ that we follow dynamically

    BOOL                _fCachedCLSID : 1;      // clsidView is already cached
    BOOL                _fHasCLSID    : 1;      // clsidView has a valid CLSID
    CLSID               _clsidView;             // CLSID for View object
    HDSA                _hdsaColHandlers;       // cached list of columns and handlers
    DWORD               _dwColCount;            // count of unique columns
    int                 _iFolderIcon;           // icon for sub folders to inherit
    BOOL                _bUpdateExtendedCols;   // set to TRUE in response to SFVM_INSERTITEM callback, passed to IColumnProvider::GetItemData then cleared 
    BOOL                _bSlowPath;             // Lazy-calculated value of whether the folder is on a slow path
    BOOL                _fDontForceCreate;      // don't succeed with STGM_CREATE passed to ParseDisplayName for a non-existent item
    FVCBFOLDERTYPE      _nFolderType;
  
    TRIBIT _tbHasLocalizedFileNamesSection; // Lazy-calculated value of whether the folder has a desktop.ini with a LocalizedFileNames section
    TRIBIT _tbDefShowExt; // cache of SHGetSetSettings(SSF_SHOWEXTENSIONS)
    TRIBIT _tbOfflineCSC; // cache of _IsOfflineCSC(_pidl)

    DWORD _grfFlags;

    DWORD               _dwEnumRequired;        // SetEnumRestriction
    DWORD               _dwEnumForbidden;       // SetEnumRestriction

    IPropertySetStorage *_pstg;
    IPropertyUI         *_pPropertyUI;
    ITransferAdviseSink * _pAdvise;
};

// fstree.cpp
STDAPI CFSFolderCallback_Create(CFSFolder *pFSFolder, IShellFolderViewCB **ppsfvcb);
STDAPI CFSDropTarget_CreateInstance(CFSFolder* pFSFolder, HWND hwnd, IDropTarget** ppdt);
STDAPI CFSFolder_CreateEnum(CFSFolder *pfsf, HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum);
STDAPI CFolderExtractImage_Create(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppvObj);

class CFSIconManager : public ICustomIconManager
{
public:

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICustomIconManager
    STDMETHODIMP SetIcon(LPCWSTR pszIconPath,int iIcon);
    STDMETHODIMP SetDefaultIcon();
    STDMETHODIMP GetDefaultIconHandle(HICON *phIcon);
    STDMETHODIMP GetIcon(LPWSTR pszIconPath, int cchszIconPath, int *piIconIndex) = 0;
   
protected:
    HRESULT _Init(LPCITEMIDLIST pidl, IShellFolder *psf);
    WCHAR _wszPath[MAX_PATH];
    CFSIconManager();
    virtual STDMETHODIMP _SetIconEx(LPCWSTR pszIconPath,int iIconIndex, BOOL fChangeNotify) = 0;
    virtual STDMETHODIMP _SetDefaultIconEx(BOOL fChangeNotify) = 0;

private:
    long _cRef;
};

class CFileFolderIconManager : public CFSIconManager
{
public:
    friend HRESULT CFileFolderIconManager_Create(IShellFolder *psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv);
    
    // ICustomIconManager
    STDMETHODIMP GetIcon(LPWSTR pszIconPath, int cchszIconPath, int *piIconIndex);
protected:
    STDMETHODIMP _SetIconEx(LPCWSTR pszIconPath,int iIconIndex, BOOL fChangeNotify);
    STDMETHODIMP _SetDefaultIconEx(BOOL fChangeNotify);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\filetbl.h ===
#ifndef _FILETBL_H
#define _FILETBL_H

#define SHIL_COUNT  (SHIL_LAST + 1)

// fileicon.c
STDAPI_(int) SHAddIconsToCache(HICON rghicon[SHIL_COUNT], LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags);

STDAPI AddToIconTable(LPCTSTR szFile, int iIconIndex, UINT uFlags, int iIndex);
STDAPI_(void) RemoveFromIconTable(LPCTSTR szFile);
STDAPI_(void) FlushIconCache(void);
STDAPI_(int)  GetFreeImageIndex(void);

STDAPI_(void) IconCacheFlush(BOOL fForce);
STDAPI_(BOOL) IconCacheSave(void);
STDAPI_(BOOL) IconCacheRestore(SIZE rgsize[SHIL_COUNT], UINT flags);
STDAPI_(void) _IconCacheDump(void);       // DEBUG ONLY

STDAPI_(int) LookupIconIndex(LPCTSTR pszFile, int iIconIndex, UINT uFlags);
STDAPI_(DWORD) LookupFileClass(LPCTSTR szClass);
STDAPI_(void)  AddFileClass(LPCTSTR szClass, DWORD dw);
STDAPI_(void)  FlushFileClass(void);
STDAPI_(BOOL)  IconIndexInFileClassTable(int iIndex);
STDAPI_(LPCTSTR) LookupFileClassName(LPCTSTR szClass);
STDAPI_(LPCTSTR) AddFileClassName(LPCTSTR szClass, LPCTSTR szClassName);
STDAPI_(UINT) LookupFileSCIDs(LPCTSTR pszClass, SHCOLUMNID *pascidOut[]);
STDAPI_(void) AddFileSCIDs(LPCTSTR pszClass, SHCOLUMNID ascidIn[], UINT cProps);

//  OpenAsTypes
typedef enum {
    GEN_CUSTOM          = -3,
    GEN_UNSPECIFIED     = -2,
    GEN_FOLDER          = -1,
    GEN_UNKNOWN         = 0,
    GEN_TEXT,
    GEN_IMAGE,
    GEN_AUDIO,
    GEN_VIDEO,
    GEN_COMPRESSED,
} PERCEIVED;

STDAPI_(PERCEIVED) LookupFilePerceivedType(LPCTSTR pszClass);
STDAPI_(void) AddFilePerceivedType(LPCTSTR pszClass, PERCEIVED gen);

PERCEIVED GetPerceivedType(IShellFolder *psf, LPCITEMIDLIST pidl);

//  g_MaxIcons is limit on the number of icons in the cache
//  when we reach this limit we will start to throw icons away.
//
extern int g_MaxIcons;               // panic limit for cache size
#ifdef DEBUG
#define DEF_MAX_ICONS   200         // to test the flush code more offten
#else
#define DEF_MAX_ICONS   500         // normal end user number
#endif

// refreshes g_MaxIcons from registry.  returns TRUE if value changed.
BOOL QueryNewMaxIcons(void);

// g_iLastSysIcon is an indicator that is used to help determine which icons
// should be flushed and which icons shouldn't.  In the EXPLORER.EXE process,
// the first 40 or so icons should be saved.  On all other processes, only
// the icon overlay's should be saved.
extern UINT g_iLastSysIcon;

typedef struct
{
    SIZE size;          // icon size
    HIMAGELIST himl;
} SHIMAGELIST;

EXTERN_C SHIMAGELIST g_rgshil[SHIL_COUNT];

BOOL _IsSHILInited();
int _GetSHILImageCount();

void _DestroyIcons(HICON *phicons, int cIcons);

// NOTE these are the size of the icons in our ImageList, not the system
// icon size.

#define g_cxIcon        ((int)g_rgshil[SHIL_LARGE].size.cx)
#define g_cyIcon        ((int)g_rgshil[SHIL_LARGE].size.cy)
#define g_cxSmIcon      ((int)g_rgshil[SHIL_SMALL].size.cx)
#define g_cySmIcon      ((int)g_rgshil[SHIL_SMALL].size.cy)

#endif  // _FILETBL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\filetbl.cpp ===
// routines for managing the icon cache tables, and file type tables.
// Jan 95, ToddLa
//
//  icon cache
//
//      the icon cache is n ImageLists
//      and a table mapping a name/icon number/flags to a ImageList
//      index, the global hash table (pht==NULL) is used to hold
//      the names.
//
//          AddToIconTable      - associate a name/number/flags with a image index
//          SHLookupIconIndex   - return a image index, given name/number/flags
//          RemoveFromIconTable - remove all entries with the given name
//          FlushIconCache      - remove all entries.
//          GetFreeImageIndex   - return a free ImageList index.
//
//      the worst part about the whole icon cache design is that people
//      can add or lookup a image index (given a name/number/flags) but
//      they never have to release it.  we never know if a ImageList index
//      is currently in use or not.  this should be the first thing
//      fixed about the shell.  currently we use a MRU type scheme when
//      we need to remove a entry from the icon cache, it is far from
//      perfect.
//
//  file type cache
//
//      the file type cache is a hash table with two DWORDs of extra data.
//      DWORD #0 holds flags, DWORD #1 holds a pointer to the name of
//      the class.
//
//          LookupFileClass     - given a file class (ie ".doc" or "Directory")
//                                maps it to a DWORD of flags, return 0 if not found.
//
//          AddFileClass        - adds a class (and flags) to cache
//
//          LookupFileClassName - given a file class, returns it name.
//          AddFileClassName    - sets the name of a class.
//          FlushFileClass      - removes all items in cache.
//

#include "shellprv.h"
#pragma  hdrstop

#include "filetbl.h"
#include "fstreex.h"
#include <ntverp.h>
#include "ovrlaymn.h"
#include "dpa.h"

typedef struct {
    DWORD cbSize;         // size of this header.
    DWORD dwMagic;        // magic number
    DWORD dwVersion;      // version of this saved icon cache
    DWORD dwBuild;        // windows build number
    DWORD dwNumIcons;     // number of icons in cache
    DWORD dwColorRes;     // color resolution of device at last save
    DWORD dwFlags;        // ILC_* flags
    DWORD dwTimeSave;     // icon time this file was saved
    DWORD dwTimeFlush;    // icon time we last flushed.
    DWORD dwFreeImageCount;
    DWORD dwFreeEntryCount;
    SIZE rgsize[SHIL_COUNT];  // array of sizes of cached icons
    DWORD cImageLists;      // equal to ARRAYSIZE(IC_HEAD.size)
} IC_HEAD;

#define ICONCACHE_MAGIC  (TEXT('W') + (TEXT('i') << 8) + (TEXT('n') << 16) + (TEXT('4') << 24))
#define ICONCACHE_VERSION 0x0505        // Unicode file names + lower case hash items + v6 imagelist

typedef struct {
    LPCTSTR  szName;     // key: file name
    int     iIconIndex; // key: icon index (or random DWORD for GIL_NOTFILE)
    UINT    uFlags;     // GIL_* flags
    int     iILIndex;   // data: system image list index
    UINT    Access;     // last access.
} LOCATION_ENTRY;

// LOCATION_ENTRY32 is the version of LOCATION_ENTRY that gets written to disk
// It must be declared explicitly 32-bit for Win32/Win64 interop.
typedef struct {
    DWORD   dwszName;   // (garbage in file)
    int     iIconIndex; // key: icon index (or random DWORD for GIL_NOTFILE)
    UINT    uFlags;     // GIL_* flags
    int     iILIndex;     // data: system image list index
    UINT    Access;     // last access.
} LOCATION_ENTRY32;

//
//  MIN_FLUSH is the minimum time interval between flushing the icon cache
//  this number is in IconTime
//
#ifdef DEBUG
#define MIN_FLUSH   60          // 60 == 1 min
#else
#define MIN_FLUSH   900         // 900 == 15min
#endif

//  all file/icons in the location table are "time stamped"
//  each time they are accessed.
//
//  this way we know the most important ones (MRU)
//
//  when the icon cache get tooooo big we sort them all
//  and throw out the old ones.

#define ICONTIME_ZERO   0

//  GetIconTime() returns the "clock" used to timestamp icons
//  in the icon table for MRU.  the clock incrments once every 1024ms
//  (about once every second)

#define GetIconTime()   (g_dwIconTimeBase + (GetTickCount() >> 10))


extern int g_ccIcon;

TIMEVAR(LookupFileClass);
TIMEVAR(AddFileClass);

TIMEVAR(LookupFileClassName);
TIMEVAR(AddFileClassName);

TIMEVAR(LookupFileSCIDs);
TIMEVAR(AddFileSCIDs);

TIMEVAR(LookupIcon);
TIMEVAR(RemoveIcon);
TIMEVAR(AddIcon);
TIMEVAR(IconFlush);

DWORD g_dwIconTimeBase      = ICONTIME_ZERO;
DWORD g_dwIconTimeFlush     = ICONTIME_ZERO;
DWORD g_dwFreeImageCount    = 0;
DWORD g_dwFreeEntryCount    = 0;

CDSA<LOCATION_ENTRY> *g_pdsaLocationEntries = NULL;
BOOL g_fDirtyIcons = FALSE;
UINT g_iLastSysIcon = 0;

typedef struct
{
    PCTSTR pszClassName;
    DWORD dwFlags;
    PERCEIVED gen;
    UINT cSCID;
    SHCOLUMNID* ascid;
} FILECLASSENTRY;

// these GIL_ (GetIconLocation) flags are used when searching for a
// match in the icon table. all other flags are ignored (when searching
// for a match)
//
// NOTE! If you change this definition, you also have to update the
// documentation for SHUpdateImage (since these are the bits that
// SHUpdateImage uses, too)
#define GIL_COMPARE (GIL_SIMULATEDOC | GIL_NOTFILENAME)

void _InitIconOverlayIndices(void);
BOOL _IconIndexInOverlayManager(int iILIndex);


LOCATION_ENTRY* _LookupIcon(LPCTSTR pszName, int iIconIndex, UINT uFlags)
{
    ASSERTCRITICAL

    TCHAR szLower[MAX_PATH];
    StrCpyN(szLower, pszName, ARRAYSIZE(szLower));
    CharLower(szLower);

    pszName = FindHashItem(NULL, szLower);

    LOCATION_ENTRY *pFound = NULL;
    if (pszName && g_pdsaLocationEntries)
    {
        LOCATION_ENTRY *p;
        int i, n = g_pdsaLocationEntries->GetItemCount();
        for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
        {
            if ((p->szName == pszName) &&
                ((UINT)(p->uFlags & GIL_COMPARE) == (uFlags & GIL_COMPARE)) &&
                (p->iIconIndex == iIconIndex))
            {
                p->Access = GetIconTime();
                pFound = p;
                break;  // we are done
            }
        }
    }
    return pFound;
}


int LookupIconIndex(LPCTSTR pszName, int iIconIndex, UINT uFlags)
{
    ASSERT(IS_VALID_STRING_PTR(pszName, -1));

    LPCTSTR pszRelativeName = PathFindFileName(pszName);

    if (lstrcmpi(pszRelativeName, TEXT("shell32.dll")) == 0)
    {
        // we want people to pass full paths in pszName, but shell32.dll is "special", since many callers
        // hardcode the short name, we will always use the short name for it.
        pszName = pszRelativeName;
    }

    ENTERCRITICAL;
    TIMESTART(LookupIcon);

    LOCATION_ENTRY *p = _LookupIcon(pszName, iIconIndex, uFlags);
    int iILIndex = p ? p->iILIndex : -1;

    TIMESTOP(LookupIcon);
    LEAVECRITICAL;

    return iILIndex;
}

STDAPI_(int) SHLookupIconIndex(LPCTSTR pszName, int iIconIndex, UINT uFlags)
{
    return LookupIconIndex(pszName, iIconIndex, uFlags);
}

#ifdef UNICODE

STDAPI_(int) SHLookupIconIndexA(LPCSTR pszName, int iIconIndex, UINT uFlags)
{
    WCHAR wsz[MAX_PATH];

    SHAnsiToUnicode(pszName, wsz, ARRAYSIZE(wsz));
    return SHLookupIconIndex(wsz, iIconIndex, uFlags);
}    

#else

STDAPI_(int) SHLookupIconIndexW(LPCWSTR pszName, int iIconIndex, UINT uFlags)
{
    char sz[MAX_PATH];
    
    SHUnicodeToAnsi(pszName, sz, ARRAYSIZE(sz));
    return SHLookupIconIndex(sz, iIconIndex, uFlags);
}    

#endif

// returns a free image index, or -1 if none

int GetFreeImageIndex(void)
{
    int iILIndex = -1;

    ASSERTCRITICAL

    if (g_dwFreeImageCount && g_pdsaLocationEntries)
    {
        LOCATION_ENTRY *p;
        int i, n = g_pdsaLocationEntries->GetItemCount();
        for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
        {
            if (p->szName == NULL && p->iILIndex != 0)
            {
                iILIndex = p->iILIndex;         // get free index
                p->iILIndex = 0;            // claim it.
                p->Access = ICONTIME_ZERO;  // mark unused entry.
                g_dwFreeImageCount--;
                g_dwFreeEntryCount++;
                break;
            }
        }
    }

    return iILIndex;
}

int GetImageIndexUsage(int iILIndex)
{
    int usage = 0;

    ASSERTCRITICAL

    if (g_pdsaLocationEntries)
    {
        LOCATION_ENTRY *p;
        int i, n = g_pdsaLocationEntries->GetItemCount();
        for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
        {
            if (p->iILIndex == iILIndex)
            {
                usage++;
            }
        }
    }

    return usage;
}

//
// free specified icon table entry. If this makes a system image list index available
// for reuse, check whether this index is cached by file class table. If it is, return
// the image index and caller is responsible for updating file class table and display.
// O/w return -1.
// 
int _FreeEntry(LOCATION_ENTRY *p)
{
    int iUsageCount;

    ASSERTCRITICAL

    TraceMsg(TF_IMAGE, "Icon cache DSA item ([\"%s\", %d], %x, %d, %x) is freed",
        p->szName, p->iIconIndex, p->uFlags, p->iILIndex, p->Access);

    g_fDirtyIcons = TRUE;        // we need to save now.

    ASSERT(p->szName);
    DeleteHashItem(NULL, p->szName);
    p->szName = 0;

    iUsageCount = GetImageIndexUsage(p->iILIndex);
    if (iUsageCount > 1)
    {
        TraceMsg(TF_IMAGE, "Icon cache: count for %d was %d (is now minus 1)", p->iILIndex, iUsageCount);
        g_dwFreeEntryCount++;
        p->iILIndex = 0;              // unused entry
        p->Access = ICONTIME_ZERO;
    }
    else
    {
        TraceMsg(TF_IMAGE, "Icon cache: count for %d was %d (is now free)", p->iILIndex, iUsageCount);
        g_dwFreeImageCount++;
        p->Access = ICONTIME_ZERO;

        if (IconIndexInFileClassTable(p->iILIndex) || _IconIndexInOverlayManager(p->iILIndex))
        {
            TraceMsg(TF_IMAGE, "Icon cache: system imagelist index %d is released for reuse", p->iILIndex);
            return p->iILIndex;
        }
    }

    return -1;
}

LOCATION_ENTRY *GetFreeEntry(void)
{
    ASSERTCRITICAL

    if (g_dwFreeEntryCount && g_pdsaLocationEntries)
    {
        LOCATION_ENTRY *p;
        int i, n = g_pdsaLocationEntries->GetItemCount();
        for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
        {
            if (p->szName == NULL && p->iILIndex == 0)
            {
                g_dwFreeEntryCount--;
                return p;
            }
        }
    }

    return NULL;
}

//  add a item the the cache
//
//      lpszIconFile    - filename to add
//      iIconIndex      - icon index in file.
//      uFlags          - flags
//                          GIL_SIMULATEDOC - this is a simulated doc icon
//                          GIL_NOTFILENAME - file is not a path/index that
//                                            ExtractIcon can deal with
//      iIndex          - image index to use.
//
//  returns:
//      image index for new entry.
//
//  notes:
//      if the item already exists it is replaced.
//
HRESULT AddToIconTable(LPCTSTR pszName, int iIconIndex, UINT uFlags, int iILIndex)
{
    HRESULT hr = E_FAIL;
    LPCTSTR pszRelativeName = PathFindFileName(pszName);

    if (lstrcmpi(pszRelativeName, TEXT("shell32.dll")) == 0)
    {
        // we want people to pass full paths in pszName, but shell32.dll is "special", since many callers
        // hardcode the short name, we will always use the short name for it.
        pszName = pszRelativeName;
    }

    if (pszName)
    {
        ENTERCRITICAL;
        TIMESTART(AddIcon);

        if (g_pdsaLocationEntries == NULL)
        {
            g_pdsaLocationEntries = CDSA_Create<LOCATION_ENTRY>(8);

            g_dwFreeEntryCount = 0;
            g_dwFreeImageCount = 0;
            g_dwIconTimeBase   = 0;
            g_dwIconTimeBase   = 0-GetIconTime();
            g_dwIconTimeFlush  = 0;
        }

        if (g_pdsaLocationEntries)
        {
            g_fDirtyIcons = TRUE;        // we need to save now.

            LOCATION_ENTRY *ple;

            if (0 == (uFlags & GIL_DONTCACHE))
            {
                ple = _LookupIcon(pszName, iIconIndex, uFlags);
                if (ple)
                {
                    if (ple->iILIndex == iILIndex)
                    {
                        hr = S_FALSE;       // We've already got this guy, no problem
                    }
                    else
                    {
                        AssertMsg(ple == NULL,TEXT("Don't call AddToIconTable with somebody who is already there!\n"));
                    }
                }
            }

            if (FAILED(hr))
            {
                TCHAR szLower[MAX_PATH];
                lstrcpyn(szLower, pszName, ARRAYSIZE(szLower));
                CharLower(szLower);
                pszName = AddHashItem(NULL, szLower);
                if (pszName)
                {
                    LOCATION_ENTRY le;
                    le.szName = pszName;
                    le.iIconIndex = iIconIndex;
                    le.iILIndex = iILIndex;
                    le.uFlags = uFlags;
                    le.Access = GetIconTime();

                    ple = GetFreeEntry();

                    if (NULL != ple)
                    {
                        TraceMsg(TF_IMAGE, "Icon cache DSA item ([\"%s\", %d], %x, %d, %x) is added (unfreed)",
                            le.szName, le.iIconIndex, le.uFlags, le.iILIndex, le.Access);

                        *ple = le;
                        hr = S_OK;
                    }
                    else
                    {
                        if (g_pdsaLocationEntries->AppendItem(&le) != -1)
                        {
                            TraceMsg(TF_IMAGE, "Icon cache DSA item ([\"%s\", %d], %x, %d, %x) is added",
                                le.szName, le.iIconIndex, le.uFlags, le.iILIndex, le.Access);

                            hr = S_OK;
                        }
                    }
                }
            }
        }

        TIMESTOP(AddIcon);
        LEAVECRITICAL;
    }

    return hr;
}

void RemoveFromIconTable(LPCTSTR pszName)
{
    BOOL fUpdateFileClass = FALSE;

    ENTERCRITICAL;
    TIMESTART(RemoveIcon);

    LPCTSTR pszRelativeName = PathFindFileName(pszName);

    if (lstrcmpi(pszRelativeName, TEXT("shell32.dll")) == 0)
    {
        // we want people to pass full paths in pszName, but shell32.dll is "special", since many callers
        // hardcode the short name, we will always use the short name for it.
        pszName = pszRelativeName;
    }

    TCHAR szLower[MAX_PATH];
    StrCpyN(szLower, pszName, ARRAYSIZE(szLower));
    CharLower(szLower);
    pszName = FindHashItem(NULL, szLower);
    if (pszName && g_pdsaLocationEntries)
    {
        TraceMsg(TF_IMAGE, "IconCache: flush \"%s\"", pszName);
        LOCATION_ENTRY *p;
        UINT i, n = g_pdsaLocationEntries->GetItemCount();
        for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
        {
            if (p->szName == pszName && i > g_iLastSysIcon)
            {
                if (-1 != _FreeEntry(p))
                    fUpdateFileClass = TRUE;
            }
        }
    }

    TIMESTOP(RemoveIcon);
    LEAVECRITICAL;

    if (fUpdateFileClass)
    {
        TraceMsg(TF_IMAGE, "Icon cache deleted some class items, broadcasting SHCNE_UPDATEIMAGE");

        FlushFileClass();
        _InitIconOverlayIndices();  // Tell overlay manager to re-determine icon indices

        SHChangeNotify(SHCNE_UPDATEIMAGE, SHCNF_DWORD, (LPCVOID)-1, NULL);
    }

    return;
}

//
// empties the icon cache
//
void FlushIconCache(void)
{
    ENTERCRITICAL;

    if (g_pdsaLocationEntries)
    {
        LOCATION_ENTRY *p;
        int i, n = g_pdsaLocationEntries->GetItemCount();
        for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
        {
            if (p->szName)
                DeleteHashItem(NULL, p->szName);
        }

        g_pdsaLocationEntries->DeleteAllItems();
        g_dwFreeEntryCount = 0;
        g_dwFreeImageCount = 0;
        g_dwIconTimeBase   = 0;
        g_dwIconTimeBase   = 0-GetIconTime();
        g_dwIconTimeFlush  = 0;
        g_fDirtyIcons   = TRUE;        // we need to save now.
    }

    LEAVECRITICAL;
}

//
// if the icon cache is too big get rid of some old items.
//
// remember FlushIconCache() removes *all* items from the
// icon table, and this function gets rid of *some* old items.
//
STDAPI_(void) IconCacheFlush(BOOL fForce)
{
    int nuked = 0;

    ENTERCRITICAL;

    if (g_pdsaLocationEntries)
    {
        // conpute the time from the last flush call
        DWORD dt = GetIconTime() - g_dwIconTimeFlush;

        // compute the number of "active" table entries.
        int active = g_pdsaLocationEntries->GetItemCount() - g_dwFreeEntryCount - g_dwFreeImageCount;
        ASSERT(active >= 0);

        if (fForce || (dt > MIN_FLUSH && active >= g_MaxIcons))
        {
            TraceMsg(TF_IMAGE, "_IconCacheFlush: removing all items older than %d. %d icons in cache", dt/2, active);

            LOCATION_ENTRY *p;
            UINT i, n = g_pdsaLocationEntries->GetItemCount();

            for (i = 0, p = g_pdsaLocationEntries->GetItemPtr(0); i < n; i++, p++)
            {
                if (i <= g_iLastSysIcon)
                    continue;

                if (p->szName)
                {
                    TraceMsg(TF_IMAGE, "_IconCacheFlush: \"%s,%d\" old enough? %d v %d", p->szName, p->iIconIndex, g_dwIconTimeFlush + dt/2, p->Access);
                }

                if (p->szName && p->Access < (g_dwIconTimeFlush + dt/2))
                {
                    nuked++;
                    _FreeEntry(p);
                }
            }

            if (nuked > 0)
            {
                g_dwIconTimeFlush = GetIconTime();
                g_fDirtyIcons  = TRUE;        // we need to save now.
            }
        }
    }

    LEAVECRITICAL;

    if (nuked > 0)
    {
        FlushFileClass();
        _InitIconOverlayIndices();  // Tell overlay manager to re-determine icon indices

        SHChangeNotify(SHCNE_UPDATEIMAGE, SHCNF_DWORD, (LPCVOID)-1, NULL);
    }
}

#ifdef DEBUG

void _IconCacheDump()
{
    TCHAR szBuffer[MAX_PATH];

    ENTERCRITICAL;
    if (g_pdsaLocationEntries && _IsSHILInited() && (g_dwDumpFlags & DF_ICONCACHE))
    {
        int cItems = g_pdsaLocationEntries->GetItemCount();

        TraceMsg(TF_IMAGE, "Icon cache: %d icons  (%d free)", cItems, g_dwFreeEntryCount);
        TraceMsg(TF_IMAGE, "Icon cache: %d images (%d free)", _GetSHILImageCount(), g_dwFreeImageCount);

        for (int i = 0; i < cItems; i++)
        {
            LOCATION_ENTRY *pLocEntry = g_pdsaLocationEntries->GetItemPtr(i);

            if (pLocEntry->szName)
                GetHashItemName(NULL, pLocEntry->szName, szBuffer, ARRAYSIZE(szBuffer));
            else
                StrCpyN(szBuffer, TEXT("(free)"), ARRAYSIZE(szBuffer));

            TraceMsg(TF_ALWAYS, "%s;%d%s%s\timage=%d access=%d",
                (LPTSTR)szBuffer,
                pLocEntry->iIconIndex,
                ((pLocEntry->uFlags & GIL_SIMULATEDOC) ? TEXT(" doc"):TEXT("")),
                ((pLocEntry->uFlags & GIL_NOTFILENAME) ? TEXT(" not file"):TEXT("")),
                pLocEntry->iILIndex, pLocEntry->Access);
        }
    }
    LEAVECRITICAL;
}
#endif

DWORD GetBuildNumber()
{
    // Need to use DLL version as we are updating this dll plus others and
    // we need the cache to be invalidated as we may change the icons...
    return VER_PRODUCTVERSION_DW;
}

#ifdef _WIN64

//
//  ps        - stream to which to save
//  hda       - DSA of LOCATION_ENTRY structures
//  cle       - count of LOCATION_ENTRY32's to write
//
//  The structures are stored as LOCATION_ENTRY32 on disk.
//

HRESULT _IconCacheWriteLocations(IStream *pstm, HDSA hdsa, int cle)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Convert from LOCATION_ENTRY to LOCATION_ENTRY32, then write out
    // the LOCATION_ENTRY32 structures.

    LOCATION_ENTRY32 *rgle32 = (LOCATION_ENTRY32*)LocalAlloc(LPTR, cle * sizeof(LOCATION_ENTRY32));
    if (rgle32)
    {
        LOCATION_ENTRY *rgle = (LOCATION_ENTRY*)DSA_GetItemPtr(hdsa, 0);
        for (int i = 0; i < cle; i++)
        {
            rgle32[i].iIconIndex = rgle[i].iIconIndex;
            rgle32[i].uFlags     = rgle[i].uFlags;
            rgle32[i].iILIndex   = rgle[i].iILIndex;
            rgle32[i].Access     = rgle[i].Access;
        }

        hr = IStream_Write(pstm, rgle32, cle * sizeof(LOCATION_ENTRY32));
        LocalFree(rgle32);
    }
    return hr;
}

#else

__inline HRESULT _IconCacheWriteLocations(IStream *pstm, HDSA hdsa, int cle)
{
    // LOCATION_ENTRY and LOCATION_ENTRY32 are the same, so we can
    // read straight into the DSA data block
    COMPILETIME_ASSERT(sizeof(LOCATION_ENTRY) == sizeof(LOCATION_ENTRY32));
    return IStream_Write(pstm, DSA_GetItemPtr(hdsa, 0), cle * sizeof(LOCATION_ENTRY));
}
#endif

HRESULT GetIconCachePath(LPTSTR pszPath)
{
    HRESULT hr = SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA | CSIDL_FLAG_CREATE, NULL, 0, pszPath);
    if (SUCCEEDED(hr))
    {
        if (!PathAppend(pszPath, TEXT("IconCache.db")))
            hr = E_FAIL;
    }
    return hr;
}


// TODO: Make this function compute the actual required size.
ULONG _GetIconCacheSize()
{
    // Set the initial size to 6MB to prevent excessive fragmentation on the disk
    ULONG uSize = 6*1024*1024;

    return uSize;
}

// persist the icon cache to a file

STDAPI_(BOOL) IconCacheSave()
{
    HRESULT hr = S_OK;  // assume OK

    // if the icon cache is not dirty no need to save anything
    if (IsMainShellProcess() && g_pdsaLocationEntries && g_fDirtyIcons)
    {
        // if the icon cache is way too big dont save it.
        // reload g_MaxIcons in case the user set it before shutting down.

        QueryNewMaxIcons();
        if ((UINT)g_pdsaLocationEntries->GetItemCount() <= (UINT)g_MaxIcons)
        {
            TCHAR szPath[MAX_PATH];
            hr = GetIconCachePath(szPath);
            if (SUCCEEDED(hr))
            {
                IStream *pstm;
                hr = SHCreateStreamOnFileEx(szPath, STGM_CREATE | STGM_WRITE | STGM_SHARE_DENY_WRITE, FILE_ATTRIBUTE_HIDDEN, TRUE, NULL, &pstm);
                if (SUCCEEDED(hr))
                {
                    ULARGE_INTEGER size;
                    size.LowPart = _GetIconCacheSize();
                    size.HighPart = 0;
                    // Set the right size initially so that the file system gives us contigous space on the disk
                    // This avoid fragmentation and improves our startup time.
                    hr = pstm->SetSize(size);
                    if (SUCCEEDED(hr))
                    {
                        ENTERCRITICAL;

                        IC_HEAD ich = {0};
                        // ich.cbSize, don't set this until we re-write the header
                        ich.dwMagic    = ICONCACHE_MAGIC;
                        ich.dwVersion  = ICONCACHE_VERSION;
                        ich.dwNumIcons = GetSystemMetrics(SM_CLEANBOOT) ? 0 : g_pdsaLocationEntries->GetItemCount();
                        ich.dwColorRes = GetCurColorRes();
                        ich.dwFlags    = g_ccIcon;
                        ich.dwBuild    = GetBuildNumber();
                        ich.dwTimeSave  = GetIconTime();
                        ich.dwTimeFlush = g_dwIconTimeFlush;
                        ich.dwFreeImageCount = g_dwFreeImageCount;
                        ich.dwFreeEntryCount = g_dwFreeEntryCount;
                        ich.cImageLists = ARRAYSIZE(g_rgshil);

                        for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
                        {
                            ImageList_GetIconSize(g_rgshil[i].himl, (int*)&ich.rgsize[i].cx, (int*)&ich.rgsize[i].cy);
                        }

                        hr = IStream_Write(pstm, &ich, sizeof(ich));
                        if (SUCCEEDED(hr))
                        {
                            // write out entries (assumes all entries are contigious in memory)
                            hr = _IconCacheWriteLocations(pstm, *g_pdsaLocationEntries, ich.dwNumIcons);
                            // write out the path names
                            for (i = 0; SUCCEEDED(hr) && (i < (int)ich.dwNumIcons); i++)
                            {
                                TCHAR ach[MAX_PATH];
                                LOCATION_ENTRY *p = g_pdsaLocationEntries->GetItemPtr(i);

                                if (p->szName)
                                    GetHashItemName(NULL, p->szName, ach, ARRAYSIZE(ach));
                                else
                                    ach[0] = 0;

                                hr = Stream_WriteString(pstm, ach, TRUE);
                            }

                            // write out the imagelist of the icons
                            for (i = 0; SUCCEEDED(hr) && (i < ARRAYSIZE(g_rgshil)); i++)
                            {
                                hr = ImageList_Write(g_rgshil[i].himl, pstm) ? S_OK : E_FAIL;
                            }


                            if (SUCCEEDED(hr))
                            {
                                hr = pstm->Commit(0);
                                if (SUCCEEDED(hr))
                                {
                                    // This is where the file pointer is at the end of the file.
                                    ULARGE_INTEGER liSize;
                                    if (SUCCEEDED(pstm->Seek(g_li0, STREAM_SEEK_CUR, &liSize)))
                                    {
                                        // Trim the file size now. Ignore the return code 
                                        pstm->SetSize(liSize);
                                    }

                                    hr = pstm->Seek(g_li0, STREAM_SEEK_SET, NULL);
                                    if (SUCCEEDED(hr))
                                    {
                                        ich.cbSize = sizeof(ich);   // not valid until this is set
                                        hr = IStream_Write(pstm, &ich, sizeof(ich));
                                        if (SUCCEEDED(hr))
                                        {
                                            g_fDirtyIcons = FALSE;  // reset dirty state
                                        }
                                    }
                                }
                            }
                        }
                        pstm->Release();

                        LEAVECRITICAL;
                    }
                }
            }
            if (FAILED(hr))
                DeleteFile(szPath); // saving failed, cleanup
        }
    }

    return SUCCEEDED(hr);
}

#ifdef _WIN64

//
//  ps        - stream from which to load
//  hda       - DSA of LOCATION_ENTRY structures
//  cle       - count of LOCATION_ENTRY32's to read
//
//  The structures are stored as LOCATION_ENTRY32 on disk.
//

HRESULT _IconCacheReadLocations(IStream *pstm, HDSA hdsa, int cle)
{
    HRESULT hr = E_OUTOFMEMORY;

    // read into a scratch buffer, then convert
    // LOCATION_ENTRY32 into LOCATION_ENTRY.

    LOCATION_ENTRY32 *rgle32 = (LOCATION_ENTRY32*)LocalAlloc(LPTR, cle * sizeof(LOCATION_ENTRY32));
    if (rgle32)
    {
        hr = IStream_Read(pstm, rgle32, cle * sizeof(LOCATION_ENTRY32));
        if (SUCCEEDED(hr))
        {
            LOCATION_ENTRY *rgle = (LOCATION_ENTRY*)DSA_GetItemPtr(hdsa, 0);
            for (int i = 0; i < cle; i++)
            {
                rgle[i].iIconIndex = rgle32[i].iIconIndex;
                rgle[i].uFlags     = rgle32[i].uFlags;
                rgle[i].iILIndex   = rgle32[i].iILIndex;
                rgle[i].Access     = rgle32[i].Access;
            }
        }
        LocalFree(rgle32);
    }
    return hr;
}

#else

__inline HRESULT _IconCacheReadLocations(IStream *pstm, HDSA hdsa, int cle)
{
    // LOCATION_ENTRY and LOCATION_ENTRY32 are the same, so we can
    // read straight into the DSA data block
    COMPILETIME_ASSERT(sizeof(LOCATION_ENTRY) == sizeof(LOCATION_ENTRY32));
    return IStream_Read(pstm, DSA_GetItemPtr(hdsa, 0), cle * sizeof(LOCATION_ENTRY));
}
#endif

void _InitIconOverlayIndices(void)
{
    IShellIconOverlayManager *psiom;

    if (SUCCEEDED(GetIconOverlayManager(&psiom)))
    {
        psiom->RefreshOverlayImages(SIOM_OVERLAYINDEX | SIOM_ICONINDEX);
        psiom->Release();
    }
}

BOOL _IconIndexInOverlayManager(int iILIndex)
{
    BOOL fInOverlayManager = FALSE;

    ENTERCRITICAL;

    IShellIconOverlayManager *psiom;

    if (SUCCEEDED(GetIconOverlayManager(&psiom)))
    {
        int iOverlayIndex;

        if (SUCCEEDED(psiom->OverlayIndexFromImageIndex(iILIndex, &iOverlayIndex, FALSE)))
        {
            fInOverlayManager = TRUE;
        }
        psiom->Release();
    }

    LEAVECRITICAL;

    return fInOverlayManager;
}

BOOL _ReadImageLists(IStream *pstrm, HIMAGELIST rghiml[SHIL_COUNT], SIZE rgsize[SHIL_COUNT])
{
    BOOL fSuccess = TRUE;
    for (int i = 0; fSuccess && i < ARRAYSIZE(g_rgshil); i++)
    {
        rghiml[i] = ImageList_Read(pstrm);
        if (rghiml[i])
        {
            // If we read the list from disk and it does not contain the
            // parallel mirrored list while we are on a mirrored system,
            // let's not use the cache in this case
            // Example of this is ARA/HEB MUI on US W2k

            if (IS_BIDI_LOCALIZED_SYSTEM() && !(ImageList_GetFlags(rghiml[i]) & ILC_MIRROR))
            {
                fSuccess = FALSE;
            }
            else
            {
                int cx, cy;
                ImageList_GetIconSize(rghiml[i], &cx, &cy);
                if (cx != rgsize[i].cx || cy != rgsize[i].cy)
                {
                    fSuccess = FALSE;
                }
            }
        }
        else
        {
            fSuccess = FALSE;
        }
    }

    if (fSuccess == FALSE)
    {
        // free any imagelists we allocated
        for (i = 0; i < ARRAYSIZE(g_rgshil); i++)
        {
            if (rghiml[i])
            {
                ImageList_Destroy(rghiml[i]);
                rghiml[i] = NULL;
            }
        }
    }

    return fSuccess;
}

// psz and cch passed in for efficiency (avoid using another MAX_PATH stack buffer)
BOOL _ReadLocationEntries(const IC_HEAD *pich, IStream *pstrm, CDSA<LOCATION_ENTRY> *pdsaTemp, LPTSTR psz, int cch)
{
    LOCATION_ENTRY dummy;

    // grow the array out so we can read data into it
    if (pdsaTemp->SetItem(pich->dwNumIcons - 1, &dummy))
    {
        ASSERT(pdsaTemp->GetItemCount() == (int)pich->dwNumIcons);
        if (SUCCEEDED(_IconCacheReadLocations(pstrm, *pdsaTemp, pich->dwNumIcons)))
        {
            // read the paths, patching up the table with the hashitem info
            for (int i = 0; i < (int)pich->dwNumIcons; i++)
            {
                LOCATION_ENTRY *pLocation = pdsaTemp->GetItemPtr(i);

                if (SUCCEEDED(Stream_ReadString(pstrm, psz, cch, TRUE)) && *psz)
                    pLocation->szName = AddHashItem(NULL, psz);
                else
                    pLocation->szName = 0;
            }
            
            // restore the image lists
            return TRUE;
        }
    }
    return FALSE;
}

BOOL _ValidateIconCacheHeader(const IC_HEAD *pich, SIZE rgsize[SHIL_COUNT], UINT flags)
{
    if (pich->cbSize      == sizeof(*pich) &&
        pich->dwVersion   == ICONCACHE_VERSION &&
        pich->dwMagic     == ICONCACHE_MAGIC &&
        pich->dwBuild     == GetBuildNumber() &&
        pich->dwFlags     == (DWORD)flags &&
        pich->cImageLists == ARRAYSIZE(g_rgshil) &&
        (0 == memcmp(pich->rgsize, rgsize, sizeof(pich->rgsize))))
    {
        UINT cres = GetCurColorRes();

        // dont load a mono image list on a color device, and
        // dont load a color image list on a mono device, get it?
        if (pich->dwColorRes == 1 && cres != 1 ||
            pich->dwColorRes != 1 && cres == 1)
        {
            return FALSE;
        }
        else if (pich->dwNumIcons > (UINT)g_MaxIcons)
        {
            return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}

void _SetNewGlobals(const IC_HEAD *pich, CDSA<LOCATION_ENTRY> *pdsaTemp, HIMAGELIST rghiml[SHIL_COUNT])
{
    ASSERTCRITICAL;

    if (g_pdsaLocationEntries)
    {
        g_pdsaLocationEntries->Destroy();
        delete g_pdsaLocationEntries;
    }
    g_pdsaLocationEntries = pdsaTemp;

    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        if (g_rgshil[i].himl)
            ImageList_Destroy(g_rgshil[i].himl);
        g_rgshil[i].himl = rghiml[i];
    }

    //
    // we want GetIconTime() to pick up
    // where it left off when we saved.
    //
    g_dwIconTimeBase   = 0;     // GetIconTime() uses g_dwIconTimeBase
    g_dwIconTimeBase   = pich->dwTimeSave - GetIconTime();
    g_dwIconTimeFlush  = pich->dwTimeFlush;
    g_dwFreeImageCount = pich->dwFreeImageCount;
    g_dwFreeEntryCount = pich->dwFreeEntryCount;
    g_fDirtyIcons   = FALSE;
}

//
//  get the icon cache back from disk, it must be the requested size and
//  bitdepth or we will not use it.
//
STDAPI_(BOOL) IconCacheRestore(SIZE rgsize[SHIL_COUNT], UINT flags)
{
    ASSERTCRITICAL;

    BOOL fSuccess = FALSE;

    if (!GetSystemMetrics(SM_CLEANBOOT))
    {
        TCHAR szPath[MAX_PATH];

        IStream *pstm;
        if (SUCCEEDED(GetIconCachePath(szPath)) &&
            SUCCEEDED(SHCreateStreamOnFile(szPath, STGM_READ | STGM_SHARE_DENY_WRITE, &pstm)))
        {
            IC_HEAD ich;
            if (SUCCEEDED(IStream_Read(pstm, &ich, sizeof(ich))) &&
                _ValidateIconCacheHeader(&ich, rgsize, flags))
            {
                CDSA<LOCATION_ENTRY> *pdsaTemp = CDSA_Create<LOCATION_ENTRY>(8);

                // load the icon table
                if (pdsaTemp)
                {
                    HIMAGELIST rghiml[ARRAYSIZE(g_rgshil)] = {0};

                    fSuccess = _ReadLocationEntries(&ich, pstm, pdsaTemp, szPath, ARRAYSIZE(szPath)) &&
                               _ReadImageLists(pstm, rghiml, rgsize);

                    if (fSuccess)
                    {
                        // Make it so, number one.
                        _SetNewGlobals(&ich, pdsaTemp, rghiml);
                        _InitIconOverlayIndices();
                    }
                    else
                    {
                        // failure, clean up
                        pdsaTemp->Destroy();
                        delete pdsaTemp;
                    }
                }
            }
            pstm->Release();
        }
    }

    return fSuccess;
}


//------------------ file class table ------------------------

HHASHTABLE g_hhtClass = NULL;

BOOL InitFileClassTable(void)
{
    ASSERTCRITICAL;

    if (!g_hhtClass)
    {
        if (!g_hhtClass)
            g_hhtClass = CreateHashItemTable(0, sizeof(FILECLASSENTRY));
    }

    return BOOLIFY(g_hhtClass);
}
        
    
void FlushFileClass(void)
{
    ENTERCRITICAL;

#ifdef DEBUG
    if (g_hhtClass != NULL) 
    {
        DebugMsg(DM_TRACE, TEXT("Flushing file class table"));
        TIMEOUT(LookupFileClass);
        TIMEOUT(AddFileClass);
        TIMEOUT(LookupFileClassName);
        TIMEOUT(AddFileClassName);
        TIMEOUT(LookupFileSCIDs);
        TIMEOUT(AddFileSCIDs);
        TIMEOUT(LookupIcon);
        TIMEOUT(AddIcon);
        TIMEOUT(RemoveIcon);

        TIMEIN(LookupFileClass);
        TIMEIN(AddFileClass);
        TIMEIN(LookupFileClassName);
        TIMEIN(AddFileClassName);
        TIMEIN(LookupFileSCIDs);
        TIMEIN(AddFileSCIDs);
        TIMEIN(LookupIcon);
        TIMEIN(AddIcon);
        TIMEIN(RemoveIcon);

        DumpHashItemTable(g_hhtClass);
    }
#endif
    if (g_hhtClass != NULL)
    {
        DestroyHashItemTable(g_hhtClass);
        g_hhtClass = NULL;
    }

    TraceMsg(TF_IMAGE, "Flushed class maps");

    LEAVECRITICAL;
}


DWORD LookupFileClass(LPCTSTR pszClass)
{
    DWORD dw = 0;

    ENTERCRITICAL;
    TIMESTART(LookupFileClass);
    
    if (g_hhtClass && (NULL != (pszClass = FindHashItem(g_hhtClass, pszClass))))   
        dw = ((FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass))->dwFlags;

    TIMESTOP(LookupFileClass);
    LEAVECRITICAL;

    return dw;
}

void AddFileClass(LPCTSTR pszClass, DWORD dw)
{
    ENTERCRITICAL;
    TIMESTART(AddFileClass);

    // create a hsa table to keep the file class info in.

    if (InitFileClassTable() && (NULL != (pszClass = AddHashItem(g_hhtClass, pszClass))))
        ((FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass))->dwFlags = dw;

    TraceMsg(TF_IMAGE, "Mapped %s to image %d", pszClass, (dw & SHCF_ICON_INDEX));

    TIMESTOP(AddFileClass);
    LEAVECRITICAL;
    return;
}

//======================================================================

typedef struct _IconIndexCountParam
{
    int       iILIndex; // hash item data
    int       cItems;   // number of hash items found
} ICONINDEXCOUNTPARAM;

//======================================================================

void _IconIndexInFileClassTableCallback(HHASHTABLE hht, LPCTSTR sz, UINT usage, DWORD_PTR dwParam)
{
    ICONINDEXCOUNTPARAM *lpParam = (ICONINDEXCOUNTPARAM *)dwParam;

    FILECLASSENTRY* pfce = (FILECLASSENTRY*)GetHashItemDataPtr(hht, sz);

    if (pfce && (pfce->dwFlags & SHCF_ICON_INDEX) == lpParam->iILIndex)
    {
        lpParam->cItems++;
    }
} 

//======================================================================

BOOL IconIndexInFileClassTable(int iILIndex)
{
    ICONINDEXCOUNTPARAM param;

    param.iILIndex = iILIndex;
    param.cItems = 0;

    ENTERCRITICAL;

    if (g_hhtClass)
    {
        EnumHashItems(g_hhtClass, _IconIndexInFileClassTableCallback, (DWORD_PTR)&param);
    }

    LEAVECRITICAL;

    return param.cItems;
}

LPCTSTR LookupFileClassName(LPCTSTR pszClass)
{
    LPCTSTR pszClassName = NULL;

    ASSERTCRITICAL
    TIMESTART(LookupFileClassName);

    if (g_hhtClass && (NULL != (pszClass = FindHashItem(g_hhtClass, pszClass))))
    {
        FILECLASSENTRY* pfce = (FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass);
        pszClassName = pfce->pszClassName;
    }
    TIMESTOP(LookupFileClassName);

    return pszClassName;
}

// If the return value is greater than zero,
// it is up to the caller to free the array that is passed out.
// If the return value is zero, the value of papProps is undefined.
UINT LookupFileSCIDs(LPCTSTR pszClass, SHCOLUMNID *pascidOut[])
{
    SHCOLUMNID *ascid = NULL;
    UINT cCount = 0;

    ASSERTCRITICAL
    TIMESTART(LookupFileClassName);

    if (g_hhtClass && (NULL != (pszClass = FindHashItem(g_hhtClass, pszClass))))
    {
        FILECLASSENTRY* pfce = (FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass);
        cCount = pfce->cSCID;
        if (cCount > 0)
        {
            // Make a local copy of the scid array
            ascid = (SHCOLUMNID*)LocalAlloc(LMEM_FIXED, sizeof(SHCOLUMNID) * cCount);
            if (ascid)
                CopyMemory(ascid, pfce->ascid, sizeof(SHCOLUMNID) * cCount);
            else
                cCount = 0;
        }
    }
    TIMESTOP(LookupFileClassName);

    *pascidOut = ascid;
    return cCount;

}

LPCTSTR AddFileClassName(LPCTSTR pszClass, LPCTSTR pszClassName)
{
    ASSERTCRITICAL
    TIMESTART(AddFileClassName);

    // create a hsa table to keep the file class info in.

    if (InitFileClassTable() && (NULL != (pszClass = AddHashItem(g_hhtClass, pszClass))))
    {
        pszClassName = AddHashItem(g_hhtClass, pszClassName);
        ((FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass))->pszClassName = pszClassName;
    }
    else
    {
        pszClassName = NULL;
    }

    TIMESTOP(AddFileClassName);
    return pszClassName;
}

// The array of SHCOLUMNIDs passed in is copied
void AddFileSCIDs(LPCTSTR pszClass, SHCOLUMNID ascidIn[], UINT cSCID)
{
    ASSERTCRITICAL
    TIMESTART(AddFileSCIDs);

    if (InitFileClassTable() && (NULL != (pszClass = AddHashItem(g_hhtClass, pszClass))))
    {
        // Make a copy of the array.
        SHCOLUMNID *ascid = (SHCOLUMNID*)LocalAlloc(LMEM_FIXED, sizeof(SHCOLUMNID) * cSCID);

        if (ascid)
        {
            FILECLASSENTRY *pfce = (FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass);
            // Free any previous scid array first
            if (pfce->ascid)
                LocalFree(pfce->ascid);
            // Note, we never free the last scid array -- freed on process exit.

            pfce->ascid = ascid;
            CopyMemory(ascid, ascidIn, cSCID * sizeof(SHCOLUMNID));
            pfce->cSCID = cSCID;
        }
    }

    TIMESTOP(AddFileSCIDs);
}

PERCEIVED LookupFilePerceivedType(LPCTSTR pszClass)
{
    PERCEIVED gen = GEN_UNKNOWN;
    

    ENTERCRITICAL;
    TIMESTART(LookupFileClassName);

    if (g_hhtClass && (NULL != (pszClass = FindHashItem(g_hhtClass, pszClass))))
    {
        FILECLASSENTRY* pfce = (FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass);
        gen = pfce->gen;
    }
    TIMESTOP(LookupFileClassName);
    LEAVECRITICAL;
    return gen;
}

void AddFilePerceivedType(LPCTSTR pszClass, PERCEIVED gen)
{
    ENTERCRITICAL;
    TIMESTART(AddFileClassName);

    // create a hsa table to keep the file class info in.

    if (InitFileClassTable() && (NULL != (pszClass = AddHashItem(g_hhtClass, pszClass))))
    {
        ((FILECLASSENTRY*)GetHashItemDataPtr(g_hhtClass, pszClass))->gen = gen;
    }

    TIMESTOP(AddFileClassName);
    LEAVECRITICAL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\filtgrep.h ===
//  10/12/99    scotthan    created

#ifndef __FILTGREP_H__
#define __FILTGREP_H__

#if WINNT

#ifndef _USE_FILTERGREP_
#define _USE_FILTERGREP_
#endif//_USE_FILTERGREP_

#include <filter.h> // STAT_CHUNK

//  CFilterGrep::Initialize() dwFlags values:
#define FGIF_CASESENSITIVE      0x00000001  // grep in case-sensitive manner
#define FGIF_GREPFILENAME       0x00000002  // grep filename
#define FGIF_GREPCONTENT        0x00000004  // grep content
#define FGIF_GREPPROPERTIES     0x00000008  // grep properties
#define FGIF_BLANKETGREP        (FGIF_GREPCONTENT|FGIF_GREPPROPERTIES)

#ifdef __cplusplus

class CGrepTokens;

class CFilterGrep  // filtergrep state engine
{
public:
    //  Methods
    STDMETHODIMP Initialize(UINT nCodePage, LPCWSTR pszMatch, LPCWSTR pszExclude, DWORD dwFlags);
    STDMETHODIMP Grep(IShellFolder *psf, LPCITEMIDLIST pidl, LPCTSTR pszName);
    STDMETHODIMP Reset();

    //  Properties
    STDMETHODIMP GetMatchTokens( OUT LPWSTR pszMatch, UINT cchMatch ) const;
    STDMETHODIMP GetExcludeTokens( OUT LPWSTR pszMatch, UINT cchMatch ) const;

private:
    //  Helpers
    STDMETHODIMP _GetThreadGrepBuffer( DWORD dwThreadID, ULONG cchNeed, LPWSTR* ppszBuf );
    STDMETHODIMP_(void)     _ClearGrepBuffers();

    STDMETHODIMP _GrepText( IFilter* pFilter, STAT_CHUNK* pstat, DWORD dwThreadID );
    STDMETHODIMP _GrepValue( IFilter* pFilter, STAT_CHUNK* pstat );
    
    STDMETHODIMP _GrepProperties(IPropertySetStorage *pss);
    STDMETHODIMP _GrepPropStg(IPropertyStorage* pstg, ULONG cspec, PROPSPEC rgspec[]);
    STDMETHODIMP _GrepEnumPropStg(IPropertyStorage* pstg);
    STDMETHODIMP_(BOOL) _IsRestrictedFileType(LPCWSTR pwszFile);

    void         _EnterCritical()   { EnterCriticalSection( &_critsec ); }
    void         _LeaveCritical()   { LeaveCriticalSection( &_critsec ); }

    //  Data
    HDPA             _hdpaGrepBuffers;
    CRITICAL_SECTION _critsec;
    BOOL             _fcritsec;
    CGrepTokens*     _pTokens;
    DWORD            _dwFlags;
    LPWSTR           _pwszContentRestricted,
                     _pwszPropertiesRestricted;

public:
    //  Ctor, Dtor
    CFilterGrep(); 
    ~CFilterGrep();

    STDMETHODIMP InitSelf(void);
};

#endif //__cplusplus

#define FACILITY_FILTERGREP         77 // arbitrary
#define MAKE_FILTGREP_ERROR(sc)     MAKE_HRESULT(SEVERITY_ERROR,FACILITY_FILTERGREP,sc)
#define MAKE_FILTGREP_WARNING(sc)   MAKE_HRESULT(SEVERITY_SUCCESS,FACILITY_FILTERGREP,sc)

#define FG_E_NOFILTER               MAKE_FILTGREP_ERROR(0x0001) 


#endif WINNT

#endif __FILTGREP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\fileicon.cpp ===
#include "shellprv.h"
#pragma  hdrstop
#include "ovrlaymn.h"
#include "fstreex.h"
#include "filetbl.h"
#include "ids.h"

// REVIEW: More clean up should be done.

BOOL _ShellImageListInit(UINT flags, BOOL fRestore);

int g_ccIcon = 0;                // color depth of ImageLists
int g_MaxIcons = DEF_MAX_ICONS;  // panic limit for icons in cache
int g_lrFlags = 0;

int g_ccIconDEBUG = -1;
int g_resDEBUG = -1;

int GetRegInt(HKEY hk, LPCTSTR szKey, int def)
{
    TCHAR ach[20];
    DWORD cb = sizeof(ach);
    if (ERROR_SUCCESS == SHQueryValueEx(hk, szKey, NULL, NULL, (LPBYTE)ach, &cb)
    && (ach[0] >= TEXT('0') && ach[0] <= TEXT('9')))
    {
        return (int)StrToLong(ach);
    }
    else
        return def;
}

int _GetMetricsRegInt(LPCTSTR pszKey, int iDefault)
{
    HKEY hkey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_METRICS, NULL, KEY_QUERY_VALUE, &hkey))
    {
        iDefault = GetRegInt(hkey, pszKey, iDefault);
        RegCloseKey(hkey);
    }
    return iDefault;
}

typedef void (*PSIZECALLBACK)(SIZE *psize);

void WINAPI _GetLargeIconSizeCB(SIZE *psize)
{
    int cxIcon = GetSystemMetrics(SM_CXICON);

    //
    //  get the user prefered icon size from the registry.
    //
    cxIcon = _GetMetricsRegInt(TEXT("Shell Icon Size"), cxIcon);

    psize->cx = psize->cy = cxIcon;
}

void WINAPI _GetSmallIconSizeCB(SIZE *psize)
{
    int cxIcon = GetSystemMetrics(SM_CXICON)/2;

    //
    //  get the user prefered icon size from the registry.
    //
    cxIcon = _GetMetricsRegInt(TEXT("Shell Small Icon Size"), cxIcon);

    psize->cx = psize->cy = cxIcon;
}

void WINAPI _GetSysSmallIconSizeCB(SIZE *psize)
{
    psize->cx = GetSystemMetrics(SM_CXSMICON);
    psize->cy = GetSystemMetrics(SM_CYSMICON);
}

void WINAPI _GetXLIconSizeCB(SIZE *psize)
{
    psize->cx = 3 * GetSystemMetrics(SM_CXICON) / 2;
    psize->cy = 3 * GetSystemMetrics(SM_CYICON) / 2;
}

static const PSIZECALLBACK c_rgSizeCB[SHIL_COUNT] =
{
    _GetLargeIconSizeCB,        // SHIL_LARGE
    _GetSmallIconSizeCB,        // SHIL_SMALL
    _GetXLIconSizeCB,           // SHIL_EXTRALARGE
    _GetSysSmallIconSizeCB,     // SHIL_SYSSMALL 
};

EXTERN_C SHIMAGELIST g_rgshil[SHIL_COUNT] = {0};


BOOL _IsSHILInited()
{
#ifdef DEBUG
    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        // If allocation of any one image list failed, all should be NULL.  So
        // make sure they're either all NULL or all non-NULL.
        ASSERTMSG((g_rgshil[0].himl == NULL) == (g_rgshil[i].himl == NULL),
            "_IsSHILInited: g_rgshil is inconsistent.  g_rgshil[0].himl %x, g_rgshil[%x].himl %x", g_rgshil[0].himl, i, g_rgshil[i].himl);
    }
#endif
    return (g_rgshil[0].himl != NULL);
}

int _GetSHILImageCount()
{
#ifdef DEBUG
    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        // If insertion of an image into one image list failed, insertion of an
        // image into all image lists should have failed.  So make sure the image
        // counts are all the same.
        ASSERTMSG(ImageList_GetImageCount(g_rgshil[0].himl) == ImageList_GetImageCount(g_rgshil[i].himl),
            "_GetSHILImageCount: g_rgshil is inconsistent.  image counts don't line up.");
    }
#endif
    return ImageList_GetImageCount(g_rgshil[0].himl);
}

//
// System imagelist - Don't change the order of this list.
// If you need to add a new icon, add it to the end of the
// array, and update shellp.h.
//
EXTERN_C UINT const c_SystemImageListIndexes[] = { IDI_DOCUMENT,
                                          IDI_DOCASSOC,
                                          IDI_APP,
                                          IDI_FOLDER,
                                          IDI_FOLDEROPEN,
                                          IDI_DRIVE525,
                                          IDI_DRIVE35,
                                          IDI_DRIVEREMOVE,
                                          IDI_DRIVEFIXED,
                                          IDI_DRIVENET,
                                          IDI_DRIVENETDISABLED,
                                          IDI_DRIVECD,
                                          IDI_DRIVERAM,
                                          IDI_WORLD,
                                          IDI_NETWORK,
                                          IDI_SERVER,
                                          IDI_PRINTER,
                                          IDI_MYNETWORK,
                                          IDI_GROUP,

                                          IDI_STPROGS,
                                          IDI_STDOCS,
                                          IDI_STSETNGS,
                                          IDI_STFIND,
                                          IDI_STHELP,
                                          IDI_STRUN,
                                          IDI_STSUSPEND,
                                          IDI_STEJECT,
                                          IDI_STSHUTD,

                                          IDI_SHARE,
                                          IDI_LINK,
                                          IDI_SLOWFILE,
                                          IDI_RECYCLER,
                                          IDI_RECYCLERFULL,
                                          IDI_RNA,
                                          IDI_DESKTOP,

                                          IDI_CPLFLD,
                                          IDI_STSPROGS,
                                          IDI_PRNFLD,
                                          IDI_STFONTS,
                                          IDI_STTASKBR,

                                          IDI_CDAUDIO,
                                          IDI_TREE,
                                          IDI_STCPROGS,
                                          IDI_STFAV,
                                          IDI_STLOGOFF,
                                          IDI_STFLDRPROP,
                                          IDI_WINUPDATE

                                          ,IDI_MU_SECURITY,
                                          IDI_MU_DISCONN
                                          };


// get g_MaxIcons from the registry, returning TRUE if it has changed

BOOL QueryNewMaxIcons(void)
{
    int MaxIcons = -1;
    HKEY hk = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, NULL, FALSE);
    if (hk)
    {
        MaxIcons = GetRegInt(hk, TEXT("Max Cached Icons"), DEF_MAX_ICONS);
        RegCloseKey(hk);
    }

    if (MaxIcons < 0)
        MaxIcons = DEF_MAX_ICONS;

    int OldMaxIcons = InterlockedExchange((LONG*)&g_MaxIcons, MaxIcons);

    return (OldMaxIcons != MaxIcons);
}

// Initializes shared resources for Shell_GetIconIndex and others

STDAPI_(BOOL) FileIconInit(BOOL fRestoreCache)
{
    BOOL fNotify = FALSE;
    static int s_res = 32;

    QueryNewMaxIcons(); // in case the size of the icon cache has changed

    SIZE rgsize[ARRAYSIZE(g_rgshil)];

    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        c_rgSizeCB[i](&rgsize[i]);
    }

    //
    //  get the user prefered color depth from the registry.
    //
    int ccIcon = _GetMetricsRegInt(TEXT("Shell Icon Bpp"), 0);
    g_ccIconDEBUG = ccIcon;

    int res = (int)GetCurColorRes();
    g_resDEBUG = res;

    if (res == 0)
        res = s_res;
    s_res = res;

    if (ccIcon > res)
        ccIcon = 0;

    if (res >= 24)           // Match User32. They will extract 32bpp icons in 24bpp.
        ccIcon = 32;

    if (res <= 8)
        ccIcon = 0; // wouldn't have worked anyway

    ENTERCRITICAL;

    //
    // if we already have a icon cache make sure it is the right size etc.
    //
    BOOL fHadCache = _IsSHILInited();

    BOOL fCacheValid = fHadCache && (ccIcon == g_ccIcon);
    for (int i = 0; fCacheValid && i < ARRAYSIZE(g_rgshil); i++)
    {
        if (g_rgshil[i].size.cx != rgsize[i].cx ||
            g_rgshil[i].size.cy != rgsize[i].cy)
        {
            fCacheValid = FALSE;
        }
    }

    if (!fCacheValid)
    {
        fNotify = fHadCache;

        FlushIconCache();
        FlushFileClass();

        // if we are the desktop process (explorer.exe), then force us to re-init the cache, so we get
        // the basic set of icons in the right order....
        if (!fRestoreCache && _IsSHILInited() && IsWindowInProcess(GetShellWindow()))
        {
            fRestoreCache = TRUE;
        }

        for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
        {
            g_rgshil[i].size.cx = rgsize[i].cx;
            g_rgshil[i].size.cy = rgsize[i].cy;
        }

        g_ccIcon = ccIcon;

        if (res > 4 && g_ccIcon <= 4)
            g_lrFlags = LR_VGACOLOR;
        else
            g_lrFlags = 0;

        if (g_iLastSysIcon == 0)        // Keep track of which icons are perm.
        {
            if (fRestoreCache)
                g_iLastSysIcon = II_LASTSYSICON;
            else
                g_iLastSysIcon = (II_OVERLAYLAST - II_OVERLAYFIRST) + 1;
        }

        //
        // if
        //   1) we already have the icon cache but want to flush and re-initialize it because of size/color depth change, or
        //   2) we don't have icon cache but want to initialize it, instead of restoring it from disk, or
        //   3) we failed to restore icon cache from disk
        // then, initialize the icon cache with c_SystemImageListIndexes
        //
        if (_IsSHILInited() || !fRestoreCache || !IconCacheRestore(rgsize, g_ccIcon))
        {
            fCacheValid = _ShellImageListInit(g_ccIcon, fRestoreCache);
        }
        else
        {
            fCacheValid = TRUE;
        }
    }

    LEAVECRITICAL;

    if (fCacheValid && fNotify)
    {
        SHChangeNotify(SHCNE_UPDATEIMAGE, SHCNF_DWORD, (LPCVOID)-1, NULL);
    }

    return fCacheValid;
}


void _ShellImageListTerm()
{
    ASSERTCRITICAL;

    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        if (g_rgshil[i].himl)
        {
            ImageList_Destroy(g_rgshil[i].himl);
            g_rgshil[i].himl = NULL;
        }
    }
}

void FileIconTerm()
{
    ENTERCRITICAL;

    _ShellImageListTerm();

    LEAVECRITICAL;
}

void _DestroyIcons(HICON *phicons, int cIcons)
{
    for (int i = 0; i < cIcons; i++)
    {
        if (phicons[i])
        {
            DestroyIcon(phicons[i]);
            phicons[i] = NULL;
        }
    }
}

BOOL _ShellImageListInit(UINT flags, BOOL fRestore)
{
    ASSERTCRITICAL;

    //
    // Check if we need to create a mirrored imagelist. [samera]
    //
    if (IS_BIDI_LOCALIZED_SYSTEM())
    {
        flags |= ILC_MIRROR;
    }

    BOOL fFailedAlloc = FALSE;
    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        if (g_rgshil[i].himl == NULL)
        {
            g_rgshil[i].himl = ImageList_Create(g_rgshil[i].size.cx, g_rgshil[i].size.cy, ILC_MASK|ILC_SHARED|flags, 0, 32);
            fFailedAlloc |= (g_rgshil[i].himl == NULL);
        }
        else
        {
            // set the flags incase the colour depth has changed...
            // ImageList_setFlags already calls ImageList_remove on success
            if (!ImageList_SetFlags(g_rgshil[i].himl, ILC_MASK|ILC_SHARED|flags))
            {
                // Couldn't change flags; tough.  At least remove them all.
                ImageList_Remove(g_rgshil[i].himl, -1);
            }
            ImageList_SetIconSize(g_rgshil[i].himl, g_rgshil[i].size.cx, g_rgshil[i].size.cy);
        }

        // set the bk colors to COLOR_WINDOW since this is what will
        // be used most of the time as the bk for these lists (cabinet, tray)
        // this avoids having to do ROPs when drawing, thus making it fast

        if (g_rgshil[i].himl)
        {
            ImageList_SetBkColor(g_rgshil[i].himl, GetSysColor(COLOR_WINDOW));
        }
    }

    // If any imagelist allocation failed, fail the whole initialization
    if (fFailedAlloc)
    {
        _ShellImageListTerm();
        return FALSE;
    }
    else
    {
        // Load all of the icons with fRestore == TRUE
        if (fRestore)
        {
            TCHAR szModule[MAX_PATH];
            HKEY hkeyIcons;

            GetModuleFileName(HINST_THISDLL, szModule, ARRAYSIZE(szModule));

            // WARNING: this code assumes that these icons are the first in
            // our RC file and are in this order and these indexes correspond
            // to the II_ constants in shell.h.

            hkeyIcons = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("Shell Icons"), FALSE);

            for (i = 0; i < ARRAYSIZE(c_SystemImageListIndexes); i++) 
            {
                HICON rghicon[ARRAYSIZE(g_rgshil)] = {0};

                // check to see if icon is overridden in the registry

                if (hkeyIcons)
                {
                    TCHAR val[12];
                    TCHAR ach[MAX_PATH];
                    DWORD cb = sizeof(ach);

                    StringCchPrintf(val, ARRAYSIZE(val), TEXT("%d"), i);    // ok to truncate

                    ach[0] = 0;
                    SHQueryValueEx(hkeyIcons, val, NULL, NULL, (LPBYTE)ach, &cb);

                    if (ach[0])
                    {
                        int iIcon = PathParseIconLocation(ach);

                        for (int j = 0; j < ARRAYSIZE(g_rgshil); j++)
                        {
                            ExtractIcons(ach, iIcon, g_rgshil[j].size.cx, g_rgshil[j].size.cy,
                                            &rghicon[j], NULL, 1, g_lrFlags);
                        }
                    }
                }

                // if we got a large icon, run with that for everyone.  otherwise fall back to loadimage.
                if (rghicon[SHIL_LARGE] == NULL)
                {
                    for (int j = 0; j < ARRAYSIZE(rghicon); j++)
                    {
                        if (rghicon[j] == NULL)
                        {
                            rghicon[j] = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(c_SystemImageListIndexes[i]),
                                                IMAGE_ICON, g_rgshil[j].size.cx, g_rgshil[j].size.cy, g_lrFlags);
                        }
                    }
                }

                int iIndex = SHAddIconsToCache(rghicon, szModule, i, 0);
                ASSERT(iIndex == i || iIndex == -1);     // assume index
                _DestroyIcons(rghicon, ARRAYSIZE(rghicon));

                if (iIndex == -1)
                {
                    fFailedAlloc = TRUE;
                    break;
                }
            }

            if (hkeyIcons)
                RegCloseKey(hkeyIcons);

            if (fFailedAlloc)
            {
                FlushIconCache();
                _ShellImageListTerm();
                return FALSE;
            }
        }

        //
        // Refresh the overlay image so that the overlays are added to the imaglist.
        // GetIconOverlayManager() will initialize the overlay manager if necessary.
        //
        IShellIconOverlayManager *psiom;
        if (SUCCEEDED(GetIconOverlayManager(&psiom)))
        {
            psiom->RefreshOverlayImages(SIOM_OVERLAYINDEX | SIOM_ICONINDEX);
            psiom->Release();
        }

        return TRUE;
    }
}

// get a hold of the system image lists

BOOL WINAPI Shell_GetImageLists(HIMAGELIST *phiml, HIMAGELIST *phimlSmall)
{
    if (!_IsSHILInited())
    {
        FileIconInit(FALSE);  // make sure they are created and the right size.

        if (!_IsSHILInited())
            return FALSE;
    }

    if (phiml)
        *phiml = g_rgshil[SHIL_LARGE].himl;

    if (phimlSmall)
        *phimlSmall = g_rgshil[SHIL_SMALL].himl;

    return TRUE;
}

HRESULT SHGetImageList(int iImageList, REFIID riid, void **ppvObj)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (!_IsSHILInited())
    {
        FileIconInit(FALSE);  // make sure they are created and the right size.

        if (!_IsSHILInited())
            return hr;
    }

    ENTERCRITICAL;

    if (iImageList >=0 && iImageList < ARRAYSIZE(g_rgshil))
    {
        hr = HIMAGELIST_QueryInterface(g_rgshil[iImageList].himl, riid, ppvObj);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    LEAVECRITICAL;

    return hr;
}

void WINAPI Shell_SysColorChange(void)
{
    COLORREF clrWindow = GetSysColor(COLOR_WINDOW);

    ENTERCRITICAL;
    for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        ImageList_SetBkColor(g_rgshil[i].himl, clrWindow);
    }
    LEAVECRITICAL;
}

// simulate the document icon by crunching a copy of an icon and putting it in the
// middle of our default document icon, then add it to the passsed image list
//
// in:
//      hIcon   icon to use as a basis for the simulation
//
// returns:
//      hicon
HBITMAP CreateDIB(HDC h, WORD depth, int cx, int cy, RGBQUAD** pprgb)
{
    BITMAPINFO bi = {0};
    bi.bmiHeader.biSize = sizeof(bi.bmiHeader);
    bi.bmiHeader.biWidth = cx;
    bi.bmiHeader.biHeight = cy;
    bi.bmiHeader.biPlanes = 1;
    bi.bmiHeader.biBitCount = depth;
    bi.bmiHeader.biCompression = BI_RGB;

    return CreateDIBSection(h, &bi, DIB_RGB_COLORS, (void**)pprgb, NULL, 0);
}

BOOL HasAlpha(RGBQUAD* prgb, int cx, int cy)
{
    int iTotal = cx * cy;

    for (int i = 0; i < iTotal; i++)
    {
        if (prgb[i].rgbReserved != 0)
            return TRUE;
    }

    return FALSE;
}

void DorkAlpha(RGBQUAD* prgb, int x, int y, int cx, int cy, int cxTotal)
{
    for (int dy = y; dy < (cy + y); dy++)
    {
        for (int dx = x; dx < (cx + x); dx++)
        {
            prgb[dx + dy * cxTotal].rgbReserved = 255;
        }
    }
}


HICON SimulateDocIcon(HIMAGELIST himl, HICON hIcon, int cx, int cy)
{
    if (himl == NULL || hIcon == NULL)
        return NULL;

    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        RGBQUAD* prgb;

        // If the display is in 24 or 32bpp mode, we may have alpha icons, so we'll need to create a dib section
        BOOL fAlphaIcon = (GetDeviceCaps(hdc, BITSPIXEL) >= 24)? TRUE: FALSE;
        HBITMAP hbmColor;
        if (fAlphaIcon)
        {
            hbmColor = CreateDIB(hdc, 32, cx, cy, &prgb);
        }
        else
        {
            hbmColor = CreateCompatibleBitmap(hdc, cx, cy);
        }

        if (hbmColor)
        {
            HBITMAP hbmMask = CreateBitmap(cx, cy, 1, 1, NULL);
            if (hbmMask)
            {
                HDC hdcMem = CreateCompatibleDC(hdc);
                if (hdcMem)
                {
                    HBITMAP hbmT = (HBITMAP)SelectObject(hdcMem, hbmMask);
                    UINT iIndex = Shell_GetCachedImageIndex(c_szShell32Dll, II_DOCNOASSOC, 0);
                    ImageList_Draw(himl, iIndex, hdcMem, 0, 0, ILD_MASK);

                    SelectObject(hdcMem, hbmColor);
                    ImageList_DrawEx(himl, iIndex, hdcMem, 0, 0, 0, 0, RGB(0,0,0), CLR_DEFAULT, ILD_NORMAL);

                    // Check to see if the parent has alpha. If so, we'll have to dork with the child's alpha later on.
                    BOOL fParentHasAlpha = fAlphaIcon?HasAlpha(prgb, cx, cy):FALSE;

                    HDC hdcMemChild = CreateCompatibleDC(hdcMem);
                    if (hdcMemChild)
                    {
                        // Notes:
                        // First: create a 24bpp Dibsection. We want to merge the alpha channel into the final image,
                        //        not preserve it.
                        // Second: The document icon has "Goo" in it. We remove this goo by blitting white into it, then 
                        //         merging the child bitmap
                        HBITMAP hbmp = CreateDIB(hdc, 24, cx/2 + 2, cy/2 + 2, NULL);
                        if (hbmp)
                        {
                            HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcMemChild, hbmp);

                            RECT rc;
                            rc.left = 0;
                            rc.top = 0;
                            rc.right = cx/2 + 3;    // Extra space to remove goo in the document icon
                            rc.bottom = cy/2 + 3;

                            // Fill with white. NOTE: don't use PatBlt because it actually adds an alpha channel!
                            SHFillRectClr(hdcMemChild, &rc, RGB(255,255,255));

                            DrawIconEx(hdcMemChild, 1, 1, hIcon, cx/2, cy/2, 0, NULL, DI_NORMAL);

                            BitBlt(hdcMem, cx/4-1, cy/4-1, cx/2+3, cy/2+3, hdcMemChild, 0, 0, SRCCOPY);
                            SelectObject(hdcMemChild, hbmpOld);
                            DeleteObject(hbmp);
                        }
                        DeleteDC(hdcMemChild);
                    }

                    if (fParentHasAlpha)
                    {
                        // If the parent had alpha, we need to bring the child alpha to opaqe
                        DorkAlpha(prgb, cx/4, cy/4, cx/2, cy/2, cx);
                    }

                    SelectBitmap(hdcMem, hbmT);
                    DeleteDC(hdcMem);
                }

                ICONINFO ii = {0};
                ii.fIcon    = TRUE;
                ii.hbmColor = hbmColor;
                ii.hbmMask  = hbmMask;
                hIcon = CreateIconIndirect(&ii);

                DeleteObject(hbmMask);
            }
            DeleteObject(hbmColor);
        }
        ReleaseDC(NULL, hdc);
    }

    return hIcon;
}

// Check if the same number of images is present in all of the image lists.
// If any of the imagelists have less icons than the others, fill the imagelist
// in with the document icon to make them all consistent.
//
// Eg:  WebZip v3.80 and v4.00 queries for the large and small image lists,
// and adds 2 icons to it.  However, it doesn't know to add these icons to the
// newer image lists.  Hence, the image lists are out of sync, and later on,
// the wrong icon appears in their treeview.
//
// Allaire Homesite 4.5 does the same thing.

void CheckConsistencyOfImageLists(void)
{
    // This has to be done under the critical section to avoid race conditions.
    // Otherwise, if another thread is adding icons to the image list,
    // we will think it is corrupted when in fact it is just fine, and
    // then our attempts to repair it will corrupt it!

    ASSERTCRITICAL;

    int i, iMax = 0, iImageListsCounts[ARRAYSIZE(g_rgshil)];
    BOOL bIdentical = TRUE;


    // Loop through all the image lists getting:
    //
    // 1) the image count for each list
    // 2) Compare the count against the count of the first (large)
    //    imagelist to see if there are any differences.
    // 3) Determine the max number of images (in a single list) across all the image lists

    for (i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        iImageListsCounts[i] = ImageList_GetImageCount (g_rgshil[i].himl);

        if (iImageListsCounts[i] != iImageListsCounts[0])
        {
            bIdentical = FALSE;
        }

        if (iImageListsCounts[i] > iMax)
        {
            iMax = iImageListsCounts[i];
        }
    }

    if (bIdentical)
    {
        return;
    }


    // For each imagelist, add the document icon as filler to bring it upto iMax in size

    for (i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        if (iImageListsCounts[i] < iMax)
        {
            HICON hIcon = (HICON) LoadImage (HINST_THISDLL, MAKEINTRESOURCE(IDI_DOCUMENT),
                                             IMAGE_ICON, g_rgshil[i].size.cx,
                                             g_rgshil[i].size.cy, LR_DEFAULTCOLOR);
            if (hIcon)
            {
                while (iImageListsCounts[i] < iMax)
                {
                    ImageList_ReplaceIcon (g_rgshil[i].himl, -1, hIcon);
                    iImageListsCounts[i]++;
                }

                DestroyIcon (hIcon);
            }
        }
    }
}

// add icons to the system imagelist (icon cache) and put the location
// in the location cache
//
// in:
//      hIcon, hIconSmall       the icons, hIconSmall can be NULL
//      pszIconPath             locations (for location cache)
//      iIconIndex              index in pszIconPath (for location cache)
//      uIconFlags              GIL_ flags (for location cahce)
// returns:
//      location in system image list
//
int SHAddIconsToCache(HICON rghicon[SHIL_COUNT], LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags)
{
    int iImage = -1;

    if (!_IsSHILInited())
    {
        FileIconInit(FALSE);  // make sure they are created and the right size.

        if (!_IsSHILInited())
            return iImage;
    }

    //
    // NOTE: user should call SHLookupIconIndex or RemoveFromIconTable first to make sure 
    // it isn't already in shell icon cache, or use Shell_GetCachedImageIndex to add icons to
    // the cache. Adding the same icon to icon cache several times may cause shell to flash.
    //
    if (!(uIconFlags & GIL_DONTCACHE))
    {
        iImage = LookupIconIndex(pszIconPath, iIconIndex, uIconFlags);
        if (-1 != iImage)
        {
            return iImage;
        }
    }

    HICON rghiconT[ARRAYSIZE(g_rgshil)] = {0};

    BOOL fFailure = FALSE;
    int i;

    for (i = 0; i < ARRAYSIZE(g_rgshil); i++)
    {
        if (rghicon == NULL)
        {
            SHDefExtractIcon(pszIconPath, iIconIndex, uIconFlags, &rghiconT[i], NULL, g_rgshil[i].size.cx);
        }
        else
        {
            if (rghicon[i])
            {
                rghiconT[i] = rghicon[i];
            }
            else
            {
                rghiconT[i] = rghicon[SHIL_LARGE];
            }
        }

        if (rghiconT[i] == NULL)
        {
            fFailure = TRUE;
            break;
        }
    }

    ENTERCRITICAL;

    // test again in case there was a race between the test at the top and the
    // icon loading code.

    if (!(uIconFlags & GIL_DONTCACHE))
    {
        iImage = LookupIconIndex(pszIconPath, iIconIndex, uIconFlags);
    }

    if (!fFailure && _IsSHILInited() && (-1 == iImage))
    {
        // still not in the table so we

        CheckConsistencyOfImageLists();

        int iImageFree = GetFreeImageIndex();

        TraceMsg(TF_IMAGE, "FreeImageIndex = %d", iImageFree);

        for (i = 0; i < ARRAYSIZE(g_rgshil); i++)
        {
            int iImageT = ImageList_ReplaceIcon(g_rgshil[i].himl, iImageFree, rghiconT[i]);

            TraceMsg(TF_IMAGE, "ImageList_ReplaceIcon(%d) returned = %d", i, iImageT);

            if (iImageT < 0)
            {
                // failure -- break and undo changes
                break;
            }
            else
            {
                ASSERT(iImage == -1 || iImage == iImageT);
                iImage = iImageT;
            }
        }

        if (i < ARRAYSIZE(g_rgshil))
        {
            // failure
            if (iImageFree == -1)
            {
                // only remove it if it was added at the end otherwise all the
                // index's above iImage will change.
                // ImageList_ReplaceIcon should only fail on the end anyway.
                for (int j = 0; j < i; j++)
                {
                    ImageList_Remove(g_rgshil[j].himl, iImage);
                }
            }
            iImage = -1;
        }
        else
        {
            // success
            ASSERT(iImage >= 0);
            AddToIconTable(pszIconPath, iIconIndex, uIconFlags, iImage);
        }
    }

    LEAVECRITICAL;

    if (rghicon == NULL)
    {
        // destroy the icons we allocated
        _DestroyIcons(rghiconT, ARRAYSIZE(rghiconT));
    }

    return iImage;
}

//
//  default handler to extract a icon from a file
//
//  supports GIL_SIMULATEDOC
//
//  returns S_OK if success
//  returns S_FALSE if the file has no icons (or not the asked for icon)
//  returns E_FAIL for files on a slow link.
//  returns E_FAIL if cant access the file
//
//  LOWORD(nIconSize) = normal icon size
//  HIWORD(nIconSize) = smal icon size
//
STDAPI SHDefExtractIcon(LPCTSTR pszIconFile, int iIndex, UINT uFlags,
                        HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    HICON hIcons[2] = {0, 0};

    UINT u;

#ifdef DEBUG
    TCHAR ach[128];
    GetModuleFileName(HINST_THISDLL, ach, ARRAYSIZE(ach));

    if (lstrcmpi(pszIconFile, ach) == 0 && iIndex >= 0)
    {
        TraceMsg(TF_WARNING, "Re-extracting %d from SHELL32.DLL", iIndex);
    }
#endif

    HIMAGELIST himlLarge, himlSmall;
    Shell_GetImageLists(&himlLarge, &himlSmall);

    //
    //  get the icon from the file
    //
    if (PathIsSlow(pszIconFile, -1))
    {
        DebugMsg(DM_TRACE, TEXT("not extracting icon from '%s' because of slow link"), pszIconFile);
        return E_FAIL;
    }

#ifdef XXDEBUG
    TraceMsg(TF_ALWAYS, "Extracting icon %d from %s.", iIndex, pszIconFile);
    Sleep(500);
#endif

    //
    // nIconSize == 0 means use the default size.
    // Backup is passing nIconSize == 1 need to support them too.
    //
    if (nIconSize <= 2)
        nIconSize = MAKELONG(g_cxIcon, g_cxSmIcon);

    if (uFlags & GIL_SIMULATEDOC)
    {
        HICON hIconSmall;

        u = ExtractIcons(pszIconFile, iIndex, g_cxSmIcon, g_cySmIcon,
            &hIconSmall, NULL, 1, g_lrFlags);

        if (u == -1)
            return E_FAIL;

        hIcons[0] = SimulateDocIcon(himlLarge, hIconSmall, g_cxIcon, g_cyIcon);
        hIcons[1] = SimulateDocIcon(himlSmall, hIconSmall, g_cxSmIcon, g_cySmIcon);

        if (hIconSmall)
            DestroyIcon(hIconSmall);
    }
    else
    {
        u = ExtractIcons(pszIconFile, iIndex, nIconSize, nIconSize,
            hIcons, NULL, 2, g_lrFlags);

        if (-1 == u)
            return E_FAIL;

#ifdef DEBUG
        if (0 == u)
        {
            TraceMsg(TF_WARNING, "Failed to extract icon %d from %s.", iIndex, pszIconFile);    
        }
#endif
    }

    if (phiconLarge)
        *phiconLarge = hIcons[0];
    else if (hIcons[0])
        DestroyIcon(hIcons[0]);

    if (phiconSmall)
        *phiconSmall = hIcons[1];
    else if (hIcons[1])
        DestroyIcon(hIcons[1]);

    return u == 0 ? S_FALSE : S_OK;
}


#ifdef UNICODE

STDAPI SHDefExtractIconA(LPCSTR pszIconFile, int iIndex, UINT uFlags, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    HRESULT hr = E_INVALIDARG;

    if (IS_VALID_STRING_PTRA(pszIconFile, -1))
    {
        WCHAR wsz[MAX_PATH];

        SHAnsiToUnicode(pszIconFile, wsz, ARRAYSIZE(wsz));
        hr = SHDefExtractIcon(wsz, iIndex, uFlags, phiconLarge, phiconSmall, nIconSize);
    }
    return hr;
}

#else

STDAPI SHDefExtractIconW(LPCWSTR pszIconFile, int iIndex, UINT uFlags, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    HRESULT hr = E_INVALIDARG;

    if (IS_VALID_STRING_PTRW(pszIconFile, -1))
    {
        char sz[MAX_PATH];

        SHUnicodeToAnsi(pszIconFile, sz, ARRAYSIZE(sz));
        hr = SHDefExtractIcon(sz, iIndex, uFlags, phiconLarge, phiconSmall, nIconSize);
    }
    return hr;
}

#endif

//
// in:
//      pszIconPath     file to get icon from (eg. cabinet.exe)
//      iIconIndex      icon index in pszIconPath to get
//      uIconFlags      GIL_ values indicating simulate doc icon, etc.

int WINAPI Shell_GetCachedImageIndex(LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags)
{
    // lots of random codepaths from APIs end up here before init
    if (!_IsSHILInited())
    {
        FileIconInit(FALSE);
        if (!_IsSHILInited())
        {
            return -1;
        }
    }

    int iImageIndex = LookupIconIndex(pszIconPath, iIconIndex, uIconFlags);
    if (iImageIndex == -1)
    {
        iImageIndex = SHAddIconsToCache(NULL, pszIconPath, iIconIndex, uIconFlags);
    }

    return iImageIndex;
}

STDAPI_(void) FixPlusIcons()
{
    // nuke all of the shell internal icons
    HKEY hkeyIcons = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("Shell Icons"), FALSE);
    if (hkeyIcons)
    {
        for (int i = 0; i < ARRAYSIZE(c_SystemImageListIndexes); i++) 
        {
            TCHAR szRegPath[12], szBuf[MAX_PATH];
            DWORD cb = sizeof(szBuf);

            StringCchPrintf(szRegPath, ARRAYSIZE(szRegPath), TEXT("%d"), i);    // ok to truncate

            if (SHQueryValueEx(hkeyIcons, szRegPath, NULL, NULL, (LPBYTE)szBuf, &cb) == ERROR_SUCCESS &&
                StrStrI(szBuf, TEXT("cool.dll")))
            {
                RegDeleteValue(hkeyIcons, szRegPath);
            }
        }
        RegCloseKey(hkeyIcons);
    }
    static const struct
    {
        const CLSID* pclsid;
        LPCTSTR pszIcon;
    }
    c_rgCLSID[] =
    {
        { &CLSID_NetworkPlaces,     TEXT("shell32.dll,17") },
        { &CLSID_ControlPanel,      TEXT("shell32.dll,-137") },
        { &CLSID_Printers,          TEXT("shell32.dll,-138") },
        { &CLSID_MyComputer,        TEXT("explorer.exe,0") },
        { &CLSID_Remote,            TEXT("rnaui.dll,0") },
        { &CLSID_CFonts,            TEXT("fontext.dll,-101") },
        { &CLSID_RecycleBin,        NULL },
        { &CLSID_Briefcase,         NULL },
    };

    for (int i = 0; i < ARRAYSIZE(c_rgCLSID); i++)
    {
        TCHAR szCLSID[64], szRegPath[128], szBuf[MAX_PATH];
        DWORD cb = sizeof(szBuf);

        SHStringFromGUID(*c_rgCLSID[i].pclsid, szCLSID, ARRAYSIZE(szCLSID));
        StringCchPrintf(szRegPath, ARRAYSIZE(szRegPath), TEXT("CLSID\\%s\\DefaultIcon"), szCLSID);  // should fit always 64 + 18 < 128

        if (SHRegGetValue(HKEY_CLASSES_ROOT, szRegPath, NULL, SRRF_RT_REG_SZ, NULL, szBuf, &cb) == ERROR_SUCCESS &&
            StrStrI(szBuf, TEXT("cool.dll")))
        {
            if (IsEqualGUID(*c_rgCLSID[i].pclsid, CLSID_RecycleBin))
            {
                RegSetValueString(HKEY_CLASSES_ROOT, szRegPath, TEXT("Empty"), TEXT("shell32.dll,31"));
                RegSetValueString(HKEY_CLASSES_ROOT, szRegPath, TEXT("Full"), TEXT("shell32.dll,32"));
                if (StrStr(szBuf, TEXT("20")))
                    RegSetString(HKEY_CLASSES_ROOT, szRegPath, TEXT("shell32.dll,31")); // empty
                else
                    RegSetString(HKEY_CLASSES_ROOT, szRegPath, TEXT("shell32.dll,32")); // full
            }
            else
            {
                if (c_rgCLSID[i].pszIcon)
                    RegSetString(HKEY_CLASSES_ROOT, szRegPath, c_rgCLSID[i].pszIcon);
                else
                    RegDeleteValue(HKEY_CLASSES_ROOT, szRegPath);
            }
        }
    }

    static const struct
    {
        LPCTSTR pszProgID;
        LPCTSTR pszIcon;
    }
    c_rgProgID[] =
    {
        { TEXT("Folder"),   TEXT("shell32.dll,3") },
        { TEXT("Directory"),TEXT("shell32.dll,3") },
        { TEXT("Drive"),    TEXT("shell32.dll,8") },
        { TEXT("drvfile"),  TEXT("shell32.dll,-154") },
        { TEXT("vxdfile"),  TEXT("shell32.dll,-154") },
        { TEXT("dllfile"),  TEXT("shell32.dll,-154") },
        { TEXT("sysfile"),  TEXT("shell32.dll,-154") },
        { TEXT("txtfile"),  TEXT("shell32.dll,-152") },
        { TEXT("inifile"),  TEXT("shell32.dll,-151") },
        { TEXT("inffile"),  TEXT("shell32.dll,-151") },
    };

    for (i = 0; i < ARRAYSIZE(c_rgProgID); i++)
    {
        TCHAR szRegPath[128], szBuf[MAX_PATH];
        DWORD cb = sizeof(szBuf);

        HRESULT hr = StringCchPrintf(szRegPath, ARRAYSIZE(szRegPath), TEXT("%s\\DefaultIcon"), c_rgProgID[i].pszProgID);
        if (SUCCEEDED(hr))
        {
            if (SHRegGetValue(HKEY_CLASSES_ROOT, szRegPath, NULL, SRRF_RT_REG_SZ, NULL, szBuf, &cb) == ERROR_SUCCESS &&
                StrStrI(szBuf, TEXT("cool.dll")))
            {
                RegSetString(HKEY_CLASSES_ROOT, szRegPath, c_rgProgID[i].pszIcon);
            }
        }
    }

    FlushIconCache();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shell32\findband.cpp ===
// findband.cpp : Implementation of CFileSearchBand
#include "shellprv.h"
#include "findband.h"
#include "findfilter.h"
#include <ciodm.h>      // AdminIndexServer custom interface

#define  CGID_FileSearchBand      CLSID_FileSearchBand

extern int IsVK_TABCycler(MSG *pMsg);


enum {  // toolbar image list indices:
    iFSTBID_NEW,
    iFSTBID_HELP,
};
#define  MAKE_FSTBID(ilIndex)    (100 /*arbitrary*/ + (ilIndex))

// toolbar button IDs
#define  FSTBID_NEW        MAKE_FSTBID(iFSTBID_NEW)
#define  FSTBID_HELP       MAKE_FSTBID(iFSTBID_HELP)

static const TBBUTTON _rgtb[] =
{
    {  iFSTBID_NEW,  FSTBID_NEW,  TBSTATE_ENABLED,  BTNS_AUTOSIZE | BTNS_SHOWTEXT,{0, 0}, 0, 0},
    {  -1,          0,            TBSTATE_ENABLED,  BTNS_SEP,                     {0, 0}, 0, 0},
    {  iFSTBID_HELP, FSTBID_HELP, TBSTATE_ENABLED,  BTNS_AUTOSIZE,                {0, 0}, 0, 1},
};


inline BOOL _IsEditWindowClass(HWND hwndTest)
{
    return IsWindowClass(hwndTest, TEXT("Edit"));
}

inline BOOL _IsComboWindowClass(HWND hwndTest)
{
    #define COMBO_CLASS  TEXT("ComboBox")
    return _IsEditWindowClass(hwndTest) ?
                IsWindowClass(GetParent(hwndTest), COMBO_CLASS) :
                IsWindowClass(hwndTest, COMBO_CLASS);
}


// CFileSearchBand impl



CWndClassInfo& CFileSearchBand::GetWndClassInfo()
{
    static CWndClassInfo wc =   { 
        { sizeof(WNDCLASSEX), CS_SAVEBITS, StartWindowProc, 
          0, 0, 0, 0, 0, 0, 0, 
          FILESEARCHCTL_CLASS, 0 }, 
          NULL, NULL, IDC_ARROW, TRUE, 0, _T("")
    };
    return wc;
}

CFileSearchBand::CFileSearchBand()  
    :   _dlgFSearch(this),
        _dlgCSearch(this),
#ifdef __PSEARCH_BANDDLG__
        _dlgPSearch(this),
#endif __PSEARCH_BANDDLG__
        _fValid(TRUE),
        _dwBandID(-1),
        _dwBandViewMode(DBIF_VIEWMODE_VERTICAL)
{
    // Verify that it initialized correctly:
    ASSERT(_pBandDlg == NULL);
    ASSERT(_psb == NULL);
    ASSERT(_guidSearch == GUID_NULL);
    ASSERT(_fDirty == FALSE);
    ASSERT(_fDeskBand == FALSE);
    ASSERT(_punkSite == NULL);
    ASSERT(_bSendFinishedDisplaying == FALSE);
    

    m_bWindowOnly = TRUE;

    ZeroMemory(&_siHorz, sizeof(_siHorz));
    ZeroMemory(&_siVert, sizeof(_siVert));
    _siHorz.cbSize = _siVert.cbSize = sizeof(SCROLLINFO);
    _sizeMin.cx = _sizeMin.cy = 0;
    _sizeMax.cx = _sizeMax.cy = 32000; // arbitrarily large.
}

CFileSearchBand::~CFileSearchBand()
{
    ImageList_Destroy(_hilDefault);
    ImageList_Destroy(_hilHot);
}


HWND CFileSearchBand::Create(
    HWND hWndParent, 
    RECT& rcPos, 
    LPCTSTR szWindowName, 
    DWORD dwStyle, 
    DWORD dwExStyle, 
    UINT nID)
{
    INITCOMMONCONTROLSEX icc;
    TCHAR       szCaption[128];

    icc.dwSize = sizeof(icc);
    icc.dwICC =  ICC_DATE_CLASSES|ICC_UPDOWN_CLASS|ICC_USEREX_CLASSES|ICC_ANIMATE_CLASS;

    EVAL(LoadString(HINST_THISDLL, IDS_FSEARCH_CAPTION, szCaption, ARRAYSIZE(szCaption)));

    InitCommonControlsEx(&icc);

    dwExStyle |= WS_EX_CONTROLPARENT;
    dwStyle |= WS_CLIPCHILDREN;

    return CWindowImpl<CFileSearchBand>::Create(hWndParent, rcPos, szCaption,
                                                 dwStyle, dwExStyle, nID);
}


LRESULT CFileSearchBand::OnCreate(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (FAILED(ShowBandDialog(SRCID_SFileSearch)))
        return -1;
    return 0;
}


CBandDlg* CFileSearchBand::GetBandDialog(REFGUID guidSearch)
{
    if (IsEqualGUID(guidSearch, SRCID_SFileSearch))
    {
        return &_dlgFSearch;
    }
#ifdef __PSEARCH_BANDDLG__
    else if (IsEqualGUID(guidSearch, SRCID_SFindPrinter))
    {
        return &_dlgPSearch;
    }
#endif __PSEARCH_BANDDLG__
    else if (IsEqualGUID(guidSearch, SRCID_SFindComputer))
    {
        return &_dlgCSearch;
    }

    return NULL;
}


//  IFileSearchBand::SetSearchParameters()
STDMETHODIMP CFileSearchBand::SetSearchParameters(
    IN BSTR* pbstrSearchID,
    IN VARIANT_BOOL bNavToResults, 
    IN OPTIONAL VARIANT *pvarScope, 
    IN OPTIONAL VARIANT *pvarQueryFile)
{
    HRESULT hr;
    
    GUID guidSearch;
    if (SUCCEEDED(SHCLSIDFromString(*pbstrSearchID, &guidSearch)))
    {
        hr = ShowBandDialog(guidSearch, bNavToResults, TRUE);
        if (SUCCEEDED(hr))
        {
            CBandDlg* pBandDlg = GetBandDialog(guidSearch);
            ASSERT(pBandDlg);

            if (pvarScope && pvarScope->vt != VT_EMPTY)
                pBandDlg->SetScope(pvarScope, TRUE);

            if (pvarQueryFile && pvarQueryFile->vt != VT_EMPTY)
                pBandDlg->SetQueryFile(pvarQueryFile);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CFileSearchBand::ShowBandDialog(
    REFGUID guidSearch, 
    BOOL bNavigateToResults,
    BOOL bDefaultFocusCtl)
{
    CBandDlg  *pDlgNew = NULL, 
              *pDlgOld = _pBandDlg;
    GUID      guidOld  = _guidSearch;
    BOOL      bNewWindow = FALSE;

    if (NULL == (pDlgNew = GetBandDialog(guidSearch)))
        return E_INVALIDARG;

    _pBandDlg   = pDlgNew;
    _guidSearch = guidSearch;
    
    //  If the dialog window has not been created, do so now.
    if (!::IsWindow(pDlgNew->Hwnd()))
    {
        if (NULL == pDlgNew->Create(*this))
        {
            _pBandDlg = pDlgOld;
            _guidSearch = guidOld;
            return E_FAIL;
        }
        bNewWindow = TRUE;
    }

    if (pDlgNew != pDlgOld)
    {
        //  If we have an active dialog, hide it
        if (pDlgOld && ::IsWindow(pDlgOld->Hwnd()))
        {
            ::ShowWindow(pDlgOld->Hwnd(), SW_HIDE);
            pDlgOld->OnBandDialogShow(FALSE);
        }
        
        bNewWindow = TRUE;
    }

    if (bNewWindow)
    {
        //  Show the new dialog window
        UpdateLayout(BLF_ALL);
        _pBandDlg->OnBandDialogShow(TRUE);
        ::ShowWindow(_pBandDlg->Hwnd(), SW_SHOW);
        ::UpdateWindow(_pBandDlg->Hwnd());

        if (bDefaultFocusCtl)
            _pBandDlg->SetDefaultFocus();
    }

    if (bNavigateToResults)
    {
        //  Navigate to results shell folder.
        IWebBrowser2* pwb2;
        HRESULT hr = IUnknown_QueryService(GetTopLevelBrowser(), SID_SWebBrowserApp, IID_PPV_ARG(IWebBrowser2, &pwb2));
        if (SUCCEEDED(hr))
        {
            _pBandDlg->NavigateToResults(pwb2);
            pwb2->Release();
        }
    }

    return S_OK;
}

void CFileSearchBand::AddButtons(BOOL fAdd)
{
    if (_fDeskBand)
    {
        ASSERT(BandSite());
        IExplorerToolbar* piet;
        if (SUCCEEDED(BandSite()->QueryInterface(IID_PPV_ARG(IExplorerToolbar, &piet))))
        {
            if (fAdd)
            {
                HRESULT hr = piet->SetCommandTarget((IUnknown*)SAFECAST(this, IOleCommandTarget*), &CGID_FileSearchBand, 0);
                if (hr == S_OK)
                {
                    if (!_fStrings)
                    {
                        piet->AddString(&CGID_SearchBand, HINST_THISDLL, IDS_FSEARCH_TBLABELS, &_cbOffset);
                        _fStrings = TRUE;
                    }

                    if (LoadImageLists())
                        piet->SetImageList(&CGID_FileSearchBand, _hilDefault, _hilHot, NULL);

                    TBBUTTON rgtb[ARRAYSIZE(_rgtb)];
                    memcpy(rgtb, _rgtb, sizeof(_rgtb));
                    for (int i = 0; i < ARRAYSIZE(rgtb); i++)
                        rgtb[i].iString += _cbOffset;

                    piet->AddButtons(&CGID_FileSearchBand, ARRAYSIZE(rgtb), rgtb);
                }
            }
            else
                piet->SetCommandTarget(NULL, NULL, 0);

            piet->Release();
        }
    }
}


BOOL CFileSearchBand::LoadImageLists()
{
    if (_hilDefault == NULL)
    {
        _hilDefault = ImageList_LoadImage(HINST_THISDLL, 
                                            MAKEINTRESOURCE(IDB_FSEARCHTB_DEFAULT), 
                                            18, 0, CLR_DEFAULT, IMAGE_BITMAP, 
                                            LR_CREATEDIBSECTION);
    }

    if (_hilHot == NULL)
    {
        _hilHot = ImageList_LoadImage(HINST_THISDLL, 
                                        MAKEINTRESOURCE(IDB_FSEARCHTB_HOT), 
                                        18, 0, CLR_DEFAULT, IMAGE_BITMAP, 
                                        LR_CREATEDIBSECTION);
    }
    return _hilDefault != NULL && _hilHot != NULL;
}


STDMETHODIMP CFileSearchBand::get_Scope(OUT VARIANT *pvarScope)
{
    if (BandDlg())
        return _pBandDlg->GetScope(pvarScope);

    VariantInit(pvarScope);
    return E_FAIL;
}


STDMETHODIMP CFileSearchBand::get_QueryFile(OUT VARIANT *pvarFile)
{
    if (BandDlg())
        return _pBandDlg->GetQueryFile(pvarFile);

    VariantInit(pvarFile);
    return E_FAIL;
}


STDMETHODIMP CFileSearchBand::get_SearchID(OUT BSTR* pbstrSearchID)
{
    if (!pbstrSearchID)
        return E_POINTER;

    WCHAR wszGuid[GUIDSTR_MAX+1];

    SHStringFromGUIDW(_guidSearch, wszGuid, ARRAYSIZE(wszGuid));
    *pbstrSearchID = SysAllocString(wszGuid);

    return IsEqualGUID(GUID_NULL, _guidSearch) ? S_FALSE : S_OK;
}


CBandDlg* CFileSearchBand::BandDlg()
{
    return _pBandDlg;
}


HRESULT CFileSearchBand::SetFocus()
{
    HRESULT hr = AutoActivate();
    if (SUCCEEDED(hr))
    {
        if (!IsChild(GetFocus()))
            ::SetFocus(BandDlg()->Hwnd());
    }
    return hr;
}


LRESULT CFileSearchBand::OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    LRESULT lRet = CWindowImpl<CFileSearchBand>::DefWindowProc(uMsg, wParam, lParam);
    AutoActivate();
    return lRet;
}


LRESULT CFileSearchBand::OnWinIniChange(UINT, WPARAM, LPARAM, BOOL&)
{
    _metrics.OnWinIniChange(BandDlg()->Hwnd());
    BandDlg()->OnWinIniChange();
    UpdateLayout();
    return 0;
}

HRESULT CFileSearchBand::AutoActivate()
{
    HRESULT hr = S_OK;

    if (!::IsWindow(m_hWnd))
        return hr;

    if (_fDeskBand)
    {
        if (_punkSite)
        {
            IInputObjectSite* pios;
            hr = _punkSite->QueryInterface(IID_PPV_ARG(IInputObjectSite, &pios));
            if (SUCCEEDED(hr))
            {
                hr = pios->OnFocusChangeIS(SAFECAST(this, IInputObject*), TRUE);
                pios->Release();
            }
        }
    }
    else if (!m_bUIActive)
    {
        RECT rc;
        ::GetWindowRect(m_hWnd, &rc);
        ::MapWindowPoints(HWND_DESKTOP, GetParent(), (LPPOINT)&rc, 2);
        hr = DoVerb(OLEIVERB_UIACTIVATE, NULL, NULL, 0, GetParent(), &rc);
    }

    return hr;
}


void  CFileSearchBand::SetDirty(BOOL bDirty)  
{ 
    _fDirty = bDirty; 
    _dlgFSearch.UpdateSearchCmdStateUI(); 
}


LRESULT CFileSearchBand::OnSize(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
{
    POINTS pts = MAKEPOINTS(lParam);
    LayoutControls(pts.x, pts.y, BLF_ALL);
    return 0;
}


LRESULT CFileSearchBand::OnEraseBkgnd(UINT, WPARAM, LPARAM, BOOL&)  
{
    return TRUE; 
}


HRESULT CFileSearchBand::SetObjectRects(LPCRECT prcPos, LPCRECT prcClip)
{
    return IOleInPlaceObjectWindowlessImpl<class CFileSearchBand>::SetObjectRects(prcPos, prcClip);  
}


STDMETHODIMP CFileSearchBand::PrivateQI(REFIID iid, void **ppvObject) 
{ 
    return _InternalQueryInterface(iid, ppvObject);
}


STDMETHODIMP CFileSearchBand::DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent) 
{
    //  Patch in shell32 logic.
    return CShell32AtlIDispatch<CFileSearchBand, &CLSID_FileSearchBand, &IID_IFileSearchBand, &LIBID_Shell32, 1, 0, CComTypeInfoHolder>::
        DoVerbUIActivate(prcPosRect, hwndParent, m_hWnd);
}


void CFileSearchBand::UpdateLayout(ULONG fLayoutFlags)
{
    RECT rc;
    GetClientRect(&rc);
    LayoutControls(RECTWIDTH(rc), RECTHEIGHT(rc), fLayoutFlags);
}


void CFileSearchBand::LayoutControls(int cx, int cy, ULONG fLayoutFlags)
{
    if (/*NULL == BandDlg() ||*/ !::IsWindow(BandDlg()->Hwnd()))
        return;

    SIZE sizeMin;
    BandDlg()->GetMinSize(m_hWnd, &sizeMin); // size of dialog

    if (fLayoutFlags & BLF_CALCSCROLL)
    {
        //  Stash pos before recalculating
        POINT pos;
        pos.x = _siHorz.nPos;
        pos.y = _siVert.nPos;

        _siHorz.fMask = _siVert.fMask = (SIF_RANGE|SIF_PAGE);

        _siHorz.nPage = cx; // thumb width
        _siVert.nPage = cy; // thumb height

        SIZE sizeDelta; // difference between what we have to show and what is shown.
        sizeDelta.cx = sizeMin.cx - _siHorz.nPage;
        sizeDelta.cy = sizeMin.cy - _siVert.nPage;

        //  establish maximum scroll positions
        _siHorz.nMax = sizeDelta.cx > 0 ? sizeMin.cx - 1 : 0;
        _siVert.nMax = sizeDelta.cy > 0 ? sizeMin.cy - 1 : 0;

        //  establish horizontal scroll pos
        if (sizeDelta.cx <= 0)   
            _siHorz.nPos = 0;  // scroll to extreme left if we're removing scroll bar
        else if (sizeDelta.cx < _siHorz.nPos) 
            _siHorz.nPos = sizeDelta.cx; // remove right-hand vacancy

        if (_siHorz.nPos != pos.x)
            _siHorz.fMask |= SIF_POS;

        //  establish vertical scroll pos
        if (sizeDelta.cy <= 0)  
            _siVert.nPos = 0; // scroll to top if we're removing scroll bar
        else if (sizeDelta.cy < _siVert.nPos) 
            _siVert.nPos = sizeDelta.cy; // remove lower-portion vacancy

        if (_siVert.nPos != pos.y)
            _siVert.fMask |= SIF_POS; 

        //  Note: can't call SetScrollInfo here, as it may generate
        //  a WM_SIZE and recurse back to this function before we had a 
        //  chance to SetWindowPos() our subdlg.  So defer it until after 
        //  we've done this.
    }

    DWORD fSwp = SWP_NOZORDER | SWP_NOACTIVATE;

    if (0 == (fLayoutFlags & BLF_RESIZECHILDREN))
        fSwp |= SWP_NOSIZE;

    if (0 == (fLayoutFlags & BLF_SCROLLWINDOW))
        fSwp |= SWP_NOMOVE;

     //  Move or size the main subdialog as requested...
    if (0 == (fSwp & SWP_NOMOVE) || 0 == (fSwp & SWP_NOSIZE))
        ::SetWindowPos(BandDlg()->Hwnd(), NULL, -_siHorz.nPos, -_siVert.nPos, 
                       