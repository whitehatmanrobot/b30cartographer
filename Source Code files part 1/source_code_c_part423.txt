              L"\r\n\t%ws\t\t%ws",
                                         pLogEntry->pwszPath,
                                         wszErrorBuffer );

                    pwszCurrent += InfoSize;
                    pLogEntry = (PACCESS_PROP_LOG_ENTRY)LogList.NextData();

                }
            }
        }
    }


    //
    // Write to the event log
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = InitializeEvents();

        if(dwErr == ERROR_SUCCESS)
        {

            hEventlog = RegisterEventSource( NULL, L"AclPropagation" );

            if(hEventlog == NULL)
            {

                dwErr = GetLastError();
                if(dwErr == RPC_S_UNKNOWN_IF)
                {
                    acDebugOut(( DEB_ERROR, "Eventlog service not started!\n" ));
                    dwErr = ERROR_SUCCESS;

                }

            }
            else
            {
                if( ReportEvent(hEventlog,
                                EVENTLOG_INFORMATION_TYPE,
                                CATEGORY_NTMARTA,
                                EventType,
                                pSid,
                                1,
                                0,
                                (LPCTSTR *)&pwszStringBuffer,
                                NULL ) == FALSE )
                {
                    dwErr = GetLastError();

                }

                DeregisterEventSource(hEventlog);
            }
        }
    }

    if(pBuff != Buffer)
    {
        AccFree(pBuff);
    }

    if ((dwErr != ERROR_SUCCESS) && (pwszStringBuffer != NULL))
    {
        AccFree(pwszStringBuffer);
    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   InitializeEvents
//
//  Synopsis:   Sets the registry values to enable NTMARTA to act as an event source
//
//  Arguments:  void
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD
InitializeEvents(void)
{

    HKEY    hKey;
    DWORD   dwErr, disp;

    dwErr = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                              TEXT("System\\CurrentControlSet\\Services\\EventLog\\Application\\AclPropagation"),
                              0,
                              TEXT(""),
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              &disp);
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }


    if (disp == REG_CREATED_NEW_KEY)
    {
        RegSetValueEx(  hKey,
                        TEXT("EventMessageFile"),
                        0,
                        REG_EXPAND_SZ,
                        (PBYTE) TEXT("%SystemRoot%\\system32\\ntmarta.dll"),
                        sizeof(TEXT("%SystemRoot%\\system32\\ntmarta.dll")) );

        RegSetValueEx(  hKey,
                        TEXT("CategoryMessageFile"),
                        0,
                        REG_EXPAND_SZ,
                        (PBYTE) TEXT("%SystemRoot%\\system32\\ntmarta.dll"),
                        sizeof(TEXT("%SystemRoot%\\system32\\ntmarta.dll")) );

        disp = EVENTLOG_ERROR_TYPE          |
                    EVENTLOG_WARNING_TYPE   |
                    EVENTLOG_INFORMATION_TYPE ;

        RegSetValueEx(  hKey,
                        TEXT("TypesSupported"),
                        0,
                        REG_DWORD,
                        (PBYTE) &disp,
                        sizeof(DWORD) );

        disp = CATEGORY_MAX_CATEGORY - 1;
        RegSetValueEx(  hKey,
                        TEXT("CategoryCount"),
                        0,
                        REG_DWORD,
                        (PBYTE) &disp,
                        sizeof(DWORD) );


    }

    RegCloseKey(hKey);

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetAccessListLookupServer
//
//  Synopsis:   Sets the name of the server to lookup the names/sids on for
//              the given path
//
//  Arguments:  [IN pwszPath]       --  Path to get the server name for
//              [IN AccessList]     --  Reference to CAccessList class that
//                                      needs the server name
//
//  Returns:    ERROR_SUCCESS       --  Success
//
//----------------------------------------------------------------------------
DWORD   SetAccessListLookupServer(IN  PWSTR         pwszPath,
                                  IN  CAccessList  &AccessList )
{
    DWORD dwErr = ERROR_SUCCESS;
    PWSTR pwszServer, pwszSep;

    if( pwszPath && IS_UNC_PATH( pwszPath, wcslen( pwszPath )  ) )
    {
        pwszServer = pwszPath + 2;
        pwszSep = wcschr(pwszServer, L'\\');
        if(pwszSep)
        {
            *pwszSep = UNICODE_NULL;
        }

        dwErr = AccessList.SetLookupServer(pwszServer);

        if(pwszSep)
        {
            *pwszSep = L'\\';
        }
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\dsctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       dsctx.cpp
//
//  Contents:   Implementation of CDsObjectContext and NT Marta DS object
//              Functions
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#include <windows.h>
#include <dsctx.h>
//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::CDsObjectContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CDsObjectContext::CDsObjectContext ()
{
    m_cRefs = 1;
    memset( &m_LdapUrlComponents, 0, sizeof( m_LdapUrlComponents ) );
    m_pBinding = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::~CDsObjectContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CDsObjectContext::~CDsObjectContext ()
{
    LdapFreeBindings( m_pBinding );
    LdapFreeUrlComponents( &m_LdapUrlComponents );

    assert( m_cRefs == 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::InitializeByName, public
//
//  Synopsis:   initialize the context given the name of the lanman share
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask)
{
    DWORD  Result = ERROR_SUCCESS;
    LPWSTR pwszName = NULL;
    ULONG  len = wcslen( pObjectName );
    ULONG  i, j;

    if ( _wcsnicmp( pObjectName, LDAP_SCHEME_U, wcslen( LDAP_SCHEME_U ) ) != 0 )
    {
        pwszName = new WCHAR [ len + wcslen( LDAP_SCHEME_UC ) + 2 ];

        if ( pwszName != NULL )
        {
            wcscpy( pwszName, LDAP_SCHEME_UC );
            wcscat( pwszName, L"/" );
            wcscat( pwszName, pObjectName );
        }
        else
        {
            Result = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        pwszName = new WCHAR [ len + 1 ];

        if ( pwszName != NULL )
        {
            wcscpy( pwszName, pObjectName );
        }
        else
        {
            Result = ERROR_OUTOFMEMORY;
        }
    }

    if ( Result == ERROR_SUCCESS )
    {
        for (i = j = 0; i <= len; i++, j++)
        {
            if (L'\\' == pwszName[i])
            {
                if (L'/' != pwszName[i+1])
                {
                    pwszName[j++] = pwszName[i++];
                }
                else
                {
                    i++;
                }
            }
            pwszName[j] = pwszName[i];
        }
    }

    if ( Result == ERROR_SUCCESS )
    {
        if ( LdapCrackUrl( pwszName, &m_LdapUrlComponents ) == FALSE )
        {
            Result = GetLastError();
        }
    }

    if ( Result == ERROR_SUCCESS )
    {
        if ( LdapGetBindings(
                 m_LdapUrlComponents.pwszHost,
                 m_LdapUrlComponents.Port,
                 0,
                 0,
                 &m_pBinding
                 ) == FALSE )
        {
            Result = GetLastError();
        }
    }

    if ( pwszName != pObjectName )
    {
        delete pwszName;
    }

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::AddRef, public
//
//  Synopsis:   add a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::AddRef ()
{
    m_cRefs += 1;
    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::Release, public
//
//  Synopsis:   release a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::Release ()
{
    m_cRefs -= 1;

    if ( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::GetDsObjectProperties, public
//
//  Synopsis:   get properties about the context
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::GetDsObjectProperties (
                    PMARTA_OBJECT_PROPERTIES pObjectProperties
                    )
{
    if ( pObjectProperties->cbSize < sizeof( MARTA_OBJECT_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pObjectProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::GetDsObjectRights, public
//
//  Synopsis:   get the DsObject security descriptor
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::GetDsObjectRights (
                    SECURITY_INFORMATION SecurityInfo,
                    PSECURITY_DESCRIPTOR* ppSecurityDescriptor
                    )
{
    DWORD Result;

    Result = MartaReadDSObjSecDesc(
                 m_pBinding,
                 m_LdapUrlComponents.pwszDN,
                 SecurityInfo,
                 ppSecurityDescriptor
                 );

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::SetDsObjectRights, public
//
//  Synopsis:   set the window security descriptor
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::SetDsObjectRights (
                   SECURITY_INFORMATION SecurityInfo,
                   PSECURITY_DESCRIPTOR pSecurityDescriptor
                   )
{
    DWORD                 Result;
    PISECURITY_DESCRIPTOR pisd = NULL;
    DWORD                 cb = 0;
    PSECURITY_DESCRIPTOR  psd = NULL;

    pisd = (PISECURITY_DESCRIPTOR)pSecurityDescriptor;

    if ( pisd->Control & SE_SELF_RELATIVE )
    {
        cb = GetSecurityDescriptorLength( pSecurityDescriptor );
        psd = pSecurityDescriptor;
    }
    else
    {
        if ( MakeSelfRelativeSD(
                 pSecurityDescriptor,
                 NULL,
                 &cb
                 ) == FALSE )
        {
            if ( cb > 0 )
            {
                psd = new BYTE [ cb ];
                if ( psd != NULL )
                {
                    if ( MakeSelfRelativeSD(
                             pSecurityDescriptor,
                             psd,
                             &cb
                             ) == FALSE )
                    {
                        delete psd;
                        return( GetLastError() );
                    }
                }
                else
                {
                    return( ERROR_OUTOFMEMORY );
                }
            }
            else
            {
                return( GetLastError() );
            }
        }
        else
        {
            assert( FALSE && "Should not get here!" );
            return( ERROR_INVALID_PARAMETER );
        }
    }

    assert( psd != NULL );

    Result = MartaStampSD(
                  m_LdapUrlComponents.pwszDN,
                  cb,
                  SecurityInfo,
                  psd,
                  m_pBinding
                  );

    if ( psd != pSecurityDescriptor )
    {
        delete psd;
    }

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectContext::GetDsObjectGuid, public
//
//  Synopsis:   get the object GUID
//
//----------------------------------------------------------------------------
DWORD
CDsObjectContext::GetDsObjectGuid (GUID* pGuid)
{
    return( ERROR_INVALID_PARAMETER );
}

//
// Functions from Ds.h which dispatch unto the CDsObjectContext class
//

DWORD
MartaAddRefDsObjectContext(
   IN MARTA_CONTEXT Context
   )
{
    return( ( (CDsObjectContext *)Context )->AddRef() );
}

DWORD
MartaCloseDsObjectContext(
     IN MARTA_CONTEXT Context
     )
{
    return( ( (CDsObjectContext *)Context )->Release() );
}

DWORD
MartaGetDsObjectProperties(
   IN MARTA_CONTEXT Context,
   IN OUT PMARTA_OBJECT_PROPERTIES pProperties
   )
{
    return( ( (CDsObjectContext *)Context )->GetDsObjectProperties( pProperties ) );
}

DWORD
MartaGetDsObjectTypeProperties(
   IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
   )
{
    if ( pProperties->cbSize < sizeof( MARTA_OBJECT_TYPE_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pProperties->dwFlags == 0 );

    pProperties->dwFlags = MARTA_OBJECT_TYPE_INHERITANCE_MODEL_PRESENT_FLAG;

    return( ERROR_SUCCESS );
}

DWORD
MartaGetDsObjectRights(
   IN  MARTA_CONTEXT Context,
   IN  SECURITY_INFORMATION   SecurityInfo,
   OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
   )
{
    return( ( (CDsObjectContext *)Context )->GetDsObjectRights(
                                               SecurityInfo,
                                               ppSecurityDescriptor
                                               ) );
}

DWORD
MartaOpenDsObjectNamedObject(
    IN  LPCWSTR pObjectName,
    IN  ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CDsObjectContext* pDsObjectContext;

    pDsObjectContext = new CDsObjectContext;
    if ( pDsObjectContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pDsObjectContext->InitializeByName( pObjectName, AccessMask );
    if ( Result != ERROR_SUCCESS )
    {
        pDsObjectContext->Release();
        return( Result );
    }

    *pContext = pDsObjectContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaSetDsObjectRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return( ( (CDsObjectContext *)Context )->SetDsObjectRights(
                                               SecurityInfo,
                                               pSecurityDescriptor
                                               ) );
}

DWORD
MartaConvertDsObjectNameToGuid(
    IN LPCWSTR pObjectName,
    OUT GUID* pGuid
    )
{
    DWORD               Result = ERROR_SUCCESS;
    LPWSTR              pwszName = NULL;
    LDAP_URL_COMPONENTS LdapUrlComponents;
    DS_NAME_RESULTW*    pnameresult;
    HANDLE              hDs = NULL;
    WCHAR               GuidString[ MAX_PATH ];

    memset( &LdapUrlComponents, 0, sizeof( LdapUrlComponents ) );

    if ( _wcsnicmp( pObjectName, LDAP_SCHEME_U, wcslen( LDAP_SCHEME_U ) ) != 0 )
    {
        pwszName = new WCHAR [ wcslen( pObjectName ) +
                               wcslen( LDAP_SCHEME_U ) + 2 ];

        if ( pwszName != NULL )
        {
            wcscpy( pwszName, LDAP_SCHEME_U );
            wcscat( pwszName, L"/" );
            wcscat( pwszName, pObjectName );
        }
        else
        {
            Result = ERROR_OUTOFMEMORY;
        }
    }
    else
    {
        pwszName = (LPWSTR)pObjectName;
    }

    if ( Result == ERROR_SUCCESS )
    {
        if ( LdapCrackUrl( pwszName, &LdapUrlComponents ) == FALSE )
        {
            Result = GetLastError();
        }
    }

    if ( Result == ERROR_SUCCESS )
    {
        Result = DsBindW( LdapUrlComponents.pwszHost, NULL, &hDs );
    }

    if ( Result == ERROR_SUCCESS )
    {
        Result = DsCrackNamesW(
                   hDs,
                   DS_NAME_NO_FLAGS,
                   DS_FQDN_1779_NAME,
                   DS_UNIQUE_ID_NAME,
                   1,
                   &LdapUrlComponents.pwszDN,
                   &pnameresult
                   );
    }

    if ( Result == ERROR_SUCCESS )
    {
        if ( ( pnameresult->cItems > 0 ) &&
             ( pnameresult->rItems[0].status == ERROR_SUCCESS ) )
        {
            Result = IIDFromString( pnameresult->rItems[0].pName, pGuid );
        }
        else
        {
            Result = ERROR_INVALID_PARAMETER;
        }

        DsFreeNameResultW( pnameresult );
    }

    if ( hDs != NULL )
    {
        DsUnBindW( &hDs );
    }

    LdapFreeUrlComponents( &LdapUrlComponents );

    if ( pwszName != pObjectName )
    {
        delete pwszName;
    }

    return( Result );
}

DWORD
MartaConvertGuidToDsName(
    IN  GUID     Guid,
    OUT LPWSTR * ppObjectName
    )
{
    DWORD            Result;
    HANDLE           hDs = NULL;
    WCHAR            GuidString[ MAX_PATH ];
    DS_NAME_RESULTW* pnameresult = NULL;
    LPWSTR           pObjectName = NULL;

    if ( StringFromGUID2( Guid, GuidString, MAX_PATH ) == 0 )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    Result = DsBindW( NULL, NULL, &hDs );

    if ( Result == ERROR_SUCCESS )
    {
        Result = DsCrackNamesW(
                   hDs,
                   DS_NAME_NO_FLAGS,
                   DS_UNIQUE_ID_NAME,
                   DS_FQDN_1779_NAME,
                   1,
                   (LPCWSTR *)&GuidString,
                   &pnameresult
                   );
    }

    if ( Result == ERROR_SUCCESS )
    {
        if ( ( pnameresult->cItems > 0 ) &&
             ( pnameresult->rItems[0].status == ERROR_SUCCESS ) )
        {
            pObjectName = (LPWSTR)LocalAlloc(
                                       LPTR,
                                       ( wcslen( pnameresult->rItems[0].pName )
                                         + 1 ) * sizeof( WCHAR )
                                       );

            if ( pObjectName != NULL )
            {
                wcscpy( pObjectName, pnameresult->rItems[0].pName );
                *ppObjectName = pObjectName;
            }
            else
            {
                Result = ERROR_OUTOFMEMORY;
            }
        }
        else
        {
            Result = ERROR_INVALID_PARAMETER;
        }

        DsFreeNameResultW( pnameresult );
    }

    if ( hDs != NULL )
    {
        DsUnBindW( &hDs );
    }

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Function:   MartaReadDSObjSecDesc
//
//  Synopsis:   Reads the security descriptor from the specied object via
//              the open ldap connection
//
//  Arguments:  [IN  pLDAP]         --  The open LDAP connection
//              [IN  SeInfo]        --  Parts of the security descriptor to
//                                      read.
//              [IN  pwszDSObj]     --  The DSObject to get the security
//                                      descriptor for
//              [OUT ppSD]          --  Where the security descriptor is
//                                      returned
//
//  Returns:    ERROR_SUCCESS       --  The object is reachable
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//  Notes:      The returned security descriptor must be freed with LocalFree
//
//----------------------------------------------------------------------------
DWORD
MartaReadDSObjSecDesc(IN  PLDAP                  pLDAP,
                      IN  LPWSTR                 pwszObject,
                      IN  SECURITY_INFORMATION   SeInfo,
                      OUT PSECURITY_DESCRIPTOR  *ppSD)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PLDAPMessage    pMessage = NULL;
    LPWSTR           rgAttribs[2];
    BYTE            berValue[8];

    //
    // JohnsonA The BER encoding is current hardcoded.  Change this to use
    // AndyHe's BER_printf package once it's done.
    //

    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE)((ULONG)SeInfo & 0xF);

    LDAPControlW     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR)berValue
                        },
                        TRUE
                    };

    PLDAPControlW    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    rgAttribs[0] = SD_PROP_NAME;
    rgAttribs[1] = NULL;



    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ldap_search_ext_sW(pLDAP,
                                   pwszObject,
                                   LDAP_SCOPE_BASE,
                                   L"(objectClass=*)",
                                   rgAttribs,
                                   0,
                                   (PLDAPControlW *)&ServerControls,
                                   NULL,
                                   NULL,
                                   10000,
                                   &pMessage);

        dwErr = LdapMapErrorToWin32( dwErr );
    }

    if(dwErr == ERROR_SUCCESS)
    {
        LDAPMessage *pEntry = NULL;

        pEntry = ldap_first_entry(pLDAP,pMessage);

        if(pEntry == NULL)
        {
            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
            if (ERROR_SUCCESS == dwErr)
                dwErr = ERROR_ACCESS_DENIED;
        }
        else
        {
            PLDAP_BERVAL *pSize = ldap_get_values_lenW(pLDAP,
                                                       pMessage,
                                                       rgAttribs[0]);
            if(pSize == NULL)
            {
                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
            }
            else
            {
                //
                // Allocate the security descriptor to return
                //
                *ppSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, (*pSize)->bv_len);
                if(*ppSD == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    memcpy(*ppSD, (PBYTE)(*pSize)->bv_val, (*pSize)->bv_len);
                }
                ldap_value_free_len(pSize);
            }
        }
    }

    if ( pMessage != NULL )
    {
        ldap_msgfree(pMessage);
    }

    return(dwErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   MartaStampSD
//
//  Synopsis:   Actually stamps the security descriptor on the object.
//
//  Arguments:  [IN  pwszObject]        --      The object to stamp the SD on
//              [IN  cSDSize]           --      The size of the security descriptor
//              [IN  SeInfo]            --      SecurityInformation about the security
//                                              descriptor
//              [IN  pSD]               --      The SD to stamp
//              [IN  pLDAP]             --      The LDAP connection to use
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
MartaStampSD(IN  LPWSTR               pwszObject,
             IN  ULONG                cSDSize,
             IN  SECURITY_INFORMATION SeInfo,
             IN  PSECURITY_DESCRIPTOR pSD,
             IN  PLDAP                pLDAP)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Now, we'll do the write.  The security descriptor
    // we got passed in better not be in the old Ds  format,
    // where the leading 4 bytes are the SECURITY_INFORMATION, which we'll skip
    // and replace with control information
    //

    assert(*(PULONG)pSD > 0xF );

    PLDAPModW       rgMods[2];
    PLDAP_BERVAL    pBVals[2];
    LDAPModW        Mod;
    LDAP_BERVAL     BVal;
    BYTE            ControlBuffer[ 5 ];

    LDAPControlW     SeInfoControl =
                    {
                        LDAP_SERVER_SD_FLAGS_OID_W,
                        {
                            5, (PCHAR) &ControlBuffer
                        },
                        TRUE
                    };

    //
    // !!! Hardcoded for now.  Use Andyhe's BER_printf once it's done.
    //

    ControlBuffer[0] = 0x30;
    ControlBuffer[1] = 0x3;
    ControlBuffer[2] = 0x02;    // Denotes an integer;
    ControlBuffer[3] = 0x01;    // Size
    ControlBuffer[4] = (BYTE)((ULONG)SeInfo & 0xF);

    PLDAPControlW    ServerControls[2] =
                    {
                        &SeInfoControl,
                        NULL
                    };

    assert(IsValidSecurityDescriptor( pSD ) );

    rgMods[0] = &Mod;
    rgMods[1] = NULL;

    pBVals[0] = &BVal;
    pBVals[1] = NULL;

    BVal.bv_len = cSDSize;
    BVal.bv_val = (PCHAR)pSD;

    Mod.mod_op      = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;
    Mod.mod_type    = SD_PROP_NAME;
    Mod.mod_values  = (LPWSTR *)pBVals;

    //
    // Now, we'll do the write...
    //

    dwErr = ldap_modify_ext_sW(pLDAP,
                               pwszObject,
                               rgMods,
                               (PLDAPControlW *)&ServerControls,
                               NULL);

    dwErr = LdapMapErrorToWin32(dwErr);

    return(dwErr);
}

DWORD
MartaGetDsParentName(
    IN LPWSTR ObjectName,
    OUT LPWSTR *pParentName
    )

/*++

Routine Description:

    Given the name of a DS object return the name of its parent. The routine
    allocates memory required to hold the parent name.

Arguments:

    ObjectName - Name of the DS object.

    pParentName - To return the pointer to the allocated parent name.
        In case of the root of the tree, we return NULL parent with ERROR_SUCCESS.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    LPCWSTR pKey  = NULL;
    LPCWSTR pVal  = NULL;
    DWORD  ccKey = 0;
    DWORD  ccDN  = 0;
    DWORD  ccVal = 0;
    DWORD  Size  = 0;
    DWORD  dwErr = ERROR_SUCCESS;
    LPCWSTR pDN   = (LPWSTR) ObjectName;

    ccDN = wcslen(pDN);
    *pParentName = NULL;

    //
    // The input is empty. There is no parent. Just return.
    //

    if (0 == ccDN)
    {
        return ERROR_SUCCESS;
    }

    //
    // Do the first pass to get to the next level. At the end of this call,
    // pDN will point to the next ','. One more call to DsGetRdnW will
    // return the right result in pKey.
    // Input:
    //   pDN = "CN=Kedar, DC=NTDEV, DC=Microsoft, DC=com"
    // Output:
    //   pDN = ", DC=NTDEV, DC=Microsoft, DC=com"
    //

    dwErr = DsGetRdnW(
                &pDN,
                &ccDN,
                &pKey,
                &ccKey,
                &pVal,
                &ccVal
                );

     if (ERROR_SUCCESS != dwErr)
     {
         return dwErr;
     }

     //
     // This is TRUE when the Object does not have any parent.
     //

     if (0 == ccDN)
     {
         return ERROR_SUCCESS;
     }

     //
     // Input:
     //   pDN = ", DC=NTDEV, DC=Microsoft, DC=com"
     // Output:
     //   pKey = "DC=NTDEV, DC=Microsoft, DC=com"
     //

     dwErr = DsGetRdnW(
                 &pDN,
                 &ccDN,
                 &pKey,
                 &ccKey,
                 &pVal,
                 &ccVal
                 );

     if (ERROR_SUCCESS != dwErr)
     {
         return dwErr;
     }

     //
     // We have to distinguish between LDAP://ServerName/ObjectName and
     // ObjectName.
     //

     if (!_wcsnicmp(ObjectName, LDAP_SCHEME_U, wcslen(LDAP_SCHEME_U)) != 0 )
     {
         ULONG HostSize;

         //
         // Compute the size of string required to hold "LDAP//ServerName/" in
         // HostSize.
         //

         pDN = ObjectName + sizeof("ldap://");
         pDN = wcschr(pDN, L'/');

         if (NULL == pDN) 
         {
             return ERROR_INVALID_PARAMETER;
         }

         HostSize = (ULONG) (pDN - ObjectName + 1);

         Size = (1 + wcslen(pKey) + HostSize) * sizeof(WCHAR);

         *pParentName = (LPWSTR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, Size);

         if (NULL == *pParentName)
         {
             return ERROR_NOT_ENOUGH_MEMORY;
         }

         //
         // Copy the name of the parent into allocated memeory.
         //

         wcsncpy(*pParentName, ObjectName, HostSize);
         wcscpy((*pParentName) + HostSize, pKey);
     }
     else
     {
         Size = (1 + wcslen(pKey)) * sizeof(WCHAR);

         *pParentName = (LPWSTR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, Size);

         if (NULL == *pParentName)
         {
             return ERROR_NOT_ENOUGH_MEMORY;
         }

         //
         // Copy the name of the parent into allocated memeory.
         //

         wcscpy(*pParentName, pKey);
     }


     return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\dfsext.c ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       dfsext.c
//
//  Contents:   Code to see if a path refers to a Dfs path.
//
//  Classes:    None
//
//  Functions:  IsThisADfsPath
//
//  History:    March 11, 1996  Milans created
//
//-----------------------------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <dfsfsctl.h>
#include <windows.h>

NTSTATUS
DfsFsctl(
    IN  HANDLE DfsHandle,
    IN  ULONG FsControlCode,
    IN  PVOID InputBuffer OPTIONAL,
    IN  ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN  ULONG OutputBufferLength);

NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle);

//+----------------------------------------------------------------------------
//
//  Function:   IsThisADfsPath, public
//
//  Synopsis:   Given a fully qualified UNC or Drive based path, this routine
//              will identify if it is a Dfs path or not.
//
//  Arguments:  [pwszPath] -- The fully qualified path to test.
//
//              [cwPath] -- Length, in WCHARs, of pwszPath. If this is 0,
//                      this routine will compute the length. If it is
//                      non-zero, it will assume that the length of pwszPath
//                      is cwPath WCHARs.
//
//  Returns:    TRUE if pwszPath is a Dfs path, FALSE otherwise.
//
//-----------------------------------------------------------------------------

BOOL
IsThisADfsPath(
    IN LPCWSTR pwszPath,
    IN DWORD cwPath OPTIONAL)
{
    NTSTATUS Status;
    HANDLE hDfs;
    BOOL fIsDfsPath = FALSE;
    PDFS_IS_VALID_PREFIX_ARG pPrefixArg;
    ULONG Size;

    //
    // We only accept UNC or drive letter paths
    //

    if (pwszPath == NULL)
        return( FALSE );

    if (cwPath == 0)
        cwPath = wcslen( pwszPath );

    if (cwPath < 2)
        return( FALSE );

    Status = DfsOpen( &hDfs );

    if (!NT_SUCCESS(Status))
        return( FALSE );

    //
    // From this point on, we must remember to close hDfs before returning.
    //

    if (pwszPath[0] == L'\\' && pwszPath[1] == L'\\') {

        Size = sizeof(DFS_IS_VALID_PREFIX_ARG) +
                    cwPath * sizeof(WCHAR);

        pPrefixArg = (PDFS_IS_VALID_PREFIX_ARG) LocalAlloc(0, Size);

        if ( pPrefixArg ) {

            //
            // the InputBuffer must be in the structure of DFS_IS_VALID_PREFIX_ARG
            //

            pPrefixArg->CSCAgentCreate = FALSE;
            pPrefixArg->RemoteNameLen = (SHORT)( (cwPath-1) * sizeof(WCHAR));
            wcscpy(&pPrefixArg->RemoteName[0], pwszPath+1);

            Status = DfsFsctl(
                        hDfs,
                        FSCTL_DFS_IS_VALID_PREFIX,
                        (PVOID) pPrefixArg, // &pwszPath[1],
                        Size, // (cwPath - 1) * sizeof(WCHAR),
                        NULL,
                        0);

            LocalFree(pPrefixArg);

        } else {
            Status = STATUS_NO_MEMORY;
        }

        if (NT_SUCCESS(Status))
            fIsDfsPath = TRUE;

    } else if (pwszPath[1] == L':') {

        //
        // This is a drive based name. We'll fsctl to the driver to return
        // the prefix for this drive, if it is indeed a Dfs drive.
        //

        Status = DfsFsctl(
                    hDfs,
                    FSCTL_DFS_IS_VALID_LOGICAL_ROOT,
                    (PVOID) &pwszPath[0],
                    sizeof(WCHAR),
                    NULL,
                    0);

        if (NT_SUCCESS(Status))
            fIsDfsPath = TRUE;

    }

    NtClose( hDfs );

    return( fIsDfsPath );

}

//+-------------------------------------------------------------------------
//
//  Function:   DfsOpen, private
//
//  Synopsis:   Opens a handle to the Dfs driver for fsctl purposes.
//
//  Arguments:  [DfsHandle] -- On successful return, contains handle to the
//                      driver.
//
//  Returns:    NTSTATUS of attempt to open the Dfs driver.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    UNICODE_STRING name = {
        sizeof(DFS_DRIVER_NAME)-sizeof(UNICODE_NULL),
        sizeof(DFS_DRIVER_NAME)-sizeof(UNICODE_NULL),
        DFS_DRIVER_NAME};

    InitializeObjectAttributes(
        &objectAttributes,
        &name,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    status = NtCreateFile(
        DfsHandle,
        SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0);

    if (NT_SUCCESS(status))
        status = ioStatus.Status;

    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctl, public
//
//  Synopsis:   Fsctl's to the Dfs driver.
//
//  Arguments:  [DfsHandle] -- Handle to the Dfs driver, usually obtained by
//                      calling DfsOpen.
//              [FsControlCode] -- The FSCTL code (see private\inc\dfsfsctl.h)
//              [InputBuffer] -- InputBuffer to the fsctl.
//              [InputBufferLength] -- Length, in BYTES, of InputBuffer
//              [OutputBuffer] -- OutputBuffer to the fsctl.
//              [OutputBufferLength] -- Length, in BYTES, of OutputBuffer
//
//  Returns:    NTSTATUS of Fsctl attempt.
//
//--------------------------------------------------------------------------

NTSTATUS
DfsFsctl(
    IN  HANDLE DfsHandle,
    IN  ULONG FsControlCode,
    IN  PVOID InputBuffer OPTIONAL,
    IN  ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN  ULONG OutputBufferLength
)
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;

    status = NtFsControlFile(
        DfsHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        FsControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength
    );

    if(NT_SUCCESS(status))
        status = ioStatus.Status;

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\filctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 2000.
//
//  File:       file.cpp
//
//  Contents:   NtMarta file functions
//
//  History:    4/99    philh       Created
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <kernel.h>
#include <assert.h>
#include <ntstatus.h>

extern "C" {
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmdfs.h>
}

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stddef.h>

#include <file.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

//+-------------------------------------------------------------------------
//  File Context data structures
//--------------------------------------------------------------------------
typedef struct _FILE_FIND_DATA FILE_FIND_DATA, *PFILE_FIND_DATA;

typedef struct _FILE_CONTEXT {
    DWORD                   dwRefCnt;
    DWORD                   dwFlags;

    // Only closed when FILE_CONTEXT_CLOSE_HANDLE_FLAG is set
    HANDLE                  hFile;

    // Following is allocated and updated for FindFirst, FindNext
    PFILE_FIND_DATA         pFileFindData;
} FILE_CONTEXT, *PFILE_CONTEXT;

#define FILE_CONTEXT_CLOSE_HANDLE_FLAG  0x1

typedef struct _QUERY_NAMES_INFO_BUFFER {
    FILE_NAMES_INFORMATION  NamesInfo;
    WCHAR                   Names[MAX_PATH];
} QUERY_NAMES_INFO_BUFFER;

struct _FILE_FIND_DATA {
    HANDLE                  hDir;
    BOOL                    fRestartScan;       // TRUE on first Find
    QUERY_NAMES_INFO_BUFFER NamesInfoBuffer;
};

//+-------------------------------------------------------------------------
//  File allocation functions
//--------------------------------------------------------------------------
#define I_MartaFileZeroAlloc(size)     \
            LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, size)
#define I_MartaFileNonzeroAlloc(size)  \
            LocalAlloc(LMEM_FIXED, size)

STATIC
inline
VOID
I_MartaFileFree(
    IN LPVOID pv
    )

/*++

Routine Description:

   Free the given memory.

Arguments:

    pv - Ponter to memory to be freed.

Return Value:

    None.

--*/

{
    if (pv)
        LocalFree(pv);
}

STATIC
DWORD
I_MartaFileGetNtParentString(
    IN OUT LPWSTR pwszNtParent
    )

/*++

Routine Description:

    Given the name for a file/dir, get the name of its parent. Does not allocate
    memory. Scans till the first '\' from the right and deletes the name after
    that.

Arguments:

    pwszNtParent - Object name which will be converted to its parent name.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    DWORD cch;
    LPWSTR pwsz;

    if (NULL == pwszNtParent)
        return ERROR_INVALID_NAME;

    cch = wcslen(pwszNtParent);
    pwsz = pwszNtParent + cch;
    if (0 == cch)
        goto InvalidNameReturn;
    pwsz--;

    //
    // Remove any trailing '\'s
    //

    while (L'\\' == *pwsz) {
        if (pwsz == pwszNtParent)
            goto InvalidNameReturn;
        pwsz--;
    }

    //
    // Peal off the last path name component
    //

    while (L'\\' != *pwsz) {
        if (pwsz == pwszNtParent)
            goto InvalidNameReturn;
        pwsz--;
    }

    //
    // Remove all trailing '\'s from the parent.
    //

    while (L'\\' == *pwsz) {
        if (pwsz == pwszNtParent)
            goto InvalidNameReturn;
        pwsz--;
    }
    pwsz++;
    assert(L'\\' == *pwsz);

    //
    // Required to distinguish between the device and root directory.
    //

    pwsz++;

    dwErr = ERROR_SUCCESS;
CommonReturn:
    *pwsz = L'\0';
    return dwErr;
InvalidNameReturn:
    dwErr = ERROR_INVALID_NAME;
    goto CommonReturn;
}


STATIC
DWORD
I_MartaFileInitContext(
    OUT PFILE_CONTEXT *ppFileContext
    )

/*++

Routine Description:

    Allocate and initialize memory for the context.

Arguments:

    ppFileContext - To return the pointer to the allcoated memory.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    PFILE_CONTEXT pFileContext;

    if (pFileContext = (PFILE_CONTEXT) I_MartaFileZeroAlloc(
            sizeof(FILE_CONTEXT))) {
        pFileContext->dwRefCnt = 1;
        dwErr = ERROR_SUCCESS;
    } else {
        pFileContext = NULL;
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppFileContext = pFileContext;
    return dwErr;
}

STATIC
DWORD
I_MartaFileNtOpenFile(
    IN PUNICODE_STRING pFileName,
    IN HANDLE hContainingDirectory, // NULL if pFileName is absolute
    IN ACCESS_MASK AccessMask,
    IN OUT PFILE_CONTEXT pFileContext
    )

/*++

Routine Description:

    Open the given file/dir with requested permissions and copy the handle into
    the supplied context.

Arguments:

    pFileName - Name of the file/dir to be opened.
    
    hContainingDirectory - Handle to the parent dir.
    
    AccessMask - Desired access mask for the open.
    
    pFileContext - Handle will be copied into the context structure.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    // cut and paste code from windows\base\advapi\security.c SetFileSecurityW

    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;

    InitializeObjectAttributes(
        &Obja,
        pFileName,
        OBJ_CASE_INSENSITIVE,
        hContainingDirectory,
        NULL
        );

    //
    // Notice that FILE_OPEN_REPARSE_POINT inhibits the reparse behavior. Thus, the
    // security will always be set, as before, in the file denoted by the name.
    //

    Status = NtOpenFile(
                 &pFileContext->hFile,
                 AccessMask,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_OPEN_REPARSE_POINT
                 );

    //
    // Back-level file systems may not support the FILE_OPEN_REPARSE_POINT
    // flag. We treat this case explicitly.
    //

    if ( Status == STATUS_INVALID_PARAMETER ) {
        //
        // Open without inhibiting the reparse behavior.
        //

        Status = NtOpenFile(
                     &pFileContext->hFile,
                     AccessMask,
                     &Obja,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     0
                     );
    }

    if (NT_SUCCESS(Status)) {
        pFileContext->dwFlags |= FILE_CONTEXT_CLOSE_HANDLE_FLAG;
        return ERROR_SUCCESS;
    } else
        return RtlNtStatusToDosError(Status);
}

DWORD
MartaOpenFileNamedObject(
    IN  LPCWSTR              pwszObject,
    IN  ACCESS_MASK          AccessMask,
    OUT PMARTA_CONTEXT       pContext
    )

/*++

Routine Description:

    Open the given file/dir with desired access mask and return a context
    handle.

Arguments:

    pwszObject - Name of the file/dir which will be opened.
    
    AccessMask - Desired access mask with which the file/dir will be opened.
    
    pContext - To return a context handle.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    PFILE_CONTEXT pFileContext = NULL;
    UNICODE_STRING FileName;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer = NULL;
    BOOL ReleaseRelativeName = FALSE;

    if (NULL == pwszObject)
        goto InvalidNameReturn;

    if (ERROR_SUCCESS != (dwErr = I_MartaFileInitContext(&pFileContext)))
        goto ErrorReturn;

    //
    // Convert the name into NT pathname.
    //

    if (!RtlDosPathNameToRelativeNtPathName_U(
            pwszObject,
            &FileName,
            NULL,
            &RelativeName
            ))
        goto InvalidNameReturn;
    ReleaseRelativeName = TRUE;
    FreeBuffer = FileName.Buffer;

    if (RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
    } else {
        RelativeName.ContainingDirectory = NULL;
    }

    //
    // Call the helper routine that does the actual open.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaFileNtOpenFile(
            &FileName,
            RelativeName.ContainingDirectory,
            AccessMask,
            pFileContext
            )))
        goto ErrorReturn;
CommonReturn:
    if (ReleaseRelativeName) {
        RtlReleaseRelativeName(&RelativeName);
    }
    if (FreeBuffer)
        RtlFreeHeap(RtlProcessHeap(), 0, FreeBuffer);
    *pContext = (MARTA_CONTEXT) pFileContext;
    return dwErr;

ErrorReturn:
    if (pFileContext) {
        MartaCloseFileContext((MARTA_CONTEXT) pFileContext);
        pFileContext = NULL;
    }
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

InvalidNameReturn:
    dwErr = ERROR_INVALID_NAME;
    goto ErrorReturn;
}

void
I_MartaFileFreeFindData(
    IN PFILE_FIND_DATA pFileFindData
    )

/*++

Routine Description:

    Free up the memory associated with the internal structure.

Arguments:

    pFileFindData - Internal file structure to be freed.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    if (NULL == pFileFindData)
        return;
    if (pFileFindData->hDir)
        NtClose(pFileFindData->hDir);

    I_MartaFileFree(pFileFindData);
}

DWORD
MartaCloseFileContext(
    IN MARTA_CONTEXT Context
    )

/*++

Routine Description:

    Close the context.

Arguments:

    Context - Context to be closed.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;

    if (NULL == pFileContext || 0 == pFileContext->dwRefCnt)
        return ERROR_INVALID_PARAMETER;

    //
    // If the refcnt has gone to zero then free up the memory associated with
    // the context handle. Also, close the file handle.
    //

    if (0 == --pFileContext->dwRefCnt) {
        if (pFileContext->pFileFindData)
            I_MartaFileFreeFindData(pFileContext->pFileFindData);

        if (pFileContext->dwFlags & FILE_CONTEXT_CLOSE_HANDLE_FLAG)
        {
            NtClose(pFileContext->hFile);
            pFileContext->hFile = NULL;
            pFileContext->dwFlags &= ~FILE_CONTEXT_CLOSE_HANDLE_FLAG;
        }

        I_MartaFileFree(pFileContext);
    }

    return ERROR_SUCCESS;
}

DWORD
MartaAddRefFileContext(
    IN MARTA_CONTEXT Context
    )

/*++

Routine Description:

    Bump up the ref count for this context.

Arguments:

    Context - Context whose ref count should be bumped up.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;

    if (NULL == pFileContext || 0 == pFileContext->dwRefCnt)
        return ERROR_INVALID_PARAMETER;

    pFileContext->dwRefCnt++;
    return ERROR_SUCCESS;
}

DWORD
MartaOpenFileHandleObject(
    IN  HANDLE               Handle,
    IN  ACCESS_MASK          AccessMask,
    OUT PMARTA_CONTEXT       pContext
    )

/*++

Routine Description:

    Given a file handle, open the context with the desired access mask and 
    return a context handle.

Arguments:

    Handle - Existing file handle.
    
    AccessMask - Desired access mask for file open.
    
    pContext - To return a handle to the context.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    PFILE_CONTEXT pFileContext = NULL;

    //
    // Allocate and initialize context.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaFileInitContext(&pFileContext)))
        goto ErrorReturn;

    //
    // Duplicate the handle for desired access mask.
    //

    if (0 == AccessMask)
        pFileContext->hFile = Handle;
    else {
        if (!DuplicateHandle(
                GetCurrentProcess(),
                Handle,
                GetCurrentProcess(),
                &pFileContext->hFile,
                AccessMask,
                FALSE,                  // bInheritHandle
                0                       // fdwOptions
                )) {
            dwErr = GetLastError();
            goto ErrorReturn;
        }
        pFileContext->dwFlags |= FILE_CONTEXT_CLOSE_HANDLE_FLAG;
    }

    dwErr = ERROR_SUCCESS;
CommonReturn:
    *pContext = (MARTA_CONTEXT) pFileContext;
    return dwErr;

ErrorReturn:
    if (pFileContext) {
        MartaCloseFileContext((MARTA_CONTEXT) pFileContext);
        pFileContext = NULL;
    }
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;
}


DWORD
MartaGetFileParentContext(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pParentContext
    )

/*++

Routine Description:

    Given the context for a file/dir, get the context for its parent.

Arguments:

    Context - Context for the file/dir.
    
    AccessMask - Desired access mask with which the parent will be opened.
    
    pParentContext - To return the context for the parent.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    LPWSTR pwszNtParentObject = NULL;
    PFILE_CONTEXT pFileContext = NULL;
    UNICODE_STRING FileName;

    //
    // Convert the context into the name of the file/dir.
    //

    if (ERROR_SUCCESS != (dwErr = MartaConvertFileContextToNtName(
            Context, &pwszNtParentObject)))
        goto ErrorReturn;

    //
    // Get the name of the parent.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaFileGetNtParentString(
            pwszNtParentObject)))
        goto NoParentReturn;

    //
    // Initialize the context structure.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaFileInitContext(&pFileContext)))
        goto ErrorReturn;

    RtlInitUnicodeString(&FileName, pwszNtParentObject);

    //
    // Open the parent dir with the requested permissions.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaFileNtOpenFile(
            &FileName,
            NULL,               // hContainingDirectory,
            AccessMask,
            pFileContext
            )))
        goto NoParentReturn;
CommonReturn:
    I_MartaFileFree(pwszNtParentObject);
    *pParentContext = (MARTA_CONTEXT) pFileContext;
    return dwErr;

NoParentReturn:
    dwErr = ERROR_SUCCESS;
ErrorReturn:
    if (pFileContext) {
        MartaCloseFileContext((MARTA_CONTEXT) pFileContext);
        pFileContext = NULL;
    }
    goto CommonReturn;
}



DWORD
MartaFindFirstFile(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pChildContext
    )

/*++

Routine Description:

    FInd the first file/dir in the given directory.

Arguments:

    Context - Context for the directory.
    
    AccessMask - Desired access mask for opening the child file/dir.

    pChildContext - To return the context for the first child in the given dir.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

Note:
    Does not free up the current context. 

--*/

{
    DWORD dwErr;
    NTSTATUS Status;
    PFILE_CONTEXT pFileParentContext = (PFILE_CONTEXT) Context;
    PFILE_CONTEXT pFileFirstContext = NULL;
    PFILE_FIND_DATA pFileFindData;    // freed as part of pFileFirstContext
    UNICODE_STRING FileName;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;

    // 
    // Allocate a context for the first child.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaFileInitContext(&pFileFirstContext)))
        goto ErrorReturn;
    if (NULL == (pFileFindData = (PFILE_FIND_DATA) I_MartaFileZeroAlloc(
            sizeof(FILE_FIND_DATA))))
        goto NotEnoughMemoryReturn;
  
    pFileFindData->fRestartScan = TRUE;
 
    pFileFirstContext->pFileFindData = pFileFindData;

    //
    // Duplicate the parent's file handle for synchronized directory access
    //

    RtlInitUnicodeString(&FileName, NULL);
    InitializeObjectAttributes(
        &Obja,
        &FileName,
        OBJ_CASE_INSENSITIVE,
        pFileParentContext->hFile,
        NULL
        );

    //
    // Obtained following parameter values from windows\base\filefind.c
    //

    Status = NtOpenFile(
        &pFileFindData->hDir,
        FILE_LIST_DIRECTORY | SYNCHRONIZE,
        &Obja,
        &IoStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT |
            FILE_OPEN_REPARSE_POINT |  FILE_OPEN_FOR_BACKUP_INTENT
        );

    //
    // Back-level file systems may not support the FILE_OPEN_REPARSE_POINT
    // flag. We treat this case explicitly.
    //

    if ( Status == STATUS_INVALID_PARAMETER ) {

        //
        // Open without inhibiting the reparse behavior.
        //

        Status = NtOpenFile(
            &pFileFindData->hDir,
            FILE_LIST_DIRECTORY | SYNCHRONIZE,
            &Obja,
            &IoStatusBlock,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT |
                FILE_OPEN_FOR_BACKUP_INTENT
            );
    }

    if (!NT_SUCCESS(Status))
        goto StatusErrorReturn;

    //
    // Following closes / frees pFileFirstContext
    //

    dwErr = MartaFindNextFile(
        (MARTA_CONTEXT) pFileFirstContext,
        AccessMask,
        pChildContext
        );
CommonReturn:
    return dwErr;

StatusErrorReturn:
    dwErr = RtlNtStatusToDosError(Status);
ErrorReturn:
    if (pFileFirstContext)
        MartaCloseFileContext((MARTA_CONTEXT) pFileFirstContext);
    *pChildContext = NULL;

    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;
}

STATIC
BOOL
I_MartaIsDfsJunctionPoint(
    IN MARTA_CONTEXT        Context
    );


DWORD
MartaFindNextFile(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pSiblingContext
    )

/*++

Routine Description:

    Get the next object in the tree. This is the sibling for the current context.

Arguments:

    Context - Context for the current object.

    AccessMask - Desired access mask for the opening the sibling.
    
    pSiblingContext - To return a handle for the sibling.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

Note:

    Closes the current context.
    
--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS Status;

    PFILE_CONTEXT pFilePrevContext = (PFILE_CONTEXT) Context;
    PFILE_CONTEXT pFileSiblingContext = NULL;

    //
    // Following don't need to be freed or closed
    //

    PFILE_FIND_DATA pFileFindData;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_NAMES_INFORMATION pNamesInfo;
    HANDLE hDir;

    if (ERROR_SUCCESS != (dwErr = I_MartaFileInitContext(&pFileSiblingContext)))
        goto ErrorReturn;

    //
    // Move the FindData on to the sibling context
    //

    pFileFindData = pFilePrevContext->pFileFindData;
    if (NULL == pFileFindData)
        goto InvalidParameterReturn;
    pFilePrevContext->pFileFindData = NULL;
    pFileSiblingContext->pFileFindData = pFileFindData;

    hDir = pFileFindData->hDir;
    pNamesInfo = &pFileFindData->NamesInfoBuffer.NamesInfo;
    while (TRUE) {
        UNICODE_STRING FileName;
        DWORD cchFileName;
        LPCWSTR pwszFileName;

        //
        // Get the name of the sibling object.
        //

        Status = NtQueryDirectoryFile(
            hDir,
            NULL,           // HANDLE Event OPTIONAL,
            NULL,           // PIO_APC_ROUTINE ApcRoutine OPTIONAL,
            NULL,           // ApcContext OPTIONAL,
            &IoStatusBlock,
            pNamesInfo,
            sizeof(pFileFindData->NamesInfoBuffer),
            FileNamesInformation,
            TRUE,           // BOOLEAN ReturnSingleEntry,
            NULL,           // PUNICODE_STRING FileName OPTIONAL,
            pFileFindData->fRestartScan != FALSE
            );
        if (ERROR_SUCCESS != Status)
            goto StatusErrorReturn;

        pFileFindData->fRestartScan = FALSE;

        FileName.Length = (USHORT) pNamesInfo->FileNameLength;
        FileName.MaximumLength = (USHORT) FileName.Length;
        FileName.Buffer = pNamesInfo->FileName;
        cchFileName = FileName.Length / sizeof(WCHAR);
        pwszFileName = FileName.Buffer;

        // Skip "." and ".."
        if (0 < cchFileName && L'.' == pwszFileName[0] &&
                (1 == cchFileName ||
                    (2 == cchFileName && L'.' == pwszFileName[1])))
            continue;

        //
        //  For an error still return this context. This allows the caller
        //  to continue on to the next sibling object and know there was an
        //  error with this sibling object
        //

        dwErr = I_MartaFileNtOpenFile(
            &FileName,
            hDir,
            AccessMask,
            pFileSiblingContext
            );

        //
        // Per Praerit, skip DFS junction points.
        //

        if (ERROR_SUCCESS == dwErr &&
                I_MartaIsDfsJunctionPoint(pFileSiblingContext)) {
            assert(pFileSiblingContext->dwFlags &
                FILE_CONTEXT_CLOSE_HANDLE_FLAG);
            if (pFileSiblingContext->dwFlags &
                    FILE_CONTEXT_CLOSE_HANDLE_FLAG) {
                NtClose(pFileSiblingContext->hFile);
                pFileSiblingContext->hFile = NULL;
                pFileSiblingContext->dwFlags &=
                    ~FILE_CONTEXT_CLOSE_HANDLE_FLAG;
            }
            continue;
        } else
            break;
    }

CommonReturn:
    MartaCloseFileContext(Context);
    *pSiblingContext = (MARTA_CONTEXT) pFileSiblingContext;
    return dwErr;

StatusErrorReturn:
    dwErr = RtlNtStatusToDosError(Status);
ErrorReturn:
    if (pFileSiblingContext) {
        MartaCloseFileContext((MARTA_CONTEXT) pFileSiblingContext);
        pFileSiblingContext = NULL;
    }

    //
    // If there are no more chidren, return ERROR_SUCCESS with a NULL sibling
    // context.
    //

    if (ERROR_NO_MORE_FILES == dwErr)
        dwErr = ERROR_SUCCESS;
    goto CommonReturn;

InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
}

#define WINDFS_DEVICE       L"\\Device\\WinDfs"
#define WINDFS_DEVICE_LEN   (sizeof(WINDFS_DEVICE) / sizeof(WCHAR) - 1)
#define WINDFS_PREFIX       WINDFS_DEVICE L"\\Root"
#define WINDFS_PREFIX_LEN   (sizeof(WINDFS_PREFIX) / sizeof(WCHAR) - 1)

#define MAX_QUERY_RETRY_CNT 16

STATIC
DWORD
I_MartaFileHandleToNtDfsName(
    IN HANDLE hFile,
    OUT LPWSTR *ppwszNtObject
    )

/*++

Routine Description:

    Covert the given file handle for a DFS object into name. Allocates memory.

Arguments:

    hFile - Handle for the DFS object.
    
    ppwszNtObject - To return the name of the DFS object.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

Note:

    Couple of problems in the name returned by NtQueryObject for DFS objects:
      - Name contains 4 extra, bogus bytes (This is a BUG that should be fixed)
      - For logical drives, returns \Device\WinDfs\X:0\server\share. This
      needs to be converted to \Device\WinDfs\Root\server\share.
      Where X is the drive letter.
      
   This routine is called when it has already been determined the hFile
   refers to a DFS object name.

--*/

{
    NTSTATUS Status;
    DWORD dwErr;
    LPWSTR pwszNtObject = NULL;

    IO_STATUS_BLOCK IoStatusBlock;
    BYTE Buff[MAX_PATH * 4];
    PFILE_NAME_INFORMATION pAllocNI = NULL;
    PFILE_NAME_INFORMATION pNI;                     // not allocated
    LPWSTR pwszFileName;
    DWORD cchFileName;
    DWORD cchNtObject;
    ULONG cbNI;
    DWORD cRetry;

    pNI = (PFILE_NAME_INFORMATION) Buff;
    cbNI = sizeof(Buff);
    cRetry = 0;
    while (TRUE) {

        //
        // This returns the filename without the Nt Dfs object name prefix.
        //
        // Assumption: the returned filename always has a leading '\'.
        //

        Status = NtQueryInformationFile(
            hFile,
            &IoStatusBlock,
            pNI,
            cbNI,
            FileNameInformation
            );

        if (ERROR_SUCCESS == Status)
            break;

        if (!(Status == STATUS_BUFFER_TOO_SMALL ||
                Status == STATUS_INFO_LENGTH_MISMATCH ||
                Status == STATUS_BUFFER_OVERFLOW))
            goto StatusErrorReturn;

        if (++cRetry >= MAX_QUERY_RETRY_CNT)
            goto InvalidNameReturn;

        //
        // Double buffer length and retry
        //

        cbNI = cbNI * 2;
        I_MartaFileFree(pAllocNI);
        if (NULL == (pAllocNI = (PFILE_NAME_INFORMATION)
                I_MartaFileNonzeroAlloc(cbNI)))
            goto NotEnoughMemoryReturn;
        pNI = pAllocNI;
    }

    //
    // Compute the length of the buffer required to hold the name.
    //

    pwszFileName = pNI->FileName;
    cchFileName = pNI->FileNameLength / sizeof(WCHAR);
    if (0 == cchFileName)
        goto InvalidNameReturn;

    cchNtObject = WINDFS_PREFIX_LEN + cchFileName;

    //
    // Allocate memory.
    //

    if (NULL == (pwszNtObject = (LPWSTR) I_MartaFileNonzeroAlloc(
            (cchNtObject + 1) * sizeof(WCHAR))))
        goto NotEnoughMemoryReturn;

    //
    // Copy the prefix and the file name.
    //

    memcpy(pwszNtObject, WINDFS_PREFIX, WINDFS_PREFIX_LEN * sizeof(WCHAR));
    memcpy(pwszNtObject + WINDFS_PREFIX_LEN, pwszFileName,
        cchFileName * sizeof(WCHAR));
    pwszNtObject[cchNtObject] = L'\0';

    dwErr = ERROR_SUCCESS;

CommonReturn:
    I_MartaFileFree(pAllocNI);
    *ppwszNtObject = pwszNtObject;
    return dwErr;

StatusErrorReturn:
    dwErr = RtlNtStatusToDosError(Status);
ErrorReturn:
    assert(NULL == pwszNtObject);
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;

InvalidNameReturn:
    dwErr = ERROR_INVALID_NAME;
    goto ErrorReturn;
}

STATIC
BOOL
I_MartaIsDfsJunctionPoint(
    IN MARTA_CONTEXT        Context
    )

/*++

Routine Description:

    Determine whether this is a DFS junction point.

Arguments:

    Context - Context for which the caller want to determine whether this is a
        dfs junction point.
        
Return Value:

    TRUE if this is a DFS junction point.
    FALSE o/w.

--*/

{
    BOOL fDfsJunctionPoint = FALSE;
    LPWSTR pwszNtObject = NULL;
    DWORD cchNtObject;
    LPWSTR pwszDfs;                 // not allocated
    NET_API_STATUS NetStatus;
    LPBYTE pbNetInfo = NULL;

    if (ERROR_SUCCESS != MartaConvertFileContextToNtName(
            Context, &pwszNtObject))
        goto CommonReturn;

    //
    // Check the prefix.
    //

    if (0 != _wcsnicmp(pwszNtObject, WINDFS_PREFIX, WINDFS_PREFIX_LEN))
        goto CommonReturn;

    //
    // Convert the NtDfs name to a UNC name
    //

    pwszDfs = pwszNtObject + WINDFS_PREFIX_LEN - 1;
    *pwszDfs = L'\\';

    //
    // Assumption: the following is only successful for DFS junction point
    // filename.
    //

    NetStatus = NetDfsGetInfo(
        pwszDfs,
        NULL,               // ServerName
        NULL,               // ShareName
        1,
        &pbNetInfo
        );
    if (0 == NetStatus) {
        fDfsJunctionPoint = TRUE;
    }

CommonReturn:
    if (pwszNtObject)
        LocalFree(pwszNtObject);
    if (pbNetInfo)
        NetApiBufferFree(pbNetInfo);

    return fDfsJunctionPoint;
}

DWORD
MartaConvertFileContextToNtName(
    IN MARTA_CONTEXT        Context,
    OUT LPWSTR              *ppwszNtObject
    )

/*++

Routine Description:

    Returns the NT Object Name for the given context. Allocates memory.

Arguments:

    Context - Context for the file/dir.

    ppwszNtbject - To return the name of the file/dir.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;
    LPWSTR pwszNtObject = NULL;

    BYTE Buff[MAX_PATH * 4];
    ULONG cLen = 0;
    POBJECT_NAME_INFORMATION pNI;                   // not allocated
    POBJECT_NAME_INFORMATION pAllocNI = NULL;

    NTSTATUS Status;
    HANDLE hFile;               // not opened
    LPWSTR pwszPath;
    DWORD cchPath;
    BOOL ExtraStep = FALSE;
    DWORD ExtraChars = 0;

    if (NULL == pFileContext || 0 == pFileContext->dwRefCnt)
        goto InvalidParameterReturn;

    hFile = pFileContext->hFile;

    //
    // The handle is invalid but we can still extract the name based on the
    // containing directory name and the basename for the child.
    //

    if (hFile == NULL) 
    {
        ExtraStep = TRUE;

        hFile = pFileContext->pFileFindData->hDir;

        if (hFile == NULL) 
        {
            goto InvalidParameterReturn;
        }

        //
        // Take into account the length needed for extra basename
        //

        ExtraChars = 1+ (pFileContext->pFileFindData->NamesInfoBuffer.NamesInfo.FileNameLength/sizeof(WCHAR));
    }

    //
    // First, determine the size of the buffer we need.
    //

    pNI = (POBJECT_NAME_INFORMATION) Buff;

    Status = NtQueryObject(hFile,
        ObjectNameInformation,
        pNI,
        sizeof(Buff),
        &cLen);

    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_BUFFER_TOO_SMALL ||
                Status == STATUS_INFO_LENGTH_MISMATCH ||
                Status == STATUS_BUFFER_OVERFLOW) {
            //
            // Allocate a big enough buffer
            //

            if (NULL == (pAllocNI = (POBJECT_NAME_INFORMATION)
                    I_MartaFileNonzeroAlloc(cLen)))
                goto NotEnoughMemoryReturn;

            pNI = pAllocNI;

            Status = NtQueryObject(hFile,
                                   ObjectNameInformation,
                                   pNI,
                                   cLen,
                                   NULL);
            if (!NT_SUCCESS(Status))
                goto StatusErrorReturn;
        } else
            goto StatusErrorReturn;
    }

    pwszPath = pNI->Name.Buffer;
    cchPath = pNI->Name.Length / sizeof(WCHAR);

    //
    // For DFS names, call a helper routine.
    //

    if (WINDFS_DEVICE_LEN <= cchPath &&
            0 == _wcsnicmp(pwszPath, WINDFS_DEVICE, WINDFS_DEVICE_LEN))
        dwErr = I_MartaFileHandleToNtDfsName(hFile, &pwszNtObject);
    else {

        //
        // Allocate and return the name of the object.
        //

        if (NULL == (pwszNtObject = (LPWSTR) I_MartaFileNonzeroAlloc(
                (cchPath + ExtraChars + 1) * sizeof(WCHAR))))
            goto NotEnoughMemoryReturn;

        memcpy(pwszNtObject, pwszPath, cchPath * sizeof(WCHAR));

        //
        // Add the basename if we really queried the directory instead of the child
        // we were supposed to.
        //

        if (ExtraStep) 
        {

            //
            // Add a backslash only if needed.
            //

            if (pwszNtObject[cchPath-1] != L'\\')
            {
                pwszNtObject[cchPath] = L'\\';
                memcpy(pwszNtObject+cchPath+1, pFileContext->pFileFindData->NamesInfoBuffer.NamesInfo.FileName, (ExtraChars-1)*sizeof(WCHAR));
                pwszNtObject[cchPath+ExtraChars] = L'\0';
            }
            else
            {
                memcpy(pwszNtObject+cchPath, pFileContext->pFileFindData->NamesInfoBuffer.NamesInfo.FileName, (ExtraChars-1)*sizeof(WCHAR));
                pwszNtObject[cchPath+ExtraChars-1] = L'\0';
            }
        }
        else
        {
            pwszNtObject[cchPath] = L'\0';
        }


        dwErr = ERROR_SUCCESS;
    }


CommonReturn:
    I_MartaFileFree(pAllocNI);
    *ppwszNtObject = pwszNtObject;
    return dwErr;

StatusErrorReturn:
    dwErr = RtlNtStatusToDosError(Status);
ErrorReturn:
    assert(NULL == pwszNtObject);
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;

InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
}


DWORD
MartaGetFileProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    )

/*++

Routine Description:

    Return the properties for file/dir represented by the context.

Arguments:

    Context - Context whose properties the caller has asked for.
    
    pProperties - To return the properties for this file/dir.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS Status;
    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicFileInfo;

    if (NULL == pFileContext || 0 == pFileContext->dwRefCnt)
        goto InvalidParameterReturn;

    //
    // Query the attributes for the file/dir.
    // In case of error, assume that it is a dir.
    //

    if (!NT_SUCCESS(Status = NtQueryInformationFile(
            pFileContext->hFile,
            &IoStatusBlock,
            &BasicFileInfo,
            sizeof(BasicFileInfo),
            FileBasicInformation)))
        pProperties->dwFlags |= MARTA_OBJECT_IS_CONTAINER;
    else if (BasicFileInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        pProperties->dwFlags |= MARTA_OBJECT_IS_CONTAINER;

    dwErr = ERROR_SUCCESS;
CommonReturn:
    return dwErr;

ErrorReturn:
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
}

DWORD
MartaGetFileTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    )

/*++

Routine Description:

    Return the properties of file system objects.

Arguments:

    pProperties - To return the properties of file system objects.

Return Value:

    ERROR_SUCCESS.

--*/

{
    const GENERIC_MAPPING GenMap = {
        FILE_GENERIC_READ,
        FILE_GENERIC_WRITE,
        FILE_GENERIC_EXECUTE,
        FILE_ALL_ACCESS
        };

    //
    // Propagation to be done on the client side.
    //
    pProperties->dwFlags |= MARTA_OBJECT_TYPE_MANUAL_PROPAGATION_NEEDED_FLAG;

    //
    // Tree organization of obects is present.
    //

    pProperties->dwFlags |= MARTA_OBJECT_TYPE_INHERITANCE_MODEL_PRESENT_FLAG;

    //
    // Return the generic mapping too.
    //

    pProperties->GenMap = GenMap;

    return ERROR_SUCCESS;
}

DWORD
MartaGetFileRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )

/*++

Routine Description:

    Get the security descriptor for the given handle.

Arguments:

    Context - Context for file/dir.
    
    SecurityInfo - Type of security information to be read.
    
    ppSecurityDescriptor - To return a self-relative security decriptor pointer.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    BOOL fResult;
    DWORD dwErr = ERROR_SUCCESS;
    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;
    DWORD cbSize;
    PISECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    if (NULL == pFileContext || 0 == pFileContext->dwRefCnt)
        goto InvalidParameterReturn;

    //
    // First, get the size we need
    //

    cbSize = 0;
    if (GetKernelObjectSecurity(
            pFileContext->hFile,
            SecurityInfo,
            NULL,                       // pSecDesc
            0,
            &cbSize
            ))
        goto InternalErrorReturn;

    dwErr = GetLastError();
    if (ERROR_INSUFFICIENT_BUFFER == dwErr) {
        if (NULL == (pSecurityDescriptor =
                (PISECURITY_DESCRIPTOR) I_MartaFileNonzeroAlloc(cbSize)))
            goto NotEnoughMemoryReturn;

        //
        // Now get the security descriptor.
        //

        if (!GetKernelObjectSecurity(
                pFileContext->hFile,
                SecurityInfo,
                pSecurityDescriptor,
                cbSize,
                &cbSize
                ))
            goto LastErrorReturn;
    } else
        goto ErrorReturn;

    dwErr = ERROR_SUCCESS;
CommonReturn:
    *ppSecurityDescriptor = pSecurityDescriptor;
    return dwErr;

LastErrorReturn:
    dwErr = GetLastError();
ErrorReturn:
    if (pSecurityDescriptor) {
        I_MartaFileFree(pSecurityDescriptor);
        pSecurityDescriptor = NULL;
    }
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;
InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
InternalErrorReturn:
    dwErr = ERROR_INTERNAL_ERROR;
    goto ErrorReturn;
}


DWORD
MartaSetFileRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )

/*++

Routine Description:

    Set the given security descriptor on the file/dir represented by the context.

Arguments:

    Context - Context for the file/dir.

    SecurityInfo - Type of security info to be stamped on the file/dir.

    pSecurityDescriptor - Security descriptor to be stamped.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;

    //
    // Basic validation on the context.
    //

    if (NULL == pFileContext || 0 == pFileContext->dwRefCnt)
        goto InvalidParameterReturn;

    //
    // Set the security on the file/dir.
    //

    if (!SetKernelObjectSecurity(
            pFileContext->hFile,
            SecurityInfo,
            pSecurityDescriptor
            ))
        goto LastErrorReturn;

    dwErr = ERROR_SUCCESS;
CommonReturn:
    return dwErr;
InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto CommonReturn;
LastErrorReturn:
    dwErr = GetLastError();
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;
}

ACCESS_MASK
MartaGetFileDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    )

/*++

Routine Description:

    Gets the access required to open object to be able to set or get the 
    specified security info.

Arguments:

    OpenType - Flag indicating if the object is to be opened to read or write
        the security information

    Attribs - TRUE indicates that additional access bits should be returned.

    SecurityInfo - owner/group/dacl/sacl

Return Value:

    Desired access mask with which open should be called.

--*/

{
    ACCESS_MASK DesiredAccess = 0;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    }

    //
    // ONLY FOR FILES.
    //

    if (Attribs)
    {
        DesiredAccess |= FILE_READ_ATTRIBUTES | READ_CONTROL;
    }

    return (DesiredAccess);
}

DWORD
MartaReopenFileContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    )

/*++

Routine Description:

    Given the context for a file/dir, close the existing handle if one exists 
    and reopen the context with new permissions.

Arguments:

    Context - Context to be reopened.
    
    AccessMask - Permissions for the reopen.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;

    PFILE_CONTEXT pFileContext = (PFILE_CONTEXT) Context;

    //
    // Following don't need to be freed or closed
    //

    PFILE_FIND_DATA pFileFindData;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_NAMES_INFORMATION pNamesInfo;
    HANDLE hDir;

    UNICODE_STRING FileName;

    //
    // VishnuP: Bug #384222 (AV since Context == NULL).
    // In MartaUpdateTree(), we don't error in case the 
    // ChildContext is NULL so return here too with success
    //

    if ( NULL == Context) 
    
    {
        return ERROR_SUCCESS;
    }

    //
    // Extract the data needed to open the file.
    //

    pFileFindData = pFileContext->pFileFindData;

    hDir = pFileFindData->hDir;
    pNamesInfo = &pFileFindData->NamesInfoBuffer.NamesInfo;

    FileName.Length = (USHORT) pNamesInfo->FileNameLength;
    FileName.MaximumLength = (USHORT) FileName.Length;
    FileName.Buffer = pNamesInfo->FileName;

    //
    // Close the original handle. We do not expect to hit this given the way
    // the code is organized now.
    //

    if (pFileContext->dwFlags & FILE_CONTEXT_CLOSE_HANDLE_FLAG)
    {
        NtClose(pFileContext->hFile);
        pFileContext->hFile = NULL;
        pFileContext->dwFlags &= ~FILE_CONTEXT_CLOSE_HANDLE_FLAG;
    }

    //
    // Open the file with the access mask desired.
    //

    dwErr = I_MartaFileNtOpenFile(
        &FileName,
        hDir,
        AccessMask,
        pFileContext
        );

    //
    // In case of a successful open mark the context.
    //

    if (ERROR_SUCCESS == dwErr)
    {
        pFileContext->dwFlags |= FILE_CONTEXT_CLOSE_HANDLE_FLAG;
    }

    return dwErr;
}

DWORD
MartaReopenFileOrigContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    )

/*++

Routine Description:

    This is a dummy routine.

Arguments:

     Are ignored.

Return Value:

    ERROR_SUCCESS

Note: 

    The context structure must be left untouched.

--*/

{
    //
    // This is a dummy routine. The real reopen is done by MartaFindFirstFile
    // that is called just after this call. The context contains a valid handle
    // which was used to set a new DACL on the file/dir.
    //

    return ERROR_SUCCESS;
}

DWORD
MartaGetFileNameFromContext(
    IN LPWSTR DosName,
    IN LPWSTR NtName,
    IN MARTA_CONTEXT Context,
    OUT LPWSTR *pObjectName
    )

/*++

Routine Description:

    Get the name of the file/dir from the context. This routine allocates 
    memory required to hold the name of the object.

Arguments:

    DosName - Dos name of the root of the tree. When this is NULL, return the 
    NtName as returned by the internal API.
    
    NtName - NtName for the root of the tree.
    
    Context - Handle to the context.
    
    pObjectName - To return the pointer to the allocated string.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    DWORD Length = 0;
    DWORD LengthDiff = 0;
    LPWSTR Str = NULL;
    LPWSTR RetStr = NULL;

    *pObjectName = NULL;

    //
    // Get the name in Nt format.
    //

    dwErr = MartaConvertFileContextToNtName(Context, &Str);

    if (dwErr != ERROR_SUCCESS) 
    {
        return dwErr;
    }

    //
    // This is a special case to get the Nt name for the root of the subtree.
    //

    if ((DosName == NULL)  || (NtName == NULL))
    {
        *pObjectName = Str;
        return ERROR_SUCCESS;
    }

    //
    // Compute the length needed to fit the Dosname.
    //

    LengthDiff = wcslen(NtName);
    Length = 1 + wcslen(DosName) + wcslen(Str) - LengthDiff;

    RetStr = (LPWSTR) LocalAlloc(LMEM_FIXED, Length * sizeof(WCHAR));

    if (RetStr == NULL) 
    {
        LocalFree(Str);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy the prefix, followed by the suffix.
    //

    wcscpy(RetStr, DosName);

    wcscat(RetStr, Str + LengthDiff);

    LocalFree(Str);

    *pObjectName = RetStr;

    return ERROR_SUCCESS;

}

DWORD
MartaGetFileParentName(
    IN LPWSTR ObjectName,
    OUT LPWSTR *pParentName
    )

/*++

Routine Description:

    Given the name of a file/dir return the name of its parent. The routine 
    allocates memory required to hold the parent name.

Arguments:

    ObjectName - Name of the file/dir.
    
    pParentName - To return the pointer to the allocated parent name.
        In case of the root of the tree, we return NULL parent with ERROR_SUCCESS.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    ULONG Length = wcslen(ObjectName) + 1;
    PWCHAR Name = (PWCHAR) I_MartaFileNonzeroAlloc(sizeof(WCHAR) * Length);
    DWORD dwErr = ERROR_SUCCESS;

    *pParentName = NULL;

    if (!Name)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Copy the name of the object into the allocated buffer.
    //

    wcscpy((WCHAR *) Name, ObjectName);

    //
    // Convert the object name intp its parent name.
    //

    dwErr = I_MartaFileGetNtParentString(Name);

    if (ERROR_SUCCESS != dwErr)
    {
        I_MartaFileFree(Name);

        //
        // This is the root of the tree which does not have a parent. Return
        // ERROR_SUCCESS with ParentName as NULL.
        //

        if (ERROR_INVALID_NAME == dwErr)
            return ERROR_SUCCESS;

        return dwErr;
    }

    *pParentName = Name;

    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\file.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       file.cxx
//
//  Contents:   Local file support functions
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <ntprov.hxx>
#include <alsup.hxx>
#include <martaevt.h>

extern "C"
{
    #include <lmdfs.h>
    #include <stdio.h>
    #include <seopaque.h>
    #include <sertlp.h>
}

#define LMRDR   L"\\Device\\LanmanRedirector"
#define WINDFS  L"\\Device\\WinDfs"

GENERIC_MAPPING gFileGenMap = {FILE_GENERIC_READ,
                              FILE_GENERIC_WRITE,
                              FILE_GENERIC_EXECUTE,
                              FILE_ALL_ACCESS};

//+---------------------------------------------------------------------------
//
//  Function:   ConvertFileHandleToName
//
//  Synopsis:   Determines the file name for a handle.  Issues an
//              NtQueryInformationFile to determine the file name
//
//  Arguments:  [IN hFile]              --      The (open) handle of the file
//                                              object
//              [OUT ppwszName]         --      Where the name is returned
//
//  Returns:    ERROR_SUCCESS           --      Succcess
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//  Notes:      The returned memory must be freed with AccFree
//
//----------------------------------------------------------------------------
DWORD
ConvertFileHandleToName(IN  HANDLE      hFile,
                        OUT PWSTR      *ppwszName)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CHECK_HEAP

    //
    // First, determine the size of the buffer we need...
    //
    HANDLE      hRootDir = NULL;
    BYTE        pBuff[512];
    ULONG       cLen = 0;
    POBJECT_NAME_INFORMATION pNI = NULL;
    PWSTR       pwszPath = NULL;
    NTSTATUS    Status = NtQueryObject(hFile,
                                       ObjectNameInformation,
                                       (POBJECT_NAME_INFORMATION)pBuff,
                                       512,
                                       &cLen);
    if(!NT_SUCCESS(Status))
    {
        if(Status == STATUS_BUFFER_TOO_SMALL ||
            Status == STATUS_INFO_LENGTH_MISMATCH)
        {
            //
            // Fine.. Allocate a big enough buffer
            //
            pNI = (POBJECT_NAME_INFORMATION)AccAlloc(cLen);
            if(pNI != NULL)
            {
                Status = NtQueryObject(hFile,
                                       ObjectNameInformation,
                                       pNI,
                                       cLen,
                                       NULL);
                if(NT_SUCCESS(Status))
                {
                    pwszPath = pNI->Name.Buffer;

                    acDebugOut((DEB_TRACE_HANDLE, "Path for handle 0x%lx: %ws\n",
                                hFile, pwszPath));
                }
                AccFree(pNI);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
            }
        }

        dwErr = RtlNtStatusToDosError(Status);

        if(dwErr == ERROR_SUCCESS && pwszPath == NULL)
        {
            dwErr = ERROR_INVALID_HANDLE;
        }

        if (dwErr != ERROR_SUCCESS)
        {
            acDebugOut(( DEB_ERROR,
                         "Failed to get path for handle 0x%lx: %lu\n",
                         hFile, dwErr ));

            ASSERT( dwErr == ERROR_SUCCESS );

        }

    }
    else
    {
        pwszPath =((POBJECT_NAME_INFORMATION)pBuff)->Name.Buffer;
        acDebugOut((DEB_TRACE_HANDLE, "Path for handle 0x%lx: %ws\n", hFile, pwszPath));
    }

    if(dwErr == ERROR_SUCCESS &&
       _wcsnicmp(pwszPath,
                 LMRDR,
                 sizeof(LMRDR) / sizeof(WCHAR) - 1) == 0)
    {
        *ppwszName = (PWSTR)AccAlloc(sizeof(WCHAR) *
              (wcslen(pwszPath + ((sizeof(LMRDR) - 1) / sizeof(WCHAR))) + 2));
        if(*ppwszName == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            swprintf(*ppwszName,
                     L"\\%ws",
                     pwszPath + (sizeof(LMRDR) / sizeof(WCHAR) - 1));
        }

        acDebugOut((DEB_TRACE_HANDLE, "returning path %ws as LM Rdr path\n",
                    *ppwszName ));


        return(dwErr);
    }

    if(dwErr != ERROR_SUCCESS)
    {
        acDebugOut((DEB_ERROR,
                    "ConvertFileHandleToPath on 0x%lx failed with %lu\n",
                    hFile,
                    dwErr));
        return(dwErr);
    }

    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   Attributes;
    UCHAR               Buffer[1024];
    BOOL                fFound = FALSE;
    ULONG               Context = 0;
    POBJECT_DIRECTORY_INFORMATION DirInfo = NULL;
    //
    // Get a handle to the directory and iterate through that directory
    // to find the object name.
    //

    RtlInitUnicodeString(&UnicodeString,
                         L"\\??");

    InitializeObjectAttributes(&Attributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenDirectoryObject(&hRootDir,
                                   DIRECTORY_QUERY,
                                   &Attributes);

    if (!NT_SUCCESS(Status))
    {
        return(RtlNtStatusToDosError(Status));
    }

    //
    // Get the entries in batches that will fit in a buffer of size
    // BUFFERSIZE until we find the entry that we want
    //
    while (NT_SUCCESS(Status) && !fFound )
    {
        RtlZeroMemory(Buffer,
                      1024);

        Status = NtQueryDirectoryObject(hRootDir,
                                        (PVOID)&Buffer,
                                        1024,
                                        FALSE,
                                        FALSE,
                                        &Context,
                                        NULL);
        if(NT_SUCCESS(Status))
        {
            //
            // Keep looking until we've examined all the entries in this
            // batch or we find what we're looking for.
            //
            DirInfo = (POBJECT_DIRECTORY_INFORMATION)&Buffer[0];
            while(!fFound && DirInfo->Name.Length != 0)
            {
                HANDLE LinkHandle;
                UNICODE_STRING LinkTarget;

                ASSERT( DirInfo != NULL );
                ASSERT( DirInfo->Name.Length != 0 );
                ASSERT( DirInfo->TypeName.Length != 0 );

                acDebugOut((DEB_TRACE_HANDLE, "Checking dir entry %wZ\n",
                            &DirInfo->Name));


                RtlInitUnicodeString(&UnicodeString,
                                     DirInfo->Name.Buffer);
                InitializeObjectAttributes(&Attributes,
                                           &UnicodeString,
                                           OBJ_CASE_INSENSITIVE,
                                           hRootDir,
                                           NULL);
                Status = NtOpenSymbolicLinkObject(&LinkHandle,
                                                  SYMBOLIC_LINK_QUERY,
                                                  &Attributes);
                if(NT_SUCCESS(Status))
                {
                    WCHAR LinkTargetBuffer[1024];
                    memset(LinkTargetBuffer,0,1024 * sizeof(WCHAR));
                    LinkTarget.Buffer = LinkTargetBuffer;
                    LinkTarget.Length = 0;
                    LinkTarget.MaximumLength = sizeof(LinkTargetBuffer);
                    Status = NtQuerySymbolicLinkObject(LinkHandle,
                                                       &LinkTarget,
                                                       NULL);
                    if(NT_SUCCESS(Status))
                    {
                        acDebugOut((DEB_TRACE_HANDLE, "Symbolic link for %wZ: %wZ\n",
                                    &DirInfo->Name, &LinkTarget));

                        if(_wcsnicmp(pwszPath,
                                     LinkTargetBuffer,
                                     LinkTarget.Length / sizeof(WCHAR)) == 0 &&
                            IS_FILE_PATH( DirInfo->Name.Buffer,
                                          DirInfo->Name.Length / sizeof(WCHAR) ) )
                        {
                            fFound = TRUE;
                            *ppwszName = (PWSTR)AccAlloc((wcslen(DirInfo->Name.Buffer) +
                                                         wcslen(pwszPath + (LinkTarget.Length / sizeof(WCHAR))) +
                                                         1) * sizeof(WCHAR));
                            if(*ppwszName == NULL)
                            {
                                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                            }
                            else
                            {
                                swprintf(*ppwszName,
                                         L"%ws%ws",
                                         DirInfo->Name.Buffer,
                                         pwszPath + (LinkTarget.Length / sizeof(WCHAR)));

                                acDebugOut((DEB_TRACE_HANDLE, "Returning path %ws\n", *ppwszName ));

                            }
                        }
                    }
                    NtClose(LinkHandle);
                }

                DirInfo++;
            }
        }
    }

    if (!fFound)
    {
        if(Status !=  STATUS_NO_MORE_ENTRIES)
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
        else
        {
            dwErr = ERROR_RESOURCE_NAME_NOT_FOUND;
        }
    }

    if(hRootDir != NULL)
    {
        NtClose(hRootDir);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadFileSD
//
//  Synopsis:   Reads the file descriptor off of the given file handle
//
//  Arguments:  [IN hFile]              --      The (open) handle of the file
//                                              object
//              [IN  SeInfo]            --      The security information to
//                                              read
//              [IN  cKnownSize]        --      If non-0, this is the size
//                                              of the buffer to allocate
//                                              for the SD.  If 0, the buffer
//                                              size is determined
//              [OUT ppSD]              --      Where the security descriptor
//                                               is returned
//
//  Returns:    ERROR_SUCCESS           --      Succcess
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//  Notes:      The returned memory must be freed with AccFree
//
//----------------------------------------------------------------------------
DWORD
ReadFileSD(IN  HANDLE                   hFile,
           IN  SECURITY_INFORMATION     SeInfo,
           IN  ULONG                    cKnownSize,
           OUT PSECURITY_DESCRIPTOR    *ppSD)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CHECK_HEAP


    NTSTATUS Status;
    ULONG   cNeeded;

    //
    // If we don't know the size of the object, go ahead and determine it
    //
    if(cKnownSize == 0)
    {
        Status = NtQuerySecurityObject(hFile,
                                       SeInfo,
                                       *ppSD,
                                       0,
                                       &cNeeded);
        if(!NT_SUCCESS(Status))
        {
            if(Status == STATUS_BUFFER_TOO_SMALL)
            {
                cKnownSize = cNeeded;
                Status = STATUS_SUCCESS;
            }
        }

        dwErr = RtlNtStatusToDosError(Status);
    }

    //
    // Now, the actual read
    //
    if(dwErr == ERROR_SUCCESS)
    {
        *ppSD = (PISECURITY_DESCRIPTOR)AccAlloc(cKnownSize);
        if(*ppSD == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            Status = NtQuerySecurityObject(hFile,
                                           SeInfo,
                                           *ppSD,
                                           cKnownSize,
                                           &cNeeded);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   IsFileContainer
//
//  Synopsis:   Determines if the file is a container (directory)
//
//  Arguments:  [IN Handle]             --      the (open) handle of the file
//                                              object
//              [OUT pfIsContainer]     --      flag indicating if the object
//                                              is a container
//
//  Returns:    ERROR_SUCCESS           --      Succcess
//
//----------------------------------------------------------------------------
DWORD
IsFileContainer(HANDLE          Handle,
                PBOOL           pfIsContainer)
{
    NTSTATUS        ntstatus;
    IO_STATUS_BLOCK iosb;
    FILE_BASIC_INFORMATION basicfileinfo;
    *pfIsContainer = FALSE;

    //
    // call NtQueryInformationFile to get basic file information
    //
    if (NT_SUCCESS(ntstatus = NtQueryInformationFile(Handle,
                                               &iosb,
                                               &basicfileinfo,
                                               sizeof(FILE_BASIC_INFORMATION),
                                               FileBasicInformation)))
    {
        *pfIsContainer =
                (basicfileinfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)   ?
                                                                    TRUE    :
                                                                    FALSE;
        return(ERROR_SUCCESS);
    }
    else
    {
        return(RtlNtStatusToDosError(ntstatus));
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   IsFilePathLocalOrLM
//
//  Synopsis:   Determines if the path is that of a local object or a remote
//              (network) object
//
//  Arguments:  [IN pwszFile]           --      The file to check
//
//  Returns:    ERROR_SUCCESS           --      Succcess
//              ERROR_PATH_NOT_FOUND    --      No such path exists
//
//----------------------------------------------------------------------------
DWORD
IsFilePathLocalOrLM(IN  LPWSTR      pwszFile)
{
    DWORD       dwErr = ERROR_SUCCESS;
    BOOL        fIsDfs = FALSE;
    NTSTATUS    Status;

    if (pwszFile && wcsncmp(pwszFile, L"\\\\?\\", 4) == 0)
    {
        pwszFile += 4;
    }

    //
    // First, try the simply case of it not being accessible...
    //
    if(GetFileAttributes(pwszFile) == 0xFFFFFFFF)
    {
        dwErr = GetLastError();

        if(dwErr == ERROR_PATH_NOT_FOUND || dwErr == ERROR_FILE_NOT_FOUND)
        {
            return(ERROR_PATH_NOT_FOUND);
        }
    }

    //
    // Otherwise, we need to find out whether it's a path that only we have
    // access to or not
    //

#if 0
    // for some reason, the full path name built is never used - waste time
    // First, we'll see if it's a relative path.  If so, we'll have to
    // build a full path...
    //
    PWSTR   pwszFullPath = pwszFile;
    DWORD   dwSize;
    if(wcslen(pwszFile) < 2 || (pwszFile[1] != L':' && pwszFile[1] != L'\\'))
    {
        //
        // It's a relative path...
        //
        dwSize = GetFullPathName(pwszFile,
                                 0,
                                 NULL,
                                 NULL);
        if(dwSize == 0)
        {
            dwErr = GetLastError();
        }
        else
        {
            pwszFullPath = (PWSTR)AccAlloc((dwSize + 1) * sizeof(WCHAR));
            if(pwszFullPath == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                PWSTR   pwszFilePart;
                if(GetFullPathName(pwszFile,
                                   dwSize,
                                   pwszFullPath,
                                   &pwszFilePart) == 0)
                {
                    dwErr = GetLastError();
                }
            }
        }
    }
#endif

    if(pwszFile[1] == L':')
    {
        if(GetDriveType(pwszFile) == DRIVE_REMOTE)
        {
            //
            // Have to figure out what it is...
            //
            #define BUFFERSIZE  1024

            HANDLE              hRootDir;
            UNICODE_STRING      ObjDir;
            OBJECT_ATTRIBUTES   Attributes;
            UCHAR               Buffer[BUFFERSIZE];
            ULONG               Context = 0;
            POBJECT_DIRECTORY_INFORMATION pDirInfo = NULL;

            RtlInitUnicodeString(&ObjDir,
                                 L"\\??");

            InitializeObjectAttributes(&Attributes,
                                       &ObjDir,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            Status = NtOpenDirectoryObject(&hRootDir,
                                           DIRECTORY_QUERY,
                                           &Attributes);

            //
            // Get the entries in batches that will fit in a buffer of size
            // BUFFERSIZE until we find the entry that we want
            //
            BOOL    fFound = FALSE;
            while (NT_SUCCESS(Status) && !fFound )
            {
                RtlZeroMemory(Buffer,
                              BUFFERSIZE);

                Status = NtQueryDirectoryObject(hRootDir,
                                                (PVOID)&Buffer,
                                                BUFFERSIZE,
                                                FALSE,
                                                FALSE,
                                                &Context,
                                                NULL);
                if(NT_SUCCESS(Status))
                {
                    //
                    // Keep looking until we've examined all the entries in this
                    // batch or we find what we're looking for.
                    //
                    pDirInfo = (POBJECT_DIRECTORY_INFORMATION)&Buffer[0];
                    while(pDirInfo->Name.Length != 0)
                    {
                        ULONG cChar;

                        cChar = pDirInfo->Name.Length/sizeof(WCHAR);
                        if(_wcsnicmp(pDirInfo->Name.Buffer,
                                     pwszFile,
                                     2) == 0)
                        {
                            fFound = TRUE;
                            break;
                        }
                        else
                        {
                            pDirInfo++;
                        }
                    }
                }
            }

            NtClose(hRootDir);

            if(fFound != TRUE)
            {
                dwErr = RtlNtStatusToDosError(Status);

                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = ERROR_PATH_NOT_FOUND;
                }
            }
            else
            {
                //
                // Now, figure out what type of path I have
                //
                if(wcscmp(pDirInfo->TypeName.Buffer,
                          L"SymbolicLink") == 0)
                {
                    HANDLE  hLink;
                    RtlInitUnicodeString(&ObjDir,
                                         pDirInfo->Name.Buffer);
                    InitializeObjectAttributes(&Attributes,
                                               &ObjDir,
                                               OBJ_CASE_INSENSITIVE,
                                               NULL,
                                               NULL);

                    Status = NtOpenSymbolicLinkObject(&hLink,
                                                      SYMBOLIC_LINK_QUERY,
                                                      &Attributes);

                    if(NT_SUCCESS(Status))
                    {
                        UNICODE_STRING  Link;
                        Link.Buffer = (PWSTR)Buffer;
                        Link.Length = 0;
                        Link.MaximumLength = sizeof(Buffer);
                        Status = NtQuerySymbolicLinkObject(hLink,
                                                           &Link,
                                                           NULL);
                        NtClose(hLink);

                        if(NT_SUCCESS(Status))
                        {
                            //
                            // See if this is part of the lanman redir set
                            //
                            if(_wcsnicmp(Link.Buffer,
                                         LMRDR,
                                         sizeof(LMRDR) / sizeof(WCHAR)) != 0)
                            {
                                //
                                // See if it's a DFS path before passing
                                // judgement
                                //
                                if(_wcsnicmp(Link.Buffer,
                                             WINDFS,
                                             sizeof(WINDFS) / sizeof(WCHAR)) == 0)
                                {
//                                    fIsDfs = TRUE;
                                }
                                else
                                {
                                    dwErr = ERROR_PATH_NOT_FOUND;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    if(fIsDfs == TRUE || IS_UNC_PATH(pwszFile, wcslen(pwszFile)))
    {

        //
        // Try and open it...
        //
/*
        //
        // First, see if it's a DFS path...
        //
        if(fIsDfs || IsThisADfsPath((LPCWSTR)pwszFile, 0) == TRUE)
        {
            ULONG cLocals = 0;
            dwErr = GetLMDfsPaths(pwszFile,
                                  &cLocals,
                                  NULL);
            if(dwErr == ERROR_SUCCESS && cLocals == 0)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
        }
        else
        {
*/
        //
        // We'll try to open it...
        //
        UNICODE_STRING      FileName;
        if ( RtlDosPathNameToNtPathName_U(pwszFile,
                                          &FileName,
                                          NULL,
                                          NULL) ) {

/*
            WCHAR   wszPath[MAX_PATH + 1 + sizeof(LMRDR) / sizeof(WCHAR) + 1];

            //
            // Build the path...
            //
            ASSERT(wcslen(pwszFile) < MAX_PATH + 1);

            swprintf(wszPath,
                     L"%ws%ws",
                     LMRDR,
                     pwszFile + 1);
*/
//            UNICODE_STRING      Path;
            OBJECT_ATTRIBUTES   ObjAttribs;
            IO_STATUS_BLOCK     IOSb;
            HANDLE              hRmt;

//            RtlInitUnicodeString(&Path, wszPath);
            InitializeObjectAttributes(&ObjAttribs,
                                       &FileName, // &Path,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            Status = NtCreateFile(&hRmt,
                                  SYNCHRONIZE,
                                  &ObjAttribs,
                                  &IOSb,
                                  NULL,
                                  FILE_ATTRIBUTE_NORMAL,
                                  FILE_SHARE_READ,
                                  FILE_OPEN_IF,
                                  FILE_SYNCHRONOUS_IO_NONALERT,
                                  NULL,
                                  0);
            if(!NT_SUCCESS(Status))
            {
                dwErr = RtlNtStatusToDosError(Status);
            }
            else
            {
                NtClose(hRmt);
            }

            RtlFreeHeap(RtlProcessHeap(), 0, FileName.Buffer );

        } else {
            dwErr = ERROR_INVALID_NAME;
        }
    }

#if 0
    //
    // never used!!! Free our memory
    //
    if(pwszFullPath != pwszFile)
    {
        AccFree(pwszFullPath);
    }
#endif

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function :  OpenFileObject
//
//  Synopsis :  opens the specified file (or directory) object
//
//  Arguments: [IN pObjectName]         --      The name of the file object
//             [IN AccessMask]          --      How to open the file
//             [OUT Handle]             --      Where to return the file
//                                              handle
//             [IN fOpenRoot]           --      Open the path as the root of a drive
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
OpenFileObject(IN  LPWSTR       pObjectName,
               IN  ACCESS_MASK  AccessMask,
               OUT PHANDLE      Handle,
               IN  BOOL         fOpenRoot)
{
    acDebugOut((DEB_TRACE, "in OpenFileObject\n"));

    NTSTATUS            ntstatus;
    DWORD               status = ERROR_SUCCESS;
    WCHAR               PathBuff[ 7 ];
    OBJECT_ATTRIBUTES   oa;
    IO_STATUS_BLOCK     isb;
    UNICODE_STRING      FileName;
    RTL_RELATIVE_NAME_U RelativeName;
    IO_STATUS_BLOCK     IoStatusBlock;
    PVOID               FreeBuffer = NULL;
    BOOL                ReleaseRelativeName = FALSE;

    //
    // cut and paste code from windows\base\advapi\security.c SetFileSecurityW
    //

    if(fOpenRoot == TRUE && wcslen(pObjectName) == 2)
    {
        wcscpy(PathBuff, L"\\??\\");
        wcscat(PathBuff, pObjectName);
        RtlInitUnicodeString(&FileName, PathBuff);
        RtlZeroMemory(&RelativeName, sizeof(RelativeName));

    } else {

        if(RtlDosPathNameToRelativeNtPathName_U(pObjectName, &FileName, NULL, &RelativeName))
        {

            ReleaseRelativeName = TRUE;
            FreeBuffer = FileName.Buffer;

            if ( RelativeName.RelativeName.Length )
            {
                FileName = RelativeName.RelativeName;
            }
            else
            {
                RelativeName.ContainingDirectory = NULL;
            }
        }
        else
        {
            status = ERROR_INVALID_NAME;
        }
    }


    if(status == ERROR_SUCCESS)
    {

        InitializeObjectAttributes(&oa,
                                   &FileName,
                                   OBJ_CASE_INSENSITIVE,
                                   RelativeName.ContainingDirectory,
                                   NULL);


        ntstatus = NtOpenFile( Handle,
                               AccessMask,
                               &oa,
                               &isb,
                               FILE_SHARE_READ |
                               FILE_SHARE_WRITE |
                               FILE_SHARE_DELETE,
                               0);

        if (!NT_SUCCESS(ntstatus))
        {
            status = RtlNtStatusToDosError(ntstatus);
        }

        if (ReleaseRelativeName) {
            RtlReleaseRelativeName(&RelativeName);
        }
        RtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);
    }
    else
    {
        status = ERROR_INVALID_NAME;
    }

    acDebugOut((DEB_TRACE, "OutOpenFileObject: %lu\n", status));
    return(status);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadFilePropertyRights
//
//  Synopsis:   Reads the access rights from the specified properties on the
//              specified file
//
//  Arguments:  [IN  pwszFile]          --      The file to get the rights for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//
//----------------------------------------------------------------------------
DWORD
ReadFilePropertyRights(IN  PWSTR                    pwszFile,
                       IN  PACTRL_RIGHTS_INFO       pRightsList,
                       IN  ULONG                    cRights,
                       IN  CAccessList&             AccessList)
{
    acDebugOut((DEB_TRACE,
                "in ReadFilePropertyRights\n"));

    DWORD   dwErr = ERROR_SUCCESS;
    PWSTR   pwszPath;

    CHECK_HEAP


    //
    // For the moment, there is only file properties itself...
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Set the server name to lookup accounts on
    //
    dwErr = SetAccessListLookupServer( pwszFile,
                                       AccessList );

    //
    // Always open with READ_CONTROL..
    //
    HANDLE  hFile;
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = OpenFileObject(pwszFile,
                               GetDesiredAccess(READ_ACCESS_RIGHTS,
                                                pRightsList[0].SeInfo)              |
                                                         FILE_READ_ATTRIBUTES   |
                                                         READ_CONTROL,
                               &hFile,
                               FALSE);
    }

    if(dwErr == ERROR_SUCCESS && IS_FILE_PATH(pwszFile,wcslen(pwszFile)))
    {
        //
        // See if there is a server associated with this path
        //
        dwErr = ConvertFileHandleToName(hFile,
                                        &pwszPath );

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = SetAccessListLookupServer( pwszPath,
                                               AccessList );

            AccFree(pwszPath);
        }
        //
        // jinhuang: do not care if it finds the remote server or not
        //
        dwErr = ERROR_SUCCESS;
    }

    if(dwErr == ERROR_SUCCESS)
    {
        PSECURITY_DESCRIPTOR    pSD = NULL;
        dwErr = GetKernelSecurityInfo(hFile,
                                      pRightsList[0].SeInfo,
                                      NULL,
                                      NULL,
                                      &pSD);

        if(dwErr == ERROR_SUCCESS && pSD == NULL)
        {
            dwErr = ERROR_ACCESS_DENIED;

        }

        //
        // If that worked, we'll have to get the parent SD, if it exists,
        // and see if we can determine the inheritance on our current object.
        // We only have to do this if we are reading the DACL or SACL
        //
        if(dwErr == ERROR_SUCCESS)
        {
            if((FLAG_ON(pRightsList[0].SeInfo, DACL_SECURITY_INFORMATION) &&
                !FLAG_ON(((PISECURITY_DESCRIPTOR)pSD)->Control,
                         SE_DACL_AUTO_INHERITED | SE_DACL_PROTECTED)) ||
               (FLAG_ON(pRightsList[0].SeInfo, SACL_SECURITY_INFORMATION) &&
                !FLAG_ON(((PISECURITY_DESCRIPTOR)pSD)->Control,
                         SE_SACL_AUTO_INHERITED | SE_SACL_PROTECTED)))
            {
                //
                // Ok, it's downlevel, so get the parent SD...
                //
                PSECURITY_DESCRIPTOR    pParentSD;
                dwErr = GetFileParentRights(pwszFile,
                                            pRightsList,
                                            cRights,
                                            NULL,
                                            NULL,
                                            &pParentSD);

                //
                // gross hack for the NTFS people, who don't allow opens on the $Extend directory
                //
                if ( dwErr == ERROR_ACCESS_DENIED &&
                     _wcsnicmp( pwszFile + 1, L":\\$Extend", 9 ) == 0 ) {

                    pParentSD = NULL;
                    dwErr = ERROR_SUCCESS;
                }

                //
                // Also, the routine to convert from nt4 to nt5 security
                // descriptor requires that we have the owner and group,
                // so we may have to reread the child SD if we don't have
                // that info
                //
                if(dwErr == ERROR_SUCCESS && (!FLAG_ON(pRightsList[0].SeInfo,
                                            OWNER_SECURITY_INFORMATION)  ||
                                            !FLAG_ON(pRightsList[0].SeInfo,
                                            GROUP_SECURITY_INFORMATION)))
                {
                    AccFree(pSD);
                    pSD = NULL;
                    dwErr = GetKernelSecurityInfo(hFile,
                                                  pRightsList[0].SeInfo |
                                                   OWNER_SECURITY_INFORMATION |
                                                   GROUP_SECURITY_INFORMATION,
                                                  NULL,
                                                  NULL,
                                                  &pSD);
                }

                //
                // A NULL parent SD means this object has no parent!
                //
                if(dwErr == ERROR_SUCCESS)
                {

                    if(pParentSD != NULL)
                    {
                        BOOL    fIsContainer;
                        dwErr = IsFileContainer(hFile,
                                                &fIsContainer);

                        if(dwErr == ERROR_SUCCESS)
                        {
                            PSECURITY_DESCRIPTOR    pNewSD;
                            dwErr = ConvertToAutoInheritSD(pParentSD,
                                                           pSD,
                                                           fIsContainer,
                                                           &gFileGenMap,
                                                           &pNewSD);
                            if(dwErr == ERROR_SUCCESS)
                            {
                                dwErr = AccessList.AddSD(pNewSD,
                                                     pRightsList[0].SeInfo,
                                                     pRightsList[0].pwszProperty);

                                DestroyPrivateObjectSecurity(&pNewSD);
                            }

                        }

                        AccFree(pParentSD);
                    }
                    else
                    {
                        dwErr = AccessList.AddSD(pSD,
                                                 pRightsList[0].SeInfo,
                                                 pRightsList[0].pwszProperty);
                    }
                }
            }
            else
            {
                //
                // Simply add the SD to our list
                //
                dwErr = AccessList.AddSD(pSD,
                                         pRightsList[0].SeInfo,
                                         pRightsList[0].pwszProperty);

            }

            //
            // Make sure to free the security descriptor...
            //
            AccFree(pSD);
        }


        NtClose(hFile);
    }

    acDebugOut((DEB_TRACE,
                "Out ReadFilePropertyRights %lu\n",
                dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadFileRights
//
//  Synopsis:   Reads the access rights from the specified properties on the
//              open file
//
//  Arguments:  [IN  pwszFile]          --      The file to get the rights for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//
//----------------------------------------------------------------------------
DWORD
ReadFileRights(IN  HANDLE               hObject,
               IN  PACTRL_RIGHTS_INFO   pRightsList,
               IN  ULONG                cRights,
               IN  CAccessList&         AccessList)
{
    acDebugOut((DEB_TRACE,
                "in ReadFileRights\n"));

    DWORD   dwErr = ERROR_SUCCESS;
    PACL                    pDAcl, pSAcl;
    PSECURITY_DESCRIPTOR    pSD;
    PWSTR   pwszPath = NULL;


    CHECK_HEAP

    //
    // See if there is a server associated with this path
    //
    dwErr = ConvertFileHandleToName(hObject,
                                    &pwszPath );

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = SetAccessListLookupServer( pwszPath,
                                           AccessList );

        AccFree(pwszPath);
    }


    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = GetKernelSecurityInfo(hObject,
                                      pRightsList[0].SeInfo,
                                      &pDAcl,
                                      &pSAcl,
                                      &pSD);
    }

    //
    // If that worked, we'll have to get the parent SD, if it exists,
    // and see if we can determine the inheritance on our current object
    //
    if(dwErr == ERROR_SUCCESS && !FLAG_ON(pRightsList[0].SeInfo,
                                            DACL_SECURITY_INFORMATION   |
                                              SACL_SECURITY_INFORMATION))
    {
        //
        // Just insert it and continue
        //
        dwErr = AccessList.AddSD(pSD,
                                 pRightsList[0].SeInfo,
                                 pRightsList[0].pwszProperty);
        AccFree(pSD);

    }
    else if(dwErr == ERROR_SUCCESS)
    {
        if(!FLAG_ON(((PISECURITY_DESCRIPTOR)pSD)->Control,
                     SE_SACL_AUTO_INHERITED |
                        SE_DACL_AUTO_INHERITED))
        {
            //
            // Ok, it's downlevel, so get the parent SD...  In order to
            // do this, we'll have to determine who the parent is (path wise)
            //
            PWSTR   pwszName = NULL;

            dwErr = ConvertFileHandleToName(hObject,
                                            &pwszName);
            if(dwErr == ERROR_SUCCESS)
            {
                PSECURITY_DESCRIPTOR    pParentSD;
                PACL                    pParentDAcl, pParentSAcl;
                dwErr = GetFileParentRights(pwszName,
                                            pRightsList,
                                            cRights,
                                            &pParentDAcl,
                                            &pParentSAcl,
                                            &pParentSD);

                if(dwErr == ERROR_SUCCESS && (!FLAG_ON(pRightsList[0].SeInfo,
                                            OWNER_SECURITY_INFORMATION)  ||
                                            !FLAG_ON(pRightsList[0].SeInfo,
                                            GROUP_SECURITY_INFORMATION)))
                {
                    AccFree(pSD);
                    pSD = NULL;
                    dwErr = GetKernelSecurityInfo(hObject,
                                                  pRightsList[0].SeInfo |
                                                   OWNER_SECURITY_INFORMATION |
                                                   GROUP_SECURITY_INFORMATION,
                                                  NULL,
                                                  NULL,
                                                  &pSD);
                }

                //
                // A NULL parent SD means this object has no parent!
                //
                if(dwErr == ERROR_SUCCESS && pParentSD != NULL)
                {
                    BOOL    fIsContainer;
                    dwErr = IsFileContainer(hObject,
                                            &fIsContainer);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        PSECURITY_DESCRIPTOR    pNewSD;
                        dwErr = ConvertToAutoInheritSD(pParentSD,
                                                       pSD,
                                                       fIsContainer,
                                                       &gFileGenMap,
                                                       &pNewSD);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            dwErr = AccessList.AddSD(pNewSD,
                                                 pRightsList[0].SeInfo,
                                                 pRightsList[0].pwszProperty);

                            DestroyPrivateObjectSecurity(&pNewSD);
                        }

                    }

                    AccFree(pParentSD);
                }
                AccFree(pwszName);

            }
        }
        else
        {
            //
            // Simply add the SD to our list
            //
            dwErr = AccessList.AddSD(pSD,
                                     pRightsList[0].SeInfo,
                                     pRightsList[0].pwszProperty);

        }

        //
        // Make sure to free the security descriptor...
        //
        AccFree(pSD);
    }

    acDebugOut((DEB_TRACE,
                "Out ReadFileRights %lu\n",
                dwErr));

    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   GetFileParentRights
//
//  Synopsis:   Determines who the parent is, and gets the access rights
//              for it.  It is used to aid in determining what the approriate
//              inheritance bits are.
//
//  Arguments:  [IN  pwszFile]          --      The file/directory to get the
//                                              parent for
//              [IN  pRightsList]       --      The properties to get the
//                                              rights for
//              [IN  cRights]           --      Number of items in rights list
//              [OUT ppDAcl]            --      Where the DACL is returned
//              [OUT ppSAcl]            --      Where the SACL is returned
//              [OUT ppSD]              --      Where the Security Descriptor
//                                              is returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
GetFileParentRights(IN  LPWSTR                      pwszFile,
                    IN  PACTRL_RIGHTS_INFO          pRightsList,
                    IN  ULONG                       cRights,
                    OUT PACL                       *ppDAcl,
                    OUT PACL                       *ppSAcl,
                    OUT PSECURITY_DESCRIPTOR       *ppSD)
{
    acDebugOut((DEB_TRACE, "in GetFileParentRights\n"));

    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fNoParent = FALSE;
    WCHAR   pwszLocalFileNameBuffer[MAX_PATH+1];
    PWSTR   pwszLocalFileName = (PWSTR) pwszLocalFileNameBuffer;
    ULONG   filesize;
    PWSTR   pwszLastComp;

    CHECK_HEAP

    if (0 == (filesize = RtlGetFullPathName_U(pwszFile, sizeof(WCHAR)*MAX_PATH, pwszLocalFileName, NULL)))
    {
        dwErr = ERROR_FILE_NOT_FOUND;
        goto FileCleanup;
    }

    if (filesize > sizeof(WCHAR)*MAX_PATH)
    {
        //
        // The buffer is too small. We have to allocate more.
        //

        if (NULL == (pwszLocalFileName = (PWSTR) AccAlloc(sizeof(WCHAR)+filesize)))
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto FileCleanup;
        }

        //
        // Try to get the full pathname again. This time the buffer is big enough to hold the full pathname.
        //

        if (0 == (RtlGetFullPathName_U(pwszFile, filesize, pwszLocalFileName, NULL)))
        {
            dwErr = ERROR_FILE_NOT_FOUND;
            goto FileCleanup;
        }
    }

    //
    // First, we have to figure out who are parent is.  For now, since there
    // are no supported properties, we'll simply open the parent object
    //
    pwszLastComp = wcsrchr(pwszLocalFileName, L'\\');
    if(pwszLastComp == NULL)
    {
        //
        // Ok, we must be at the root, so we won't have any inheritance
        //
        //
        // Return success after nulling out SD.
        //
        *ppSD = NULL;

    }
    else
    {
        //
        // We'll shorten our path, and then get the info
        //
        WCHAR   wcLast;

        // Leave the trailing \, it doesn't hurt to have them on directories.
        // Plus, we don't end up querying security on the Device (x:) instead
        // of the intended root (x:\)
        //
        // We restore

        pwszLastComp ++;

        wcLast = *pwszLastComp;

        *pwszLastComp = L'\0';

        //
        // Make sure if we were looking at the root of a share, that we don't try and go to far
        //
        if (IS_UNC_PATH(pwszLocalFileName, wcslen(pwszLocalFileName)))
        {
            //
            //
            // Have to pass "\\server" if the original string was "\\server\share"
            //

            *(pwszLastComp-1) = L'\0';

            if(wcsrchr(pwszLocalFileName+2, L'\\') == NULL)
            {
                //
                // It's impossible for us to have a parent, so return
                //
                *ppSD = NULL;
                fNoParent = TRUE;
            }

            //
            // Restore the '\'
            //
            *(pwszLastComp-1) = L'\\';
        }

        if(fNoParent == FALSE)
        {
            HANDLE  hFile;

            SECURITY_INFORMATION    SeInfo = pRightsList[0].SeInfo;

            //
            // Don't want owner or group
            //
            SeInfo &= ~(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION);
            dwErr = OpenFileObject(pwszLocalFileName,
                                   GetDesiredAccess(READ_ACCESS_RIGHTS,SeInfo),
                                   &hFile,
                                   TRUE);

            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = GetKernelSecurityInfo(hFile,
                                              SeInfo,
                                              NULL,
                                              NULL,
                                              ppSD);
                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Convert it to self relative
                    //
                    PSECURITY_DESCRIPTOR    pNewSD;
                    dwErr = MakeSDSelfRelative(*ppSD,
                                               &pNewSD,
                                               ppDAcl,
                                               ppSAcl);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        *ppSD = pNewSD;
                    }
                    else
                    {
                        AccFree(*ppSD);
                    }

                }
                NtClose(hFile);
            }

        }
        *pwszLastComp = wcLast;
    }

FileCleanup:

    if ((pwszLocalFileName != (PWSTR) pwszLocalFileNameBuffer) && (NULL != pwszLocalFileName))
    {
        AccFree(pwszLocalFileName);
    }

    acDebugOut((DEB_TRACE, "Out GetFileParentRights: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetFilePropertyRights
//
//  Synopsis:   Sets the specified security info on the specified file object
//              property
//
//  Arguments:  [IN  hFile]             --      The handle to the open object
//              [IN  SeInfo]            --      Flag indicating what security
//                                              info to set
//              [IN  pwszProperty]      --      Property to set it on
//              [IN  pSD]               --      The security desciptor to set
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad paramter was given
//
//----------------------------------------------------------------------------
DWORD
SetFilePropertyRights(IN  HANDLE                    hFile,
                      IN  SECURITY_INFORMATION      SeInfo,
                      IN  PWSTR                     pwszProperty,
                      IN  PSECURITY_DESCRIPTOR      pSD)
{
    acDebugOut((DEB_TRACE, "in SetFilePropertyRights\n"));

    DWORD dwErr = ERROR_SUCCESS;

    //
    // Filesystems don't support properties yet...
    //
    ASSERT(pwszProperty == NULL);
    if(pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Marta only writes uplevel security descriptors.
    //
    // The caller of SetFilePropertyRights will call with SE_xACL_AUTO_INHERITED off in those
    //  cases that it wants the underlying file system to do auto inheritance.
    // The caller of SetFilePropertyRights will call with SE_xACL_AUTO_INHERITED on in those
    //  cases that it wants the underlying file system to simply store the bits.
    //
    // In the later case, the OS uses the SE_xACL_AUTO_INHERIT_REQ bit as a flag indicating
    // that it is OK to preserve SE_xACL_AUTO_INHERITED bit.
    //
    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION)) {
        ((PISECURITY_DESCRIPTOR)pSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
    }

    if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION)) {
        ((PISECURITY_DESCRIPTOR)pSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
    }


    //
    // Otherwise, do the set
    //
    NTSTATUS Status = NtSetSecurityObject(hFile,
                                          SeInfo,
                                          pSD);
    dwErr = RtlNtStatusToDosError(Status);


    acDebugOut((DEB_TRACE,
               "Out SetFilePropertyRights: %ld\n",
               dwErr));
    return(dwErr);
}




#define CLEANUP_ON_INTERRUPT(pstopflag)                                     \
if(*pstopflag != 0)                                                         \
{                                                                           \
    goto FileCleanup;                                                       \
}
//+---------------------------------------------------------------------------
//
//  Function:   SetAndPropagateFilePropertyRights
//
//  Synopsis:   Sets the speecified access on the object and, if appropriate,
//              propagates the access to the apporpriate child objects
//
//  Arguments:  [IN  pwszFile]          --      The path to set and propagate
//              [IN  pwszProperty]      --      Property to set it on
//              [IN  RootAccList]       --      CAccessList that indicates
//                                              what access is to be set on
//                                              the object
//              [IN  pfStopFlag]        --      Address of the stop flag
//                                              to be monitored
//              [IN  pcProcessed]       --      Count of processed items
//              [IN  hOpenObject]       --      OPTIONAL handle to the file object
//                                              if it's already open
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad paramter was given
//
//----------------------------------------------------------------------------
DWORD
SetAndPropagateFilePropertyRights(IN  PWSTR             pwszFile,
                                  IN  PWSTR             pwszProperty,
                                  IN  CAccessList&      RootAccList,
                                  IN  PULONG            pfStopFlag,
                                  IN  PULONG            pcProcessed,
                                  IN  HANDLE            hOpenObject OPTIONAL)
{
    acDebugOut((DEB_TRACE, "in SetAndPropagateFilePropertyRights\n"));

    DWORD                   dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR    pReadSD = NULL;
    HANDLE                  hObject = NULL;
    BOOL                    fManualProp = FALSE;
    NTSTATUS                Status;
    ULONG                   cNeeded = 0;
    BOOL                    fIsCont = FALSE;
    ULONG                   fProtected = 0;
    HANDLE                  hProcessToken;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_INFORMATION    SeInfo = 0;
    PSECURITY_DESCRIPTOR    pUpdateSD = NULL;

    CSList                  FailureLogList(FreePropagationFailureListEntry);

    //
    // First, get the security descriptor
    //
    dwErr = RootAccList.BuildSDForAccessList(&pSD,
                                             &SeInfo,
                                             ACCLIST_SD_ABSOK);

    if(dwErr == ERROR_SUCCESS &&
            FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION))
    {
        //
        // Next, open it
        //
        if(hOpenObject == NULL)
        {
            dwErr = OpenFileObject(pwszFile,
                                   GetDesiredAccess(MODIFY_ACCESS_RIGHTS,
                                                    SeInfo) | FILE_READ_ATTRIBUTES | READ_CONTROL,
                                   &hObject,
                                   FALSE);
        }
        else
        {
            hObject = hOpenObject;
        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = IsFileContainer(hObject,
                                    &fIsCont);
        }

        if(dwErr != ERROR_SUCCESS || *pfStopFlag != 0)
        {
            goto FileCleanup;
        }

        //
        // Ok, first, we have to read the SD off the object.  We do this
        // so that we can determine what the potential inheritance is for
        // our children following the object getting an updated security
        // descriptor.
        //
        if(dwErr == ERROR_SUCCESS && fIsCont == TRUE)
        {
            dwErr = ReadFileSD(hObject,
                               SeInfo,
                               0,
                               &pReadSD);

        }

        //
        // Now, write the current SD out to the object.  Note that it's being
        // written out as an uplevel acl
        //
        if(dwErr == ERROR_SUCCESS)
        {
            CLEANUP_ON_INTERRUPT(pfStopFlag);
            dwErr = SetFilePropertyRights(hObject,
                                          SeInfo,
                                          pwszProperty,
                                          pSD);
            if(dwErr == ERROR_SUCCESS)
            {
                PSECURITY_DESCRIPTOR    pVerifySD;
                (*pcProcessed)++;
                CLEANUP_ON_INTERRUPT(pfStopFlag);

                //
                // Now, we have to reread the new SD, to see if we need
                // to do manual propagation
                //
                dwErr = ReadFileSD(hObject,
                                   SeInfo,
                                   RootAccList.QuerySDSize(),
                                   &pVerifySD);

                //
                // Get our process token
                //
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = GetCurrentToken(&hProcessToken);
                }

                if(dwErr == ERROR_SUCCESS)
                {

                    //
                    // Check to see if this was done uplevel...
                    //
                    PISECURITY_DESCRIPTOR pISD = (PISECURITY_DESCRIPTOR)pVerifySD;
                    if(!(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) &&
                        FLAG_ON(pISD->Control, SE_DACL_AUTO_INHERITED) &&
                        !FLAG_ON(pISD->Control, SE_DACL_PROTECTED)) &&
                       !(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) &&
                        FLAG_ON(pISD->Control, SE_SACL_AUTO_INHERITED &&
                        !FLAG_ON(pISD->Control, SE_SACL_PROTECTED))))
                    {
                        //
                        // It's not uplevel, so we'll turn the AutoInherit
                        // flags on, rewrite it, and do our own propagation,
                        // only if this is a container and we're setting the
                        // dacl or sacl
                        //
                        if(FLAG_ON(SeInfo,
                                   (DACL_SECURITY_INFORMATION |
                                                SACL_SECURITY_INFORMATION)) &&
                                   fIsCont == TRUE)
                        {
                            fManualProp = TRUE;
                        }


                        //
                        // Upgrade it...
                        //
                        dwErr = UpdateFileSDByPath(pSD,
                                                   pwszFile,
                                                   hObject,
                                                   hProcessToken,
                                                   SeInfo,
                                                   fIsCont,
                                                   &pUpdateSD);


                        //
                        // Now, if we're going to do manual propagation,
                        // we'll write out the old SD until we get everyone
                        // else updated
                        //
                        PSECURITY_DESCRIPTOR    pWriteSD = pUpdateSD;
                        if(fManualProp == TRUE)
                        {
                            pWriteSD = pReadSD;
                        }

                        //
                        // Reset it...
                        //
                        if(dwErr == ERROR_SUCCESS)
                        {
                            dwErr = SetFilePropertyRights(hObject,
                                                          SeInfo,
                                                          pwszProperty,
                                                          pWriteSD);
                        }
                    }

                    AccFree(pVerifySD);
                }

                CLEANUP_ON_INTERRUPT(pfStopFlag);

            }
        }


        //
        // Ok, now we'll do the right thing
        //
        if(dwErr == ERROR_SUCCESS && fManualProp == TRUE)
        {
            //
            // We'll have to do our own propagation...
            //
            PSECURITY_DESCRIPTOR    pUpdateParentSD = NULL;
            if(!FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION)  ||
               !FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
            {
                dwErr = GetKernelSecurityInfo(hObject,
                                      SeInfo |
                                        OWNER_SECURITY_INFORMATION |
                                        GROUP_SECURITY_INFORMATION,
                                      NULL,
                                      NULL,
                                      &pUpdateParentSD);
            }

            //
            // Ok, go ahead and do deep.  This will possibly save us
            // some storage space in the long run...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Set our protected flags.  If we aren't messing with a particular acl, we'll
                // pretend it's protected
                //

                fProtected = ((SECURITY_DESCRIPTOR *)pUpdateSD)->Control &
                                                        ~(SE_DACL_PROTECTED | SE_SACL_PROTECTED);
                if(!FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                {
                    fProtected |= SE_DACL_PROTECTED;
                }

                if(!FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                {
                    fProtected |= SE_SACL_PROTECTED;
                }

                dwErr = PropagateFileRightsDeep(pUpdateSD,
                                                pUpdateParentSD,
                                                SeInfo,
                                                pwszFile,
                                                pwszProperty,
                                                pcProcessed,
                                                pfStopFlag,
                                                fProtected,
                                                hProcessToken,
                                                FailureLogList);
            }

            //
            // If that worked, write out our updated root security descriptor
            //
            if(dwErr == ERROR_SUCCESS)
            {

                dwErr = SetFilePropertyRights(hObject,
                                              SeInfo,
                                              pwszProperty,
                                              pUpdateSD );
            }

            AccFree(pUpdateParentSD);
        }

        if(pUpdateSD != NULL)
        {
            DestroyPrivateObjectSecurity(&pUpdateSD);
        }
    }
    else
    {
        if(dwErr == ERROR_SUCCESS &&
           FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION))
        {
            if(hOpenObject == NULL)
            {
                dwErr = OpenFileObject(pwszFile,
                                       GetDesiredAccess(WRITE_ACCESS_RIGHTS,
                                                        SeInfo),
                                       &hObject,
                                       FALSE);

            }
            else
            {
                hObject = hOpenObject;
            }
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = SetFilePropertyRights(hObject,
                                              SeInfo,
                                              pwszProperty,
                                              pSD);
            }

        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = WritePropagationFailureList(MARTAEVT_DIRECTORY_PROPAGATION_FAILED,
                                            FailureLogList,
                                            hProcessToken);
        //
        // Temporary hack. The failure list should be written to the eventlog rather
        // than to a registry key.
        //
        // Remember to change this in future.
        // KedarD
        //

        dwErr = ERROR_SUCCESS;
    }

FileCleanup:
    if(hObject != hOpenObject)
    {
        NtClose(hObject);
    }

    AccFree(pReadSD);

    acDebugOut((DEB_TRACE,
               "Out SetAndPropagateFilePropertyRights: %ld\n",
               dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetAndPropagateFilePropertyRightsByHandle
//
//  Synopsis:   Same as above, but deals with a handle to the open object
//              as opposed to a file name.
//
//  Arguments:  [IN  hObject]           --      File handle
//              [IN  pwszProperty]      --      Property to set it on
//              [IN  RootAccList]       --      CAccessList that indicates
//                                              what access is to be set on
//                                              the object
//              [IN  pfStopFlag]        --      Address of the stop flag
//                                              to be monitored
//              [IN  pcProcessed]       --      Count of processed items
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad paramter was given
//
//----------------------------------------------------------------------------
DWORD
SetAndPropagateFilePropertyRightsByHandle(IN  HANDLE        hObject,
                                          IN  PWSTR         pwszProperty,
                                          IN  CAccessList&  RootAccList,
                                          IN  PULONG        pfStopFlag,
                                          IN  PULONG        pcProcessed)
{
    acDebugOut((DEB_TRACE, "in SetAndPropagateFilePropertyRightsByHandle\n"));



    CHECK_HEAP


    //
    // We'll do this the easy way... convert it to a path, and call on up
    //
    PWSTR   pwszPath = NULL;

    DWORD   dwErr = ConvertFileHandleToName(hObject,
                                            &pwszPath);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = SetAndPropagateFilePropertyRights(pwszPath,
                                                  pwszProperty,
                                                  RootAccList,
                                                  pfStopFlag,
                                                  pcProcessed,
                                                  hObject);
        AccFree(pwszPath);
    }


    acDebugOut((DEB_TRACE,
               "Out SetAndPropagateFilePropertyRightsByHandle: %ld\n",
               dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetLMDfsPaths
//
//  Synopsis:   Given a DFS path, this function will return a list of the
//              LANMAN shares supporting this path.  If any non-LM paths are
//              found, they are ignored.
//
//  Arguments:  [IN  pwszPath]          --      Path to check
//              [OUT pcItems]           --      Where the count of the
//                                              number of items in the list
//                                              is returned
//              [OUT pppwszLocalList]   --      OPTIONAL.  If present, the
//                                              list of LM paths is returned
//                                              here.
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
GetLMDfsPaths(IN  PWSTR     pwszPath,
              OUT PULONG    pcItems,
              OUT PWSTR   **pppwszLocalList OPTIONAL)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CHECK_HEAP


    PDFS_INFO_3 pDI3;

    dwErr = LoadDLLFuncTable();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    dwErr = (*DLLFuncs.PNetDfsGetInfo)(pwszPath,
                                       NULL,
                                       NULL,
                                       3,
                                       (PBYTE *)&pDI3);
    //
    // Now, build the list of information to return.
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Go through and size our list
        //
        *pcItems = 0;
        DWORD   dwSize = sizeof(PWSTR) * pDI3->NumberOfStorages;

        for(ULONG iIndex = 0; iIndex < pDI3->NumberOfStorages; iIndex++)
        {
            WCHAR   wszUNCPath[MAX_PATH + 1];
            swprintf(wszUNCPath,
                     L"\\\\%ws\\%ws",
                     pDI3->Storage[iIndex].ServerName,
                     pDI3->Storage[iIndex].ShareName);

            dwErr = IsFilePathLocalOrLM(wszUNCPath);

            if(dwErr != ERROR_SUCCESS)
            {
                if(dwErr == ERROR_PATH_NOT_FOUND)
                {
                    dwErr = ERROR_SUCCESS;
                    continue;
                }
                else
                {
                    break;
                }
            }
            (*pcItems)++;
            if(pppwszLocalList != NULL)
            {
                //
                // Set a flag in the information so we can look up the
                // valid names quicker below, when we copy them
                //
                pDI3->Storage[iIndex].State = 0xFFFFFFFF;
                dwSize += SIZE_PWSTR(pDI3->Storage[iIndex].ServerName);
                dwSize += SIZE_PWSTR(pDI3->Storage[iIndex].ShareName);
                dwSize += 2 * sizeof(WCHAR);    // Room for leading \\'s.  The
                                                // NULL of the server name
                                                // gives the seperator
            }
        }

        if(dwErr == ERROR_SUCCESS && pppwszLocalList != NULL)
        {
            //
            // Now, allocate, and we'll fill
            //
            *pppwszLocalList = (PWSTR *)AccAlloc(dwSize);
            if(*pppwszLocalList == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                PWSTR   pwszStrStart = (PWSTR)(*pppwszLocalList +
                                    (sizeof(PWSTR) * pDI3->NumberOfStorages));

                for(iIndex = 0; iIndex < pDI3->NumberOfStorages; iIndex++)
                {
                    if(pDI3->Storage[iIndex].State == 0xFFFFFFFF)
                    {
                        (*pppwszLocalList)[iIndex] = pwszStrStart;
                        swprintf(pwszStrStart,
                                 L"\\\\%ws\\%ws",
                                 pDI3->Storage[iIndex].ServerName,
                                 pDI3->Storage[iIndex].ShareName);

                        pwszStrStart += wcslen(pwszStrStart) + 1;
                    }

                }
            }
        }

        //
        // Make sure to free our buffer
        //
        (*DLLFuncs.PNetApiBufferFree)(pDI3);


    }
    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   PropagateFileRightsDeep, recursive
//
//  Synopsis:   Does a deep propagation of the access.  At the same time, it
//              will update NT4 acls to NT5 acls.  This function is only
//              called on downlevel file systems, so the update will always
//              happen (where appropriate).  The algorithm is:
//                  - Read the current security descriptor from the object
//                  - If it's a downlevel acl, update it using the OLD
//                    parent security descriptor (to set any inheritied aces)
//                  - Update the security descriptor using the NEW parent
//                    security descriptor.
//                  - Repeat for its children.  (This is necessar, since there
//                    could have been unmarked inheritance off of the old
//                    security descriptor)
//
//  Arguments:  [IN  pParentSD]         --      The current parent sd
//              [IN  pOldParentSD]      --      The previous parent SD (before
//                                              the current parent SD was
//                                              stamped on the object)
//              [IN  SeInfo]            --      What is being written
//              [IN  pwszFile]          --      Parent file path
//              [IN  pwszProperty]      --      What property is being
//                                              written
//              [IN  pcProcessed]       --      Where the number processed is
//                                              returned.
//              [IN  pfStopFlag]        --      Stop flag to monitor
//              [IN  fProtectedFlag]    --      Indicates whether acls are protected or not
//              [IN  hToken]            --      Handle to the process token
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
#define ALL_STR L"\\*.*"
DWORD
PropagateFileRightsDeep(IN  PSECURITY_DESCRIPTOR    pParentSD,
                        IN  PSECURITY_DESCRIPTOR    pOldParentSD,
                        IN  SECURITY_INFORMATION    SeInfo,
                        IN  PWSTR                   pwszFile,
                        IN  PWSTR                   pwszProperty,
                        IN  PULONG                  pcProcessed,
                        IN  PULONG                  pfStopFlag,
                        IN  ULONG                   fProtectedFlag,
                        IN  HANDLE                  hToken,
                        IN OUT CSList&              LogList)
{
    acDebugOut((DEB_TRACE, "in PropagateFileRightsDeep\n"));
    DWORD       dwErr = ERROR_SUCCESS;

    WIN32_FIND_DATA         FindData;
    HANDLE                  hFind = NULL;
    HANDLE                  hChild = NULL;
    ULONG                   cRootLen = SIZE_PWSTR(pwszFile), Protected = 0;
    SECURITY_DESCRIPTOR    *pChildSD = NULL;
    PSECURITY_DESCRIPTOR    pNewSD = NULL;
    PWSTR                   pwszFull = NULL;
    BOOL                    fUpdateChild = FALSE;   // Write out the child?
    BOOL                    fAccFreeChild = TRUE;   // How to free the child
    BOOL                    fNoPropagate = FALSE;
    BOOL                    fLoggedFailure = FALSE;

    acDebugOut((DEB_TRACE_PROP, " Path: %ws\n", pwszFile));
    acDebugOut((DEB_TRACE_PROP, "   ParentSD: 0x%lx, OldParentSD: 0x%lx\n",
               pParentSD, pOldParentSD));

    //
    // If the any part of the node is going be ingnored because of protection, log it
    //
    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) && FLAG_ON(fProtectedFlag, SE_DACL_PROTECTED))
    {
        Protected |= SE_DACL_PROTECTED;
    }

    if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) && FLAG_ON(fProtectedFlag, SE_SACL_PROTECTED))
    {
        Protected |= SE_SACL_PROTECTED;
    }


    if( Protected != 0)
    {
        dwErr = InsertPropagationFailureEntry(LogList,
                                              0,
                                              Protected,
                                              pwszFile);
        if(dwErr != ERROR_SUCCESS)
        {
            return(dwErr);
        }

    }

    //
    // Check to see if we've reached full protection saturation
    //
    if(fProtectedFlag == (SE_DACL_PROTECTED | SE_SACL_PROTECTED))
    {
        acDebugOut((DEB_TRACE_PROP, "Parent of %ws is fully or effectively protected\n",
                    pwszFile));
        return(ERROR_SUCCESS);
    }


    //
    // Build the full path name
    //
    PWSTR   pwszFindRoot = (PWSTR)AccAlloc(cRootLen + sizeof(ALL_STR));
    if(pwszFindRoot == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        swprintf(pwszFindRoot,
                 L"%ws%ws",
                 pwszFile,
                 ALL_STR);

        hFind = FindFirstFile(pwszFindRoot,
                              &FindData);
        if(hFind == INVALID_HANDLE_VALUE)
        {
            dwErr = InsertPropagationFailureEntry(LogList,
                                                  GetLastError(),
                                                  0,
                                                  pwszFile);
            fNoPropagate = TRUE;
        }

    }

    //
    // Start processing all the files
    //
    while(dwErr == ERROR_SUCCESS && fNoPropagate == FALSE)
    {
        //
        // Ignore the . and ..
        //
        if(_wcsicmp(FindData.cFileName, L".") != 0 &&
           wcscmp(FindData.cFileName, L"..") != 0)
        {
            //
            // Now, build the full path...
            //
            pwszFull = (PWSTR)AccAlloc(cRootLen + SIZE_PWSTR(FindData.cFileName));
            if(pwszFull == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            wcscpy(pwszFull,
                   pwszFile);
            if(pwszFull[(cRootLen / sizeof(WCHAR)) - 2] != L'\\')
            {
                wcscat(pwszFull,
                       L"\\");
            }
            wcscat(pwszFull,
                   FindData.cFileName);

            acDebugOut((DEB_TRACE_PROP,
                        "Processing %ws\n",
                        pwszFull));

            //
            // Open the object
            //
            if(hChild != NULL)
            {
                NtClose(hChild);
                hChild = NULL;
            }

            dwErr = OpenFileObject(pwszFull,
                                   GetDesiredAccess(MODIFY_ACCESS_RIGHTS,
                                                    SeInfo) | FILE_READ_ATTRIBUTES | READ_CONTROL,
                                   &hChild,
                                   FALSE);

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Ok, is it a file or directory
                //
                BOOL    fIsCont;
                dwErr = IsFileContainer(hChild,
                                        &fIsCont);
                //
                // First, we have to read the current security descriptor
                // on the object
                //
                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Get the owner and the group if we have to
                    //
                    if(pChildSD == NULL ||
                       !FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION)  ||
                       !FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                    {
                        AccFree(pChildSD);
                        pChildSD = NULL;
                        dwErr = ReadFileSD(hChild,
                                           SeInfo                           |
                                                OWNER_SECURITY_INFORMATION  |
                                                GROUP_SECURITY_INFORMATION,
                                           0,
                                           (PSECURITY_DESCRIPTOR *)&pChildSD);
                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        //
                        // If we don't have an uplevel SecurityDescriptor,
                        // we'll need to update it with our old parent sd
                        //
                        if(!FLAG_ON(pChildSD->Control,
                                   SE_DACL_AUTO_INHERITED |
                                                     SE_SACL_AUTO_INHERITED))
                        {
                            dwErr = ConvertToAutoInheritSD(pOldParentSD,
                                                           pChildSD,
                                                           fIsCont,
                                                           &gFileGenMap,
                                                           &pNewSD);
                            if(dwErr == ERROR_SUCCESS)
                            {
                                if(fAccFreeChild == TRUE)
                                {
                                    AccFree(pChildSD);
                                }
                                else
                                {
                                    DestroyPrivateObjectSecurity((PSECURITY_DESCRIPTOR *)&pChildSD);
                                }
                                pChildSD = (SECURITY_DESCRIPTOR *)pNewSD;
                                fAccFreeChild = FALSE;
                                pNewSD = NULL;
                            }
                        }
                    }

                    //
                    // Now, compute the new security descriptor
                    //
                    if(dwErr == ERROR_SUCCESS)
                    {
                        DebugDumpSD("CPOS ParentSD", pParentSD);
                        DebugDumpSD("CPOS ChildSD",  pChildSD);

                        if(CreatePrivateObjectSecurityEx(
                                            pParentSD,
                                            pChildSD,
                                            &pNewSD,
                                            NULL,
                                            fIsCont,
                                            SEF_DACL_AUTO_INHERIT          |
                                                SEF_SACL_AUTO_INHERIT      |
                                                SEF_AVOID_OWNER_CHECK      |
                                                SEF_AVOID_PRIVILEGE_CHECK,
                                            hToken,
                                            &gFileGenMap) == FALSE)
                        {
                            dwErr = GetLastError();
                        }

#ifdef DBG
                        if(dwErr == ERROR_SUCCESS)
                        {
                            DebugDumpSD("CPOS NewChild", pNewSD);
                        }
#endif
                        if(dwErr == ERROR_SUCCESS)
                        {
                            //
                            // If the resultant child is protected, don't bother propagating
                            // down.
                            //
                            if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                            {
                                if(DACL_PROTECTED(pNewSD))
                                {
                                    fProtectedFlag |= SE_DACL_PROTECTED;
                                }
                            }

                            if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                            {
                                if(SACL_PROTECTED(pNewSD))
                                {
                                    fProtectedFlag |= SE_SACL_PROTECTED;
                                }
                            }

                            if(fProtectedFlag == (SE_DACL_PROTECTED | SE_SACL_PROTECTED))
                            {
                                fIsCont = FALSE;
                            }

                            //
                            // If we haven't changed the acl, security descriptor, then
                            // we can also quit
                            //
                            if(EqualSecurityDescriptors(pNewSD, pChildSD))
                            {
                                fIsCont = FALSE;
                            }
                        }
                    }

                    //
                    // Now, if it's a directory, call ourselves
                    //
                    if(dwErr == ERROR_SUCCESS && fIsCont == TRUE)
                    {
                        dwErr = PropagateFileRightsDeep(pNewSD,
                                                        pChildSD,
                                                        SeInfo,
                                                        pwszFull,
                                                        pwszProperty,
                                                        pcProcessed,
                                                        pfStopFlag,
                                                        fProtectedFlag,
                                                        hToken,
                                                        LogList);
                    }

                    //
                    // Free the old child, since we won't need it anymore
                    //
                    if(fAccFreeChild == TRUE)
                    {
                        AccFree(pChildSD);
                    }
                    else
                    {
                        DestroyPrivateObjectSecurity((PSECURITY_DESCRIPTOR *)
                                                                   &pChildSD);
                    }
                    pChildSD = NULL;

                }
            }
            else
            {
                dwErr = InsertPropagationFailureEntry(LogList,
                                                      dwErr,
                                                      0,
                                                      pwszFull);
                fLoggedFailure = TRUE;

            }

            acDebugOut((DEB_TRACE_PROP,
                        "Processed %ws: %lu\n",
                        pwszFull,
                        dwErr));

            //
            // Finally, set the new security
            //
            if(dwErr == ERROR_SUCCESS && fLoggedFailure == FALSE)
            {
                //
                // Now, we'll simply stamp it on the object
                //

                dwErr = SetFilePropertyRights(hChild,
                                              SeInfo,
                                              pwszProperty,
                                              pNewSD);
                (*pcProcessed)++;

            }


            DestroyPrivateObjectSecurity(&pNewSD);
            pNewSD = NULL;
            AccFree(pwszFull);
            pwszFull = NULL;
            fLoggedFailure = FALSE;
        }

        CLEANUP_ON_INTERRUPT(pfStopFlag);

        if(dwErr != ERROR_SUCCESS)
        {
            break;
        }

        if(FindNextFile(hFind,
                        &FindData) == FALSE)
        {
            dwErr = GetLastError();
        }
    }

    if(dwErr == ERROR_NO_MORE_FILES)
    {
        dwErr = ERROR_SUCCESS;
    }



FileCleanup:
    if(hChild != NULL)
    {
        NtClose(hChild);
    }

    if(hFind != NULL)
    {
        FindClose(hFind);
    }

    AccFree(pwszFull);
    AccFree(pwszFindRoot);
    if(pNewSD != NULL)
    {
        DestroyPrivateObjectSecurity(&pNewSD);
    }

    acDebugOut((DEB_TRACE, "Out PropagateFileRightsDeep: %ld\n", dwErr));
    return(dwErr);

}




//+---------------------------------------------------------------------------
//
//  Function:   MakeSDSelfRelative
//
//  Synopsis:   Makes the indicated security descriptor self relative,
//              if it isn't already.
//
//  Arguments:  [IN  pOldSD]            --      The security descriptor to
//                                              convert
//              [OUT ppNewSD]           --      Where the new SD is returned
//              [OUT ppDAcl]            --      If non-NULL, the DACL pointer
//                                              is returned here
//              [OUT ppSAcl]            --      If non-NULL, the SACL pointer
//                                              is returned here
//              [IN  fFreeOldSD]        --      If true, AccFree is called
//                                              on the old SD.
//              [IN  fRtlAlloc]         --      If true, use the RtlAllocation
//                                              routines instead of AccAlloc
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
MakeSDSelfRelative(IN  PSECURITY_DESCRIPTOR     pOldSD,
                   OUT PSECURITY_DESCRIPTOR    *ppNewSD,
                   OUT PACL                    *ppDAcl,
                   OUT PACL                    *ppSAcl,
                   IN  BOOL                     fFreeOldSD,
                   IN  BOOL                     fRtlAlloc)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CHECK_HEAP


    if(pOldSD == NULL)
    {
        *ppNewSD = NULL;
        return(dwErr);
    }

    //
    // If it's already self relative and we don't need it to be allocated via
    // RtlAllocateHead, simply return what we have
    //
    if(FLAG_ON(((SECURITY_DESCRIPTOR *)pOldSD)->Control,
                    SE_SELF_RELATIVE) && fRtlAlloc == FALSE)
    {
        *ppNewSD = pOldSD;
    }
    else
    {
        DWORD   dwSize = RtlLengthSecurityDescriptor(pOldSD);

        if(fRtlAlloc == FALSE)
        {
            *ppNewSD = (PSECURITY_DESCRIPTOR)AccAlloc(dwSize);
        }
        else
        {
            *ppNewSD = (PSECURITY_DESCRIPTOR)RtlAllocateHeap(RtlProcessHeap(),
                                                             0, dwSize);
        }

        if(*ppNewSD == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            if(FLAG_ON(((SECURITY_DESCRIPTOR *)pOldSD)->Control, SE_SELF_RELATIVE))
            {
                RtlCopyMemory(*ppNewSD, pOldSD, dwSize);
            }
            else
            {
                if(MakeSelfRelativeSD(pOldSD,
                                      *ppNewSD,
                                      &dwSize) == FALSE)
                {
                    dwErr = GetLastError();
                    if(fRtlAlloc == FALSE)
                    {
                        AccFree(*ppNewSD);
                        *ppNewSD = NULL;
                    }
                    else
                    {
                        RtlFreeHeap(RtlProcessHeap(), 0, *ppNewSD);
                    }
                }
            }
        }

    }

    if(dwErr == ERROR_SUCCESS)
    {
        if(ppDAcl != NULL)
        {
            *ppDAcl =
              RtlpDaclAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)*ppNewSD);
        }

        if(ppSAcl != NULL)
        {
            *ppSAcl =
               RtlpSaclAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)*ppNewSD);
        }

        //
        // Don't release it if we're returning it...
        //
        if(fFreeOldSD == TRUE && *ppNewSD != pOldSD)
        {
            AccFree(pOldSD);
        }
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   UpdateFileSDByPath
//
//  Synopsis:   Determines the inheritance necessary for the current security
//              descriptor given the path to the object
//
//  Arguments:  [IN  pCurrentSD]        --      The security descriptor to
//                                              update
//              [IN  pwszPath]          --      The path to th object
//              [IN  hFile]             --      Handle to the open file
//              [IN  SeInfo]            --      The security information of
//                                              the current SD.
//              [IN  fIsContainer]      --      Does the Sec. Desc. refer to
//                                              a container?
//              [OUT ppNewSD]           --      Where the new SD is returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//  Notes:      The returned security descriptor must be freed via a call to
//              DestroyPrivateObjectSecurity
//
//----------------------------------------------------------------------------
DWORD
UpdateFileSDByPath(IN  PSECURITY_DESCRIPTOR     pCurrentSD,
                   IN  PWSTR                    pwszPath,
                   IN  HANDLE                   hFile,
                   IN  HANDLE                   hProcessToken,
                   IN  SECURITY_INFORMATION     SeInfo,
                   IN  BOOL                     fIsContainer,
                   OUT PSECURITY_DESCRIPTOR    *ppNewSD)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CHECK_HEAP


    acDebugOut((DEB_TRACE, "In UpdateFileSDByPath\n"));

    PSECURITY_DESCRIPTOR    pSD = pCurrentSD;
    PSECURITY_DESCRIPTOR    pParentSD = NULL;

    if(!FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION)  ||
       !FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
    {
        //
        // We'll have to reopen by path to get this to work properly, since we're
        // now reading the owner/group
        //
        HANDLE  hLocalFile;
        dwErr = OpenFileObject(pwszPath,
                               GetDesiredAccess(READ_ACCESS_RIGHTS,
                                                SeInfo                          |
                                                    OWNER_SECURITY_INFORMATION  |
                                                    GROUP_SECURITY_INFORMATION) |
                                                         FILE_READ_ATTRIBUTES,
                               &hLocalFile,
                               FALSE);

        //
        // If we get back an access denied from the open request, try it with the
        // handle we were given on input
        //
        if(dwErr == ERROR_ACCESS_DENIED)
        {
            hLocalFile = hFile;
            dwErr = ERROR_SUCCESS;
        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = GetKernelSecurityInfo(hLocalFile,
                                          SeInfo |
                                            OWNER_SECURITY_INFORMATION |
                                            GROUP_SECURITY_INFORMATION,
                                          NULL,
                                          NULL,
                                          &pSD);
            if(hLocalFile != hFile)
            {
                NtClose(hLocalFile);
            }
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Get the parent security descriptor
        //
        ACTRL_RIGHTS_INFO  RightsInfo;
        RightsInfo.SeInfo = SeInfo;
        RightsInfo.pwszProperty = 0;
        dwErr = GetFileParentRights(pwszPath,
                                    &RightsInfo,
                                    1,
                                    NULL,
                                    NULL,
                                    &pParentSD);
    }

    //
    // Finally, do the update
    //
    if(dwErr == ERROR_SUCCESS)
    {
        acDebugOut((DEB_TRACE_PROP,"Update being called:  Parent info: 0x%lx\n",
                    pParentSD));
        acDebugOut((DEB_TRACE_PROP,"Child: path %ws, 0x%lx\n",
                    pwszPath, pSD));


        if(CreatePrivateObjectSecurityEx(pParentSD,
                                         pSD,
                                         ppNewSD,
                                         NULL,
                                         fIsContainer,
                                         SEF_DACL_AUTO_INHERIT      |
                                             SEF_SACL_AUTO_INHERIT  |
                                             SEF_AVOID_OWNER_CHECK  |
                                             SEF_AVOID_PRIVILEGE_CHECK,
                                         hProcessToken,
                                         &gFileGenMap) == FALSE)
        {
            dwErr = GetLastError();
        }

        AccFree(pParentSD);
    }

    //
    // See if we had to read a new security descriptor for the object.  If so,
    // we'll need to release that memory as well
    //
    if(pSD != pCurrentSD)
    {
        AccFree(pSD);
    }

    acDebugOut((DEB_TRACE, "Out UpdateFileSDByPath: %ld\n", dwErr));

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\geefa.cxx ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  Microsoft Windows                                                         //
//  Copyright (C) Microsoft Corporation, 1999.                                //
//                                                                            //
//  File:    geefa.cxx                                                        //
//                                                                            //
//  Contents:    New marta rewrite functions for GetExplicitEntriesFromAcl    //
//                                                                            //
//  History:    4/99    KedarD     Created                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <aclpch.hxx>
#pragma hdrstop

extern "C"
{
    #include <stdio.h>
    #include <permit.h>
    #include <dsgetdc.h>
    #include <lmapibuf.h>
    #include <wmistr.h>
    #include <ntprov.hxx>
    #include <strings.h>
    #include <seopaque.h>
    #include <sertlp.h>
    #include <accctrl.h>
    #include <aclapi.h>
    #include <global.h>
}

#define MARTA_ALIGNED_SID_LENGTH(p) ((PtrAlignSize(RtlLengthSid((p)))))

DWORD
MartaGetAceToEntrySize(
    IN  PACE_HEADER pAce,
    OUT PULONG      pLen,
    OUT PULONG      pCount
    );

DWORD
MartaFillExplicitEntries(
    IN PACL   pacl,
    IN PUCHAR Buffer,
    IN ULONG  AccessCnt
    );

DWORD
AccRewriteGetExplicitEntriesFromAcl(
    IN  PACL                 pacl,
    OUT PULONG               pcCountOfExplicitEntries,
    OUT PEXPLICIT_ACCESS_W * pListOfExplicitEntries
    );

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: AccRewriteGetExplicitEntriesFromAcl                              //
//                                                                            //
// Description: Extract the explicit entries from an acl.                     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN pacl]                        Acl to be converted                   //
//     [OUT pcCountOfExplicitEntries]  To return the number of entries found  //
//     [OUT pListOfExplicitEntries]    To return the list of entries found    //
//                                                                            //
// Returns: ERROR_SUCCESS if the Acl could be converted to expcilt entries    //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
AccRewriteGetExplicitEntriesFromAcl(
    IN  PACL                 pacl,
    OUT PULONG               pcCountOfExplicitEntries,
    OUT PEXPLICIT_ACCESS_W * pListOfExplicitEntries)
{
    DWORD       dwErr     = ERROR_SUCCESS;
    ULONG       AccessCnt = 0;
    ULONG       Size      = 0;
    USHORT      AceCnt    = 0;
    ULONG       Count     = 0;
    ULONG       j         = 0;
    ULONG       Len       = 0;
    PUCHAR      Buffer    = NULL;
    PACE_HEADER pAce      = NULL;

    if ((NULL == pcCountOfExplicitEntries) || (NULL == pListOfExplicitEntries))
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pcCountOfExplicitEntries = 0;
    *pListOfExplicitEntries   = NULL;

    if ((NULL == pacl) || (0 == pacl->AceCount))
    {
        return ERROR_SUCCESS;
    }

    if (!RtlValidAcl(pacl))
    {
        return ERROR_INVALID_PARAMETER;
    }

    AceCnt = pacl->AceCount;

    pAce = (PACE_HEADER) FirstAce(pacl);

    for (j = 0; j < AceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            continue;
        }

        dwErr = MartaGetAceToEntrySize(pAce, &Len, &Count);

        CONDITIONAL_EXIT(dwErr, End);

        AccessCnt += Count;
        Size += Count * (Len + sizeof(EXPLICIT_ACCESS_W));
    }

    if (0 == Size)
    {
        goto End;
    }

    Buffer = (PUCHAR) AccAlloc(Size);

    if (NULL == Buffer)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto End;
    }

    dwErr = MartaFillExplicitEntries(pacl, Buffer, AccessCnt);

    if (ERROR_SUCCESS != dwErr)
    {
        goto End;
    }

    *pcCountOfExplicitEntries = AccessCnt;
    *pListOfExplicitEntries   = (PEXPLICIT_ACCESS_W) Buffer;

End:
    if (ERROR_SUCCESS != dwErr)
    {
        if (NULL != Buffer)
        {
            AccFree(Buffer);
        }
    }
    return dwErr;

}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetAceToEntrySize                                           //
//                                                                            //
// Description: Compute:                                                      //
//                Size needed to convert a given ace into explicit entry      //
//                Number of explicit entries for this ace                     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN pAce]       Ace to be converted to an explicit entry               //
//     [OUT pLen]      To return the length of the entry                      //
//     [OUT pCount]    To return the number of explict entries for this ace   //
//                                                                            //
// Returns: ERROR_SUCCESS if the ace could be converted to an expcilt entry   //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaGetAceToEntrySize(
    IN  PACE_HEADER pAce,
    OUT PULONG      pLen,
    OUT PULONG      pCount
    )
{
    switch (pAce->AceType)
    {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        *pLen = MARTA_ALIGNED_SID_LENGTH((PSID) &((PKNOWN_ACE) pAce)->SidStart);
        break;
    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        *pLen = MARTA_ALIGNED_SID_LENGTH(RtlCompoundAceServerSid(pAce));
        *pLen += sizeof(TRUSTEE_W) + MARTA_ALIGNED_SID_LENGTH(RtlCompoundAceClientSid(pAce)); 
        break;
    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        *pLen = MARTA_ALIGNED_SID_LENGTH(RtlObjectAceSid(pAce)) + sizeof(OBJECTS_AND_SID);
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    switch (pAce->AceType)
    {
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        *pCount = 0;
        if (FLAG_ON(pAce->AceFlags, SUCCESSFUL_ACCESS_ACE_FLAG))
        {
            *pCount += 1;
        }
        if (FLAG_ON(pAce->AceFlags, FAILED_ACCESS_ACE_FLAG))
        {
            *pCount += 1;
        }

        if (0 == *pCount)
        {
            return ERROR_INVALID_PARAMETER;
        }
        break;
    default:
        *pCount = 1;
        break;
    }

    return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaFillExplicitEntries                                         //
//                                                                            //
// Description: Convert an ace into explicit entry stucture(s)                //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN pacl]        Acl to be converted                                   //
//     [IN Buffer]      Buffer to be filled with explicit entries             //
//     [IN AccessCnt]   Number of explicitentries created                     //
//                                                                            //
// Returns: ERROR_SUCCESS if the acl could be converted to expcilt entries    //
//          Appropriate failure otherwise                                     //
//                                                                            //
// Note: Since Audit aces might be converted into one/two entries we need a   //
//       flag to maintain whethe the given ace was already seen in the last   //
//       pass.                                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaFillExplicitEntries(
    IN PACL   pacl,
    IN PUCHAR Buffer,
    IN ULONG  AccessCnt
    )
{
    DWORD            dwErr         = ERROR_SUCCESS;
    ULONG            AceCnt        = pacl->AceCount;
    PUCHAR           CurrentBuffer = Buffer + sizeof(EXPLICIT_ACCESS_W) * AccessCnt;
    ACCESS_MASK      Mask          = 0;
    ULONG            j             = 0;
    ULONG            i             = 0;
    ULONG            Length        = 0;
    PACE_HEADER      pAce          = NULL;
    PSID             pSid          = NULL;
    POBJECTS_AND_SID pObjSid       = NULL;
    BOOL             bFlag         = FALSE;

    PEXPLICIT_ACCESS_W pExplicit = (PEXPLICIT_ACCESS_W) Buffer;

    pAce = (PACE_HEADER) FirstAce(pacl);

    for (i = j = 0; i < AceCnt; )
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            i++;
            pAce = (PACE_HEADER) NextAce(pAce);

            continue;
        }

        switch (pAce->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:

            Mask   = ((PKNOWN_ACE) pAce)->Mask;
            pSid   = (PSID) &((PKNOWN_ACE) pAce)->SidStart;
            Length = RtlLengthSid(pSid);

            memcpy(CurrentBuffer, pSid, Length);

            BuildTrusteeWithSidW(
                &(pExplicit[j].Trustee),
                (PSID) CurrentBuffer
                );

            CurrentBuffer += PtrAlignSize(Length);
            break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

            Mask   = ((PKNOWN_COMPOUND_ACE) pAce)->Mask;
            pSid   = (PSID) &((PKNOWN_ACE) pAce)->SidStart;
            Length = RtlLengthSid(pSid);

            memcpy(CurrentBuffer, pSid, Length);

            BuildTrusteeWithSidW(
                &(pExplicit[j].Trustee),
                (PSID) CurrentBuffer
                );

            CurrentBuffer += PtrAlignSize(Length);
            pSid           = (PSID) (((PUCHAR) &(((PKNOWN_ACE) pAce)->SidStart)) + PtrAlignSize(Length));
            Length         = RtlLengthSid(pSid);

            memcpy(CurrentBuffer, pSid, Length);

            pSid           = (PSID) CurrentBuffer;
            CurrentBuffer += PtrAlignSize(Length);

            BuildTrusteeWithSidW(
                (PTRUSTEE_W) CurrentBuffer,
                pSid
                );

            BuildImpersonateTrusteeW(
                &(pExplicit[j].Trustee),
                (PTRUSTEE_W) CurrentBuffer
                );

            CurrentBuffer += sizeof(TRUSTEE_W);
            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:

            Mask   = ((PKNOWN_OBJECT_ACE) pAce)->Mask;
            pSid   = RtlObjectAceSid(pAce);
            Length = RtlLengthSid(pSid);

            memcpy((PUCHAR) CurrentBuffer, (PUCHAR) pSid, Length);

            pSid           = (PSID) CurrentBuffer;
            CurrentBuffer += PtrAlignSize(Length);
            pObjSid        = (POBJECTS_AND_SID) CurrentBuffer;
            CurrentBuffer += sizeof(OBJECTS_AND_SID);

            BuildTrusteeWithObjectsAndSidW(
                &(pExplicit[j].Trustee),
                pObjSid,
                RtlObjectAceObjectType(pAce),
                RtlObjectAceInheritedObjectType(pAce),
                pSid
                );
            break;

        default:
            return ERROR_INVALID_PARAMETER;
        }

        switch (pAce->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

            pExplicit[j].grfAccessMode = GRANT_ACCESS;
            break;

        case ACCESS_DENIED_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:

            pExplicit[j].grfAccessMode = DENY_ACCESS;
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:

            if ((FALSE == bFlag) && (FLAG_ON(pAce->AceFlags, SUCCESSFUL_ACCESS_ACE_FLAG)))
            {
                pExplicit[j].grfAccessMode = SET_AUDIT_SUCCESS;
                if (FLAG_ON(pAce->AceFlags, FAILED_ACCESS_ACE_FLAG))
                {
                    bFlag = TRUE;
                }
            }
            else if (FLAG_ON(pAce->AceFlags, FAILED_ACCESS_ACE_FLAG))
            {
                pExplicit[j].grfAccessMode = SET_AUDIT_FAILURE;
                bFlag = FALSE;
            }

            break;

        default:
            return ERROR_INVALID_PARAMETER;
        }

        pExplicit[j].grfAccessPermissions = Mask;
        pExplicit[j].grfInheritance = pAce->AceFlags & VALID_INHERIT_FLAGS;

        if (FALSE == bFlag)
        {
            i++;
            pAce = (PACE_HEADER) NextAce(pAce);
        }

        j++;
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\event.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:       EVENT.C
//
//  Contents:   Routines used by the event viewer to map GUIDs to names
//
//  History:    25-Oct-97       CliffV        Created
//
//----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>
#include <lucache.h>



DWORD
EventGuidToName(
    IN LPCWSTR Source,
    IN LPCWSTR GuidString,
    OUT LPWSTR *NameString
    )
/*++

Routine Description:

    General purpose routine used by the event viewer to translate from a GUID
    in an event log message to a name of the GUID.

    This instance of the routine translates the following GUID types:
        Object Class Guids (e.g., user)
        Property set Guids (e.g., ATT_USER_PRINCIPLE_NAME)
        Property Guids (e.g., adminDisplayName)
        Object Guids (e.g., <DnsDomainName>/Users/<UserName>)

Arguments:

    Source - Specifies the source of the GUID.  The routine will use this field
        to differentiate between multiple sources potentially implemented by
        the routine.

        This instance of the routine requires the Source to be
        ACCESS_DS_SOURCE_W.

    GuidString - A string-ized version of the GUID to translate.  The GUID should
        be in the form 33ff431c-4d78-11d1-b61a-00c04fd8ebaa.

    NameString - Returns the name that corresponds to the GUID.  If the name cannot
        be found, a stringized version of the GUID is returned.
        The name should be freed by calling EventNameFree.

Return Value:

    NO_ERROR - The Name was successfully translated.

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to complete the operation.

    ERROR_INVALID_PARAMETER - Source is not supported.

    RPC_S_INVALID_STRING_UUID - Syntax of GuidString is invalid

--*/

{
    DWORD dwErr;
    GUID Guid;

    //
    // Ensure the source is one we recognize.
    //

    if ( _wcsicmp( Source, ACCESS_DS_SOURCE_W) != 0 ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Convert the specified GUID to binary.
    //

    dwErr = UuidFromString((LPWSTR)GuidString, &Guid);

    if ( dwErr != NO_ERROR ) {
        return dwErr;
    }


    //
    // Convert the GUID to a name.
    //

    dwErr = AccctrlLookupIdName(
                    NULL,   // No existing LDAP handle
                    L"",    // Only the root path
                    &Guid,
                    TRUE,   // Allocate the return buffer
                    TRUE,   // Handle individual object GUIDs
                    NameString );

    return dwErr;

}





VOID
EventNameFree(
    IN LPCWSTR NameString
    )
/*++

Routine Description:

    Routine to free strings returned by EventNameFree.

Arguments:

    NameString - Returns the name that corresponds to the GUID.

Return Value:

    None.

--*/

{
    LocalFree((PVOID)NameString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\idcache.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:        idcache.cxx
//
//  Contents:    Implementation of the DS guid/name lookup cache
//
//  History:     20-Feb-97      MacM        Created
//
//--------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <stdio.h>
#include <alsup.hxx>

//
// This list contains pointers to memory allocated when a node is converted
// to/from a guid via Rpc apis.  It gets freed during cleanup.
//
typedef struct _ACTRL_ID_MEM
{
    PVOID   pv;
    BOOL    fRpc;
    struct _ACTRL_ID_MEM   *pNext;
} ACTRL_ID_MEM, *PACTRL_ID_MEM;

//
// Global name/id cache
//
PACTRL_OBJ_ID_CACHE  grgIdNameCache[ACTRL_OBJ_ID_TABLE_SIZE];
PACTRL_OBJ_ID_CACHE  grgIdGuidCache[ACTRL_OBJ_ID_TABLE_SIZE];

//
// Mem list head pointer
//
PACTRL_ID_MEM   gpMemCleanupList;

//
// Last connection info/time we read from the schema
//
static ACTRL_ID_SCHEMA_INFO    LastSchemaRead;

//
// Defines for attribute strings
//
#define ACTRL_OBJ_NAME  L"NAME '"
#define ACTRL_OBJ_GUID  L"PROPERTY-GUID '"
#define ACTRL_OBJ_CLASS L"CLASS-GUID '"
#define ACTRL_OBJ_NAME_LEN  sizeof(ACTRL_OBJ_NAME) / sizeof(WCHAR) - 1
#define ACTRL_OBJ_GUID_LEN  sizeof(ACTRL_OBJ_GUID) / sizeof(WCHAR) - 1
#define ACTRL_OBJ_CLASS_LEN  sizeof(ACTRL_OBJ_CLASS) / sizeof(WCHAR) - 1

//
// Local function prototypes
//
PACTRL_NAME_CACHE AccctrlpLookupIdNameInCache(PWSTR   pwszName);

PACTRL_NAME_CACHE AccctrlpLookupGuidInCache(PSID     pSid);

DWORD   AccctrlpNewNameGuidNode(PWSTR                pwszName,
                                PGUID                pGuid,
                                PACTRL_OBJ_ID_CACHE *ppNewNode);

BOOL    AccctrlpInsertIdNameNode(PACTRL_OBJ_ID_CACHE *ppRootNode,
                                 PACTRL_OBJ_ID_CACHE  pNewNode);

BOOL    AccctrlpInsertGuidNode(PACTRL_OBJ_ID_CACHE *ppRootNode,
                               PACTRL_OBJ_ID_CACHE  pNewNode);

VOID    AccctrlpRemoveIdNameNode(PACTRL_OBJ_ID_CACHE *ppRootNode,
                                 PACTRL_OBJ_ID_CACHE  pNewNode);

VOID    AccctrlpFreeUserCacheName(PWSTR      pwszName,
                                  PWSTR      pwszCacheName);

DWORD   AccctrlpLoadCacheFromSchema(PLDAP   pLDAP,
                                    PWSTR   pwszDsPath);

static RTL_RESOURCE gIdCacheLock;
BOOL bIdCacheLockInitialized = FALSE;

//+----------------------------------------------------------------------------
//
//  Function:   ActrlHashIdName
//
//  Synopsis:   Determines the hash index for the given ldap display name
//
//  Arguments:  pwszName        --      Name to hash
//
//  Returns:    Hash index of the string
//
//-----------------------------------------------------------------------------
INT
ActrlHashIdName(PWSTR pwszName)
{
    INT Hash = 0;
#if DBG
    PWSTR   pwsz = pwszName;
#endif

    if(pwszName != NULL)
    {
        while(*pwszName != L'\0')
        {
            Hash = (Hash * 16 + ( tolower(*pwszName++))) % ACTRL_OBJ_ID_TABLE_SIZE;
        }
    }

#if DBG
    acDebugOut((DEB_TRACE_LOOKUP,"Hashing id name %ws to %lu\n",
                pwsz, Hash));
#endif

    return(Hash);
}




//+----------------------------------------------------------------------------
//
//  Function:   ActrlHashGuid
//
//  Synopsis:   Determines the hash index for the given guid
//
//  Arguments:  pGuid           --      Guid to hash
//
//  Returns:    Hash index of the Guid
//
//-----------------------------------------------------------------------------
INT
ActrlHashGuid(PGUID  pGuid)
{
    DWORD   dwTotal = 0;

    //
    // Just deal with the sub authorities
    //
    for(INT i = 0; i < sizeof(GUID) / sizeof(DWORD); i++)
    {
        dwTotal += ((PULONG)pGuid)[i];
    }

#if DBG
    CHAR    szGuid[38];
    memset( szGuid,
            0,
            sizeof(szGuid));
    sprintf(szGuid, "%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x",
                pGuid->Data1,pGuid->Data2,pGuid->Data3,pGuid->Data4[0],
                pGuid->Data4[1],pGuid->Data4[2],pGuid->Data4[3],
                pGuid->Data4[4],pGuid->Data4[5],pGuid->Data4[6],
                pGuid->Data4[7]);


    acDebugOut((DEB_TRACE_LOOKUP,
                "Hashing id %s (Total %lu) to %lu\n",
                szGuid, dwTotal, dwTotal % ACTRL_OBJ_ID_TABLE_SIZE));
#endif
    return(dwTotal % ACTRL_OBJ_ID_TABLE_SIZE);
}





//+----------------------------------------------------------------------------
//
//  Function:   AccctrlInitializeIdNameCache
//
//  Synopsis:   Initialize the ID name/Guid lookup cache
//
//  Arguments:  VOID
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//-----------------------------------------------------------------------------
DWORD AccctrlInitializeIdNameCache(VOID)
{
    DWORD dwErr;

    if (TRUE == bIdCacheLockInitialized)
    {
        // Just a precautionary measure to make sure that we do not initialize
        // multiple times.
        //

        ASSERT(FALSE);
        return ERROR_SUCCESS;
    }

    memset(grgIdNameCache, 0,
           sizeof(PACTRL_OBJ_ID_CACHE) * ACTRL_OBJ_ID_TABLE_SIZE);
    memset(grgIdGuidCache, 0,
           sizeof(PACTRL_OBJ_ID_CACHE) * ACTRL_OBJ_ID_TABLE_SIZE);

    gpMemCleanupList = NULL;

    memset(&LastSchemaRead, 0, sizeof(ACTRL_ID_SCHEMA_INFO));

    __try
    {
        RtlInitializeResource(&gIdCacheLock);
        dwErr = ERROR_SUCCESS;
        bIdCacheLockInitialized = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = RtlNtStatusToDosError(GetExceptionCode());
    }

    return dwErr;
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlFreeIdNameCache
//
//  Synopsis:   Frees any memory allocated for the id name/guid cache
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID AccctrlFreeIdNameCache(VOID)
{
    INT i;
    PACTRL_OBJ_ID_CACHE   pNode, pNext;

    if (FALSE == bIdCacheLockInitialized)
    {
        return;
    }

    for(i = 0; i < ACTRL_OBJ_ID_TABLE_SIZE; i++)
    {
        //
        // Nodes are only inserted into the name cache, so that is the only
        // place we delete them from
        //
        pNode = grgIdNameCache[i];
        while(pNode != NULL)
        {
            pNext = pNode->pNextName;
            AccFree(pNode->pwszName);
            AccFree(pNode);
            pNode = pNext;
        }
    }

    PACTRL_ID_MEM   pMem = gpMemCleanupList;

    while(pMem != NULL)
    {
        if(pMem->fRpc == TRUE)
        {
            PWSTR   pwsz = (PWSTR)pMem->pv;
            RpcStringFree(&pwsz);
        }
        else
        {
            AccFree(pMem->pv);
        }

        pMem = pMem->pNext;
    }

    AccFree(LastSchemaRead.pwszPath);

    RtlDeleteResource(&gIdCacheLock);

    bIdCacheLockInitialized = FALSE;

}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpLookupIdNameInCache
//
//  Synopsis:   Determines if the given name exists in the cache or not
//
//  Arguments:  [pwszName]      --      Name to be looked up
//
//  Returns:    Matching node if found, NULL if not
//
//-----------------------------------------------------------------------------
PACTRL_OBJ_ID_CACHE AccctrlpLookupNameInCache(PWSTR   pwszName)
{
    PACTRL_OBJ_ID_CACHE pNode = NULL;

    pNode =  grgIdNameCache[ActrlHashIdName(pwszName)];

    while(pNode != NULL)
    {
        if(_wcsicmp(pwszName, pNode->pwszName) == 0)
        {
            break;
        }
        pNode = pNode->pNextName;
    }

#if DBG
    if(pNode != NULL )
    {
    CHAR    szGuid[38];
    PGUID   pGuid = &pNode->Guid;
    sprintf(szGuid, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                pGuid->Data1,pGuid->Data2,pGuid->Data3,pGuid->Data4[0],
                pGuid->Data4[1],pGuid->Data4[2],pGuid->Data4[3],
                pGuid->Data4[4],pGuid->Data4[5],pGuid->Data4[6],
                pGuid->Data4[7]);

    acDebugOut((DEB_TRACE_LOOKUP,
                "LookupName on  %ws found %s\n",
                pwszName, szGuid));
    }
#endif

    return(pNode);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpLookupGuidInCache
//
//  Synopsis:   Determines if the given guid exists in the cache or not
//
//  Arguments:  [pGuid]         --      Guid to be looked up
//
//  Returns:    Matching node if found, NULL if not
//
//-----------------------------------------------------------------------------
PACTRL_OBJ_ID_CACHE AccctrlpLookupGuidInCache(PGUID    pGuid)
{
    PACTRL_OBJ_ID_CACHE pNode = grgIdGuidCache[ActrlHashGuid(pGuid)];

    while(pNode != NULL)
    {
        if(memcmp(pGuid, &(pNode->Guid), sizeof(GUID)) == 0)
        {
            break;
        }
        pNode = pNode->pNextGuid;
    }

#if DBG
    if(pNode != NULL )
    {
    CHAR    szGuid[37];
    sprintf(szGuid, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                pGuid->Data1,pGuid->Data2,pGuid->Data3,pGuid->Data4[0],
                pGuid->Data4[1],pGuid->Data4[2],pGuid->Data4[3],
                pGuid->Data4[4],pGuid->Data4[5],pGuid->Data4[6],
                pGuid->Data4[7]);

    acDebugOut((DEB_TRACE_LOOKUP,
                "LookupGuid on  %s found %ws\n",
                szGuid, pNode->pwszName));
    }
#endif


    return(pNode);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpNewNameGuidNode
//
//  Synopsis:   Allocates a new node and inserts them into the caches
//
//  Arguments:  [pwszName]      --      Name to insert
//              [pGuid]         --      Guid to insert
//              [pNewNode]      --      Newly added node
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_INVALID_DATA      A node was only inserted in one list
//
//-----------------------------------------------------------------------------
DWORD  AccctrlpNewNameGuidNode(PWSTR                  pwszName,
                               PGUID                  pGuid,
                               PACTRL_OBJ_ID_CACHE   *ppNewNode)
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fNameRet = FALSE, fGuidRet = FALSE;

    PACTRL_OBJ_ID_CACHE   pNewNode = (PACTRL_OBJ_ID_CACHE)AccAlloc(
                                                  sizeof(ACTRL_OBJ_ID_CACHE));
    if(pNewNode == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pNewNode->pwszName = pwszName;
        memcpy(&pNewNode->Guid, pGuid, sizeof(GUID));
        pNewNode->pNextName= NULL;
        pNewNode->pNextGuid= NULL;

        fNameRet = AccctrlpInsertIdNameNode(
                                &(grgIdNameCache[ActrlHashIdName(pwszName)]),
                                pNewNode);

        if ( fNameRet == TRUE ) {

            fGuidRet = AccctrlpInsertGuidNode(
                                    &(grgIdGuidCache[ActrlHashGuid(pGuid)]),
                                    pNewNode);
        }

        if(fNameRet == TRUE && fGuidRet == TRUE)
        {
            *ppNewNode = pNewNode;
        }
        else
        {
            dwErr = ERROR_INVALID_DATA;

            if( fNameRet == TRUE )
            {
                AccctrlpRemoveIdNameNode( &(grgIdNameCache[ActrlHashIdName(pwszName)]),
                                          pNewNode);
            }

            AccFree(pNewNode);
            *ppNewNode = NULL;

        }


    }
    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpInsertIdNameNode
//
//  Synopsis:   Inserts the specified new node into the caches
//
//  Arguments:  [ppRootNode]    --      Root node in the name cache
//              [pNewNode]      --      Node to insert
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
BOOL AccctrlpInsertIdNameNode(PACTRL_OBJ_ID_CACHE *ppRootNode,
                              PACTRL_OBJ_ID_CACHE  pNewNode)
{
    PACTRL_OBJ_ID_CACHE   pNext = NULL, pTrail = NULL;
    BOOL                  fReturn = TRUE;

    if(*ppRootNode == NULL)
    {
        *ppRootNode = pNewNode;
    }
    else
    {
//        acDebugOut((DEB_TRACE_LOOKUP, "Collision inserting %ws with:\n",
//                    pNewNode->pwszName));

        pNext = *ppRootNode;
//        acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        while(pNext != NULL)
        {
            if(_wcsicmp(pNewNode->pwszName, pNext->pwszName) == 0)
            {
                //
                // If a node is already found, exit
                //
                fReturn = FALSE;
                acDebugOut((DEB_TRACE_LOOKUP, "Name %ws already exists. Bailing\n",
                            pNewNode->pwszName));
                break;
            }

            pTrail = pNext;
            pNext = pNext->pNextName;
//            acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        }

        if(fReturn == TRUE)
        {
            if ( pTrail == NULL ) {

                (*ppRootNode)->pNextName = pNewNode;

            } else {

                pTrail->pNextName = pNewNode;

            }
        }
    }

    return(fReturn);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpInsertGuidNode
//
//  Synopsis:   Inserts the specified new node into the caches
//
//  Arguments:  [ppRootNode]    --      Root node in the name cache
//              [pNewNode]      --      Node to insert
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
BOOL   AccctrlpInsertGuidNode(PACTRL_OBJ_ID_CACHE *ppRootNode,
                              PACTRL_OBJ_ID_CACHE  pNewNode)
{
    PACTRL_OBJ_ID_CACHE   pNext = NULL, pTrail = NULL;
    BOOL                  fReturn = TRUE;

    if(*ppRootNode == NULL)
    {
        *ppRootNode = pNewNode;
    }
    else
    {
//        acDebugOut((DEB_TRACE_LOOKUP, "Collision inserting %ws with:\n",
//                    pNewNode->pwszName));

        pNext = *ppRootNode;
//        acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        while(pNext != NULL)
        {
            if(memcmp(&(pNewNode->Guid), &(pNext->Guid), sizeof(GUID)) == 0)
            {
                fReturn = FALSE;
                acDebugOut((DEB_TRACE_LOOKUP, "Guid for %ws already exists. Bailing\n",
                            pNewNode->pwszName));
                break;
            }

            pTrail = pNext;
            pNext = pNext->pNextGuid;

//            acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        }

        if(fReturn == TRUE)
        {
            if ( pTrail == NULL ) {

                (*ppRootNode)->pNextGuid = pNewNode;

            } else {

                pTrail->pNextGuid = pNewNode;
            }

        }
    }

    return(fReturn);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlLookupIdName
//
//  Synopsis:   Looks up the name for the specified GUID.
//              Algorithm:
//                  Search cache for ID
//                  If not found, reload table from schema on DS referenced
//                      by the DS path
//                  Search the cache for the ID
//                  If not found, return the string version of the ID
//
//  Arguments:  [pGuid]         --      Guid to lookup
//              [fAllocateReturn]-      If true, the name returned is allocated
//                                      into a new buffer.  Otherwise, a
//                                      reference is returned.
//              [ppwszName]     --      Where the name is returned.
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
DWORD
AccctrlLookupIdName(IN  PLDAP       pLDAP,
                    IN  PWSTR       pwszDsPath,
                    IN  PGUID       pGuid,
                    IN  BOOL        fAllocateReturn,
                    IN  BOOL        fHandleObjectGuids,
                    OUT PWSTR      *ppwszName)
{
    DWORD   dwErr = ERROR_SUCCESS;
    PWSTR   pwszStringId = NULL;

    RtlAcquireResourceShared(&gIdCacheLock, TRUE);

#if DBG
    CHAR    szGuid[38];
    sprintf(szGuid,
            "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
             pGuid->Data1,pGuid->Data2,pGuid->Data3,
             pGuid->Data4[0],
             pGuid->Data4[1],pGuid->Data4[2],pGuid->Data4[3],
             pGuid->Data4[4],pGuid->Data4[5],pGuid->Data4[6],
             pGuid->Data4[7]);
#endif

    //
    // First, see if the sid alreadt exists in our cache
    //
    PACTRL_OBJ_ID_CACHE pNode = AccctrlpLookupGuidInCache(pGuid);
    if(pNode == NULL)
    {
        acDebugOut((DEB_TRACE_LOOKUP, "Guid %s not found in cache\n", szGuid));
        //
        // Grab a write lock
        //
        RtlConvertSharedToExclusive(&gIdCacheLock);


        //
        // We'll have to look it up...
        //
        dwErr = AccctrlpLoadCacheFromSchema(pLDAP, pwszDsPath);
        if(dwErr == ERROR_SUCCESS)
        {
            pNode = AccctrlpLookupGuidInCache(pGuid);

            //
            // If we've been asked to handle individual object guids,
            //  see if this GUID is one.
            //

            if ( fHandleObjectGuids ) {
                PWSTR pwszUuid;
                DWORD dwUuidLen;
                PWSTR pwszDSObj;
                PDS_NAME_RESULTW pNameRes;

                //
                // Convert the GUID to a string.
                //

                dwErr = UuidToString(pGuid, &pwszUuid);

                if ( dwErr == ERROR_SUCCESS ) {

                    //
                    // Convert the string-ized GUID to an object name.
                    //

                    dwUuidLen = wcslen( pwszUuid );

                    pwszDSObj = (PWSTR) AccAlloc( (dwUuidLen+3)*sizeof(WCHAR) );

                    if ( pwszDSObj == NULL) {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    } else {
                        PWSTR pwszServer = NULL, pwszObject = NULL;

                        pwszDSObj[0] = L'{';
                        memcpy( &pwszDSObj[1], pwszUuid, dwUuidLen*sizeof(WCHAR) );
                        pwszDSObj[dwUuidLen+1] = L'}';
                        pwszDSObj[dwUuidLen+2] = L'\0';

                        //
                        // Crack the name into canonical form
                        //
                        dwErr = DspSplitPath( pwszDSObj, &pwszServer, &pwszObject );

                        if(dwErr == ERROR_SUCCESS)
                        {

                            dwErr = DspBindAndCrackEx(
                                        pwszServer,
                                        pwszObject,
                                        0,
                                        DS_CANONICAL_NAME,
                                        &pNameRes );

                            if ( dwErr == ERROR_SUCCESS ) {
                                if(pNameRes->cItems == 0 || pNameRes->rItems[0].status != 0) {
                                    dwErr = ERROR_SUCCESS;
                                } else {
                                    //
                                    // Cache our newly found name.
                                    //

                                    dwErr = AccctrlpNewNameGuidNode( pNameRes->rItems[0].pName,
                                                                     pGuid,
                                                                     &pNode);
                                }


                                // Clean up
                                DsFreeNameResultW(pNameRes);
                            } else {

                                // Failure to find name isn't fatal
                                dwErr = ERROR_SUCCESS;
                            }

                            AccFree(pwszServer);
                        }

                        // Clean up
                        AccFree( pwszDSObj );
                    }

                    // Clean up
                    RpcStringFree(&pwszUuid);
                }
            }

            //
            // If it wasn't found, return the string version of the ID
            //
            if( dwErr == ERROR_SUCCESS && pNode == NULL)
            {
                dwErr = UuidToString(pGuid, &pwszStringId);
            }

        }
    }
    else
    {
        acDebugOut((DEB_TRACE_LOOKUP, "Guid %s found in cache\n", szGuid));
    }

    //
    // Finally, return the information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR   pwszName;

        if(pNode != NULL)
        {
            pwszName = pNode->pwszName;
        }
        else
        {
            pwszName = pwszStringId;
        }

        if(fAllocateReturn == TRUE)
        {
            ACC_ALLOC_AND_COPY_STRINGW(pwszName, *ppwszName, dwErr);
        }
        else
        {
            *ppwszName = pwszName;

            if(pwszStringId != NULL)
            {
                PACTRL_ID_MEM pMem = (PACTRL_ID_MEM)AccAlloc(sizeof(ACTRL_ID_MEM));
                if(pMem == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    RpcStringFree(&pwszStringId);
                }
                else
                {
                    pMem->pv = pwszStringId;
                    pMem->fRpc = TRUE;
                    pMem->pNext = gpMemCleanupList;
                    gpMemCleanupList = pMem;
                }
            }
        }
    }

    RtlReleaseResource(&gIdCacheLock);

    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlLookupGuid
//
//  Synopsis:   Looks up the GUID for the specified name
//
//  Arguments:  [pwszName]      --      Name to lookup
//              [fAllocateReturn]-      If true, the name returned is allocated
//                                      into a new buffer.  Otherwise, a
//                                      reference is returned.
//              [ppGuid]        --      Where the guid is returned.
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
DWORD
AccctrlLookupGuid(IN  PLDAP         pLDAP,
                  IN  PWSTR         pwszDsPath,
                  IN  PWSTR         pwszName,
                  IN  BOOL          fAllocateReturn,
                  OUT PGUID        *ppGuid)
{
    DWORD   dwErr = ERROR_SUCCESS;
    GUID    guid, *pguid = NULL;
    BOOL    fConverted = FALSE;

    RtlAcquireResourceShared(&gIdCacheLock, TRUE);

    //
    // First, see if the sid already exists in our cache
    //
    PACTRL_OBJ_ID_CACHE pNode = AccctrlpLookupNameInCache(pwszName);
    if(pNode == NULL)
    {
        //
        // Grab a write lock
        //
        RtlConvertSharedToExclusive(&gIdCacheLock);

        acDebugOut((DEB_TRACE_LOOKUP,"Name %ws not found in cache\n",
                    pwszName));
        //
        // We'll have to look it up...
        //
        dwErr = AccctrlpLoadCacheFromSchema(pLDAP, pwszDsPath);
        if(dwErr == ERROR_SUCCESS)
        {
            pNode = AccctrlpLookupNameInCache(pwszName);

            //
            // If it wasn't found, return the ID from the string
            //
            if(pNode == NULL)
            {
                dwErr = UuidFromString(pwszName, &guid);
                fConverted = TRUE;
                pguid = &guid;

            }
            else
            {
                pguid = &pNode->Guid;
            }
        }
    }
    else
    {
        acDebugOut((DEB_TRACE_LOOKUP,"Name %ws found in cache\n", pwszName));
        pguid = &pNode->Guid;
    }

    //
    // Finally, return the information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        if(fAllocateReturn == TRUE)
        {
            ACC_ALLOC_AND_COPY_GUID(pguid, *ppGuid, dwErr);
        }
        else
        {
            if(fConverted == TRUE)
            {
                ACC_ALLOC_AND_COPY_GUID(pguid, *ppGuid, dwErr);

                if(dwErr == ERROR_SUCCESS)
                {
                    PACTRL_ID_MEM pMem = (PACTRL_ID_MEM)AccAlloc(
                                                        sizeof(ACTRL_ID_MEM));
                    if(pMem == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                        AccFree(*ppGuid);
                    }
                    else
                    {
                        pMem->pv = *ppGuid;
                        pMem->pNext = gpMemCleanupList;
                        gpMemCleanupList = pMem;
                    }
                }
            }
            else
            {
                *ppGuid = pguid;
            }

        }
    }

    RtlReleaseResource(&gIdCacheLock);

    return(dwErr);
}


#define WCHAR_TO_HEX_BYTE(wc)           \
        (BYTE)((wc) >= L'0' && (wc) <= L'9' ? (wc) - L'0' : towlower( (wc) ) - L'a' + 10)
#define WCHAR_TO_HI_HEX_BYTE(wc)    (WCHAR_TO_HEX_BYTE(wc) << 4 )

//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpDsStrGuidToGuid
//
//  Synopsis:   Converts a read string guid into an actual guid
//
//  Arguments:  [pwszStrGuid]   --      String version of the id
//              [pGuid]         --      Where the build ID is returned
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//-----------------------------------------------------------------------------
DWORD AccctrlpDsStrGuidToGuid(IN  PWSTR     pwszStrGuid,
                              OUT PGUID     pGuid)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(pwszStrGuid == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
#if 1
        //
        // The string guid we're given is not in a standard UuidToString form,
        // so we'll have to convert it
        //
        PBYTE   pCurr = (PBYTE)pGuid;

        for(ULONG i = 0; i < sizeof(GUID); i++)
        {
            *pCurr = WCHAR_TO_HI_HEX_BYTE(*pwszStrGuid) | WCHAR_TO_HEX_BYTE(*(pwszStrGuid + 1));
            pCurr++;
            pwszStrGuid += 2;
        }
#else

        //
        // Whack it into the right form...
        //
        WCHAR   wszStrFormat[sizeof(GUID) * sizeof(WCHAR) + 7];
        ULONG   Blocks[] = {8, 4, 4, 4, 12};

        PWSTR   pwszStrFor = wszStrFormat;
        for(ULONG i = 0 ; i < sizeof(Blocks) / sizeof(ULONG) ; i++ )
        {
            for(ULONG j = 0; j < Blocks[i]; j++)
            {
                *pwszStrFor++ = *pwszStrGuid++;
            }
            *pwszStrFor++ = L'-';
        }

        pwszStrFor--;
        *pwszStrFor = UNICODE_NULL;

        dwErr = UuidFromString(wszStrFormat, pGuid);
#endif

    }

    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpLoadCacheFromSchema
//
//  Synopsis:   Reads the schema cache and adds the entries into the
//              cache
//
//  Arguments:  [pLDAP]         --      LDAP connection to the server
//              [pwszPath]      --      DS path to the object
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//-----------------------------------------------------------------------------
DWORD   AccctrlpLoadCacheFromSchema(PLDAP   pLDAP,
                                    PWSTR   pwszDsPath)
{
    DWORD       dwErr = ERROR_SUCCESS;
    PLDAP       pLocalLDAP = pLDAP;
    ULONG       cValues[2];
    PWSTR      *ppwszValues[2];
    PWSTR       rgwszGuidStrs[] = {ACTRL_OBJ_CLASS, ACTRL_OBJ_GUID};
    ULONG       rgGuidStrLen[] = {ACTRL_OBJ_CLASS_LEN, ACTRL_OBJ_GUID_LEN};

    acDebugOut((DEB_TRACE_LOOKUP, "Reloading cache from schema\n"));

    //
    // If we have no parameters, just return...
    //
    if(pLDAP == NULL && pwszDsPath == NULL)
    {
        return(ERROR_SUCCESS);
    }

    //
    // See if we need to read...  If our data is over 5 minutes old or if our path referenced is
    // not the same as the last one...
    //
#define FIVE_MINUTES    300000
    if((LastSchemaRead.LastReadTime != 0 &&
                            (GetTickCount() - LastSchemaRead.LastReadTime < FIVE_MINUTES)) &&
       DoPropertiesMatch(pwszDsPath, LastSchemaRead.pwszPath) &&
       ((pLDAP == NULL && LastSchemaRead.fLDAP == FALSE) ||
        (pLDAP != NULL && memcmp(pLDAP, &(LastSchemaRead.LDAP), sizeof(LDAP)))))

    {
        acDebugOut((DEB_TRACE_LOOKUP,"Cache up to date...\n"));
        return(ERROR_SUCCESS);
    }
    else
    {
        //
        // Need to reinitialize it...
        //
        if(pLDAP == NULL)
        {
            LastSchemaRead.fLDAP = FALSE;
        }
        else
        {
            LastSchemaRead.fLDAP = TRUE;
            memcpy(&(LastSchemaRead.LDAP), pLDAP, sizeof(LDAP));
        }

        AccFree(LastSchemaRead.pwszPath);
        if(pwszDsPath != NULL)
        {
            ACC_ALLOC_AND_COPY_STRINGW(pwszDsPath, LastSchemaRead.pwszPath, dwErr);
        }

        LastSchemaRead.LastReadTime = GetTickCount();
    }



    if(dwErr == ERROR_SUCCESS && pLocalLDAP == NULL)
    {
        PWSTR pwszServer = NULL, pwszObject = NULL;

        dwErr = DspSplitPath( pwszDsPath, &pwszServer, &pwszObject );

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = BindToDSObject(pwszServer, pwszObject, &pLocalLDAP);
            LocalFree(pwszServer);
        }
    }

    //
    // Now, get the info.  First, extended rights, then the schema info
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccDsReadExtendedRights(pLocalLDAP,
                                        &(cValues[0]),
                                        &(ppwszValues[0]),
                                        &(ppwszValues[1]));
        if(dwErr == ERROR_SUCCESS )
        {
            for(ULONG j = 0; j < cValues[0]  && dwErr == ERROR_SUCCESS; j++)
            {
                GUID    guid;

                dwErr = UuidFromString(ppwszValues[1][j], &guid);

                if(dwErr == ERROR_SUCCESS)
                {
                    PACTRL_OBJ_ID_CACHE pNewNode;

                    PWSTR   pwsz;
                    ACC_ALLOC_AND_COPY_STRINGW(ppwszValues[0][j], pwsz, dwErr);

                    if(dwErr == ERROR_SUCCESS )
                    {

                        dwErr = AccctrlpNewNameGuidNode(pwsz,
                                                        &guid,
                                                        &pNewNode);

                        if(dwErr != ERROR_SUCCESS)
                        {
                            AccFree(pwsz);

                            if ( dwErr == ERROR_INVALID_DATA ) {

                                dwErr = ERROR_SUCCESS;
                            }
                        }
                    }
                }
            }

            AccDsFreeExtendedRights(cValues[0],
                                    ppwszValues[0],
                                    ppwszValues[1]);
        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AccDsReadSchemaInfo(pLocalLDAP,
                                        &(cValues[0]),
                                        &(ppwszValues[0]),
                                        &(cValues[1]),
                                        &(ppwszValues[1]));
            if(dwErr == ERROR_SUCCESS )
            {
                for(ULONG i = 0; i < 2 && dwErr == ERROR_SUCCESS; i++)
                {
                    for(ULONG j = 0;
                        j < cValues[i]  && dwErr == ERROR_SUCCESS; j++)
                    {
                        PWSTR   pwszVal = ppwszValues[i][j];
                        GUID    guid;

                        PWSTR   pwszName, pwszGuid, pwszTick;

                        pwszName = wcswcs(pwszVal, ACTRL_OBJ_NAME) + ACTRL_OBJ_NAME_LEN;
                        pwszGuid = wcswcs(pwszName, rgwszGuidStrs[i]) + rgGuidStrLen[i];
                        pwszTick = wcswcs(pwszName, L"'");

                        if(pwszTick != NULL)
                        {
                            *pwszTick = UNICODE_NULL;
                        }

                        dwErr = AccctrlpDsStrGuidToGuid(pwszGuid, &guid);

                        if(dwErr == ERROR_SUCCESS)
                        {
                            PACTRL_OBJ_ID_CACHE pNewNode;

                            PWSTR   pwsz;
                            ACC_ALLOC_AND_COPY_STRINGW(pwszName, pwsz, dwErr);

                            if(dwErr == ERROR_SUCCESS )
                            {

                                dwErr = AccctrlpNewNameGuidNode(pwsz,
                                                                &guid,
                                                                &pNewNode);

                                if(dwErr != ERROR_SUCCESS)
                                {
                                    AccFree(pwsz);

                                    if ( dwErr == ERROR_INVALID_DATA ) {

                                        dwErr = ERROR_SUCCESS;
                                    }
                                }
                            }
                        }

                        pwszVal = pwszGuid;
                    }
                }


                ldap_value_free(ppwszValues[0]);
                ldap_value_free(ppwszValues[1]);
            }


        }

    }

    //
    // See if we need to release our ldap connection
    //
    if(pLocalLDAP != pLDAP && pLocalLDAP != NULL)
    {
        UnBindFromDSObject(&pLocalLDAP);
    }
    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpRemoveIdNameNode
//
//  Synopsis:   Removes the specified new node into the caches
//
//  Arguments:  [ppRootNode]    --      Root node in the name cache
//              [pNewNode]      --      Node to remove
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID AccctrlpRemoveIdNameNode(PACTRL_OBJ_ID_CACHE *ppRootNode,
                              PACTRL_OBJ_ID_CACHE  pNewNode)
{
    PACTRL_OBJ_ID_CACHE   pNext = NULL, pPrev;

    ASSERT( *ppRootNode != NULL );
    if(_wcsicmp((*ppRootNode)->pwszName, pNewNode->pwszName) == 0)
    {
        *ppRootNode = NULL;
    }
    else
    {

        pNext = (*ppRootNode)->pNextName;
        pPrev = *ppRootNode;
        while(pNext != NULL)
        {
            if(_wcsicmp(pNewNode->pwszName, pNext->pwszName) == 0)
            {
                //
                // Remove the node
                //
                pPrev->pNextName = pNext->pNextName;
                acDebugOut((DEB_TRACE_LOOKUP, "Removed node for %ws\n",
                            pNext->pwszName));
                break;
            }

            pPrev = pNext;
            pNext = pNext->pNextName;
        }

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\kernel.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       kernel.cxx
//
//  Contents:   Kernel support functions
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#include <seopaque.h>
#include <sertlp.h>
#pragma warning(disable: 4200)
#include <wmistr.h>
#include <wmiumkm.h>

#define BASED_NAMED_OBJECTS_DIR     L"\\BaseNamedObjects"

//
// Function prototypes
//
ULONG WmipOpenKernelGuid(
    CONST GUID *Guid,
    ACCESS_MASK DesiredAccess,
    PHANDLE Handle
    );

HANDLE WmiGuidHandle = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   OpenKernelObject
//
//  Synopsis:   Gets a handle to the specified kernel object
//
//  Arguments:  [IN  pwszObject]        --      Object to open
//              [IN  AccessMask]        --      Type of open to do
//              [OUT pHandle]           --      Where the handle to the object
//                                              is returned
//              [OUT KernelType]        --      Type of the kernel object
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
OpenKernelObject(IN  LPWSTR       pwszObject,
                 IN  ACCESS_MASK  AccessMask,
                 OUT PHANDLE      pHandle,
                 OUT PMARTA_KERNEL_TYPE KernelType)
{
    #define BUFFERSIZE  1024

    HANDLE              hRootDir;
    NTSTATUS            Status;
    UNICODE_STRING      UnicodeString;
    OBJECT_ATTRIBUTES   Attributes;
    UCHAR               Buffer[BUFFERSIZE];
    BOOL                fFound = FALSE;
    ULONG               Context = 0;
    DWORD               dwErr = ERROR_SUCCESS;
    POBJECT_DIRECTORY_INFORMATION DirInfo = NULL;


    //
    // Get a handle to the base named and iterate through that directory
    // to find the object name.
    //

    RtlInitUnicodeString(&UnicodeString,
                         BASED_NAMED_OBJECTS_DIR);

    InitializeObjectAttributes(&Attributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenDirectoryObject(&hRootDir,
                                   DIRECTORY_QUERY,
                                   &Attributes);

    if (!NT_SUCCESS(Status))
    {
        return(RtlNtStatusToDosError(Status));
    }

    //
    // Get the entries in batches that will fit in a buffer of size
    // BUFFERSIZE until we find the entry that we want
    //
    while (NT_SUCCESS(Status) && !fFound )
    {
        RtlZeroMemory(Buffer,
                      BUFFERSIZE);

        Status = NtQueryDirectoryObject(hRootDir,
                                        (PVOID)&Buffer,
                                        BUFFERSIZE,
                                        FALSE,
                                        FALSE,
                                        &Context,
                                        NULL);
        if(NT_SUCCESS(Status))
        {
            //
            // Keep looking until we've examined all the entries in this
            // batch or we find what we're looking for.
            //
            DirInfo = (POBJECT_DIRECTORY_INFORMATION)&Buffer[0];
            while(!fFound && DirInfo->Name.Length != 0)
            {
                ULONG cChar;

                cChar = DirInfo->Name.Length/sizeof(WCHAR);
                if((cChar == wcslen(pwszObject)) &&
                     (!wcsncmp(pwszObject,
                               DirInfo->Name.Buffer,
                               cChar )) )
                {
                    fFound = TRUE;
                }
                else
                {
                    DirInfo++;
                }
            }
        }
    }

    if (!fFound)
    {
        if(Status !=  STATUS_NO_MORE_ENTRIES)
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
        else
        {
            dwErr = ERROR_RESOURCE_NAME_NOT_FOUND;
        }
    }
    else
    {
        ASSERT( DirInfo != NULL );
        ASSERT( DirInfo->Name.Length != 0 );
        ASSERT( DirInfo->TypeName.Length != 0 );

        RtlInitUnicodeString(&UnicodeString,
                             pwszObject);
        InitializeObjectAttributes(&Attributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   hRootDir,
                                   NULL);

        //
        // Open the object to get its handle based on its type
        //
        if (wcsncmp(L"Event",
                    DirInfo->TypeName.Buffer,
                    DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenEvent(pHandle,
                                 AccessMask,
                                 &Attributes);
            *KernelType = MARTA_EVENT;
        }
        else if (wcsncmp( L"EventPair",
                          DirInfo->TypeName.Buffer,
                          DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenEventPair(pHandle,
                                     AccessMask,
                                     &Attributes);
            *KernelType = MARTA_EVENT_PAIR;
        }
        else if (wcsncmp(L"Mutant",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenMutant(pHandle,
                                  AccessMask,
                                  &Attributes);
            *KernelType = MARTA_MUTANT;
        }
        else if (wcsncmp(L"Process",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenProcess(pHandle,
                                   AccessMask,
                                   &Attributes,
                                   NULL);
            *KernelType = MARTA_PROCESS;
        }
        else if (wcsncmp( L"Section",
                          DirInfo->TypeName.Buffer,
                          DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenSection(pHandle,
                                   AccessMask,
                                   &Attributes);
            *KernelType = MARTA_SECTION;
        }
        else if (wcsncmp(L"Semaphore",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenSemaphore(pHandle,
                                     AccessMask,
                                     &Attributes);
            *KernelType = MARTA_SEMAPHORE;
        }
        else if (wcsncmp(L"SymbolicLink",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenSymbolicLinkObject(pHandle,
                                              AccessMask,
                                              &Attributes);
            *KernelType = MARTA_SYMBOLIC_LINK;
        }
        else if (wcsncmp(L"Thread",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenThread(pHandle,
                                  AccessMask,
                                  &Attributes,
                                  NULL);
            *KernelType = MARTA_THREAD;
        }
        else if (wcsncmp(L"Timer",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenTimer(pHandle,
                                 AccessMask,
                                 &Attributes);
            *KernelType = MARTA_TIMER;
        }
        else if (wcsncmp(L"Job",
                         DirInfo->TypeName.Buffer,
                         DirInfo->TypeName.Length/sizeof(WCHAR)) == 0)
        {
            Status = NtOpenJobObject(pHandle,
                                     AccessMask,
                                     &Attributes);
            *KernelType = MARTA_JOB;
        }
        else
        {
            Status = STATUS_OBJECT_NAME_INVALID;
        }

        if(!NT_SUCCESS(Status))
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
    }

    NtClose(hRootDir);

    return (dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadKernelPropertyRights
//
//  Synopsis:   Gets the specified rights from the kernel object
//
//  Arguments:  [IN  pwszObject]        --      The object to get the rights
//                                              for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//
//  Note:      Kernel objects are assumed to be created through the
//             Win32 APIs so they all reside in the \basenamedobjects
//             directory.
//
//----------------------------------------------------------------------------
DWORD
ReadKernelPropertyRights(IN  LPWSTR                 pwszObject,
                         IN  PACTRL_RIGHTS_INFO     pRightsList,
                         IN  ULONG                  cRights,
                         IN  CAccessList&           AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadKernelPropertyRights\n"));

    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hObject = NULL;
    MARTA_KERNEL_TYPE KernelType;

    //
    // Kernel objects don't have parents from whom they can inherit
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = OpenKernelObject(pwszObject,
                             GetDesiredAccess(READ_ACCESS_RIGHTS,
                                              pRightsList[0].SeInfo),
                             &hObject,
                             &KernelType);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = GetKernelSecurityInfo(hObject,
                                      pRightsList,
                                      cRights,
                                      AccessList);
        NtClose(hObject);
    }

    acDebugOut((DEB_TRACE, "Out ReadKernelPropertyRights: %lu\n", dwErr));

    return (dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetKernelSecurityInfo
//
//  Arguments:  [IN  hObject]           --      The handle to the object to
//                                              get the rights for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
GetKernelSecurityInfo(IN  HANDLE                 hObject,
                      IN  PACTRL_RIGHTS_INFO     pRightsList,
                      IN  ULONG                  cRights,
                      IN  CAccessList&           AccessList)
{
    acDebugOut((DEB_TRACE, "in GetKernelSecurityInfo\n"));

    UCHAR                   pSDBuff[PSD_BASE_LENGTH];
    PISECURITY_DESCRIPTOR   pSD;
    DWORD                   dwErr = ERROR_SUCCESS;
    NTSTATUS                Status;
    ULONG                   cNeeded = 0;

    for(ULONG iIndex = 0; iIndex < cRights && dwErr == ERROR_SUCCESS; iIndex++)
    {
        pSD = (PISECURITY_DESCRIPTOR)pSDBuff;

        Status = NtQuerySecurityObject(hObject,
                                       pRightsList[iIndex].SeInfo,
                                       pSD,
                                       PSD_BASE_LENGTH,
                                       &cNeeded);
        if(!NT_SUCCESS(Status))
        {
            if(Status == STATUS_BUFFER_TOO_SMALL)
            {
                //
                // Fine.. Allocate a big enough buffer
                //
                pSD = (PISECURITY_DESCRIPTOR)AccAlloc(cNeeded);
                if(pSD == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                Status = NtQuerySecurityObject(hObject,
                                               pRightsList[iIndex].SeInfo,
                                               pSD,
                                               cNeeded,
                                               &cNeeded);
            }
        }

        //
        // Now, we've either got a failure or a valid SD...
        //
        if(NT_SUCCESS(Status))
        {
            dwErr = AccessList.AddSD(pSD,
                                     pRightsList[iIndex].SeInfo,
                                     pRightsList[iIndex].pwszProperty);
        }
        else
        {
            dwErr = RtlNtStatusToDosError(Status);
        }

        if(pSD != (PISECURITY_DESCRIPTOR)pSDBuff)
        {
            AccFree(pSD);
        }
    }

    acDebugOut((DEB_TRACE, "Out GetKernelSecurityInfo: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetKernelParentRights
//
//  Synopsis:   Determines who the parent is, and gets the access rights
//              for it.  It is used to aid in determining what the approriate
//              inheritance bits are.
//
//              This operation does not make sense for kernel objects
//
//  Arguments:  [IN  pwszObject]        --      The object to get the parent
//                                              for
//              [IN  pRightsList]       --      The properties to get the
//                                              rights for
//              [IN  cRights]           --      Number of items in rights list
//              [OUT ppDAcl]            --      Where the DACL is returned
//              [OUT ppSAcl]            --      Where the SACL is returned
//              [OUT ppSD]              --      Where the Security Descriptor
//                                              is returned
//
//  Returns:    ERROR_INVALID_FUNCTION  --      Call doesn't make sense here
//
//----------------------------------------------------------------------------
DWORD
GetKernelParentRights(IN  LPWSTR                    pwszObject,
                      IN  PACTRL_RIGHTS_INFO        pRightsList,
                      IN  ULONG                     cRights,
                      OUT PACL                     *ppDAcl,
                      OUT PACL                     *ppSAcl,
                      OUT PSECURITY_DESCRIPTOR     *ppSD)
{
    //
    // This doesn't currently make sense for kernel objects, so simply
    // return an error
    //
    return(ERROR_INVALID_FUNCTION);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetKernelSecurityInfo
//
//  Synopsis:   Sets the specified security info for the handle's
//              kernel object
//
//  Arguments:  [IN  hKernel]           --      The handle of the object
//              [IN  SeInfo]            --      Flag indicating what security
//                                              info to set
//              [IN  pwszProperty]      --      The property on the object to
//                                              set
//                                              For kernel objects, this MBZ
//              [IN  pSD]               --      The security descriptor to set
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was given
//
//----------------------------------------------------------------------------
DWORD
SetKernelSecurityInfo(IN  HANDLE                    hKernel,
                      IN  SECURITY_INFORMATION      SeInfo,
                      IN  PWSTR                     pwszProperty,
                      IN  PSECURITY_DESCRIPTOR      pSecurityDescriptor)
{
    acDebugOut((DEB_TRACE, "in SetNamedKernelSecurityInfo\n"));

    DWORD dwErr = ERROR_SUCCESS;

    if(pwszProperty != NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        NTSTATUS Status = NtSetSecurityObject(hKernel,
                                              SeInfo,
                                              pSecurityDescriptor);

        dwErr = RtlNtStatusToDosError(Status);
    }

    acDebugOut((DEB_TRACE, "Out SetKernelSecurityInfo %lu\n", dwErr));

    return (dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetKernelSecurityInfo
//
//  Arguments:  [IN  hObject]           --      The handle to the object to
//                                              get the rights for
//              [IN  SeInfo]            --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
GetKernelSecurityInfo(IN  HANDLE                    hObject,
                      IN  SECURITY_INFORMATION      SeInfo,
                      OUT PACL                     *ppDAcl,
                      OUT PACL                     *ppSAcl,
                      OUT PSECURITY_DESCRIPTOR     *ppSD)
{
    acDebugOut((DEB_TRACE, "in GetKernelSecurityInfo\n"));

    PISECURITY_DESCRIPTOR   pSD = NULL;
    DWORD                   dwErr = ERROR_SUCCESS;
    NTSTATUS                Status;
    ULONG                   cNeeded = 0;

    Status = NtQuerySecurityObject(hObject,
                                   SeInfo,
                                   pSD,
                                   0,
                                   &cNeeded);
    if(!NT_SUCCESS(Status))
    {
        if(Status == STATUS_BUFFER_TOO_SMALL)
        {
            //
            // Fine.. Allocate a big enough buffer
            //
            pSD = (PISECURITY_DESCRIPTOR)AccAlloc(cNeeded);
            if(pSD == NULL)
            {
                Status = STATUS_NO_MEMORY;
            }
            else
            {
                Status = NtQuerySecurityObject(hObject,
                                               SeInfo,
                                               pSD,
                                               cNeeded,
                                               &cNeeded);
            }
        }
    }

    //
    // Now, we've either got a failure or a valid SD...
    //
    if(NT_SUCCESS(Status))
    {
        if (pSD != NULL)
        {
            if(ppDAcl != NULL)
            {
                *ppDAcl = RtlpDaclAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)pSD);
            }

            if(ppSAcl != NULL)
            {
                *ppSAcl = RtlpSaclAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)pSD);
            }

            *ppSD = pSD;
        }
        else
        {
            dwErr = ERROR_ACCESS_DENIED;
        }

    }
    else
    {
        dwErr = RtlNtStatusToDosError(Status);
    }


    acDebugOut((DEB_TRACE, "Out GetKernelSecurityInfo: %lu\n", dwErr));
    return(dwErr);
}


//
// Routines provided by AlanWar for accessind WmiGuid objects
//
_inline HANDLE WmipAllocEvent(
    VOID
    )
{
    HANDLE EventHandle;

    EventHandle = (HANDLE)InterlockedExchangePointer(( PVOID *)&WmiGuidHandle, NULL );

    if ( EventHandle == NULL ) {

        EventHandle = CreateEvent( NULL, FALSE, FALSE, NULL );
    }

    return( EventHandle );
}

_inline void WmipFreeEvent(
    HANDLE EventHandle
    )
{
    if ( InterlockedCompareExchangePointer( &WmiGuidHandle,
                                            EventHandle,
                                            NULL) != NULL ) {

        CloseHandle( EventHandle );
    }
}

ULONG WmipSendWmiKMRequest(
    ULONG Ioctl,
    PVOID Buffer,
    ULONG InBufferSize,
    ULONG MaxBufferSize,
    ULONG *ReturnSize
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the WMI kernel
    mode device.  Any retry errors returned by the WMI device are handled
    in this routine.

Arguments:

    Ioctl is the IOCTL code to send to the WMI device
    Buffer is the input and output buffer for the call to the WMI device
    InBufferSize is the size of the buffer passed to the device
    MaxBufferSize is the maximum number of bytes that can be written
        into the buffer
    *ReturnSize on return has the actual number of bytes written in buffer

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    OVERLAPPED Overlapped;
    ULONG Status;
    BOOL IoctlSuccess;
    HANDLE WmipKMHandle = NULL;
    //
    // If device is not open for then open it now. The
    // handle is closed in the process detach dll callout (DlllMain)
    WmipKMHandle = CreateFile(WMIDataDeviceName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL |
                              FILE_FLAG_OVERLAPPED,
                              NULL);
    if (WmipKMHandle == (HANDLE)-1)
    {
        WmipKMHandle = NULL;
        return(GetLastError());
    }

    Overlapped.hEvent = WmipAllocEvent();
    if (Overlapped.hEvent == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    do
    {
        IoctlSuccess = DeviceIoControl(WmipKMHandle,
                              Ioctl,
                              Buffer,
                              InBufferSize,
                              Buffer,
                              MaxBufferSize,
                              ReturnSize,
                              &Overlapped);

        if (GetLastError() == ERROR_IO_PENDING)
        {
            IoctlSuccess = GetOverlappedResult(WmipKMHandle,
                                               &Overlapped,
                                               ReturnSize,
                                               TRUE);
        }

        if (! IoctlSuccess)
        {
            Status = GetLastError();
        } else {
            Status = ERROR_SUCCESS;
        }
    } while (Status == ERROR_WMI_TRY_AGAIN);


    NtClose( WmipKMHandle );

    WmipFreeEvent(Overlapped.hEvent);

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   OpenWmiGuidObject
//
//  Synopsis:   Gets a handle to the specified WmiGuid object
//
//  Arguments:  [IN  pwszObject]        --      Object to open
//              [IN  AccessMask]        --      Type of open to do
//              [OUT pHandle]           --      Where the handle to the object
//                                              is returned
//              [OUT KernelType]        --      Type of the kernel object
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
OpenWmiGuidObject(IN  LPWSTR       pwszObject,
                  IN  ACCESS_MASK  AccessMask,
                  OUT PHANDLE      pHandle,
                  OUT PMARTA_KERNEL_TYPE KernelType)
{
    DWORD dwErr;
    UNICODE_STRING GuidString;
    WMIOPENGUIDBLOCK WmiOpenGuidBlock;
    WCHAR GuidObjectNameBuffer[WmiGuidObjectNameLength+1];
    PWCHAR GuidObjectName = GuidObjectNameBuffer;
    ULONG ReturnSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Length;

    acDebugOut((DEB_TRACE, "In OpenWmiGuidObject\n"));

    Length = (wcslen(WmiGuidObjectDirectory) + wcslen(pwszObject) + 1) * sizeof(WCHAR);

    if ( Length > sizeof(GuidObjectNameBuffer) ) 
    {
        GuidObjectName = (PWCHAR)LocalAlloc( LPTR, Length );

        if ( GuidObjectName == NULL ) 
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    wcscpy(GuidObjectName, WmiGuidObjectDirectory);
    wcscat(GuidObjectName, pwszObject);
    RtlInitUnicodeString(&GuidString, GuidObjectName);

    memset(&ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.ObjectName = &GuidString;

    WmiOpenGuidBlock.ObjectAttributes = &ObjectAttributes;

    WmiOpenGuidBlock.DesiredAccess = AccessMask;

    dwErr = WmipSendWmiKMRequest(IOCTL_WMI_OPEN_GUID,
                                     (PVOID)&WmiOpenGuidBlock,
                                     sizeof(WMIOPENGUIDBLOCK),
                                     sizeof(WMIOPENGUIDBLOCK),
                                     &ReturnSize);

    if (dwErr == ERROR_SUCCESS)
    {
        *pHandle = WmiOpenGuidBlock.Handle.Handle;
        *KernelType = MARTA_WMI_GUID;
    }
    else
    {
        *pHandle = NULL;
    }

    if ( GuidObjectName != GuidObjectNameBuffer )
    {
        LocalFree( GuidObjectName );
    }

    acDebugOut((DEB_TRACE, "Out OpenWmiGuidObject: %lu\n", dwErr));

    return(dwErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   ReadWmiGuidPropertyRights
//
//  Synopsis:   Gets the specified rights from the WmiGuids object
//
//  Arguments:  [IN  pwszObject]        --      The object to get the rights
//                                              for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//
//  Note:      Kernel objects are assumed to be created through the
//             Win32 APIs so they all reside in the \basenamedobjects
//             directory.
//
//----------------------------------------------------------------------------
DWORD
ReadWmiGuidPropertyRights(IN  LPWSTR                 pwszObject,
                          IN  PACTRL_RIGHTS_INFO     pRightsList,
                          IN  ULONG                  cRights,
                          IN  CAccessList&           AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadKernelPropertyRights\n"));

    DWORD dwErr = ERROR_SUCCESS;
    HANDLE hObject;
    MARTA_KERNEL_TYPE KernelType;

    //
    // Kernel objects don't have parents from whom they can inherit
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = OpenWmiGuidObject(pwszObject,
                              GetDesiredAccess(READ_ACCESS_RIGHTS,
                                               pRightsList[0].SeInfo),
                              &hObject,
                              &KernelType);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = GetWmiGuidSecurityInfo(hObject,
                                       pRightsList,
                                       cRights,
                                       AccessList);
        CloseWmiGuidObject(hObject);
    }

    acDebugOut((DEB_TRACE, "Out ReadKernelPropertyRights: %lu\n", dwErr));

    return (dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetKernelSecurityInfo
//
//  Arguments:  [IN  hObject]           --      The handle to the object to
//                                              get the rights for
//              [IN  SeInfo]            --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
GetWmiGuidSecurityInfo(IN  HANDLE                    hObject,
                       IN  PACTRL_RIGHTS_INFO        pRightsList,
                       IN  ULONG                     cRights,
                       IN  CAccessList&              AccessList)
{
    acDebugOut((DEB_TRACE, "in GetWmiGuidSecurityInfo\n"));

    UCHAR                   pSDBuff[PSD_BASE_LENGTH];
    PISECURITY_DESCRIPTOR   pSD;
    DWORD                   dwErr = ERROR_SUCCESS;
    NTSTATUS                Status;
    ULONG                   cNeeded = 0;

    for(ULONG iIndex = 0; iIndex < cRights && dwErr == ERROR_SUCCESS; iIndex++)
    {
        pSD = (PISECURITY_DESCRIPTOR)pSDBuff;

        Status = NtQuerySecurityObject(hObject,
                                       pRightsList[iIndex].SeInfo,
                                       pSD,
                                       PSD_BASE_LENGTH,
                                       &cNeeded);
        if(!NT_SUCCESS(Status))
        {
            if(Status == STATUS_BUFFER_TOO_SMALL)
            {
                //
                // Fine.. Allocate a big enough buffer
                //
                pSD = (PISECURITY_DESCRIPTOR)AccAlloc(cNeeded);
                if(pSD == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                Status = NtQuerySecurityObject(hObject,
                                               pRightsList[iIndex].SeInfo,
                                               pSD,
                                               cNeeded,
                                               &cNeeded);
            }
        }

        //
        // Now, we've either got a failure or a valid SD...
        //
        if(NT_SUCCESS(Status))
        {
            dwErr = AccessList.AddSD(pSD,
                                     pRightsList[iIndex].SeInfo,
                                     pRightsList[iIndex].pwszProperty);
        }
        else
        {
            dwErr = RtlNtStatusToDosError(Status);
        }

        if(pSD != (PISECURITY_DESCRIPTOR)pSDBuff)
        {
            AccFree(pSD);
        }
    }

    acDebugOut((DEB_TRACE, "Out GetWmiGuidSecurityInfo: %lu\n", dwErr));
    return(dwErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   SetWmiGuidSecurityInfo
//
//  Synopsis:   Sets the specified security info for the handle's
//              WmiGuid object
//
//  Arguments:  [IN  hKernel]           --      The handle of the object
//              [IN  SeInfo]            --      Flag indicating what security
//                                              info to set
//              [IN  pwszProperty]      --      The property on the object to
//                                              set
//                                              For kernel objects, this MBZ
//              [IN  pSD]               --      The security descriptor to set
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was given
//
//----------------------------------------------------------------------------
DWORD
SetWmiGuidSecurityInfo(IN  HANDLE                    hWmiGuid,
                       IN  SECURITY_INFORMATION      SeInfo,
                       IN  PWSTR                     pwszProperty,
                       IN  PSECURITY_DESCRIPTOR      pSD)
{
    acDebugOut((DEB_TRACE, "in SetWmiGuidSecurityInfo\n"));

    DWORD dwErr = ERROR_SUCCESS;

    if(pwszProperty != NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        NTSTATUS Status = NtSetSecurityObject(hWmiGuid,
                                              SeInfo,
                                              pSD);

        dwErr = RtlNtStatusToDosError(Status);
    }

    acDebugOut((DEB_TRACE, "Out SetWmiGuidSecurityInfo %lu\n", dwErr));

    return (dwErr);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetKernelSecurityInfo
//
//  Arguments:  [IN  hObject]           --      The handle to the object to
//                                              get the rights for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
GetWmiGuidSecurityInfo(IN  HANDLE                    hObject,
                       IN  SECURITY_INFORMATION      SeInfo,
                       OUT PACL                     *ppDAcl,
                       OUT PACL                     *ppSAcl,
                       OUT PSECURITY_DESCRIPTOR     *ppSD)
{
    acDebugOut((DEB_TRACE, "in GetWmiGuidSecurityInfo\n"));

    PISECURITY_DESCRIPTOR   pSD = NULL;
    DWORD                   dwErr = ERROR_SUCCESS;
    NTSTATUS                Status;
    ULONG                   cNeeded = 0;

    Status = NtQuerySecurityObject(hObject,
                                   SeInfo,
                                   pSD,
                                   0,
                                   &cNeeded);
    if(!NT_SUCCESS(Status))
    {
        if(Status == STATUS_BUFFER_TOO_SMALL)
        {
            //
            // Fine.. Allocate a big enough buffer
            //
            pSD = (PISECURITY_DESCRIPTOR)AccAlloc(cNeeded);
            if(pSD == NULL)
            {
                Status = STATUS_NO_MEMORY;
            }
            else
            {
                Status = NtQuerySecurityObject(hObject,
                                               SeInfo,
                                               pSD,
                                               cNeeded,
                                               &cNeeded);
            }
        }
    }

    //
    // Now, we've either got a failure or a valid SD...
    //
    if(NT_SUCCESS(Status))
    {
        if (pSD != NULL)
        {
            if(ppDAcl != NULL)
            {
                *ppDAcl = RtlpDaclAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)pSD);
            }

            if(ppSAcl != NULL)
            {
                *ppSAcl = RtlpSaclAddrSecurityDescriptor((SECURITY_DESCRIPTOR *)pSD);
            }

            *ppSD = pSD;
        }
        else
        {
            dwErr = ERROR_ACCESS_DENIED;
        }
    }
    else
    {
        dwErr = RtlNtStatusToDosError(Status);
    }


    acDebugOut((DEB_TRACE, "Out GetWmiGuidSecurityInfo: %lu\n", dwErr));
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\init.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       INIT.C
//
//  Contents:   DLL Initialization routine
//
//  History:    22-Aug-96       MacM        Created
//
//----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <accdbg.h>
#include <lucache.h>
#include <seopaque.h>

HINSTANCE    ghDll;

RTL_RESOURCE gWrkrLock;
BOOL bWrkrLockInitialized = FALSE;

RTL_RESOURCE gCacheLock;
BOOL bCacheLockInitialized = FALSE;

RTL_RESOURCE gLocalSidCacheLock;
BOOL bLocalSidCacheLockInitialized = FALSE;

#if DBG

    #include <seopaque.h>
    #include <sertlp.h>

    #define IsObjectAceType(Ace) (                                              \
        (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE) && \
            (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE)    \
                )

    DEFINE_DEBUG2(ac);

    DEBUG_KEY   acDebugKeys[] = {{DEB_ERROR,         "Error"},
                                 {DEB_WARN,          "Warn"},
                                 {DEB_TRACE,         "Trace"},
                                 {DEB_TRACE_API,     "AccAPI"},
                                 {DEB_TRACE_ACC,     "AccList"},
                                 {DEB_TRACE_CACHE,   "AccCache"},
                                 {DEB_TRACE_PROP,    "AccProp"},
                                 {DEB_TRACE_SD,      "AccSD"},
                                 {DEB_TRACE_LOOKUP,  "AccLU"},
                                 {DEB_TRACE_MEM,     "AccMem"},
                                 {DEB_TRACE_HANDLE,  "AccHandle"},
                                 {0,                 NULL}};


    VOID
    DebugInitialize()
    {
        acInitDebug(acDebugKeys);
    }

    VOID
    DebugUninit()
    {
        acUnloadDebug();
    }

    PVOID   DebugAlloc(ULONG cSize)
    {
        PVOID   pv = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cSize);

        acDebugOut((DEB_TRACE_MEM, "Allocated %lu at 0x%lx\n", cSize, pv ));

        return(pv);
    }

    VOID    DebugFree(PVOID  pv)
    {
        if(pv == NULL)
        {
            return;
        }
        acDebugOut((DEB_TRACE_MEM, "Freeing 0x%lx\n", pv ));

        ASSERT(RtlValidateHeap(RtlProcessHeap(),0,NULL));

        LocalFree(pv);
    }
#endif // DBG


//+----------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Initialize state for NTMARTA.DLL
//
//  Arguments:  [hInstance]     --      Module handle
//              [dwReason]      --      Reason this function is being called
//              [lpReserved]    --      Reserved
//
//  Returns:    TRUE            --      Success
//              FALSE           --      Failure
//
//-----------------------------------------------------------------------------
BOOL
WINAPI
DllMain(HINSTANCE       hInstance,
        DWORD           dwReason,
        LPVOID          lpReserved)
{
    BOOL    fRet = TRUE;
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInstance);
        ghDll = hInstance;

        __try
        {
            RtlInitializeResource(&gWrkrLock);
            bWrkrLockInitialized = TRUE;
            RtlInitializeResource(&gCacheLock);
            bCacheLockInitialized = TRUE;
            RtlInitializeResource(&gLocalSidCacheLock);
            bLocalSidCacheLockInitialized = TRUE;
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            fRet = FALSE;
        }

        if (FALSE == fRet)
        {
            goto ProcessAttachCleanup;
        }

#if DBG
        DebugInitialize();
#endif

        if(AccctrlInitializeSidNameCache() != ERROR_SUCCESS)
        {
            fRet = FALSE;
            goto ProcessAttachCleanup;
        }

        if(AccctrlInitializeIdNameCache() != ERROR_SUCCESS)
        {
            fRet = FALSE;
            goto ProcessAttachCleanup;
        }

        if (AccctrlInitializeRightsCache() != ERROR_SUCCESS)
        {
            fRet = FALSE;
            goto ProcessAttachCleanup;
        }

        return TRUE;

ProcessAttachCleanup:

        if (TRUE == bWrkrLockInitialized)
        {
            bWrkrLockInitialized = FALSE;
            RtlDeleteResource(&gWrkrLock);
        }

        if (TRUE == bCacheLockInitialized)
        {
            bCacheLockInitialized = FALSE;
            RtlDeleteResource(&gCacheLock);
        }

        if (TRUE == bLocalSidCacheLockInitialized)
        {
            bLocalSidCacheLockInitialized = FALSE;
            RtlDeleteResource(&gLocalSidCacheLock);
        }

        AccctrlFreeSidNameCache();

        AccctrlFreeIdNameCache();

        break;

    case DLL_PROCESS_DETACH:

#if DBG
        DebugUninit();
#endif
        if (TRUE == bWrkrLockInitialized)
        {
            bWrkrLockInitialized = FALSE;
            RtlDeleteResource(&gWrkrLock);
        }

        if (TRUE == bCacheLockInitialized)
        {
            bCacheLockInitialized = FALSE;
            RtlDeleteResource(&gCacheLock);
        }

        if (TRUE == bLocalSidCacheLockInitialized)
        {
            bLocalSidCacheLockInitialized = FALSE;
            RtlDeleteResource(&gLocalSidCacheLock);
        }

        AccctrlFreeSidNameCache();
        AccctrlFreeIdNameCache();
        AccctrlFreeRightsCache();

        if(WmiGuidHandle)
        {
            CloseHandle(WmiGuidHandle);
        }
        break;

    default:
        break;

    }

    return(fRet);

}


#if DBG
VOID
DebugDumpSid(PSTR   pszTag,
             PSID   pSid)
{
    if(pSid == NULL)
    {
        acDebugOut((DEB_TRACE_SD, "%s NULL\n", pszTag));
    }
    else
    {
        UNICODE_STRING SidString;
        NTSTATUS Status;

        Status = RtlConvertSidToUnicodeString(&SidString,
                                              pSid,
                                              TRUE);
        if(!NT_SUCCESS(Status))
        {
            acDebugOut((DEB_ERROR, "%s Can't convert sid to string: 0x%lx\n",
                        pszTag, Status));
        }
        else
        {
            acDebugOut((DEB_TRACE_SD, "%s %wZ\n", pszTag, &SidString));
            RtlFreeUnicodeString(&SidString);
        }
    }
}

VOID
DebugDumpSD(PSTR                    pszTag,
            PSECURITY_DESCRIPTOR    pSD)
{
    if(pSD == NULL)
    {
        acDebugOut((DEB_TRACE_SD,"%s NULL\n", pszTag));
    }
    else
    {
        PISECURITY_DESCRIPTOR   pISD = (PISECURITY_DESCRIPTOR)pSD;


        acDebugOut((DEB_TRACE_SD,"%s: 0x%lx\n", pszTag, pSD));
        acDebugOut((DEB_TRACE_SD,"\tRevision: 0x%lx\n",pISD->Revision));
        acDebugOut((DEB_TRACE_SD,"\tSbz1: 0x%lx\n", pISD->Sbz1));
        acDebugOut((DEB_TRACE_SD,"\tControl: 0x%lx\n",pISD->Control));

        DebugDumpSid("\tOwner", RtlpOwnerAddrSecurityDescriptor(pISD));
        DebugDumpSid("\tGroup", RtlpGroupAddrSecurityDescriptor(pISD));
        DebugDumpAcl("\tDAcl",  RtlpDaclAddrSecurityDescriptor(pISD));
        DebugDumpAcl("\tSAcl",  RtlpSaclAddrSecurityDescriptor(pISD));
    }
}



VOID
DebugDumpAcl(PSTR   pszTag,
             PACL   pAcl)
{
    ACL_SIZE_INFORMATION        AclSize;
    ACL_REVISION_INFORMATION    AclRev;
    PKNOWN_ACE                  pAce;
    PSID                        pSid;
    DWORD                       iIndex;

    if(pAcl == NULL)
    {
        acDebugOut((DEB_TRACE_SD,"%s NULL\n", pszTag));
    }
    else
    {
        acDebugOut((DEB_TRACE_SD, "%s: 0x%lx\n", pszTag, pAcl));

        if(GetAclInformation(pAcl,
                             &AclRev,
                             sizeof(ACL_REVISION_INFORMATION),
                             AclRevisionInformation) == FALSE)
        {
            acDebugOut((DEB_TRACE_SD,
                        "GetAclInformation [Revision] failed: %lu\n",
                        GetLastError()));
            return;
        }

        if(GetAclInformation(pAcl,
                             &AclSize,
                             sizeof(ACL_SIZE_INFORMATION),
                             AclSizeInformation) == FALSE)
        {
            acDebugOut((DEB_TRACE_SD,
                        "GetAclInformation [Size] failed: %lu\n",
                        GetLastError()));
            return;
        }

        acDebugOut((DEB_TRACE_SD, "\t\tRevision: %lu\n", AclRev.AclRevision));
        acDebugOut((DEB_TRACE_SD, "\t\tAceCount: %lu\n", AclSize.AceCount));
        acDebugOut((DEB_TRACE_SD, "\t\tInUse: %lu\n", AclSize.AclBytesInUse));
        acDebugOut((DEB_TRACE_SD, "\t\tFree: %lu\n", AclSize.AclBytesFree));
        acDebugOut((DEB_TRACE_SD, "\t\tFlags: %lu\n", pAcl->Sbz1));


        //
        // Now, dump all of the aces
        //
        pAce = FirstAce(pAcl);
        for(iIndex = 0; iIndex < pAcl->AceCount; iIndex++)
        {
            acDebugOut((DEB_TRACE_SD,"\t\tAce %lu\n", iIndex));

            acDebugOut((DEB_TRACE_SD,"\t\t\tType: %lu\n",
                        pAce->Header.AceType));
            acDebugOut((DEB_TRACE_SD,"\t\t\tFlags: 0x%lx\n",
                        pAce->Header.AceFlags));
            acDebugOut((DEB_TRACE_SD,"\t\t\tSize: 0x%lx\n",
                        pAce->Header.AceSize));
            acDebugOut((DEB_TRACE_SD,"\t\t\tMask: 0x%lx\n",
                        pAce->Mask));

            //
            // If it's an object ace, dump the guids
            //
            if(IsObjectAceType(pAce))
            {
                DebugDumpGuid("\t\t\tObjectId", RtlObjectAceObjectType(pAce));
                DebugDumpGuid("\t\t\tInheritId",
                              RtlObjectAceInheritedObjectType(pAce));
                DebugDumpSid("\t\t\tSid", RtlObjectAceSid(pAce));
            }
            else
            {
                DebugDumpSid("\t\t\tSid", ((PSID)&(pAce->SidStart)));
            }

            pAce = NextAce(pAce);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\krnctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       krnctx.cpp
//
//  Contents:   Implementation of CKernelContext and NT Marta Kernel Functions
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <krnctx.h>
#include <wmistr.h>
#include <wmiumkm.h>
//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::CKernelContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CKernelContext::CKernelContext ()
{
    m_cRefs = 1;
    m_hObject = NULL;
    m_fNameInitialized = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::~CKernelContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CKernelContext::~CKernelContext ()
{
    if ( ( m_hObject != NULL ) && ( m_fNameInitialized == TRUE ) )
    {
        CloseHandle( m_hObject );
    }

    assert( m_cRefs == 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::InitializeByName, public
//
//  Synopsis:   initialize the context given the name of the Kernel
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask)
{
    DWORD LastError;

    m_fNameInitialized = TRUE;

    m_hObject = OpenMutexW( AccessMask, FALSE, pObjectName );
    if ( m_hObject != NULL )
    {
        return( ERROR_SUCCESS );
    }

    LastError = GetLastError();

    if ( LastError == ERROR_INVALID_HANDLE )
    {
        m_hObject = OpenEventW( AccessMask, FALSE, pObjectName );
        if ( m_hObject != NULL )
        {
            return( ERROR_SUCCESS );
        }
    }
    else
    {
        goto ErrorReturn;
    }

    LastError = GetLastError();

    if ( LastError == ERROR_INVALID_HANDLE )
    {
        m_hObject = OpenSemaphoreW( AccessMask, FALSE, pObjectName );
        if ( m_hObject != NULL )
        {
            return( ERROR_SUCCESS );
        }
    }
    else
    {
        goto ErrorReturn;
    }

    LastError = GetLastError();

    if ( LastError == ERROR_INVALID_HANDLE )
    {
        m_hObject = OpenFileMappingW( AccessMask, FALSE, pObjectName );
        if ( m_hObject != NULL )
        {
            return( ERROR_SUCCESS );
        }
    }
    else
    {
        goto ErrorReturn;
    }

    LastError = GetLastError();

    if ( LastError == ERROR_INVALID_HANDLE )
    {
        m_hObject = OpenJobObjectW( AccessMask, FALSE, pObjectName );
        if ( m_hObject != NULL )
        {
            return( ERROR_SUCCESS );
        }
    }
    else
    {
        goto ErrorReturn;
    }

    LastError = GetLastError();

    if ( LastError == ERROR_INVALID_HANDLE )
    {
        m_hObject = OpenWaitableTimerW( AccessMask, FALSE, pObjectName );
        if ( m_hObject != NULL )
        {
            return( ERROR_SUCCESS );
        }
    }

    LastError = GetLastError();

ErrorReturn:

    m_fNameInitialized = FALSE;

    return( LastError );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::InitializeByWmiName, public
//
//  Synopsis:   initlialize a WMI kernel context
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::InitializeByWmiName (
                          LPCWSTR pObjectName,
                          ACCESS_MASK AccessMask
                          )
{
    DWORD  Result;
    HANDLE hObject;

    Result = OpenWmiGuidObject( (LPWSTR)pObjectName, AccessMask, &hObject );

    if ( Result == ERROR_SUCCESS )
    {
        m_hObject = hObject;
        m_fNameInitialized = TRUE;
    }

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::InitializeByHandle, public
//
//  Synopsis:   initialize the context given a Kernel handle
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::InitializeByHandle (HANDLE Handle)
{
    m_hObject = Handle;

    assert( m_fNameInitialized == FALSE );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::AddRef, public
//
//  Synopsis:   add a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::AddRef ()
{
    m_cRefs += 1;
    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::Release, public
//
//  Synopsis:   release a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::Release ()
{
    m_cRefs -= 1;

    if ( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::GetKernelProperties, public
//
//  Synopsis:   get properties about the context
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::GetKernelProperties (
                    PMARTA_OBJECT_PROPERTIES pObjectProperties
                    )
{
    if ( pObjectProperties->cbSize < sizeof( MARTA_OBJECT_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pObjectProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::GetKernelRights, public
//
//  Synopsis:   get the Kernel security descriptor
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::GetKernelRights (
                    SECURITY_INFORMATION SecurityInfo,
                    PSECURITY_DESCRIPTOR* ppSecurityDescriptor
                    )
{
    BOOL                 fResult;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD                cb = 0;

    assert( m_hObject != NULL );

    fResult = GetKernelObjectSecurity(
                 m_hObject,
                 SecurityInfo,
                 pSecurityDescriptor,
                 0,
                 &cb
                 );

    if ( ( fResult == FALSE ) && ( cb > 0 ) )
    {
        assert( ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) ||
                ( GetLastError() == STATUS_BUFFER_TOO_SMALL ) );

        pSecurityDescriptor = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
        if ( pSecurityDescriptor == NULL )
        {
            return( ERROR_OUTOFMEMORY );
        }

        fResult = GetKernelObjectSecurity(
                     m_hObject,
                     SecurityInfo,
                     pSecurityDescriptor,
                     cb,
                     &cb
                     );
    }
    else
    {
        assert( fResult == FALSE );

        return( GetLastError() );
    }

    if ( fResult == TRUE )
    {
        *ppSecurityDescriptor = pSecurityDescriptor;
    }
    else
    {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CKernelContext::SetKernelRights, public
//
//  Synopsis:   set the window security descriptor
//
//----------------------------------------------------------------------------
DWORD
CKernelContext::SetKernelRights (
                   SECURITY_INFORMATION SecurityInfo,
                   PSECURITY_DESCRIPTOR pSecurityDescriptor
                   )
{
    assert( m_hObject != NULL );

    if ( SetKernelObjectSecurity(
            m_hObject,
            SecurityInfo,
            pSecurityDescriptor
            ) == FALSE )
    {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

//
// Functions from Kernel.h which dispatch unto the CKernelContext class
//

DWORD
MartaAddRefKernelContext(
   IN MARTA_CONTEXT Context
   )
{
    return( ( (CKernelContext *)Context )->AddRef() );
}

DWORD
MartaCloseKernelContext(
     IN MARTA_CONTEXT Context
     )
{
    return( ( (CKernelContext *)Context )->Release() );
}

DWORD
MartaGetKernelProperties(
   IN MARTA_CONTEXT Context,
   IN OUT PMARTA_OBJECT_PROPERTIES pProperties
   )
{
    return( ( (CKernelContext *)Context )->GetKernelProperties( pProperties ) );
}

DWORD
MartaGetKernelTypeProperties(
   IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
   )
{
    if ( pProperties->cbSize < sizeof( MARTA_OBJECT_TYPE_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

DWORD
MartaGetKernelRights(
   IN  MARTA_CONTEXT Context,
   IN  SECURITY_INFORMATION   SecurityInfo,
   OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
   )
{
    return( ( (CKernelContext *)Context )->GetKernelRights(
                                               SecurityInfo,
                                               ppSecurityDescriptor
                                               ) );
}

DWORD
MartaOpenKernelNamedObject(
    IN  LPCWSTR pObjectName,
    IN  ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CKernelContext* pKernelContext;

    pKernelContext = new CKernelContext;
    if ( pKernelContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pKernelContext->InitializeByName( pObjectName, AccessMask );
    if ( Result != ERROR_SUCCESS )
    {
        pKernelContext->Release();
        return( Result );
    }

    *pContext = pKernelContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaOpenKernelHandleObject(
    IN HANDLE   Handle,
    IN ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CKernelContext* pKernelContext;

    pKernelContext = new CKernelContext;
    if ( pKernelContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pKernelContext->InitializeByHandle( Handle );
    if ( Result != ERROR_SUCCESS )
    {
        pKernelContext->Release();
        return( Result );
    }

    *pContext = pKernelContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaSetKernelRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return( ( (CKernelContext *)Context )->SetKernelRights(
                                               SecurityInfo,
                                               pSecurityDescriptor
                                               ) );
}

//
// Routines provided by AlanWar for accessing WmiGuid objects
//

HANDLE RWmiGuidHandle = NULL;

_inline HANDLE WmipAllocEvent(
    VOID
    )
{
    HANDLE EventHandle;

    EventHandle = (HANDLE)InterlockedExchangePointer(( PVOID *)&RWmiGuidHandle, NULL );

    if ( EventHandle == NULL ) {

        EventHandle = CreateEvent( NULL, FALSE, FALSE, NULL );
    }

    return( EventHandle );
}

_inline void WmipFreeEvent(
    HANDLE EventHandle
    )
{
    if ( InterlockedCompareExchangePointer( &RWmiGuidHandle,
                                            EventHandle,
                                            NULL) != NULL ) {

        CloseHandle( EventHandle );
    }
}

ULONG RWmipSendWmiKMRequest(
    ULONG Ioctl,
    PVOID Buffer,
    ULONG InBufferSize,
    ULONG MaxBufferSize,
    ULONG *ReturnSize
    )
/*+++

Routine Description:

    This routine does the work of sending WMI requests to the WMI kernel
    mode device.  Any retry errors returned by the WMI device are handled
    in this routine.

Arguments:

    Ioctl is the IOCTL code to send to the WMI device
    Buffer is the input and output buffer for the call to the WMI device
    InBufferSize is the size of the buffer passed to the device
    MaxBufferSize is the maximum number of bytes that can be written
        into the buffer
    *ReturnSize on return has the actual number of bytes written in buffer

Return Value:

    ERROR_SUCCESS or an error code
---*/
{
    OVERLAPPED Overlapped;
    ULONG Status;
    BOOL IoctlSuccess;
    HANDLE WmipKMHandle = NULL;
    //
    // If device is not open for then open it now. The
    // handle is closed in the process detach dll callout (DlllMain)
    WmipKMHandle = CreateFile(WMIDataDeviceName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL |
                              FILE_FLAG_OVERLAPPED,
                              NULL);
    if (WmipKMHandle == (HANDLE)-1)
    {
        WmipKMHandle = NULL;
        return(GetLastError());
    }

    Overlapped.hEvent = WmipAllocEvent();
    if (Overlapped.hEvent == NULL)
    {
        NtClose( WmipKMHandle );
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    do
    {
        IoctlSuccess = DeviceIoControl(WmipKMHandle,
                              Ioctl,
                              Buffer,
                              InBufferSize,
                              Buffer,
                              MaxBufferSize,
                              ReturnSize,
                              &Overlapped);

        if (GetLastError() == ERROR_IO_PENDING)
        {
            IoctlSuccess = GetOverlappedResult(WmipKMHandle,
                                               &Overlapped,
                                               ReturnSize,
                                               TRUE);
        }

        if (! IoctlSuccess)
        {
            Status = GetLastError();
        } else {
            Status = ERROR_SUCCESS;
        }
    } while (Status == ERROR_WMI_TRY_AGAIN);


    NtClose( WmipKMHandle );

    WmipFreeEvent(Overlapped.hEvent);

    return(Status);
}

//+---------------------------------------------------------------------------
//
//  Function:   OpenWmiGuidObject
//
//  Synopsis:   Gets a handle to the specified WmiGuid object
//
//  Arguments:  [IN  pwszObject]        --      Object to open
//              [IN  AccessMask]        --      Type of open to do
//              [OUT pHandle]           --      Where the handle to the object
//                                              is returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
OpenWmiGuidObject(IN  LPWSTR       pwszObject,
                  IN  ACCESS_MASK  AccessMask,
                  OUT PHANDLE      pHandle)
{
    DWORD dwErr;
    UNICODE_STRING GuidString;
    WMIOPENGUIDBLOCK WmiOpenGuidBlock;
    WCHAR GuidObjectNameBuffer[WmiGuidObjectNameLength+1];
    PWCHAR GuidObjectName = GuidObjectNameBuffer;
    ULONG ReturnSize;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Length;

    Length = (wcslen(WmiGuidObjectDirectory) + wcslen(pwszObject) + 1) * sizeof(WCHAR);

    if ( Length > sizeof(GuidObjectNameBuffer) ) 
    {
        GuidObjectName = (PWCHAR)LocalAlloc( LPTR, Length );

        if ( GuidObjectName == NULL ) 
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    wcscpy(GuidObjectName, WmiGuidObjectDirectory);
    wcscat(GuidObjectName, pwszObject);	
    RtlInitUnicodeString(&GuidString, GuidObjectName);
	
    memset(&ObjectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);
    ObjectAttributes.ObjectName = &GuidString;
	
    WmiOpenGuidBlock.ObjectAttributes = &ObjectAttributes;

    WmiOpenGuidBlock.DesiredAccess = AccessMask;

    dwErr = RWmipSendWmiKMRequest(IOCTL_WMI_OPEN_GUID,
                                     (PVOID)&WmiOpenGuidBlock,
                                     sizeof(WMIOPENGUIDBLOCK),
                                     sizeof(WMIOPENGUIDBLOCK),
                                     &ReturnSize);

    if (dwErr == ERROR_SUCCESS)
    {
        *pHandle = WmiOpenGuidBlock.Handle.Handle;
    }
    else
    {
        *pHandle = NULL;
    }

    if ( GuidObjectName != GuidObjectNameBuffer )
    {
        LocalFree( GuidObjectName );
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\ldapsp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       ldapsp.h
//
//  Contents:   LDAP Scheme Provider definitions
//
//  History:    28-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__LDAPSP_H__)
#define __LDAPSP_H__

#include <windows.h>
#include <wininet.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <stdlib.h>

#define LDAP_SCHEME_U L"ldap://"
#define LDAP_SCHEME_UC L"LDAP://"

//
// LDAP Scheme Provider Support API
//

typedef struct _LDAP_URL_COMPONENTS {

    LPWSTR  pwszHost;
    ULONG   Port;
    LPWSTR  pwszDN;
    ULONG   cAttr;
    LPWSTR* apwszAttr;
    ULONG   Scope;
    LPWSTR  pwszFilter;

} LDAP_URL_COMPONENTS, *PLDAP_URL_COMPONENTS;

BOOL
LdapCrackUrl (
    LPCWSTR pwszUrl,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedHost (
    LPWSTR pwszHost,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedDN (
    LPWSTR pwszDN,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedAttributeList (
    LPWSTR pwszAttrList,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedScopeAndFilter (
    LPWSTR pwszScope,
    LPWSTR pwszFilter,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

VOID
LdapFreeUrlComponents (
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapGetBindings (
    LPWSTR pwszHost,
    ULONG  Port,
    DWORD  dwRetrievalFlags,
    DWORD  dwTimeout,
    LDAP** ppld
    );

VOID
LdapFreeBindings (
    LDAP* pld
    );

BOOL
LdapBindWithOptionalRediscover (LDAP* pld, LPWSTR pwszHost);

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\ldapsp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       ldapsp.cpp
//
//  Contents:   LDAP Scheme Provider for Remote Object Retrieval
//
//  History:    23-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------

#include <aclpch.hxx>
#pragma hdrstop

#include <ldapsp.h>
#include <shlwapi.h>
//+---------------------------------------------------------------------------
//
//  Function:   LdapCrackUrl
//
//  Synopsis:   Crack an LDAP URL into its relevant parts.  The result must
//              be freed using LdapFreeUrlComponents
//
//----------------------------------------------------------------------------
BOOL
LdapCrackUrl (
    LPCWSTR pwszUrl,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    BOOL   fResult = TRUE;
    ULONG  cbUrl = INTERNET_MAX_PATH_LENGTH;
    LPWSTR pwszHostInfo = NULL;
    LPWSTR pwszDN = NULL;
    LPWSTR pwszAttrList = NULL;
    LPWSTR pwszScope = NULL;
    LPWSTR pwszFilter = NULL;
    LPWSTR pwszToken = NULL;
    WCHAR  pwszBuffer[INTERNET_MAX_PATH_LENGTH+1];
    PWCHAR pwsz = pwszBuffer;
    DWORD  len = 0;
    HRESULT hr;

    //
    // Capture the URL and initialize the out parameter
    //

    if ( wcsncmp( pwszUrl, LDAP_SCHEME_U, wcslen( LDAP_SCHEME_U ) ) == 0 )
    {
        __try
        {
            hr = UrlCanonicalizeW(
                         pwszUrl,
                         pwsz,
                         &cbUrl,
                         ICU_DECODE | URL_WININET_COMPATIBILITY);

            if(FAILED(hr))
            {
                return( FALSE );
            }

            //
            // Make sure that we do not have a trailing '/'.
            //

            len = wcslen(pwsz);
            if (pwsz[len-1] == L'/') 
            {
                pwsz[--len] = L'\0';
            }
        }

        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            SetLastError( GetExceptionCode() );
            return( FALSE );
        }
    }
    else
    {
        len = wcslen(pwszUrl);

        if (len > INTERNET_MAX_PATH_LENGTH)
        {
            pwsz = new WCHAR [len + 1];

            if (pwsz == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return( FALSE );
            }
        }

        wcscpy(pwsz, pwszUrl);
    }

    memset( pLdapUrlComponents, 0, sizeof( LDAP_URL_COMPONENTS ) );

    //
    // Find the host
    //

    pwszHostInfo = pwsz + sizeof( "ldap://" ) - sizeof( CHAR );
    if ( *pwszHostInfo == L'/' )
    {
        //
        // This is ldap:///ObjectName format.
        //

        pwszToken = pwszHostInfo + 1;
        pwszHostInfo = NULL;
    }
    else
    {
        if (wcschr(pwszHostInfo, L'/'))
        {
            //
            // This is ldap://ServerName/ObjectName format.
            //

            pwszHostInfo = wcstok( pwszHostInfo, L"/" );
        }
        else
        {
            //
            // This is ldap://ObjectName format.
            //

            pwszToken = pwszHostInfo;
            pwszHostInfo = NULL;

        }
    }

    //
    // Find the DN
    //

    if ( wcsncmp( pwszUrl, LDAP_SCHEME_U, wcslen( LDAP_SCHEME_U ) ) == 0 )
    {
        if ( pwszToken != NULL )
        {
            pwszDN = L"";

            if ( *pwszToken != L'\0' )
            {
                if ( *pwszToken == L'?' )
                {
                    pwszToken += 1;
                }
                else
                {
                    pwszDN = pwszToken;

                    do
                    {
                        pwszToken += 1;
                    }
                    while ( ( *pwszToken != L'\0' ) && ( *pwszToken != L'?' ) );

                    if ( *pwszToken == L'?' )
                    {
                        *pwszToken = L'\0';
                        pwszToken += 1;
                    }
                }
            }
        }
        else
        {
            pwszDN = wcstok( pwszToken, L"?" );
            pwszToken = NULL;
            if ( pwszDN == NULL )
            {
                SetLastError( E_INVALIDARG );
                return( FALSE );
            }
        }

        //
        // Check for attributes
        //

        if ( pwszToken != NULL )
        {
            if ( *pwszToken == L'?' )
            {
                pwszAttrList = L"";
                pwszToken += 1;
            }
            else if ( *pwszToken == L'\0' )
            {
                pwszAttrList = NULL;
            }
            else
            {
                pwszAttrList = wcstok( pwszToken, L"?" );
                pwszToken = NULL;
            }
        }
        else
        {
            pwszAttrList = wcstok( NULL, L"?" );
        }

        //
        // Check for a scope and filter
        //

        if ( pwszAttrList != NULL )
        {
            pwszScope = wcstok( pwszToken, L"?" );
            if ( pwszScope != NULL )
            {
                pwszFilter = wcstok( NULL, L"?" );
            }
        }

        if ( pwszScope == NULL )
        {
            pwszScope = L"base";
        }

        if ( pwszFilter == NULL )
        {
            pwszFilter = L"(objectClass=*)";
        }
    }
    else
    {
        if ( pwszToken != NULL )
        {
            pwszDN = pwszToken;
        }
        else
        {
            //
            // pwszDN = wcstok( pwszToken, L"\0" );
            //

            pwszDN = pwszHostInfo + wcslen( pwszHostInfo ) + 1;
        }

        pwszAttrList = NULL;
        pwszFilter = L"(objectClass=*)";
        pwszScope = L"base";
    }
    //
    // Now we build up our URL components
    //

    fResult = LdapParseCrackedHost( pwszHostInfo, pLdapUrlComponents );

    if ( fResult == TRUE )
    {
        fResult = LdapParseCrackedDN( pwszDN, pLdapUrlComponents );
    }

    if ( fResult == TRUE )
    {
        fResult = LdapParseCrackedAttributeList(
                      pwszAttrList,
                      pLdapUrlComponents
                      );
    }

    if ( fResult == TRUE )
    {
        fResult = LdapParseCrackedScopeAndFilter(
                      pwszScope,
                      pwszFilter,
                      pLdapUrlComponents
                      );
    }

    if ( fResult != TRUE )
    {
        LdapFreeUrlComponents( pLdapUrlComponents );
    }

    if (pwsz != pwszBuffer)
    {
        delete pwsz;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedHost
//
//  Synopsis:   Parse the cracked host string (pwszHost is modified)
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedHost (
    LPWSTR pwszHost,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    LPWSTR pwszPort;

    if ( pwszHost == NULL )
    {
        pLdapUrlComponents->pwszHost = NULL;
        pLdapUrlComponents->Port = LDAP_PORT;
        return( TRUE );
    }

    pwszPort = wcschr( pwszHost, L':' );
    if ( pwszPort != NULL )
    {
        *pwszPort = L'\0';
        pwszPort++;
    }

    pLdapUrlComponents->pwszHost = new WCHAR [wcslen( pwszHost ) + 1];
    if ( pLdapUrlComponents->pwszHost == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    wcscpy( pLdapUrlComponents->pwszHost, pwszHost );
    pLdapUrlComponents->Port = 0;

    if ( pwszPort != NULL )
    {
        pLdapUrlComponents->Port = _wtol( pwszPort );
    }

    if ( pLdapUrlComponents->Port == 0 )
    {
        pLdapUrlComponents->Port = LDAP_PORT;
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedDN
//
//  Synopsis:   Parse the cracked DN
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedDN (
    LPWSTR pwszDN,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    pLdapUrlComponents->pwszDN = new WCHAR [wcslen( pwszDN ) + 1];
    if ( pLdapUrlComponents->pwszDN == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    wcscpy( pLdapUrlComponents->pwszDN, pwszDN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedAttributeList
//
//  Synopsis:   Parse the cracked attribute list
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedAttributeList (
    LPWSTR pwszAttrList,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    LPWSTR pwsz;
    LPWSTR pwszAttr;
    ULONG  cAttr = 0;
    ULONG  cCount;

    if ( ( pwszAttrList == NULL ) || ( wcslen( pwszAttrList ) == 0 ) )
    {
        pLdapUrlComponents->cAttr = 0;
        pLdapUrlComponents->apwszAttr = NULL;
        return( TRUE );
    }

    pwsz = new WCHAR [wcslen( pwszAttrList ) + 1];
    if ( pwsz == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    wcscpy( pwsz, pwszAttrList );

    pwszAttr = wcstok( pwsz, L"," );
    while ( pwszAttr != NULL )
    {
        cAttr += 1;
        pwszAttr = wcstok( NULL, L"," );
    }

    pLdapUrlComponents->apwszAttr = new LPWSTR [cAttr+1];
    if ( pLdapUrlComponents->apwszAttr == NULL )
    {
        delete pwsz;
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    pLdapUrlComponents->cAttr = cAttr;
    for ( cCount = 0; cCount < cAttr; cCount++ )
    {
        pLdapUrlComponents->apwszAttr[cCount] = pwsz;
        pwsz += ( wcslen(pwsz) + 1 );
    }

    pLdapUrlComponents->apwszAttr[cAttr] = NULL;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedScopeAndFilter
//
//  Synopsis:   Parse the cracked scope and filter
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedScopeAndFilter (
    LPWSTR pwszScope,
    LPWSTR pwszFilter,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    ULONG Scope;

    if ( _wcsicmp( pwszScope, L"base" ) == 0 )
    {
        Scope = LDAP_SCOPE_BASE;
    }
    else if ( _wcsicmp( pwszScope, L"one" ) == 0 )
    {
        Scope = LDAP_SCOPE_ONELEVEL;
    }
    else if ( _wcsicmp( pwszScope, L"sub" ) == 0 )
    {
        Scope = LDAP_SCOPE_SUBTREE;
    }
    else
    {
        SetLastError( E_INVALIDARG );
        return( FALSE );
    }

    pLdapUrlComponents->pwszFilter = new WCHAR [wcslen( pwszFilter ) + 1];
    if ( pLdapUrlComponents->pwszFilter == NULL )
    {
        SetLastError( E_OUTOFMEMORY );
        return( FALSE );
    }

    wcscpy( pLdapUrlComponents->pwszFilter, pwszFilter );
    pLdapUrlComponents->Scope = Scope;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapFreeUrlComponents
//
//  Synopsis:   Frees allocate URL components returned from LdapCrackUrl
//
//----------------------------------------------------------------------------
VOID
LdapFreeUrlComponents (
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    delete pLdapUrlComponents->pwszHost;
    pLdapUrlComponents->pwszHost = NULL;
    delete pLdapUrlComponents->pwszDN;
    pLdapUrlComponents->pwszDN = NULL;


    if ( pLdapUrlComponents->apwszAttr != NULL )
    {
        delete pLdapUrlComponents->apwszAttr[0];
        pLdapUrlComponents->apwszAttr = NULL;
    }

    delete pLdapUrlComponents->apwszAttr;
    pLdapUrlComponents->apwszAttr = NULL;
    delete pLdapUrlComponents->pwszFilter;
    pLdapUrlComponents->pwszFilter = NULL;
}


//+---------------------------------------------------------------------------
//
//  Function:   LdapGetBindings
//
//  Synopsis:   allocates and initializes the LDAP session binding
//
//----------------------------------------------------------------------------
BOOL
LdapGetBindings (
    LPWSTR pwszHost,
    ULONG Port,
    DWORD dwRetrievalFlags,
    DWORD dwTimeout,
    LDAP** ppld
    )
{
    BOOL  fResult = TRUE;
    LDAP* pld;

    pld = ldap_initW( pwszHost, Port );
    if ( pld != NULL )
    {
        ULONG ldaperr;

        if ( dwTimeout != 0 )
        {
            ldap_set_option( pld, LDAP_OPT_TIMELIMIT, (void *)&dwTimeout );
        }

        fResult = LdapBindWithOptionalRediscover( pld, pwszHost );
    }
    else
    {
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        *ppld = pld;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapFreeBindings
//
//  Synopsis:   frees allocated LDAP session binding
//
//----------------------------------------------------------------------------
VOID
LdapFreeBindings (
    LDAP* pld
    )
{
    if ( pld != NULL )
    {
        ldap_unbind_s( pld );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapBindWithOptionalRediscover
//
//  Synopsis:   bind to the host with optional DC rediscovery if the host is
//              NULL (which means use default via DsGetDcName)
//
//----------------------------------------------------------------------------
BOOL
LdapBindWithOptionalRediscover (LDAP* pld, LPWSTR pwszHost)
{
    BOOL  fResult = TRUE;
    ULONG ldaperr;
    ULONG ldapsaveerr;
    DWORD dwFlags = DS_FORCE_REDISCOVERY;

    ldaperr = ldap_connect( pld, NULL );

    if ( ( ldaperr != LDAP_SUCCESS ) && ( pwszHost == NULL ) )
    {
        ldapsaveerr = ldaperr;

        ldaperr = ldap_set_option(
                       pld,
                       LDAP_OPT_GETDSNAME_FLAGS,
                       (LPVOID)&dwFlags
                       );

        if ( ldaperr == LDAP_SUCCESS )
        {
            ldaperr = ldap_connect( pld, NULL );

        }
        else
        {
            ldaperr = ldapsaveerr;
        }
    }

    if ( ldaperr == LDAP_SUCCESS )
    {
        ldaperr = ldap_bind_sW(
                       pld,
                       NULL,
                       NULL,
                       LDAP_AUTH_SSPI
                       );

    }

    if ( ldaperr != LDAP_SUCCESS )
    {
        fResult = FALSE;
        SetLastError( LdapMapErrorToWin32(ldaperr) );
    }

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\lmsctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       lmsctx.cpp
//
//  Contents:   Implementation of CLMShareContext and NT Marta LanMan Functions
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <lmshare.h>
#include <lmcons.h>
#include <lmsctx.h>
#include <svcctx.h>
//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::CLMShareContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CLMShareContext::CLMShareContext ()
{
    m_cRefs = 1;
    m_pwszMachine = NULL;
    m_pwszShare = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::~CLMShareContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CLMShareContext::~CLMShareContext ()
{
    if ( m_pwszMachine != NULL )
    {
        delete m_pwszMachine;
    }

    if ( m_pwszShare != NULL )
    {
        delete m_pwszShare;
    }

    assert( m_cRefs == 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::InitializeByName, public
//
//  Synopsis:   initialize the context given the name of the lanman share
//
//----------------------------------------------------------------------------
DWORD
CLMShareContext::InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask)
{
    return( LMShareContextParseLMShareName(
                   pObjectName,
                   &m_pwszMachine,
                   &m_pwszShare
                   ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::AddRef, public
//
//  Synopsis:   add a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CLMShareContext::AddRef ()
{
    m_cRefs += 1;
    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::Release, public
//
//  Synopsis:   release a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CLMShareContext::Release ()
{
    m_cRefs -= 1;

    if ( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::GetLMShareProperties, public
//
//  Synopsis:   get properties about the context
//
//----------------------------------------------------------------------------
DWORD
CLMShareContext::GetLMShareProperties (
                    PMARTA_OBJECT_PROPERTIES pObjectProperties
                    )
{
    if ( pObjectProperties->cbSize < sizeof( MARTA_OBJECT_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pObjectProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::GetLMShareRights, public
//
//  Synopsis:   get the LMShare security descriptor
//
//----------------------------------------------------------------------------
DWORD
CLMShareContext::GetLMShareRights (
                    SECURITY_INFORMATION SecurityInfo,
                    PSECURITY_DESCRIPTOR* ppSecurityDescriptor
                    )
{
    DWORD                 Result;
    PSHARE_INFO_502       psi = NULL;
    PISECURITY_DESCRIPTOR pisd = NULL;
    PSECURITY_DESCRIPTOR  psd = NULL;
    DWORD                 cb = 0;

    assert( m_pwszShare != NULL );

    Result = NetShareGetInfo( m_pwszMachine, m_pwszShare, 502, (PBYTE *)&psi );

    if ( Result == ERROR_SUCCESS )
    {
        if ( psi->shi502_security_descriptor == NULL )
        {
            *ppSecurityDescriptor = NULL;
            Result = ERROR_SUCCESS;
            goto Cleanup;
        }

        pisd = (PISECURITY_DESCRIPTOR)psi->shi502_security_descriptor;
        if ( pisd->Control & SE_SELF_RELATIVE )
        {
            cb = GetSecurityDescriptorLength( psi->shi502_security_descriptor );
            psd = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
            if ( psd == NULL )
            {
                Result = ERROR_OUTOFMEMORY;
                goto Cleanup;
            }

            memcpy( psd, psi->shi502_security_descriptor, cb );
        }
        else
        {
            if ( MakeSelfRelativeSD(
                     psi->shi502_security_descriptor,
                     NULL,
                     &cb
                     ) == FALSE )
            {
                if ( cb > 0 )
                {
                    psd = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
                    if ( psd != NULL )
                    {
                        if ( MakeSelfRelativeSD(
                                 psi->shi502_security_descriptor,
                                 psd,
                                 &cb
                                 ) == FALSE )
                        {
                            LocalFree( psd );
                            Result = GetLastError();
                            goto Cleanup;
                        }
                    }
                    else
                    {
                        Result = ERROR_OUTOFMEMORY;
                        goto Cleanup;
                    }
                }
                else
                {
                    Result = GetLastError();
                    goto Cleanup;
                }
            }
            else
            {
                assert( FALSE && "Should not get here!" );
                Result = ERROR_INVALID_PARAMETER;
                goto Cleanup;
            }
        }

        *ppSecurityDescriptor = psd;
    }

Cleanup:

    if (psi != NULL) 
    {
        NetApiBufferFree(psi);
    }

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLMShareContext::SetLMShareRights, public
//
//  Synopsis:   set the window security descriptor
//
//----------------------------------------------------------------------------
DWORD
CLMShareContext::SetLMShareRights (
                   SECURITY_INFORMATION SecurityInfo,
                   PSECURITY_DESCRIPTOR pSecurityDescriptor
                   )
{
    DWORD           Result;
    SHARE_INFO_1501 si;

    si.shi1501_reserved = 0;
    si.shi1501_security_descriptor = pSecurityDescriptor;

    Result = NetShareSetInfo(
                m_pwszMachine,
                m_pwszShare,
                1501,
                (PBYTE)&si,
                NULL
                );

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Function:   LMShareContextParseLMShareName
//
//  Synopsis:   parse the service name and machine
//
//----------------------------------------------------------------------------
DWORD
LMShareContextParseLMShareName (
       LPCWSTR pwszName,
       LPWSTR* ppMachine,
       LPWSTR* ppLMShare
       )
{
    return( StandardContextParseName( pwszName, ppMachine, ppLMShare ) );
}

//
// Functions from LMShare.h which dispatch unto the CLMShareContext class
//

DWORD
MartaAddRefLMShareContext(
   IN MARTA_CONTEXT Context
   )
{
    return( ( (CLMShareContext *)Context )->AddRef() );
}

DWORD
MartaCloseLMShareContext(
     IN MARTA_CONTEXT Context
     )
{
    return( ( (CLMShareContext *)Context )->Release() );
}

DWORD
MartaGetLMShareProperties(
   IN MARTA_CONTEXT Context,
   IN OUT PMARTA_OBJECT_PROPERTIES pProperties
   )
{
    return( ( (CLMShareContext *)Context )->GetLMShareProperties( pProperties ) );
}

DWORD
MartaGetLMShareTypeProperties(
   IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
   )
{
    if ( pProperties->cbSize < sizeof( MARTA_OBJECT_TYPE_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

DWORD
MartaGetLMShareRights(
   IN  MARTA_CONTEXT Context,
   IN  SECURITY_INFORMATION   SecurityInfo,
   OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
   )
{
    return( ( (CLMShareContext *)Context )->GetLMShareRights(
                                               SecurityInfo,
                                               ppSecurityDescriptor
                                               ) );
}

DWORD
MartaOpenLMShareNamedObject(
    IN  LPCWSTR pObjectName,
    IN  ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CLMShareContext* pLMShareContext;

    pLMShareContext = new CLMShareContext;
    if ( pLMShareContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pLMShareContext->InitializeByName( pObjectName, AccessMask );
    if ( Result != ERROR_SUCCESS )
    {
        pLMShareContext->Release();
        return( Result );
    }

    *pContext = pLMShareContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaSetLMShareRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return( ( (CLMShareContext *)Context )->SetLMShareRights(
                                               SecurityInfo,
                                               pSecurityDescriptor
                                               ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\krnctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       krnctx.h
//
//  Contents:   NT Marta kernel context class
//
//  History:    4-1-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__KRNCTX_H__)
#define __KRNCTX_H__

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <kernel.h>
#include <assert.h>
#include <ntstatus.h>

//
// CKernelContext.  This represents a LanMan share object to the NT Marta
// infrastructure
//

class CKernelContext
{
public:

    //
    // Construction
    //

    CKernelContext ();

    ~CKernelContext ();

    DWORD InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask);

    DWORD InitializeByWmiName (LPCWSTR pObjectName, ACCESS_MASK AccessMask);

    DWORD InitializeByHandle (HANDLE Handle);

    //
    // Dispatch methods
    //

    DWORD AddRef ();

    DWORD Release ();

    DWORD GetKernelProperties (
             PMARTA_OBJECT_PROPERTIES pProperties
             );

    DWORD GetKernelRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR* ppSecurityDescriptor
             );

    DWORD SetKernelRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR pSecurityDescriptor
             );

private:

    //
    // Reference count
    //

    DWORD  m_cRefs;

    //
    // Kernel object handle
    //

    HANDLE m_hObject;

    //
    // Initialized by name
    //

    BOOL   m_fNameInitialized;
};

DWORD
OpenWmiGuidObject(IN  LPWSTR       pwszObject,
                  IN  ACCESS_MASK  AccessMask,
                  OUT PHANDLE      pHandle);

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\lmshare.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       lmshare.cxx
//
//  Contents:   local functions
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <lmerr.h>
#include <lmcons.h>

//+---------------------------------------------------------------------------
//
//  Function:   PingLmShare
//
//  Synopsis:   Determines whether the given share is a Lanman share or not...
//
//  Arguments:  [IN  pwszShare]   --  The name of the share to ping
//
//  Returns:    ERROR_SUCCESS       --  The share is lanman
//              ERROR_INVALID_NAME  --  The format of the name is unrecognized
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
PingLmShare( IN LPCWSTR     pwszShareName)
{
    acDebugOut((DEB_TRACE, "in PingLmShare\n"));

    DWORD   dwErr;

    dwErr = LoadDLLFuncTable();
    if(dwErr != NO_ERROR)
    {
        return(dwErr);
    }

    if(pwszShareName != NULL)
    {
        //
        // save the object since we must crack it to go to remote machines
        //
        WCHAR   wszUseName[RMLEN + 1];
        LPWSTR  pwszUseName;

        dwErr = AccGetBufferOfSizeW((PWSTR)pwszShareName,
                                    wszUseName,
                                    &pwszUseName);
        if(dwErr == ERROR_SUCCESS)
        {
            PWSTR   pwszShare, pwszMachine;

            //
            // get the machinename from the full name
            //
            dwErr = ParseName(pwszUseName,
                              &pwszMachine,
                              &pwszShare);
            if(dwErr == ERROR_SUCCESS)
            {
                PSHARE_INFO_0 pSI0;

                //
                // get share infolevel 0
                //
                dwErr = (*DLLFuncs.PNetShareGetInfo)(pwszMachine,
                                                     pwszShare,
                                                     0,
                                                     (PBYTE *)&pSI0);
                if(dwErr == ERROR_SUCCESS)
                {
                    (*DLLFuncs.PNetApiBufferFree)(pSI0);
                }
                else
                {
                    if(dwErr == NERR_NetNameNotFound)
                    {
                        dwErr = ERROR_PATH_NOT_FOUND;
                    }

                    //
                    // Any other error will be returned to the calling
                    // API
                    //
                }
            }
            AccFreeBufferOfSizeW(wszUseName,
                                 pwszUseName);
        }
    }
    else
    {
        dwErr = ERROR_INVALID_NAME;
    }

    acDebugOut((DEB_TRACE, "Out PingLmShare(%d)\n", dwErr));

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadSharePropertyRights
//
//  Synopsis:   Gets the specified security info for the specified net share
//              object
//
//  Arguments:  [IN  pwszShare]         --      The share to get the rights
//                                              for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadSharePropertyRights(IN  LPWSTR                pwszShare,
                        IN  PACTRL_RIGHTS_INFO    pRightsList,
                        IN  ULONG                 cRights,
                        IN  CAccessList&          AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadSharePropertyRights\n"));

    DWORD dwErr;
    PSHARE_INFO_502 pSI502;

    dwErr = LoadDLLFuncTable();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }


    //
    // For the moment, there is only the share itself...
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    if(pwszShare != NULL)
    {
        WCHAR   wszName[MAX_PATH + 1];
        PWSTR   pwszName;
        //
        // save the object since we must crack it to go to remote machines
        //
        dwErr = AccGetBufferOfSizeW(pwszShare,
                                    wszName,
                                    &pwszName);
        if(dwErr == ERROR_SUCCESS)
        {
            PWSTR   pwszShr, pwszMachine;

            //
            // Separate the names
            //
            dwErr = ParseName(pwszName,
                              &pwszMachine,
                              &pwszShr);

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // get share infolevel 502 (a bunch of stuff) since
                // level 1501 seems to be write only
                //
                PSHARE_INFO_0 pSI0;
                dwErr = (*DLLFuncs.PNetShareGetInfo)(pwszMachine,
                                                     pwszShr,
                                                     502,
                                                     (PBYTE *)&pSI502);
                if(dwErr == ERROR_SUCCESS &&
                                    pSI502->shi502_security_descriptor != NULL)
                {
                    //
                    // Add it
                    //
                    dwErr = AccessList.AddSD(
                                          pSI502->shi502_security_descriptor,
                                          pRightsList->SeInfo,
                                          pRightsList->pwszProperty);

                    (*DLLFuncs.PNetApiBufferFree)(pSI502);
                }
            }

            AccFreeBufferOfSizeW(wszName, pwszName);
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    acDebugOut((DEB_TRACE, "Out ReadSharePropertyRights: %lu\n", dwErr));
    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   GetShareParentRights
//
//  Synopsis:   Determines who the parent is, and gets the access rights
//              for it.  It is used to aid in determining what the approriate
//              inheritance bits are.
//
//              This operation does not make sense for share objects
//
//  Arguments:  [IN  pwszShare]         --      The share to get the parent
//                                              for
//              [IN  pRightsList]       --      The properties to get the
//                                              rights for
//              [IN  cRights]           --      Number of items in rights list
//              [OUT ppDAcl]            --      Where the DACL is returned
//              [OUT ppSAcl]            --      Where the SACL is returned
//              [OUT ppSD]              --      Where the Security Descriptor
//                                              is returned
//
//  Returns:    ERROR_INVALID_FUNCTION  --      Call doesn't make sense here
//
//----------------------------------------------------------------------------
DWORD
GetShareParentRights(IN  LPWSTR                    pwszShare,
                      IN  PACTRL_RIGHTS_INFO       pRightsList,
                      IN  ULONG                    cRights,
                      OUT PACL                    *ppDAcl,
                      OUT PACL                    *ppSAcl,
                      OUT PSECURITY_DESCRIPTOR    *ppSD)
{
    //
    // This doesn't currently make sense for share objects, so simply
    // return an error
    //
    return(ERROR_INVALID_FUNCTION);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetShareSecurityInfo
//
//  Synopsis:   Sets the specified security info on the specified share
//              object
//
//  Arguments:  [IN  pwszShare]         --      Share to set it on
//              [IN  SeInfo]            --      Flag indicating what security
//                                              info to set
//              [IN  pwszProperty]      --      The property on the object to
//                                              set
//                                              For kernel objects, this MBZ
//              [IN  pSD]               --      The security descriptor to set
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was given
//
//----------------------------------------------------------------------------
DWORD
SetShareSecurityInfo(IN  PWSTR                     pwszShare,
                     IN  SECURITY_INFORMATION      SeInfo,
                     IN  PWSTR                     pwszProperty,
                     IN  PSECURITY_DESCRIPTOR      pSD)
{
    acDebugOut((DEB_TRACE, "in SetShareSecurityInfo \n"));

    DWORD           dwErr = ERROR_SUCCESS;
    SHARE_INFO_1501 SI1501;

    //
    // Net shares don't have properties
    //
    if(pwszProperty != NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        dwErr = LoadDLLFuncTable();
        if(dwErr != ERROR_SUCCESS)
        {
            return(dwErr);
        }

        if(pwszShare != NULL)
        {
            WCHAR   wszName[MAX_PATH + 1];
            PWSTR   pwszName;
            //
            // save the object since we must crack it to go to remote machines
            //
            dwErr = AccGetBufferOfSizeW(pwszShare,
                                        wszName,
                                        &pwszName);
            if(dwErr == ERROR_SUCCESS)
            {
                PWSTR   pwszShr, pwszMachine;

                //
                // Separate the names
                //
                dwErr = ParseName(pwszName,
                                  &pwszMachine,
                                  &pwszShr);
                if(dwErr == ERROR_SUCCESS)
                {
                    SI1501.shi1501_reserved = 0;
                    SI1501.shi1501_security_descriptor = pSD;

                    //
                    // set the security descriptor
                    //
                    dwErr = (*DLLFuncs.PNetShareSetInfo)(pwszMachine,
                                                          pwszShr,
                                                          1501,
                                                          (PBYTE)&SI1501,
                                                          NULL);
                }

                AccFreeBufferOfSizeW(wszName, pwszName);

            }
            else
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
    }
    acDebugOut((DEB_TRACE, "Out SetShareSecurityInfo: %lu\n", dwErr));
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\lmsctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       lmsctx.h
//
//  Contents:   NT Marta LanMan share context class
//
//  History:    4-1-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__LMSCTX_H__)
#define __LMSCTX_H__

#include <windows.h>
#include <lmsh.h>
#include <assert.h>

//
// CLMShareContext.  This represents a LanMan share object to the NT Marta
// infrastructure
//

class CLMShareContext
{
public:

    //
    // Construction
    //

    CLMShareContext ();

    ~CLMShareContext ();

    DWORD InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask);

    //
    // Dispatch methods
    //

    DWORD AddRef ();

    DWORD Release ();

    DWORD GetLMShareProperties (
             PMARTA_OBJECT_PROPERTIES pProperties
             );

    DWORD GetLMShareRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR* ppSecurityDescriptor
             );

    DWORD SetLMShareRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR pSecurityDescriptor
             );

private:

    //
    // Reference count
    //

    DWORD       m_cRefs;

    //
    // Parsed machine and share
    //

    LPWSTR      m_pwszMachine;
    LPWSTR      m_pwszShare;
};

//
// Private functions
//

DWORD
LMShareContextParseLMShareName (
       LPCWSTR pwszName,
       LPWSTR* ppMachine,
       LPWSTR* ppLMShare
       );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\martabas.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       MARTABAS.CXX
//
//  Contents:   Implementation of the base MARTA funcitons
//
//  History:    22-Jul-96       MacM        Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <ntprov.hxx>
#include <strings.h>
#include <ntdsguid.h>


CSList      gWrkrList(NtProvFreeWorkerItem); // List of active worker threads

//+---------------------------------------------------------------------------
//
//  Function:   AccProvGetCapabilities
//
//  Synopsis:   Gets the provider capabilities
//
//  Arguments:  [IN  fClass]        --  Class of capabilities to request
//              [OUT pulCaps]       --  Provider capabilities
//
//  Returns:    VOID
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
AccProvGetCapabilities(IN  ULONG       fClass,
                       OUT PULONG      pulCaps)
{
    acDebugOut((DEB_TRACE_API,"in.out AccProvGetCapabilities\n"));

    if(fClass == ACTRL_CLASS_GENERAL)
    {
        *pulCaps = ACTRL_CAP_KNOWS_SIDS | ACTRL_CAP_SUPPORTS_HANDLES;
    }
    else
    {
        *pulCaps = ACTRL_CAP_NONE;
    }

    return;
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvIsObjectAccessible
//
//  Synopsis:   Determines if the given path is accessible or not
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//
//  Returns:    ERROR_SUCCESS           --  The path is recognized
//              ERROR_PATH_NOT_FOUND    --  The path was not recognized
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvIsObjectAccessible(IN  LPCWSTR           pwszObjectPath,
                          IN  SE_OBJECT_TYPE    ObjectType)
{
    acDebugOut((DEB_TRACE_API,"in AccProvIsObjectAccessible\n"));
    DWORD   dwErr = ERROR_PATH_NOT_FOUND;
    PWSTR   DsServerlessPath, OldServerPath = NULL;

    static  NTMARTA_ACCESS_CACHE    rgAccessCache[MAX_ACCESS_ENTRIES];
    static  ULONG                   cCacheEntries = 0;
    static  ULONG                   iCacheOldest  = 0;


    //
    // First, check our cache.  Maybe we can get out cheap.  Note that
    // we expect our result to be failure when we start.
    //
    ULONG   dwObjLen = wcslen(pwszObjectPath);
    if(dwObjLen < MAX_PATH)
    {
        RtlAcquireResourceShared(&gCacheLock, TRUE);
        for(ULONG iIndex = 0;
            iIndex < cCacheEntries && dwErr == ERROR_PATH_NOT_FOUND;
            iIndex++)
        {
            //
            // We'll have to do this base on object type...
            //
            switch(ObjectType)
            {
                case SE_SERVICE:
                case SE_PRINTER:
                case SE_REGISTRY_KEY:
                    //
                    // See if it's a UNC name, in which case we'll compare
                    // the only the server\\share name.
                    //
                    if(dwObjLen > 1 && pwszObjectPath[1] == L'\\')
                    {
                        //
                        // It's a UNC name
                        //
                        if(_wcsnicmp(pwszObjectPath,
                                     rgAccessCache[iIndex].wszPath,
                                     rgAccessCache[iIndex].cLen) == 0 &&
                           (*(pwszObjectPath + rgAccessCache[iIndex].cLen)
                                                                  == L'\0' ||
                            *(pwszObjectPath + rgAccessCache[iIndex].cLen)
                                                                  == L'\\'))
                        {
                            dwErr = ERROR_SUCCESS;
                        }
                    }
                    else
                    {
                        if(_wcsicmp(pwszObjectPath,
                                    rgAccessCache[iIndex].wszPath) == 0)
                        {
                            dwErr = ERROR_SUCCESS;
                        }
                    }
                    break;

                case SE_DS_OBJECT:
                case SE_DS_OBJECT_ALL:
                    //
                    // These have to match exact.  Handle the case where we were given a
                    // server name prefixed DS path
                    //
                    if(IS_UNC_PATH(pwszObjectPath, dwObjLen ) )
                    {
                        DsServerlessPath = wcschr(pwszObjectPath+2, L'\\');

                        if(DsServerlessPath != NULL)
                        {
                            DsServerlessPath++;
                            OldServerPath = ( PWSTR )pwszObjectPath;
                            pwszObjectPath = DsServerlessPath;
                            dwObjLen = wcslen(DsServerlessPath);
                        }
                    }

                    if(dwObjLen == rgAccessCache[iIndex].cLen &&
                       _wcsicmp(pwszObjectPath,
                                rgAccessCache[iIndex].wszPath) == 0)
                    {
                        dwErr = ERROR_SUCCESS;
                    }

                    break;


                case SE_FILE_OBJECT:
                case SE_KERNEL_OBJECT:
                case SE_LMSHARE:
                case SE_WMIGUID_OBJECT:

                    if(dwObjLen == rgAccessCache[iIndex].cLen &&
                       _wcsicmp(pwszObjectPath,
                                rgAccessCache[iIndex].wszPath) == 0)
                    {
                        dwErr = ERROR_SUCCESS;
                    }

                    break;
            }

            //
            // Make sure our types match...
            //
            if(dwErr == ERROR_SUCCESS && ObjectType != rgAccessCache[iIndex].ObjectType)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
#ifdef DBG
            if(dwErr == ERROR_SUCCESS)
            {
                acDebugOut((DEB_TRACE_CACHE, "Object %ws [%lu] found in cache!\n",
                            rgAccessCache[iIndex].wszPath,
                            rgAccessCache[iIndex].ObjectType));
            }
#endif

        }

        RtlReleaseResource(&gCacheLock);
    }

    //
    // If we got a match, return
    //
    if(dwErr == ERROR_SUCCESS)
    {
        return(ERROR_SUCCESS);
    }

    //
    // Well, that didn't work, so we'll have to go check.  Note that there
    // is not a lock here, so there is a window whereby an entry could be added
    // for the path that we are currently checking.  If that happens, it only
    // means that the same entry will be in the cache more than once.  This
    // is harmless.
    //
    HANDLE  hHandle;

    switch (ObjectType)
    {
    case SE_FILE_OBJECT:
        dwErr = IsFilePathLocalOrLM((PWSTR)pwszObjectPath);
        break;

    case SE_SERVICE:
        dwErr = OpenServiceObject((PWSTR)pwszObjectPath,
                                  SERVICE_USER_DEFINED_CONTROL,
                                  (SC_HANDLE *)&hHandle);
        if(dwErr == ERROR_SUCCESS)
        {
            CloseServiceHandle((SC_HANDLE)hHandle);
        }
        else
        {
            if(dwErr == ERROR_SERVICE_DOES_NOT_EXIST ||
               dwErr == ERROR_INVALID_NAME)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
        }
        break;

    case SE_PRINTER:
        dwErr = OpenPrinterObject((PWSTR)pwszObjectPath,
                                  PRINTER_ACCESS_USE,
                                  &hHandle);
        if(dwErr == ERROR_SUCCESS)
        {
            ClosePrinter(hHandle);
        }
        else
        {
            if(dwErr == ERROR_INVALID_PRINTER_NAME)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }
        }
        break;

    case SE_REGISTRY_KEY:
        dwErr = OpenRegistryObject((PWSTR)pwszObjectPath,
                                   KEY_EXECUTE,
                                   &hHandle);
        if(dwErr == ERROR_SUCCESS)
        {
            RegCloseKey((HKEY)hHandle);
        }
        else
        {
            if(dwErr == ERROR_INVALID_PARAMETER ||
               dwErr == ERROR_FILE_NOT_FOUND)
            {
                dwErr = ERROR_PATH_NOT_FOUND;
            }

        }

        break;

    case SE_LMSHARE:
        //
        // Note that this doesn't have to be a local share, just a lan man
        // share
        //
        dwErr = PingLmShare(pwszObjectPath);

        break;

    case SE_KERNEL_OBJECT:                          // FALL THROUGH
    case SE_WMIGUID_OBJECT:

        //
        // Can't have kernel objects outside of NT, so just return success
        //
        dwErr = ERROR_SUCCESS;
        break;

    case SE_DS_OBJECT:                              // FALL THROUGH
    case SE_DS_OBJECT_ALL:
        dwErr = PingDSObj(OldServerPath ? OldServerPath : pwszObjectPath);
        break;

    default:

        //
        // Unknown object type.  Pass it on.
        //
        dwErr = ERROR_PATH_NOT_FOUND;
        break;
    }


    if(dwErr == ERROR_ACCESS_DENIED)
    {

        dwErr = ERROR_SUCCESS;
    }

    //
    // Add it to the cache, if we succeeded
    //
    if(dwErr == ERROR_SUCCESS &&
       (ObjectType != SE_KERNEL_OBJECT && ObjectType != SE_WMIGUID_OBJECT))
    {
        //
        // Lock the cache
        //
        RtlAcquireResourceExclusive(&gCacheLock, TRUE);

        //
        // For some items, we'll want to save the root of the path, since it
        // is not possible to have linked services, registry keys, etc, while
        // for files and shares, it can cause problems.  If an entry is too
        // long to be cached, we'll ignore it.
        //

        if(dwObjLen <= MAX_PATH)
        {
            //
            // Save off the object type and path name.  For those that
            // need it, we'll go through and shorten them as requried.
            //
            rgAccessCache[iCacheOldest].ObjectType = ObjectType;
            wcscpy(rgAccessCache[iCacheOldest].wszPath,
                   pwszObjectPath);
            rgAccessCache[iCacheOldest].cLen = dwObjLen;

            PWSTR   pwszLop = rgAccessCache[iCacheOldest].wszPath;
            switch (ObjectType)
            {
                case SE_SERVICE:
                case SE_PRINTER:
                case SE_REGISTRY_KEY:
                    //
                    // See if it's a UNC name, in which case we'll lop
                    // it off
                    //
                    if(IS_UNC_PATH(pwszObjectPath, dwObjLen))
                    {
                        //
                        // It's a UNC name, so lop it off
                        //
                        pwszLop = wcschr(pwszLop + 2,
                                         L'\\');
                        if(pwszLop != NULL)
                        {
                            pwszLop = wcschr(pwszLop + 1, '\\');

                            if(pwszLop != NULL)
                            {
                                *pwszLop = L'\0';
                                rgAccessCache[iCacheOldest].cLen = (DWORD)(pwszLop -
                                          rgAccessCache[iCacheOldest].wszPath);
                            }
                        }
                    }
                    break;

                case SE_DS_OBJECT:
                case SE_DS_OBJECT_ALL:
                    //
                    // Save off the domain name part
                    //

                    //
                    // Note that we'll get the object in RDN format, so
                    // it's a simple matter to lop it off if necessary
                    pwszLop = wcschr(pwszLop, L'\\');
                    if(pwszLop != NULL)
                    {
                        *pwszLop = L'\0';
                        rgAccessCache[iCacheOldest].cLen = (DWORD)(pwszLop -
                                          rgAccessCache[iCacheOldest].wszPath);
                    }
                    break;
            }

            //
            // Update our indexes and counts
            //
            if(cCacheEntries < MAX_ACCESS_ENTRIES)
            {
                cCacheEntries++;
            }

            iCacheOldest++;
            if(iCacheOldest == MAX_ACCESS_ENTRIES)
            {
                iCacheOldest = 0;
            }
        }

        RtlReleaseResource(&gCacheLock);
    }

    if ( dwErr == ERROR_INVALID_NAME ) {

        acDebugOut(( DEB_ERROR, "%ws returned ERROR_INVALID_NAME\n", pwszObjectPath ));
        ASSERT( FALSE );

    }
    acDebugOut((DEB_TRACE_API,"out AccProvIsObjectAccessible: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleIsObjectAccessible
//
//  Synopsis:   Determines if the given object is accessible or not given
//              a handle to it
//
//  Arguments:  [IN  hObject]           --  Object handle
//              [IN  ObjectType]        --  Type of the object
//
//  Returns:    ERROR_SUCCESS           --  The path is recognized
//              ERROR_PATH_NOT_FOUND    --  The path was not recognized
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleIsObjectAccessible(IN  HANDLE            hObject,
                                IN  SE_OBJECT_TYPE    ObjectType)
{
    acDebugOut((DEB_TRACE_API,"in AccProvHandleIsObjectAccessible\n"));

    DWORD dwErr = ERROR_PATH_NOT_FOUND;

    //
    // Because a handle can get reused, we can't cache them like we did
    // above...
    //

    switch (ObjectType)
    {
    case SE_FILE_OBJECT:
        {
            DWORD   dwHigh;
            DWORD   dwSize = GetFileSize(hObject,
                                         &dwHigh);
            if(dwSize == 0xFFFFFFFF)
            {
                dwErr = GetLastError();
            }
            else
            {
                dwErr = ERROR_SUCCESS;
            }
        }
        break;

    case SE_SERVICE:
        {
            SERVICE_STATUS  SvcStatus;

            if(QueryServiceStatus((SC_HANDLE)hObject,
                                  &SvcStatus) == FALSE)
            {
                dwErr = GetLastError();
            }
            else
            {
                dwErr = ERROR_SUCCESS;
            }
        }
        break;

    case SE_PRINTER:
        {
            dwErr = LoadDLLFuncTable();
            if(dwErr == ERROR_SUCCESS)
            {
                ULONG cNeeded;
                if(DLLFuncs.PGetPrinter(hObject,
                                        1,
                                        NULL,
                                        0,
                                        &cNeeded) == FALSE)
                {
                    dwErr = GetLastError();
                    if(dwErr == ERROR_INSUFFICIENT_BUFFER)
                    {
                        dwErr = ERROR_SUCCESS;
                    }
                }
            }
        }
        break;

    case SE_REGISTRY_KEY:
        dwErr = RegQueryInfoKey((HKEY)hObject,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);
        break;

    case SE_KERNEL_OBJECT:                          // FALL THROUGH
    case SE_WINDOW_OBJECT:                          // FALL THROUGH
    case SE_WMIGUID_OBJECT:
        //
        // Can't have kernel/windows objects outside of NT, so just return
        // success
        //
        dwErr = ERROR_SUCCESS;
        break;

    case SE_LMSHARE:                                // FALL THROUGH
    case SE_DS_OBJECT:                              // FALL THROUGH
    case SE_DS_OBJECT_ALL:
        //
        // Can't have handles to DS objects
        //
        dwErr = ERROR_PATH_NOT_FOUND;
        break;


    default:

        //
        // Unknown object type.  Pass it on.
        //
        dwErr = ERROR_PATH_NOT_FOUND;
        break;
    }



    //
    // Make sure the reason we failed isn't because of permissions
    //
    if(dwErr == ERROR_ACCESS_DENIED)
    {
        dwErr = ERROR_SUCCESS;
    }

    acDebugOut((DEB_TRACE_API,"out AccProvIsObjectAccessible: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvCancelOperation
//
//  Synopsis:   Cancels an ongoing operation.
//
//  Arguments:  [IN  pOverlapped]       --  Operation to cancel
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_INVALID_PARAMETER --  A bad overlapped structure was
//                                          given
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvCancelOperation(IN   PACTRL_OVERLAPPED   pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, grab a read lock, so nobody inserts on us, and find the
    // right node
    //
    PNTMARTA_WRKR_INFO  pWrkrNode = NULL;

    {
        // RtlAcquireResourceShared(&gWrkrLock, TRUE);
        RtlAcquireResourceExclusive(&gWrkrLock, TRUE);

        pWrkrNode = (PNTMARTA_WRKR_INFO)gWrkrList.Find((PVOID)pOverlapped,
                                                       NtProvFindWorkerItem);
        RtlReleaseResource(&gWrkrLock);
    }

    if(pWrkrNode == NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // All right.  We'll set our stop flag, and wait for it to return..
        // It doesn't matter what we set the flag to, since all we need to do
        // is set it non-0
        //
        pWrkrNode->fState++;

        //
        // Now, wait for the call to finish
        //
        WaitForSingleObject(pWrkrNode->hWorker,
                            INFINITE);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvGetOperationResults
//
//  Synopsis:   Gets the results of an operation
//
//  Arguments:  [IN  pOverlapped]       --  Operation to cancel
//              [OUT dwResults]         --  Where the results are returned
//              [OUT pcProcessed]       --  Number of items processed
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_INVALID_PARAMETER --  A bad overlapped structure was
//                                          given
//              ERROR_IO_PENDING        --  Operation hasn't completed yet
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvGetOperationResults(IN   PACTRL_OVERLAPPED   pOverlapped,
                           OUT  PDWORD              dwResults,
                           OUT  PDWORD              pcProcessed)
{
    DWORD   dwErr = ERROR_SUCCESS;
    PNTMARTA_WRKR_INFO  pWrkrNode = NULL;

    //
    // Ok, first, grab a write lock.  This will prevent anyone from
    // reading and or writing to the list, until we get done updating
    // our overlapped structure.
    //
    RtlAcquireResourceExclusive(&gWrkrLock, TRUE);

    pWrkrNode = (PNTMARTA_WRKR_INFO)gWrkrList.Find((PVOID)pOverlapped,
                                                   NtProvFindWorkerItem);

    RtlReleaseResource(&gWrkrLock);

    if(pWrkrNode == NULL)
    {
        //
        // Now, the reason we may have not found the node is that somebody
        // has removed it.  If so, check our overlapped structure, since
        // that will have been updated by the last call
        //
        if(pOverlapped->hEvent != NULL)
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }
        else
        {
            *dwResults = pOverlapped->Reserved2;
            if(pcProcessed != NULL)
            {
                *pcProcessed = pOverlapped->Reserved1;
            }
        }
    }
    else
    {
        //
        // See if the thread has stopped processing or not
        //
        if(WaitForSingleObject(pWrkrNode->hWorker, 0) == WAIT_TIMEOUT)
        {
            if(pcProcessed != NULL)
            {
                *pcProcessed = pWrkrNode->cProcessed;
            }
            dwErr = ERROR_IO_PENDING;
        }
        else
        {
            //
            // Get the results of the thread exit first.
            //
            if(GetExitCodeThread(pWrkrNode->hWorker,
                                 dwResults) == FALSE)
            {
                dwErr = GetLastError();
            }
            else
            {
                dwErr = ERROR_SUCCESS;
                CloseHandle(pWrkrNode->hWorker);
                pWrkrNode->hWorker = NULL;

                //
                // Save off the results.  They go in Reserved2 parameter
                //
                pOverlapped->Reserved2 = *dwResults;
                pOverlapped->Reserved1 = pWrkrNode->cProcessed;

                //
                // Remove the node from our list, and do our updates.  We
                // need to do all of this before releasing our resource,
                // to prevent some race conditions
                //
                RtlAcquireResourceExclusive(&gWrkrLock, TRUE);

                gWrkrList.Remove((PVOID)pWrkrNode);

                RtlReleaseResource(&gWrkrLock);

                //
                // Deallocate our memory
                //
                AccFree(pWrkrNode);
            }
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvSetAccessRights
//
//  Synopsis:   Sets the access rights on the given object.  It replaces any
//              existing rights.
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pAccessList]       --  Optional.  The list of access
//                                          rights to set.
//              [IN  pAuditList]        --  Optional.  The list of access
//                                          rights to set.
//              [IN  pOwner]            --  Optional.  Owner to set
//              [IN  pGroup]            --  Optional.  Group to set
//              [IN  pOverlapped]       --  Overlapped structure to use for
//                                          asynchronous control
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvSetAccessRights(IN           LPCWSTR                 pwszObjectPath,
                       IN           SE_OBJECT_TYPE          ObjectType,
                       IN           SECURITY_INFORMATION    SecurityInfo,
                       IN  OPTIONAL PACTRL_ACCESS           pAccessList,
                       IN  OPTIONAL PACTRL_AUDIT            pAuditList,
                       IN  OPTIONAL PTRUSTEE                pOwner,
                       IN  OPTIONAL PTRUSTEE                pGroup,
                       IN           PACTRL_OVERLAPPED       pOverlapped)
{
    DWORD   dwErr;

    CAccessList *pAccList = new CAccessList;
    if(pAccList == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        dwErr = pAccList->SetObjectType(ObjectType);
        if(dwErr == ERROR_SUCCESS)
        {
            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                dwErr = pAccList->AddAccessLists(DACL_SECURITY_INFORMATION,
                                                 pAccessList,
                                                 FALSE);
            }

            if(dwErr == ERROR_SUCCESS &&
               FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                dwErr = pAccList->AddAccessLists(SACL_SECURITY_INFORMATION,
                                                 pAuditList,
                                                 FALSE);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Add the owner and group
                //
                dwErr = pAccList->AddOwnerGroup(SecurityInfo,
                                                pOwner,
                                                pGroup);
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Finally, if all that worked, we'll do the rest
            //
            dwErr = NtProvDoSet(pwszObjectPath,
                                ObjectType,
                                pAccList,
                                pOverlapped,
                                NTMARTA_DELETE_ALIST);
        }

        if(dwErr != ERROR_SUCCESS)
        {
            delete(pAccList);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleSetAccessRights
//
//  Synopsis:   Sets the access rights on the given object.  It replaces any
//              existing rights.
//
//  Arguments:  [IN  hObject]           --  Handle to the object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pAccessList]       --  Optional.  The list of access
//                                          rights to set.
//              [IN  pAuditList]        --  Optional.  The list of access
//                                          rights to set.
//              [IN  pOwner]            --  Optional.  Owner to set
//              [IN  pGroup]            --  Optional.  Group to set
//              [IN  pOverlapped]       --  Overlapped structure to use for
//                                          asynchronous control
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleSetAccessRights(IN   HANDLE                  hObject,
                             IN   SE_OBJECT_TYPE          ObjectType,
                             IN   SECURITY_INFORMATION    SecurityInfo,
                             IN   PACTRL_ACCESS           pAccessList  OPTIONAL,
                             IN   PACTRL_AUDIT            pAuditList   OPTIONAL,
                             IN   PTRUSTEE                pOwner       OPTIONAL,
                             IN   PTRUSTEE                pGroup       OPTIONAL,
                             IN   PACTRL_OVERLAPPED       pOverlapped)
{
    DWORD   dwErr;

    CAccessList *pAccList = new CAccessList;
    if(pAccList == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        dwErr = pAccList->SetObjectType(ObjectType);
        if(dwErr == ERROR_SUCCESS)
        {
            if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                dwErr = pAccList->AddAccessLists(DACL_SECURITY_INFORMATION,
                                                 pAccessList,
                                                 FALSE);
            }

            if(dwErr == ERROR_SUCCESS &&
               FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                dwErr = pAccList->AddAccessLists(SACL_SECURITY_INFORMATION,
                                                 pAuditList,
                                                 FALSE);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Add the owner and group
                //
                dwErr = pAccList->AddOwnerGroup(SecurityInfo,
                                                pOwner,
                                                pGroup);
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Finally, if all that worked, we'll do the rest
            //
            dwErr = NtProvDoHandleSet(hObject,
                                      ObjectType,
                                      pAccList,
                                      pOverlapped,
                                      NTMARTA_DELETE_ALIST);
        }

        if(dwErr != ERROR_SUCCESS)
        {
            delete pAccList;
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvGrantAccessRights
//
//  Synopsis:   Grants the access rights on the given object.  It merges the
//              supplied rights with any existing rights.
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pAccessList]       --  Optional.  The list of access
//                                          rights to set.
//              [IN  pAuditList]        --  Optional.  The list of access
//                                          rights to set.
//
//  Returns:    ERROR_SUCCESS           --  The path is recognized
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvGrantAccessRights(IN             LPCWSTR            pwszObjectPath,
                         IN             SE_OBJECT_TYPE     ObjectType,
                         IN  OPTIONAL   PACTRL_ACCESS      pAccessList,
                         IN  OPTIONAL   PACTRL_AUDIT       pAuditList,
                         IN             PACTRL_OVERLAPPED  pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, read the relevant information.  This will involve getting the
    // access and audit lists for each property specified in the access and
    // audit list.
    //
    PACTRL_RIGHTS_INFO      pRightsList = NULL;
    ULONG                   cItems;
    dwErr = NtProvSetRightsList(pAccessList,
                                pAuditList,
                                &cItems,
                                &pRightsList);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, read all of the rights
        //
        CAccessList *pAccList = NULL;

        //
        // NtProvGetAccessListForObject modifies its first
        // parameter, so we can't pass in a CONST string.
        //

        PWSTR pwszTmpObjectPath = (PWSTR)AccAlloc( (wcslen(pwszObjectPath) + 1) * sizeof( WCHAR )  );

        if (pwszTmpObjectPath)
        {
            wcscpy( pwszTmpObjectPath, pwszObjectPath );
            pwszTmpObjectPath[wcslen(pwszObjectPath)] = UNICODE_NULL;

            dwErr = NtProvGetAccessListForObject( pwszTmpObjectPath,
                                                  ObjectType,
                                                  pRightsList,
                                                  cItems,
                                                  &pAccList);

            //
            // Now, process the input lists
            //
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // First, the access list
                //
                if(pAccessList != NULL)
                {
                    dwErr = pAccList->AddAccessLists(DACL_SECURITY_INFORMATION,
                                                     pAccessList,
                                                     TRUE);

                }

                //
                // Then, the audit list
                //
                if(dwErr == ERROR_SUCCESS && pAuditList != NULL)
                {
                    dwErr = pAccList->AddAccessLists(SACL_SECURITY_INFORMATION,
                                                     pAuditList,
                                                     TRUE);
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Finally, if all that worked, we'll do the rest
                //
                dwErr = NtProvDoSet(pwszObjectPath,
                                    ObjectType,
                                    pAccList,
                                    pOverlapped,
                                    NTMARTA_DELETE_ALIST);
            }

            if(dwErr != ERROR_SUCCESS)
            {
                delete pAccList;
            }

            AccFree( pwszTmpObjectPath );
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }

        AccFree(pRightsList);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleGrantAccessRights
//
//  Synopsis:   Grants the access rights on the given object.  It merges the
//              supplied rights with any existing rights.
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pAccessList]       --  Optional.  The list of access
//                                          rights to set.
//              [IN  pAuditList]        --  Optional.  The list of access
//                                          rights to set.
//
//  Returns:    ERROR_SUCCESS           --  The path is recognized
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleGrantAccessRights(IN             HANDLE             hObject,
                               IN             SE_OBJECT_TYPE     ObjectType,
                               IN  OPTIONAL   PACTRL_ACCESS      pAccessList,
                               IN  OPTIONAL   PACTRL_AUDIT       pAuditList,
                               IN             PACTRL_OVERLAPPED  pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, read the relevant information.  This will involve getting the
    // access and audit lists for each property specified in the access and
    // audit list.
    //
    PACTRL_RIGHTS_INFO      pRightsList = NULL;
    ULONG                   cItems;
    dwErr = NtProvSetRightsList(pAccessList,
                                pAuditList,
                                &cItems,
                                &pRightsList);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, read all of the rights
        //
        CAccessList *pAccList = NULL;
        dwErr = NtProvGetAccessListForHandle(hObject,
                                             ObjectType,
                                             pRightsList,
                                             cItems,
                                             &pAccList);
        //
        // Don't need the rights list, so we might as well release it
        //
        AccFree(pRightsList);

        //
        // Now, process the input lists
        //
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // First, the access list
            //
            if(pAccessList != NULL)
            {
                dwErr = pAccList->AddAccessLists(DACL_SECURITY_INFORMATION,
                                                 pAccessList,
                                                 TRUE);

            }

            //
            // Then, the audit list
            //
            if(dwErr == ERROR_SUCCESS && pAuditList != NULL)
            {
                dwErr = pAccList->AddAccessLists(SACL_SECURITY_INFORMATION,
                                                 pAuditList,
                                                 TRUE);
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Finally, if all that worked, we'll do the rest
            //
            dwErr = NtProvDoHandleSet(hObject,
                                      ObjectType,
                                      pAccList,
                                      pOverlapped,
                                      NTMARTA_DELETE_ALIST);
        }

        if(dwErr != ERROR_SUCCESS)
        {
            delete pAccList;
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvRevokeAccessRights
//
//  Synopsis:   Revokes the access rights on the given object.  It goes
//              through and removes any explicit entries for the given
//              trustees
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN  cTrustees]         --  Number of trustees in list
//              [IN  prgTrustees]       --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvRevokeAccessRights(IN            LPCWSTR             pwszObjectPath,
                          IN            SE_OBJECT_TYPE      ObjectType,
                          IN  OPTIONAL  LPCWSTR             pwszProperty,
                          IN            ULONG               cTrustees,
                          IN            PTRUSTEE            prgTrustees,
                          IN            PACTRL_OVERLAPPED   pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CAccessList *pAccList = NULL;
    //
    // First, read the relevant information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ACTRL_RIGHTS_INFO    RI;
        RI.pwszProperty = (PWSTR)pwszProperty;
        RI.SeInfo       = DACL_SECURITY_INFORMATION;

        PWSTR pwszTmpObjectPath = (PWSTR)AccAlloc( (wcslen(pwszObjectPath) + 1) * sizeof( WCHAR )  );

        if (pwszTmpObjectPath)
        {
            wcscpy( pwszTmpObjectPath, pwszObjectPath );
            pwszTmpObjectPath[wcslen(pwszObjectPath)] = UNICODE_NULL;

            dwErr = NtProvGetAccessListForObject(pwszTmpObjectPath,
                                                 ObjectType,
                                                 &RI,
                                                 1,
                                                 &pAccList);

            AccFree( pwszTmpObjectPath );
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    for(DWORD iIndex = 0;
        iIndex < cTrustees && dwErr == ERROR_SUCCESS;
        iIndex++)
    {
        dwErr = pAccList->RemoveTrusteeFromAccess(DACL_SECURITY_INFORMATION,
                                                  &(prgTrustees[iIndex]),
                                                  (PWSTR)pwszProperty);
    }

    //
    // Then, do the set
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = NtProvDoSet(pwszObjectPath,
                            ObjectType,
                            pAccList,
                            pOverlapped,
                            NTMARTA_DELETE_ALIST);
    }

    if(dwErr != ERROR_SUCCESS)
    {
        delete pAccList;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleRevokeAccessRights
//
//  Synopsis:   Revokes the access rights on the given object.  It goes
//              through and removes any explicit entries for the given
//              trustees
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN  cTrustees]         --  Number of trustees in list
//              [IN  prgTrustees]       --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleRevokeAccessRights(IN            HANDLE              hObject,
                                IN            SE_OBJECT_TYPE      ObjectType,
                                IN  OPTIONAL  LPCWSTR             pwszProperty,
                                IN            ULONG               cTrustees,
                                IN            PTRUSTEE            prgTrustees,
                                IN            PACTRL_OVERLAPPED   pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CAccessList *pAccList = NULL;

    //
    // First, read the relevant information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ACTRL_RIGHTS_INFO    RI;
        RI.pwszProperty = (PWSTR)pwszProperty;
        RI.SeInfo       = DACL_SECURITY_INFORMATION;
        dwErr = NtProvGetAccessListForHandle(hObject,
                                             ObjectType,
                                             &RI,
                                             1,
                                             &pAccList);
    }

    for(DWORD iIndex = 0;
        iIndex < cTrustees && dwErr == ERROR_SUCCESS;
        iIndex++)
    {
        dwErr = pAccList->RemoveTrusteeFromAccess(DACL_SECURITY_INFORMATION,
                                                  &(prgTrustees[iIndex]),
                                                  (PWSTR)pwszProperty);
    }

    //
    // Then, do the set
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = NtProvDoHandleSet(hObject,
                                  ObjectType,
                                  pAccList,
                                  pOverlapped,
                                  NTMARTA_DELETE_ALIST);
    }

    if(dwErr != ERROR_SUCCESS)
    {
        delete pAccList;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvRevokeAuditRights
//
//  Synopsis:   Revokes the audit rights on the given object.  It goes
//              through and removes any explicit entries for the given
//              trustees
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN  cTrustees]         --  Number of trustees in list
//              [IN  prgTrustees]       --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvRevokeAuditRights(IN             LPCWSTR             pwszObjectPath,
                         IN             SE_OBJECT_TYPE      ObjectType,
                         IN  OPTIONAL   LPCWSTR             pwszProperty,
                         IN             ULONG               cTrustees,
                         IN             PTRUSTEE            prgTrustees,
                         IN             PACTRL_OVERLAPPED   pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CAccessList *pAccList = NULL;
    //
    // First, read the relevant information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ACTRL_RIGHTS_INFO    RI;
        RI.pwszProperty = (PWSTR)pwszProperty;
        RI.SeInfo       = SACL_SECURITY_INFORMATION;

        PWSTR pwszTmpObjectPath = (PWSTR)AccAlloc( (wcslen(pwszObjectPath) + 1) * sizeof( WCHAR )  );

        if (pwszTmpObjectPath)
        {
            wcscpy( pwszTmpObjectPath, pwszObjectPath );
            pwszTmpObjectPath[wcslen(pwszObjectPath)] = UNICODE_NULL;

            dwErr = NtProvGetAccessListForObject(pwszTmpObjectPath,
                                                 ObjectType,
                                                 &RI,
                                                 1,
                                                 &pAccList);
            AccFree( pwszTmpObjectPath );
        }
        else
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    for(DWORD iIndex = 0;
        iIndex < cTrustees && dwErr == ERROR_SUCCESS;
        iIndex++)
    {
        dwErr = pAccList->RemoveTrusteeFromAccess(SACL_SECURITY_INFORMATION,
                                                  &(prgTrustees[iIndex]),
                                                  (PWSTR)pwszProperty);
    }

    //
    // Then, do the set
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = NtProvDoSet(pwszObjectPath,
                            ObjectType,
                            pAccList,
                            pOverlapped,
                            NTMARTA_DELETE_ALIST);
    }

    if(dwErr != ERROR_SUCCESS)
    {
        delete pAccList;
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleRevokeAuditRights
//
//  Synopsis:   Revokes the audit rights on the given object.  It goes
//              through and removes any explicit entries for the given
//              trustees
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN  cTrustees]         --  Number of trustees in list
//              [IN  prgTrustees]       --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleRevokeAuditRights(IN             HANDLE              hObject,
                               IN             SE_OBJECT_TYPE      ObjectType,
                               IN  OPTIONAL   LPCWSTR             pwszProperty,
                               IN             ULONG               cTrustees,
                               IN             PTRUSTEE            prgTrustees,
                               IN             PACTRL_OVERLAPPED   pOverlapped)
{
    DWORD   dwErr = ERROR_SUCCESS;

    CAccessList *pAccList = NULL;
    //
    // First, read the relevant information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        ACTRL_RIGHTS_INFO    RI;
        RI.pwszProperty = (PWSTR)pwszProperty;
        RI.SeInfo       = SACL_SECURITY_INFORMATION;
        dwErr = NtProvGetAccessListForHandle(hObject,
                                             ObjectType,
                                             &RI,
                                             1,
                                             &pAccList);
    }

    for(DWORD iIndex = 0;
        iIndex < cTrustees && dwErr == ERROR_SUCCESS;
        iIndex++)
    {
        dwErr = pAccList->RemoveTrusteeFromAccess(SACL_SECURITY_INFORMATION,
                                                  &(prgTrustees[iIndex]),
                                                  (PWSTR)pwszProperty);
    }

    //
    // Then, do the set
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = NtProvDoHandleSet(hObject,
                                  ObjectType,
                                  pAccList,
                                  pOverlapped,
                                  NTMARTA_DELETE_ALIST);
    }

    if(dwErr != ERROR_SUCCESS)
    {
        delete pAccList;
    }


    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvGetAllRights
//
//  Synopsis:   Gets the all the requested rights from the object.  This
//              includes the access rights, audit rights, and owner and group
//              if supported.
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [OUT ppAccessList]      --  Optional.  Where to return the
//                                          access list
//              [OUT ppAuditList]       --  Optional.  Where to return the
//                                          audit list.
//              [OUT ppOwner]           --  Number of trustees in list
//              [OUT ppGroup]           --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_INVALID_PARAMETER --  An non-NULL property name was
//                                          given on an object that doesn't
//                                          support properties.
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvGetAllRights(IN              LPCWSTR             pwszObjectPath,
                    IN              SE_OBJECT_TYPE      ObjectType,
                    IN              LPCWSTR             pwszProperty,
                    OUT OPTIONAL    PACTRL_ACCESS      *ppAccessList,
                    OUT OPTIONAL    PACTRL_AUDIT       *ppAuditList,
                    OUT OPTIONAL    PTRUSTEE           *ppOwner,
                    OUT OPTIONAL    PTRUSTEE           *ppGroup)
{
    acDebugOut((DEB_TRACE_API,"in AccProvGetAllRights\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Do the simple parameter checks first...
    //
    if(pwszProperty != NULL &&
           !(ObjectType == SE_DS_OBJECT_ALL || ObjectType == SE_DS_OBJECT))
    {
        return(ERROR_INVALID_PARAMETER);
    }

    SECURITY_INFORMATION    SeInfo = 0;

    //
    // Determine what we need to read
    //
    if(ppAccessList != NULL)
    {
        SeInfo |= DACL_SECURITY_INFORMATION;
        *ppAccessList = NULL;
    }

    if(ppAuditList != NULL)
    {
        SeInfo |= SACL_SECURITY_INFORMATION;
        *ppAuditList = NULL;
    }

    if(ppOwner != NULL)
    {
        SeInfo |= OWNER_SECURITY_INFORMATION;
        *ppOwner = NULL;
    }

    if(ppGroup != NULL)
    {
        SeInfo |= GROUP_SECURITY_INFORMATION;
        *ppGroup = NULL;
    }

    //
    // If nothing was requested, do nothing...
    //
    if(SeInfo == 0)
    {
        return(ERROR_SUCCESS);
    }

    //
    // Now, go ahead and do the read...
    //
    CAccessList   *pAccList;

    ACTRL_RIGHTS_INFO    RI;
    RI.pwszProperty = (PWSTR)pwszProperty;
    RI.SeInfo       = SeInfo;

    //
    // NtProvGetAccessListForObject modifies its first
    // parameter, so we can't pass in a CONST string.
    //

    PWSTR pwszTmpObjectPath = (PWSTR)AccAlloc( (wcslen(pwszObjectPath) + 1) * sizeof( WCHAR )  );

    if (pwszTmpObjectPath)
    {
        wcscpy( pwszTmpObjectPath, pwszObjectPath );
        pwszTmpObjectPath[wcslen(pwszObjectPath)] = UNICODE_NULL;

        dwErr = NtProvGetAccessListForObject(pwszTmpObjectPath,
                                             ObjectType,
                                             &RI,
                                             1,
                                             &pAccList);


        //
        // Now, get the data in the form we need
        //
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Now, convert the stuff that we need to...
            //
            dwErr = pAccList->MarshalAccessLists(SeInfo,
                                                 ppAccessList,
                                                 ppAuditList);

            if(dwErr == ERROR_SUCCESS && ppOwner != NULL)
            {
                dwErr = pAccList->GetSDSidAsTrustee(OWNER_SECURITY_INFORMATION,
                                                    ppOwner);
            }

            if(dwErr == ERROR_SUCCESS && ppGroup != NULL)
            {
                dwErr = pAccList->GetSDSidAsTrustee(GROUP_SECURITY_INFORMATION,
                                                    ppGroup);
            }

            //
            // Ok, if anything failed, we'll do the cleanup
            //
            if(dwErr != ERROR_SUCCESS)
            {
                if((SeInfo & DACL_SECURITY_INFORMATION) != 0)
                {
                    AccFree(*ppAccessList);
                }

                if((SeInfo & SACL_SECURITY_INFORMATION) != 0)
                {
                    AccFree(*ppAuditList);
                }

                if((SeInfo & OWNER_SECURITY_INFORMATION) != 0)
                {
                    AccFree(*ppOwner);
                }

                if((SeInfo & GROUP_SECURITY_INFORMATION) != 0)
                {
                    AccFree(*ppGroup);
                }
            }

            delete pAccList;
        }

        AccFree( pwszTmpObjectPath );
    }
    else
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // The destruction of the CAclList class will clean up all of the
    // memory we obtained
    //
    acDebugOut((DEB_TRACE_API,"out AccProvGetAllRights: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleGetAllRights
//
//  Synopsis:   Gets the all the requested rights from the object.  This
//              includes the access rights, audit rights, and owner and group
//              if supported.
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [OUT ppAccessList]      --  Optional.  Where to return the
//                                          access list
//              [OUT ppAuditList]       --  Optional.  Where to return the
//                                          audit list.
//              [OUT ppOwner]           --  Number of trustees in list
//              [OUT ppGroup]           --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_INVALID_PARAMETER --  An non-NULL property name was
//                                          given on an object that doesn't
//                                          support properties.
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleGetAllRights(IN              HANDLE              hObject,
                          IN              SE_OBJECT_TYPE      ObjectType,
                          IN              LPCWSTR             pwszProperty,
                          OUT OPTIONAL    PACTRL_ACCESS      *ppAccessList,
                          OUT OPTIONAL    PACTRL_AUDIT       *ppAuditList,
                          OUT OPTIONAL    PTRUSTEE           *ppOwner,
                          OUT OPTIONAL    PTRUSTEE           *ppGroup)
{
    acDebugOut((DEB_TRACE_API,"in AccProvHandleGetAllRights\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Do the simple parameter checks first...
    //
    if(pwszProperty != NULL &&
           (ObjectType != SE_DS_OBJECT_ALL && ObjectType != SE_DS_OBJECT))
    {
        return(ERROR_INVALID_PARAMETER);
    }

    SECURITY_INFORMATION    SeInfo = 0;

    //
    // Determine what we need to read
    //
    if(ppAccessList != NULL)
    {
        SeInfo |= DACL_SECURITY_INFORMATION;
        *ppAccessList = NULL;
    }

    if(ppAuditList != NULL)
    {
        SeInfo |= SACL_SECURITY_INFORMATION;
        *ppAuditList = NULL;
    }

    if(ppOwner != NULL)
    {
        SeInfo |= OWNER_SECURITY_INFORMATION;
        *ppOwner = NULL;
    }

    if(ppGroup != NULL)
    {
        SeInfo |= GROUP_SECURITY_INFORMATION;
        *ppGroup = NULL;
    }

    //
    // If nothing was requested, do nothing...
    //
    if(SeInfo == 0)
    {
        return(ERROR_SUCCESS);
    }

    //
    // Now, go ahead and do the read...
    //
    CAccessList   *pAccList;

    ACTRL_RIGHTS_INFO    RI;
    RI.pwszProperty = (PWSTR)pwszProperty;
    RI.SeInfo       = SeInfo;
    dwErr = NtProvGetAccessListForHandle(hObject,
                                         ObjectType,
                                         &RI,
                                         1,
                                         &pAccList);


    //
    // Now, get the data in the form we need
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Now, convert the stuff that we need to...
        //
        dwErr = pAccList->MarshalAccessLists(SeInfo,
                                             ppAccessList,
                                             ppAuditList);

        if(dwErr == ERROR_SUCCESS && ppOwner != NULL)
        {
            dwErr = pAccList->GetSDSidAsTrustee(OWNER_SECURITY_INFORMATION,
                                                ppOwner);
        }

        if(dwErr == ERROR_SUCCESS && ppGroup != NULL)
        {
            dwErr = pAccList->GetSDSidAsTrustee(GROUP_SECURITY_INFORMATION,
                                                ppGroup);
        }

        //
        // Ok, if anything failed, we'll do the cleanup
        //
        if(dwErr != ERROR_SUCCESS)
        {
            if((SeInfo & DACL_SECURITY_INFORMATION) != 0)
            {
                AccFree(*ppAccessList);
            }

            if((SeInfo & SACL_SECURITY_INFORMATION) != 0)
            {
                AccFree(*ppAuditList);
            }

            if((SeInfo & OWNER_SECURITY_INFORMATION) != 0)
            {
                AccFree(*ppOwner);
            }

            if((SeInfo & GROUP_SECURITY_INFORMATION) != 0)
            {
                AccFree(*ppGroup);
            }
        }

        delete pAccList;
    }

    //
    // The destruction of the CAclList class will clean up all of the
    // memory we obtained
    //
    acDebugOut((DEB_TRACE_API,"out AccProvHandleGetAllRights: %lu\n", dwErr));
    return(dwErr);
}




DWORD
AccProvpDoTrusteeAccessCalculations(IN      CAccessList    *pAccList,
                                    IN      PTRUSTEE        pTrustee,
                                    IN OUT  PTRUSTEE_ACCESS pTrusteeAccess)
{
    DWORD   dwErr;

    ULONG   DeniedMask;
    ULONG   AllowedMask;
    dwErr = pAccList->GetExplicitAccess(pTrustee,
                                        (PWSTR)pTrusteeAccess->lpProperty,
                                        &DeniedMask,
                                        &AllowedMask);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Process the entries
        //

        //
        // It depends on what it is we're looking for...
        //
        pTrusteeAccess->fReturnedAccess = 0;
        if(pTrusteeAccess->fAccessFlags == TRUSTEE_ACCESS_EXPLICIT)
        {
            //
            // Ok, we'll look for these explicit rights
            //

            //
            // First, see if any of our denieds match...
            //
            if (pTrusteeAccess->Access == TRUSTEE_ACCESS_ALL)
            {
                pTrusteeAccess->fReturnedAccess = AllowedMask & ~DeniedMask;
            }
            else
            {
                if((pTrusteeAccess->Access & DeniedMask) == 0)
                {
                    //
                    // Now, see if we're allowed
                    //
                    if((pTrusteeAccess->Access & AllowedMask) ==
                                                       pTrusteeAccess->Access)
                    {
                        pTrusteeAccess->fReturnedAccess =
                                                      TRUSTEE_ACCESS_ALLOWED;
                    }
                }
            }
        }
        else if(FLAG_ON(pTrusteeAccess->fAccessFlags, TRUSTEE_ACCESS_READ) ||
                FLAG_ON(pTrusteeAccess->fAccessFlags, TRUSTEE_ACCESS_WRITE))
        {
            //
            // We're only looking for read/write access
            //
            ACCESS_RIGHTS   Access[2];
            ULONG           fValue[2], i = 0;

            if(FLAG_ON(pTrusteeAccess->fAccessFlags, TRUSTEE_ACCESS_READ))
            {
                Access[i] = ACTRL_READ_CONTROL;
                fValue[i] = TRUSTEE_ACCESS_READ;
                i++;
            }

            if(FLAG_ON(pTrusteeAccess->fAccessFlags, TRUSTEE_ACCESS_WRITE))
            {
                Access[i] = ACTRL_CHANGE_ACCESS | ACTRL_CHANGE_OWNER;
                fValue[i] = TRUSTEE_ACCESS_WRITE;
                i++;
            }

            for(ULONG iIndex = 0; iIndex < i; iIndex++)
            {
                if((Access[iIndex] & DeniedMask) == 0)
                {
                    //
                    // Now, see if we're allowed
                    //
                    if((Access[iIndex] & AllowedMask) == Access[iIndex])
                    {
                        pTrusteeAccess->fReturnedAccess |= fValue[iIndex];
                    }
                }
            }
        }
        else
        {
            dwErr = ERROR_INVALID_PARAMETER;
        }

        //
        // If we asked for read/write access, make sure we have them both
        //
        if(dwErr == ERROR_SUCCESS && pTrusteeAccess->fAccessFlags == TRUSTEE_ACCESS_READ_WRITE)
        {
            if( pTrusteeAccess->fReturnedAccess != TRUSTEE_ACCESS_READ_WRITE )
            {
                pTrusteeAccess->fReturnedAccess = 0;
            }
        }

    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvGetTrusteesAccess
//
//  Synopsis:   Determines whether the given trustee has the specified
//              rights to the object
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN OUT pTrusteeAccess] --  Type of access to check for
//                                          and where the access is returned
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvGetTrusteesAccess(IN     LPCWSTR             pwszObjectPath,
                         IN     SE_OBJECT_TYPE      ObjectType,
                         IN     PTRUSTEE            pTrustee,
                         IN OUT PTRUSTEE_ACCESS     pTrusteeAccess)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, we'll load all the objects entries that we need
    //
    CAccessList    *pAccList;
    ACTRL_RIGHTS_INFO    RI;
    RI.pwszProperty = (PWSTR)pTrusteeAccess->lpProperty;
    RI.SeInfo       = DACL_SECURITY_INFORMATION;

    PWSTR pwszTmpObjectPath = (PWSTR)AccAlloc( (wcslen(pwszObjectPath) + 1) * sizeof( WCHAR )  );

    if (pwszTmpObjectPath)
    {
        wcscpy( pwszTmpObjectPath, pwszObjectPath );
        pwszTmpObjectPath[wcslen(pwszObjectPath)] = UNICODE_NULL;

        dwErr = NtProvGetAccessListForObject(pwszTmpObjectPath,
                                             ObjectType,
                                             &RI,
                                             1,
                                             &pAccList);
        AccFree( pwszTmpObjectPath );
    }
    else
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpDoTrusteeAccessCalculations(pAccList,
                                                    pTrustee,
                                                    pTrusteeAccess);
        delete pAccList;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleGetTrusteesAccess
//
//  Synopsis:   Determines whether the given trustee has the specified
//              rights to the object
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN OUT pTrusteeAccess] --  Type of access to check for
//                                          and where the access is returned
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleGetTrusteesAccess(IN     HANDLE              hObject,
                               IN     SE_OBJECT_TYPE      ObjectType,
                               IN     PTRUSTEE            pTrustee,
                               IN OUT PTRUSTEE_ACCESS     pTrusteeAccess)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, we'll load all the objects entries that we need
    //
    CAccessList    *pAccList;
    ACTRL_RIGHTS_INFO    RI;
    RI.pwszProperty = (PWSTR)pTrusteeAccess->lpProperty;
    RI.SeInfo       = DACL_SECURITY_INFORMATION;

    dwErr = NtProvGetAccessListForHandle(hObject,
                                         ObjectType,
                                         &RI,
                                         1,
                                         &pAccList);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpDoTrusteeAccessCalculations(pAccList,
                                                    pTrustee,
                                                    pTrusteeAccess);

        delete pAccList;
    }

    return(dwErr);
}




DWORD
AccProvpDoAccessAuditedCalculations(IN   CAccessList   *pAccList,
                                    IN   LPCWSTR        pwszProperty,
                                    IN   PTRUSTEE       pTrustee,
                                    IN   ACCESS_RIGHTS  ulAuditRights,
                                    OUT  PBOOL          pfAuditedSuccess,
                                    OUT  PBOOL          pfAuditedFailure)
{
    ULONG   SuccessMask;
    ULONG   FailureMask;
    DWORD   dwErr = pAccList->GetExplicitAudits(pTrustee,
                                               (PWSTR)pwszProperty,
                                                &SuccessMask,
                                                &FailureMask);
    if(dwErr == ERROR_SUCCESS)
    {

        //
        // Process the entries
        //
        *pfAuditedSuccess = FALSE;
        *pfAuditedFailure = FALSE;
        if((ulAuditRights & SuccessMask) == ulAuditRights)
        {
            *pfAuditedSuccess = TRUE;
        }

        if((ulAuditRights & FailureMask) == ulAuditRights)
        {
            *pfAuditedFailure = TRUE;
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvIsAccessAudited
//
//  Synopsis:   Determines whether the given trustee will envoke an audit
//              entry by accessing the object
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN  pTrustee]          --  Trustee for which to check access
//              [IN  AuditRights]       --  Type of audit we care about
//              [OUT pfAccessAllowed]   --  Where the results are returned.
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvIsAccessAudited(IN  LPCWSTR          pwszObjectPath,
                       IN  SE_OBJECT_TYPE   ObjectType,
                       IN  LPCWSTR          pwszProperty,
                       IN  PTRUSTEE         pTrustee,
                       IN  ACCESS_RIGHTS    AuditRights,
                       OUT PBOOL            pfAuditedSuccess,
                       OUT PBOOL            pfAuditedFailure)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, we'll load all the objects entries that we need
    //
    CAccessList    *pAccList;

    ACTRL_RIGHTS_INFO   RI;
    RI.pwszProperty = (PWSTR)pwszProperty;
    RI.SeInfo       = SACL_SECURITY_INFORMATION;

    PWSTR pwszTmpObjectPath = (PWSTR)AccAlloc( (wcslen(pwszObjectPath) + 1) * sizeof( WCHAR )  );

    if (pwszTmpObjectPath)
    {
        wcscpy( pwszTmpObjectPath, pwszObjectPath );
        pwszTmpObjectPath[wcslen(pwszObjectPath)] = UNICODE_NULL;

        dwErr = NtProvGetAccessListForObject(pwszTmpObjectPath,
                                             ObjectType,
                                             &RI,
                                             1,
                                             &pAccList);
        AccFree( pwszTmpObjectPath );
    }
    else
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpDoAccessAuditedCalculations(pAccList,
                                                    pwszProperty,
                                                    pTrustee,
                                                    AuditRights,
                                                    pfAuditedSuccess,
                                                    pfAuditedFailure);
        delete pAccList;
    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleIsAccessAudited
//
//  Synopsis:   Determines whether the given trustee will envoke an audit
//              entry by accessing the object
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN  pTrustee]          --  Trustee for which to check access
//              [IN  ulAuditRights]     --  Type of audit we care about
//              [OUT pfAccessAllowed]   --  Where the results are returned.
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleIsAccessAudited(IN  HANDLE           hObject,
                             IN  SE_OBJECT_TYPE   ObjectType,
                             IN  LPCWSTR          pwszProperty,
                             IN  PTRUSTEE         pTrustee,
                             IN  ACCESS_RIGHTS    AuditRights,
                             OUT PBOOL            pfAuditedSuccess,
                             OUT PBOOL            pfAuditedFailure)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, first, we'll load all the objects entries that we need
    //
    CAccessList    *pAccList;

    ACTRL_RIGHTS_INFO   RI;
    RI.pwszProperty = (PWSTR)pwszProperty;
    RI.SeInfo       = SACL_SECURITY_INFORMATION;
    dwErr = NtProvGetAccessListForHandle(hObject,
                                         ObjectType,
                                         &RI,
                                         1,
                                         &pAccList);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpDoAccessAuditedCalculations(pAccList,
                                                    pwszProperty,
                                                    pTrustee,
                                                    AuditRights,
                                                    pfAuditedSuccess,
                                                    pfAuditedFailure);
        delete pAccList;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvpGetAccessInfoPerObjectType
//
//  Synopsis:   Returns the list of available access permissions for the
//              specified object type
//
//  Arguments:  [IN  ObjectType]        --  Type of the object
//              [IN  DsObjType]         --  If this is a DS object, the type
//                                          of the object
//              [IN  pwszDsPath]        --  Full path to the object
//
//              [IN  lpProperty]        --  Optional.  If present, the name of
//                                          the property to get the access
//                                          rights for.
//              [IN  fIsDir]            --  If TRUE, the path is a directory
//              [OUT pcEntries]         --  Where the count of items is returned
//              [OUT ppAccessInfo]      --  Where the list of items is returned
//              [OUT pcControlRights]   --  Count of control rights are
//                                          is returned here
//              [OUT ppControlRights]   --  Where the list of control rights
//                                          is returned
//              [OUT pfAccessFlags]     --  Where the provider flags are
//                                          returned.
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_INVALID_PARAMETER --  The operation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvpGetAccessInfoPerObjectType(IN   SE_OBJECT_TYPE           ObjectType,
                                   IN   BOOL                     fIsDir,
                                   IN   PWSTR                    pwszDsPath,
                                   IN   PWSTR                    lpProperty,
                                   OUT  PULONG                   pcEntries,
                                   OUT  PACTRL_ACCESS_INFO  *ppAccessInfoList,
                                   OUT  PULONG               pcControlRights,
                                   OUT  PACTRL_CONTROL_INFOW *ppControlRights,
                                   OUT  PULONG               pfAccessFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    ControlRightsValid = FALSE;
    ULONG   cStart = 0;
    ULONG   cItems = 0;

    #define LENGTH_OF_STR_GUID 37
    #define LENGTH_OF_LONGEST_STRING   20

    //
    // DS control rights
    //
    *pfAccessFlags = ACTRL_ACCESS_NO_OPTIONS;

    *ppControlRights = NULL;
    *pcControlRights = 0;

    *ppAccessInfoList = 0;
    *pcEntries = 0;

    //
    // Do the right thing based on the object type
    //
    switch (ObjectType)
    {
    case SE_LMSHARE:                                // FALL THROUGH
    case SE_FILE_OBJECT:
        if(fIsDir == TRUE)
        {
            cStart = ACCPROV_DIR_ACCESS;
            cItems = ACCPROV_NUM_DIR;
        }
        else
        {
            cStart = ACCPROV_FILE_ACCESS;
            cItems = ACCPROV_NUM_FILE;
        }
        break;

    case SE_SERVICE:
        cStart = ACCPROV_SERVICE_ACCESS;
        cItems = ACCPROV_NUM_SERVICE;
        break;

    case SE_PRINTER:
        cStart = ACCPROV_PRINT_ACCESS;
        cItems = ACCPROV_NUM_PRINT;
        break;

    case SE_REGISTRY_KEY:
        cStart = ACCPROV_REGISTRY_ACCESS;
        cItems = ACCPROV_NUM_REGISTRY;
        break;

    case SE_KERNEL_OBJECT:                          // FALL THROUGH
    case SE_WMIGUID_OBJECT:
        cStart = ACCPROV_KERNEL_ACCESS;
        cItems = ACCPROV_NUM_KERNEL;
        break;

    case SE_DS_OBJECT:                              // FALL THROUGH
    case SE_DS_OBJECT_ALL:
        cStart = ACCPROV_DS_ACCESS;
        cItems = ACCPROV_NUM_DS;
        ControlRightsValid = TRUE;
        break;

    case SE_WINDOW_OBJECT:
        cStart = ACCPROV_WIN_ACCESS;
        cItems = ACCPROV_NUM_WIN;
        break;

    default:
        dwErr = ERROR_INVALID_PARAMETER;
    }

    if(dwErr == ERROR_SUCCESS && ControlRightsValid == FALSE && lpProperty != NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Ok, we go through and size all of the strings that we need to add
        //
        ULONG cSize = 0;
        WCHAR   wszBuff[ACCPROV_LONGEST_STRING + 1];
        for(ULONG iIndex = 0; iIndex < cItems; iIndex++)
        {
            LoadString(ghDll, cStart + iIndex, wszBuff, ACCPROV_LONGEST_STRING);

            cSize += SIZE_PWSTR(wszBuff);
        }


        //
        // Always return the standard rights, as well...
        //
        for(iIndex = 0; iIndex < ACCPROV_NUM_STD; iIndex++)
        {
            LoadString(ghDll,
                       ACCPROV_STD_ACCESS + iIndex,
                       wszBuff,
                       ACCPROV_LONGEST_STRING);
            cSize += SIZE_PWSTR(wszBuff);
        }

        //
        // Make sure to return the proper count
        //
        *pcEntries = cItems + ACCPROV_NUM_STD;

        //
        // Ok, now we can allocate, and do the same thing again
        //
        *ppAccessInfoList = (PACTRL_ACCESS_INFO)AccAlloc(
                        (cItems + ACCPROV_NUM_STD) * sizeof(ACTRL_ACCESS_INFO) +
                        cSize);
        if(*ppAccessInfoList == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }

        if(*ppAccessInfoList == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            PWSTR   pwszStart = (PWSTR)((PBYTE)(*ppAccessInfoList) +
                          (cItems + ACCPROV_NUM_STD) * sizeof(ACTRL_ACCESS_INFO));
            //
            // Start with the standard items
            //
            ULONG iLst = 0;
            for(iIndex = 0; iIndex < ACCPROV_NUM_STD; iIndex++)
            {
                LoadString(ghDll,
                           ACCPROV_STD_ACCESS + iIndex,
                           wszBuff,
                           ACCPROV_LONGEST_STRING);
                cSize = SIZE_PWSTR(wszBuff);

                memcpy(pwszStart,
                       wszBuff,
                       cSize);

                //
                // Handle STD_RIGTHS_ALL as a special case...
                //
                if(iIndex == ACCPROV_NUM_STD - 1)
                {
                    (*ppAccessInfoList)[iLst].fAccessPermission = ACTRL_STD_RIGHTS_ALL;
                }
                else
                {
                    (*ppAccessInfoList)[iLst].fAccessPermission =
                                                           ACTRL_SYSTEM_ACCESS << iIndex;
                }
                (*ppAccessInfoList)[iLst].lpAccessPermissionName = pwszStart;
                pwszStart = (PWSTR)Add2Ptr(pwszStart,cSize);
                iLst++;
            }


            for(ULONG iIndex = 0; iIndex < cItems; iIndex++)
            {
                LoadString(ghDll,
                           cStart + iIndex, wszBuff, ACCPROV_LONGEST_STRING);

                cSize = SIZE_PWSTR(wszBuff);

                memcpy(pwszStart,
                       wszBuff,
                       cSize);
                (*ppAccessInfoList)[iLst].fAccessPermission =
                                                           ACTRL_PERM_1 << iIndex;
                (*ppAccessInfoList)[iLst].lpAccessPermissionName = pwszStart;
                pwszStart = (PWSTR)Add2Ptr(pwszStart,cSize);
                iLst++;
            }

            //
            // Now, add extra control rights
            //

            if(ObjectType == SE_DS_OBJECT || ObjectType == SE_DS_OBJECT_ALL )
            {
                dwErr = AccctrlLookupRightsByName( NULL,
                                                   pwszDsPath,
                                                   lpProperty,
                                                   pcControlRights,
                                                   ppControlRights);

                //
                // If we can't find the entry we want, return 0 items...
                //
                if(dwErr == ERROR_NOT_FOUND)
                {
                    *pcControlRights = 0;
                    *ppControlRights = NULL;
                    dwErr = ERROR_SUCCESS;
                }
            }
        }
    }


    if(dwErr == ERROR_SUCCESS)
    {
        *pcEntries = cItems + ACCPROV_NUM_STD;

    }
    else
    {
        if(*ppAccessInfoList != NULL)
        {
            AccFree(*ppAccessInfoList);
            *pcEntries = 0;
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvGetAccessInfoPerObjectType
//
//  Synopsis:   Returns the list of available access permissions for the
//              specified object type
//
//  Arguments:  [IN  lpObject]          --  Full path to the object
//              [IN  ObjectType]        --  Type of the object
//              [IN  lpProperty]        --  Optional.  If present, the name of
//                                          the property to get the access
//                                          rights for.
//              [OUT pcEntries]         --  Where the count of items is returned
//              [OUT ppAccessInfo]      --  Where the list of items is returned
//              [OUT pfAccessFlags]     --  Where the provider flags are
//                                          returned.
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_INVALID_PARAMETER --  The operation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvGetAccessInfoPerObjectType(IN   LPCWSTR              lpObject,
                                  IN   SE_OBJECT_TYPE       ObjectType,
                                  IN   LPCWSTR              lpProperty,
                                  OUT  PULONG               pcEntries,
                                  OUT  PACTRL_ACCESS_INFO  *ppAccessInfoList,
                                  OUT  PULONG               pcControlRights,
                                  OUT  PACTRL_CONTROL_INFOW *ppControlRights,
                                  OUT  PULONG               pfAccessFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fIsDir = FALSE;

    if(ObjectType == SE_LMSHARE || ObjectType == SE_FILE_OBJECT)
    {
        //
        // Check to see whether this is a file or a directory...
        //
        ULONG ulAttribs = GetFileAttributes((PWSTR)lpObject);
        if(FLAG_ON(ulAttribs, FILE_ATTRIBUTE_DIRECTORY))
        {
            fIsDir = TRUE;
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpGetAccessInfoPerObjectType(ObjectType,
                                                   fIsDir,
                                                   (LPWSTR)lpObject,
                                                   (LPWSTR)lpProperty,
                                                   pcEntries,
                                                   ppAccessInfoList,
                                                   pcControlRights,
                                                   ppControlRights,
                                                   pfAccessFlags);
    }
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   AccProvHandleGetAccessInfoPerObjectType
//
//  Synopsis:   Returns the list of available access permissions for the
//              specified object type
//
//  Arguments:  [IN  hObject]           --  Handle to the open object
//              [IN  ObjectType]        --  Type of the object
//              [IN  lpProperty]        --  Optional.  If present, the name of
//                                          the property to get the access
//                                          rights for.
//              [OUT pcEntries]         --  Where the count of items is returned
//              [OUT ppAccessInfo]      --  Where the list of items is returned
//              [OUT pfAccessFlags]     --  Where the provider flags are
//                                          returned.
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_INVALID_PARAMETER --  The operation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
AccProvHandleGetAccessInfoPerObjectType(IN   HANDLE               hObject,
                                        IN   SE_OBJECT_TYPE       ObjectType,
                                        IN   LPCWSTR              lpProperty,
                                        OUT  PULONG               pcEntries,
                                        OUT  PACTRL_ACCESS_INFO  *ppAccessInfoList,
                                        OUT  PULONG               pcControlRights,
                                        OUT  PACTRL_CONTROL_INFOW *ppControlRights,
                                        OUT  PULONG               pfAccessFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    fIsDir = FALSE;

    if(ObjectType == SE_LMSHARE || ObjectType == SE_FILE_OBJECT)
    {
        BY_HANDLE_FILE_INFORMATION  BHFI;
        //
        // Check to see whether this is a file or a directory...
        //
        if(GetFileInformationByHandle(hObject,
                                      &BHFI) == FALSE)
        {
            dwErr = GetLastError();
        }
        else
        {
            if(FLAG_ON(BHFI.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY))
            fIsDir = TRUE;
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccProvpGetAccessInfoPerObjectType(ObjectType,
                                                   fIsDir,
                                                   NULL,
                                                   (LPWSTR)lpProperty,
                                                   pcEntries,
                                                   ppAccessInfoList,
                                                   pcControlRights,
                                                   ppControlRights,
                                                   pfAccessFlags);
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\member.cxx ===
//+------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1994 - 1996.
//
// File:        member.cxx
//
// Classes:     CMemberCheck
//
// History:     Nov-94      DaveMont         Created.
//
//-------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

extern "C"
{
    #include <ntprov.hxx>
    #include <strings.h>
}

SID WORLD_SID = {SID_REVISION,
                 1,
                 SECURITY_WORLD_SID_AUTHORITY,
                 SECURITY_WORLD_RID};

#define MARTA_MAX_RECURSION_COUNT 256
//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::Init, public
//
//  Synopsis:   initializes the class
//
//  Arguments:  none
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::Init()
{
    acDebugOut((DEB_TRACE, "In CMemberCheck::Init\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // get the local machine name
    //
    ULONG   cSize = MAX_COMPUTERNAME_LENGTH + 1;
    if(GetComputerName(_wszComputerName, &cSize) == FALSE)
    {
        dwErr = GetLastError();
    }

    acDebugOut((DEB_TRACE, "Out CMemberCheck::Init: %lu\n", dwErr));

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::IsMemberOf, public
//
//  Synopsis:   Checks if the current sid is a member of the input sid.
//              The current sid is a part of our initialize TRUSTEE_NODE and
//              the input sid is in our passed in TRUSTEE_NODE
//
//  Arguments:  [IN  pTrusteeNode]          --  Input TRUSTEE_NODE
//              [OUT pfIsMemberOf]          --  Where the results are returned.
//                                              Is TRUE if the initialization
//                                              SID is a member of the input
//                                              SID.
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::IsMemberOf(IN  PTRUSTEE_NODE  pTrusteeNode,
                               OUT PBOOL          pfIsMemberOf)
{
    acDebugOut((DEB_TRACE, "In CMemberCheck::IsMemberOf\n"));
    DWORD   dwErr = ERROR_SUCCESS;

    if(RtlEqualSid(pTrusteeNode->pSid, &WORLD_SID) == TRUE)
    {
        *pfIsMemberOf = TRUE;
    }
    else if(RtlEqualSid(_pCurrentNode->pSid, pTrusteeNode->pSid) == TRUE)
    {
        //
        // If they're the same sid, they're bound to be a member of eachother
        //
        *pfIsMemberOf = TRUE;
    }
    else if(pTrusteeNode->SidType == SidTypeGroup)
    {
        //
        // We'll have to look it up, and check for group membership
        //
        dwErr = CheckGroup(pTrusteeNode->pSid,
                           pfIsMemberOf, 
                           1);
    }
    else if(pTrusteeNode->SidType == SidTypeAlias)
    {
        //
        // We'll have to expand the alias and look
        //
        dwErr = CheckAlias(pTrusteeNode->pSid,
                           pfIsMemberOf, 
                           1);
    }
    else
    {
        //
        // Well, here's something we don't know how to handle
        //
        *pfIsMemberOf = FALSE;
    }

    acDebugOut((DEB_TRACE,
                "Out CMemberCheck::IsMemberOf(%lx)(%d)\n",
                dwErr,
                *pfIsMemberOf));
    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Member:     GetDomainName, private
//
//  Synopsis:   gets the domain name for the given sid
//
//  Arguments:  [IN  pSid]             --  Input Sid
//              [OUT ppwszDomainName]  --  To return the domain name
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------

DWORD
GetDomainName(
    IN PSID pSid,
    OUT PWSTR *ppwszDomainName
    )
{
    LPWSTR Name = NULL;
    LPWSTR RefName = NULL;
    SID_NAME_USE SidType;

    //
    // Lookup the sid and get the name for the user.
    //

    DWORD dwErr = AccLookupAccountName(
                      NULL,
                      pSid,
                      ppwszDomainName,
                      &RefName,
                      &SidType
                      );

    if (dwErr == ERROR_SUCCESS) 
    {
        //
        // The returned string is of the type "Domain\\User". Strip off the 
        // backslash to get the name of the domain.
        //

        PWSTR pwszTmp = wcschr(*ppwszDomainName, L'\\');

        if(pwszTmp != NULL)
        {
            *pwszTmp = L'\0';
        }

        //
        // We do not need this one. Free it.
        //

        AccFree(RefName);
    }

    return dwErr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::GetDomainInfo, private
//
//  Synopsis:   gets the domain handle for the domain of the specified account
//
//  Arguments:  [IN  pSid]          --  Input Sid
//
//  Returns:    ERROR_SUCCESS               --  Success
//              ERROR_NOT_ENOUGH_MEMORY     --  A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::GetDomainInfo(IN  PSID    pSid)
{
    acDebugOut((DEB_TRACE, "In CMemberCheck::GetDomainInfo\n"));

    NTSTATUS Status = STATUS_SUCCESS;
    BOOL     fSidMatched = FALSE;
    PISID    pCheckSid;


    DWORD dwErr = LoadDLLFuncTable();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //
    // allocate a spare sid so we can grovel in it for the domain id
    //
    pCheckSid = (PISID)AccAlloc(RtlLengthSid(pSid));
    if(pCheckSid != NULL)
    {
        Status = RtlCopySid(RtlLengthSid(pSid),
                                         pCheckSid,
                                         pSid);
        if(NT_SUCCESS(Status))
        {

            //
            // make it the domain identifier 
            //
            if(pCheckSid->SubAuthorityCount > 1)
            {
                --(pCheckSid->SubAuthorityCount);
            }

            //
            // if we already have a domain sid, check it against the input sid
            //
            if(_pDomainSid != NULL)
            {
                if(RtlEqualSid(pCheckSid, _pDomainSid))
                {
                    //
                    // in this case we are all done.
                    //
                    AccFree(pCheckSid);
                    pCheckSid = NULL;
                    fSidMatched = TRUE;
                }
            }


            if ( fSidMatched == FALSE)
            {
                PDOMAIN_CONTROLLER_INFO DomainInfo = NULL;

                //
                // Free the current sid
                //
                AccFree(_pDomainSid);
                _pDomainSid = NULL;

                if(_hDomain)
                {
                    (*DLLFuncs.PSamCloseHandle)(_hDomain);
                    _hDomain = NULL;
                }

                SAM_HANDLE      hSam = NULL;

                PWSTR pwszDomainName = NULL;

                dwErr = GetDomainName(pSid, &pwszDomainName);

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // If we know the domain name of the input sid, check for
                    // well known, and local names
                    //
                    if(pwszDomainName != NULL)
                    {
                        WCHAR wszStringBuffer[256];

                        if (!LoadString(ghDll,
                                   ACCPROV_BUILTIN,
                                   wszStringBuffer,
                                   sizeof( wszStringBuffer ) / sizeof( WCHAR ))
                                   ) {
                            wszStringBuffer[0] = L'\0';
                        }

                        if(_wcsicmp(pwszDomainName,
                                    wszStringBuffer) != 0)
                        {
                            if (!LoadString(ghDll,
                                       ACCPROV_NTAUTHORITY,
                                       wszStringBuffer,
                                       sizeof( wszStringBuffer ) / sizeof( WCHAR ))
                                       ) {
                                wszStringBuffer[0] = L'\0';
                            }

                            if(_wcsicmp(pwszDomainName,
                                        wszStringBuffer) != 0)
                            {
                                if(_wcsicmp(_wszComputerName,
                                          pwszDomainName) != 0)
                                {
                                    dwErr = DsGetDcName(NULL, pwszDomainName, NULL, NULL, 0, &DomainInfo);
                                }
                            }
                        }
                    }


                    if(dwErr == ERROR_SUCCESS)
                    {
                        UNICODE_STRING UnicodeString = {0};
                        
                        if (DomainInfo != NULL)
                        {
                            RtlInitUnicodeString(&UnicodeString, DomainInfo->DomainControllerName);
                        }

                        OBJECT_ATTRIBUTES ObjAttrib;
                        Status = (*DLLFuncs.PSamConnect)(
                                       DomainInfo ? &UnicodeString : NULL,
                                       &hSam,
                                       GENERIC_EXECUTE,
                                       &ObjAttrib);


                        if(NT_SUCCESS(Status))
                        {
                            //
                            // open the domain
                            //
                            Status = (*DLLFuncs.PSamOpenDomain)(
                                                hSam,
                                                GENERIC_READ | DOMAIN_LOOKUP,
                                                pCheckSid,
                                                &_hDomain);

                            (*DLLFuncs.PSamCloseHandle)(hSam);
                        }

                        dwErr = RtlNtStatusToDosError(Status);
                    }

                       
                    if (DomainInfo)
                    {
                        NetApiBufferFree(DomainInfo);
                        DomainInfo = NULL;
                    }

                    AccFree(pwszDomainName);

                    if(dwErr == ERROR_SUCCESS)
                    {
                        //
                        // We have a new DomainSid
                        //
                        _pDomainSid = pCheckSid;
                        pCheckSid = NULL;
                    }
                }
            }
        }
        else
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
    }
    else
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (pCheckSid != NULL) 
    {
        AccFree(pCheckSid);
    }

    acDebugOut((DEB_TRACE, "Out CMemberCheck::_GetDomainInfo: %lu\n",
               dwErr));

    return(dwErr);
}
//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::CheckDomainUsers, private
//
//  Synopsis:   Checks if the Group is Domain Users and if the Users Domain sid
//              is the same as that of the group.
//
//  Arguments:  [IN  pSid]          --  Input Sid
//              [OUT pfIsMemberOf]          --  Where the results are returned.
//                                              Is TRUE if the current SID
//                                              is a member of the input SID
//                                              group.
//              [OUT pbQuitEarly]          --  Is TRUE if the group is Domain Users
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::CheckDomainUsers(IN  PSID  pSid,
                                     OUT PBOOL pfIsMemberOf, 
                                     OUT PBOOL pbQuitEarly)
{
    DWORD Rid = ((PISID) pSid)->SubAuthority[((PISID) pSid)->SubAuthorityCount-1];
    BOOL b = FALSE;
    BOOL bEqual = FALSE;
    SAM_HANDLE hUser = 0;
    PUCHAR Buffer = NULL;
    NTSTATUS status = STATUS_SUCCESS;

    if (Rid != DOMAIN_GROUP_RID_USERS)
    {
        //
        // No need to do anything. Just return.
        //

        return ERROR_SUCCESS;
    }

    //
    // Since it is domain users we will quit early.
    //

    *pbQuitEarly = TRUE;

    b = EqualDomainSid(pSid, _pCurrentNode->pSid, &bEqual);

    //
    // ERROR_NON_DOMAIN_SID is returned for wellknown sids.
    // It is ok to ignore this error and continue.
    //

    if ((b == FALSE) && (GetLastError() != ERROR_NON_DOMAIN_SID))
    {
        return GetLastError();
    }

    //
    // If the domains do not match, return FALSE.
    //

    if (!bEqual)
    {
        return ERROR_SUCCESS;
    }

    //
    // Get the Rid for the user.
    //

    DWORD dwRelativeId = *RtlSubAuthoritySid(
                             _pCurrentNode->pSid,
                             *RtlSubAuthorityCountSid(_pCurrentNode->pSid) - 1
                             );

    //
    // Open the user for read.
    //
    
    status = SamOpenUser(
                 _hDomain,
                 USER_READ_GENERAL,
                 dwRelativeId,
                 &hUser
                 );
    
    if (!NT_SUCCESS(status))
    {
        return RtlNtStatusToDosError(status);
    }
    
    //
    // Get the primary group information for the user.
    //
    
    status = SamQueryInformationUser(
                 hUser,
                 UserPrimaryGroupInformation,
                 (PVOID *) &Buffer
                 );

    SamCloseHandle(hUser);

    if (!NT_SUCCESS(status))
    {
        return RtlNtStatusToDosError(status);
    }

    //
    // If the primary group matched then return TRUE.
    //

    if (DOMAIN_GROUP_RID_USERS == ((USER_PRIMARY_GROUP_INFORMATION *) Buffer)->PrimaryGroupId)
    {
        *pfIsMemberOf = TRUE;
    }

    (VOID) SamFreeMemory(Buffer);

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::CheckGroup, private
//
//  Synopsis:   Checks if the objects account is in the specifed group
//              account
//
//  Arguments:  [IN  pSid]                  --  Input Sid
//              [OUT pfIsMemberOf]          --  Where the results are returned.
//                                              Is TRUE if the current SID
//                                              is a member of the input SID
//                                              group.
//              [IN RecursionCount]         -- Recursion level 
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::CheckGroup(IN  PSID  pSid,
                               OUT PBOOL pfIsMemberOf,
                               IN  DWORD RecursionCount)
{
    acDebugOut((DEB_TRACE, "In CMemberCheck::CheckGroup\n"));
    NTSTATUS    Status;
    SAM_HANDLE  hSam = NULL;
    ULONG       rid = ((PISID)(pSid))->SubAuthority[
                         ((PISID)(pSid))->SubAuthorityCount-1];
    BYTE LocalBuffer[8 + 4 * SID_MAX_SUB_AUTHORITIES];
    PISID LocalSid = (PISID) LocalBuffer;
    PULONG      attributes = NULL;
    PULONG      Members = NULL;
    ULONG       cMembers;
    DWORD       dwErr;
    BOOL bQuitEarly = FALSE;

    *pfIsMemberOf = FALSE;

    if (RecursionCount > MARTA_MAX_RECURSION_COUNT)
    {
        return ERROR_CIRCULAR_DEPENDENCY;
    }

    dwErr = LoadDLLFuncTable();
    if (dwErr != ERROR_SUCCESS)
    {
        acDebugOut((DEB_TRACE, "Out CMemberCheck::CheckGroup: %lu\n", dwErr));
        return(dwErr);
    }

    dwErr = GetDomainInfo(pSid);
    if(dwErr != ERROR_SUCCESS)
    {
        acDebugOut((DEB_TRACE, "Out CMemberCheck::CheckGroup: %lu\n", dwErr));
        return(dwErr);
    }

    Status = RtlCopySid(RtlLengthSid(_pDomainSid), LocalSid, _pDomainSid);

    if(!NT_SUCCESS(Status))
    {
        return RtlNtStatusToDosError(Status);
    }

    //
    // Special case the Domain Users sid.
    //

    dwErr = CheckDomainUsers(pSid, pfIsMemberOf, &bQuitEarly);
  
    if (dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }
 
    if (bQuitEarly)
    {
        //
        // We are looking at Domain Users group. No need to enumerate this one.
        //

        return ERROR_SUCCESS;
    }             

    //
    // open the group
    //
    Status = (*DLLFuncs.PSamOpenGroup)(_hDomain,
                                       GENERIC_READ,
                                       rid,
                                       &hSam);
    if(NT_SUCCESS(Status))
    {
        //
        // Get the members
        //
        Status = (*DLLFuncs.PSamGetMembersInGroup)(hSam,
                                                   &Members,
                                                   &attributes,
                                                   &cMembers);
        if(NT_SUCCESS(Status) && cMembers )
        {
            //
            // ugly sid rid twiddling
            //
            ++(LocalSid->SubAuthorityCount);

            //
            // loop thru the members and check if the user sid is an immediate
            // member.
            //
            for (ULONG iIndex = 0; iIndex < cMembers; iIndex++ )
            {
                //
                // Plug the rid into the sid
                //
                LocalSid->SubAuthority[LocalSid->SubAuthorityCount-1] =
                        Members[iIndex];

                //
                // and compare
                //
                if(RtlEqualSid(_pCurrentNode->pSid,LocalSid) == TRUE)
                {
                    *pfIsMemberOf = TRUE;
                    break;
                }
            }

            //
            // If we did not match the sid, enumerate recursively.
            //

            if (*pfIsMemberOf == FALSE)
            {
                ULONG SidLength = RtlLengthSid(LocalSid);
                ULONG TotalSize = cMembers * (sizeof(PSID) + SidLength);
                PUCHAR Buffer = NULL;
                PSID *Sids = NULL;


                //
                // Allocate memory to hold the sid array.
                //

                Buffer = (PUCHAR) AccAlloc(TotalSize);
                Sids = (PSID *) Buffer; 

                if (Sids != NULL)
                {
                    PLSA_TRANSLATED_NAME Names = NULL;
                    Buffer += (sizeof(PSID) * cMembers);

                    //
                    // Copy the sids into the allocated array.
                    //

                    for (ULONG iIndex = 0; iIndex < cMembers; iIndex++ )
                    {
                        Sids[iIndex] = Buffer;
                        Buffer += SidLength;

                        LocalSid->SubAuthority[LocalSid->SubAuthorityCount-1] =
                                Members[iIndex];

                        Status = RtlCopySid(SidLength, Sids[iIndex], LocalSid);

                        if (!NT_SUCCESS( Status ))
                        {
                            break;
                        }

                    }

                    if (NT_SUCCESS( Status ))
                    {

                        //
                        // Do a single lookup and get the types of the sids 
                        // in the group.
                        //

                        dwErr = GetSidTypeMultiple(
                                     cMembers,
                                     Sids,
                                     &Names
                                     );

                        if (dwErr == ERROR_SUCCESS)
                        {
                            //
                            // Loop thru the sids and call the recursive routines
                            // if the sidtype is a group or alias.
                            // 

                            for (ULONG iIndex = 0; iIndex < cMembers; iIndex++ )
                            {
                                if (Names[iIndex].Use == SidTypeGroup)
                                {
                                    dwErr = CheckGroup(Sids[iIndex], pfIsMemberOf, RecursionCount+1);

                                    if (dwErr != ERROR_SUCCESS)
                                    {
                                        break;
                                    }

                                    if (*pfIsMemberOf == TRUE)
                                    {
                                        //
                                        // We have a match. There is no need to
                                        // enumerate any more.
                                        //

                                        break;
                                    }
                                }
                                else if (Names[iIndex].Use == SidTypeAlias)
                                {
                                    dwErr = CheckAlias(Sids[iIndex], pfIsMemberOf, RecursionCount+1);

                                    if (dwErr != ERROR_SUCCESS)
                                    {
                                        break;
                                    }

                                    if (*pfIsMemberOf == TRUE)
                                    {
                                        //
                                        // We have a match. There is no need to
                                        // enumerate any more.
                                        //

                                        break;
                                    }
                                }
                            }

                            (VOID) LsaFreeMemory(Names);
                        }
                    }

                    AccFree(Sids);
                }
                else
                {
                    Status = STATUS_NO_MEMORY;
                }
            }

        }

        if (attributes != NULL)
        {
            LocalFree(attributes);
            attributes = NULL;
        }

        if (Members != NULL)
        {
            LocalFree(Members);
            Members = NULL;
        }

        (*DLLFuncs.PSamCloseHandle)(hSam);
    }

    if(!NT_SUCCESS(Status))
    {
        dwErr = RtlNtStatusToDosError(Status);
    }

    acDebugOut((DEB_TRACE, "Out CMemberCheck::CheckGroup: %lu\n", dwErr));
    return(dwErr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::GetSidType, private
//
//  Synopsis:   Returns the type of the Sid
//
//  Arguments:  [IN  pSid]         --  Input Sid
//              [OUT pSidType]     --  Returns the type of Sid.
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::GetSidType(
    IN PSID Sid,
    OUT SID_NAME_USE *pSidType)
{
    LPWSTR Name = NULL;
    LPWSTR DomainName = NULL;
    DWORD dwErr;

    dwErr = AccLookupAccountName(NULL,
                                 Sid,
                                 &Name,
                                 &DomainName,
                                 pSidType);

    if (dwErr == ERROR_SUCCESS)
    {
        AccFree(Name);
        AccFree(DomainName);
    }

    return dwErr;
    
}

//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::GetSidTypeMultiple, private
//
//  Synopsis:   Returns the tanslated names of the Sids
//
//  Arguments:  [IN  Count]        --  Number of sids
//              [IN  pSid]         --  Input Sid
//              [OUT pNames]       --  Returns lsa names structure
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::GetSidTypeMultiple(
    IN LONG Count,
    IN PSID *Sids,
    OUT PLSA_TRANSLATED_NAME *pNames
    )
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE PolicyHandle;
    PLSA_REFERENCED_DOMAIN_LIST ReferencedDomains;
    PLSA_TRANSLATED_NAME Names = NULL;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    NTSTATUS Status;
    NTSTATUS TmpStatus;

    *pNames = NULL;

    SecurityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    SecurityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    SecurityQualityOfService.EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the SecurityQualityOfService field, so we must manually copy that
    // structure for now.
    //

    ObjectAttributes.SecurityQualityOfService = &SecurityQualityOfService;

    Status = LsaOpenPolicy(
                 NULL,
                 &ObjectAttributes,
                 POLICY_LOOKUP_NAMES,
                 &PolicyHandle
                 );

    if ( !NT_SUCCESS( Status )) {
        return RtlNtStatusToDosError(Status);
    }

    Status = LsaLookupSids(
                 PolicyHandle,
                 Count,
                 Sids,
                 &ReferencedDomains,
                 &Names
                 );

    TmpStatus = LsaClose( PolicyHandle );

    //
    // If an error was returned, check specifically for STATUS_NONE_MAPPED.
    // In this case, we may need to dispose of the returned Referenced Domain
    // List and Names structures.  For all other errors, LsaLookupSids()
    // frees these structures prior to exit.
    //

    if ( !NT_SUCCESS( Status )) {

        if (Status == STATUS_NONE_MAPPED) {

            if (ReferencedDomains != NULL) {

                TmpStatus = LsaFreeMemory( ReferencedDomains );
                ASSERT( NT_SUCCESS( TmpStatus ));
            }

            if (Names != NULL) {

                TmpStatus = LsaFreeMemory( Names );
                ASSERT( NT_SUCCESS( TmpStatus ));
            }
        }


        return RtlNtStatusToDosError(Status);
    }

    if (ReferencedDomains != NULL) {

        Status = LsaFreeMemory( ReferencedDomains );
        ASSERT( NT_SUCCESS( Status ));
    }

    *pNames = Names;

    return ERROR_SUCCESS;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMemberCheck::CheckAlias, private
//
//  Synopsis:   checks if the objects account is in the specifed alias account
//
//  Arguments:  [IN  pSid]                  --  Input Sid
//              [OUT pfIsMemberOf]          --  Where the results are returned.
//                                              Is TRUE if the current SID
//                                              is a member of the input SID
//                                              group.
//              [IN RecursionCount]         -- Recursion level 
//
//  Returns:    ERROR_SUCCESS               --  Success
//
//----------------------------------------------------------------------------
DWORD CMemberCheck::CheckAlias(IN  PSID  pSid,
                               OUT PBOOL          pfIsMemberOf,
                               IN DWORD RecursionCount)
{
    acDebugOut((DEB_TRACE, "In CMemberCheck::CheckAlias\n"));
    NTSTATUS    Status;
    SAM_HANDLE  hSam = NULL;
    ULONG       rid = ((PISID)(pSid))->SubAuthority[
                         ((PISID)(pSid))->SubAuthorityCount-1];
    ULONG_PTR * Members;
    ULONG       cMembers;
    DWORD       dwErr;

    *pfIsMemberOf = FALSE;

    if (RecursionCount > MARTA_MAX_RECURSION_COUNT)
    {
        return ERROR_CIRCULAR_DEPENDENCY;
    }

    dwErr = LoadDLLFuncTable();
    if (dwErr != ERROR_SUCCESS)
    {
        acDebugOut((DEB_TRACE, "Out CMemberCheck::CheckGroup: %lu\n", dwErr));
        return(dwErr);
    }

    dwErr = GetDomainInfo(pSid);
    if(dwErr != ERROR_SUCCESS)
    {
        acDebugOut((DEB_TRACE, "Out CMemberCheck::CheckGroup: %lu\n", dwErr));
        return(dwErr);
    }


    //
    // open the alias
    //
    Status = (*DLLFuncs.PSamOpenAlias)(_hDomain,
                                       GENERIC_READ,
                                       rid,
                                       &hSam);
    if(NT_SUCCESS(Status))
    {
        //
        // get the members
        //
        Status = (*DLLFuncs.PSamGetMembersInAlias)(hSam,
                                                  (void ***)&Members,
                                                  &cMembers);
        if(NT_SUCCESS(Status) && cMembers)
        {
            //
            // loop thru the members
            //
            for (ULONG iIndex = 0; iIndex < cMembers; iIndex++)
            {
                if(RtlEqualSid(_pCurrentNode->pSid,
                              ((SID **)(Members))[iIndex]) == TRUE)
                {
                    *pfIsMemberOf = TRUE;
                    break;
                }

            }

            //
            // If we did not match the sid, enumerate recursively.
            //

            if (*pfIsMemberOf == FALSE)
            {
                PLSA_TRANSLATED_NAME Names = NULL;

                //
                // Do a single lookup and get the types of the sids 
                // in the group.
                //

                dwErr = GetSidTypeMultiple(
                             cMembers,
                             (PSID *) Members,
                             &Names
                             );

                if (dwErr == ERROR_SUCCESS)
                {
                    //
                    // Loop thru the sids and call the recursive routines
                    // if the sidtype is a group or an alias.
                    // 

                    for (ULONG iIndex = 0; iIndex < cMembers; iIndex++ )
                    {
                        if (Names[iIndex].Use == SidTypeGroup)
                        {
                            dwErr = CheckGroup(((SID **) (Members))[iIndex], pfIsMemberOf, RecursionCount+1);

                            if (dwErr != ERROR_SUCCESS)
                            {
                                break;
                            }

                            if (*pfIsMemberOf == TRUE)
                            {
                                //
                                // We have a match. There is no need to
                                // enumerate any more.
                                //

                                break;
                            }
                        }
                        else if (Names[iIndex].Use == SidTypeAlias)
                        {
                            dwErr = CheckAlias(((SID **) (Members))[iIndex], pfIsMemberOf, RecursionCount+1);

                            if (dwErr != ERROR_SUCCESS)
                            {
                                break;
                            }

                            if (*pfIsMemberOf == TRUE)
                            {
                                //
                                // We have a match. There is no need to
                                // enumerate any more.
                                //

                                break;
                            }
                        }
                    }

                    (VOID) LsaFreeMemory(Names);
                }
            }

            if(cMembers > 0)
            {
                LocalFree(Members);
            }
        }

        (*DLLFuncs.PSamCloseHandle)(hSam);
    }

    if(!NT_SUCCESS(Status))
    {
        dwErr = RtlNtStatusToDosError(Status);
    }

    acDebugOut((DEB_TRACE, "Out CMemberCheck::CheckGroup: %lu\n", dwErr));
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\prtctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       prtctx.cpp
//
//  Contents:   Implementation of CPrinterContext and NT Marta Printer Functions
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <prtctx.h>
//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::CPrinterContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CPrinterContext::CPrinterContext ()
{
    m_cRefs = 1;
    m_hPrinter = NULL;
    m_fNameInitialized = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::~CPrinterContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CPrinterContext::~CPrinterContext ()
{
    if ( ( m_hPrinter != NULL ) && ( m_fNameInitialized == TRUE ) )
    {
        ClosePrinter( m_hPrinter );
    }

    assert( m_cRefs == 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::InitializeByName, public
//
//  Synopsis:   initialize the context given the name of the printer
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask)
{
    PRINTER_DEFAULTSW PrinterDefaults;

    PrinterDefaults.pDatatype = NULL;
    PrinterDefaults.pDevMode = NULL;
    PrinterDefaults.DesiredAccess = AccessMask;

    if ( OpenPrinterW(
             (LPWSTR)pObjectName,
             &m_hPrinter,
             &PrinterDefaults
             ) == FALSE )
    {
        return( GetLastError() );
    }

    m_fNameInitialized = TRUE;

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::InitializeByHandle, public
//
//  Synopsis:   initialize the context given a printer handle
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::InitializeByHandle (HANDLE Handle)
{
    m_hPrinter = Handle;
    assert( m_fNameInitialized == FALSE );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::AddRef, public
//
//  Synopsis:   add a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::AddRef ()
{
    m_cRefs += 1;
    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::Release, public
//
//  Synopsis:   release a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::Release ()
{
    m_cRefs -= 1;

    if ( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::GetPrinterProperties, public
//
//  Synopsis:   get properties about the context
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::GetPrinterProperties (
                    PMARTA_OBJECT_PROPERTIES pObjectProperties
                    )
{
    if ( pObjectProperties->cbSize < sizeof( MARTA_OBJECT_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pObjectProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::GetPrinterRights, public
//
//  Synopsis:   get the Printer security descriptor
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::GetPrinterRights (
                    SECURITY_INFORMATION SecurityInfo,
                    PSECURITY_DESCRIPTOR* ppSecurityDescriptor
                    )
{
    PISECURITY_DESCRIPTOR pisd = NULL;
    PSECURITY_DESCRIPTOR  psd = NULL;
    DWORD                 cb = 0;
    PPRINTER_INFO_3       pPrinterInfo = NULL;

    assert( m_hPrinter != NULL );

    if ( ( GetPrinterW(
              m_hPrinter,
              3,
              (LPBYTE)pPrinterInfo,
              cb,
              &cb
              ) == FALSE ) &&
         ( cb > 0 ) )
    {
        pPrinterInfo = (PPRINTER_INFO_3)new BYTE [ cb ];
        if ( pPrinterInfo != NULL )
        {
            if ( GetPrinterW(
                    m_hPrinter,
                    3,
                    (LPBYTE)pPrinterInfo,
                    cb,
                    &cb
                    ) == FALSE )
            {
                delete pPrinterInfo;
                return( GetLastError() );
            }
        }
        else
        {
            return( E_OUTOFMEMORY );
        }
    }
    else
    {
        return( GetLastError() );
    }

    pisd = (PISECURITY_DESCRIPTOR)pPrinterInfo->pSecurityDescriptor;
    if ( pisd->Control & SE_SELF_RELATIVE )
    {
        cb = GetSecurityDescriptorLength( pPrinterInfo->pSecurityDescriptor );
        psd = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
        if ( psd == NULL )
        {
            delete pPrinterInfo;
            return( ERROR_OUTOFMEMORY );
        }

        memcpy( psd, pPrinterInfo->pSecurityDescriptor, cb );
    }
    else
    {
        if ( MakeSelfRelativeSD(
                 pPrinterInfo->pSecurityDescriptor,
                 NULL,
                 &cb
                 ) == FALSE )
        {
            if ( cb > 0 )
            {
                psd = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
                if ( psd != NULL )
                {
                    if ( MakeSelfRelativeSD(
                             pPrinterInfo->pSecurityDescriptor,
                             psd,
                             &cb
                             ) == FALSE )
                    {
                        LocalFree( psd );
                        delete pPrinterInfo;
                        return( GetLastError() );
                    }
                }
            }
            else
            {
                delete pPrinterInfo;
                return( GetLastError() );
            }
        }
    }

    delete pPrinterInfo;
    *ppSecurityDescriptor = psd;

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceContext::SetPrinterRights, public
//
//  Synopsis:   set the window security descriptor
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::SetPrinterRights (
                   SECURITY_INFORMATION SecurityInfo,
                   PSECURITY_DESCRIPTOR pSecurityDescriptor
                   )
{
    PRINTER_INFO_3 PrinterInfo;

    assert( m_hPrinter != NULL );

    PrinterInfo.pSecurityDescriptor = pSecurityDescriptor;

    if ( SetPrinterW( m_hPrinter, 3, (LPBYTE)&PrinterInfo, 0 ) == FALSE )
    {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

//
// Functions from printer.h which dispatch unto the CPrinterContext class
//

DWORD
MartaAddRefPrinterContext(
   IN MARTA_CONTEXT Context
   )
{
    return( ( (CPrinterContext *)Context )->AddRef() );
}

DWORD
MartaClosePrinterContext(
     IN MARTA_CONTEXT Context
     )
{
    return( ( (CPrinterContext *)Context )->Release() );
}

DWORD
MartaGetPrinterProperties(
   IN MARTA_CONTEXT Context,
   IN OUT PMARTA_OBJECT_PROPERTIES pProperties
   )
{
    return( ( (CPrinterContext *)Context )->GetPrinterProperties( pProperties ) );
}

DWORD
MartaGetPrinterTypeProperties(
   IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
   )
{
    if ( pProperties->cbSize < sizeof( MARTA_OBJECT_TYPE_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

DWORD
MartaGetPrinterRights(
   IN  MARTA_CONTEXT Context,
   IN  SECURITY_INFORMATION   SecurityInfo,
   OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
   )
{
    return( ( (CPrinterContext *)Context )->GetPrinterRights(
                                               SecurityInfo,
                                               ppSecurityDescriptor
                                               ) );
}

DWORD
MartaOpenPrinterNamedObject(
    IN  LPCWSTR pObjectName,
    IN  ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CPrinterContext* pPrinterContext;

    pPrinterContext = new CPrinterContext;
    if ( pPrinterContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pPrinterContext->InitializeByName( pObjectName, AccessMask );
    if ( Result != ERROR_SUCCESS )
    {
        pPrinterContext->Release();
        return( Result );
    }

    *pContext = pPrinterContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaOpenPrinterHandleObject(
    IN  HANDLE   Handle,
    IN ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CPrinterContext* pPrinterContext;

    pPrinterContext = new CPrinterContext;
    if ( pPrinterContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pPrinterContext->InitializeByHandle( Handle );
    if ( Result != ERROR_SUCCESS )
    {
        pPrinterContext->Release();
        return( Result );
    }

    *pContext = pPrinterContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaSetPrinterRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return( ( (CPrinterContext *)Context )->SetPrinterRights(
                                               SecurityInfo,
                                               pSecurityDescriptor
                                               ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\prtctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       prtctx.h
//
//  Contents:   NT Marta printer context class
//
//  History:    4-1-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__PRTCTX_H__)
#define __PRTCTX_H__

#include <windows.h>
#include <printer.h>
#include <assert.h>
#include <winspool.h>

//
// CPrinterContext.  This represents a printer object to the NT Marta
// infrastructure
//

class CPrinterContext
{
public:

    //
    // Construction
    //

    CPrinterContext ();

    ~CPrinterContext ();

    DWORD InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask);

    DWORD InitializeByHandle (HANDLE Handle);

    //
    // Dispatch methods
    //

    DWORD AddRef ();

    DWORD Release ();

    DWORD GetPrinterProperties (
             PMARTA_OBJECT_PROPERTIES pProperties
             );

    DWORD GetPrinterRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR* ppSecurityDescriptor
             );

    DWORD SetPrinterRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR pSecurityDescriptor
             );

private:

    //
    // Reference count
    //

    DWORD     m_cRefs;

    //
    // Printer handles
    //

    HANDLE    m_hPrinter;

    //
    // Were we initialized by name or handle?
    //

    BOOL      m_fNameInitialized;
};

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\printer.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:    printer.cxx
//
//  Contents:    local functions
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   OpenPrinterObject
//
//  Synopsis:   Opens the specified printer object
//
//  Arguments:  [IN pwszPrinter]        --      The name of the printer to
//                                              open
//              [IN AccessMask]         --      Flags indicating if the object
//                                              is to be opened to read or write
//                                              the DACL
//              [OUT pHandle]           --      Where the open handle is
//                                              returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad name was given
//
//----------------------------------------------------------------------------
DWORD
OpenPrinterObject( IN  LPWSTR       pwszPrinter,
                   IN  ACCESS_MASK  AccessMask,
                   OUT PHANDLE      pHandle)
{
    acDebugOut((DEB_TRACE, "in OpenPrinterObject\n"));

    DWORD dwErr;

    //
    // Make sure the printer functions are loaded
    //
    dwErr = LoadDLLFuncTable();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    if(pwszPrinter != NULL)
    {
        PRINTER_DEFAULTS pd;
        pd.pDatatype     = NULL;
        pd.pDevMode      = NULL;
        pd.DesiredAccess = AccessMask;

        //
        // open the printer
        //
        if(DLLFuncs.POpenPrinter(pwszPrinter, pHandle, &pd) == FALSE)
        {
            dwErr = GetLastError();
        }
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    acDebugOut((DEB_TRACE, "Out OpenPrinterObject: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadPrinterPropertyRights
//
//  Synopsis:   Gets the specified security info for the specified printer
//              object
//
//  Arguments:  [IN  pwszPrinter]       --      The printer to get the rights
//                                              for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadPrinterPropertyRights(IN  LPWSTR                pwszPrinter,
                          IN  PACTRL_RIGHTS_INFO    pRightsList,
                          IN  ULONG                 cRights,
                          IN  CAccessList&          AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadPrinterPropertyRights \n"));

    HANDLE  hPrinter;
    DWORD   dwErr;

    //
    // For the moment, there is only the printer property itself...
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    dwErr = OpenPrinterObject(pwszPrinter,
                              GetDesiredAccess(READ_ACCESS_RIGHTS,
                                               pRightsList[0].SeInfo),
                              &hPrinter);

    if(dwErr == ERROR_SUCCESS)
    {

        dwErr = ReadPrinterRights(hPrinter,
                                  pRightsList,
                                  cRights,
                                  AccessList);


        //
        // Close the printer handle
        //
        DLLFuncs.PClosePrinter(hPrinter);
    }

    acDebugOut((DEB_TRACE, "Out ReadPrinterPropertyRights: %lu\n", dwErr));
    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   ReadPrinterRights
//
//  Synopsis:   Gets the specified security info for the specified printer
//              object
//
//  Arguments:  [IN  hPrinter]          --      Open printer handle
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadPrinterRights(IN  HANDLE                hPrinter,
                  IN  PACTRL_RIGHTS_INFO    pRightsList,
                  IN  ULONG                 cRights,
                  IN  CAccessList&          AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadPrinterRights \n"));

    DWORD   dwErr = ERROR_SUCCESS;

    //
    // For the moment, there is only the printer property itself...
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    UCHAR           PI3Buff[PSD_BASE_LENGTH];
    PPRINTER_INFO_3 pPI3 = (PPRINTER_INFO_3)PI3Buff;
    ULONG           cSize = 0;
    BOOLEAN         fDummy, fParmPresent;
    NTSTATUS        Status;
    PACL            pAcl = NULL;

    //
    // Get printer info 3 (a security descriptor)
    //
    if(DLLFuncs.PGetPrinter(hPrinter,
                            3,
                            (LPBYTE)pPI3,
                            PSD_BASE_LENGTH,
                            &cSize) == FALSE )
    {
        dwErr = GetLastError();
        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            //
            // Allocate one big enough
            //
            pPI3 = (PPRINTER_INFO_3)AccAlloc(cSize);
            if(pPI3 == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                dwErr = ERROR_SUCCESS;
                if(DLLFuncs.PGetPrinter(hPrinter,
                                        3,
                                        (LPBYTE)pPI3,
                                        cSize,
                                        &cSize) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }

        }
    }

    //
    // Because the printer APIs are not very smart, we need to make
    // an explicit check to see if the handle was opened with the correct
    // access to return what the caller wants.
    //
    // eg. if caller wants a DACL but got the handle with only
    // ACCESS_SYSTEM_INFO, then we need to return ACCESS_DENIED.
    //

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // If caller wants DACL, group, or owner, then they must open
        // the handle with READ_CONTROL. The only way we can check this
        // is to see if there is a DACL present.
        //
        fParmPresent = FALSE;
        Status = RtlGetDaclSecurityDescriptor(pPI3->pSecurityDescriptor,
                                              &fParmPresent,
                                              &pAcl,
                                              &fDummy);
        if(NT_SUCCESS(Status))
        {
            if (fParmPresent == FALSE &&
               (FLAG_ON(pRightsList[0].SeInfo,DACL_SECURITY_INFORMATION) ||
                FLAG_ON(pRightsList[0].SeInfo,OWNER_SECURITY_INFORMATION)||
                FLAG_ON(pRightsList[0].SeInfo,GROUP_SECURITY_INFORMATION)))

            {
                //
                // this means that the handle was not open with correct access.
                //
                dwErr = ERROR_ACCESS_DENIED;
            }
        }
        else
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Do same hack with SACL
        //
        fParmPresent = FALSE;
        Status = RtlGetSaclSecurityDescriptor(pPI3->pSecurityDescriptor,
                                              &fParmPresent,
                                              &pAcl,
                                              &fDummy);
        if(NT_SUCCESS(Status))
        {
            if(fParmPresent == FALSE &&
               FLAG_ON(pRightsList[0].SeInfo,SACL_SECURITY_INFORMATION))
            {
                dwErr = ERROR_ACCESS_DENIED;
            }
        }
        else
        {
            dwErr = RtlNtStatusToDosError(Status);
        }
    }

    //
    // Finally, add the security descriptor
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccessList.AddSD(pPI3->pSecurityDescriptor,
                                 pRightsList->SeInfo,
                                 pRightsList->pwszProperty);
    }

    if(cSize > PSD_BASE_LENGTH)
    {
        AccFree(pPI3);
    }


    acDebugOut((DEB_TRACE, "Out ReadPrinterRights: %lu\n", dwErr));
    return(dwErr);
}





//+---------------------------------------------------------------------------
//
//  Function:   GetPrinterParentRights
//
//  Synopsis:   Determines who the parent is, and gets the access rights
//              for it.  It is used to aid in determining what the approriate
//              inheritance bits are.
//
//              This operation does not make sense for kernel objects
//
//  Arguments:  [IN  pwszPrinter]       --      The printer to get the parent
//                                              for
//              [IN  pRightsList]       --      The properties to get the
//                                              rights for
//              [IN  cRights]           --      Number of items in rights list
//              [OUT ppDAcl]            --      Where the DACL is returned
//              [OUT ppSAcl]            --      Where the SACL is returned
//              [OUT ppSD]              --      Where the Security Descriptor
//                                              is returned
//
//  Returns:    ERROR_INVALID_FUNCTION  --      Call doesn't make sense here
//
//----------------------------------------------------------------------------
DWORD
GetPrinterParentRights(IN  LPWSTR                    pwszPrinter,
                       IN  PACTRL_RIGHTS_INFO        pRightsList,
                       IN  ULONG                     cRights,
                       OUT PACL                     *ppDAcl,
                       OUT PACL                     *ppSAcl,
                       OUT PSECURITY_DESCRIPTOR     *ppSD)
{
    //
    // This doesn't currently make sense for kernel objects, so simply
    // return an error
    //
    return(ERROR_INVALID_FUNCTION);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetPrinterSecurityInfo
//
//  Synopsis:   Sets the specified security info on the specified printer
//              object
//
//  Arguments:  [IN  hPrinter]          --      The handle of the object
//              [IN  SeInfo]            --      Flag indicating what security
//                                              info to set
//              [IN  pwszProperty]      --      The property on the object to
//                                              set
//                                              For kernel objects, this MBZ
//              [IN  pSD]               --      The security descriptor to set
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was given
//
//----------------------------------------------------------------------------
DWORD
SetPrinterSecurityInfo(IN  HANDLE                    hPrinter,
                       IN  SECURITY_INFORMATION      SeInfo,
                       IN  PWSTR                     pwszProperty,
                       IN  PSECURITY_DESCRIPTOR      pSD)
{
    acDebugOut((DEB_TRACE, "in SetPrinterSecurityInfo\n"));
    DWORD dwErr = ERROR_SUCCESS;

    //
    // Make sure the printer functions are loaded
    //

    dwErr = LoadDLLFuncTable();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //
    // Service don't have properties
    //
    if(pwszProperty != NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        PRINTER_INFO_3 PI3;

        PI3.pSecurityDescriptor = pSD;

        if (DLLFuncs.PSetPrinter(hPrinter,
                                 3,
                                 (LPBYTE)&PI3,
                                 0) == FALSE)
        {
            dwErr = GetLastError();
        }
    }

    acDebugOut((DEB_TRACE, "Out SetPrinterSecurityInfo: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ClosePrinterObject
//
//  Synopsis:   Closes the opened printer handle
//
//  Arguments:  [IN  hPrinter]          --      The handle of the printer
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
ClosePrinterObject(IN  HANDLE   hPrinter)
{
    acDebugOut((DEB_TRACE, "in ClosePrinterObject\n"));
    DWORD dwErr = ERROR_SUCCESS;

    //
    // Make sure the printer functions are loaded
    //

    dwErr = LoadDLLFuncTable();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    //
    // Close the printer handle
    //
    DLLFuncs.PClosePrinter(hPrinter);

    acDebugOut((DEB_TRACE, "Out ClosePrinterObject: %lu\n", dwErr));
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\ntmarta.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       NTMARTA.CXX
//
//  Contents:   Implementation of the private provider functions and
//              worker threads
//
//  History:    22-Jul-96       MacM        Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <ntprov.hxx>


//
// This macro montiors the worker thread interrupt flag, and goes to to the
// CleanUp label when it discovers it has been set.
//
#define CLEANUP_ON_INTERRUPT(info)                                          \
if(info->pWrkrInfo->fState != 0)                                            \
{                                                                           \
    goto CleanUp;                                                           \
}

DWORD
InsertAndContinueWorkerThread(IN  PNTMARTA_WRKR_INFO      pWrkrInfo);



//+---------------------------------------------------------------------------
//
//  Function:   NtProvFreeWorkerItem
//
//  Synopsis:   Used by the linked list class that maintains the list of
//              active worker threads.  This is used to delete an item
//              in the worker list.  If the thread is still active, it
//              will be given some amount of time to finish.  If it hasn't
//              finished in that amount of time, it will be killed.  Note
//              that this means that a memory leak could occur.
//
//  Arguments:  [IN  pv]                --  Item to be freed
//
//  Returns:    void
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
NtProvFreeWorkerItem(PVOID    pv)
{
    PNTMARTA_WRKR_INFO pWI = (PNTMARTA_WRKR_INFO)pv;

    if(pWI != NULL && pWI->hWorker != NULL)
    {
        pWI->fState++;

        DWORD   dwPop = WaitForSingleObject(pWI->hWorker,
                                            THREAD_KILL_WAIT);
        if(dwPop == WAIT_ABANDONED)
        {
            //
            // The wait timed out, so kill it.  Note also that the rules
            // state that anytime the thread stops, we need to set the
            // event as well.
            //
            TerminateThread(pWI->hWorker,
                            ERROR_OPERATION_ABORTED);
            SetEvent(pWI->pOverlapped->hEvent);

            //
            // The memory passed in to the thread as an argument was just
            // leaked.  this is fixable.
            //
        }
    }

    //
    // Deallocate our memory
    //
    AccFree(pv);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProvFindWorkerItem
//
//  Synopsis:   Used by the linked list class that maintains the list of
//              active worker threads.  This is used locate a particular
//              worker item in the list
//
//  Arguments:  [IN  pv1]               --  Item to be found.  In this
//                                          case, a pOverlapped struct
//              [IN  pv2]               --  Item in the list.  In this case,
//                                          a PNTMARTA_WRKR_INFO struct.
//
//  Returns:    TRUE                    --  They match
//              FALSE                   --  They don't match
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
NtProvFindWorkerItem(PVOID    pv1,
                     PVOID    pv2)
{
    PNTMARTA_WRKR_INFO  pWI = (PNTMARTA_WRKR_INFO)pv2;
    PACTRL_OVERLAPPED   pOL = (PACTRL_OVERLAPPED)pv1;
    if(pWI->pOverlapped->hEvent == pOL->hEvent)
    {
        return(TRUE);
    }

    return(FALSE);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProvGetBasePathForFilePath
//
//  Synopsis:   Gets the base path for this item as necessary.  For
//              a FILE type object, it will check to see if it is a DFS path,
//              and if so, will retrieve the list of machine paths that
//              support this DFS path.  For a non-File object, the path is
//              simply copied.
//
//  Arguments:  [IN  pwszObject]            --      Object path
//              [IN  ObjectType]            --      The type of the object
//              [OUT pcPaths]               --      Where the count of paths
//                                                  is to be returned
//              [OUT pppwszBasePaths]       --      The list of paths.
//
//  Returns:    VOID
//
//  Notes:      The returned list must be free via a call to AccFree
//
//----------------------------------------------------------------------------
DWORD
NtProvGetBasePathsForFilePath(PWSTR             pwszObject,
                              SE_OBJECT_TYPE    ObjectType,
                              PULONG            pcPaths,
                              PWSTR           **pppwszBasePaths)
{
    DWORD   dwErr = ERROR_SUCCESS;

    *pcPaths = 0;
    //
    // First, we'll see if it's a relative path.  If so, we'll have to
    // build a full path...
    //
    PWSTR   pwszFullPath = pwszObject;
    DWORD   dwSize;
    if(ObjectType == SE_FILE_OBJECT)
    {
        if(wcslen(pwszObject) < 2 ||
                            (pwszObject[1] != L':' && pwszObject[1] != L'\\'))
        {
            //
            // It's a relative path...
            //
            dwSize = GetFullPathName(pwszObject,
                                     0,
                                     NULL,
                                     NULL);
            if(dwSize == 0)
            {
                dwErr = GetLastError();
            }
            else
            {
                pwszFullPath = (PWSTR)AccAlloc((dwSize + 1) * sizeof(WCHAR));
                if(pwszFullPath == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    PWSTR   pwszFilePart;
                    if(GetFullPathName(pwszObject,
                                       dwSize,
                                       pwszFullPath,
                                       &pwszFilePart) == 0)
                    {
                        dwErr = GetLastError();
                    }
                }
            }
        }

        //
        // Ok, now see if it's a DFS path
        //
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = LoadDLLFuncTable();

            if(dwErr == ERROR_SUCCESS)
            {
/*
                if(IsThisADfsPath(pwszFullPath,0) == TRUE)
                {
                    dwErr = GetLMDfsPaths(pwszFullPath,
                                          pcPaths,
                                          pppwszBasePaths);
                }
                else
                {
*/
                    *pppwszBasePaths = (PWSTR *)AccAlloc(sizeof(PWSTR) +
                                                     SIZE_PWSTR(pwszObject));
                    if(*pppwszBasePaths == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        (*pppwszBasePaths)[0] =
                             (PWSTR)((PBYTE)*pppwszBasePaths + sizeof(PWSTR));
                        wcscpy((PWSTR)((PBYTE)*pppwszBasePaths + sizeof(PWSTR)),
                               pwszObject);
                        *pcPaths = 1;
                    }
//                }
            }
        }
    }
    else
    {
        *pppwszBasePaths = (PWSTR *)AccAlloc(sizeof(PWSTR) +
                                             SIZE_PWSTR(pwszObject));
        if(*pppwszBasePaths == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            (*pppwszBasePaths)[0] =
                                (PWSTR)((PBYTE)*pppwszBasePaths + sizeof(PWSTR));
            wcscpy((PWSTR)((PBYTE)*pppwszBasePaths + sizeof(PWSTR)),
                   pwszObject);
            *pcPaths = 1;
        }
    }

    //
    // Make sure to deallocate any memory
    //
    if(pwszFullPath != pwszObject)
    {
        AccFree(pwszFullPath);
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProvSetAccessRightsWorkerThread
//
//  Synopsis:   Sets the access rights on the given object.  It replaces any
//              existing rights.
//
//  Arguments:  [IN  pWorkerArgs]       --  Pointer to the structure that
//                                          contains all of the thread
//                                          arguments.
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_OPERATION_ABORTED --  The operation was aborted
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
NtProvSetAccessRightsWorkerThread(IN PVOID pWorkerArgs)
{
    PNTMARTA_SET_WRKR_INFO  pSetInfo = (PNTMARTA_SET_WRKR_INFO)pWorkerArgs;
    DWORD                   dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    MARTA_KERNEL_TYPE       KernelType;
    {
        //
        // Now, we'll do this in a loop, so we can handle the DFS case where
        // we get a failure on one path, but another path may work
        //
        pSetInfo->pWrkrInfo->cProcessed = 0;
        ULONG iIndex = 0;
        do
        {
            CLEANUP_ON_INTERRUPT(pSetInfo)

            //
            // If it worked, write them all out...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                CLEANUP_ON_INTERRUPT(pSetInfo)

                //
                // First, get the Security Descriptor
                //
                SECURITY_INFORMATION    SeInfo;
                ULONG                   fSDFlags = ACCLIST_SD_ABSOK;

                if(pSetInfo->ObjectType == SE_DS_OBJECT ||
                                    pSetInfo->ObjectType == SE_DS_OBJECT_ALL)
                {
                    pSetInfo->pAccessList->SetDsPathInfo(NULL,
                                  (PWSTR)pSetInfo->ppwszObjectList[iIndex]);
                    fSDFlags = 0;

                }

                dwErr = pSetInfo->pAccessList->BuildSDForAccessList(&pSD,
                                                                    &SeInfo,
                                                                    fSDFlags);
                CLEANUP_ON_INTERRUPT(pSetInfo)
                if(dwErr == ERROR_SUCCESS)
                {
                    HANDLE  hObject = NULL;
                    BOOL    fHandleLocal = TRUE;

                    if(FLAG_ON(pSetInfo->fFlags, NTMARTA_HANDLE_VALID))
                    {
                        hObject = pSetInfo->hObject;
                        fHandleLocal = FALSE;

                    }
                    switch (pSetInfo->ObjectType)
                    {
                    case SE_SERVICE:
                        if(fHandleLocal == TRUE)
                        {
                            dwErr = OpenServiceObject(
                                    (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                    GetDesiredAccess(WRITE_ACCESS_RIGHTS,
                                                     SeInfo),
                                    (SC_HANDLE *)&hObject);
                        }

                        if(dwErr == ERROR_SUCCESS)
                        {
                            if(pSetInfo->pWrkrInfo->fState != 0)
                            {
                                CloseServiceObject((SC_HANDLE)hObject);
                                goto CleanUp;
                            }

                            dwErr = SetServiceSecurityInfo((SC_HANDLE)hObject,
                                                           SeInfo,
                                                           NULL,
                                                           pSD);

                            if(fHandleLocal == TRUE)
                            {
                                CloseServiceObject((SC_HANDLE)hObject);
                            }
                        }
                        break;

                    case SE_PRINTER:
                        if(fHandleLocal == TRUE)
                        {
                            dwErr = OpenPrinterObject(
                                    (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                    GetDesiredAccess(WRITE_ACCESS_RIGHTS,
                                                     SeInfo),
                                    &hObject);
                        }

                        if(dwErr == ERROR_SUCCESS)
                        {
                            if(pSetInfo->pWrkrInfo->fState != 0)
                            {
                                ClosePrinterObject(hObject);
                                goto CleanUp;
                            }

                            dwErr = SetPrinterSecurityInfo(hObject,
                                                           SeInfo,
                                                           NULL,
                                                           pSD);

                            if(fHandleLocal == TRUE)
                            {
                                ClosePrinterObject(hObject);
                            }

                        }
                        break;

                    case SE_LMSHARE:
                        dwErr = SetShareSecurityInfo(
                                    (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                    SeInfo,
                                    NULL,
                                    pSD);
                        break;

                    case SE_KERNEL_OBJECT:
                        if(fHandleLocal == TRUE)
                        {
                            dwErr = OpenKernelObject(
                                    (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                    GetDesiredAccess(WRITE_ACCESS_RIGHTS,
                                                     SeInfo),
                                    &hObject,
                                    &KernelType);

                            if(dwErr == ERROR_SUCCESS)
                            {
                                pSetInfo->pAccessList->SetKernelObjectType( KernelType );
                            }
                        }

                        if(dwErr == ERROR_SUCCESS)
                        {
                            if(pSetInfo->pWrkrInfo->fState != 0)
                            {
                                CloseKernelObject(hObject);
                                goto CleanUp;
                            }

                            dwErr = SetKernelSecurityInfo(hObject,
                                                          SeInfo,
                                                          NULL,
                                                          pSD);

                            if(fHandleLocal == TRUE)
                            {
                                CloseKernelObject(hObject);
                            }

                        }
                        break;


                    case SE_WMIGUID_OBJECT:
                        if(fHandleLocal == TRUE)
                        {
                            dwErr = OpenWmiGuidObject(
                                            (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                            GetDesiredAccess(WRITE_ACCESS_RIGHTS,
                                                             SeInfo),
                                            &hObject,
                                            &KernelType);

                            if(dwErr == ERROR_SUCCESS)
                            {
                                pSetInfo->pAccessList->SetKernelObjectType( KernelType );
                            }
                        }

                        if(dwErr == ERROR_SUCCESS)
                        {
                            if(pSetInfo->pWrkrInfo->fState != 0)
                            {
                                CloseKernelObject(hObject);
                                goto CleanUp;
                            }

                            dwErr = SetWmiGuidSecurityInfo(hObject,
                                                           SeInfo,
                                                           NULL,
                                                           pSD);

                            if(fHandleLocal == TRUE)
                            {
                                CloseWmiGuidObject(hObject);
                            }

                        }
                        break;


                    case SE_FILE_OBJECT:
                        if(fHandleLocal == TRUE)
                        {
                            dwErr = SetAndPropagateFilePropertyRights(
                                     (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                     NULL,
                                     *(pSetInfo->pAccessList),
                                     &(pSetInfo->pWrkrInfo->fState),
                                     &(pSetInfo->pWrkrInfo->cProcessed),
                                     NULL);
                        }
                        else
                        {
                            dwErr = SetAndPropagateFilePropertyRightsByHandle(
                                     hObject,
                                     NULL,
                                     *(pSetInfo->pAccessList),
                                     &(pSetInfo->pWrkrInfo->fState),
                                     &(pSetInfo->pWrkrInfo->cProcessed));

                        }
                        break;

                    case SE_REGISTRY_KEY:

                        if(fHandleLocal == TRUE)
                        {
                            dwErr = SetAndPropagateRegistryPropertyRights(
                                     (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                     NULL,
                                     *(pSetInfo->pAccessList),
                                     &(pSetInfo->pWrkrInfo->fState),
                                     &(pSetInfo->pWrkrInfo->cProcessed));

                        }
                        else
                        {
                            dwErr = SetAndPropagateRegistryPropertyRightsByHandle(
                                     (HKEY)hObject,
                                     *(pSetInfo->pAccessList),
                                     &(pSetInfo->pWrkrInfo->fState),
                                     &(pSetInfo->pWrkrInfo->cProcessed));

                        }
                        break;

                    case SE_DS_OBJECT:
                    case SE_DS_OBJECT_ALL:

                        dwErr = SetDSObjSecurityInfo(
                                     (PWSTR)pSetInfo->ppwszObjectList[iIndex],
                                     SeInfo,
                                     NULL,
                                     pSD,
                                     pSetInfo->pAccessList->QuerySDSize(),
                                     &(pSetInfo->pWrkrInfo->fState),
                                     &(pSetInfo->pWrkrInfo->cProcessed));
                        break;

                    case SE_WINDOW_OBJECT:

                        if(SetUserObjectSecurity(hObject,
                                                 &SeInfo,
                                                 pSD) == FALSE)
                        {
                            dwErr = GetLastError();
                        }
                        break;

                    default:
                        dwErr = ERROR_INVALID_PARAMETER;
                        break;

                    }
                }
            }

            CLEANUP_ON_INTERRUPT(pSetInfo)

            iIndex++;
        } while(dwErr != ERROR_SUCCESS && iIndex < pSetInfo->cObjects);

    }

    //
    // This is the cleanup section
    //
CleanUp:
    AccFree(pSetInfo->ppwszObjectList);


    //
    // See if we need to clean up any allocated memory
    //
    if(pSetInfo->fFlags & NTMARTA_DELETE_ALIST)
    {
        delete pSetInfo->pAccessList;
    }

    if(pSetInfo->pWrkrInfo->fState != 0)
    {
        dwErr = ERROR_OPERATION_ABORTED;
    }

    HANDLE  hEvent = pSetInfo->pWrkrInfo->pOverlapped->hEvent;

    //
    // See if we need to delete the arguments themselves
    //
    if(pSetInfo->fFlags & NTMARTA_DELETE_ARGS)
    {
        AccFree(pSetInfo);
    }

    //
    // Finally, set our event
    //
    SetEvent(hEvent);

    ExitThread(dwErr);
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProvDoSet
//
//  Synopsis:   Sets up the worker thread to do the SetAccessRights
//
//  Arguments:  [IN  pwszObjectPath]    --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  pSetInfo]          --  List of rights infos
//              [IN  cRightsInfos]      --  Number of items in list
//              [IN  pAccessList]       --  Ptr to a CAccessList class
//              [IN  pOwner]            --  Optional.  Owner to set
//              [IN  pGroup]            --  Optional.  Group to set
//              [IN  pOverlapped]       --  Overlapped structure to use for
//                                          asynchronous control
//              [IN  fSetFlags]         --  Flags governing the control of
//                                          the worker thread
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
NtProvDoSet(IN  LPCWSTR                 pwszObjectPath,
            IN  SE_OBJECT_TYPE          ObjectType,
            IN  CAccessList            *pAccessList,
            IN  PACTRL_OVERLAPPED       pOverlapped,
            IN  DWORD                   fSetFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, we'll create the relevant information structures, create
    // the thread, and then let it go.
    //
    PNTMARTA_WRKR_INFO      pWrkrInfo = NULL;
    PNTMARTA_SET_WRKR_INFO  pSetWrkrInfo =
              (PNTMARTA_SET_WRKR_INFO)AccAlloc(sizeof(NTMARTA_SET_WRKR_INFO));
    if(pSetWrkrInfo == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pSetWrkrInfo->ppwszObjectList = NULL;

        //
        // Initialize the rest of the items
        //
        pSetWrkrInfo->ObjectType = ObjectType;
        pSetWrkrInfo->pAccessList= pAccessList;
        pSetWrkrInfo->fFlags     = fSetFlags | NTMARTA_DELETE_ARGS;
    }

    //
    // If that worked, create the new worker info struct
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, create a new structure
        //
        pWrkrInfo = (PNTMARTA_WRKR_INFO)AccAlloc(sizeof(NTMARTA_WRKR_INFO));
        if(pWrkrInfo == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Initialize the structure members
            //
            pWrkrInfo->pOverlapped  = pOverlapped;
            pWrkrInfo->fState       = 0;
            pSetWrkrInfo->pWrkrInfo = pWrkrInfo;
        }
    }

    //
    // Now, get the path information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = NtProvGetBasePathsForFilePath((PWSTR)pwszObjectPath,
                                              pSetWrkrInfo->ObjectType,
                                              &(pSetWrkrInfo->cObjects),
                                              &(pSetWrkrInfo->ppwszObjectList));
    }

    //
    // Then, create the thread, SUSPENDED.  The insertion routine will send
    // if off.
    //
    if(dwErr == ERROR_SUCCESS)
    {
        DWORD   dwThreadId;

        HANDLE  hWorker = CreateThread(NULL,
                                       0,
                                       NtProvSetAccessRightsWorkerThread,
                                       (LPVOID)pSetWrkrInfo,
                                       CREATE_SUSPENDED,
                                       &dwThreadId);

        if(hWorker == NULL)
        {
            dwErr = GetLastError();
        }
        else
        {
            pWrkrInfo->hWorker = hWorker;

            //
            // Now, insert the new node in the list.  Note the use of the
            // resource, since the list is not multi-thread safe.  Note the
            // scoping, since we need to protect the list until the thread
            // actually gets started
            //
            dwErr = InsertAndContinueWorkerThread(pWrkrInfo);
        }
    }


    if(dwErr != ERROR_SUCCESS)
    {
        //
        // Clean up the allocated memory
        //
        if(pSetWrkrInfo != NULL)
        {
            AccFree(pSetWrkrInfo->ppwszObjectList);
        }
        AccFree(pSetWrkrInfo);

        if(pWrkrInfo != NULL)
        {
            AccFree(pWrkrInfo);
        }
    }

    return(dwErr);
}








//+---------------------------------------------------------------------------
//
//  Function:   NtProvDoHandleSet
//
//  Synopsis:   Sets up the worker thread to do the SetAccessRights for the
//              handle based APIs
//
//  Arguments:  [IN  hObject]           --  Handle to the object
//              [IN  ObjectType]        --  Type of the object
//              [IN  pSetInfo]          --  List of rights infos
//              [IN  cRightsInfos]      --  Number of items in list
//              [IN  pAccessList]       --  Ptr to a CAccessList class
//              [IN  pOwner]            --  Optional.  Owner to set
//              [IN  pGroup]            --  Optional.  Group to set
//              [IN  pOverlapped]       --  Overlapped structure to use for
//                                          asynchronous control
//              [IN  fSetFlags]         --  Flags governing the control of
//                                          the worker thread
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
NtProvDoHandleSet(IN  HANDLE              hObject,
                  IN  SE_OBJECT_TYPE      ObjectType,
                  IN  CAccessList        *pAccessList,
                  IN  PACTRL_OVERLAPPED   pOverlapped,
                  IN  DWORD               fSetFlags)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Ok, we'll create the relevant information structures, create
    // the thread, and then let it go.
    //
    PNTMARTA_WRKR_INFO      pWrkrInfo = NULL;
    PNTMARTA_SET_WRKR_INFO  pSetWrkrInfo =
              (PNTMARTA_SET_WRKR_INFO)AccAlloc(sizeof(NTMARTA_SET_WRKR_INFO));
    if(pSetWrkrInfo == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pSetWrkrInfo->ppwszObjectList = NULL;

        //
        // Initialize the rest of the items
        //
        pSetWrkrInfo->ObjectType = ObjectType;
        pSetWrkrInfo->pAccessList= pAccessList;
        pSetWrkrInfo->fFlags     = fSetFlags                |
                                        NTMARTA_DELETE_ARGS |
                                        NTMARTA_HANDLE_VALID;
        pSetWrkrInfo->hObject    = hObject;
    }

    //
    // If that worked, create the new worker info struct
    //
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, create a new structure
        //
        pWrkrInfo = (PNTMARTA_WRKR_INFO)AccAlloc(sizeof(NTMARTA_WRKR_INFO));
        if(pWrkrInfo == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            //
            // Initialize the structure members
            //
            pWrkrInfo->pOverlapped  = pOverlapped;
            pWrkrInfo->fState       = 0;
            pSetWrkrInfo->pWrkrInfo = pWrkrInfo;
        }
    }

    //
    // Then, create the thread, SUSPENDED.  The insertion routine will send
    // if off.
    //
    if(dwErr == ERROR_SUCCESS)
    {
        DWORD   dwThreadId;
        HANDLE  hWorker = CreateThread(NULL,
                                       0,
                                       NtProvSetAccessRightsWorkerThread,
                                       (LPVOID)pSetWrkrInfo,
                                       CREATE_SUSPENDED,
                                       &dwThreadId);
        if(hWorker == NULL)
        {
            dwErr = GetLastError();
        }
        else
        {
            pWrkrInfo->hWorker = hWorker;

            //
            // Now, insert the new node in the list.  Note the use of the
            // resource, since the list is not multi-thread safe.  Note the
            // scoping, since we need to protect the list until the thread
            // actually gets started
            //
            dwErr = InsertAndContinueWorkerThread(pWrkrInfo);
        }
    }


    if(dwErr != ERROR_SUCCESS)
    {
        //
        // Clean up the allocated memory
        //
        if(pSetWrkrInfo != NULL)
        {
            AccFree(pSetWrkrInfo->ppwszObjectList);
        }
        AccFree(pSetWrkrInfo);

        if(pWrkrInfo != NULL)
        {
            AccFree(pWrkrInfo);
        }
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProvGetAccessListForObject
//
//  Synopsis:
//
//  Arguments:  [IN  pObjectName]       --  Path to the object in question
//              [IN  ObjectType]        --  Type of the object
//              [IN  SecurityInfo]      --  What information is be obtained
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN OUT AccList]        --  The CAccessList reference to fill
//              [OUT ppOwner]           --  Number of trustees in list
//              [OUT ppGroup]           --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
NtProvGetAccessListForObject(IN  PWSTR                      pwszObject,
                             IN  SE_OBJECT_TYPE             ObjectType,
                             IN  PACTRL_RIGHTS_INFO         pRightsInfo,
                             IN  ULONG                      cProps,
                             OUT CAccessList              **ppAccessList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, allocate a new class pointer
    //
    *ppAccessList = new CAccessList;

    if(*ppAccessList == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    dwErr = (*ppAccessList)->SetObjectType(ObjectType);

    for(ULONG iIndex = 0; iIndex < cProps && dwErr == ERROR_SUCCESS; iIndex++)
    {
        //
        // Now, do the read
        //
        switch (ObjectType)
        {
        case SE_KERNEL_OBJECT:
            dwErr = ReadKernelPropertyRights(pwszObject,
                                             pRightsInfo,
                                             cProps,
                                             **ppAccessList);
            break;

        case SE_WMIGUID_OBJECT:
            dwErr = ReadWmiGuidPropertyRights(pwszObject,
                                              pRightsInfo,
                                              cProps,
                                              **ppAccessList);
            break;

        case SE_FILE_OBJECT:
            dwErr = ReadFilePropertyRights(pwszObject,
                                           pRightsInfo,
                                           cProps,
                                           **ppAccessList);

            break;

        case SE_SERVICE:
            dwErr = ReadServicePropertyRights(pwszObject,
                                              pRightsInfo,
                                              cProps,
                                              **ppAccessList);
            break;

        case SE_PRINTER:
            dwErr = ReadPrinterPropertyRights(pwszObject,
                                              pRightsInfo,
                                              cProps,
                                              **ppAccessList);
            break;

        case SE_REGISTRY_KEY:
            dwErr = ReadRegistryPropertyRights(pwszObject,
                                              pRightsInfo,
                                              cProps,
                                              **ppAccessList);
            break;

        case SE_LMSHARE:
            dwErr = ReadSharePropertyRights(pwszObject,
                                            pRightsInfo,
                                            cProps,
                                            **ppAccessList);
            break;

        case SE_DS_OBJECT:
#ifdef ACTRL_NEED_SET_PRIVS
            dwErr = SetPriv();
            if(dwErr == ERROR_SUCCESS)
            {
#endif
            dwErr = ReadDSObjPropertyRights(pwszObject,
                                            pRightsInfo,
                                            cProps,
                                            **ppAccessList);
#ifdef ACTRL_NEED_SET_PRIVS
            }
#endif
            break;

        case SE_DS_OBJECT_ALL:
#ifdef ACTRL_NEED_SET_PRIVS
            dwErr = SetPriv();
            if(dwErr == ERROR_SUCCESS)
            {
#endif
            (**ppAccessList).SetDsPathInfo(NULL,
                                           (PWSTR)pwszObject);
            dwErr = ReadAllDSObjPropertyRights(pwszObject,
                                               pRightsInfo,
                                               cProps,
                                               **ppAccessList);
#ifdef ACTRL_NEED_SET_PRIVS
            }
#endif
            break;

        default:
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    if (dwErr != ERROR_SUCCESS) {
        delete (*ppAccessList);
        *ppAccessList = 0;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProvGetAccessListForHandle
//
//  Synopsis:
//
//  Arguments:  [IN  hObject]           --  Handle to the object
//              [IN  ObjectType]        --  Type of the object
//              [IN  SecurityInfo]      --  What information is be obtained
//              [IN  pwszProperty]      --  Optional.  The name of the
//                                          property on the object to revoke
//                                          for
//              [IN OUT AccList]        --  The CAccessList reference to fill
//              [OUT ppOwner]           --  Number of trustees in list
//              [OUT ppGroup]           --  List of trustees to revoke
//
//  Returns:    ERROR_SUCCESS           --  The operation succeeded
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
NtProvGetAccessListForHandle(IN  HANDLE                     hObject,
                             IN  SE_OBJECT_TYPE             ObjectType,
                             IN  PACTRL_RIGHTS_INFO         pRightsInfo,
                             IN  ULONG                      cProps,
                             OUT CAccessList              **ppAccessList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, allocate a new class pointer
    //
    *ppAccessList = new CAccessList;

    if(*ppAccessList == NULL)
    {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    dwErr = (*ppAccessList)->SetObjectType(ObjectType);

    for(ULONG iIndex = 0; iIndex < cProps && dwErr == ERROR_SUCCESS; iIndex++)
    {
        //
        // Now, do the read
        //
        switch (ObjectType)
        {
        case SE_KERNEL_OBJECT:
            dwErr = GetKernelSecurityInfo(hObject,
                                          pRightsInfo,
                                          cProps,
                                          **ppAccessList);
            break;

        case SE_WMIGUID_OBJECT:
            dwErr = GetWmiGuidSecurityInfo(hObject,
                                           pRightsInfo,
                                           cProps,
                                           **ppAccessList);
            break;

        case SE_FILE_OBJECT:
            dwErr = ReadFileRights(hObject,
                                   pRightsInfo,
                                   cProps,
                                   **ppAccessList);

            break;

        case SE_SERVICE:
            dwErr = ReadServiceRights((SC_HANDLE)hObject,
                                      pRightsInfo,
                                      cProps,
                                      **ppAccessList);
            break;

        case SE_PRINTER:
            dwErr = ReadPrinterRights(hObject,
                                      pRightsInfo,
                                      cProps,
                                      **ppAccessList);
            break;

        case SE_REGISTRY_KEY:
            dwErr = ReadRegistryRights(hObject,
                                       pRightsInfo,
                                       cProps,
                                       **ppAccessList);
            break;

        case SE_WINDOW_OBJECT:
            dwErr = ReadWindowPropertyRights(hObject,
                                             pRightsInfo,
                                             cProps,
                                             **ppAccessList);
            break;


        case SE_LMSHARE:            // FALL THROUGH
        case SE_DS_OBJECT:          // FALL THROUGH
        case SE_DS_OBJECT_ALL:      // FALL THROUGH
            dwErr = ERROR_INVALID_PARAMETER;
            break;

        default:
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
    }

    if (dwErr != ERROR_SUCCESS) {
        delete (*ppAccessList);
        *ppAccessList = 0;
    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   NtProSetRightsList
//
//  Synopsis:   Goes through an optional access and audit list, and builds
//              the required RIGHTS_INFO list
//
//  Arguments:  [IN  pAccessList]       --  Optional access list to scan
//              [IN  pAuditList]        --  Optional audit list to scan
//              [OUT pcItems]           --  Where the count of items in the
//                                          rights info list is returned
//              [OUT ppRightsList]      --  Where the rights list is returned
//
//  Returns:    ERROR_SUCCESS           --  Success
//              ERROR_NOT_ENOUGH_MEMORY --  A memory allocation failed
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
NtProvSetRightsList(IN  OPTIONAL   PACTRL_ACCESS            pAccessList,
                    IN  OPTIONAL   PACTRL_AUDIT             pAuditList,
                    OUT            PULONG                   pcItems,
                    OUT            PACTRL_RIGHTS_INFO      *ppRightsList)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // Simple.  We'll go through and count the number of entries we need
    //
    ULONG   cItems = 0;

    if(pAccessList == NULL)
    {
        if(pAuditList != NULL)
        {
            cItems = pAuditList->cEntries;
        }
    }
    else
    {
        cItems = pAccessList->cEntries;
        if(pAuditList != NULL)
        {
            //
            // We'll make the assumption that they are all different.  In that
            // way, at worst, we'll allocate a few more pointers than we need
            // to.
            //
            cItems += pAuditList->cEntries;
        }
    }

    //
    // Now, do the allocation
    //
    *ppRightsList = (PACTRL_RIGHTS_INFO)AccAlloc(
                                       cItems * sizeof(ACTRL_RIGHTS_INFO));
    if(*ppRightsList == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        //
        // Ok, now we'll copy over only the unique lists
        //

        *pcItems = 0;
        //
        // Start with the access list
        //
        ULONG cAccess = 0;
        if(pAccessList != NULL)
        {
            for(ULONG iIndex = 0; iIndex < pAccessList->cEntries; iIndex++)
            {
                (*ppRightsList)[iIndex].pwszProperty = (PWSTR)
                        (pAccessList->pPropertyAccessList[iIndex].lpProperty);
                (*ppRightsList)[iIndex].SeInfo = DACL_SECURITY_INFORMATION;
            }

            *pcItems = pAccessList->cEntries;
            cAccess  = pAccessList->cEntries;
        }

        //
        // Ok, now process the audit list
        //
        if(pAuditList != NULL)
        {
            for(ULONG iIndex = 0; iIndex < pAuditList->cEntries; iIndex++)
            {
                //
                // See if this is a new entry or not...
                //
                for(ULONG iChk = 0; iChk < cAccess; iChk++)
                {
                    if(_wcsicmp((PWSTR)(pAuditList->
                                      pPropertyAccessList[iIndex].lpProperty),
                                (*ppRightsList)[iChk].pwszProperty) == 0)
                    {
                        (*ppRightsList)[iIndex].SeInfo |=
                                                    SACL_SECURITY_INFORMATION;
                        break;
                    }
                }

                //
                // Ok, if we got and didn't find the entry, add it
                //
                if(iChk >= cAccess)
                {
                    (*ppRightsList)[*pcItems].pwszProperty = (PWSTR)
                        (pAuditList->pPropertyAccessList[iIndex].lpProperty);
                    (*ppRightsList)[*pcItems].SeInfo =
                                                   SACL_SECURITY_INFORMATION;
                }
            }
        }
    }

    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   InsertAndContinueWorkerThread
//
//  Synopsis:   Inserts a new worker thread info into the list, and resumes
//              the worker thread
//
//  Arguments:  [IN  pWrkrInfo]         --  Worker info to insert
//
//  Returns:    ERROR_SUCCESS           --  Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
InsertAndContinueWorkerThread(PNTMARTA_WRKR_INFO      pWrkrInfo)
{
    DWORD   dwErr = ERROR_SUCCESS;
    HANDLE  Token = NULL;

    //
    // If there is a thread token, make sure we set it as our current thread token before
    // we continue execution
    //
    if(!OpenThreadToken(GetCurrentThread(),
                        MAXIMUM_ALLOWED,
                        TRUE,
                        &Token))
    {
        dwErr = GetLastError();

        //
        // if not, use the process token
        //
        if(dwErr == ERROR_NO_TOKEN)
        {
            dwErr = ERROR_SUCCESS;
        }
    }
    else
    {
        if(SetThreadToken(&(pWrkrInfo->hWorker),
                          Token) == FALSE )
        {

            dwErr = GetLastError();
        }
    }

    if (dwErr == ERROR_SUCCESS)
    {

        RtlAcquireResourceExclusive(&gWrkrLock, TRUE);

        dwErr = gWrkrList.Insert((PVOID)pWrkrInfo);

        if(dwErr == ERROR_SUCCESS)
        {
            if(ResumeThread(pWrkrInfo->hWorker) == 0xFFFFFFFF)
            {
                dwErr = GetLastError();
            }
        }

        RtlReleaseResource(&gWrkrLock);

        //
        // If we failed to insert or resume the thread, make sure to
        // kill it
        //
        if(dwErr != ERROR_SUCCESS)
        {
            TerminateThread(pWrkrInfo->hWorker,
                            dwErr);
        }

    }


    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\prtctx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       prtctx.cpp
//
//  Contents:   Implementation of CPrinterContext and NT Marta Printer Functions
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#if 0
//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::CPrinterContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CPrinterContext::CPrinterContext ()
{
    m_cRefs = 1;
    m_hPrinter = NULL;
    m_fNameInitialized = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::~CPrinterContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CPrinterContext::~CPrinterContext ()
{
    if ( ( m_hPrinter != NULL ) && ( m_fNameInitialized == TRUE ) )
    {
        ClosePrinter( m_hPrinter );
    }

    assert( m_cRefs == 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::InitializeByName, public
//
//  Synopsis:   initialize the context given the name of the printer
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask)
{
    PRINTER_DEFAULTSW PrinterDefaults;

    PrinterDefaults.pDatatype = NULL;
    PrinterDefaults.pDevMode = NULL;
    PrinterDefaults.DesiredAccess = AccessMask;

    if ( OpenPrinterW(
             (LPWSTR)pObjectName,
             &m_hPrinter,
             &PrinterDefaults
             ) == FALSE )
    {
        return( GetLastError() );
    }

    m_fNameInitialized = TRUE;

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::InitializeByHandle, public
//
//  Synopsis:   initialize the context given a printer handle
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::InitializeByHandle (HANDLE Handle)
{
    m_hPrinter = Handle;
    assert( m_fNameInitialized == FALSE );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::AddRef, public
//
//  Synopsis:   add a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::AddRef ()
{
    m_cRefs += 1;
    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::Release, public
//
//  Synopsis:   release a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::Release ()
{
    m_cRefs -= 1;

    if ( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::GetPrinterProperties, public
//
//  Synopsis:   get properties about the context
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::GetPrinterProperties (
                    PMARTA_OBJECT_PROPERTIES pObjectProperties
                    )
{
    if ( pObjectProperties->cbSize < sizeof( MARTA_OBJECT_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pObjectProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CPrinterContext::GetPrinterRights, public
//
//  Synopsis:   get the Printer security descriptor
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::GetPrinterRights (
                    SECURITY_INFORMATION SecurityInfo,
                    PSECURITY_DESCRIPTOR* ppSecurityDescriptor
                    )
{
    PISECURITY_DESCRIPTOR pisd = NULL;
    PSECURITY_DESCRIPTOR  psd = NULL;
    DWORD                 cb = 0;
    PPRINTER_INFO_3       pPrinterInfo = NULL;

    assert( m_hPrinter != NULL );

    if ( ( GetPrinterW(
              m_hPrinter,
              3,
              (LPBYTE)pPrinterInfo,
              cb,
              &cb
              ) == FALSE ) &&
         ( cb > 0 ) )
    {
        pPrinterInfo = (PPRINTER_INFO_3)new BYTE [ cb ];
        if ( pPrinterInfo != NULL )
        {
            if ( GetPrinterW(
                    m_hPrinter,
                    3,
                    (LPBYTE)pPrinterInfo,
                    cb,
                    &cb
                    ) == FALSE )
            {
                delete pPrinterInfo;
                return( GetLastError() );
            }
        }
        else
        {
            return( E_OUTOFMEMORY );
        }
    }
    else
    {
        return( GetLastError() );
    }

    pisd = (PISECURITY_DESCRIPTOR)pPrinterInfo->pSecurityDescriptor;
    if ( pisd->Control & SE_SELF_RELATIVE )
    {
        cb = GetSecurityDescriptorLength( pPrinterInfo->pSecurityDescriptor );
        psd = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
        if ( psd == NULL )
        {
            return( ERROR_OUTOFMEMORY );
        }

        memcpy( psd, pPrinterInfo->pSecurityDescriptor, cb );
    }
    else
    {
        if ( MakeSelfRelativeSD(
                 pPrinterInfo->pSecurityDescriptor,
                 NULL,
                 &cb
                 ) == FALSE )
        {
            if ( cb > 0 )
            {
                psd = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
                if ( psd != NULL )
                {
                    if ( MakeSelfRelativeSD(
                             pPrinterInfo->pSecurityDescriptor,
                             psd,
                             &cb
                             ) == FALSE )
                    {
                        LocalFree( psd );
                        return( GetLastError() );
                    }
                }
            }
            else
            {
                return( GetLastError() );
            }
        }
    }

    *ppSecurityDescriptor = psd;

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceContext::SetPrinterRights, public
//
//  Synopsis:   set the window security descriptor
//
//----------------------------------------------------------------------------
DWORD
CPrinterContext::SetPrinterRights (
                   SECURITY_INFORMATION SecurityInfo,
                   PSECURITY_DESCRIPTOR pSecurityDescriptor
                   )
{
    PRINTER_INFO_3 PrinterInfo;

    assert( m_hPrinter != NULL );

    PrinterInfo.pSecurityDescriptor = pSecurityDescriptor;

    if ( SetPrinterW( m_hPrinter, 3, (LPBYTE)&PrinterInfo, 0 ) == FALSE )
    {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

//
// Functions from printer.h which dispatch unto the CPrinterContext class
//

DWORD
MartaAddRefPrinterContext(
   IN MARTA_CONTEXT Context
   )
{
    return( ( (CPrinterContext *)Context )->AddRef() );
}

DWORD
MartaClosePrinterContext(
     IN MARTA_CONTEXT Context
     )
{
    return( ( (CPrinterContext *)Context )->Release() );
}

DWORD
MartaGetPrinterProperties(
   IN MARTA_CONTEXT Context,
   IN OUT PMARTA_OBJECT_PROPERTIES pProperties
   )
{
    return( ( (CPrinterContext *)Context )->GetPrinterProperties( pProperties ) );
}

DWORD
MartaGetPrinterTypeProperties(
   IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
   )
{
    if ( pProperties->cbSize < sizeof( MARTA_OBJECT_TYPE_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

DWORD
MartaGetPrinterRights(
   IN  MARTA_CONTEXT Context,
   IN  SECURITY_INFORMATION   SecurityInfo,
   OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
   )
{
    return( ( (CPrinterContext *)Context )->GetPrinterRights(
                                               SecurityInfo,
                                               ppSecurityDescriptor
                                               ) );
}

DWORD
MartaOpenPrinterNamedObject(
    IN  LPCWSTR pObjectName,
    IN  ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CPrinterContext* pPrinterContext;

    pPrinterContext = new CPrinterContext;
    if ( pPrinterContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pPrinterContext->InitializeByName( pObjectName, AccessMask );
    if ( Result != ERROR_SUCCESS )
    {
        pPrinterContext->Release();
        return( Result );
    }

    *pContext = pPrinterContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaOpenPrinterHandleObject(
    IN  HANDLE   Handle,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CPrinterContext* pPrinterContext;

    pPrinterContext = new CPrinterContext;
    if ( pPrinterContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pPrinterContext->InitializeByHandle( Handle );
    if ( Result != ERROR_SUCCESS )
    {
        pPrinterContext->Release();
        return( Result );
    }

    *pContext = pPrinterContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaSetPrinterRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return( ( (CPrinterContext *)Context )->SetPrinterRights(
                                               SecurityInfo,
                                               pSecurityDescriptor
                                               ) );
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\service.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       service.cxx
//
//  Contents:   Service support functions
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   OpenServiceObject
//
//  Synopsis:   Opens the specified service object
//
//  Arguments:  [IN pwszService]        --      The name of the service to
//                                              open
//              [IN AccessMask]         --      Flags indicating if the object
//                                              is to be opened to read or write
//                                              the DACL
//              [OUT pHandle]           --      Where the open handle is
//                                              returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//              ERROR_INVALID_PARAMETER --      A bad name was given
//
//----------------------------------------------------------------------------
DWORD
OpenServiceObject(IN  LPWSTR       pwszService,
                  IN  ACCESS_MASK  AccessMask,
                  OUT SC_HANDLE   *pHandle)
{
    acDebugOut((DEB_TRACE, "in OpenServiceObject \n"));

    DWORD dwErr;

    //
    // Make sure the service functions are loaded
    //
    dwErr = LoadDLLFuncTable();
    if(dwErr != ERROR_SUCCESS)
    {
        return(dwErr);
    }

    if(pwszService != NULL)
    {
        WCHAR   wszName[MAX_PATH + 1];
        PWSTR   pwszName;
        //
        // save the object since we must crack it to go to remote machines
        //
        dwErr = AccGetBufferOfSizeW(pwszService,
                                    wszName,
                                    &pwszName);
        if(dwErr == ERROR_SUCCESS)
        {
            PWSTR   pwszSvcName, pwszMachine;

            //
            // Separate the names
            //
            dwErr = ParseName(pwszName,
                              &pwszMachine,
                              &pwszSvcName);

            //
            // Go ahead and open the service control manager
            //
            if(dwErr == ERROR_SUCCESS)
            {
                SC_HANDLE hSC = OpenSCManager(pwszMachine,
                                              NULL,
                                              GENERIC_READ);
                if(hSC == NULL)
                {
                    dwErr = GetLastError();
                }
                else
                {
                    //
                    // Open the service
                    //
                    *pHandle = OpenService(hSC,
                                           pwszSvcName,
                                           AccessMask);
                    if(*pHandle == NULL)
                    {
                        dwErr = GetLastError();
                    }

                    //
                    // Close the handle to the scm
                    //
                    CloseServiceHandle(hSC);
                }

            }

            //
            // Free our buffer
            //
            AccFreeBufferOfSizeW(wszName, pwszName);
        }
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    acDebugOut((DEB_TRACE, "Out OpenServiceObject: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadServicePropertyRights
//
//  Synopsis:   Gets the specified security info for the specified service
//              object
//
//  Arguments:  [IN  pwszService]       --      The service to get the rights
//                                              for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadServicePropertyRights(IN  LPWSTR                pwszService,
                          IN  PACTRL_RIGHTS_INFO    pRightsList,
                          IN  ULONG                 cRights,
                          IN  CAccessList&          AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadServicePropertyRights\n"));
    DWORD       dwErr = ERROR_SUCCESS;
    SC_HANDLE   hSvc;

    //
    // For the moment, there is only service property itself...
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }


    //
    // Open the service
    //
    dwErr = OpenServiceObject(pwszService,
                              GetDesiredAccess(READ_ACCESS_RIGHTS,
                                               pRightsList[0].SeInfo),
                              &hSvc);

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = ReadServiceRights(hSvc,
                                  pRightsList,
                                  cRights,
                                  AccessList);
        //
        // Close the object handle
        //
        CloseServiceHandle(hSvc);
    }

    acDebugOut((DEB_TRACE, "Out ReadServicePropertyRights: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadServiceRights
//
//  Synopsis:   Gets the specified security info for the specified service
//              object
//
//  Arguments:  [IN  hSvc]              --      Handle to the open service
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadServiceRights(IN  SC_HANDLE             hSvc,
                  IN  PACTRL_RIGHTS_INFO    pRightsList,
                  IN  ULONG                 cRights,
                  IN  CAccessList&          AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadServiceRights\n"));
    DWORD       dwErr = ERROR_SUCCESS;

    //
    // For the moment, there is only service property itself...
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }


    //
    // Get the service security...
    //
    UCHAR                   SDBuff[PSD_BASE_LENGTH];
    PISECURITY_DESCRIPTOR   pSD = (PISECURITY_DESCRIPTOR)SDBuff;
    ULONG                   cSize = 0;

    //
    // Get the size of the security descriptor from the service
    //
    if(QueryServiceObjectSecurity(hSvc,
                                  pRightsList[0].SeInfo,
                                  pSD,
                                  PSD_BASE_LENGTH,
                                  &cSize) == FALSE)
    {
        dwErr = GetLastError();

        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            dwErr = ERROR_SUCCESS;
            pSD = (PISECURITY_DESCRIPTOR)AccAlloc(cSize);
            if(pSD == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                if(QueryServiceObjectSecurity(hSvc,
                                              pRightsList[0].SeInfo,
                                              pSD,
                                              cSize,
                                              &cSize) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }
        }
    }

    //
    // If all that worked, we'll add our SD
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccessList.AddSD(pSD,
                                 pRightsList->SeInfo,
                                 pRightsList->pwszProperty);
    }

    //
    // Free our memory if we allocated...
    //
    if(cSize > PSD_BASE_LENGTH)
    {
        AccFree(pSD);
    }

    acDebugOut((DEB_TRACE, "Out ReadServiceRights: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetServiceParentRights
//
//  Synopsis:   Determines who the parent is, and gets the access rights
//              for it.  It is used to aid in determining what the approriate
//              inheritance bits are.
//
//              This operation does not make sense for kernel objects
//
//  Arguments:  [IN  pwszService]       --      The service to get the parent
//                                              for
//              [IN  pRightsList]       --      The properties to get the
//                                              rights for
//              [IN  cRights]           --      Number of items in rights list
//              [OUT ppDAcl]            --      Where the DACL is returned
//              [OUT ppSAcl]            --      Where the SACL is returned
//              [OUT ppSD]              --      Where the Security Descriptor
//                                              is returned
//
//  Returns:    ERROR_INVALID_FUNCTION  --      Call doesn't make sense here
//
//----------------------------------------------------------------------------
DWORD
GetServiceParentRights(IN  LPWSTR                    pwszService,
                       IN  PACTRL_RIGHTS_INFO        pRightsList,
                       IN  ULONG                     cRights,
                       OUT PACL                     *ppDAcl,
                       OUT PACL                     *ppSAcl,
                       OUT PSECURITY_DESCRIPTOR     *ppSD)
{
    //
    // This doesn't currently make sense for kernel objects, so simply
    // return an error
    //
    return(ERROR_INVALID_FUNCTION);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetServiceSecurityInfo
//
//  Synopsis:   Sets the specified security info on the specified service
//              object
//
//  Arguments:  [IN  hService]          --      The handle of the object
//              [IN  SeInfo]            --      Flag indicating what security
//                                              info to set
//              [IN  pwszProperty]      --      The property on the object to
//                                              set
//                                              For kernel objects, this MBZ
//              [IN  pSD]               --      The security descriptor to set
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was given
//
//----------------------------------------------------------------------------
DWORD
SetServiceSecurityInfo(IN  SC_HANDLE                 hService,
                       IN  SECURITY_INFORMATION      SeInfo,
                       IN  PWSTR                     pwszProperty,
                       IN  PSECURITY_DESCRIPTOR      pSD)
{
    acDebugOut((DEB_TRACE, "in SetServiceSecurityInfo\n"));

    DWORD       dwErr = ERROR_SUCCESS;

    //
    // Service don't have properties
    //
    if(pwszProperty != NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION)) {

            ((PISECURITY_DESCRIPTOR)pSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
        }

        if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION)) {

            ((PISECURITY_DESCRIPTOR)pSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
        }

        //
        // set the security descriptor on the service
        //
        if(SetServiceObjectSecurity(hService,
                                    SeInfo,
                                    pSD) == FALSE)
         {
             dwErr = GetLastError();
         }
    }
    acDebugOut((DEB_TRACE, "Out SetServiceSecurityInfo: %lu\n", dwErr));

    return(dwErr);
}

#if 0
//+---------------------------------------------------------------------------
//
//  Function :  GetServiceAccessMaskFromProviderIndependentRights
//
//  Synopsis :  translates the specified provider independent access rights into
//              an access mask for a service
//
//  Arguments: IN [AccessRights]   - the input access rights
//             OUT [AccessMask]   - the returned NT access mask
//
//----------------------------------------------------------------------------
void GetServiceAccessMaskFromProviderIndependentRights(ULONG AccessRights,
                                                       ACCESS_MASK *AccessMask)
{
    if (PROV_OBJECT_READ & AccessRights)
    {
        *AccessMask |= SERVICE_READ;
    }
    if (PROV_OBJECT_WRITE & AccessRights)
    {
        *AccessMask |= SERVICE_WRITE;
    }
    if (PROV_OBJECT_EXECUTE & AccessRights)
    {
        *AccessMask |= SERVICE_EXECUTE;
    }
}
//+---------------------------------------------------------------------------
//
//  Function :  GetServiceProviderIndependentRightsFromAccessMask
//
//  Synopsis :  translates a service access mask into provider independent
//              access rights
//
//  Arguments: IN OUT [AccessMask]   - the input NT access mask (modified)
//             OUT [AccessRights]   - the returned access rights
//
//----------------------------------------------------------------------------
ACCESS_RIGHTS GetServiceProviderIndependentRightsFromAccessMask( ACCESS_MASK AccessMask)
{
    ACCESS_RIGHTS accessrights = 0;

    if (GENERIC_ALL & AccessMask)
    {
        accessrights = PROV_ALL_ACCESS;
    } else
    {
        if (KEY_ALL_ACCESS == (KEY_ALL_ACCESS & AccessMask))
        {
            accessrights = PROV_ALL_ACCESS;
        } else
        {
            if (WRITE_DAC & AccessMask)
            {
                accessrights |= PROV_EDIT_ACCESSRIGHTS;
            }

            if (SERVICE_READ == (SERVICE_READ & AccessMask))
            {
                accessrights |= PROV_OBJECT_READ;
            }
            if (SERVICE_WRITE == (SERVICE_WRITE & AccessMask))
            {
                accessrights |= PROV_OBJECT_WRITE;
            }
            if (SERVICE_EXECUTE == (SERVICE_EXECUTE & AccessMask) )
            {
                accessrights |= PROV_OBJECT_EXECUTE;
            }
        }
    }
    return(accessrights);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:    registry.cxx
//
//  Contents:    local functions
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <alsup.hxx>
#include <martaevt.h>

//
// Registry generic mapping
//
GENERIC_MAPPING         gRegGenMapping = {STANDARD_RIGHTS_READ     | 0x1,
                                          STANDARD_RIGHTS_WRITE    | 0x2,
                                          STANDARD_RIGHTS_EXECUTE  | 0x4,
                                          STANDARD_RIGHTS_REQUIRED | 0x3F};



//+---------------------------------------------------------------------------
//
//  Function : GetDesiredAccess
//
//  Synopsis : Gets the access required to open object to be able to set or
//             get the specified security info.
//
//  Arguments: IN [SecurityOpenType]  - Flag indicating if the object is to be
//                                      opened to read or write the DACL
//
//----------------------------------------------------------------------------
ACCESS_MASK RegGetDesiredAccess(IN SECURITY_OPEN_TYPE   OpenType,
                                IN SECURITY_INFORMATION SecurityInfo)
{
    acDebugOut((DEB_TRACE_ACC, "in GetDesiredAccess \n"));

    ACCESS_MASK DesiredAccess = 0;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    }

    acDebugOut((DEB_TRACE_ACC, "out RegGetDesiredAccess: %lu\n", DesiredAccess));

    return (DesiredAccess);
}


//+---------------------------------------------------------------------------
//
//  Function:   OpenRegistryObject
//
//  Synopsis:   Opens the specified registry object
//
//  Arguments:  [IN pwszRegistry]       --      The name of the registry key
//                                              to open
//              [IN AccessMask]         --      Flags indicating if the object
//                                              is to be opened to read or write
//                                              the DACL
//              [OUT pHandle]           --      Where the open handle is
//                                              returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//              ERROR_INVALID_PARAMETER --      A bad name was given
//
//----------------------------------------------------------------------------
DWORD
OpenRegistryObject(IN  LPWSTR       pwszRegistry,
                   IN  ACCESS_MASK  AccessMask,
                   OUT PHANDLE      pHandle)
{
    acDebugOut((DEB_TRACE, "in OpenRegistryObject\n"));

    DWORD dwErr;
    HKEY  hBase;

    if(pwszRegistry != NULL)
    {
        WCHAR   wszName[MAX_PATH + 1];
        PWSTR   pwszName;
        //
        // save the object since we must crack it to go to remote machines
        //
        dwErr = AccGetBufferOfSizeW(pwszRegistry,
                                    wszName,
                                    &pwszName);
        if(dwErr == ERROR_SUCCESS)
        {
            PWSTR   pwszRemaining, pwszMachine;

            //
            // Separate the names
            //
            dwErr = ParseName(pwszName,
                              &pwszMachine,
                              &pwszRemaining);

            if(dwErr == ERROR_SUCCESS)
            {
                PWSTR   pwszKey = NULL;
                //
                // look for the key names  localization required.
                //
                if (pwszRemaining != NULL)
                {
                    PWSTR   pwszBase = pwszRemaining;
                    pwszKey  = wcschr(pwszRemaining, L'\\');
                    if(pwszKey != NULL)
                    {
                        *pwszKey = L'\0';
                        pwszKey++;
                    }

                    //
                    // Now, figure out what our base key will be
                    //
                    if(_wcsicmp(pwszBase, L"MACHINE") == 0)
                    {
                        hBase = HKEY_LOCAL_MACHINE;
                    }
                    else if(_wcsicmp(pwszBase, L"USERS") == 0 ||
                            _wcsicmp(pwszBase, L"USER") == 0 )
                    {
                        hBase = HKEY_USERS;
                    }
                    //
                    // The next three are valid only for the local machine
                    //
                    else if(pwszMachine == NULL &&
                            _wcsicmp(pwszBase, L"CLASSES_ROOT") == 0)
                    {
                        hBase = HKEY_CLASSES_ROOT;
                    }
                    else if(pwszMachine == NULL &&
                            _wcsicmp(pwszBase,L"CURRENT_USER") == 0)
                    {
                        hBase = HKEY_CURRENT_USER;
                    }
                    else if(pwszMachine == NULL &&
                            _wcsicmp(pwszBase, L"CONFIG") == 0)
                    {
                        hBase = HKEY_CURRENT_CONFIG;
                    }
                    else
                    {
                        dwErr = ERROR_INVALID_PARAMETER;
                    }
                }
                else
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                }

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // if it is a remote name, connect to that registry
                    //
                    if(pwszMachine != NULL)
                    {
                        HKEY hMach = hBase;
                        dwErr = RegConnectRegistry(pwszMachine,
                                                   hMach,
                                                   &hBase);
                    }

                    //
                    // Now, open the key
                    //
                    if(dwErr == ERROR_SUCCESS)
                    {
                        dwErr = RegOpenKeyEx(hBase,
                                             pwszKey,
                                             0,
                                             AccessMask,
                                             (PHKEY)pHandle);

                        if(pwszMachine != NULL)
                        {
                            RegCloseKey(hBase);
                        }
                    }
                }
            }

            AccFreeBufferOfSizeW(wszName, pwszName);
        }
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }

    acDebugOut((DEB_TRACE, "Out OpenRegistryObject: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadRegistryPropertyRights
//
//  Synopsis:   Gets the specified security info for the specified registry
//              object
//
//  Arguments:  [IN  pwszRegistry]      --      The reg key to get the rights
//                                              for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadRegistryPropertyRights(IN  LPWSTR                pwszRegistry,
                           IN  PACTRL_RIGHTS_INFO    pRightsList,
                           IN  ULONG                 cRights,
                           IN  CAccessList&          AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadRegistryPropertyRights\n"));

    HANDLE hReg;
    DWORD  dwErr;

    //
    // Currently, there are only registry object properties
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Set the lookup server name
    //
    dwErr = SetAccessListLookupServer( pwszRegistry,
                                       AccessList );

    //
    // Open the registry key
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = OpenRegistryObject(pwszRegistry,
                                   RegGetDesiredAccess(READ_ACCESS_RIGHTS,
                                                       pRightsList[0].SeInfo),
                                   &hReg);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        PSECURITY_DESCRIPTOR    pSD;
        dwErr = ReadRegistrySecurityInfo(hReg,
                                         pRightsList[0].SeInfo,
                                         &pSD);
        //
        // If that worked, we'll have to get the parent SD, if it exists,
        // and see if we can determine the inheritance on our current object
        //
        if(dwErr == ERROR_SUCCESS)
        {
            if((pRightsList[0].SeInfo & ~(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION)) != 0 &&
                !FLAG_ON(((PISECURITY_DESCRIPTOR)pSD)->Control,
                         SE_SACL_AUTO_INHERITED |
                            SE_DACL_AUTO_INHERITED))
            {
                //
                // Ok, it's downlevel, so get the parent SD...
                //
                PSECURITY_DESCRIPTOR    pParentSD;
                dwErr = GetRegistryParentRights(pwszRegistry,
                                                pRightsList[0].SeInfo,
                                                &pParentSD);

                //
                // Also, the routine to convert from nt4 to nt5 security
                // descriptor requires that we have the owner and group,
                // so we may have to reread the child SD if we don't have
                // that info
                //
                if(dwErr == ERROR_SUCCESS && (!FLAG_ON(pRightsList[0].SeInfo,
                                            OWNER_SECURITY_INFORMATION)  ||
                                            !FLAG_ON(pRightsList[0].SeInfo,
                                            GROUP_SECURITY_INFORMATION)))
                {
                    AccFree(pSD);
                    pSD = NULL;
                    dwErr = ReadRegistrySecurityInfo(hReg,
                                                     pRightsList[0].SeInfo          |
                                                        OWNER_SECURITY_INFORMATION  |
                                                        GROUP_SECURITY_INFORMATION,
                                                     &pSD);
                }

                //
                // A NULL parent SD means this object has no parent!
                //
                if(dwErr == ERROR_SUCCESS && pParentSD != NULL)
                {
                    PSECURITY_DESCRIPTOR    pNewSD;
                    dwErr = ConvertToAutoInheritSD(pParentSD,
                                                   pSD,
                                                   TRUE,
                                                   &gRegGenMapping,
                                                   &pNewSD);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        dwErr = AccessList.AddSD(pNewSD,
                                                 pRightsList[0].SeInfo,
                                                 pRightsList[0].pwszProperty);

                        DestroyPrivateObjectSecurity(&pNewSD);
                    }

                    AccFree(pParentSD);
                }
            }
            else
            {
                //
                // Simply add the SD to our list
                //
                dwErr = AccessList.AddSD(pSD,
                                         pRightsList[0].SeInfo,
                                         pRightsList[0].pwszProperty);

            }

            //
            // Make sure to free the security descriptor...
            //
            AccFree(pSD);
        }


        RegCloseKey((HKEY)hReg);
    }


    acDebugOut((DEB_TRACE, "Out  ReadRegistryPropertyRights: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadRegistryRights
//
//  Synopsis:   Gets the specified security info for the specified registry
//              object
//
//  Arguments:  [IN  hRegistry]         --      Reg handle to get the rights
//                                              for
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadRegistryRights(IN  HANDLE                hRegistry,
                   IN  PACTRL_RIGHTS_INFO    pRightsList,
                   IN  ULONG                 cRights,
                   IN  CAccessList&          AccessList)
{
    acDebugOut((DEB_TRACE, "in ReadRegistryRights\n"));

    DWORD  dwErr;

    //
    // Currently, there are only registry object properties
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }


    PSECURITY_DESCRIPTOR    pSD = NULL;

    dwErr = ReadRegistrySecurityInfo(hRegistry,
                                     pRightsList[0].SeInfo,
                                     &pSD);
    if((dwErr != ERROR_SUCCESS) || (pSD == NULL))
    {
        return(dwErr);
    }

    //
    // Take a look at it... If it's a downlevel object, let's reread it as an uplevel, if
    // possible
    //
    if(!FLAG_ON(((PISECURITY_DESCRIPTOR)pSD)->Control,
                  SE_SACL_AUTO_INHERITED |
                               SE_DACL_AUTO_INHERITED))
    {
        PWSTR   pwszRegPath = NULL;

        dwErr = ConvertRegHandleToName((HKEY)hRegistry,
                                       &pwszRegPath);
        if(dwErr != ERROR_SUCCESS)
        {
            if(dwErr == ERROR_INVALID_HANDLE)
            {
                //
                // It's remote, so add it as is...
                //
                dwErr = AccessList.AddSD(pSD,
                                         pRightsList->SeInfo,
                                         pRightsList->pwszProperty);
            }
        }
        else
        {
            dwErr = ReadRegistryPropertyRights(pwszRegPath,
                                               pRightsList,
                                               cRights,
                                               AccessList);
            AccFree(pwszRegPath);
        }

    }
    else
    {
        //
        // It's already uplevel, so add it as is...
        //
        dwErr = AccessList.AddSD(pSD,
                                 pRightsList->SeInfo,
                                 pRightsList->pwszProperty);
    }

    AccFree(pSD);

    acDebugOut((DEB_TRACE, "Out  ReadRegistryRights: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ReadRegistrySecurityInfo
//
//  Synopsis:   Reads the specified security info for the handle's registry
//              key object
//
//  Arguments:  [IN  hRegistry]         --      The handle to the object to
//                                              get the rights for
//              [IN  SeInfo]            --      SecurityInfo to read based
//              [OUT ppOwner]           --      The owner sid
//              [OUT ppGroup]           --      The group sid
//              [OUT pDAcl]             --      The DACL
//              [OUT pSAcl]             --      The SACL
//              [OUT pSD]               --      The security descriptor itself
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadRegistrySecurityInfo(IN  HANDLE                 hRegistry,
                         IN  SECURITY_INFORMATION   SeInfo,
                         OUT PSECURITY_DESCRIPTOR  *ppSD)
{
    acDebugOut((DEB_TRACE, "in ReadRegistrySecurityInfo \n"));

    ULONG                   cSize = 0;
    DWORD                   dwErr;

    //
    // First, get the size we need
    //
    dwErr = RegGetKeySecurity((HKEY)hRegistry,
                              SeInfo,
                              *ppSD,
                              &cSize);
    if(dwErr == ERROR_INSUFFICIENT_BUFFER)
    {
        dwErr = ERROR_SUCCESS;
        *ppSD = (PISECURITY_DESCRIPTOR)AccAlloc(cSize);
        if(*ppSD == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            dwErr = RegGetKeySecurity((HKEY)hRegistry,
                                      SeInfo,
                                      *ppSD,
                                      &cSize);


            if(dwErr == ERROR_SUCCESS &&
                FLAG_ON(((SECURITY_DESCRIPTOR *)*ppSD)->Control,SE_SELF_RELATIVE))
            {
                PSECURITY_DESCRIPTOR    pAbs;
                dwErr = MakeSDAbsolute(*ppSD,
                                       SeInfo,
                                       &pAbs);
                if(dwErr == ERROR_SUCCESS)
                {
                    AccFree(*ppSD);
                    *ppSD = pAbs;
                }
            }
        }
    }
    else

    {
        ASSERT(dwErr != ERROR_INSUFFICIENT_BUFFER);
    }


    acDebugOut((DEB_TRACE, "Out ReadRegistrySecurityInfo: %lu\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   GetRegistryParentRights
//
//  Synopsis:   Determines who the parent is, and gets the access rights
//              for it.  It is used to aid in determining what the approriate
//              inheritance bits are.
//
//              This operation does not make sense for kernel objects
//
//  Arguments:  [IN  pwszRegistry]      --      The reg path to get the parent
//                                              for
//              [IN  SeInfo]            --      The security information to do
//                                              the read for
//              [OUT ppDAcl]            --      Where the DACL is returned
//              [OUT ppSAcl]            --      Where the SACL is returned
//              [OUT ppSD]              --      Where the Security Descriptor
//                                              is returned
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//
//----------------------------------------------------------------------------
DWORD
GetRegistryParentRights(IN  LPWSTR                    pwszRegistry,
                        IN  SECURITY_INFORMATION      SeInfo,
                        OUT PSECURITY_DESCRIPTOR     *ppSD)
{
    DWORD   dwErr = ERROR_SUCCESS;
    //
    // Basically, we'll figure out who our parent is, and get their info
    //
    PWSTR   pwszLastComp = wcsrchr(pwszRegistry, L'\\');
    if(pwszLastComp == NULL)
    {
        //
        // Ok, we must be at the root, so we won't have any inheritance
        //
        //
        // Return success after nulling out SD.
        //
        *ppSD = NULL;
    }
    else
    {
        //
        // We'll shorten our path, and then get the info
        //
        *pwszLastComp = L'\0';

        HANDLE  hReg;

        //
        // Don't want owner or group
        //
        SeInfo &= ~(OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION);
        dwErr = OpenRegistryObject(pwszRegistry,
                                   RegGetDesiredAccess(READ_ACCESS_RIGHTS,SeInfo),
                                   &hReg);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = ReadRegistrySecurityInfo(hReg,
                                             SeInfo,
                                             ppSD);
            RegCloseKey((HKEY)hReg);
        }

        *pwszLastComp = L'\\';

    }

    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetRegistrySecurityInfo
//
//  Synopsis:   Sets the specified security info on the specified registry
//              object
//
//  Arguments:  [IN  hService]          --      The handle of the object
//              [IN  SeInfo]            --      Flag indicating what security
//                                              info to set
//              [IN  pwszProperty]      --      The property on the object to
//                                              set
//                                              For kernel objects, this MBZ
//              [IN  pSD]               --      The security descriptor to set
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was given
//
//----------------------------------------------------------------------------
DWORD
SetRegistrySecurityInfo(IN  HANDLE                    hRegistry,
                        IN  SECURITY_INFORMATION      SeInfo,
                        IN  PWSTR                     pwszProperty,
                        IN  PSECURITY_DESCRIPTOR      pSD)
{
    acDebugOut((DEB_TRACE, "in SetNamedRegistrySecurityInfo\n"));

    DWORD dwErr;

    //
    // Registry keys don't have properties
    //
    if(pwszProperty != NULL)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        //
        // Marta only writes uplevel security descriptors.
        //
        // The caller of SetRegistrySecurityInfo will call with SE_xACL_AUTO_INHERITED off in those
        //  cases that it wants the underlying registry to do auto inheritance.
        // The caller of SetRegistrySecurityInfo will call with SE_xACL_AUTO_INHERITED on in those
        //  cases that it wants the underlying registry to simply store the bits.
        //
        // In the later case, the OS uses the SE_xACL_AUTO_INHERIT_REQ bit as a flag indicating
        // that it is OK to preserve SE_xACL_AUTO_INHERITED bit.
        //
        if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION)) {
            ((PISECURITY_DESCRIPTOR)pSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
        }

        if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION)) {
            ((PISECURITY_DESCRIPTOR)pSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
        }

        dwErr = RegSetKeySecurity((HKEY)hRegistry,
                                  SeInfo,
                                  pSD);

    }

    acDebugOut((DEB_TRACE, "Out SetRegistrySecurityInfo: %lu\n", dwErr));
    return(dwErr);
}




#define CLEANUP_ON_INTERRUPT(pstopflag)                                     \
if(*pstopflag != 0)                                                         \
{                                                                           \
    goto RegCleanup;                                                        \
}
//+---------------------------------------------------------------------------
//
//  Function:   SetAndPropagateRegistryPropertyRights
//
//  Synopsis:   Sets the access on the given registry path and propagates
//              it as necessary
//
//  Arguments:  [IN  pwszRegistry]      --      The path to set and propagate
//              [IN  pwszProperty]      --      The registry property to
//                                              operate upon
//              [IN  RootAccList]       --      The CAccessList class that has
//                                              the security descriptor/info
//              [IN  pfStopFlag]        --      Address of the stop flag
//                                              to be monitored
//              [IN  pcProcessed]       --      count of processed items to
//                                              be incremented.
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad paramter was given
//
//----------------------------------------------------------------------------
DWORD
SetAndPropagateRegistryPropertyRights(IN  PWSTR                 pwszRegistry,
                                      IN  PWSTR                 pwszProperty,
                                      IN  CAccessList&          RootAccList,
                                      IN  PULONG                pfStopFlag,
                                      IN  PULONG                pcProcessed)
{
    acDebugOut((DEB_TRACE, "in SetAndPropagateRegistryPropertyRights\n"));

    DWORD                   dwErr = ERROR_SUCCESS;

    //
    // First, get our security descriptor and sec info
    //
    HKEY                    hReg = NULL;
    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSECURITY_DESCRIPTOR    pParentSD = NULL;
    SECURITY_INFORMATION    SeInfo = 0;

    dwErr = RootAccList.BuildSDForAccessList(&pSD,
                                             &SeInfo,
                                             ACCLIST_SD_ABSOK);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Next, open the registry
        //
        dwErr = OpenRegistryObject(pwszRegistry,
                                   RegGetDesiredAccess(MODIFY_ACCESS_RIGHTS,
                                                    SeInfo)             |
                                        KEY_ENUMERATE_SUB_KEYS          |
                                        KEY_QUERY_VALUE,
                                   (PHANDLE)&hReg);
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Next, get our parent security descriptor
            //
            //
            // If we are only setting the owner or group, we don't need to get the parent
            //
            if (FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) ||
                FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) ) {

                dwErr = GetRegistryParentRights(pwszRegistry,
                                                SeInfo,
                                                &pParentSD);
            }

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Make the call
                //
                dwErr = SetAndPropRegRights(hReg,
                                            pwszRegistry,
                                            SeInfo,
                                            pParentSD,
                                            pSD,
                                            pfStopFlag,
                                            pcProcessed);
            }

        }

    }

    //
    // Clean up
    //
    if(hReg != NULL)
    {
        RegCloseKey(hReg);
    }

    AccFree(pParentSD);

    acDebugOut((DEB_TRACE,
               "Out SetAndPropagateRegistryPropertyRights: %ld\n", dwErr));
    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetAndPropagateRegistryPropertyRightsByHandle
//
//  Synopsis:   Same as above, but assumes the registry key has already
//              been opened
//
//  Arguments:  [IN  hReg]              --      The registry key to use
//              [IN  RootAccList]       --      The CAccessList class that has
//                                              the security descriptor/info
//              [IN  pfStopFlag]        --      Address of the stop flag
//                                              to be monitored
//              [IN  pcProcessed]       --      count of processed items to
//                                              be incremented.
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad paramter was given
//
//----------------------------------------------------------------------------
DWORD
SetAndPropagateRegistryPropertyRightsByHandle(IN  HKEY          hReg,
                                              IN  CAccessList&  RootAccList,
                                              IN  PULONG        pfStopFlag,
                                              IN  PULONG        pcProcessed)
{
    acDebugOut((DEB_TRACE, "in SetAndPropagateRegistryPropertyRightsByHandle\n"));

    DWORD                   dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR    pParentSD = NULL;
    HANDLE                  hObject = NULL;
    BOOL                    fUplevelAcl = TRUE;
    PWSTR                   pwszRegPath = NULL;

    //
    // First, get our security descriptor and sec info
    //
    PSECURITY_DESCRIPTOR    pSD = NULL;
    SECURITY_INFORMATION    SeInfo = 0;

    dwErr = RootAccList.BuildSDForAccessList(&pSD,
                                             &SeInfo,
                                             ACCLIST_SD_ABSOK);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // If we are only setting the owner or group, we don't need to get the parent
        //
        if (FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) ||
            FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) ) {

            dwErr = ConvertRegHandleToName(hReg,
                                           &pwszRegPath);
            if((dwErr != ERROR_SUCCESS) || (pwszRegPath == NULL))
            {
                if(dwErr == ERROR_INVALID_HANDLE)
                {
                    dwErr = ERROR_SUCCESS;
                }
            }
            else
            {
                dwErr = GetRegistryParentRights(pwszRegPath,
                                                SeInfo,
                                                &pParentSD);
            }
        }


        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Make the call
            //
            dwErr = SetAndPropRegRights(hReg,
                                        NULL,
                                        SeInfo,
                                        pParentSD,
                                        pSD,
                                        pfStopFlag,
                                        pcProcessed);

            if(dwErr == ERROR_ACCESS_DENIED)
            {
                //
                // See if we can reopen the path adding in readcontrol, and try it all again
                //
                if(pwszRegPath == NULL)
                {
                    dwErr = ConvertRegHandleToName(hReg,
                                                   &pwszRegPath);
                }

                if(pwszRegPath != NULL)
                {
                    dwErr = SetAndPropagateRegistryPropertyRights(pwszRegPath,
                                                                  NULL,
                                                                  RootAccList,
                                                                  pfStopFlag,
                                                                  pcProcessed);
                }

            }
        }
    }

    //
    // Clean up
    //
    AccFree(pwszRegPath);
    AccFree(pParentSD);

    acDebugOut((DEB_TRACE,
               "Out SetAndPropagateRegistryPropertyRightsByHandle: %ld\n", dwErr));
    return(dwErr);
}



//+---------------------------------------------------------------------------
//
//  Function:   PropagateRegRightsDeep, recursive
//
//  Synopsis:   Does a deep propagation of the access.  At the same time, it
//              will update NT4 acls to NT5 acls.  This function is only
//              called on downlevel registries, so the update will always
//              happen (where appropriate).  The algorithm is:
//                  - Read the current security descriptor from the object
//                  - If it's a downlevel acl, update it using the OLD
//                    parent security descriptor (to set any inheritied aces)
//                  - Update the security descriptor using the NEW parent
//                    security descriptor.
//                  - Repeat for its children.  (This is necessar, since there
//                    could have been unmarked inheritance off of the old
//                    security descriptor)
//
//  Arguments:  [IN  pOldParentSD]      --      The previous parent SD (before
//                                              the current parent SD was
//                                              stamped on the object)
//              [IN  pParentSD]         --      The current parent sd
//              [IN  SeInfo]            --      What is being written
//              [IN  hParent]           --      Opened parent registry key
//              [IN  pcProcessed]       --      Where the number processed is
//                                              returned.
//              [IN  pfStopFlag]        --      Stop flag to monitor
//              [IN  fProtectedFlag]    --      Determines whether the acls are already
//                                              protected
//              [IN  hProcessToken]     --      Handle to the process token
//              [IN  LogList]           --      List of keys to which propagation failed
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad paramter was given
//
//----------------------------------------------------------------------------
DWORD
PropagateRegRightsDeep(IN  PSECURITY_DESCRIPTOR    pOldParentSD,
                       IN  PSECURITY_DESCRIPTOR    pParentSD,
                       IN  SECURITY_INFORMATION    SeInfo,
                       IN  HKEY                    hParent,
                       IN  PULONG                  pcProcessed,
                       IN  PULONG                  pfStopFlag,
                       IN  ULONG                   fProtectedFlag,
                       IN  HANDLE                  hProcessToken,
                       IN OUT CSList&              LogList)
{
    acDebugOut((DEB_TRACE, "in  PropagteRegRightsDeep\n"));

    DWORD                   dwErr = ERROR_SUCCESS;
    SECURITY_DESCRIPTOR    *pChildSD = NULL;
    PSECURITY_DESCRIPTOR    pNewSD = NULL;
    BOOL                    fUpdateChild = FALSE;   // Write out the child?
    BOOL                    fAccFreeChild = TRUE;   // How to free the child

    //
    // Check to see if we've reached full protection saturation
    //
    if(fProtectedFlag == (SE_DACL_PROTECTED | SE_SACL_PROTECTED))
    {
        acDebugOut((DEB_TRACE_PROP, "Parent is fully or effectively protected\n"));
        return(ERROR_SUCCESS);
    }


    HKEY    hChild = NULL;

    ULONG    cSubKeys;
    dwErr = RegQueryInfoKey(hParent,
                            NULL,
                            NULL,
                            NULL,
                            &cSubKeys,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL);

    CLEANUP_ON_INTERRUPT(pfStopFlag);


    if(dwErr == ERROR_SUCCESS && cSubKeys != 0)
    {
        WCHAR   wszBuff[MAX_PATH + 1];

        ULONG       iIndex = 0;
        ULONG       cSize;
        FILETIME    WriteTime;
        while(dwErr == ERROR_SUCCESS)
        {
            cSize = MAX_PATH + 1;
            dwErr = RegEnumKeyEx(hParent,
                                 iIndex,
                                 wszBuff,
                                 &cSize,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &WriteTime);
            if(dwErr == ERROR_NO_MORE_ITEMS)
            {
                dwErr = ERROR_SUCCESS;
                break;
            }

            acDebugOut((DEB_TRACE_PROP,"Propagating to %ws\n", wszBuff));

            CLEANUP_ON_INTERRUPT(pfStopFlag);

            //
            // Now, determine if we need to propagate or not...
            //
            if(dwErr == ERROR_SUCCESS)
            {
                ULONG                   cSDLen = 0;
                BOOL                    fWriteSD = FALSE;

                dwErr = RegOpenKeyEx(hParent,
                                     wszBuff,
                                     0,
                                     RegGetDesiredAccess(MODIFY_ACCESS_RIGHTS,
                                                      SeInfo)           |
                                     KEY_ENUMERATE_SUB_KEYS             |
                                     KEY_QUERY_VALUE,
                                     &hChild);

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Get our number of children
                    //
                    dwErr = RegQueryInfoKey(hChild,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &cSubKeys,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL);

                    if ( dwErr == ERROR_INSUFFICIENT_BUFFER ) {

                        acDebugOut((DEB_ERROR,"RegQueryInfoKey failure on %ws\n", wszBuff));
                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        CLEANUP_ON_INTERRUPT(pfStopFlag);

                        //
                        // Read the current security descriptor
                        //
                        dwErr = ReadRegistrySecurityInfo(hChild,
                                                         SeInfo,
                                                         (PSECURITY_DESCRIPTOR *)&pChildSD);

                        CLEANUP_ON_INTERRUPT(pfStopFlag);

                        if(dwErr == ERROR_SUCCESS &&
                           !(FLAG_ON(pChildSD->Control,
                                     SE_DACL_AUTO_INHERITED |
                                     SE_SACL_AUTO_INHERITED)))
                        {
                            //
                            // Before we convert this, we may need to reread the SD... if
                            // we don't have owner and group
                            //
                            if(!FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION)  ||
                               !FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                            {
                                AccFree(pChildSD);
                                pChildSD = NULL;
                                dwErr = ReadRegistrySecurityInfo(
                                                    hChild,
                                                    SeInfo                          |
                                                        OWNER_SECURITY_INFORMATION  |
                                                        GROUP_SECURITY_INFORMATION,
                                                    (PSECURITY_DESCRIPTOR *)&pChildSD);
                                if(dwErr == ERROR_ACCESS_DENIED)
                                {
                                    RegCloseKey(hChild);
                                    dwErr = RegOpenKeyEx(hParent,
                                                         wszBuff,
                                                         0,
                                                         RegGetDesiredAccess(MODIFY_ACCESS_RIGHTS,
                                                              SeInfo    |
                                                              OWNER_SECURITY_INFORMATION |
                                                              GROUP_SECURITY_INFORMATION)   |
                                                         KEY_ENUMERATE_SUB_KEYS             |
                                                         KEY_QUERY_VALUE,
                                                         &hChild);
                                    if(dwErr == ERROR_SUCCESS)
                                    {
                                        dwErr = ReadRegistrySecurityInfo(
                                                            hChild,
                                                            SeInfo                          |
                                                                OWNER_SECURITY_INFORMATION  |
                                                                GROUP_SECURITY_INFORMATION,
                                                            (PSECURITY_DESCRIPTOR *)&pChildSD);
                                    }
                                }
                            }

                            if(dwErr == ERROR_SUCCESS)
                            {
                                dwErr = ConvertToAutoInheritSD(pOldParentSD,
                                                               pChildSD,
                                                               TRUE,
                                                               &gRegGenMapping,
                                                               &pNewSD);
                                AccFree(pChildSD);

                                if(dwErr == ERROR_SUCCESS)
                                {
                                    pChildSD = (SECURITY_DESCRIPTOR *)pNewSD;
                                    fAccFreeChild = FALSE;
                                    pNewSD = NULL;
                                }
                            }
                        }


                        //
                        // Now, compute the new security descriptor
                        if(dwErr == ERROR_SUCCESS)
                        {
                            DebugDumpSD("CPOS ParentSD", pParentSD);
                            DebugDumpSD("CPOS CreatorSD",  pChildSD);

                            if(CreatePrivateObjectSecurityEx(pParentSD,
                                                             pChildSD,
                                                             &pNewSD,
                                                             NULL,
                                                             TRUE,
                                                             SEF_DACL_AUTO_INHERIT      |
                                                                 SEF_SACL_AUTO_INHERIT  |
                                                                 SEF_AVOID_OWNER_CHECK  |
                                                                 SEF_AVOID_PRIVILEGE_CHECK,
                                                             hProcessToken,
                                                             &gRegGenMapping) == FALSE)
                            {
                                dwErr = GetLastError();
                            }
                        }
#ifdef DBG
                        else
                        {
                            DebugDumpSD("CPOS NewChild", pNewSD);
                        }
#endif

                        if(dwErr == ERROR_SUCCESS)
                        {
                            //
                            // If the resultant child is protected, don't bother propagating
                            // down.
                            //
                            if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                            {
                                if(DACL_PROTECTED(pNewSD))
                                {
                                    fProtectedFlag |= SE_DACL_PROTECTED;
                                }
                            }

                            if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                            {
                                if(SACL_PROTECTED(pNewSD))
                                {
                                    fProtectedFlag |= SE_SACL_PROTECTED;
                                }
                            }

                            if(FLAG_ON( fProtectedFlag, (SE_DACL_PROTECTED | SE_SACL_PROTECTED)))
                            {
                                cSubKeys = 0;
                                dwErr = InsertPropagationFailureEntry(LogList,
                                                                      0,
                                                                      fProtectedFlag,
                                                                      wszBuff);
                            }

                            //
                            // If we haven't changed the acl, security descriptor, then
                            // we can also quit
                            //
                            if(EqualSecurityDescriptors(pNewSD, pChildSD))
                            {
                                cSubKeys = 0;
                            }
                        }


                    }

                    //
                    // Now, if it's a directory, call ourselves
                    //
                    if(dwErr == ERROR_SUCCESS && cSubKeys != 0)
                    {
                        dwErr = PropagateRegRightsDeep(pChildSD,
                                                       pNewSD,
                                                       SeInfo,
                                                       hChild,
                                                       pcProcessed,
                                                       pfStopFlag,
                                                       fProtectedFlag,
                                                       hProcessToken,
                                                       LogList);

                        if(dwErr == ERROR_ACCESS_DENIED)
                        {
                            dwErr = InsertPropagationFailureEntry(LogList,
                                                                  dwErr,
                                                                  0,
                                                                  wszBuff);
                        }
                    }

                    //
                    // Free the old child, since we won't need it anymore
                    //
                    if(fAccFreeChild == TRUE)
                    {
                        AccFree(pChildSD);
                    }
                    else
                    {
                        DestroyPrivateObjectSecurity((PSECURITY_DESCRIPTOR *)
                                                                   &pChildSD);
                    }
                    pChildSD = NULL;

                }
            }

            acDebugOut((DEB_TRACE_PROP,
                        "Processed %ws: %lu\n",
                        wszBuff,
                        dwErr));

            //
            // Finally, set the new security
            //
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Now, we'll simply stamp it on the object
                //

                dwErr = SetRegistrySecurityInfo(hChild,
                                                SeInfo,
                                                NULL,
                                                pNewSD);
                (*pcProcessed)++;

            }


            DestroyPrivateObjectSecurity(&pNewSD);
            pNewSD = NULL;

            CLEANUP_ON_INTERRUPT(pfStopFlag);
            iIndex++;
        }
    }

    if(dwErr == ERROR_NO_MORE_FILES)
    {
        dwErr = ERROR_SUCCESS;
    }

RegCleanup:
    if(hChild != NULL)
    {
        RegCloseKey(hChild);
    }

    if(pNewSD != NULL)
    {
        DestroyPrivateObjectSecurity(&pNewSD);
    }

    acDebugOut((DEB_TRACE,
               "Out PropagteRegRightsDeep: %ld\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   SetAndPropRegRights
//
//  Synopsis:   Sets the access on the given registry path and propagates
//              it as necessary
//
//  Arguments:  [IN  hReg]              --      Handle to the reg. object to set
//              [IN  pwszPath]          --      Registry path referred to by hReg,
//                                              if known
//              [IN  SeInfo]            --      Security information to set
//              [IN  pParentSD]         --      Security descriptor of the parent
//              [IN  pSD]               --      SD to set
//              [IN  pfStopFlag]        --      Address of the stop flag
//                                              to be monitored
//              [IN  pcProcessed]       --      count of processed items to
//                                              be incremented.
//
//  Returns:    ERROR_SUCCESS           --      Success
//
//----------------------------------------------------------------------------
DWORD
SetAndPropRegRights(IN  HKEY                    hReg,
                    IN  PWSTR                   pwszPath,
                    IN  SECURITY_INFORMATION    SeInfo,
                    IN  PSECURITY_DESCRIPTOR    pParentSD,
                    IN  PSECURITY_DESCRIPTOR    pSD,
                    IN  PULONG                  pfStopFlag,
                    IN  PULONG                  pcProcessed)
{
    acDebugOut((DEB_TRACE, "in SetAndPropRegRights\n"));

    DWORD                   dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR    pOldObjSD = NULL;
    PSECURITY_DESCRIPTOR    pUpdatedSD = NULL;
    PSECURITY_DESCRIPTOR    pVerifySD = NULL;
    BOOL                    fManualProp = FALSE;
    ULONG                   fProtected = 0;
    ULONG                   cSubKeys;
    HANDLE                  hProcessToken = NULL;
    PSID                    pOwner = NULL, pGroup = NULL;

    CSList                  FailureLogList(FreePropagationFailureListEntry);



    //
    // Ok, read the existing security
    //
    dwErr = ReadRegistrySecurityInfo(hReg,
                                     SeInfo,
                                     &pOldObjSD);

    //
    // Now, we'll write out the current, and then read it back and make sure
    // that it's properly updated
    //
    if(dwErr == ERROR_SUCCESS &&
        FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION) )
    {
        CLEANUP_ON_INTERRUPT(pfStopFlag);
        dwErr = SetRegistrySecurityInfo(hReg,
                                        SeInfo,
                                        NULL,
                                        pSD);
        if(dwErr == ERROR_SUCCESS)
        {
            (*pcProcessed)++;
            CLEANUP_ON_INTERRUPT(pfStopFlag);

            dwErr = ReadRegistrySecurityInfo(hReg,
                                             SeInfo,
                                             &pVerifySD);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Check to see if this was done uplevel...
                //
                PISECURITY_DESCRIPTOR pISD = (PISECURITY_DESCRIPTOR)pVerifySD;
                if(!(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) &&
                    FLAG_ON(pISD->Control, SE_DACL_AUTO_INHERITED)) &&
                   !(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) &&
                    FLAG_ON(pISD->Control, SE_SACL_AUTO_INHERITED)))
                {
                    //
                    // It's not uplevel, so we'll turn the AutoInherit
                    // flags on, rewrite it, and do our own propagation,
                    // only if this is a container and we're setting the
                    // dacl or sacl
                    //
                    if(FLAG_ON(SeInfo,
                               (DACL_SECURITY_INFORMATION |
                                            SACL_SECURITY_INFORMATION)))
                    {
                        fManualProp = TRUE;
                    }

                    if(FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
                    {
                        pISD->Control |= SE_DACL_AUTO_INHERITED;
                    }

                    if(FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
                    {
                        pISD->Control |= SE_SACL_AUTO_INHERITED;
                    }

                    //
                    // Go ahead and upgrade it to autoinherit
                    //
                    if(!FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION)  ||
                       !FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                    {
                        //
                        // Need to reread it to get the owner and group
                        //
                        AccFree(pVerifySD);
                        dwErr = ReadRegistrySecurityInfo(hReg,
                                                         SeInfo |
                                                            OWNER_SECURITY_INFORMATION |
                                                            GROUP_SECURITY_INFORMATION,
                                                         &pVerifySD);
                        //
                        // If we failed to read it because we didn't originally have permissions
                        // and we have the path, we'll try to reopen the handle with the
                        // proper rights
                        //
                        if(dwErr == ERROR_ACCESS_DENIED && pwszPath != NULL)
                        {
                            HKEY    hReg2;

                            dwErr = OpenRegistryObject(pwszPath,
                                                       RegGetDesiredAccess(READ_ACCESS_RIGHTS,
                                                            SeInfo |
                                                                OWNER_SECURITY_INFORMATION |
                                                                GROUP_SECURITY_INFORMATION),
                                                       (PHANDLE)&hReg2);

                            if(dwErr == ERROR_SUCCESS)
                            {
                                dwErr = ReadRegistrySecurityInfo(hReg2,
                                                         SeInfo |
                                                            OWNER_SECURITY_INFORMATION |
                                                            GROUP_SECURITY_INFORMATION,
                                                         &pVerifySD);
                                RegCloseKey(hReg2);
                            }

                        }


                        //
                        // Set our owner/group in the old security descriptor
                        //
                        if(dwErr == ERROR_SUCCESS)
                        {
                            BOOL    fDefaulted;

                            if(!FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
                            {
                                if(!GetSecurityDescriptorOwner(pVerifySD, &pOwner, &fDefaulted))
                                {
                                    dwErr = GetLastError();
                                }
                            }

                            if(!FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
                            {
                                if(!GetSecurityDescriptorGroup(pVerifySD, &pGroup, &fDefaulted))
                                {
                                    dwErr = GetLastError();
                                }
                            }

                            if(dwErr == ERROR_SUCCESS)
                            {
                                //
                                // If it's self relative, we'll have to make it absolute.
                                //
                                if(FLAG_ON(((SECURITY_DESCRIPTOR *)pSD)->Control,
                                            SE_SELF_RELATIVE))
                                {
                                    PSECURITY_DESCRIPTOR pSD2;
                                    dwErr = MakeSDAbsolute(pSD,
                                                           SeInfo,
                                                           &pSD2,
                                                           pOwner,
                                                           pGroup);
                                    if(dwErr == ERROR_SUCCESS)
                                    {
                                        AccFree(pSD);
                                        pSD = pSD2;
                                    }
                                }
                                else
                                {
                                    if(pOwner != NULL)
                                    {
                                        if(SetSecurityDescriptorOwner(pOldObjSD,
                                                                      pOwner,
                                                                      FALSE) == FALSE)
                                        {
                                            dwErr = GetLastError();
                                        }
                                    }

                                    if(pGroup != NULL)
                                    {
                                        if(SetSecurityDescriptorGroup(pOldObjSD,
                                                                      pGroup,
                                                                      FALSE) == FALSE)
                                        {
                                            dwErr = GetLastError();
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if(dwErr == ERROR_SUCCESS)
                    {
                        dwErr = GetCurrentToken( &hProcessToken );
                    }


                    if(dwErr == ERROR_SUCCESS)
                    {
                        dwErr = ConvertToAutoInheritSD(pParentSD,
                                                       pOldObjSD,
                                                       TRUE,
                                                       &gRegGenMapping,
                                                       &pUpdatedSD);
                        if(dwErr == ERROR_SUCCESS)
                        {
                            //
                            // Now, if we're going to do manual propagation,
                            // we'll write out the old SD until we get everyone
                            // else updated
                            //
                            PSECURITY_DESCRIPTOR    pWriteSD = pUpdatedSD;
                            if(fManualProp == TRUE)
                            {
                                pWriteSD = pOldObjSD;
                            }
                            else
                            {
                                if(SetPrivateObjectSecurity(SeInfo,
                                                            pParentSD,
                                                            &pUpdatedSD,
                                                            &gRegGenMapping,
                                                            hProcessToken) == FALSE)
                                {
                                    dwErr = GetLastError();
                                }
                            }

                            //
                            // Reset it...
                            //
                            if(dwErr == ERROR_SUCCESS)
                            {
                                dwErr = SetRegistrySecurityInfo(hReg,
                                                                SeInfo,
                                                                NULL,
                                                                pWriteSD);
                            }
                        }
                    }
                    else
                    {
                        pVerifySD = NULL;
                    }



                }

            }

        }
    }
    else
    {
        if(dwErr == ERROR_SUCCESS &&
           FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION))
        {

            dwErr = SetRegistrySecurityInfo(hReg,
                                            SeInfo,
                                            NULL,
                                            pSD);
        }
    }

    //
    // Ok, now if we're doing propagation, we'll get busy and do that...
    //
    if(dwErr == ERROR_SUCCESS && fManualProp == TRUE)
    {
        //
        // Set our protected flags.  If we aren't messing with a particular acl, we'll
        // pretend it's protected
        //

        fProtected = ((SECURITY_DESCRIPTOR *)pUpdatedSD)->Control &
                                                ~(SE_DACL_PROTECTED | SE_SACL_PROTECTED);
        if(FLAG_ON(fProtected, SE_DACL_PROTECTED ) || FLAG_ON(fProtected, SE_SACL_PROTECTED ))
        {
            dwErr = InsertPropagationFailureEntry(FailureLogList,
                                                  0,
                                                  fProtected,
                                                  pwszPath == NULL ?
                                                        L"<Unkown Registry Root>" :
                                                        pwszPath);
        }

        if(!FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION))
        {
            fProtected |= SE_DACL_PROTECTED;
        }

        if(!FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION))
        {
            fProtected |= SE_SACL_PROTECTED;
        }

        //
        // Ok, go ahead and do deep.  This will possibly save us
        // some storage space in the long run...
        //
        dwErr = PropagateRegRightsDeep(pOldObjSD,
                                       pUpdatedSD,
                                       SeInfo,
                                       hReg,
                                       pcProcessed,
                                       pfStopFlag,
                                       fProtected,
                                       hProcessToken,
                                       FailureLogList);
        if(dwErr == ERROR_ACCESS_DENIED)
        {
            dwErr = InsertPropagationFailureEntry(FailureLogList,
                                                  dwErr,
                                                  0,
                                                  pwszPath == NULL ?
                                                        L"<Unkown Registry Root>" :
                                                        pwszPath);
        }


        //
        // If that worked, write out our updated root security descriptor
        //
        if(dwErr == ERROR_SUCCESS)
        {
            PSECURITY_DESCRIPTOR    pSet;

            if(!FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION))
            {
                if(!SetSecurityDescriptorOwner(pSD, pOwner, FALSE))
                {
                    dwErr = GetLastError();
                }
            }

            if(!FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION))
            {
                if(!SetSecurityDescriptorGroup(pSD, pGroup, FALSE))
                {
                    dwErr = GetLastError();
                }
            }

            if(dwErr == ERROR_SUCCESS)
            {
                if(CreatePrivateObjectSecurityEx(pParentSD,
                                                 pSD,
                                                 &pSet,
                                                 NULL,
                                                 TRUE,
                                                 SEF_DACL_AUTO_INHERIT      |
                                                     SEF_SACL_AUTO_INHERIT  |
                                                     SEF_AVOID_OWNER_CHECK  |
                                                     SEF_AVOID_PRIVILEGE_CHECK,
                                                 hProcessToken,
                                                 &gRegGenMapping) == FALSE)
                {
                    dwErr = GetLastError();
                }
                else
                {
                    dwErr = SetRegistrySecurityInfo(hReg,
                                                    SeInfo,
                                                    NULL,
                                                    pSet);
                    DestroyPrivateObjectSecurity(&pSet);
                }
            }
        }
    }


    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = WritePropagationFailureList(MARTAEVT_REGISTRY_PROPAGATION_FAILED,
                                            FailureLogList,
                                            hProcessToken);
    }

RegCleanup:
    AccFree(pOldObjSD);
    AccFree(pVerifySD);

    if(pUpdatedSD != NULL)
    {
        DestroyPrivateObjectSecurity(&pUpdatedSD);
    }

    acDebugOut((DEB_TRACE, "Out SetAndPropRegRights: %ld\n", dwErr));
    return(dwErr);
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertRegHandleToName
//
//  Synopsis:   Determines the registry path for a handle.  Issues an
//              NtQueryInformationFile to determine the path name
//
//  Arguments:  [IN  hKey]              --      The (open) handle of the file
//                                              object
//              [OUT ppwszName]         --      Where the name is returned
//
//  Returns:    ERROR_SUCCESS           --      Succcess
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//  Notes:      The returned memory must be freed with AccFree
//
//----------------------------------------------------------------------------
DWORD
ConvertRegHandleToName(IN  HKEY       hKey,
                       OUT PWSTR      *ppwszName)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // First, determine the size of the buffer we need...
    //
    BYTE        pBuff[512];
    ULONG       cLen = 0;
    POBJECT_NAME_INFORMATION pNI = NULL;
    PWSTR       pwszPath = NULL;
    NTSTATUS    Status = NtQueryObject(hKey,
                                       ObjectNameInformation,
                                       (POBJECT_NAME_INFORMATION)pBuff,
                                       512,
                                       &cLen);
    if(!NT_SUCCESS(Status))
    {
        if(Status == STATUS_BUFFER_TOO_SMALL ||
            Status == STATUS_INFO_LENGTH_MISMATCH)
        {
            //
            // Fine.. Allocate a big enough buffer
            //
            pNI = (POBJECT_NAME_INFORMATION)AccAlloc(cLen);
            if(pNI != NULL)
            {
                Status = NtQueryObject(hKey,
                                       ObjectNameInformation,
                                       pNI,
                                       cLen,
                                       NULL);
                if(NT_SUCCESS(Status))
                {
                    pwszPath = pNI->Name.Buffer;
                }
                AccFree(pNI);
            }
            else
            {
                Status = STATUS_NO_MEMORY;
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = RtlNtStatusToDosError(Status);
        }

    }
    else
    {
        pwszPath = ((POBJECT_NAME_INFORMATION)pBuff)->Name.Buffer;
    }

    //
    // If we have a path, then it's a simple matter to pull out the appropriate string,
    // since what gets returned is something in the form of \\REGISTRY\\MACHINE\\somepath
    // which is pretty close to what we want
    //
    #define REG_OBJ_TAG L"\\REGISTRY\\"

    if(pwszPath != NULL)
    {
        pwszPath += (sizeof(REG_OBJ_TAG) / sizeof(WCHAR) - 1);
        ACC_ALLOC_AND_COPY_STRINGW(pwszPath,
                                   *ppwszName,
                                   dwErr);

    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\seia.cxx ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  Microsoft Windows                                                         //
//  Copyright (C) Microsoft Corporation, 1999.                                //
//                                                                            //
//  File:    seia.cxx                                                         //
//                                                                            //
//  Contents:    New marta rewrite functions for SetEntriesInAcl              //
//                                                                            //
//  History:    4/99    KedarD     Created                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <aclpch.hxx>
#pragma hdrstop

extern "C"
{
    #include <stdio.h>
    #include <permit.h>
    #include <dsgetdc.h>
    #include <lmapibuf.h>
    #include <wmistr.h>
    #include <ntprov.hxx>
    #include <strings.h>
    #include <seopaque.h>
    #include <sertlp.h>
    #include <accctrl.h>
    #include <guidtables.h>
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// MACRO DEFINITIONS START HERE                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define MARTA_SID_FOR_NAME                                                     \
        {                                                                      \
           ((PKNOWN_ACE) *ppAcl)->Mask = pAccessInfo->Mask;                    \
           AceSize = RtlLengthSid(pAccessInfo->pSid);                          \
           memcpy(                                                             \
               ((PUCHAR) *ppAcl) + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK),   \
               (PUCHAR) pAccessInfo->pSid,                                     \
               AceSize                                                         \
               );                                                              \
           AceSize += sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);                \
        }

#define MARTA_SID_FOR_SID                                                      \
        {                                                                      \
           ((PKNOWN_ACE) *ppAcl)->Mask = pAccessInfo->Mask;                    \
           AceSize = RtlLengthSid((PSID) pExplicitAccess->Trustee.ptstrName);  \
           memcpy(                                                             \
               ((PUCHAR) *ppAcl) + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK),   \
               (PUCHAR) pExplicitAccess->Trustee.ptstrName,                    \
               AceSize                                                         \
               );                                                              \
           AceSize += sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);                \
        }

#define MARTA_SID_AND_GUID_FOR_OBJECT_NAME                                     \
        {                                                                      \
           pObjName = (POBJECTS_AND_NAME_W) pExplicitAccess->Trustee.ptstrName;\
           ((PKNOWN_OBJECT_ACE) *ppAcl)->Flags = pObjName->ObjectsPresent;     \
           ((PKNOWN_OBJECT_ACE) *ppAcl)->Mask = pAccessInfo->Mask;             \
           AceSize = RtlLengthSid(pAccessInfo->pSid);                          \
           memcpy(                                                             \
               (PUCHAR) RtlObjectAceSid(*ppAcl),                               \
               (PUCHAR) pAccessInfo->pSid,                                     \
               AceSize                                                         \
               );                                                              \
           pGuid = RtlObjectAceObjectType(*ppAcl);                             \
           if (NULL != pGuid)                                                  \
           {                                                                   \
               memcpy(                                                         \
                   (PUCHAR) pGuid,                                             \
                   (PUCHAR) pAccessInfo->pObjectTypeGuid,                      \
                   sizeof(GUID)                                                \
                   );                                                          \
               AceSize += sizeof(GUID);                                        \
           }                                                                   \
           pGuid = RtlObjectAceInheritedObjectType(*ppAcl);                    \
           if (NULL != pGuid)                                                  \
           {                                                                   \
               memcpy(                                                         \
                   (PUCHAR) pGuid,                                             \
                   (PUCHAR) pAccessInfo->pInheritedObjectTypeGuid,             \
                   sizeof(GUID)                                                \
                   );                                                          \
               AceSize += sizeof(GUID);                                        \
           }                                                                   \
           AceSize += sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + sizeof(ULONG);\
        }

#define MARTA_SID_AND_GUID_FOR_OBJECT_SID                                      \
        {                                                                      \
           pObjSid = (POBJECTS_AND_SID) pExplicitAccess->Trustee.ptstrName;    \
           ((PKNOWN_OBJECT_ACE) *ppAcl)->Flags = pObjSid->ObjectsPresent;      \
           ((PKNOWN_OBJECT_ACE) *ppAcl)->Mask = pAccessInfo->Mask;             \
           AceSize = RtlLengthSid(pObjSid->pSid);                              \
           memcpy(                                                             \
               (PUCHAR) RtlObjectAceSid(*ppAcl),                               \
               (PUCHAR) pObjSid->pSid,                                         \
               AceSize                                                         \
               );                                                              \
           pGuid = RtlObjectAceObjectType(*ppAcl);                             \
           if (NULL != pGuid)                                                  \
           {                                                                   \
               memcpy(                                                         \
                   (PUCHAR) pGuid,                                             \
                   (PUCHAR) &(pObjSid->ObjectTypeGuid),                        \
                   sizeof(GUID)                                                \
                   );                                                          \
               AceSize += sizeof(GUID);                                        \
           }                                                                   \
           pGuid = RtlObjectAceInheritedObjectType(*ppAcl);                    \
           if (NULL != pGuid)                                                  \
           {                                                                   \
               memcpy(                                                         \
                   (PUCHAR) pGuid,                                             \
                   (PUCHAR) &(pObjSid->InheritedObjectTypeGuid),               \
                   sizeof(GUID)                                                \
                   );                                                          \
               AceSize += sizeof(GUID);                                        \
           }                                                                   \
           AceSize += sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + sizeof(ULONG);\
        }

typedef struct _MARTA_ACCESS_INFO
{
    ACCESS_MASK   Mask;
    ULONG         Size;
    PSID          pSid;
    PSID          pServerSid;
    GUID        * pObjectTypeGuid;
    GUID        * pInheritedObjectTypeGuid;
} MARTA_ACCESS_INFO, *PMARTA_ACCESS_INFO;

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// FUNCTION PROTOTYPES START HERE                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
AccRewriteSetEntriesInAcl(
    IN  ULONG                cCountOfExplicitEntries,
    IN  PEXPLICIT_ACCESS_W   pListOfExplicitEntries,
    IN  PACL                 OldAcl,
    OUT PACL               * pNewAcl
    );

BOOL
MartaIsExplicitAclCanonical(
    IN  PACL   pAcl,
    OUT PULONG pExplicitAceCnt
    );

DWORD
MartaTrusteeSidAndGuidSize(
    IN  PTRUSTEE_W  pTrustee,
    IN  BOOL        bComputeGuidSize,
    OUT PSID      * ppSid,
    OUT PULONG      pSize,
    OUT PULONG      pGuidCnt          OPTIONAL
    );

DWORD
MartaAddExplicitEntryToAcl(
    IN OUT PUCHAR             * ppAcl,
    IN     PEXPLICIT_ACCESS_W   pExplicitAccess,
    IN     PMARTA_ACCESS_INFO   pAccessInfo
    );

DWORD
MartaGetSidFromName(
    IN  LPWSTR   pName,
    OUT PSID   * ppSid
    );

DWORD
MartaGetGuid(
    IN  LPWSTR           pObjectName,
    IN  SE_OBJECT_TYPE   ObjectType,
    OUT GUID           * pGuid
    );

DWORD
MartaGetExplicitAccessEntrySize(
    IN  PEXPLICIT_ACCESS_W pExplicitAccess,
    OUT PMARTA_ACCESS_INFO pAccessInfo,
    OUT PULONG             pGuidCnt,
    OUT PUCHAR             pAclRevision
    );

DWORD
MartaCompareAcesAndMarkMasks(
    IN PUCHAR             pAce,
    IN PACCESS_MASK       pAceMask,
    IN PEXPLICIT_ACCESS_W pExplicitAccess,
    IN PMARTA_ACCESS_INFO pAccessInfo,
    IN BOOL               bCanonical
    );

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaAddExplicitEntryToAcl                                       //
//                                                                            //
// Description: Convert an explicit entry into an ace and store it in the     //
//              acl. Update the acl pointer to the end.                       //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN OUT ppAcl]        Acl pointer where the ace should be stored       //
//                                                                            //
//     [IN pExplicitAccess]  Explicit entry to convert into an ace            //
//     [IN pAccessInfo]      Temp info associated with the explicit entry     //
//                                                                            //
// Returns: ERROR_SUCCESS if the entry could be converted into an ACE         //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaAddExplicitEntryToAcl(
    IN OUT PUCHAR             * ppAcl,
    IN     PEXPLICIT_ACCESS_W   pExplicitAccess,
    IN     PMARTA_ACCESS_INFO   pAccessInfo
    )
{
    DWORD                 dwErr      = ERROR_SUCCESS;
    ULONG                 AceSize    = 0;
    ULONG                 SidSize    = 0;
    UCHAR                 AceType    = 0;
    UCHAR                 AceFlags   = 0;
    PSID                  pSid       = NULL;
    GUID                * pGuid      = NULL;
    POBJECTS_AND_SID      pObjSid    = NULL;
    POBJECTS_AND_NAME_W   pObjName   = NULL;

    if (REVOKE_ACCESS == pExplicitAccess->grfAccessMode)
    {
        return ERROR_SUCCESS;
    }

    if (FLAG_ON(pExplicitAccess->grfInheritance, INHERITED_ACE))
    {
        return ERROR_SUCCESS;
    }

    if (0 == pAccessInfo->Size)
    {
        return ERROR_SUCCESS;
    }

    if (TRUSTEE_IS_IMPERSONATE == pExplicitAccess->Trustee.MultipleTrusteeOperation)
    {
        ((PKNOWN_COMPOUND_ACE) *ppAcl)->CompoundAceType = COMPOUND_ACE_IMPERSONATION;
        ((PKNOWN_COMPOUND_ACE) *ppAcl)->Mask = pAccessInfo->Mask;
        ((PKNOWN_COMPOUND_ACE) *ppAcl)->Reserved        = 0;

        AceSize = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + sizeof(LONG);

        pSid = pAccessInfo->pServerSid     ?
                   pAccessInfo->pServerSid :
                   (PSID) pExplicitAccess->Trustee.ptstrName;

        SidSize = RtlLengthSid(pSid);

        memcpy(
            ((PUCHAR) *ppAcl) + AceSize,
            (PUCHAR) pSid,
            SidSize
            );

        AceSize += SidSize;

        pSid = pAccessInfo->pSid     ?
                   pAccessInfo->pSid :
                   (PSID) (pExplicitAccess->Trustee.pMultipleTrustee->ptstrName);

        SidSize = RtlLengthSid(pSid);

        memcpy(
            ((PUCHAR) *ppAcl) + AceSize,
            (PUCHAR) pSid,
            SidSize
            );

        AceSize += SidSize;

        CONDITIONAL_ACE_SIZE_ERROR(AceSize);

        ((PACE_HEADER) *ppAcl)->AceType  = ACCESS_ALLOWED_COMPOUND_ACE_TYPE;
        ((PACE_HEADER) *ppAcl)->AceFlags = (UCHAR) pExplicitAccess->grfInheritance;
        ((PACE_HEADER) *ppAcl)->AceSize  = (USHORT) AceSize;
        *ppAcl  += AceSize;

        return ERROR_SUCCESS;
    }

    switch (pExplicitAccess->grfAccessMode)
    {
    case GRANT_ACCESS:
    case SET_ACCESS:
        AceFlags = (UCHAR) pExplicitAccess->grfInheritance;
        switch (pExplicitAccess->Trustee.TrusteeForm)
        {
        case TRUSTEE_IS_NAME:
            AceType = ACCESS_ALLOWED_ACE_TYPE;
            MARTA_SID_FOR_NAME
            break;
        case TRUSTEE_IS_SID:
            AceType = ACCESS_ALLOWED_ACE_TYPE;
            MARTA_SID_FOR_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_SID:
            AceType  = ACCESS_ALLOWED_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_NAME:
            AceType  = ACCESS_ALLOWED_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_NAME
            break;
        default:
            break;
        }
        break;
    case DENY_ACCESS:
        AceFlags = (UCHAR) pExplicitAccess->grfInheritance;
        switch (pExplicitAccess->Trustee.TrusteeForm)
        {
        case TRUSTEE_IS_NAME:
            AceType = ACCESS_DENIED_ACE_TYPE;
            MARTA_SID_FOR_NAME
            break;
        case TRUSTEE_IS_SID:
            AceType = ACCESS_DENIED_ACE_TYPE;
            MARTA_SID_FOR_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_SID:
            AceType = ACCESS_DENIED_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_NAME:
            AceType = ACCESS_DENIED_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_NAME
            break;
        default:
            break;
        }
        break;
    case SET_AUDIT_SUCCESS:
        AceFlags = (UCHAR) (pExplicitAccess->grfInheritance | SUCCESSFUL_ACCESS_ACE_FLAG);
        switch (pExplicitAccess->Trustee.TrusteeForm)
        {
        case TRUSTEE_IS_NAME:
            AceType = SYSTEM_AUDIT_ACE_TYPE;
            MARTA_SID_FOR_NAME
            break;
        case TRUSTEE_IS_SID:
            AceType = SYSTEM_AUDIT_ACE_TYPE;
            MARTA_SID_FOR_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_SID:
            AceType = SYSTEM_AUDIT_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_NAME:
            AceType = SYSTEM_AUDIT_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_NAME
            break;
        default:
            break;
        }
        break;
    case SET_AUDIT_FAILURE:
        AceFlags = (UCHAR) (pExplicitAccess->grfInheritance | FAILED_ACCESS_ACE_FLAG);
        switch (pExplicitAccess->Trustee.TrusteeForm)
        {
        case TRUSTEE_IS_NAME:
            AceType = SYSTEM_AUDIT_ACE_TYPE;
            MARTA_SID_FOR_NAME
            break;
        case TRUSTEE_IS_SID:
            AceType = SYSTEM_AUDIT_ACE_TYPE;
            MARTA_SID_FOR_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_SID:
            AceType = SYSTEM_AUDIT_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_SID
            break;
        case TRUSTEE_IS_OBJECTS_AND_NAME:
            AceType = SYSTEM_AUDIT_OBJECT_ACE_TYPE;
            MARTA_SID_AND_GUID_FOR_OBJECT_NAME
            break;
        default:
            break;
        }
        break;
    case REVOKE_ACCESS:
        return ERROR_SUCCESS;
    default:
        return ERROR_SUCCESS;
    }

    CONDITIONAL_ACE_SIZE_ERROR(AceSize);

    ((PACE_HEADER) *ppAcl)->AceType  = AceType;
    ((PACE_HEADER) *ppAcl)->AceFlags = AceFlags;
    ((PACE_HEADER) *ppAcl)->AceSize  = (USHORT) AceSize;

    *ppAcl += AceSize;

    return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaCompareAcesAndMarkMasks                                     //
//                                                                            //
// Description: Check if the explicit entry is supposed to make any changes   //
//              to the ace. If so, store the change into the temp structure   //
//              assoiciated with the ace.                                     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN pAce]             Ace to compare with the explict entry            //
//     [IN pAceMask]         Temp info associated with the ace                //
//     [IN pExplicitAccess]  Explicit entry                                   //
//     [IN pAccessInfo]      Temp info associated with the explicit entry     //
//     [IN bCanonical]       Whether the acl passed in is canonical           //
//                                                                            //
// Returns: ERROR_SUCCESS if the entry could be converted into an ACE         //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaCompareAcesAndMarkMasks(
    IN PUCHAR             pAce,
    IN PACCESS_MASK       pAceMask,
    IN PEXPLICIT_ACCESS_W pExplicitAccess,
    IN PMARTA_ACCESS_INFO pAccessInfo,
    IN BOOL               bCanonical
    )
{
    ULONG                 SidLength                = 0;
    DWORD                 ObjectsPresent           = 0;
    GUID                * pGuid                    = NULL;
    GUID                * pObjectTypeGuid          = NULL;
    GUID                * pInheritedObjectTypeGuid = NULL;
    PSID                  pSid                     = NULL;
    POBJECTS_AND_SID      pObjSid                  = NULL;
    POBJECTS_AND_NAME_W   pObjName                 = NULL;
    ULONG                 AuditFlag                = FAILED_ACCESS_ACE_FLAG;
    UCHAR                 AceFlags                 = 0;

    if (FLAG_ON(pExplicitAccess->grfInheritance, INHERITED_ACE))
    {
        return ERROR_SUCCESS;
    }

    if (TRUSTEE_IS_IMPERSONATE == pExplicitAccess->Trustee.MultipleTrusteeOperation)
    {
        if (ACCESS_ALLOWED_COMPOUND_ACE_TYPE != ((PACE_HEADER) pAce)->AceType)
        {
            return ERROR_SUCCESS;
        }

        pSid = pAccessInfo->pServerSid     ?
                   pAccessInfo->pServerSid :
                   (PSID) pExplicitAccess->Trustee.ptstrName;

        if (!RtlEqualSid(
                pSid,
                (PSID) &(((PCOMPOUND_ACCESS_ALLOWED_ACE) pAce)->SidStart)
                ))
        {
            return ERROR_SUCCESS;
        }

        SidLength = RtlLengthSid(pSid);

        pSid = pAccessInfo->pSid     ?
                   pAccessInfo->pSid :
                   (PSID) (pExplicitAccess->Trustee.pMultipleTrustee->ptstrName);

        if (!RtlEqualSid(
                pSid,
                (PSID) (((PUCHAR) &(((PCOMPOUND_ACCESS_ALLOWED_ACE) pAce)->SidStart)) + SidLength)
                ))
        {
            return ERROR_SUCCESS;
        }
    }
    else
    {
        switch (((PACE_HEADER) pAce)->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
            switch (pExplicitAccess->Trustee.TrusteeForm)
            {
            case TRUSTEE_IS_SID:
                pSid = (PSID) pExplicitAccess->Trustee.ptstrName;
                break;
            case TRUSTEE_IS_NAME:
                pSid = pAccessInfo->pSid;
                break;
            default:
                return ERROR_SUCCESS;
            }

            if (!RtlEqualSid(
                    pSid,
                    (PSID) &(((PKNOWN_ACE) pAce)->SidStart)
                    ))
            {
                return ERROR_SUCCESS;
            }

            break;
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
            return ERROR_SUCCESS;
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:

            switch (pExplicitAccess->Trustee.TrusteeForm)
            {
            case TRUSTEE_IS_OBJECTS_AND_SID:
                pObjSid = (POBJECTS_AND_SID) pExplicitAccess->Trustee.ptstrName;
                ObjectsPresent           = pObjSid->ObjectsPresent;
                pSid                     = pObjSid->pSid;
                pObjectTypeGuid          = &(pObjSid->ObjectTypeGuid);
                pInheritedObjectTypeGuid = &(pObjSid->InheritedObjectTypeGuid);
                break;
            case TRUSTEE_IS_OBJECTS_AND_NAME:
                pObjName = (POBJECTS_AND_NAME_W) pExplicitAccess->Trustee.ptstrName;
                ObjectsPresent           = pObjName->ObjectsPresent;
                pSid                     = pAccessInfo->pSid;
                pObjectTypeGuid          = pAccessInfo->pObjectTypeGuid;
                pInheritedObjectTypeGuid = pAccessInfo->pInheritedObjectTypeGuid;
                break;
            default:
                return ERROR_SUCCESS;
            }

            if (ObjectsPresent != ((PKNOWN_OBJECT_ACE) pAce)->Flags)
            {
                return ERROR_SUCCESS;
            }

            if (!RtlEqualSid(pSid, RtlObjectAceSid(pAce)))
            {
                return ERROR_SUCCESS;
            }

            pGuid = RtlObjectAceObjectType(pAce);

            if (NULL != pGuid)
            {
                if ((NULL == pObjectTypeGuid) ||
                    !RtlpIsEqualGuid(pGuid, pObjectTypeGuid))
                {
                    return ERROR_SUCCESS;
                }
            }

            pGuid = RtlObjectAceInheritedObjectType(pAce);

            if (NULL != pGuid)
            {
                if ((NULL == pInheritedObjectTypeGuid) ||
                    !RtlpIsEqualGuid(pGuid, pInheritedObjectTypeGuid))
                {
                    return ERROR_SUCCESS;
                }
            }

            break;
        }
    }

    AceFlags = (((PACE_HEADER) pAce)->AceFlags) & VALID_INHERIT_FLAGS;

    switch (pExplicitAccess->grfAccessMode)
    {
    case REVOKE_ACCESS:
        switch (((PACE_HEADER) pAce)->AceType)
        {
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_ALLOWED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:
            *pAceMask = 0;
            break;
        default:
            break;
        }
        break;
    case GRANT_ACCESS:
        if (pExplicitAccess->grfInheritance != AceFlags)
        {
            return ERROR_SUCCESS;
        }

        switch (((PACE_HEADER) pAce)->AceType)
        {
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_ALLOWED_ACE_TYPE:
            if (TRUE == bCanonical)
            {
                *pAceMask |= pAccessInfo->Mask;
                pAccessInfo->Size = 0;
            }
            break;
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
            *pAceMask &= ~pAccessInfo->Mask;
            break;
        default:
            return ERROR_SUCCESS;
        }
        break;
    case DENY_ACCESS:
        if (pExplicitAccess->grfInheritance != AceFlags)
        {
            return ERROR_SUCCESS;
        }

        switch (((PACE_HEADER) pAce)->AceType)
        {
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_ALLOWED_ACE_TYPE:

            //
            // Do not delete existing Allow aces!
            //
            // *pAceMask &= ~pAccessInfo->Mask;
            //

            break;
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
            if (TRUE == bCanonical)
            {
                *pAceMask |= pAccessInfo->Mask;
                pAccessInfo->Size = 0;
            }
            break;
        default:
            return ERROR_SUCCESS;
        }
        break;
    case SET_ACCESS:
        switch (((PACE_HEADER) pAce)->AceType)
        {
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
            *pAceMask = 0;
            break;
        default:
            return ERROR_SUCCESS;
        }
        break;
    case SET_AUDIT_SUCCESS:
        AuditFlag = SUCCESSFUL_ACCESS_ACE_FLAG;
    case SET_AUDIT_FAILURE:
        if (pExplicitAccess->grfInheritance != AceFlags)
        {
            return ERROR_SUCCESS;
        }
        switch (((PACE_HEADER) pAce)->AceType)
        {
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:
            if (!FLAG_ON(((PACE_HEADER) pAce)->AceFlags, AuditFlag))
            {
                return ERROR_SUCCESS;
            }

            *pAceMask |= pAccessInfo->Mask;
            pAccessInfo->Size = 0;
            break;
        default:
            return ERROR_SUCCESS;
        }
    }

    return ERROR_SUCCESS;
}


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetExplicitAccessEntrySize                                  //
//                                                                            //
// Description: Computes the memory size in bytes for the ace for the         //
//              explicit entry.                                               //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN pExplicitAccess]  Explicit entry to convert into an ace            //
//     [IN pAccessInfo]      Temp info associated with the explicit entry     //
//                                                                            //
//     [IN OUT pGuidCnt]     Number of guid-names that have to be convrted    //
//                           to guid structs.                                 //
//                                                                            //
// Returns: ERROR_SUCCESS if the entry could be converted into an ACE         //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaGetExplicitAccessEntrySize(
    IN  PEXPLICIT_ACCESS_W pExplicitAccess,
    OUT PMARTA_ACCESS_INFO pAccessInfo,
    OUT PULONG             pGuidCnt,
    OUT PUCHAR             pAclRevision
    )
{
    DWORD dwErr          = ERROR_SUCCESS;
    ULONG SidAndGuidSize = 0;

    if (FLAG_ON(pExplicitAccess->grfInheritance, ~VALID_INHERIT_FLAGS))
    {
        return ERROR_INVALID_PARAMETER;
    }

    switch (pExplicitAccess->grfAccessMode)
    {
    case REVOKE_ACCESS:
    case DENY_ACCESS:
    case GRANT_ACCESS:
    case SET_ACCESS:
    case SET_AUDIT_SUCCESS:
    case SET_AUDIT_FAILURE:
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    if (FLAG_ON(pExplicitAccess->grfInheritance, INHERITED_ACE))
    {
        pAccessInfo->Size = 0;
        return ERROR_SUCCESS;
    }

    //
    // For an impersonate trustee, two sids contribute to the size.
    //

    if (TRUSTEE_IS_IMPERSONATE == pExplicitAccess->Trustee.MultipleTrusteeOperation)
    {
        pAccessInfo->Size = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + sizeof(ULONG);

        dwErr = MartaTrusteeSidAndGuidSize(
                    &(pExplicitAccess->Trustee),
                    FALSE,
                    &(pAccessInfo->pServerSid),
                    &SidAndGuidSize,
                    NULL
                    );

        if (ERROR_SUCCESS != dwErr)
        {
            return dwErr;
        }

        pAccessInfo->Size += SidAndGuidSize;

        if (NULL == pExplicitAccess->Trustee.pMultipleTrustee)
        {
            return ERROR_INVALID_PARAMETER;
        }

        dwErr = MartaTrusteeSidAndGuidSize(
                    pExplicitAccess->Trustee.pMultipleTrustee,
                    FALSE,
                    &(pAccessInfo->pSid),
                    &SidAndGuidSize,
                    NULL
                    );

        if (ERROR_SUCCESS != dwErr)
        {
            return dwErr;
        }

        pAccessInfo->Size += SidAndGuidSize;

        if (*pAclRevision < ACL_REVISION3)
        {
            *pAclRevision = ACL_REVISION3;
        }

        return ERROR_SUCCESS;
    }

    //
    // For any other type of trustee, compute the space required for the SID as
    // well as Guids, if any.
    //

    switch (pExplicitAccess->Trustee.TrusteeForm)
    {
    case TRUSTEE_IS_OBJECTS_AND_SID:
    case TRUSTEE_IS_OBJECTS_AND_NAME:
        pAccessInfo->Size = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + sizeof(ULONG);
        *pAclRevision     = ACL_REVISION_DS;
        break;
    case TRUSTEE_IS_SID:
    case TRUSTEE_IS_NAME:
        pAccessInfo->Size = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    dwErr = MartaTrusteeSidAndGuidSize(
                &(pExplicitAccess->Trustee),
                TRUE,
                &(pAccessInfo->pSid),
                &SidAndGuidSize,
                pGuidCnt
                );

    if (ERROR_SUCCESS != dwErr)
    {
        return dwErr;
    }

    if (REVOKE_ACCESS == pExplicitAccess->grfAccessMode)
    {
        pAccessInfo->Size = 0;
    }
    else
    {
        pAccessInfo->Size += SidAndGuidSize;
    }

    return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaIsExplicitAclCanonical                                      //
//                                                                            //
// Description: Determines whether the explicit part of the acl is canonical. //
//              Finds the first explicit allow ace.                           //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN pAcl]              Acl                                             //
//     [OUT pExplicitAceCnt]  To return the first allow explicit ace          //
//                                                                            //
// Returns: TRUE     if the acl is canonical                                  //
//          FALSE    otherwise                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

BOOL
MartaIsExplicitAclCanonical(
    IN  PACL   pAcl,
    OUT PULONG pExplicitAceCnt
    )
{
    USHORT      j;
    USHORT      AceCnt;
    PACE_HEADER pAce;

    *pExplicitAceCnt = 0;

    if ((NULL == pAcl) || (0 == pAcl->AceCount))
    {
        return TRUE;
    }

    AceCnt = pAcl->AceCount;

    pAce = (PACE_HEADER) FirstAce(pAcl);
    for (j = 0; j < AceCnt; pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            j++;
            continue;
        }

        if ((ACCESS_ALLOWED_ACE_TYPE == pAce->AceType) ||
            (ACCESS_ALLOWED_OBJECT_ACE_TYPE == pAce->AceType) ||
            (ACCESS_ALLOWED_COMPOUND_ACE_TYPE == pAce->AceType))
        {
            break;
        }

        *pExplicitAceCnt = ++j;
    }

    for (; j < AceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            continue;
        }

        if ((ACCESS_DENIED_ACE_TYPE == pAce->AceType) ||
            (ACCESS_DENIED_OBJECT_ACE_TYPE == pAce->AceType))
        {
            return FALSE;
        }
    }

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaTrusteeSidAndGuidSize                                       //
//                                                                            //
// Description: Compute the size for the Sid(s) and Guid(s) for the trustee.  //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pTrustee]           Trsutee for which the size has to be computed //
//     [IN  bComputeGuidSize]   Whether Guidsize should be computed           //
//                                                                            //
//     [OUT ppSid]              To return the Sid if trustee is "named"       //
//     [OUT pSize]              To return the size computed                   //
//     [OUT pGuidCnt]           To return the number of guids                 //
//                                                                            //
// Returns: ERROR_SUCCESS if Name to Sid resolution passed                    //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaTrusteeSidAndGuidSize(
    IN  PTRUSTEE_W  pTrustee,
    IN  BOOL        bComputeGuidSize,
    OUT PSID      * ppSid,
    OUT PULONG      pSize,
    OUT PULONG      pGuidCnt          OPTIONAL
    )
{
    PSID         pSid    = NULL;
    SID_NAME_USE SidType = SidTypeUnknown;
    DWORD        dwErr   = ERROR_SUCCESS;

    switch (pTrustee->TrusteeForm)
    {
    case TRUSTEE_IS_SID:

        pSid = (PSID) pTrustee->ptstrName;

        if ((NULL == pSid) || (!RtlValidSid(pSid)))
        {
            return ERROR_INVALID_PARAMETER;
        }

        *pSize = RtlLengthSid(pSid);

        break;

    case TRUSTEE_IS_OBJECTS_AND_SID:

        pSid = ((POBJECTS_AND_SID) pTrustee->ptstrName)->pSid;

        if ((NULL == pSid) || (!RtlValidSid(pSid)))
        {
            return ERROR_INVALID_PARAMETER;
        }

        *pSize = RtlLengthSid(pSid);

        if (TRUE == bComputeGuidSize)
        {
            if (FLAG_ON(((POBJECTS_AND_SID) pTrustee->ptstrName)->ObjectsPresent,
                        ACE_OBJECT_TYPE_PRESENT))
            {
                *pSize += sizeof(GUID);
            }

            if (FLAG_ON(((POBJECTS_AND_SID) pTrustee->ptstrName)->ObjectsPresent,
                        ACE_INHERITED_OBJECT_TYPE_PRESENT))
            {
                *pSize += sizeof(GUID);
            }
        }

        break;

    case TRUSTEE_IS_NAME:

        dwErr = MartaGetSidFromName(pTrustee->ptstrName, ppSid);

        CONDITIONAL_RETURN(dwErr);

        *pSize = RtlLengthSid(*ppSid);

        break;

    case TRUSTEE_IS_OBJECTS_AND_NAME:

        dwErr = MartaGetSidFromName(
                    ((POBJECTS_AND_NAME_W) pTrustee->ptstrName)->ptstrName,
                    ppSid
                    );

        CONDITIONAL_RETURN(dwErr);

        *pSize = RtlLengthSid(*ppSid);

        if (TRUE == bComputeGuidSize)
        {
            if (FLAG_ON(((POBJECTS_AND_NAME_W) pTrustee->ptstrName)->ObjectsPresent,
                        ACE_OBJECT_TYPE_PRESENT))
            {
                *pSize += sizeof(GUID);
                (*pGuidCnt)++;
            }

            if (FLAG_ON(((POBJECTS_AND_NAME_W) pTrustee->ptstrName)->ObjectsPresent,
                        ACE_INHERITED_OBJECT_TYPE_PRESENT))
            {
                *pSize += sizeof(GUID);
                (*pGuidCnt)++;
            }
        }

        break;

    default:
        return ERROR_NONE_MAPPED;

    }

    return ERROR_SUCCESS;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetSidFromName                                              //
//                                                                            //
// Description: Resolves a given Name to Sid.                                 //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pName]              Name to be resolved                           //
//     [OUT ppSid]              To return the Sid for the trustee             //
//                                                                            //
// Returns: ERROR_SUCCESS if Name to Sid resolution passed                    //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaGetSidFromName(
    IN  LPWSTR   pName,
    OUT PSID   * ppSid
    )
{

#define MARTA_DEFAULT_SID_SIZE    64
#define MARTA_DEFAULT_DOMAIN_SIZE 256

    WCHAR        DomainBuffer[MARTA_DEFAULT_DOMAIN_SIZE];
    ULONG        SidSize    = MARTA_DEFAULT_SID_SIZE;
    ULONG        DomainSize = MARTA_DEFAULT_DOMAIN_SIZE;
    LPWSTR       Domain     = (LPWSTR) DomainBuffer;
    SID_NAME_USE SidNameUse = SidTypeUnknown;
    DWORD        dwErr      = ERROR_SUCCESS;

    if (NULL == ppSid)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if(0 == _wcsicmp(pName, L"CURRENT_USER"))
    {
        HANDLE TokenHandle;

        dwErr = GetCurrentToken(&TokenHandle);

        if(dwErr != ERROR_SUCCESS)
        {
            return dwErr;
        }

        dwErr = AccGetSidFromToken(
                    NULL,
                    TokenHandle,
                    TokenUser,
                    ppSid
                    );

        CloseHandle(TokenHandle);

        return dwErr;
    }

    *ppSid = (PSID) AccAlloc(SidSize);

    if(NULL == *ppSid)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if(!LookupAccountName(
            NULL,
            pName,
            *ppSid,
            &SidSize,
            Domain,
            &DomainSize,
            &SidNameUse))
    {
        dwErr = GetLastError();

        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            dwErr = ERROR_SUCCESS;

            if (SidSize > MARTA_DEFAULT_SID_SIZE)
            {
                AccFree(*ppSid);

                *ppSid = (PSID) AccAlloc(SidSize);

                if (*ppSid == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    goto End;
                }
            }

            if(DomainSize > MARTA_DEFAULT_DOMAIN_SIZE)
            {
                Domain = (LPWSTR) AccAlloc(DomainSize * sizeof(WCHAR));

                if (NULL == Domain)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    goto End;
                }

            }
            if(!LookupAccountName(
                    NULL,
                    pName,
                    *ppSid,
                    &SidSize,
                    Domain,
                    &DomainSize,
                    &SidNameUse))
            {
                dwErr = GetLastError();
                goto End;
            }
        }
    }

End:

    if (Domain != (LPWSTR) DomainBuffer)
    {
        AccFree(Domain);
    }

    if (ERROR_SUCCESS != dwErr)
    {
        if (NULL != *ppSid)
        {
            AccFree(*ppSid);
            *ppSid = NULL;
        }
    }
    return dwErr;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetGuid                                                     //
//                                                                            //
// Description: Resolves a given Guid Name to a Guid struct.                  //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pObjectName]        Name to be resolved                           //
//     [IN  ObjectType]         Object type of the name to be resolved        //
//     [OUT pGuid]              To return the guid                            //
//                                                                            //
// Returns: ERROR_SUCCESS if Name to guid resolution passed                   //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaGetGuid(
    IN  LPWSTR           pObjectName,
    IN  SE_OBJECT_TYPE   ObjectType,
    OUT GUID           * pGuid
    )
{
    switch (ObjectType)
    {
    case SE_DS_OBJECT:
    case SE_DS_OBJECT_ALL:
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    return MartaConvertNameToGuid[ObjectType](
               pObjectName,
               pGuid
               );
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: AccRewriteSetEntriesInAcl                                        //
//                                                                            //
// Description: Resolves a given Name to Sid.                                 //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  cCountOfExplicitEntries]  Number of items in list                 //
//     [IN  pListOfExplicitEntries]   List of entries to be added             //
//     [IN  OldAcl]                   The old acl to add the entries to       //
//     [OUT pNewAcl]                  To return the new acl                   //
//                                                                            //
// Returns: ERROR_SUCCESS if everything passed                                //
//          Appropriate failure otherwise                                     //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
AccRewriteSetEntriesInAcl(
    IN  ULONG                cCountOfExplicitEntries,
    IN  PEXPLICIT_ACCESS_W   pListOfExplicitEntries,
    IN  PACL                 OldAcl,
    OUT PACL               * pNewAcl
    )

{
    PMARTA_ACCESS_INFO    pAccessInfo    = NULL;
    PACCESS_MASK          pAceMaskInfo   = NULL;
    PACE_HEADER           pAce           = NULL;
    GUID                * pGuid          = NULL;
    GUID                * pCurrentGuid   = NULL;
    POBJECTS_AND_NAME_W   pObjName       = NULL;
    PUCHAR                pAcl           = NULL;
    USHORT                OldAceCnt      = 0;
    USHORT                NewAceCnt      = 0;
    ULONG                 ExplicitAceCnt = 0;
    ULONG                 NewAclSize     = sizeof(ACL);
    BOOL                  bCanonical     = TRUE;
    DWORD                 dwErr          = ERROR_SUCCESS;
    ULONG                 i              = 0;
    ULONG                 j              = 0;
    ULONG                 GuidCnt        = 0;
    ULONG                 ObjectsPresent = 0;
    UCHAR                 AclRevision    = ACL_REVISION;

    if ((NULL == pNewAcl) || ((NULL != OldAcl) && (!RtlValidAcl(OldAcl))))

    {
        return ERROR_INVALID_PARAMETER;
    }

    *pNewAcl = NULL;

    //
    // If the number of entries to be added is zero then make a copy of the Old
    // Acl as it is. Do not try to convert it into Canonical form if it's not.
    //

    if (0 == cCountOfExplicitEntries)
    {
        if (NULL != OldAcl)
        {
            *pNewAcl = (PACL) AccAlloc(OldAcl->AclSize);

            if (NULL == *pNewAcl)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            memcpy((PUCHAR) *pNewAcl, (PUCHAR) OldAcl, OldAcl->AclSize);
        }
        return ERROR_SUCCESS;
    }

    //
    // Canonical acls processing will be done as in the past.
    // Note: We now support non-canonical acls as well..
    //

    bCanonical = MartaIsExplicitAclCanonical(OldAcl, &ExplicitAceCnt);

    //
    // The Mask for all the aces is stored in a pAceMaskInfo and modified as
    // dictated by the ExplicitAccess entries.
    //

    if (NULL != OldAcl)
    {
        OldAceCnt  = OldAcl->AceCount;
        NewAclSize = OldAcl->AclSize;
        NewAceCnt  = OldAceCnt;

        pAceMaskInfo = (PACCESS_MASK) AccAlloc(sizeof(ACCESS_MASK) * OldAceCnt);

        if (NULL == pAceMaskInfo)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto End;
        }

        AclRevision = OldAcl->AclRevision;
    }

    //
    // Note: cCountOfExplicitEntries is non-zero at this point.
    //

    pAccessInfo = (PMARTA_ACCESS_INFO) AccAlloc(sizeof(MARTA_ACCESS_INFO) * cCountOfExplicitEntries);

    if (NULL == pAccessInfo)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto End;
    }

    //
    // Initialize the temp structures for the acl and the explicit entries.
    //

    pAce = (PACE_HEADER) FirstAce(OldAcl);

    for (j = 0; j < OldAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        pAceMaskInfo[j] = ((PKNOWN_ACE) pAce)->Mask;
    }

    for (i = 0; i < cCountOfExplicitEntries; i++)
    {
        pAccessInfo[i].pServerSid               = NULL;
        pAccessInfo[i].pSid                     = NULL;
        pAccessInfo[i].pObjectTypeGuid          = NULL;
        pAccessInfo[i].pInheritedObjectTypeGuid = NULL;
        pAccessInfo[i].Mask = pListOfExplicitEntries[i].grfAccessPermissions;
    }

    //
    // Compute the size required to add this explicit entry to the acl.
    //

    for (i = 0; i < cCountOfExplicitEntries; i++)
    {
        dwErr = MartaGetExplicitAccessEntrySize(
                    pListOfExplicitEntries + i,
                    pAccessInfo + i,
                    &GuidCnt,
                    &AclRevision
                    );

        CONDITIONAL_EXIT(dwErr, End);
    }

    //
    // For TRUSTEE_IS_OBJECTS_AND_NAME, resolve the GuidNames to Guids and store
    // them in the temp structure.
    //

    if (0 != GuidCnt)
    {
        pGuid = pCurrentGuid = (GUID *) AccAlloc(sizeof(GUID) * GuidCnt);

        if (NULL == pGuid)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto End;
        }

        for (i = 0; i < cCountOfExplicitEntries; i++)
        {
            pObjName = (POBJECTS_AND_NAME_W) pListOfExplicitEntries[i].Trustee.ptstrName;
            ObjectsPresent = pObjName->ObjectsPresent;

            if (FLAG_ON(ObjectsPresent, ACE_OBJECT_TYPE_PRESENT))
            {
                dwErr = MartaGetGuid(
                            pObjName->ObjectTypeName,
                            pObjName->ObjectType,
                            pCurrentGuid
                            );

                CONDITIONAL_EXIT(dwErr, End);

                pAccessInfo[i].pObjectTypeGuid = pCurrentGuid++;
            }

            if (FLAG_ON(ObjectsPresent, ACE_INHERITED_OBJECT_TYPE_PRESENT))
            {
                dwErr = MartaGetGuid(
                            pObjName->InheritedObjectTypeName,
                            pObjName->ObjectType,
                            pCurrentGuid
                            );

                CONDITIONAL_EXIT(dwErr, End);

                pAccessInfo[i].pInheritedObjectTypeGuid = pCurrentGuid++;
            }
        }
    }

    //
    // Compute the effect of explict entries added on the exisiting acl.
    // The size of an explicit entry will be set to zero if the entry will be
    // absorbed by some existing ace.
    // The Mask for an ace will be set to zero if the AceMask flags have been
    // nulled out by explicit entries.
    //

    for (i = 0; i < cCountOfExplicitEntries; i++)
    {
        pAce = (PACE_HEADER) FirstAce(OldAcl);

        for (j = 0; j < OldAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
        {
            //
            // Skip Inherited aces.
            //

            if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
            {
                continue;
            }

            dwErr = MartaCompareAcesAndMarkMasks(
                        (PUCHAR) pAce,
                        pAceMaskInfo + j,
                        pListOfExplicitEntries + i,
                        pAccessInfo + i,
                        bCanonical
                        );
            CONDITIONAL_EXIT(dwErr, End);
        }
    }

    //
    // Compute the size required for the new acl and the number of aces in it.
    //

    pAce = (PACE_HEADER) FirstAce(OldAcl);

    for (j = 0; j < OldAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (0 == pAceMaskInfo[j])
        {
            NewAclSize -= pAce->AceSize;
            NewAceCnt--;
        }
    }

    for (i = 0; i < cCountOfExplicitEntries; i++)
    {
        if (0 != pAccessInfo[i].Size)
        {
            NewAclSize += pAccessInfo[i].Size;
            NewAceCnt++;
        }
    }

    *pNewAcl = (PACL) AccAlloc(NewAclSize);

    if (NULL == *pNewAcl)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto End;
    }

    if (FALSE == InitializeAcl(*pNewAcl, NewAclSize, AclRevision))
    {
        dwErr = GetLastError();
        goto End;
    }

    (*pNewAcl)->AceCount = NewAceCnt;

    pAcl = ((PUCHAR) *pNewAcl) + sizeof(ACL);

    for (i = 0; i < cCountOfExplicitEntries; i++)
    {
        //
        // Add all the DENY ACES to the ACL.
        //

        switch (pListOfExplicitEntries[i].grfAccessMode)
        {
        case DENY_ACCESS:
        case SET_AUDIT_SUCCESS:
        case SET_AUDIT_FAILURE:
            dwErr = MartaAddExplicitEntryToAcl(
                        &pAcl,
                        pListOfExplicitEntries + i,
                        pAccessInfo + i
                        );
            CONDITIONAL_EXIT(dwErr, End);
            break;
        default:
            break;
        }
    }

    //
    // Copy the explicit aces from the OldAcl that have not been invalidated by
    // the new Aces added.
    // Inherited aces will be copied afterthe explict ones have been copied.
    //

    pAce = (PACE_HEADER) FirstAce(OldAcl);

    for (j = 0; j < ExplicitAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            continue;
        }

        if (0 != pAceMaskInfo[j])
        {
            memcpy((PUCHAR) pAcl, (PUCHAR) pAce, pAce->AceSize);

            ((PKNOWN_ACE) pAcl)->Mask = pAceMaskInfo[j];
            pAcl += pAce->AceSize;
        }
    }

    //
    // Add all the NON-DENY ACES to the ACL.
    // DENY aces have already been added.
    //
    // If the ACL was canonical then follow the old behavior i.e. add the
    // remaining explicit entries to the beginning of the "allowed" acl.
    // Otherwise, add the ACEs to the end of the explicit part of the ACL.
    //

    if (FALSE == bCanonical)
    {
        for (; j < OldAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
        {
            if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
            {
                continue;
            }

            if (0 != pAceMaskInfo[j])
            {
                memcpy((PUCHAR) pAcl, (PUCHAR) pAce, pAce->AceSize);

                ((PKNOWN_ACE) pAcl)->Mask = pAceMaskInfo[j];
                pAcl += pAce->AceSize;
            }
        }

        for (i = 0; i < cCountOfExplicitEntries; i++)
        {
            switch (pListOfExplicitEntries[i].grfAccessMode)
            {
            case GRANT_ACCESS:
            case SET_ACCESS:
                dwErr = MartaAddExplicitEntryToAcl(
                            &pAcl,
                            pListOfExplicitEntries + i,
                            pAccessInfo + i
                            );
                CONDITIONAL_EXIT(dwErr, End);
                break;
            default:
                break;
            }
        }
    }
    else
    {
        for (i = 0; i < cCountOfExplicitEntries; i++)
        {
            switch (pListOfExplicitEntries[i].grfAccessMode)
            {
            case GRANT_ACCESS:
            case SET_ACCESS:
                dwErr = MartaAddExplicitEntryToAcl(
                            &pAcl,
                            pListOfExplicitEntries + i,
                            pAccessInfo + i
                            );
                CONDITIONAL_EXIT(dwErr, End);
                break;
            default:
                break;
            }
        }

        for (; j < OldAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
        {
            if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
            {
                continue;
            }

            if (0 != pAceMaskInfo[j])
            {
                memcpy((PUCHAR) pAcl, (PUCHAR) pAce, pAce->AceSize);

                ((PKNOWN_ACE) pAcl)->Mask = pAceMaskInfo[j];
                pAcl += pAce->AceSize;
            }
        }
    }

    //
    // Add the inherited aces to the new ACL. This will reorder the ACEs so that
    // the EXPLICIT ACEs precede the INHERITED ONES but will not arrange the ACL
    // in canonical form if it was not to start with.
    //

    pAce = (PACE_HEADER) FirstAce(OldAcl);

    for (j = 0; j < OldAceCnt; j++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            memcpy((PUCHAR) pAcl, (PUCHAR) pAce, pAce->AceSize);

            pAcl += pAce->AceSize;
        }
    }

End:
    if (NULL != pAccessInfo)
    {
        for (i = 0; i < cCountOfExplicitEntries; i++ )
        {
            if (NULL != pAccessInfo[i].pServerSid)
            {
                AccFree(pAccessInfo[i].pServerSid);
            }

            if (NULL != pAccessInfo[i].pSid)
            {
                AccFree(pAccessInfo[i].pSid);
            }
        }
        AccFree(pAccessInfo);
    }

    if (NULL != pGuid)
    {
        AccFree(pGuid);
    }

    if (NULL != pAceMaskInfo)
    {
        AccFree(pAceMaskInfo);
    }

    if (ERROR_SUCCESS != dwErr)
    {
        if (NULL != *pNewAcl)
        {
            AccFree(*pNewAcl);
            *pNewAcl = NULL;
        }
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\rewrite.cxx ===
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  Microsoft Windows                                                         //
//  Copyright (C) Microsoft Corporation, 1999.                                //
//                                                                            //
//  File:    rewrite.cxx                                                      //
//                                                                            //
//  Contents:    New marta rewrite functions.                                 //
//                                                                            //
//  History:    4/99    KedarD     Created                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <aclpch.hxx>
#pragma hdrstop

extern "C"
{
    #include <stdio.h>
    #include <permit.h>
    #include <dsgetdc.h>
    #include <lmapibuf.h>
    #include <wmistr.h>
    #include <ntprov.hxx>
    #include <strings.h>
    #include <seopaque.h>
    #include <sertlp.h>
    #include <tables.h>

}

#define MARTA_DEBUG_NO 0

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// STRUCTURES DEFINITIONS TO HOLD FUNCTION POINTERS START HERE                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

typedef struct _MARTA_GET_FUNCTION_CONTEXT {
    FN_ADD_REF_CONTEXT     fAddRefContext;
    FN_CLOSE_CONTEXT       fCloseContext;
    FN_GET_DESIRED_ACCESS  fGetDesiredAccess;
    FN_GET_PARENT_CONTEXT  fGetParentContext;
    FN_GET_PROPERTIES      fGetProperties;
    FN_GET_TYPE_PROPERTIES fGetTypeProperties;
    FN_OPEN_NAMED_OBJECT   fOpenNamedObject;
    FN_OPEN_HANDLE_OBJECT  fOpenHandleObject;
    FN_GET_RIGHTS          fGetRights;
} MARTA_GET_FUNCTION_CONTEXT, *PMARTA_GET_FUNCTION_CONTEXT;

typedef struct _MARTA_SET_FUNCTION_CONTEXT {
    FN_ADD_REF_CONTEXT       fAddRefContext;
    FN_CLOSE_CONTEXT         fCloseContext;
    FN_FIND_FIRST            fFindFirst;
    FN_FIND_NEXT             fFindNext;
    FN_GET_DESIRED_ACCESS    fGetDesiredAccess;
    FN_GET_PARENT_CONTEXT    fGetParentContext;
    FN_GET_PROPERTIES        fGetProperties;
    FN_GET_TYPE_PROPERTIES   fGetTypeProperties;
    FN_GET_RIGHTS            fGetRights;
    FN_OPEN_NAMED_OBJECT     fOpenNamedObject;
    FN_OPEN_HANDLE_OBJECT    fOpenHandleObject;
    FN_SET_RIGHTS            fSetRights;
    FN_REOPEN_CONTEXT        fReopenContext;
    FN_REOPEN_ORIG_CONTEXT   fReopenOrigContext;
    FN_GET_NAME_FROM_CONTEXT fGetNameFromContext;
} MARTA_SET_FUNCTION_CONTEXT, *PMARTA_SET_FUNCTION_CONTEXT;

typedef struct _MARTA_INDEX_FUNCTION_CONTEXT {
    FN_OPEN_NAMED_OBJECT  fOpenNamedObject;
    FN_CLOSE_CONTEXT      fCloseContext;
    FN_GET_RIGHTS         fGetRights;
    FN_GET_PARENT_NAME    fGetParentName;
} MARTA_INDEX_FUNCTION_CONTEXT, *PMARTA_INDEX_FUNCTION_CONTEXT;

typedef struct _MARTA_RESET_FUNCTION_CONTEXT {
    FN_ADD_REF_CONTEXT     fAddRefContext;
    FN_CLOSE_CONTEXT       fCloseContext;
    FN_GET_DESIRED_ACCESS  fGetDesiredAccess;
    FN_GET_PARENT_CONTEXT  fGetParentContext;
    FN_GET_PROPERTIES      fGetProperties;
    FN_GET_TYPE_PROPERTIES fGetTypeProperties;
    FN_OPEN_NAMED_OBJECT   fOpenNamedObject;
    FN_GET_RIGHTS          fGetRights;
} MARTA_RESET_FUNCTION_CONTEXT, *PMARTA_RESET_FUNCTION_CONTEXT;
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// MACRO DEFINITIONS START HERE                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define MARTA_DACL_NOT_PROTECTED(sd, si)                                       \
        (FLAG_ON((si), DACL_SECURITY_INFORMATION) &&                           \
         !FLAG_ON((sd)->Control, SE_DACL_PROTECTED))

#define MARTA_SACL_NOT_PROTECTED(sd, si)                                       \
        (FLAG_ON((si), SACL_SECURITY_INFORMATION) &&                           \
         !FLAG_ON((sd)->Control, SE_SACL_PROTECTED))

#define MARTA_SD_NOT_PROTECTED(sd, si)                                         \
        ((MARTA_DACL_NOT_PROTECTED((sd), (si))) ||                             \
         (MARTA_SACL_NOT_PROTECTED((sd), (si))))

#define MARTA_NT5_FLAGS_ON(c)                                                  \
        (FLAG_ON((c), (SE_SACL_AUTO_INHERITED   | SE_DACL_AUTO_INHERITED |     \
                       SE_DACL_PROTECTED        | SE_SACL_PROTECTED |          \
                       SE_DACL_AUTO_INHERIT_REQ | SE_SACL_AUTO_INHERIT_REQ)))



#if 1
#define MARTA_TURN_OFF_IMPERSONATION                                           \
        if (OpenThreadToken(                                                   \
                GetCurrentThread(),                                            \
                MAXIMUM_ALLOWED,                                               \
                TRUE,                                                          \
                &ThreadHandle                                                  \
                ))                                                             \
        {                                                                      \
            if (!RevertToSelf())                                               \
            {                                                                  \
                dwErr = GetLastError();                                        \
            }                                                                  \
        }                                                                      \
        else                                                                   \
        {                                                                      \
            ThreadHandle = NULL;                                               \
        }                                                                      


#define MARTA_TURN_ON_IMPERSONATION                                            \
        if (ThreadHandle != NULL)                                              \
        {                                                                      \
            if (!SetThreadToken(NULL, ThreadHandle))                           \
            {                                                                  \
                dwErr = GetLastError();                                        \
            }                                                                  \
            else                                                               \
            {                                                                  \
                CloseHandle(ThreadHandle);                                     \
                ThreadHandle = NULL;                                           \
            }                                                                  \
        }

#else

#define MARTA_TURN_ON_IMPERSONATION 
#define MARTA_TURN_OFF_IMPERSONATION 

#endif

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// FUNCTION PROTOTYPES START HERE                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
AccRewriteSetHandleRights(
    IN     HANDLE               Handle,
    IN     SE_OBJECT_TYPE       ObjectType,
    IN     SECURITY_INFORMATION SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

DWORD
AccRewriteSetNamedRights(
    IN     LPWSTR               pObjectName,
    IN     SE_OBJECT_TYPE       ObjectType,
    IN     SECURITY_INFORMATION SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN     BOOL                 bSkipInheritanceComputation
    );

VOID
MartaInitializeGetContext(
    IN  SE_OBJECT_TYPE              ObjectType,
    OUT PMARTA_GET_FUNCTION_CONTEXT pFunctionContext
    );

VOID
MartaInitializeIndexContext(
    IN  SE_OBJECT_TYPE                ObjectType,
    OUT PMARTA_INDEX_FUNCTION_CONTEXT pFunctionContext
    );

BOOL
MartaUpdateTree(
    IN SECURITY_INFORMATION        SecurityInfo,
    IN PSECURITY_DESCRIPTOR        pNewSD,
    IN PSECURITY_DESCRIPTOR        pOldSD,
    IN MARTA_CONTEXT               Context,
    IN HANDLE                      ProcessHandle,
    IN PMARTA_SET_FUNCTION_CONTEXT pMartaSetFunctionContext,
    IN PGENERIC_MAPPING            pGenMap
    );

BOOL
MartaResetTree(
    IN LPWSTR                      pObjectName,
    IN LPWSTR                      NtObjectName,
    IN SECURITY_INFORMATION        SecurityInfo,
    IN SECURITY_INFORMATION        TmpSeInfo,
    IN PSECURITY_DESCRIPTOR        pNewSD,
    IN PSECURITY_DESCRIPTOR        pEmptySD,
    IN MARTA_CONTEXT               Context,
    IN HANDLE                      ProcessHandle,
    IN PMARTA_SET_FUNCTION_CONTEXT pMartaSetFunctionContext,
    IN PGENERIC_MAPPING            pGenMap,
    IN ACCESS_MASK                 MaxAccessMask,
    IN ACCESS_MASK                 AccessMask,
    IN ACCESS_MASK                 RetryAccessMask,
    IN OUT PPROG_INVOKE_SETTING    pOperation,
    IN FN_PROGRESS                 fnProgress,
    IN PVOID                       Args,
    IN BOOL                        KeepExplicit
    );

DWORD
MartaGetNT4NodeSD(
    IN     PSECURITY_DESCRIPTOR pOldSD,
    IN OUT PSECURITY_DESCRIPTOR pOldChildSD,
    IN     HANDLE               ProcessHandle,
    IN     BOOL                 bIsChildContainer,
    IN     PGENERIC_MAPPING     pGenMap,
    IN     SECURITY_INFORMATION SecurityInfo
    );

DWORD
MartaCompareAndMarkInheritedAces(
    IN  PACL    pParentAcl,
    IN  PACL    pChildAcl,
    IN  BOOL    bIsChildContainer,
    OUT PBOOL   pCompareStatus
    );

BOOL
MartaEqualAce(
    IN PACE_HEADER pParentAce,
    IN PACE_HEADER pChildAce,
    IN PACE_HEADER pNextChildAce,
    IN BOOL        bIsChildContainer,
    OUT PBOOL      pbMarkNextAce
    );

DWORD
MartaManualPropagation(
    IN     MARTA_CONTEXT               Context,
    IN     SECURITY_INFORMATION        SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR        pSD,
    IN     PGENERIC_MAPPING            pGenMap,
    IN     BOOL                        bDoPropagate,
    IN     BOOL                        bReadOldProtectedBits,
    IN     PMARTA_SET_FUNCTION_CONTEXT pMartaSetFunctionContext,
    IN     BOOL                        bSkipInheritanceComputation
    );

VOID
MartaInitializeSetContext(
    IN  SE_OBJECT_TYPE              ObjectType,
    OUT PMARTA_SET_FUNCTION_CONTEXT pFunctionContext
    );

DWORD
AccRewriteGetHandleRights(
    IN  HANDLE                 Handle,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
AccRewriteGetNamedRights(
    IN  LPWSTR                 pObjectName,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
MartaGetRightsFromContext(
    IN  MARTA_CONTEXT               Context,
    IN  PMARTA_GET_FUNCTION_CONTEXT pGetFunctionContext,
    IN  SECURITY_INFORMATION        SecurityInfo,
    OUT PSID                      * ppSidOwner,
    OUT PSID                      * ppSidGroup,
    OUT PACL                      * ppDacl,
    OUT PACL                      * ppSacl,
    OUT PSECURITY_DESCRIPTOR      * ppSecurityDescriptor
    );

VOID
MartaGetSidsAndAclsFromSD(
    IN  SECURITY_INFORMATION   SecurityInfo,
    IN  PSECURITY_DESCRIPTOR   pSD,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

BOOL
MartaIsSDNT5Style(
    IN PSECURITY_DESCRIPTOR SD
    );

BOOL
MartaIsAclNt5Style(
    PACL pAcl
    );

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// FUNCTIONS START HERE                                                       //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaIsSDNT5Style                                                //
//                                                                            //
// Description: Determine if the Security Descriptor is NT5 style.            //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pSD]                    Security Descriptor                       //
//                                                                            //
// Returns:  TRUE if any of the following is true                             //
//               Presence of Protected/AutoInherited in the contol bits of SD //
//               Presence of INHERITED_ACE flag in DACL/SACL                  //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

BOOL
MartaIsSDNT5Style(
    IN PSECURITY_DESCRIPTOR pSD
    )
{
    BOOL                  bRetval = TRUE;
    PACL                  pAcl    = NULL;
    PISECURITY_DESCRIPTOR pISD    = (PISECURITY_DESCRIPTOR) pSD;

    if (MARTA_NT5_FLAGS_ON(pISD->Control))
    {
        return TRUE;
    }

    pAcl = RtlpDaclAddrSecurityDescriptor(pISD);

    if (NULL != pAcl)
    {
        bRetval = FALSE;

        if (MartaIsAclNt5Style(pAcl))
        {
            return TRUE;
        }
    }

    pAcl = RtlpSaclAddrSecurityDescriptor(pISD);

    if (NULL != pAcl)
    {
        bRetval = FALSE;

        if (MartaIsAclNt5Style(pAcl))
        {
            return TRUE;
        }
    }

    return bRetval;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaIsAclNT5Style                                               //
//                                                                            //
// Description: Determine if the Acl is NT5 style.                            //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pAcl]                    ACL                                      //
//                                                                            //
// Returns: TRUE if INHERITED_ACE flags exists in the AceFlags                //
//          FALSE otherwise                                                   //
////////////////////////////////////////////////////////////////////////////////

BOOL
MartaIsAclNt5Style(
    PACL pAcl
    )
{
    ULONG       i    = 0;
    PACE_HEADER pAce = (PACE_HEADER) FirstAce(pAcl);

    for (; i < pAcl->AceCount; i++, pAce = (PACE_HEADER) NextAce(pAce))
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            return TRUE;
        }
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaInitializeGetContext                                        //
//                                                                            //
// Description: Initializes the function pointers based on object-type.       //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  ObjectType]        Type of the object                             //
//     [OUT pFunctionContext]  Structure to hold function pointers            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

VOID
MartaInitializeGetContext(
    IN  SE_OBJECT_TYPE              ObjectType,
    OUT PMARTA_GET_FUNCTION_CONTEXT pFunctionContext
    )
{
    pFunctionContext->fAddRefContext     = MartaAddRefContext[ObjectType];
    pFunctionContext->fCloseContext      = MartaCloseContext[ObjectType];
    pFunctionContext->fOpenNamedObject   = MartaOpenNamedObject[ObjectType];
    pFunctionContext->fOpenHandleObject  = MartaOpenHandleObject[ObjectType];
    pFunctionContext->fGetRights         = MartaGetRights[ObjectType];
    pFunctionContext->fGetDesiredAccess  = MartaGetDesiredAccess[ObjectType];
    pFunctionContext->fGetParentContext  = MartaGetParentContext[ObjectType];
    pFunctionContext->fGetTypeProperties = MartaGetTypeProperties[ObjectType];
    pFunctionContext->fGetProperties     = MartaGetProperties[ObjectType];
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetSidsAndAclsFromSD                                        //
//                                                                            //
// Description: Fill in the fields requested by GetSecurity API.              //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  SecurityInfo]           Security Information requested            //
//     [IN  pSD]                    Security Descriptor from which the out    //
//                                  fields will be returned                   //
//                                                                            //
//     [OUT  ppSIdOwner]            To return the owner                       //
//     [OUT  ppSidGroup]            To return the group                       //
//     [OUT  ppDacl]                To return the Dacl                        //
//     [OUT  ppSacl]                To return the Sacl                        //
//     [OUT  ppSecurityDescriptor]  To return the Security Descriptor         //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

VOID
MartaGetSidsAndAclsFromSD(
    IN  SECURITY_INFORMATION   SecurityInfo,
    IN  PSECURITY_DESCRIPTOR   pSD,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
{
    PISECURITY_DESCRIPTOR pISD = (PISECURITY_DESCRIPTOR) pSD;

    if (FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION) && (NULL != ppSidOwner))
    {
        *ppSidOwner = RtlpOwnerAddrSecurityDescriptor(pISD);
    }

    if (FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION) && (NULL != ppSidGroup))
    {
        *ppSidGroup = RtlpGroupAddrSecurityDescriptor(pISD);
    }

    if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION) && (NULL != ppDacl))
    {
       *ppDacl = RtlpDaclAddrSecurityDescriptor(pISD);
    }

    if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION) && (ppSacl != NULL))
    {
        *ppSacl = RtlpSaclAddrSecurityDescriptor(pISD);
    }

    if (NULL != ppSecurityDescriptor)
    {
        *ppSecurityDescriptor = pSD;
    }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetRightsFromContext                                        //
//                                                                            //
// Description: Get the security information requested given the Context.     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  Context]                Context structure for the object          //
//     [IN  pGetFunctionContext]    Structure holding the function pointers   //
//     [IN  SecurityInfo]           Security Information requested            //
//                                                                            //
//     [OUT  ppSIdOwner]            To return the owner                       //
//     [OUT  ppSidGroup]            To return the group                       //
//     [OUT  ppDacl]                To return the Dacl                        //
//     [OUT  ppSacl]                To return the Sacl                        //
//     [OUT  ppSecurityDescriptor]  To return the Security Descriptor         //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaGetRightsFromContext(
    IN  MARTA_CONTEXT               Context,
    IN  PMARTA_GET_FUNCTION_CONTEXT pGetFunctionContext,
    IN  SECURITY_INFORMATION        SecurityInfo,
    OUT PSID                      * ppSidOwner,
    OUT PSID                      * ppSidGroup,
    OUT PACL                      * ppDacl,
    OUT PACL                      * ppSacl,
    OUT PSECURITY_DESCRIPTOR      * ppSecurityDescriptor
    )
{
    DWORD                dwErr         = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR pSD           = NULL;
    PSECURITY_DESCRIPTOR pParentSD     = NULL;
    HANDLE               ProcessHandle = NULL;
    GENERIC_MAPPING      ZeroGenMap    = {0, 0, 0, 0};
    MARTA_CONTEXT        ParentContext = NULL_MARTA_CONTEXT;
    BOOL                 bIsContainer  = FALSE;

    MARTA_OBJECT_PROPERTIES      ObjectProperties;
    MARTA_OBJECT_TYPE_PROPERTIES ObjectTypeProperties;

    dwErr = (*(pGetFunctionContext->fGetRights))(
                   Context,
                   SecurityInfo,
                   &pSD
                   );

    CONDITIONAL_RETURN(dwErr);

    if (NULL == pSD)
    {
        goto End;
    }

    if (!FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION))
    {
        goto GetResults;
    }

    //
    // If the SD is NT4 && acl requested is not PROTECTED && ManualPropagation
    // is required then
    //     Get the ParentSD and convert the SD into NT5 style
    // else
    //     Goto GetResults
    //

    if (!MARTA_SD_NOT_PROTECTED((PISECURITY_DESCRIPTOR) pSD, SecurityInfo))
    {
        goto GetResults;
    }

    if (MartaIsSDNT5Style(pSD))
    {
        goto GetResults;
    }

    //
    // Get the "Type" properties for the object,
    //

    ObjectTypeProperties.cbSize  = sizeof(ObjectTypeProperties);
    ObjectTypeProperties.dwFlags = 0;
    ObjectTypeProperties.GenMap  = ZeroGenMap;

    dwErr = (*(pGetFunctionContext->fGetTypeProperties))(&ObjectTypeProperties);

    CONDITIONAL_EXIT(dwErr, End);

    if (!FLAG_ON(ObjectTypeProperties.dwFlags, MARTA_OBJECT_TYPE_MANUAL_PROPAGATION_NEEDED_FLAG))
    {
        goto GetResults;
    }

    dwErr = (*(pGetFunctionContext->fGetParentContext))(
                Context,
                (*(pGetFunctionContext->fGetDesiredAccess))(READ_ACCESS_RIGHTS, FALSE, SecurityInfo),
                &ParentContext
                );

    CONDITIONAL_EXIT(dwErr, End);

    //
    // The SD is NT4 style. Read the parent SD to determine whether the aces are
    // the "same" on both the parent and the child.
    //

    if (NULL == ParentContext)
    {
        goto GetResults;
    }

    dwErr = (*(pGetFunctionContext->fGetRights))(
                   ParentContext,
                   SecurityInfo,
                   &pParentSD
                   );

    (VOID) (*(pGetFunctionContext->fCloseContext))(ParentContext);

    CONDITIONAL_EXIT(dwErr, End);

    if (NULL == pParentSD)
    {
        goto GetResults;
    }

    dwErr = GetCurrentToken(&ProcessHandle);

    CONDITIONAL_EXIT(dwErr, End);

    if (!((FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION)) &&
          (FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))))
    {
        AccFree(pSD);
        pSD = NULL;

        dwErr = (*(pGetFunctionContext->fGetRights))(
                       Context,
                       (SecurityInfo | OWNER_SECURITY_INFORMATION |
                        GROUP_SECURITY_INFORMATION),
                       &pSD
                       );

        CONDITIONAL_EXIT(dwErr, End);
    }

    ObjectProperties.cbSize  = sizeof(ObjectProperties);
    ObjectProperties.dwFlags = 0;

    dwErr = (*(pGetFunctionContext->fGetProperties))(
                   Context,
                   &ObjectProperties
                   );

    CONDITIONAL_EXIT(dwErr, End);

    bIsContainer = FLAG_ON(ObjectProperties.dwFlags, MARTA_OBJECT_IS_CONTAINER);

    dwErr = MartaGetNT4NodeSD(
                pParentSD,
                pSD,
                ProcessHandle,
                bIsContainer,
                &(ObjectTypeProperties.GenMap),
                SecurityInfo
                );

    CONDITIONAL_EXIT(dwErr, End);

GetResults:

    MartaGetSidsAndAclsFromSD(
        SecurityInfo,
        pSD,
        ppSidOwner,
        ppSidGroup,
        ppDacl,
        ppSacl,
        ppSecurityDescriptor
        );

End:

    if (NULL != pParentSD)
    {
        AccFree(pParentSD);
    }

    if (NULL != ProcessHandle)
    {
        CloseHandle(ProcessHandle);
    }

    if (ERROR_SUCCESS != dwErr)
    {
        AccFree(pSD);
    }

    return dwErr;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: AccRewriteGetNamedRights                                         //
//                                                                            //
// Description: Get the security information requested given the object       //
//              name and information. This is the routine that is called by   //
//              advapi32.                                                     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pObjectName]            Name of the Object                        //
//     [IN  ObjectType]             Type of the object                        //
//     [IN  SecurityInfo]           Security Information requested            //
//                                                                            //
//     [OUT  ppSIdOwner]            To return the owner                       //
//     [OUT  ppSidGroup]            To return the group                       //
//     [OUT  ppDacl]                To return the Dacl                        //
//     [OUT  ppSacl]                To return the Sacl                        //
//     [OUT  ppSecurityDescriptor]  To return the Security Descriptor         //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
AccRewriteGetNamedRights(
    IN  LPWSTR                 pObjectName,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
{
    DWORD         dwErr   = ERROR_SUCCESS;
    MARTA_CONTEXT Context = NULL_MARTA_CONTEXT;

    MARTA_GET_FUNCTION_CONTEXT MartaGetFunctionContext;

    switch (ObjectType)
    {
    case SE_FILE_OBJECT:
    case SE_SERVICE:
    case SE_PRINTER:
    case SE_REGISTRY_KEY:
    case SE_REGISTRY_WOW64_32KEY:
    case SE_LMSHARE:
    case SE_KERNEL_OBJECT:
    case SE_WINDOW_OBJECT:
    case SE_WMIGUID_OBJECT:
    case SE_DS_OBJECT:
    case SE_DS_OBJECT_ALL:
        break;
    case SE_PROVIDER_DEFINED_OBJECT:
    case SE_UNKNOWN_OBJECT_TYPE:
    default:
        return ERROR_INVALID_PARAMETER;
    }

    MartaInitializeGetContext(ObjectType, &MartaGetFunctionContext);

    //
    // Open the object with permissions to read the object type as well. If that
    // fails, open the object with just read permissions. This has to be done in
    // order to accomodate NT4 SDs.
    //

    dwErr = (*(MartaGetFunctionContext.fOpenNamedObject))(
                   pObjectName,
                   (*(MartaGetFunctionContext.fGetDesiredAccess))(READ_ACCESS_RIGHTS, TRUE, SecurityInfo),
                   &Context
                   );

    if (ERROR_SUCCESS != dwErr)
    {
        dwErr = (*(MartaGetFunctionContext.fOpenNamedObject))(
                       pObjectName,
                       (*(MartaGetFunctionContext.fGetDesiredAccess))(READ_ACCESS_RIGHTS, FALSE, SecurityInfo),
                       &Context
                       );

        CONDITIONAL_EXIT(dwErr, End);
    }

    dwErr = MartaGetRightsFromContext(
                Context,
                &MartaGetFunctionContext,
                SecurityInfo,
                ppSidOwner,
                ppSidGroup,
                ppDacl,
                ppSacl,
                ppSecurityDescriptor
                );

    (VOID) (*(MartaGetFunctionContext.fCloseContext))(Context);

End:
    return dwErr;

}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: AccRewriteGetHandleRights                                        //
//                                                                            //
// Description: Get the security information requested given the object       //
//              handle and information. This is the routine that is called by //
//              advapi32.                                                     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  Handle]                 Handle to the Object                      //
//     [IN  pGetFunctionContext]    Structure holding the function pointers   //
//     [IN  SecurityInfo]           Security Information requested            //
//                                                                            //
//     [OUT  ppSIdOwner]            To return the owner                       //
//     [OUT  ppSidGroup]            To return the group                       //
//     [OUT  ppDacl]                To return the Dacl                        //
//     [OUT  ppSacl]                To return the Sacl                        //
//     [OUT  ppSecurityDescriptor]  To return the Security Descriptor         //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
AccRewriteGetHandleRights(
    IN  HANDLE                 Handle,
    IN  SE_OBJECT_TYPE         ObjectType,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSID                 * ppSidOwner,
    OUT PSID                 * ppSidGroup,
    OUT PACL                 * ppDacl,
    OUT PACL                 * ppSacl,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
{
    DWORD         dwErr   = ERROR_SUCCESS;
    MARTA_CONTEXT Context = NULL_MARTA_CONTEXT;

    MARTA_GET_FUNCTION_CONTEXT MartaGetFunctionContext;

    switch (ObjectType)
    {
    case SE_FILE_OBJECT:
    case SE_SERVICE:
    case SE_PRINTER:
    case SE_REGISTRY_KEY:
    case SE_LMSHARE:
    case SE_KERNEL_OBJECT:
    case SE_WINDOW_OBJECT:
    case SE_WMIGUID_OBJECT:
        break;
    case SE_DS_OBJECT:
    case SE_DS_OBJECT_ALL:
    case SE_PROVIDER_DEFINED_OBJECT:
    case SE_UNKNOWN_OBJECT_TYPE:
    default:
        return ERROR_INVALID_PARAMETER;
    }

    MartaInitializeGetContext(ObjectType, &MartaGetFunctionContext);

    //
    // Open the object with permissions to read the object type as well. If that
    // fails, open the object with just read permissions. This has to be done in
    // order to accomodate NT4 SDs.
    //

    dwErr = (*(MartaGetFunctionContext.fOpenHandleObject))(
                   Handle,
                   (*(MartaGetFunctionContext.fGetDesiredAccess))(READ_ACCESS_RIGHTS, TRUE, SecurityInfo),
                   &Context
                   );

    if (ERROR_SUCCESS != dwErr)
    {
        dwErr = (*(MartaGetFunctionContext.fOpenHandleObject))(
                       Handle,
                       (*(MartaGetFunctionContext.fGetDesiredAccess))(READ_ACCESS_RIGHTS, FALSE, SecurityInfo),
                       &Context
                       );

        CONDITIONAL_EXIT(dwErr, End);
    }

    dwErr = MartaGetRightsFromContext(
                Context,
                &MartaGetFunctionContext,
                SecurityInfo,
                ppSidOwner,
                ppSidGroup,
                ppDacl,
                ppSacl,
                ppSecurityDescriptor
                );

    (VOID) (*(MartaGetFunctionContext.fCloseContext))(Context);

End:
    return dwErr;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaInitializeSetContext                                        //
//                                                                            //
// Description: Initializes the function pointers based on object-type.       //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  ObjectType]        Type of the object                             //
//     [OUT pFunctionContext]  Structure to hold function pointers            //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////


VOID
MartaInitializeSetContext(
    IN  SE_OBJECT_TYPE              ObjectType,
    OUT PMARTA_SET_FUNCTION_CONTEXT pFunctionContext
    )
{
    pFunctionContext->fAddRefContext      = MartaAddRefContext[ObjectType];
    pFunctionContext->fCloseContext       = MartaCloseContext[ObjectType];
    pFunctionContext->fFindFirst          = MartaFindFirst[ObjectType];
    pFunctionContext->fFindNext           = MartaFindNext[ObjectType];
    pFunctionContext->fGetParentContext   = MartaGetParentContext[ObjectType];
    pFunctionContext->fGetProperties      = MartaGetProperties[ObjectType];
    pFunctionContext->fGetTypeProperties  = MartaGetTypeProperties[ObjectType];
    pFunctionContext->fGetRights          = MartaGetRights[ObjectType];
    pFunctionContext->fOpenNamedObject    = MartaOpenNamedObject[ObjectType];
    pFunctionContext->fOpenHandleObject   = MartaOpenHandleObject[ObjectType];
    pFunctionContext->fSetRights          = MartaSetRights[ObjectType];
    pFunctionContext->fGetDesiredAccess   = MartaGetDesiredAccess[ObjectType];
    pFunctionContext->fReopenContext      = MartaReopenContext[ObjectType];
    pFunctionContext->fReopenOrigContext  = MartaReopenOrigContext[ObjectType];
    pFunctionContext->fGetNameFromContext = MartaGetNameFromContext[ObjectType];
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaManualPropagation                                           //
//                                                                            //
// Description: Stamp the security descriptor on the object referred by the   //
//              context and propagate the inheritable aces to its children.   //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  Context]                Context structure for the object          //
//     [IN  SecurityInfo]           Security Information requested            //
//     [IN  OUT pSD]                Security Descriptor to be stamped on the  //
//                                  object in absolute format.                //
//     [IN  pGenMap]                Generic mapping of the object rights      //
//     [IN  bDoPropagate]           Whether propagation _can_ be done         //
//     [IN  bReadOldProtectedBits]  Whether to read existing protection info  //
//     [IN  pSetFunctionContext]    Structure holding the function pointers   //
//     [IN  bSkipInheritanceComputation]  Whether to compute inherited aces   //
//                                        from the parent
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaManualPropagation(
    IN     MARTA_CONTEXT               Context,
    IN     SECURITY_INFORMATION        SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR        pSD,
    IN     PGENERIC_MAPPING            pGenMap,
    IN     BOOL                        bDoPropagate,
    IN     BOOL                        bReadOldProtectedBits,
    IN     PMARTA_SET_FUNCTION_CONTEXT pMartaSetFunctionContext,
    IN     BOOL                        bSkipInheritanceComputation
    )
{
    DWORD                       dwErr             = ERROR_SUCCESS;
    BOOL                        bProtected        = TRUE;
    BOOL                        bIsChildContainer = FALSE;
    BOOL                        bRetryPropagation = FALSE;
    PSECURITY_DESCRIPTOR        pParentSD         = NULL;
    PSECURITY_DESCRIPTOR        pOldSD            = NULL;
    PSECURITY_DESCRIPTOR        pNewSD            = NULL;
    PSID                        pSidOwner         = NULL;
    HANDLE                      ProcessHandle     = NULL;
    HANDLE                      ThreadHandle      = NULL;
    MARTA_CONTEXT               ParentContext     = NULL_MARTA_CONTEXT;
    SECURITY_DESCRIPTOR_CONTROL LocalControl      = (SECURITY_DESCRIPTOR_CONTROL) 0;

    MARTA_OBJECT_PROPERTIES ObjectProperties;

    //
    // Check if manual propagation should be done. Propagation is not tried if
    // any errors are encountered.
    //

    ObjectProperties.cbSize  = sizeof(ObjectProperties);
    ObjectProperties.dwFlags = 0;

    dwErr = (*(pMartaSetFunctionContext->fGetProperties))(
                   Context,
                   &ObjectProperties
                   );

    CONDITIONAL_EXIT(dwErr, End);

    bIsChildContainer = FLAG_ON(ObjectProperties.dwFlags, MARTA_OBJECT_IS_CONTAINER);

    dwErr = GetCurrentToken(&ProcessHandle);

    CONDITIONAL_EXIT(dwErr, End);

    //
    // Compute inherited aces if the caller has not already. This is the usual
    // case.
    //

    if (FALSE == bSkipInheritanceComputation)
    {
        //
        // Read the parent ACL only if xACL is to be stamped on is not protected.
        //

        if (MARTA_SD_NOT_PROTECTED((PISECURITY_DESCRIPTOR) pSD, SecurityInfo))
        {
            bProtected = FALSE;

            dwErr = (*(pMartaSetFunctionContext->fGetParentContext))(
                        Context,
                        (*(pMartaSetFunctionContext->fGetDesiredAccess))(READ_ACCESS_RIGHTS, FALSE, SecurityInfo),
                        &ParentContext
                        );

            CONDITIONAL_EXIT(dwErr, End);

            if (NULL != ParentContext)
            {
                dwErr = (*(pMartaSetFunctionContext->fGetRights))(
                               ParentContext,
                               SecurityInfo,
                               &pParentSD
                               );

                (VOID) (*(pMartaSetFunctionContext->fCloseContext))(ParentContext);

                CONDITIONAL_EXIT(dwErr, End);

                if (NULL != pParentSD)
                {
                    if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
                    {
                        ((PISECURITY_DESCRIPTOR) pParentSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
                    }

                    if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
                    {
                        ((PISECURITY_DESCRIPTOR) pParentSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
                    }
                }
            }
        }

        //
        // Read the old security descriptor on the child.
        // To take case of creator-owner/group aces, read in Owner/Group info as
        // well and set it in the SD passed in if it is not already present.
        //

        {
            SECURITY_INFORMATION LocalSeInfo = SecurityInfo;

            if (NULL == RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD))
            {
                LocalSeInfo |= OWNER_SECURITY_INFORMATION;
            }

            if (NULL == RtlpGroupAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD))
            {
                LocalSeInfo |= GROUP_SECURITY_INFORMATION;
            }

            dwErr = (*(pMartaSetFunctionContext->fGetRights))(
                           Context,
                           LocalSeInfo,
                           &pOldSD
                           );

            CONDITIONAL_EXIT(dwErr, End);

            if (NULL == RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD))
            {
                if (FALSE == SetSecurityDescriptorOwner(
                                 pSD,
                                 RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldSD),
                                 FALSE))
                {
                    dwErr = GetLastError();
                }

                CONDITIONAL_EXIT(dwErr, End);
            }

            if (NULL == RtlpGroupAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD))
            {
                if (FALSE == SetSecurityDescriptorGroup(
                                 pSD,
                                 RtlpGroupAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldSD),
                                 FALSE))
                {
                    dwErr = GetLastError();
                }

                CONDITIONAL_EXIT(dwErr, End);
            }

        }

        //
        // If none of the PROTECTED flags are passed in then do the "right" thing.
        // Read the PROTECTED bit from the existing security descriptor and set it
        // in the new one.
        //

        if (bReadOldProtectedBits && (NULL != pOldSD))
        {
            if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
            {
                if (!FLAG_ON(SecurityInfo, (PROTECTED_DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION)))
                {
                    ((PISECURITY_DESCRIPTOR) pSD)->Control |= ((PISECURITY_DESCRIPTOR) pOldSD)->Control & SE_DACL_PROTECTED;
                }
            }

            if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
            {
                if (!FLAG_ON(SecurityInfo, (PROTECTED_SACL_SECURITY_INFORMATION | UNPROTECTED_SACL_SECURITY_INFORMATION)))
                {
                    ((PISECURITY_DESCRIPTOR) pSD)->Control |= ((PISECURITY_DESCRIPTOR) pOldSD)->Control & SE_SACL_PROTECTED;
                }
            }
        }

        //
        // Merge the SD with the parent SD whether or not it is protected.
        // This is done to lose the inherited aces if the child is protected.
        //

        MARTA_TURN_OFF_IMPERSONATION;
        
        CONDITIONAL_EXIT(dwErr, End);

        if (FALSE == CreatePrivateObjectSecurityEx(
                         pParentSD,
                         pSD,
                         &pNewSD,
                         NULL,
                         bIsChildContainer,
                         (SEF_DACL_AUTO_INHERIT | SEF_SACL_AUTO_INHERIT | SEF_AVOID_OWNER_CHECK | SEF_AVOID_PRIVILEGE_CHECK),
                         ProcessHandle,
                         pGenMap
                         ))
        {
            dwErr = GetLastError();
        }

        MARTA_TURN_ON_IMPERSONATION;

        CONDITIONAL_EXIT(dwErr, End);
    }
    else
    {
        //
        // Stamp the security descriptor as prvided by the caller. The only
        // caller of this is SCE.
        //

        pNewSD = pSD;

        //
        // Read the old security descriptor on the child if xAcl it is a container.
        //

        if (bIsChildContainer)
        {
            dwErr = (*(pMartaSetFunctionContext->fGetRights))(
                           Context,
                           (SecurityInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)),
                           &pOldSD
                           );

            CONDITIONAL_EXIT(dwErr, End);
        }
    }

    //
    // If the child is a container then update the subtree underneath it.
    //

    if (bIsChildContainer)
    {
        if (bDoPropagate)
        {
            bRetryPropagation = MartaUpdateTree(
                                    SecurityInfo,
                                    pNewSD,
                                    pOldSD,
                                    Context,
                                    ProcessHandle,
                                    pMartaSetFunctionContext,
                                    pGenMap
                                    );
        }
        else
        {
            bRetryPropagation = TRUE;
        }
    }

    //
    // Stamp NewNodeSD on the node
    //

    if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        ((PISECURITY_DESCRIPTOR) pNewSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
    }

    if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        ((PISECURITY_DESCRIPTOR) pNewSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
    }

    dwErr = (*(pMartaSetFunctionContext->fSetRights))(
                   Context,
                   SecurityInfo,
                   pNewSD
                   );

    CONDITIONAL_EXIT(dwErr, End);

    //
    // If propagation had failed in the first attept then try again. This is to
    // cover the case when the container can be enumerated after setting the new
    // security.

    if (bRetryPropagation && (SecurityInfo & DACL_SECURITY_INFORMATION))
    {
        ACCESS_MASK Access = (*(pMartaSetFunctionContext->fGetDesiredAccess))(
                                    NO_ACCESS_RIGHTS,
                                    TRUE,
                                    SecurityInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)
                                    );

        DWORD lErr = (*(pMartaSetFunctionContext->fReopenOrigContext))(
                       Context,
                       Access
                       );

        CONDITIONAL_EXIT(lErr, End);

        (VOID) MartaUpdateTree(
                   SecurityInfo,
                   pNewSD,
                   pOldSD,
                   Context,
                   ProcessHandle,
                   pMartaSetFunctionContext,
                   pGenMap
                   );
    }

End:

    if (NULL != ProcessHandle)
    {
        CloseHandle(ProcessHandle);
    }

    if (NULL != pOldSD)
    {
        AccFree(pOldSD);
    }

    if (NULL != pParentSD)
    {
        AccFree(pParentSD);
    }

    if ((NULL != pNewSD) && (pNewSD != pSD))
    {
        DestroyPrivateObjectSecurity(&pNewSD);
    }

    return dwErr;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaEqualAce                                                    //
//                                                                            //
// Description: Compare an ace from child to an ace from parent to determine  //
//              if the child ace has been inherited from its parent.          //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pParentAce]          The ace for the parent object                //
//     [IN  pChildAce]           The ace for the child object                 //
//     [IN  pNextChildAce]       The next ace for the child object            //
//     [IN  bIsChildContainer]   Whether the child object is a Container      //
//     [OUT pbMarkNextAce]       Whether next ACE should be marked inherited  //
//                                                                            //
// Returns: TRUE    if the two aces are equal                                 //
//          FALSE   otherwise                                                 //
//                                                                            //
// Notes: No ace should contain generic bits and the parent ace should not    //
//        have INHERIT_ONLY bit.                                              //
//        Inherit flags are ignored.                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

BOOL
MartaEqualAce(
    IN PACE_HEADER pParentAce,
    IN PACE_HEADER pChildAce,
    IN PACE_HEADER pNextChildAce,
    IN BOOL        bIsChildContainer,
    OUT PBOOL      pbMarkNextAce
    )
{
    PSID        pSid1   = NULL;
    PSID        pSid2   = NULL;
    ACCESS_MASK Access1 = 0;
    ACCESS_MASK Access2 = 0;
    ULONG       Length1 = 0;
    ULONG       Length2 = 0;
    UCHAR       ParentFlags = pParentAce->AceFlags & ~INHERITED_ACE;

    *pbMarkNextAce = FALSE;

    if ((NULL == pParentAce) || (NULL == pChildAce))
    {
        return FALSE;
    }

    //
    // Compare ACE type.
    //

    if (pParentAce->AceType != pChildAce->AceType)
    {
        return FALSE;
    }

    if ((pParentAce->AceFlags & ~INHERITED_ACE) != (pChildAce->AceFlags))
    {
        //
        // The flags did not match exactly. So, this is not a NT4 object created
        // on Win2K+ system. But, this may be a NT4 object created on NT4 system. 
        // The inheritance algorithm on NT4 was not optimal and it creates two
        // ACEs when one is sufficient.
        // The specific case we are trying to catch is:
        //    Ace on the parent = combination of OI, CI
        //    On Child
        //      ACE1 = NO Flags
        //      ACE2 = Same flags as well as OI
        //

        if (bIsChildContainer &&
            (ParentFlags != 0) && 
            (pNextChildAce != NULL) && 
            (pChildAce->AceFlags == 0) && 
            ((ParentFlags & INHERIT_ONLY) == 0) &&
            (ParentFlags == (pNextChildAce->AceFlags ^ INHERIT_ONLY))
            )
        {
            switch (pParentAce->AceType) {
            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_DENIED_ACE_TYPE:
            case SYSTEM_AUDIT_ACE_TYPE:
            case SYSTEM_ALARM_ACE_TYPE:
                if ((((PKNOWN_ACE) pParentAce)->Mask == ((PKNOWN_ACE) pNextChildAce)->Mask) &&
                    RtlEqualSid((PSID) &((PKNOWN_ACE) pNextChildAce)->SidStart, (PSID) &((PKNOWN_ACE) pChildAce)->SidStart)
                    )
                {
                    //
                    // Compare the next ACE instead.
                    //

                    pChildAce = pNextChildAce;
                }
                else
                {
                    return FALSE;
                }
                break;
            default:
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }

    }

    //
    // Get access mask and SID pointer.
    //

    switch (pParentAce->AceType) {
    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:

        pSid1   = (PSID) &((PKNOWN_ACE) pParentAce)->SidStart;
        pSid2   = (PSID) &((PKNOWN_ACE) pChildAce)->SidStart;
        Access1 = ((PKNOWN_ACE) pParentAce)->Mask;
        Access2 = ((PKNOWN_ACE) pChildAce)->Mask;
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:

        if (((PKNOWN_OBJECT_ACE) pParentAce)->Flags !=
             ((PKNOWN_OBJECT_ACE) pChildAce)->Flags )
        {
            return FALSE;
        }

        if (((PKNOWN_OBJECT_ACE) pParentAce)->Flags & ACE_OBJECT_TYPE_PRESENT)
        {
            if (!RtlpIsEqualGuid(
                     RtlObjectAceObjectType(pParentAce),
                     RtlObjectAceObjectType(pChildAce)))
            {
                return FALSE;
            }
        }

        if (((PKNOWN_OBJECT_ACE) pParentAce)->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT)
        {
            if (!RtlpIsEqualGuid(
                     RtlObjectAceInheritedObjectType(pParentAce),
                     RtlObjectAceInheritedObjectType(pChildAce)))
            {
                return FALSE;
            }
        }

        pSid1 = RtlObjectAceSid(pParentAce);
        pSid2 = RtlObjectAceSid(pChildAce);

        Access1 = ((PKNOWN_OBJECT_ACE) pParentAce)->Mask;
        Access2 = ((PKNOWN_OBJECT_ACE) pChildAce)->Mask;

        break;

    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

        if (((PKNOWN_COMPOUND_ACE) pParentAce)->CompoundAceType !=
            ((PKNOWN_COMPOUND_ACE) pChildAce)->CompoundAceType)
        {
            return FALSE;
        }

        pSid1 = (PSID) &((PKNOWN_COMPOUND_ACE) pParentAce)->SidStart;
        pSid2 = (PSID) &((PKNOWN_COMPOUND_ACE) pParentAce)->SidStart;

        if ((!RtlValidSid(pSid1)) || (!RtlValidSid(pSid2)))
        {
            return FALSE;
        }

        if (!RtlEqualSid(pSid1, pSid2))
        {
            return FALSE;
        }

        Length1 = RtlLengthSid(pSid1);
        Length2 = RtlLengthSid(pSid2);

        pSid1 = (PSID) (((PUCHAR) pSid1) + Length1);
        pSid2 = (PSID) (((PUCHAR) pSid2) + Length2);

        Access1 = ((PKNOWN_COMPOUND_ACE) pParentAce)->Mask;
        Access2 = ((PKNOWN_COMPOUND_ACE) pChildAce)->Mask;
        break;

    default:
        return FALSE;
    }

    //
    // Compare access mask. There should be no generic mask and both the parent
    // object and the child object should have the same object type.
    //

    if (Access1 != Access2) {
        return FALSE;
    }

    //
    // Compare the Sids.
    //

    if ((!RtlValidSid(pSid1)) || (!RtlValidSid(pSid2)))
    {
        return FALSE;
    }

    if (!RtlEqualSid(pSid1, pSid2))
    {
        return FALSE;
    }

    if (pChildAce == pNextChildAce)
    {
        *pbMarkNextAce = TRUE;
    }

    return TRUE;

}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: CompareAndMarkInheritedAces                                      //
//                                                                            //
// Description: Compare the parent acl with the child. If all the effective   //
//              aces from parent are present in the child then mark those     //
//              aces in the child with INHERITED_ACE bit.                     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pParentAcl]          The acl for the parent object                //
//     [IN  OUT pChildAcl]       The acl for the child object                 //
//     [IN  bIsChildContainer]   Whether the child object is a Container      //
//                                                                            //
//     [OUT  pCompareStatus]  To return the Security Descriptor               //
//                                                                            //
// Returns: TRUE    if the all effective parent aces are present in the child //
//          FALSE   otherwise                                                 //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaCompareAndMarkInheritedAces(
    IN      PACL    pParentAcl,
    IN  OUT PACL    pChildAcl,
    IN      BOOL    bIsChildContainer,
    OUT     PBOOL   pCompareStatus
    )
{
    DWORD       dwErr                 = ERROR_SUCCESS;
    LONG        ParentAceCnt          = 0;
    LONG        ChildAceCnt           = 0;
    LONG        i                     = 0;
    LONG        j                     = 0;
    LONG        LastDenyAce           = -1;
    LONG        LastExplicitAce       = -1;
    LONG        LastInheritedDenyAce  = -1;
    LONG        FirstAllowAce         = ChildAceCnt;
    LONG        FirstInheritedAce     = ChildAceCnt;
    LONG        FirstExplicitAllowAce = ChildAceCnt;
    BOOL        bMarkNextAce          = FALSE;
    PACE_HEADER pParentAce            = NULL;
    PACE_HEADER pChildAce             = NULL;
    PACE_HEADER pNextChildAce         = NULL;
    PBOOL       Flags                 = NULL;
    PUCHAR      Buffer                = NULL;
    PUCHAR      CurrentBuffer         = NULL;

    //
    // If the ChildAcl is NULL then it is a superset of the parent ACL.
    //

    if (NULL == pChildAcl)
    {
        *pCompareStatus = FALSE;
        goto End;
    }

    //
    // If the ParentAcl is NULL then it is a superset of the child ACL.
    // Since Child Acl is non-null at this point return TRUE.
    //

    if (NULL == pParentAcl)
    {
        *pCompareStatus = TRUE;
        goto End;
    }

    //
    // If the parent has no aces that could have been inherited then all the
    // child aces must be explicit.
    //

    ParentAceCnt = pParentAcl->AceCount;

    if (0 == ParentAceCnt)
    {
        *pCompareStatus = TRUE;
        goto End;
    }

    //
    // If the parent has one/more inheritable aces but the child has none then
    // the acl must be protected.
    //

    ChildAceCnt  = pChildAcl->AceCount;

    if (0 == ChildAceCnt)
    {
        *pCompareStatus = FALSE;
        goto End;
    }

    Flags = (PBOOL) AccAlloc(sizeof(BOOL) * ChildAceCnt);

    if (NULL == Flags)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto End;
    }

    for (i = 0; i < ChildAceCnt; i++)
    {
        Flags[i] = FALSE;
    }

    //
    // For all aces present in ParentAcl
    //     If the ace is not present in ChildAcl
    //         return FALSE
    //     else
    //         Mark the position of the this ace in Child Acl in fFlags.
    //         These will later be marked as INHERITED if the acl can be
    //         rearranged to be canonical.
    //

    i = 0;
    pParentAce = (PACE_HEADER) FirstAce(pParentAcl);

    for (; i < ParentAceCnt; i++, pParentAce = (PACE_HEADER) NextAce(pParentAce))
    {
        j = 0;
        pChildAce = (PACE_HEADER) FirstAce(pChildAcl);

        for (; j < ChildAceCnt; j++, pChildAce = (PACE_HEADER) NextAce(pChildAce))
        {
            if ((j + 1) == ChildAceCnt)
            {
                //
                // There is no next ACE.
                //

                pNextChildAce = NULL;
            }
            else
            {
                pNextChildAce = (PACE_HEADER) NextAce(pChildAce); 
            }

            if (TRUE == MartaEqualAce(pParentAce, pChildAce, pNextChildAce, bIsChildContainer, &bMarkNextAce))
            {
                Flags[j] = TRUE;

                if (bMarkNextAce)
                {
                    Flags[j + 1] = TRUE;
                }
                break;
            }
        }

        if (ChildAceCnt == j)
        {
            *pCompareStatus = FALSE;
            goto End;
        }
    }

    //
    // Mark all the aces that we had marked as INHERITED.
    // This will make sure that they are not DUPLICATED.
    //

    LastDenyAce           = -1;
    LastExplicitAce       = -1;
    LastInheritedDenyAce  = -1;

    FirstAllowAce         = ChildAceCnt;
    FirstInheritedAce     = ChildAceCnt;
    FirstExplicitAllowAce = ChildAceCnt;

    //
    // Run thru the acl and mark the positions of aces. These will be later used
    // to dtermine what should be done with the acl.
    //

    j = 0;
    pChildAce = (PACE_HEADER) FirstAce(pChildAcl);

    for (; j < ChildAceCnt; j++, pChildAce = (PACE_HEADER) NextAce(pChildAce))
    {
        switch (pChildAce->AceType)
        {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:

            if (FALSE == Flags[j])
            {
                if (ChildAceCnt == FirstExplicitAllowAce)
                {
                    FirstExplicitAllowAce = j;
                }
            }

            if (ChildAceCnt == FirstAllowAce)
            {
                FirstAllowAce = j;
            }

            break;

        case ACCESS_DENIED_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:

            if (TRUE == Flags[j])
            {
                LastInheritedDenyAce = j;
            }

            LastDenyAce = j;

            break;

        default:
            break;
        }

        if (FALSE == Flags[j])
        {
            LastExplicitAce = j;
        }
        else
        {
            if (ChildAceCnt == FirstInheritedAce)
            {
                FirstInheritedAce = j;
            }
        }
    }

    //
    // This a non-canonical acl. Do not try to correct it.
    //

    if ((ChildAceCnt != FirstAllowAce) && (LastDenyAce > FirstAllowAce))
    {
        *pCompareStatus = FALSE;
        goto End;
    }

    //
    // Do not try to rearrange the acl if
    //     1. an inherited deny ace exists AND
    //     2. an explicit allow ace exists.
    //

    if ((-1 != LastInheritedDenyAce) && (ChildAceCnt != FirstExplicitAllowAce))
    {
        *pCompareStatus = FALSE;
        goto End;
    }

    //
    // The acl need not be rearranged since all the explicit aces are ahead of
    // the inherited ones.
    //

    if (LastExplicitAce < FirstInheritedAce)
    {
        j = 0;
        pChildAce = (PACE_HEADER) FirstAce(pChildAcl);

        for (; j < ChildAceCnt; j++, pChildAce = (PACE_HEADER) NextAce(pChildAce))
        {
            if (TRUE == Flags[j])
            {
                pChildAce->AceFlags |= INHERITED_ACE;
            }
        }
    }

    //
    // At least one inherited ace exists before an explicit one.
    // Rearrange the acl to get it in canonical form.
    //

    else
    {
        Buffer = (PUCHAR) AccAlloc(pChildAcl->AclSize - sizeof(ACL));
        CurrentBuffer = Buffer;

        if (NULL == Buffer)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto End;
        }

        j = 0;
        pChildAce = (PACE_HEADER) FirstAce(pChildAcl);

        for (; j <= LastExplicitAce; j++, pChildAce = (PACE_HEADER) NextAce(pChildAce))
        {
            if (FALSE == Flags[j])
            {
                memcpy(CurrentBuffer, (PUCHAR) pChildAce, pChildAce->AceSize);
                CurrentBuffer += pChildAce->AceSize;
            }
        }

        j = 0;
        pChildAce = (PACE_HEADER) FirstAce(pChildAcl);

        for (; j < ChildAceCnt; j++, pChildAce = (PACE_HEADER) NextAce(pChildAce))
        {
            if (TRUE == Flags[j])
            {
                memcpy(CurrentBuffer, (PUCHAR) pChildAce, pChildAce->AceSize);
                ((PACE_HEADER) CurrentBuffer)->AceFlags |= INHERITED_ACE;
                CurrentBuffer += pChildAce->AceSize;
            }
        }

        memcpy(
            ((PUCHAR) pChildAcl) + sizeof(ACL),
            Buffer,
            pChildAcl->AclSize - sizeof(ACL)
            );
    }

    *pCompareStatus = TRUE;

End:

    if (NULL != Flags)
    {
        AccFree(Flags);
    }

    if (NULL != Buffer)
    {
        AccFree(Buffer);
    }

    return dwErr;;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaGetNT4NodeSD                                                //
//                                                                            //
// Description: Converts the child security descriptor NT4 ACL into NT5 ACL   //
//              by comparing it to the parent ACL.                            //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pOldSD]              Old parent security descriptor               //
//     [IN  OUT pOldChildSD]     Old child security descriptor                //
//     [IN  Processhandle]       Process Handle                               //
//     [IN  bIsChildContainer]   Whether the child object is a Container      //
//     [IN  pGenMap]             Generic mapping of the object rights         //
//     [IN  SecurityInfo]        Security Information requested               //
//                                                                            //
// Algorithm:                                                                 //
//     if child acl and parent acl differ then                                //
//         mark the child acl PROTECTED                                       //
//                                                                            //
// Returns: ERROR_SUCCESS on successful completion of the routine             //
//          ERROR_XXXX    Otherwise                                           //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
MartaGetNT4NodeSD(
    IN     PSECURITY_DESCRIPTOR pOldSD,
    IN OUT PSECURITY_DESCRIPTOR pOldChildSD,
    IN     HANDLE               ProcessHandle,
    IN     BOOL                 bIsChildContainer,
    IN     PGENERIC_MAPPING     pGenMap,
    IN     SECURITY_INFORMATION SecurityInfo
    )
{
    SECURITY_DESCRIPTOR  NullSD;

    DWORD                dwErr         = ERROR_SUCCESS;
    BOOL                 CompareStatus = FALSE;
    PACL                 pChildAcl     = NULL;
    PACL                 pParentAcl    = NULL;
    HANDLE               ThreadHandle  = NULL;
    PSECURITY_DESCRIPTOR pTmpSD        = NULL;
    UCHAR                Buffer[2 * sizeof(ACL)];
    PACL                 pDacl         = (PACL) Buffer;
    PACL                 pSacl         = (PACL) (Buffer + sizeof(ACL));

    if (!FLAG_ON(SecurityInfo, (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)))
    {
        return ERROR_SUCCESS;
    }

    InitializeSecurityDescriptor(&NullSD, SECURITY_DESCRIPTOR_REVISION);

    if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        if (FALSE == InitializeAcl(pDacl, sizeof(ACL), ACL_REVISION))
        {
            return ERROR_ACCESS_DENIED;
        }

        if (FALSE == SetSecurityDescriptorDacl(
                         &NullSD,
                         TRUE,
                         pDacl,
                         FALSE))
        {
            return GetLastError();
        }
    }

    if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        if (FALSE == InitializeAcl(pSacl, sizeof(ACL), ACL_REVISION))
        {
            return ERROR_ACCESS_DENIED;
        }

        if (FALSE == SetSecurityDescriptorSacl(
                         &NullSD,
                         TRUE,
                         pSacl,
                         FALSE))
        {
            return GetLastError();
        }
    }

    if (FALSE == SetSecurityDescriptorOwner(
                     &NullSD,
                     RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldChildSD),
                     FALSE))
    {
        return GetLastError();
    }

    if (FALSE == SetSecurityDescriptorGroup(
                     &NullSD,
                     RtlpGroupAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldChildSD),
                     FALSE))
    {
        return GetLastError();
    }

    MARTA_TURN_OFF_IMPERSONATION;

    CONDITIONAL_EXIT(dwErr, End);

    if (FALSE == CreatePrivateObjectSecurityEx(
                     pOldSD,
                     &NullSD,
                     &pTmpSD,
                     NULL,
                     bIsChildContainer,
                     (SEF_DACL_AUTO_INHERIT | SEF_SACL_AUTO_INHERIT | SEF_AVOID_OWNER_CHECK | SEF_AVOID_PRIVILEGE_CHECK),
                     ProcessHandle,
                     pGenMap
                     ))
    {
        dwErr = GetLastError();
    }

    MARTA_TURN_ON_IMPERSONATION;

    CONDITIONAL_EXIT(dwErr, End);

    //
    // Mark the aces from the child DACL, which are present in the parent.
    //

    if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        pChildAcl  = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldChildSD);
        pParentAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pTmpSD);

        dwErr = MartaCompareAndMarkInheritedAces(
                    pParentAcl,
                    pChildAcl,
                    bIsChildContainer,
                    &CompareStatus
                    );

        CONDITIONAL_EXIT(dwErr, End);

        if (FALSE == CompareStatus)
        {
            ((PISECURITY_DESCRIPTOR) pOldChildSD)->Control |= SE_DACL_PROTECTED;

        }
    }

    //
    // Mark the aces from the child SACL, which are present in the parent.
    //

    if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        pChildAcl  = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldChildSD);
        pParentAcl = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pTmpSD);

        dwErr = MartaCompareAndMarkInheritedAces(
                    pParentAcl,
                    pChildAcl,
                    bIsChildContainer,
                    &CompareStatus
                    );

        CONDITIONAL_EXIT(dwErr, End);

        if (FALSE == CompareStatus)
        {
            ((PISECURITY_DESCRIPTOR) pOldChildSD)->Control |= SE_SACL_PROTECTED;

        }

        CONDITIONAL_EXIT(dwErr, End);
    }

End:
    if (NULL != pTmpSD)
    {
        DestroyPrivateObjectSecurity(&pTmpSD);
    }

    return dwErr;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaUpdateTree                                                  //
//                                                                            //
// Description: Propagate the inheritable aces to the children.               //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  SecurityInfo]           Security Information requested            //
//     [IN  pNewSD]                 New parent security descriptor            //
//     [IN  pOldSD]                 Old parent security descriptor            //
//     [IN  Context]                Context structure for the object          //
//     [IN  Processhandle]          Process Handle                            //
//     [IN  pSetFunctionContext]    Structure holding the function pointers   //
//     [IN  pGenMap]                Generic mapping of the object rights      //
//                                                                            //
// Algorithm:                                                                 //
//     For all children that are not "Protected"                              //
//         if OldChildSD = NT4 style                                          //
//            Convert it into NT5 style                                       //
//         NewChildSD = Merge(ParentSD, OldChildSD)                           //
//         UpdateTree(Child)                                                  //
//         Stamp NewChildSD on Child                                          //
//                                                                            //
// Note: An error in the propagation is ignored.                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

BOOL
MartaUpdateTree(
    IN SECURITY_INFORMATION        SecurityInfo,
    IN PSECURITY_DESCRIPTOR        pNewSD,
    IN PSECURITY_DESCRIPTOR        pOldSD,
    IN MARTA_CONTEXT               Context,
    IN HANDLE                      ProcessHandle,
    IN PMARTA_SET_FUNCTION_CONTEXT pMartaSetFunctionContext,
    IN PGENERIC_MAPPING            pGenMap
    )
{
    MARTA_OBJECT_PROPERTIES ObjectProperties;

    DWORD                dwErr             = ERROR_SUCCESS;
    BOOL                 bIsChildContainer = FALSE;
    BOOL                 bRetryPropagation = FALSE;
    BOOL                 bDoPropagate      = TRUE;
    HANDLE               ThreadHandle      = NULL;
    PSECURITY_DESCRIPTOR pOldChildSD       = NULL;
    PSECURITY_DESCRIPTOR pNewChildSD       = NULL;
    MARTA_CONTEXT        ChildContext      = NULL_MARTA_CONTEXT;

    //
    // Get the first child to update.
    //

    dwErr = (*(pMartaSetFunctionContext->fFindFirst))(
                   Context,
                   (*(pMartaSetFunctionContext->fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, TRUE, SecurityInfo),
                   &ChildContext
                   );

    if (ERROR_SUCCESS != dwErr)
    {
        if (NULL == ChildContext)
        {
            dwErr = (*(pMartaSetFunctionContext->fFindFirst))(
                           Context,
                           (*(pMartaSetFunctionContext->fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, FALSE, SecurityInfo),
                           &ChildContext
                           );
        }
        else
        {
            dwErr = (*(pMartaSetFunctionContext->fReopenContext))(
                           ChildContext,
                           (*(pMartaSetFunctionContext->fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, FALSE, SecurityInfo)
                           );
        }

        bDoPropagate = FALSE;
    }

    if (NULL == ChildContext)
    {
        return TRUE;
    }

    CONDITIONAL_EXIT(dwErr, EndOfWhile);

    //
    // Note: On any intermediate error the current child is skipped.
    //

    while (ChildContext)
    {

        ObjectProperties.cbSize  = sizeof(ObjectProperties);
        ObjectProperties.dwFlags = 0;

        dwErr = (*(pMartaSetFunctionContext->fGetProperties))(
                       ChildContext,
                       &ObjectProperties
                       );

        CONDITIONAL_EXIT(dwErr, EndOfWhile);

        bIsChildContainer = FLAG_ON(ObjectProperties.dwFlags, MARTA_OBJECT_IS_CONTAINER);

        dwErr = (*(pMartaSetFunctionContext->fGetRights))(
                       ChildContext,
                       (SecurityInfo | OWNER_SECURITY_INFORMATION |
                        GROUP_SECURITY_INFORMATION),
                       &pOldChildSD
                       );

        CONDITIONAL_EXIT(dwErr, EndOfWhile);

        //
        // Skip the children that are protected.
        //

        if (!MARTA_SD_NOT_PROTECTED((PISECURITY_DESCRIPTOR) pOldChildSD, SecurityInfo))
        {
            goto EndOfWhile;

        }

        //
        // Convert NT4 SD to NT5 style.
        //

        if (FALSE == MartaIsSDNT5Style(pOldChildSD))
        {
            //
            // Note that this modifies OldChildSD in one of the two ways:
            //     1. If any of the inheritable aces from the OldSD are missing
            //        from OldChild then
            //            Mark the acl PROTECTED.
            //     2. else
            //            Mark the common aces in ChildSD as INHERITED.
            //

            dwErr = MartaGetNT4NodeSD(
                        pOldSD,
                        pOldChildSD,
                        ProcessHandle,
                        bIsChildContainer,
                        pGenMap,
                        SecurityInfo
                        );

            CONDITIONAL_EXIT(dwErr, EndOfWhile);
        }

        MARTA_TURN_OFF_IMPERSONATION;

        CONDITIONAL_EXIT(dwErr, EndOfWhile);
        
        //
        // Merge the NewParentSD and the OldChildSD to create NewChildSD.
        //

        if (FALSE == CreatePrivateObjectSecurityEx(
                         pNewSD,
                         pOldChildSD,
                         &pNewChildSD,
                         NULL,
                         bIsChildContainer,
                         (SEF_DACL_AUTO_INHERIT | SEF_SACL_AUTO_INHERIT |
                          SEF_AVOID_OWNER_CHECK | SEF_AVOID_PRIVILEGE_CHECK),
                         ProcessHandle,
                         pGenMap
                         ))
        {
            dwErr = GetLastError();
        }

        MARTA_TURN_ON_IMPERSONATION;

        CONDITIONAL_EXIT(dwErr, EndOfWhile);

        //
        // Update the subtree undrneath this child.
        //

        if (bIsChildContainer)
        {
            if (bDoPropagate)
            {
                bRetryPropagation = MartaUpdateTree(
                                        SecurityInfo,
                                        pNewChildSD,
                                        pOldChildSD,
                                        ChildContext,
                                        ProcessHandle,
                                        pMartaSetFunctionContext,
                                        pGenMap
                                        );
            }
            else
            {
                bRetryPropagation = TRUE;
            }
        }

        //
        // Stamp NewChildSD on child.
        //

        if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR) pNewChildSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
        }

        if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR) pNewChildSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
        }

        dwErr = (*(pMartaSetFunctionContext->fSetRights))(
                       ChildContext,
                       SecurityInfo,
                       pNewChildSD
                       );

        CONDITIONAL_EXIT(dwErr, EndOfWhile);

        //
        // If propagation had failed in the first attept then try again. This is to
        // cover the case when the container can be enumerated after setting the new
        // security.

        if (bRetryPropagation && (SecurityInfo & DACL_SECURITY_INFORMATION))
        {
            ACCESS_MASK Access = (*(pMartaSetFunctionContext->fGetDesiredAccess))(
                                        NO_ACCESS_RIGHTS,
                                        TRUE,
                                        SecurityInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)
                                        );

            dwErr = (*(pMartaSetFunctionContext->fReopenContext))(
                           ChildContext,
                           Access
                           );

            CONDITIONAL_EXIT(dwErr, EndOfWhile);

            (VOID) MartaUpdateTree(
                       SecurityInfo,
                       pNewChildSD,
                       pOldChildSD,
                       ChildContext,
                       ProcessHandle,
                       pMartaSetFunctionContext,
                       pGenMap
                       );
        }

EndOfWhile:

        bRetryPropagation = FALSE;

        if (NULL != pOldChildSD)
        {
            AccFree(pOldChildSD);
            pOldChildSD = NULL;
        }

        if (NULL != pNewChildSD)
        {
            DestroyPrivateObjectSecurity(&pNewChildSD);
            pNewChildSD = NULL;
        }

        //
        // Get the next child.
        //

        do {

            dwErr = (*(pMartaSetFunctionContext->fFindNext))(
                           ChildContext,
                           (*(pMartaSetFunctionContext->fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, TRUE, SecurityInfo),
                           &ChildContext
                           );

            if ((ERROR_SUCCESS != dwErr) && (NULL != ChildContext))
            {
                dwErr = (*(pMartaSetFunctionContext->fReopenContext))(
                               ChildContext,
                               (*(pMartaSetFunctionContext->fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, FALSE, SecurityInfo)
                               );

                bDoPropagate = FALSE;
            }
            else
            {
                bDoPropagate = TRUE;
            }

        } while ((ERROR_SUCCESS != dwErr) && (NULL != ChildContext));
    }

    return FALSE;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: AccRewriteSetNamedRights                                         //
//                                                                            //
// Description: Set the security descriptor passed in on the object passed in //
//              by Name.                                                      //
//              This routine is exported by ntmarta and called by advapi32.   //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pObjectName]            Name of the Object                        //
//     [IN  ObjectType]             Type of the object                        //
//     [IN  SecurityInfo]           Security Information to be stamped        //
//     [IN  pSecurityDescriptor]    Security descriptor to be stamped         //
//     [IN  bSkipInheritanceComputation]  Whether to compute inherited aces   //
//                                        from the parent
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
AccRewriteSetNamedRights(
    IN     LPWSTR               pObjectName,
    IN     SE_OBJECT_TYPE       ObjectType,
    IN     SECURITY_INFORMATION SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN     BOOL                 bSkipInheritanceComputation
    )
{
    DWORD         dwErr                 = ERROR_SUCCESS;
    MARTA_CONTEXT Context               = NULL_MARTA_CONTEXT;
    BOOL          bDoPropagate          = FALSE;
    BOOL          bReadOldProtectedBits = FALSE;

    MARTA_OBJECT_TYPE_PROPERTIES ObjectTypeProperties;
    MARTA_SET_FUNCTION_CONTEXT   MartaSetFunctionContext;

    GENERIC_MAPPING      ZeroGenMap        = {0, 0, 0, 0};
    SECURITY_INFORMATION LocalSecurityInfo = (SECURITY_INFORMATION) 0;
    PSECURITY_DESCRIPTOR pOldSD            = NULL;

    //
    // Named calls are not valid only for the following object types.
    //

    switch (ObjectType)
    {
    case SE_FILE_OBJECT:
    case SE_SERVICE:
    case SE_PRINTER:
    case SE_REGISTRY_KEY:
    case SE_REGISTRY_WOW64_32KEY:
    case SE_LMSHARE:
    case SE_KERNEL_OBJECT:
    case SE_WINDOW_OBJECT:
    case SE_WMIGUID_OBJECT:
    case SE_DS_OBJECT:
    case SE_DS_OBJECT_ALL:
        break;
    case SE_PROVIDER_DEFINED_OBJECT:
    case SE_UNKNOWN_OBJECT_TYPE:
    default:
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Initialize the structure to hold the function pointers.
    //

    MartaInitializeSetContext(ObjectType, &MartaSetFunctionContext);


    //
    // Get the "Type" properties for the object,
    //

    ObjectTypeProperties.cbSize  = sizeof(ObjectTypeProperties);
    ObjectTypeProperties.dwFlags = 0;
    ObjectTypeProperties.GenMap  = ZeroGenMap;

    dwErr = (*(MartaSetFunctionContext.fGetTypeProperties))(&ObjectTypeProperties);

    CONDITIONAL_EXIT(dwErr, End);

    //
    // To make sure that NT4 applications do not wipe out PROTECTED bits, make a
    // note whether the caller knows what he is doing i.e. has passed in the
    // appropriate PROTECTED flags.
    //

    if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        if (!FLAG_ON(SecurityInfo, (PROTECTED_DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION)))
        {
            bReadOldProtectedBits  = TRUE;
            LocalSecurityInfo     |= DACL_SECURITY_INFORMATION;
        }
    }

    if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        if (!FLAG_ON(SecurityInfo, (PROTECTED_SACL_SECURITY_INFORMATION | UNPROTECTED_SACL_SECURITY_INFORMATION)))
        {
            bReadOldProtectedBits  = TRUE;
            LocalSecurityInfo     |= SACL_SECURITY_INFORMATION;
        }
    }

    //
    // Even for objects like Files/RegistryKeys manual propagation is required
    // only if DACl/SACL is to be set.
    //

    if ((FLAG_ON(ObjectTypeProperties.dwFlags, MARTA_OBJECT_TYPE_MANUAL_PROPAGATION_NEEDED_FLAG)) &&
        (FLAG_ON(SecurityInfo, (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION))))
    {
        dwErr = (*(MartaSetFunctionContext.fOpenNamedObject))(
                       pObjectName,
                       (*(MartaSetFunctionContext.fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, TRUE, SecurityInfo),
                       &Context
                       );

        if (ERROR_SUCCESS != dwErr)
        {
            bDoPropagate = FALSE;

            dwErr = (*(MartaSetFunctionContext.fOpenNamedObject))(
                           pObjectName,
                           (*(MartaSetFunctionContext.fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, FALSE, SecurityInfo),
                           &Context
                           );

            CONDITIONAL_EXIT(dwErr, End);
        }
        else
        {
            bDoPropagate = TRUE;
        }

        dwErr = MartaManualPropagation(
                    Context,
                    SecurityInfo,
                    pSecurityDescriptor,
                    &(ObjectTypeProperties.GenMap),
                    bDoPropagate,
                    bReadOldProtectedBits,
                    &MartaSetFunctionContext,
                    bSkipInheritanceComputation
                    );

        CONDITIONAL_EXIT(dwErr, End);
    }

    //
    // For object for which manual propagation is not required, stamp the SD
    // on the object.
    //

    else
    {
        if ((FLAG_ON(ObjectTypeProperties.dwFlags, MARTA_OBJECT_TYPE_INHERITANCE_MODEL_PRESENT_FLAG)) &&
            bReadOldProtectedBits)
        {
            dwErr = (*(MartaSetFunctionContext.fOpenNamedObject))(
                           pObjectName,
                           (*(MartaSetFunctionContext.fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, FALSE, SecurityInfo),
                           &Context
                           );

            CONDITIONAL_EXIT(dwErr, End);

            dwErr = (*(MartaSetFunctionContext.fGetRights))(
                           Context,
                           LocalSecurityInfo,
                           &pOldSD
                           );

            CONDITIONAL_EXIT(dwErr, End);

            //
            // If none of the PROTECTED flags are passed in then do the "right" thing.
            // Read the PROTECTED bit from the existing security descriptor and set it
            // in the new one.
            //

            if (NULL != pOldSD)
            {
                if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
                {
                    if (!FLAG_ON(SecurityInfo, (PROTECTED_DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION)))
                    {
                        ((PISECURITY_DESCRIPTOR) pSecurityDescriptor)->Control |= ((PISECURITY_DESCRIPTOR) pOldSD)->Control & SE_DACL_PROTECTED;

                    }
                }

                if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
                {
                    if (!FLAG_ON(SecurityInfo, (PROTECTED_SACL_SECURITY_INFORMATION | UNPROTECTED_SACL_SECURITY_INFORMATION)))
                    {
                        ((PISECURITY_DESCRIPTOR) pSecurityDescriptor)->Control |= ((PISECURITY_DESCRIPTOR) pOldSD)->Control & SE_SACL_PROTECTED;
                    }
                }
            }
        }
        else
        {
            dwErr = (*(MartaSetFunctionContext.fOpenNamedObject))(
                           pObjectName,
                           (*(MartaSetFunctionContext.fGetDesiredAccess))(WRITE_ACCESS_RIGHTS, FALSE, SecurityInfo),
                           &Context
                           );

            CONDITIONAL_EXIT(dwErr, End);
        }

        if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR) pSecurityDescriptor)->Control |= SE_DACL_AUTO_INHERIT_REQ;
        }

        if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR) pSecurityDescriptor)->Control |= SE_SACL_AUTO_INHERIT_REQ;
        }

        dwErr = (*(MartaSetFunctionContext.fSetRights))(
                       Context,
                       SecurityInfo,
                       pSecurityDescriptor
                       );

        CONDITIONAL_EXIT(dwErr, End);
    }

End:

    if (NULL != Context)
    {
        (VOID) (*(MartaSetFunctionContext.fCloseContext))(Context);
    }

    if (NULL != pOldSD)
    {
        AccFree(pOldSD);
    }

    return dwErr;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: AccRewriteSetHandleRights                                        //
//                                                                            //
// Description: Set the security descriptor passed in on the object passed in //
//              as Handle.                                                    //
//              This routine is exported by ntmarta and called by advapi32.   //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  Handle]                 Handle to the Object                      //
//     [IN  ObjectType]             Type of the object                        //
//     [IN  SecurityInfo]           Security Information to be stamped        //
//     [IN  pSecurityDescriptor]    Security descriptor to be stamped         //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
AccRewriteSetHandleRights(
    IN     HANDLE               Handle,
    IN     SE_OBJECT_TYPE       ObjectType,
    IN     SECURITY_INFORMATION SecurityInfo,
    IN OUT PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    DWORD         dwErr                 = ERROR_SUCCESS;
    MARTA_CONTEXT Context               = NULL_MARTA_CONTEXT;
    BOOL          bDoPropagate          = FALSE;
    BOOL          bReadOldProtectedBits = FALSE;

    MARTA_OBJECT_TYPE_PROPERTIES ObjectTypeProperties;
    MARTA_SET_FUNCTION_CONTEXT   MartaSetFunctionContext;

    GENERIC_MAPPING      ZeroGenMap        = {0, 0, 0, 0};
    SECURITY_INFORMATION LocalSecurityInfo = (SECURITY_INFORMATION) 0;
    PSECURITY_DESCRIPTOR pOldSD            = NULL;

    //
    // Handle calls are not valid for all object types.
    //

    switch (ObjectType)
    {
    case SE_FILE_OBJECT:
    case SE_SERVICE:
    case SE_PRINTER:
    case SE_REGISTRY_KEY:
    case SE_LMSHARE:
    case SE_KERNEL_OBJECT:
    case SE_WINDOW_OBJECT:
    case SE_WMIGUID_OBJECT:
        break;
    case SE_DS_OBJECT:
    case SE_DS_OBJECT_ALL:
    case SE_PROVIDER_DEFINED_OBJECT:
    case SE_UNKNOWN_OBJECT_TYPE:
    default:
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Initialize the structure to hold the function pointers.
    //

    MartaInitializeSetContext(ObjectType, &MartaSetFunctionContext);

    //
    // Get the "Type" properties for the object,
    //

    ObjectTypeProperties.cbSize  = sizeof(ObjectTypeProperties);
    ObjectTypeProperties.dwFlags = 0;
    ObjectTypeProperties.GenMap  = ZeroGenMap;

    dwErr = (*(MartaSetFunctionContext.fGetTypeProperties))(&ObjectTypeProperties);

    CONDITIONAL_EXIT(dwErr, End);

    //
    // To make sure that NT4 applications do not wipe out PROTECTED bits, make a
    // note whether the caller knows what he is doing i.e. has passed in the
    // appropriate PROTECTED flags.
    //

    if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        if (!FLAG_ON(SecurityInfo, (PROTECTED_DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION)))
        {
            bReadOldProtectedBits  = TRUE;
            LocalSecurityInfo     |= DACL_SECURITY_INFORMATION;
        }
    }

    if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        if (!FLAG_ON(SecurityInfo, (PROTECTED_SACL_SECURITY_INFORMATION | UNPROTECTED_SACL_SECURITY_INFORMATION)))
        {
            bReadOldProtectedBits  = TRUE;
            LocalSecurityInfo     |= SACL_SECURITY_INFORMATION;
        }
    }

    //
    // Even for objects like Files/RegistryKeys manual propagation is required
    // only if DACl/SACL is to be set.
    //

    if ((FLAG_ON(ObjectTypeProperties.dwFlags, MARTA_OBJECT_TYPE_MANUAL_PROPAGATION_NEEDED_FLAG)) &&
        (FLAG_ON(SecurityInfo, (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION))))
    {
        dwErr = (*(MartaSetFunctionContext.fOpenHandleObject))(
                       Handle,
                       (*(MartaSetFunctionContext.fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, TRUE, SecurityInfo),
                       &Context
                       );

        if (ERROR_SUCCESS != dwErr)
        {
            bDoPropagate = FALSE;

            dwErr = (*(MartaSetFunctionContext.fOpenHandleObject))(
                           Handle,
                           (*(MartaSetFunctionContext.fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, FALSE, SecurityInfo),
                           &Context
                           );

            CONDITIONAL_EXIT(dwErr, End);
        }
        else
        {
            bDoPropagate = TRUE;
        }

        dwErr = MartaManualPropagation(
                    Context,
                    SecurityInfo,
                    pSecurityDescriptor,
                    &(ObjectTypeProperties.GenMap),
                    bDoPropagate,
                    bReadOldProtectedBits,
                    &MartaSetFunctionContext,
                    FALSE  // Do not skip inheritance computation
                    );

        CONDITIONAL_EXIT(dwErr, End);
    }

    //
    // For object for which manual propagation is not required, stamp the SD
    // on the object.
    //

    else
    {
        if ((FLAG_ON(ObjectTypeProperties.dwFlags, MARTA_OBJECT_TYPE_INHERITANCE_MODEL_PRESENT_FLAG)) &&
            bReadOldProtectedBits)
        {
            dwErr = (*(MartaSetFunctionContext.fOpenHandleObject))(
                           Handle,
                           (*(MartaSetFunctionContext.fGetDesiredAccess))(MODIFY_ACCESS_RIGHTS, FALSE, SecurityInfo),
                           &Context
                           );

            CONDITIONAL_EXIT(dwErr, End);

            dwErr = (*(MartaSetFunctionContext.fGetRights))(
                           Context,
                           LocalSecurityInfo,
                           &pOldSD
                           );

            CONDITIONAL_EXIT(dwErr, End);

            //
            // If none of the PROTECTED flags are passed in then do the "right" thing.
            // Read the PROTECTED bit from the existing security descriptor and set it
            // in the new one.
            //

            if (NULL != pOldSD)
            {
                if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
                {
                    if (!FLAG_ON(SecurityInfo, (PROTECTED_DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION)))
                    {
                        ((PISECURITY_DESCRIPTOR) pSecurityDescriptor)->Control |= ((PISECURITY_DESCRIPTOR) pOldSD)->Control & SE_DACL_PROTECTED;
                    }
                }

                if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
                {
                    if (!FLAG_ON(SecurityInfo, (PROTECTED_SACL_SECURITY_INFORMATION | UNPROTECTED_SACL_SECURITY_INFORMATION)))
                    {
                        ((PISECURITY_DESCRIPTOR) pSecurityDescriptor)->Control |= ((PISECURITY_DESCRIPTOR) pOldSD)->Control & SE_SACL_PROTECTED;
                    }
                }
            }
        }
        else
        {
            dwErr = (*(MartaSetFunctionContext.fOpenHandleObject))(
                           Handle,
                           (*(MartaSetFunctionContext.fGetDesiredAccess))(WRITE_ACCESS_RIGHTS, FALSE, SecurityInfo),
                           &Context
                           );

            CONDITIONAL_EXIT(dwErr, End);
        }

        if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR) pSecurityDescriptor)->Control |= SE_DACL_AUTO_INHERIT_REQ;
        }

        if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR) pSecurityDescriptor)->Control |= SE_SACL_AUTO_INHERIT_REQ;
        }

        dwErr = (*(MartaSetFunctionContext.fSetRights))(
                       Context,
                       SecurityInfo,
                       pSecurityDescriptor
                       );

        CONDITIONAL_EXIT(dwErr, End);
    }

End:
    if (NULL != Context)
    {
        (VOID) (*(MartaSetFunctionContext.fCloseContext))(Context);
    }

    if (NULL != pOldSD)
    {
        AccFree(pOldSD);
    }

    return dwErr;
}

typedef struct _FN_OBJECT_FUNCTIONS
{
    ULONG Flags;
} FN_OBJECT_FUNCTIONS, *PFN_OBJECT_FUNCTIONS;

#define MARTA_NO_PARENT    (LONG) -1
#define MARTA_EXPLICIT_ACE  0

VOID
MartaInitializeIndexContext(
    IN  SE_OBJECT_TYPE                ObjectType,
    OUT PMARTA_INDEX_FUNCTION_CONTEXT pFunctionContext
    )
{
    pFunctionContext->fCloseContext    = MartaCloseContext[ObjectType];
    pFunctionContext->fOpenNamedObject = MartaOpenNamedObject[ObjectType];
    pFunctionContext->fGetRights       = MartaGetRights[ObjectType];
    pFunctionContext->fGetParentName   = MartaGetParentName[ObjectType];
}

typedef DWORD (*PFN_FREE) (IN PVOID Mem);

DWORD
AccFreeIndexArray(
    IN OUT PINHERITED_FROMW pInheritArray,
    IN USHORT AceCnt,
    IN PFN_FREE pfnFree
    );

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: AccGetInheritanceSource                                          //
//                                                                            //
// Description: Get the source of every inherited ace in the gicen acl.       //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN pObjectName]      Name of the object                               //
//     [IN ObjecType]        Type of the object ex. File/Reg/DS               //
//     [IN SecurityInfo]     Whether DACL/SACL                                //
//     [IN Container]        Whether Object or Container                      //
//     [IN ObjecTypeGuid]    Type of the object (for DS objects)              //
//     [IN pAcl]             DACL or SACL depending on SecurityInfo           //
//     [IN pGenericMapping]  GenericMapping for the object type               //
//     [IN pfnArray]         Function pointers when we support non-DS/FS/Reg  //
//     [OUT pInheritArray]    To return the results                           //
//                                                                            //
//                                                                            //
// Algorithm:                                                                 //
//     Initialize the output structure.                                       //
//     Read the Owner/Group info needed for CreatePrivateObjectSecurityEx.    // 
//     while (unmarked inherited aces exist)                                  //
//         Get the parent at the next level.                                  //
//         if we are at the root,                                             //
//             break                                                          //
//         Get the xAcl for the parent.                                       //
//         for ancestors other than the immediate parent                      //
//             Mask off inheritance flags for ACES with NP or ID              //
//         for immediate parent                                               //
//             Mask off inheritance flags for ACES with ID                    //
//         Call CreatePrivateObjectSecurityEx with the empty SD and ParentSD  // 
//             to get ExpectedSD                                              //
//         From the input xAcl,                                               //
//             mark unmarked common inherited aces                            //
//             Update count                                                   //
//         If the parent xAcl was protected,                                  //
//             break                                                          //
//                                                                            //
// Returns: ERROR_SUCCESS on successful completion of the routine             //
//          ERROR_XXXX    Otherwise                                           //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
AccGetInheritanceSource(
    IN  LPWSTR                   pObjectName,
    IN  SE_OBJECT_TYPE           ObjectType,
    IN  SECURITY_INFORMATION     SecurityInfo,
    IN  BOOL                     Container,
    IN  GUID                  ** pObjectTypeGuid OPTIONAL,
    IN  DWORD                    GuidCount,
    IN  PACL                     pAcl,
    IN  PGENERIC_MAPPING         pGenericMapping,
    IN  PFN_OBJECT_MGR_FUNCTS    pfnArray OPTIONAL,
    OUT PINHERITED_FROMW         pInheritArray
    )
{
    SECURITY_DESCRIPTOR  EmptySD;
    MARTA_INDEX_FUNCTION_CONTEXT MartaIndexFunctionContext;

    USHORT               i               = 0;
    USHORT               j               = 0;
    USHORT               AceCnt          = 0;
    USHORT               ParentAceCnt    = 0;
    USHORT               ExpectedAceCnt  = 0;
    USHORT               InheritedAceCnt = 0;
    USHORT               ParentIndex     = 0;
    ULONG                ProtectedBit    = 0;
    UCHAR                FlagsToKeep     = 0;
    DWORD                dwErr           = ERROR_SUCCESS;
    BOOL                 bKnownObject    = FALSE;
    BOOL                 Match           = TRUE;
    BOOL                 ProtectedParent = FALSE;
    LPWSTR               ParentName      = NULL;
    LPWSTR               OldName         = NULL;
    PACL                 pParentAcl      = NULL;
    PACL                 pExpectedAcl    = NULL;
    PACE_HEADER          pAce            = NULL;
    PACE_HEADER          pParentAce      = NULL;
    PACE_HEADER          pExpectedAce    = NULL;
    PSECURITY_DESCRIPTOR pSD             = NULL;
    PSECURITY_DESCRIPTOR pNewSD          = NULL;
    PSECURITY_DESCRIPTOR pParentSD       = NULL;
    MARTA_CONTEXT        Context         = NULL_MARTA_CONTEXT;

    //
    // Simple error checks to make sure that the input is valid.
    //

    if ((NULL == pAcl) || (!RtlValidAcl(pAcl)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ((NULL == pObjectName) || (NULL == pInheritArray) || (NULL == pGenericMapping))
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make sure that the caller requested for either the SACL or the DACL and
    // nothing else.
    // Record the corresponding protected flag. This will be used later on.
    //

    switch (SecurityInfo)
    {
    case DACL_SECURITY_INFORMATION:
        ProtectedBit = SE_DACL_PROTECTED;
        break;
    case SACL_SECURITY_INFORMATION:
        ProtectedBit = SE_SACL_PROTECTED;
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    //
    // The function is supported for just files, registry, and DS objects.
    //

    switch (ObjectType)
    {
    case SE_FILE_OBJECT:
    case SE_REGISTRY_KEY:
    case SE_DS_OBJECT:
    case SE_DS_OBJECT_ALL:

        bKnownObject = TRUE;
        MartaInitializeIndexContext(ObjectType, &MartaIndexFunctionContext);
        break;

    default:
        return ERROR_INVALID_PARAMETER;
    }

    AceCnt = pAcl->AceCount;

    //
    // Return for an empty acl.
    //

    if (0 == AceCnt)
    {
        return ERROR_SUCCESS;
    }

    //
    // We need to mask off certain aceflags for ancestors other than the parent.
    //

    if (Container)
    {
        FlagsToKeep = ~(OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE);
    }
    else
    {
        FlagsToKeep = ~OBJECT_INHERIT_ACE;
    }

    //
    // Run thru the acl and mark the aces as either INHERITED or EXPLICIT.
    // Keep a count of inherited aces and set return values to default.
    //

    pAce = (PACE_HEADER) FirstAce(pAcl);
    for (i = 0; i < AceCnt; pAce = (PACE_HEADER) NextAce(pAce), i++)
    {
        if (FLAG_ON(pAce->AceFlags, INHERITED_ACE))
        {
            pInheritArray[i].GenerationGap = MARTA_NO_PARENT;
            InheritedAceCnt++;
        }
        else
        {
            pInheritArray[i].GenerationGap = MARTA_EXPLICIT_ACE;
        }

        pInheritArray[i].AncestorName = NULL;
    }

    //
    // Return for an acl with no inherited aces.
    //

    if (0 == InheritedAceCnt)
    {
        return ERROR_SUCCESS;
    }

    InitializeSecurityDescriptor(&EmptySD, SECURITY_DESCRIPTOR_REVISION);

    if (bKnownObject)
    {
        //
        // Read the owner and group information on the object.
        //

        dwErr = (*(MartaIndexFunctionContext.fOpenNamedObject))(
                       pObjectName,
                       READ_CONTROL,
                       &Context
                       );

        CONDITIONAL_EXIT(dwErr, End);

        dwErr = (*(MartaIndexFunctionContext.fGetRights))(
                       Context,
                       OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION,
                       &pSD
                       );

        // Note: This has to be freed immediately!!

        (VOID) (*(MartaIndexFunctionContext.fCloseContext))(Context);

        CONDITIONAL_EXIT(dwErr, End);
    }
    else
    {
        //
        // Get the owner and group information.
        //
    }

    //
    // Set the owner and group information in pSD.
    //

    if (!SetSecurityDescriptorOwner(
             &EmptySD,
             RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD),
             FALSE))
    {
        dwErr = GetLastError();
        goto End;
    }

    if (!SetSecurityDescriptorGroup(
             &EmptySD,
             RtlpGroupAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pSD),
             FALSE))
    {
        dwErr = GetLastError();
        goto End;
    }


    if (bKnownObject)
    {
        dwErr = (*(MartaIndexFunctionContext.fGetParentName))(
                       pObjectName,
                       &ParentName
                       );

        CONDITIONAL_EXIT(dwErr, End);

        //
        // A null parent name means we have hit the root of the hierarchy.
        //

        if (NULL == ParentName)
        {
            goto End;
        }
    }
    else
    {
    }

    OldName = ParentName;

    //
    // Run thru the list of ancestors as long as
    //     1. we have inherited aces whose ancestor is yet to be found AND
    //     2. we have not yet hit an ancestor that is PROTECTED.
    //

    for (ParentIndex = 1; InheritedAceCnt > 0 && !ProtectedParent; ParentIndex++)
    {
        if (bKnownObject)
        {
#ifdef MARTA_DEBUG
            wprintf(L"\n\nParentIndex = %d, ParentName = %s\n", ParentIndex, ParentName);
#endif

            //
            // Get parent security descriptor
            //

            dwErr = AccRewriteGetNamedRights(
                        ParentName,
                        ObjectType,
                        SecurityInfo,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        &pParentSD
                        );

            CONDITIONAL_EXIT(dwErr, End);

        }
        else
        {
            // Get the ParentName and ParentSD
        }

        //
        // This might happen if we were to extend the API to support new object
        // types.
        //

        if (NULL == pParentSD)
        {
            dwErr = ERROR_ACCESS_DENIED;
            goto End;
        }

        //
        // Get the Acl
        //

        if (DACL_SECURITY_INFORMATION == SecurityInfo)
        {
            pParentAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pParentSD);
        }
        else
        {
            pParentAcl = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pParentSD);
        }

        //
        // Null acls are really protected.
        //

        if (NULL == pParentAcl)
        {
            break;
        }

        ParentAceCnt = pParentAcl->AceCount;

        if (ParentIndex > 1)
        {
            //
            // This is an ancestor other then the immediate parent. Mask off its
            // inheritable inherited aces as well as those with NP flag in them.
            // Now we will not see them in the inherited part of the acl after
            // calling CreatePrivateObjectSecurityEx.
            // We save on multiple calls to CreatePrivateObjectSecurityEx by
            // masking off the NP aces.
            //

            pParentAce = (PACE_HEADER) FirstAce(pParentAcl);
            for (i = 0; i < ParentAceCnt; pParentAce = (PACE_HEADER) NextAce(pParentAce), i++)
            {
                if (FLAG_ON(pParentAce->AceFlags, INHERITED_ACE) ||
                    FLAG_ON(pParentAce->AceFlags, NO_PROPAGATE_INHERIT_ACE))
                {
                    pParentAce->AceFlags &= FlagsToKeep;
                }
            }
        }
        else
        {
            //
            // This is the immediate parent. Mask off its inheritable inherited
            // aces so that we will not see them in the inherited part of the
            // acl after calling CreatePrivateObjectSecurityEx.
            //

            pParentAce = (PACE_HEADER) FirstAce(pParentAcl);
            for (i = 0; i < ParentAceCnt; pParentAce = (PACE_HEADER) NextAce(pParentAce), i++)
            {
                if (FLAG_ON(pParentAce->AceFlags, INHERITED_ACE))
                {
                    pParentAce->AceFlags &= FlagsToKeep;
                }
            }
        }

        //
        // Merge the Empty SD with the modified parent SD.
        //

        if (!CreatePrivateObjectSecurityWithMultipleInheritance(
                 pParentSD,
                 &EmptySD,
                 &pNewSD,
                 pObjectTypeGuid,
                 GuidCount,
                 Container,
                 (SEF_DACL_AUTO_INHERIT | SEF_SACL_AUTO_INHERIT | SEF_AVOID_OWNER_CHECK | SEF_AVOID_PRIVILEGE_CHECK),
                 NULL,
                 pGenericMapping
                 ))
        {
            dwErr = GetLastError();
            goto End;
        }

        //
        // Get the ChildAcl
        //

        if (DACL_SECURITY_INFORMATION == SecurityInfo)
        {
            pExpectedAcl = RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pNewSD);
        }
        else
        {
            pExpectedAcl = RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pNewSD);
        }

        if (NULL == pExpectedAcl)
        {
#ifdef MARTA_DEBUG
        wprintf(L"ExpectedAcl is NULL!!!\n\n");
#endif
            pExpectedAce = NULL;
            ExpectedAceCnt = 0;
        }
        else
        {
            pExpectedAce = (PACE_HEADER) FirstAce(pExpectedAcl);
            ExpectedAceCnt = pExpectedAcl->AceCount;
        }

        Match = FALSE;

#ifdef MARTA_DEBUG
        wprintf(L"ExpectedAceCnt = %d, AceCnt = %d\n", ExpectedAceCnt, AceCnt);
#endif

        //
        // for all expected inherited aces
        //   if there's a match with an "avaliable" ace in the supplied ACL
        //     Record the name and the level of the ancestor in the output array
        //

        for (i = 0; i < ExpectedAceCnt; pExpectedAce = (PACE_HEADER) NextAce(pExpectedAce), i++)
        {
            pAce = (PACE_HEADER) FirstAce(pAcl);
            for (j = 0; j < AceCnt; pAce = (PACE_HEADER) NextAce(pAce), j++)
            {
                //
                // Skip aces whose ancestor has already been determined.
                //

                if (MARTA_NO_PARENT != pInheritArray[j].GenerationGap)
                {
#ifdef MARTA_DEBUG
                    wprintf(L"Ace %d taken by level %d, name = %s\n", j,
                            pInheritArray[j].GenerationGap, pInheritArray[j].AncestorName);
#endif

                    continue;
                }

#ifdef MARTA_DEBUG
                wprintf(L"Ace matching i = %d, j = %d, Parent = %s\n", i, j, ParentName);
#endif

                //
                // Check if the aces match.
                //

                if ((pAce->AceSize == pExpectedAce->AceSize) &&
                    !memcmp(pAce, pExpectedAce, pAce->AceSize))
                {
#ifdef MARTA_DEBUG
                    wprintf(L"Ace match found i = %d, j = %d, left = %d, Parent = %s\n",
                            i, j, InheritedAceCnt, ParentName);
#endif

                    //
                    // Record the name and level of the parent.
                    //

                    pInheritArray[j].GenerationGap = ParentIndex;
                    pInheritArray[j].AncestorName = ParentName;

                    //
                    // A match has been found.
                    //

                    Match = TRUE;

                    //
                    // Decrement the "available" ace count.
                    //

                    InheritedAceCnt--;

                    break;
                }
            }

        }

        //
        // Check if the ancestor is protected. The loop stops after we have
        // processed a protected ancestor.
        //

        ProtectedParent = FLAG_ON(((PISECURITY_DESCRIPTOR) pParentSD)->Control, ProtectedBit);

        if (NULL != pParentSD)
        {
            if (bKnownObject)
            {
                LocalFree(pParentSD);
            }
            else
            {
            }

            pParentSD = NULL;
        }

        ParentName = NULL;

        //
        // Get the name of the next ancestor only if we still need to continue.
        //

        if (InheritedAceCnt > 0 && !ProtectedParent)
        {
            dwErr = (*(MartaIndexFunctionContext.fGetParentName))(
                           OldName,
                           &ParentName
                           );

        }

        //
        // Free the ancestor name if no aces were inherited from it.
        //

        if (!Match)
        {
            if (bKnownObject)
            {
                LocalFree(OldName);
            }
            else
            {
            }
        }

        OldName = NULL;

        CONDITIONAL_EXIT(dwErr, End);

        //
        // A null parent name means we have hit the root of the hierarchy.
        //

        if (NULL == ParentName)
        {
            break;
        }

        OldName = ParentName;
    }

End:

    if (bKnownObject)
    {
        if (ERROR_SUCCESS != dwErr)
        {
            AccFreeIndexArray(pInheritArray, AceCnt, NULL);
        }

        if (NULL != pSD)
        {
            LocalFree(pSD);
        }

        if (NULL != OldName)
        {
            LocalFree(OldName);
        }

        if (NULL != pParentSD)
        {
            LocalFree(pParentSD);
        }
    }
    else
    {
    }

    return dwErr;
}


#ifdef MAX_INDEX_LEVEL
#undef MAX_INDEX_LEVEL
#endif

#define MAX_INDEX_LEVEL 10

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: AccFreeIndexArray                                              //
//                                                                            //
// Description: Free the strings allocated and stored in the array.           //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN OUT pInheritArray]    Array to free results from                   //
//     [IN AceCnt]               Number of elements in the array              //
//     [IN pfnFree]              Function to use for freeing                  //
//                                                                            //
// Algorithm:                                                                 //
//     Note that there is a single allocated string for all nodes at the same //
//     level.                                                                 //
//     In (1, p1), (2, p2), (3, p3), (1, p1) (1, p1) (2, p2)                  //
//         we free just three strings p1, p2 and p3.                          //
//     Initialize the boolean 'freed' array to TRUE                           //
//     For all elements of the array,                                         //
//         if (InheritedAce AND Ancestor name non-NULL AND Not already freed) //
//             Mark as Freed and free the string.                             //
//                                                                            //
// Returns: ERROR_SUCCESS on successful completion of the routine             //
//          ERROR_XXXX    Otherwise                                           //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
AccFreeIndexArray(
    IN OUT PINHERITED_FROMW pInheritArray,
    IN USHORT AceCnt,
    IN PFN_FREE pfnFree
    )
{
    USHORT i = 0;
    LONG MaxLevel = 0;
    BOOL LevelBuffer[MAX_INDEX_LEVEL + 1];
    PBOOL pLevelStatus = (PBOOL) LevelBuffer;

    for (i = 0; i < AceCnt; i++)
    {
        if (pInheritArray[i].GenerationGap > MaxLevel)
        {
            MaxLevel = pInheritArray[i].GenerationGap;
        }
    }

    if (MaxLevel <= 0)
    {
        return ERROR_SUCCESS;
    }

    if (MaxLevel > MAX_INDEX_LEVEL)
    {
        pLevelStatus = (PBOOL) AccAlloc(sizeof(BOOL) * (MaxLevel + 1));

        if (NULL == pLevelStatus)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    for (i = 0; i <= MaxLevel; i++)
    {
        pLevelStatus[i] = TRUE;
    }

    for (i = 0; i < AceCnt; i++)
    {
        if ((pInheritArray[i].GenerationGap > 0) &&
            (NULL != pInheritArray[i].AncestorName) &&
            (pLevelStatus[pInheritArray[i].GenerationGap]))
        {
            pLevelStatus[pInheritArray[i].GenerationGap] = FALSE;
            if (NULL == pfnFree)
            {
                AccFree(pInheritArray[i].AncestorName);
            }
            else
            {
                pfnFree(pInheritArray[i].AncestorName);
            }
        }
    }

    if (pLevelStatus != (PBOOL) LevelBuffer)
    {
        AccFree(pLevelStatus);
    }

    return ERROR_SUCCESS;
}


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: AccTreeResetNamedSecurityInfo                                    //
//                                                                            //
// Description: Reset permissions on the subtree starting at pObjectName.     //
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pObjectName]    Name of the Object                                //
//     [IN  ObjectType]     Type of the object                                //
//     [IN  SecurityInfo]   Security info to reset                            //
//     [IN  pOwner]         Owner sid to reset                                //
//     [IN  pGroup]         Group sid to reset                                //
//     [IN  pDacl]          Dacl to reset                                     //
//     [IN  pSacl]          Sacl to reset                                     //
//     [IN  KeepExplicit]   if TRUE, retain explicit aces on the subtree, not //
//                          including the object.                             //
//     [IN  fnProgress]     Caller supplied callback function                 //
//     [IN  ProgressInvokeSetting] To determine if callback should be invoked.//
//                                     callback function.                     //
//     [IN  Args]                      Arguments supplied by the caller       //
//                                                                            //
// Returns:  TRUE if reset succeeded.                                         //
//           FALSE o/w                                                        //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

DWORD
AccTreeResetNamedSecurityInfo(
    IN LPWSTR               pObjectName,
    IN SE_OBJECT_TYPE       ObjectType,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSID                 pOwner OPTIONAL,
    IN PSID                 pGroup OPTIONAL,
    IN PACL                 pDacl OPTIONAL,
    IN PACL                 pSacl OPTIONAL,
    IN BOOL                 KeepExplicit,
    IN FN_PROGRESS          fnProgress OPTIONAL,
    IN PROG_INVOKE_SETTING  ProgressInvokeSetting,
    IN PVOID                Args OPTIONAL
    )
{
    MARTA_OBJECT_TYPE_PROPERTIES ObjectTypeProperties;
    MARTA_SET_FUNCTION_CONTEXT   MartaSetFunctionContext;
    MARTA_OBJECT_PROPERTIES      ObjectProperties;
    SECURITY_DESCRIPTOR          TmpSD;
    UCHAR                        Buffer[2 * sizeof(ACL)];
    ACL                          EmptyDacl;
    ACL                          EmptySacl;

    SECURITY_INFORMATION LocalSeInfo     = 0;
    PSID                 LocalGroup      = pGroup;
    PSID                 LocalOwner      = pOwner;
    ACCESS_MASK          LocalAccessMask = 0;
    MARTA_CONTEXT        Context         = NULL_MARTA_CONTEXT;
    MARTA_CONTEXT        ParentContext   = NULL_MARTA_CONTEXT;
    GENERIC_MAPPING      ZeroGenMap      = {0, 0, 0, 0};
    PSECURITY_DESCRIPTOR pOldSD          = NULL;
    PSECURITY_DESCRIPTOR pParentSD       = NULL;
    PSECURITY_DESCRIPTOR pNewSD          = NULL;
    DWORD                dwErr           = ERROR_SUCCESS;
    BOOL                 bIsContainer    = FALSE;
    HANDLE               ProcessHandle   = NULL;
    HANDLE               ThreadHandle    = NULL;
    ACCESS_MASK          AccessMask      = 0;
    ACCESS_MASK          RetryAccessMask = 0;
    ACCESS_MASK          MaxAccessMask   = 0;
    BOOL                 bRetry          = FALSE;
    BOOL                 bSetWorked      = FALSE;
    PROG_INVOKE_SETTING  Operation       = ProgressInvokeSetting;
    SECURITY_INFORMATION TmpSeInfo       = (OWNER_SECURITY_INFORMATION |
                                            GROUP_SECURITY_INFORMATION );

    LPWSTR               NtObjectName          = NULL;


    //
    // TmpSeInfo records whether Owner + Group sids have been supplied by the
    // caller.
    //

    TmpSeInfo = (SecurityInfo & TmpSeInfo) ^ TmpSeInfo;

    //
    // Initialize the dummy security descriptor. This may be changed by the
    // recursive calls.
    //

    InitializeSecurityDescriptor(&TmpSD, SECURITY_DESCRIPTOR_REVISION);

    //
    // Initialize the function pointers based on the object type.
    //

    MartaInitializeSetContext(ObjectType, &MartaSetFunctionContext);

    //
    // Basic error checks for owner and group.
    //

    if (FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
    {
        if ((NULL == pOwner) || !RtlValidSid(pOwner))
        {
            return ERROR_INVALID_SID;
        }
    }

    if (FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
    {
        if ((NULL == pGroup) || !RtlValidSid(pGroup))
        {
            return ERROR_INVALID_SID;
        }
    }

    //
    // For both DACL and SACL:
    //   If the caller requested for inheritance blocking
    //     set the appropriate bit in TmpSD
    //   else
    //     note that the parent Acl should be read for computing inherited aces
    //   Do basic error checks on the Acl.
    //

    if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {

        if (FLAG_ON(SecurityInfo, PROTECTED_DACL_SECURITY_INFORMATION))
        {
            TmpSD.Control |= SE_DACL_PROTECTED;
        }
        else
        {
            LocalSeInfo |= DACL_SECURITY_INFORMATION;
        }

        if ((NULL == pDacl) || !RtlValidAcl(pDacl))
        {
            return ERROR_INVALID_ACL;
        }

        if (FALSE == SetSecurityDescriptorDacl(&TmpSD, TRUE, pDacl, FALSE))
        {
            return GetLastError();
        }
    }

    if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        if (FLAG_ON(SecurityInfo, PROTECTED_SACL_SECURITY_INFORMATION))
        {
            TmpSD.Control |= SE_SACL_PROTECTED;
        }
        else
        {
            LocalSeInfo |= SACL_SECURITY_INFORMATION;
        }

        if ((NULL == pSacl) || !RtlValidAcl(pSacl))
        {
            return ERROR_INVALID_ACL;
        }

        if (FALSE == SetSecurityDescriptorSacl(&TmpSD, TRUE, pSacl, FALSE))
        {
            return GetLastError();
        }
    }

    if (FLAG_ON(SecurityInfo, (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)))
    {
        //
        // We need read as well as write access to take care of CO/CG.
        //

        MaxAccessMask = (*(MartaSetFunctionContext.fGetDesiredAccess))(
                               MODIFY_ACCESS_RIGHTS,
                               TRUE,
                               SecurityInfo
                               );

        AccessMask = (*(MartaSetFunctionContext.fGetDesiredAccess))(
                            MODIFY_ACCESS_RIGHTS,
                            FALSE,
                            SecurityInfo
                            );
    }
    else
    {
        //
        // We only need WRITE access if we are not setting any ACL.
        //

        MaxAccessMask = (*(MartaSetFunctionContext.fGetDesiredAccess))(
                               WRITE_ACCESS_RIGHTS,
                               TRUE,
                               SecurityInfo
                               );

        AccessMask = (*(MartaSetFunctionContext.fGetDesiredAccess))(
                            WRITE_ACCESS_RIGHTS,
                            FALSE,
                            SecurityInfo
                            );
    }

    RetryAccessMask = (*(MartaSetFunctionContext.fGetDesiredAccess))(
                             NO_ACCESS_RIGHTS,
                             TRUE,
                             SecurityInfo
                             );

    //
    // Open the object for maximum access that may be needed for computing
    // new SD, setting it on the object and Listing the subtree below this node.
    //

    dwErr = (*(MartaSetFunctionContext.fOpenNamedObject))(
                   pObjectName,
                   MaxAccessMask,
                   &Context
                   );

    if (ERROR_SUCCESS != dwErr)
    {
        //
        // We did not have List permission. Open the object for computing the
        // new SD and setting it on the object.
        //

        dwErr = (*(MartaSetFunctionContext.fOpenNamedObject))(
                       pObjectName,
                       AccessMask,
                       &Context
                       );

        CONDITIONAL_EXIT(dwErr, End);

        //
        // Note that we must retry List and propagate on the subtree.
        //

        bRetry = TRUE;
    }

    if (SE_FILE_OBJECT == ObjectType) 
    {
        dwErr = (*(MartaSetFunctionContext.fGetNameFromContext))(
                             NULL, // Special case of the root of the subtree.
                             NULL, // Special case of the root of the subtree.
                             Context,
                             &NtObjectName
                             );

        CONDITIONAL_EXIT(dwErr, End);
    }

    //
    // Read the object atributes to figure out whether the object is a container.
    //

    ObjectProperties.cbSize  = sizeof(ObjectProperties);
    ObjectProperties.dwFlags = 0;

    dwErr = (*(MartaSetFunctionContext.fGetProperties))(
                   Context,
                   &ObjectProperties
                   );

    CONDITIONAL_EXIT(dwErr, End);

    bIsContainer = FLAG_ON(ObjectProperties.dwFlags, MARTA_OBJECT_IS_CONTAINER);

    //
    // LocalSeInfo != corresponds to
    //     Resetting ACL(s) in LocalSeInfo and they should not be PROTECTED.
    //
    // Read the existing ACL(s) on the parent.
    //

    if (0 != LocalSeInfo)
    {
        LocalAccessMask = (*(MartaSetFunctionContext.fGetDesiredAccess))(
                                 READ_ACCESS_RIGHTS,
                                 FALSE,
                                 LocalSeInfo
                                 );

        dwErr = (*(MartaSetFunctionContext.fGetParentContext))(
                       Context,
                       LocalAccessMask,
                       &ParentContext
                       );

        CONDITIONAL_EXIT(dwErr, End);

        if (NULL != ParentContext)
        {
            dwErr = (*(MartaSetFunctionContext.fGetRights))(
                           ParentContext,
                           SecurityInfo,
                           &pParentSD
                           );

            (VOID) (*(MartaSetFunctionContext.fCloseContext))(ParentContext);

            CONDITIONAL_EXIT(dwErr, End);
        }
    }

    if (FLAG_ON(SecurityInfo, (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)))
    {
        //
        // Read the owner and group info from the object if it has not been
        // supplied by the caller.
        //

        if (!((FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION)) &&
             (FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))))
        {
            dwErr = (*(MartaSetFunctionContext.fGetRights))(
                           Context,
                           TmpSeInfo,
                           &pOldSD
                           );

            CONDITIONAL_EXIT(dwErr, End);
        }

        //
        // If Owner sid has not been provided by the caller, pick it up from the
        // existing security descriptor.
        //

        LocalOwner = pOwner;

        if (NULL == LocalOwner)
        {
            LocalOwner = RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldSD);
        }

        //
        // Set the owner sid in the TmpSd.
        //

        if (FALSE == SetSecurityDescriptorOwner(
                         &TmpSD,
                         LocalOwner,
                         FALSE))
        {
            dwErr = GetLastError();

            CONDITIONAL_EXIT(dwErr, End);
        }

        //
        // If Group sid has not been provided by the caller, pick it up from the
        // existing security descriptor.
        //

        if (NULL == LocalGroup)
        {
            LocalGroup = RtlpGroupAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldSD);
        }

        //
        // Set the group sid in the TmpSd.
        //

        if (FALSE == SetSecurityDescriptorGroup(
                         &TmpSD,
                         LocalGroup,
                         FALSE))
        {
            dwErr = GetLastError();

            CONDITIONAL_EXIT(dwErr, End);
        }

        dwErr = GetCurrentToken(&ProcessHandle);

        CONDITIONAL_EXIT(dwErr, End);

        ObjectTypeProperties.cbSize  = sizeof(ObjectTypeProperties);
        ObjectTypeProperties.dwFlags = 0;
        ObjectTypeProperties.GenMap  = ZeroGenMap;

        //
        // Get information regarding the object type.
        //

        dwErr = (*(MartaSetFunctionContext.fGetTypeProperties))(&ObjectTypeProperties);

        CONDITIONAL_EXIT(dwErr, End);

        MARTA_TURN_OFF_IMPERSONATION;

        CONDITIONAL_EXIT(dwErr, End);

        //
        // Compute the new security descriptor.
        //

        if (FALSE == CreatePrivateObjectSecurityEx(
                         pParentSD,
                         &TmpSD,
                         &pNewSD,
                         NULL,
                         bIsContainer,
                         (SEF_DACL_AUTO_INHERIT | SEF_SACL_AUTO_INHERIT | SEF_AVOID_OWNER_CHECK | SEF_AVOID_PRIVILEGE_CHECK),
                         ProcessHandle,
                         &ObjectTypeProperties.GenMap
                         ))
        {
            dwErr = GetLastError();
        }

        MARTA_TURN_ON_IMPERSONATION;

        CONDITIONAL_EXIT(dwErr, End);

        //
        // Set the owner and the group fields in TmpSD to NULL if the caller
        // did not want to set these.
        //

        if (NULL == pOwner)
        {
            if (FALSE == SetSecurityDescriptorOwner(
                             &TmpSD,
                             NULL,
                             FALSE))
            {
                dwErr = GetLastError();
            }

            CONDITIONAL_EXIT(dwErr, End);
        }

        if (NULL == pGroup)
        {
            if (FALSE == SetSecurityDescriptorGroup(
                             &TmpSD,
                             NULL,
                             FALSE))
            {
                dwErr = GetLastError();
            }

            CONDITIONAL_EXIT(dwErr, End);
        }

        //
        // Set the DACL to Empty if the caller requested for resetting the DACL.
        //

        if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
        {
            if (FALSE == InitializeAcl(&EmptyDacl, sizeof(ACL), ACL_REVISION))
            {
                return ERROR_ACCESS_DENIED;
            }

            if (FALSE == SetSecurityDescriptorDacl(
                             &TmpSD,
                             TRUE,
                             &EmptyDacl,
                             FALSE))
            {
                return GetLastError();
            }
        }

        //
        // Set the SACL to Empty if the caller requested for resetting the SACL.
        //

        if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
        {
            if (FALSE == InitializeAcl(&EmptySacl, sizeof(ACL), ACL_REVISION))
            {
                return ERROR_ACCESS_DENIED;
            }

            if (FALSE == SetSecurityDescriptorSacl(
                             &TmpSD,
                             TRUE,
                             &EmptySacl,
                             FALSE))
            {
                return GetLastError();
            }
        }

        //
        // We now have TmpSD with
        //     Owner Sid     if SecurityInfo contains OWNER_SECURITY_INFORMATION
        //     Group Sid     if SecurityInfo contains GROUP_SECURITY_INFORMATION
        //     Empty DACL    if SecurityInfo contains DACL_SECURITY_INFORMATION
        //     Empty SACL    if SecurityInfo contains SACL_SECURITY_INFORMATION
        //

    }
    else
    {
        //
        // The caller requested for resetting owner and/or group.
        // Set these in the TmpSD which will be passed to the recursive routine.
        //

        if (FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
        {
            if (FALSE == SetSecurityDescriptorOwner(
                             &TmpSD,
                             LocalOwner,
                             FALSE))
            {
                dwErr = GetLastError();
            }

            CONDITIONAL_EXIT(dwErr, End);
        }

        if (FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
        {
            if (FALSE == SetSecurityDescriptorGroup(
                             &TmpSD,
                             LocalGroup,
                             FALSE))
            {
                dwErr = GetLastError();
            }

            CONDITIONAL_EXIT(dwErr, End);
        }

        //
        // This is also out New SD to set on the object.
        //

        pNewSD = &TmpSD;
    }

    //
    // If the child is a container then update the subtree underneath it.
    //

    if (bIsContainer)
    {
        TmpSD.Control &= ~(SE_DACL_PROTECTED | SE_SACL_PROTECTED);

        if (!bRetry)
        {
            bRetry = MartaResetTree(
                         pObjectName,
                         NtObjectName,
                         SecurityInfo,
                         TmpSeInfo,
                         pNewSD,
                         &TmpSD,
                         Context,
                         ProcessHandle,
                         &MartaSetFunctionContext,
                         &ObjectTypeProperties.GenMap,
                         MaxAccessMask,
                         AccessMask,
                         RetryAccessMask,
                         &Operation,
                         fnProgress,
                         Args,
                         KeepExplicit
                         );
        }
    }
    else
    {
        bRetry = FALSE;
    }

    //
    // Set the computed security descriptor on the object.
    //

    if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
    {
        ((PISECURITY_DESCRIPTOR) pNewSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
    }

    if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
    {
        ((PISECURITY_DESCRIPTOR) pNewSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
    }

    dwErr = (*(MartaSetFunctionContext.fSetRights))(
                   Context,
                   SecurityInfo,
                   pNewSD
                   );

    CONDITIONAL_EXIT(dwErr, End);

    //
    // Note that the set operation on the object is successful.
    //

    bSetWorked = TRUE;

    //
    // Abort if the progress function requested a "Cancel" in the subtree
    // below this node. The value is propagated all the way to the root as
    // the stack unwinds.
    //

    if (ProgressCancelOperation == Operation)
    {
        goto End;
    }

    //
    // If propagation had failed in the first attept then try again. This is to
    // cover the case when the container can be enumerated after setting the new
    // security.
    //

    if (bRetry && bIsContainer && (SecurityInfo & DACL_SECURITY_INFORMATION))
    {

Retry:

         bRetry = FALSE;

        //
        // Reopen the object for List and retry on the subtree. Note that for
        // file objects this is just a dummy routine. The actual reopen happens
        // in FindFirst.
        //

        dwErr = (*(MartaSetFunctionContext.fReopenOrigContext))(
                            Context,
                            RetryAccessMask
                            );

        CONDITIONAL_EXIT(dwErr, End);

        bRetry = MartaResetTree(
                     pObjectName,
                     NtObjectName,
                     SecurityInfo,
                     TmpSeInfo,
                     pNewSD,
                     &TmpSD,
                     Context,
                     ProcessHandle,
                     &MartaSetFunctionContext,
                     &ObjectTypeProperties.GenMap,
                     MaxAccessMask,
                     AccessMask,
                     RetryAccessMask,
                     &Operation,
                     fnProgress,
                     Args,
                     KeepExplicit
                     );

        //
        // Retry failed. We should give a callback stating enum failed.
        //

        if (bRetry)
        {
            switch (Operation)
            {
            case ProgressInvokeNever:
                break;

            case ProgressInvokeOnError:

                if (ERROR_SUCCESS == dwErr)
                {
                    break;
                }

                //
                // Fallthrough is intended!!
                //

            case ProgressInvokeEveryObject:

                if (NULL != fnProgress)
                {
                    fnProgress(
                        pObjectName,
                        ERROR_ACCESS_DENIED,
                        &Operation,
                        Args,
                        TRUE
                        );

                    //
                    // This was the latest feature request by HiteshR. At this
                    // point, retry has failed, but the caller has made some
                    // changes and expects retry to work okay now.
                    //

                    if (ProgressRetryOperation == Operation)
                    {
                        Operation = ProgressInvokeEveryObject;
                        goto Retry;
                    }
                }

                break;

            default:
                break;
            }
        }
    }
End:

    if (bRetry && bIsContainer) 
    {
        dwErr = ERROR_ACCESS_DENIED;
    }

    switch (Operation)
    {
    case ProgressInvokeNever:
        break;

    case ProgressInvokeOnError:

        if (ERROR_SUCCESS == dwErr)
        {
            break;
        }

        //
        // Fallthrough is intended!!
        //

    case ProgressInvokeEveryObject:

        if (NULL != fnProgress)
        {
            fnProgress(
                pObjectName,
                dwErr,
                &Operation,
                Args,
                bSetWorked
                );

            //
            // This was the latest feature request by HiteshR. At this
            // point, retry has failed, but the caller has made some
            // changes and expects retry to work okay now.
            //

            if (ProgressRetryOperation == Operation)
            {
                Operation = ProgressInvokeEveryObject;
                goto Retry;
            }
        }

        break;

    default:
        break;
    }

    if (NULL != ProcessHandle)
    {
        CloseHandle(ProcessHandle);
    }

    if (NULL != pOldSD)
    {
        AccFree(pOldSD);
    }

    if (NULL != pParentSD)
    {
        AccFree(pParentSD);
    }

    if ((NULL != pNewSD) && (&TmpSD != pNewSD))
    {
        DestroyPrivateObjectSecurity(&pNewSD);
    }

    if (NULL != Context)
    {
        (VOID) (*(MartaSetFunctionContext.fCloseContext))(Context);
    }

    if (NULL != NtObjectName) 
    {
        LocalFree(NtObjectName);
    }

    return dwErr;
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// Function: MartaResetTree                                                    //
//                                                                            //
// Description: Reset permissions on the subtree below the node represented   //
//              by Context.
//                                                                            //
// Arguments:                                                                 //
//                                                                            //
//     [IN  pObjectName]               Name of the root of the subtree        //
//     [IN  NtObjectName]              Nt Name of the root of the subtree     //
//                                     Valid only for file objects            //
//     [IN  SecurityInfo]              Security info to reset                 //
//     [IN  TmpSeInfo]                 Info that needs to be read from the    //
//                                     object                                 //
//     [IN  pNewSD]                    New security Descriptor on the parent  //
//     [IN  pEmptySD]                  Security Descriptor with owner/group   //
//     [IN  Context]                   Context for the root of the subtree    //
//     [IN  ProcessHandle]             Handle to the process token            //
//     [IN  pMartaSetFunctionContext]  Struct holding function pointers       //
//     [IN  pGenMap]                   Generic mapping for the object         //
//     [IN  MaxAccessMask]             Desired access mask for R, W, List     //
//     [IN  AccessMask]                Desired access mask for W              //
//     [IN  RetryMask]                 Desired access mask for List           //
//     [IN  OUT pOperation]            To determine if callback should be     //
//                                     invoked. Value may be changed by the   //
//                                     callback function.                     //
//     [IN  Args]                      Arguments supplied by the caller       //
//     [IN  fnProgress]                Caller supplied callback function      //
//     [IN  KeepExplicit]              if TRUE, retain explicit aces          //
//                                                                            //
//                                                                            //
// Algorithm:                                                                 //
//     Open the first child for R, W, List                                    //
//     if open failed                                                         //
//         Try again for just R, W and note that a retry is needed.           //
//     Return TRUE if no children exist.                                      //
//     Return FALSE if we can not list                                        //
//     for all children                                                       //
//       If resetting xAcl (and maybe owner/group)                            //
//         if KeepExplicit                                                    //
//           read old xAcl and (owner/group if not provided by the caller)    //
//         else                                                               //
//           read owner/group if not provided by the caller)                  //
//         Compute NewChildSD using this computed info and new parent SD      //
//       else                                                                 //
//         NewChildSD = EmptySD                                               //
//       Invoke callback depending on the flag.                               //
//       Retry propagation if it failed the first time.                       //
//       If at any time, the callback function requests a cancel              //
//           Abort.                                                           //
//
// Returns:  TRUE if propagation succeeded                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

BOOL
MartaResetTree(
    IN LPWSTR                      pObjectName,
    IN LPWSTR                      NtObjectName,
    IN SECURITY_INFORMATION        SecurityInfo,
    IN SECURITY_INFORMATION        TmpSeInfo,
    IN PSECURITY_DESCRIPTOR        pNewSD,
    IN PSECURITY_DESCRIPTOR        pEmptySD,
    IN MARTA_CONTEXT               Context,
    IN HANDLE                      ProcessHandle,
    IN PMARTA_SET_FUNCTION_CONTEXT pMartaSetFunctionContext,
    IN PGENERIC_MAPPING            pGenMap,
    IN ACCESS_MASK                 MaxAccessMask,
    IN ACCESS_MASK                 AccessMask,
    IN ACCESS_MASK                 RetryAccessMask,
    IN OUT PPROG_INVOKE_SETTING    pOperation,
    IN FN_PROGRESS                 fnProgress,
    IN PVOID                       Args,
    IN BOOL                        KeepExplicit
    )
{
    MARTA_OBJECT_PROPERTIES      ObjectProperties;

    MARTA_CONTEXT        ChildContext  = NULL_MARTA_CONTEXT;
    PSECURITY_DESCRIPTOR pNewChildSD   = NULL;
    PSECURITY_DESCRIPTOR pOldChildSD   = NULL;
    DWORD                dwErr         = ERROR_SUCCESS;
    BOOL                 bIsContainer  = FALSE;
    HANDLE               ThreadHandle  = NULL;
    BOOL                 bRetry        = FALSE;
    BOOL                 bSetWorked    = FALSE;

    //
    // Get the first child of this container. In the first attempt try to open
    // the child with read/write as well as list.
    //

    dwErr = (*(pMartaSetFunctionContext->fFindFirst))(
                   Context,
                   MaxAccessMask,
                   &ChildContext
                   );

    if (ERROR_SUCCESS != dwErr)
    {

#ifdef MARTA_DEBUG
            wprintf(L"FindFirst failed\n");
#endif

        if (NULL == ChildContext)
        {
            //
            // This should never happen. A NULL ChildContext represents no
            // more children. We have this code path just in case some resource
            // manager cannot open the object for list.
            //

            dwErr = (*(pMartaSetFunctionContext->fFindFirst))(
                           Context,
                           AccessMask,
                           &ChildContext
                           );
        }
        else
        {
            //
            // Try opening the child again, this time with permissions sufficent
            // for computing security info to set and setting it.
            //

            dwErr = (*(pMartaSetFunctionContext->fReopenContext))(
                           ChildContext,
                           AccessMask
                           );
        }

        //
        // We failed to open the object for list. Record this failure and open
        // the child again if it is a container.
        //

        bRetry = TRUE;
    }
    else
    {
#ifdef MARTA_DEBUG
            wprintf(L"FindFirst succeeded\n");
#endif
    }

    if (NULL == ChildContext)
    {
        //
        // The parent does not have any children.
        //

        if (ERROR_SUCCESS == dwErr)
        {

#ifdef MARTA_DEBUG
            wprintf(L"The container does not have any children\n");
#endif

            return FALSE;
        }

#ifdef MARTA_DEBUG
        wprintf(L"Can not list objects in the current container. Retry needed\n");
#endif

        //
        // We need a propagation retry for the parent.
        //

        return TRUE;
    }

    CONDITIONAL_EXIT(dwErr, EndOfWhile);

    //
    // Child context becomes NULL when there are no more children.
    //

    while (ChildContext)
    {
        ObjectProperties.cbSize  = sizeof(ObjectProperties);
        ObjectProperties.dwFlags = 0;

        //
        // Get information about the current child. We need to know whether
        // it is a container.
        //
        //

        dwErr = (*(pMartaSetFunctionContext->fGetProperties))(
                       ChildContext,
                       &ObjectProperties
                       );

        CONDITIONAL_EXIT(dwErr, EndOfWhile);

#ifdef MARTA_DEBUG
        wprintf(L"GetProperties succeeded\n");
#endif

        bIsContainer = FLAG_ON(ObjectProperties.dwFlags, MARTA_OBJECT_IS_CONTAINER);

        //
        // If we are setting any of the ACLs then the security descriptor must
        // be recomputed.
        //

        if (FLAG_ON(SecurityInfo, (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION)))
        {
            //
            // TmpSeInfo is ZERO if the caller is resetting both OWNER and GROUP
            // as well.
            // We have to read the old ACLs if the caller wants to retain explicit
            // aces.
            //

            if (KeepExplicit)
            {
                TmpSeInfo |= (SecurityInfo & (DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION));
            }

            //
            // Read the existing security on the child.
            //

            if (0 != TmpSeInfo)
            {
                dwErr = (*(pMartaSetFunctionContext->fGetRights))(
                               ChildContext,
                               TmpSeInfo,
                               &pOldChildSD
                               );

                CONDITIONAL_EXIT(dwErr, EndOfWhile);

                //
                // Set the existing owner information in the empty security descriptor
                // if the caller has not provided an Owner sid to set.
                //

                if (!FLAG_ON(SecurityInfo, OWNER_SECURITY_INFORMATION))
                {
                    if (FALSE == SetSecurityDescriptorOwner(
                                     pEmptySD,
                                     RtlpOwnerAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldChildSD),
                                     FALSE))
                    {
                        dwErr = GetLastError();

                        CONDITIONAL_EXIT(dwErr, EndOfWhile);
                    }
                }

                if (KeepExplicit)
                {
                    //
                    // Set the ACLs in the EmptySD to existing ones in order to
                    // retain explicit aces.
                    //

                    if (FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
                    {
                        if (FALSE == SetSecurityDescriptorDacl(
                                         pEmptySD,
                                         TRUE,
                                         RtlpDaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldChildSD),
                                         FALSE))
                        {
                            dwErr = GetLastError();

                            CONDITIONAL_EXIT(dwErr, EndOfWhile);
                        }
                    }

                    if (FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
                    {
                        if (FALSE == SetSecurityDescriptorSacl(
                                         pEmptySD,
                                         TRUE,
                                         RtlpSaclAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldChildSD),
                                         FALSE))
                        {
                            dwErr = GetLastError();

                            CONDITIONAL_EXIT(dwErr, EndOfWhile);
                        }
                    }
                }

                //
                // Set the existing group information in the empty security descriptor
                // if the caller has not provided a group sid to set.
                //

                if (!FLAG_ON(SecurityInfo, GROUP_SECURITY_INFORMATION))
                {
                    if (FALSE == SetSecurityDescriptorGroup(
                                     pEmptySD,
                                     RtlpGroupAddrSecurityDescriptor((PISECURITY_DESCRIPTOR) pOldChildSD),
                                     FALSE))
                    {
                        dwErr = GetLastError();

                        CONDITIONAL_EXIT(dwErr, EndOfWhile);
                    }
                }
            }

            MARTA_TURN_OFF_IMPERSONATION;

            CONDITIONAL_EXIT(dwErr, EndOfWhile);

            //
            // Merge the NewParentSD and the OldChildSD to create NewChildSD.
            //

            if (FALSE == CreatePrivateObjectSecurityEx(
                             pNewSD,
                             pEmptySD,
                             &pNewChildSD,
                             NULL,
                             bIsContainer,
                             (SEF_DACL_AUTO_INHERIT | SEF_SACL_AUTO_INHERIT |
                              SEF_AVOID_OWNER_CHECK | SEF_AVOID_PRIVILEGE_CHECK),
                             ProcessHandle,
                             pGenMap
                             ))
            {
                dwErr = GetLastError();
            }

            MARTA_TURN_ON_IMPERSONATION;

            CONDITIONAL_EXIT(dwErr, EndOfWhile);
        }
        else
        {
            //
            // The new ChildSD does not have to computed. We only want to set
            // Owner/Group information.
            //

            pNewChildSD = pEmptySD;
        }

        //
        // Update the subtree undrneath this child.
        //

        if (bIsContainer)
        {

            if (!bRetry)
            {

#ifdef MARTA_DEBUG
        wprintf(L"Trying reset \n");
#endif

                bRetry = MartaResetTree(
                           pObjectName,
                           NtObjectName,
                           SecurityInfo,
                           TmpSeInfo,
                           pNewChildSD,
                           pEmptySD,
                           ChildContext,
                           ProcessHandle,
                           pMartaSetFunctionContext,
                           pGenMap,
                           MaxAccessMask,
                           AccessMask,
                           RetryAccessMask,
                           pOperation,
                           fnProgress,
                           Args,
                           KeepExplicit
                           );
            }
        }
        else
        {
            bRetry = FALSE;
        }

        //
        // Stamp NewChildSD on child.
        //

        if(FLAG_ON(SecurityInfo, DACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR) pNewChildSD)->Control |= SE_DACL_AUTO_INHERIT_REQ;
        }

        if(FLAG_ON(SecurityInfo, SACL_SECURITY_INFORMATION))
        {
            ((PISECURITY_DESCRIPTOR) pNewChildSD)->Control |= SE_SACL_AUTO_INHERIT_REQ;
        }

        dwErr = (*(pMartaSetFunctionContext->fSetRights))(
                       ChildContext,
                       SecurityInfo,
                       pNewChildSD
                       );

        CONDITIONAL_EXIT(dwErr, EndOfWhile);

#ifdef MARTA_DEBUG
        wprintf(L"Set right succeeded\n");
#endif

        //
        // Note down that we were able to set security on this object.
        //

        bSetWorked = TRUE;

        //
        // Abort if the progress function requested a "Cancel" in the subtree
        // below this node. The value is propagated all the way to the root as
        // the stack unwinds.
        //

        if (ProgressCancelOperation == *pOperation)
        {
            goto EndOfWhile;
        }

        //
        // If propagation had failed in the first attept then try again. This is to
        // cover the case when the container can be enumerated after setting the new
        // security.
        //

        if (bRetry && bIsContainer && (SecurityInfo & DACL_SECURITY_INFORMATION))
        {

Retry:

            bRetry = FALSE;

            //
            // Reopen the object for List and retry on the subtree.
            //

            dwErr = (*(pMartaSetFunctionContext->fReopenContext))(
                           ChildContext,
                           RetryAccessMask
                           );

            CONDITIONAL_EXIT(dwErr, EndOfWhile);

            bRetry = MartaResetTree(
                       pObjectName,
                       NtObjectName,
                       SecurityInfo,
                       TmpSeInfo,
                       pNewSD,
                       pEmptySD,
                       ChildContext,
                       ProcessHandle,
                       pMartaSetFunctionContext,
                       pGenMap,
                       MaxAccessMask,
                       AccessMask,
                       RetryAccessMask,
                       pOperation,
                       fnProgress,
                       Args,
                       KeepExplicit
                       );
        }

EndOfWhile:

        if (bRetry && bIsContainer) 
        {
            dwErr = ERROR_ACCESS_DENIED;
        }

        switch (*pOperation)
        {

        case ProgressInvokeNever:

            break;

        case ProgressInvokeOnError:

            if (ERROR_SUCCESS == dwErr)
            {
                break;
            }

            //
            // Fallthough is intended!!
            //

        case ProgressInvokeEveryObject:

            if (NULL != fnProgress)
            {
                LPWSTR Name = NULL;

                //
                // Get the name of the current object from the context and call
                // the progress function with the arguments provided by the
                // caller of ResetTree API.
                //

                DWORD Error = (*(pMartaSetFunctionContext->fGetNameFromContext))(
                                     pObjectName,
                                     NtObjectName,
                                     ChildContext,
                                     &Name
                                     );

                if (ERROR_SUCCESS == Error)
                {
                    fnProgress(
                        Name,
                        dwErr,
                        pOperation,
                        Args,
                        bSetWorked
                        );

                    LocalFree(Name);

                    //
                    // This was the latest feature request by HiteshR. At this
                    // point, retry has failed, but the caller has made some
                    // changes and expects retry to work okay now.
                    //

                    if (ProgressRetryOperation == *pOperation)
                    {
                        *pOperation = ProgressInvokeEveryObject;
                        goto Retry;
                    }
                }
            }

            break;

        default:
            break;
        }

        bSetWorked = bRetry = FALSE;

        if ((NULL != pNewChildSD) && (pEmptySD != pNewChildSD))
        {
            DestroyPrivateObjectSecurity(&pNewChildSD);
            pNewChildSD = NULL;
        }

        if (NULL != pOldChildSD)
        {
            LocalFree(pOldChildSD);
            pOldChildSD = NULL;
        }

        //
        // Abort if the progress function requested a "Cancel".
        //

        if (ProgressCancelOperation == *pOperation)
        {
            (*(pMartaSetFunctionContext->fCloseContext)) (ChildContext);
            return TRUE;
        }

        //
        // Get the next child.
        //

        do {

            bRetry = FALSE;

            dwErr = (*(pMartaSetFunctionContext->fFindNext))(
                           ChildContext,
                           MaxAccessMask,
                           &ChildContext
                           );

            if (NULL == ChildContext)
            {
                break;
            }

            if (ERROR_SUCCESS != dwErr)
            {

#ifdef MARTA_DEBUG
                wprintf(L"FindNext failed\n");
#endif

                dwErr = (*(pMartaSetFunctionContext->fReopenContext))(
                               ChildContext,
                               AccessMask
                               );

#ifdef MARTA_DEBUG
                if (dwErr == ERROR_SUCCESS)
                {
                    wprintf(L"FindNext failed\n");
                }
#endif

                bRetry = TRUE;
            }
            else
            {
#ifdef MARTA_DEBUG
                wprintf(L"Findnext succeeded\n");
#endif
            }

            switch (*pOperation)
            {

            case ProgressInvokeNever:

                break;

            case ProgressInvokeOnError:

                //
                // If we encountered an error in FindNext then report it to the
                // caller.
                //

                if (ERROR_SUCCESS == dwErr)
                {
                    break;
                }

                //
                // Fallthough is intended!!
                //

            case ProgressInvokeEveryObject:

                if (NULL != fnProgress)
                {
                    LPWSTR Name = NULL;

                    //
                    // Get the name of the current object.
                    //

                    DWORD Error = (*(pMartaSetFunctionContext->fGetNameFromContext))(
                                         pObjectName,
                                         NtObjectName,
                                         ChildContext,
                                         &Name
                                         );

                    if (ERROR_SUCCESS == Error)
                    {
                        fnProgress(
                            Name,
                            dwErr,
                            pOperation,
                            Args,
                            bSetWorked
                            );

                        LocalFree(Name);

                    }
                }

                break;

            default:
                break;
            }

            //
            // Abort if the progress function requested a "Cancel".
            //

            if (ProgressCancelOperation == *pOperation)
            {
                (*(pMartaSetFunctionContext->fCloseContext)) (ChildContext);
                return TRUE;
            }

        } while ((ERROR_SUCCESS != dwErr) && (NULL != ChildContext));
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\rightsca.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998 - 1998.
//
//  File:        rightsca.cxx
//
//  Contents:    Implementation of the DS access control rights cache
//
//  History:     20-Feb-98      MacM        Created
//
//--------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <stdio.h>
#include <alsup.hxx>

//
// Global name/id cache
//
PACTRL_RIGHTS_CACHE  grgRightsNameCache[ACTRL_OBJ_ID_TABLE_SIZE];

//
// Last connection info/time we read from the schema
//
static ACTRL_ID_SCHEMA_INFO    LastSchemaRead;

static RTL_RESOURCE RightsCacheLock;
BOOL bRightsCacheLockInitialized = FALSE;

#define ACTRL_EXT_RIGHTS_CONTAINER L"CN=Extended-Rights,"

//+----------------------------------------------------------------------------
//
//  Function:   AccctrlInitializeRightsCache
//
//  Synopsis:   Initialize the access control rights lookup cache
//
//  Arguments:  VOID
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//-----------------------------------------------------------------------------
DWORD AccctrlInitializeRightsCache(VOID)
{
    DWORD dwErr;
    
    if (TRUE == bRightsCacheLockInitialized)
    {
        //
        // Just a precautionary measure to make sure that we do not initialize
        // multiple times.
        //

        ASSERT(FALSE);
        return ERROR_SUCCESS;
    }

    memset(grgRightsNameCache, 0,
           sizeof(PACTRL_RIGHTS_CACHE) * ACTRL_OBJ_ID_TABLE_SIZE);

    memset(&LastSchemaRead, 0, sizeof(ACTRL_ID_SCHEMA_INFO));

    __try
    {
        RtlInitializeResource(&RightsCacheLock);
        dwErr = ERROR_SUCCESS;
        bRightsCacheLockInitialized = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = RtlNtStatusToDosError(GetExceptionCode());
    }

    return dwErr;
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlFreeRightsCache
//
//  Synopsis:   Frees any memory allocated for the id name/guid cache
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID AccctrlFreeRightsCache(VOID)
{
    INT i,j;
    PACTRL_RIGHTS_CACHE   pNode, pNext;

    if (FALSE == bRightsCacheLockInitialized)
    {
        return;
    }

    for(i = 0; i < ACTRL_OBJ_ID_TABLE_SIZE; i++)
    {
        pNode = grgRightsNameCache[i];
        while(pNode != NULL)
        {
            pNext = pNode->pNext;
            for (j = 0; j < (INT)pNode->cRights; j++)
            {
                AccFree(pNode->RightsList[j]);
            }
            AccFree(pNode->RightsList);

            AccFree(pNode);
            pNode = pNext;
        }
    }

    AccFree(LastSchemaRead.pwszPath);

    RtlDeleteResource(&RightsCacheLock);

    bRightsCacheLockInitialized = FALSE;

}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlFindRightsNode
//
//  Synopsis:   Looks up the node for the given class GUID
//
//  Arguments:  [ClassGuid]     --      Class guid to look up
//
//  Returns:    NULL            --      Node not found
//              else a valid node pointer
//
//-----------------------------------------------------------------------------
PACTRL_RIGHTS_CACHE
AccctrlpLookupClassGuidInCache(IN  PGUID ClassGuid)
{
    PACTRL_RIGHTS_CACHE pNode = NULL;

    pNode =  grgRightsNameCache[ActrlHashGuid(ClassGuid)];

    while(pNode != NULL)
    {
        if(memcmp(ClassGuid, &pNode->ObjectClassGuid,sizeof(GUID)) == 0)
        {
            break;
        }
        pNode = pNode->pNext;
    }

#if DBG
    if(pNode != NULL )
    {
    CHAR    szGuid[38];
    PGUID   pGuid = &pNode->ObjectClassGuid;
    sprintf(szGuid, "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                pGuid->Data1,pGuid->Data2,pGuid->Data3,pGuid->Data4[0],
                pGuid->Data4[1],pGuid->Data4[2],pGuid->Data4[3],
                pGuid->Data4[4],pGuid->Data4[5],pGuid->Data4[6],
                pGuid->Data4[7]);

    acDebugOut((DEB_TRACE_LOOKUP,
                "Found guid %s\n",
                szGuid));
    }
#endif

    return(pNode);
}



//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpInsertRightsNode
//
//  Synopsis:   Updates the information for an existing node or creates and
//              inserts a new one
//
//  Arguments:  [AppliesTo]     --      Guid this control right applies to
//              [RightsGuid]    --      Control right
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//-----------------------------------------------------------------------------
DWORD AccctrlpInsertRightsNode(IN PGUID AppliesTo,
                               IN PWSTR ControlRight)
{
    DWORD dwErr = ERROR_SUCCESS;
    PACTRL_RIGHTS_CACHE Node, pNext, pTrail = NULL;
    PWSTR *NewList;
    BOOL NewNode = FALSE;

    //
    // First, find the existing node, if it exists
    //
    Node = AccctrlpLookupClassGuidInCache( AppliesTo );

    if(Node == NULL)
    {
        //
        // Have to create and insert a new one
        //
        Node = (PACTRL_RIGHTS_CACHE)AccAlloc(sizeof(ACTRL_RIGHTS_CACHE));

        if(Node == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            NewNode = TRUE;
            memcpy(&Node->ObjectClassGuid, AppliesTo, sizeof(GUID));
            Node->cRights=0;

            pNext = grgRightsNameCache[ActrlHashGuid(AppliesTo)];

            while(pNext != NULL)
            {
                if(memcmp(AppliesTo, &(pNext->ObjectClassGuid), sizeof(GUID)) == 0)
                {
                    dwErr = ERROR_ALREADY_EXISTS;
                    acDebugOut((DEB_TRACE_LOOKUP, "Guid collision. Bailing\n"));
                    break;
                }

                pTrail = pNext;
                pNext = pNext->pNext;
            }

        }

        if(dwErr == ERROR_SUCCESS)
        {
            if(pTrail == NULL)
            {

                grgRightsNameCache[ActrlHashGuid(AppliesTo)] = Node;

            }
            else {

                pTrail->pNext = Node;
            }

        }
    }

    //
    // Now, insert the new applies to list
    if(dwErr == ERROR_SUCCESS)
    {
        NewList = (PWSTR *)AccAlloc((Node->cRights + 1) * sizeof(PWSTR));
        if(NewList==NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            memcpy(NewList, Node->RightsList, Node->cRights * sizeof( PWSTR ));

            NewList[Node->cRights] = (PWSTR)AccAlloc((wcslen(ControlRight) + 1) * sizeof(WCHAR));
            if(NewList[Node->cRights] == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                AccFree(NewList);
            }
            else
            {
                wcscpy(NewList[Node->cRights], ControlRight);
                Node->cRights++;
                AccFree(Node->RightsList);
                Node->RightsList = NewList;
            }
        }
    }

    //
    // Clean up if necessary
    //
    if(dwErr != ERROR_SUCCESS && NewNode == TRUE)
    {
        AccFree(Node);
    }

    return(dwErr);
}

//+---------------------------------------------------------------------------
//
//  Function:   AccDsReadAndInsertExtendedRights
//
//  Synopsis:   Reads the full list of extended rights from the schema
//
//  Arguments:  [IN  pLDAP]                 --      LDAP connection to use
//              [OUT pcItems]               --      Where the count of items
//                                                  is returned
//              [OUT RightsList]            --      Where the list of rights
//                                                  entries is returned.
//
//  Notes:
//
//  Returns:    ERROR_SUCCESS               --      Success
//
//----------------------------------------------------------------------------
DWORD
AccDsReadAndInsertExtendedRights(IN PLDAP   pLDAP)
{
    DWORD               dwErr = ERROR_SUCCESS;
    PWSTR              *ppwszValues = NULL, *ppwszApplies = NULL;
    PWSTR               rgwszAttribs[3];
    PWSTR               pwszERContainer = NULL;
    PDS_NAME_RESULTW    pNameRes = NULL;
    LDAPMessage         *pMessage, *pEntry;
    ULONG               cEntries, i, j;
    PACTRL_RIGHTS_CACHE pCurrentEntry;
    GUID                RightsGuid;

    //
    // Get the subschema path
    //
    if(dwErr == ERROR_SUCCESS)
    {
        rgwszAttribs[0] = L"configurationNamingContext";
        rgwszAttribs[1] = NULL;

        dwErr = ldap_search_s(pLDAP,
                              NULL,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgwszAttribs,
                              0,
                              &pMessage);
        if(dwErr == ERROR_SUCCESS)
        {
            pEntry = ldap_first_entry(pLDAP,
                                      pMessage);

            if(pEntry == NULL)
            {
                ldap_msgfree(pMessage);
                pMessage = NULL;
                dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
            }
            else
            {
                //
                // Now, we'll have to get the values
                //
                ppwszValues = ldap_get_values(pLDAP,
                                              pEntry,
                                              rgwszAttribs[0]);
                ldap_msgfree(pMessage);
                pMessage = NULL;

                if(ppwszValues == NULL)
                {
                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                }
                else
                {
                    pwszERContainer = (PWSTR)AccAlloc((wcslen(ppwszValues[0]) * sizeof(WCHAR)) +
                                                      sizeof(ACTRL_EXT_RIGHTS_CONTAINER));
                    if(pwszERContainer == NULL)
                    {
                        dwErr = ERROR_NOT_ENOUGH_MEMORY;
                    }
                    else
                    {
                        wcscpy(pwszERContainer,
                               ACTRL_EXT_RIGHTS_CONTAINER);
                        wcscat(pwszERContainer,
                               ppwszValues[0]);


                        rgwszAttribs[0] = L"rightsGuid";
                        rgwszAttribs[1] = L"appliesTo";
                        rgwszAttribs[2] = NULL;

                        //
                        // Read the control access rights
                        //
                        dwErr = ldap_search_s(pLDAP,
                                              pwszERContainer,
                                              LDAP_SCOPE_ONELEVEL,
                                              L"(objectClass=controlAccessRight)",
                                              rgwszAttribs,
                                              0,
                                              &pMessage);

                        dwErr = LdapMapErrorToWin32( dwErr );

                        AccFree(pwszERContainer);
                    }
                    ldap_value_free(ppwszValues);


                    //
                    // Process the entries
                    //
                    if(dwErr == ERROR_SUCCESS)
                    {
                        pEntry = ldap_first_entry(pLDAP,
                                                 pMessage);

                        if(pEntry == NULL)
                        {
                            dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                        }
                        else
                        {
                            cEntries = ldap_count_entries( pLDAP, pMessage );

                            for(i = 0; i < cEntries && dwErr == ERROR_SUCCESS; i++) {

                                ppwszValues = ldap_get_values(pLDAP,
                                                              pEntry,
                                                              rgwszAttribs[0]);
                                if(ppwszValues == NULL)
                                {
                                    dwErr = LdapMapErrorToWin32( pLDAP->ld_errno );
                                }
                                else
                                {
                                    //
                                    // Then the list of applies to
                                    //
                                    ppwszApplies = ldap_get_values(pLDAP,
                                                                  pEntry,
                                                                  rgwszAttribs[1]);
                                    j = 0;

                                    while(ppwszApplies[j] != NULL && dwErr == ERROR_SUCCESS)
                                    {

                                        dwErr = UuidFromString(ppwszApplies[j],
                                                               &RightsGuid);

                                        if(dwErr == ERROR_SUCCESS)
                                        {
                                            dwErr = AccctrlpInsertRightsNode( &RightsGuid,
                                                                              ppwszValues[0]);
                                        }
                                        j++;
                                    }

                                    ldap_value_free(ppwszApplies);
                                    ppwszApplies = NULL;
                                    ldap_value_free(ppwszValues);

                                }

                                pEntry = ldap_next_entry( pLDAP, pEntry );
                            }

                        }
                    }

                    if (pMessage != NULL)
                    {
                        ldap_msgfree(pMessage);
                    }
                }
            }

        }
        else
        {
            ldap_msgfree(pMessage);
            dwErr = LdapMapErrorToWin32( dwErr );
        }

    }

    return(dwErr) ;
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpLoadRightsCacheFromSchema
//
//  Synopsis:   Reads the control rights schema cache and adds the entries into the
//              cache
//
//  Arguments:  [pLDAP]         --      LDAP connection to the server
//              [pwszPath]      --      DS path to the object
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//-----------------------------------------------------------------------------
DWORD   AccctrlpLoadRightsCacheFromSchema(PLDAP   pLDAP,
                                          PWSTR   pwszDsPath)
{
    DWORD       dwErr = ERROR_SUCCESS;
    PLDAP       pLocalLDAP = pLDAP;
    ULONG       cValues[2];
    PWSTR      *ppwszValues[2];

    acDebugOut((DEB_TRACE_LOOKUP, "Reloading rights cache from schema\n"));

    //
    // If we have no parameters, just return...
    //
    if(pLDAP == NULL && pwszDsPath == NULL)
    {
        return(ERROR_SUCCESS);
    }

    //
    // See if we need to read...  If our data is over 5 minutes old or if our path referenced is
    // not the same as the last one...
    //
#define FIVE_MINUTES    300000
    if((LastSchemaRead.LastReadTime != 0 &&
                            (GetTickCount() - LastSchemaRead.LastReadTime < FIVE_MINUTES)) &&
       DoPropertiesMatch(pwszDsPath, LastSchemaRead.pwszPath) &&
       ((pLDAP == NULL && LastSchemaRead.fLDAP == FALSE) ||
        (pLDAP != NULL && memcmp(pLDAP, &(LastSchemaRead.LDAP), sizeof(LDAP)))))

    {
        acDebugOut((DEB_TRACE_LOOKUP,"Cache up to date...\n"));
        return(ERROR_SUCCESS);
    }
    else
    {
        //
        // Need to reinitialize it...
        //
        if(pLDAP == NULL)
        {
            LastSchemaRead.fLDAP = FALSE;
        }
        else
        {
            LastSchemaRead.fLDAP = TRUE;
            memcpy(&(LastSchemaRead.LDAP), pLDAP, sizeof(LDAP));
        }

        AccFree(LastSchemaRead.pwszPath);
        if(pwszDsPath != NULL)
        {
            ACC_ALLOC_AND_COPY_STRINGW(pwszDsPath, LastSchemaRead.pwszPath, dwErr);
        }

        LastSchemaRead.LastReadTime = GetTickCount();
    }



    if(dwErr == ERROR_SUCCESS && pLocalLDAP == NULL)
    {
        PWSTR pwszServer = NULL, pwszObject = NULL;

        dwErr = DspSplitPath( pwszDsPath, &pwszServer, &pwszObject );

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = BindToDSObject(pwszServer, pwszObject, &pLocalLDAP);
            LocalFree(pwszServer);
        }
    }

    //
    // Now, get the info.  First, extended rights, then the schema info
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AccDsReadAndInsertExtendedRights(pLocalLDAP);
    }

    //
    // See if we need to release our ldap connection
    //
    if(pLocalLDAP != pLDAP && pLocalLDAP != NULL)
    {
        UnBindFromDSObject(&pLocalLDAP);
    }

    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlLookupRightByName
//
//  Synopsis:   Returns the list of control rights for a given object class
//
//  Arguments:  [pLDAP]         --      LDAP connection to the server
//              [pwszPath]      --      DS path to the object
//              [pwszName]      --      Object class name
//              [pCount]        --      Where the count if items is returned
//              [ppRightsList]  --      List of control rights
//              [ppwszNameList] --      List of control rights names
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//              ERROR_NOT_FOUND --      No such ID exists
//
//-----------------------------------------------------------------------------
DWORD
AccctrlLookupRightsByName(IN  PLDAP      pLDAP,
                          IN  PWSTR      pwszDsPath,
                          IN  PWSTR      pwszName,
                          OUT PULONG     pCount,
                          OUT PACTRL_CONTROL_INFOW *ControlInfo)
{
    DWORD dwErr = ERROR_SUCCESS;
    GUID *ObjectClassGuid, RightsGuid;
    PACTRL_RIGHTS_CACHE Node;
    ULONG Size = 0, i;
    PWSTR GuidName, Current;

    if((pwszDsPath == NULL && pLDAP == NULL) || pwszName == NULL)
    {
        *pCount = 0;
        *ControlInfo = NULL;
        return(ERROR_SUCCESS);
    }

    RtlAcquireResourceShared(&RightsCacheLock, TRUE);

    //
    // This is a multi-staged process.  First, we have to lookup the guid associated
    // with the object class name.  Then, we get the list of control rights for it
    //
    dwErr = AccctrlLookupGuid(pLDAP,
                              pwszDsPath,
                              pwszName,
                              FALSE,        // Don't allocate
                              &ObjectClassGuid);
    if(dwErr == ERROR_SUCCESS)
    {
        Node = AccctrlpLookupClassGuidInCache(ObjectClassGuid);

        if(Node == NULL)
        {
            RtlConvertSharedToExclusive( &RightsCacheLock );

            dwErr = AccctrlpLoadRightsCacheFromSchema(pLDAP, pwszDsPath );

            if(dwErr == ERROR_SUCCESS)
            {
                Node = AccctrlpLookupClassGuidInCache(ObjectClassGuid);
                if(Node == NULL)
                {
                    dwErr = ERROR_NOT_FOUND;
                }
            }

        }


        if(Node != NULL)
        {
            //
            // Size all of the return strings
            //
            for (i = 0;i < Node->cRights && dwErr == ERROR_SUCCESS; i++) {

                dwErr = UuidFromString( Node->RightsList[i],&RightsGuid);

                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = AccctrlLookupIdName(pLDAP,
                                                pwszDsPath,
                                                &RightsGuid,
                                                FALSE,
                                                FALSE,
                                                &GuidName);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        Size += wcslen( GuidName ) + 1;
                        Size += wcslen( Node->RightsList[i] ) + 1;
                    }

                }
            }

            //
            // Now, allocate the return information
            //
            if(dwErr == ERROR_SUCCESS)
            {
                *ControlInfo = (PACTRL_CONTROL_INFOW)AccAlloc((Size * sizeof(WCHAR)) +
                                                   (Node->cRights * sizeof(ACTRL_CONTROL_INFOW)));
                if(*ControlInfo == NULL)
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                }
                else
                {
                    Current = (PWSTR)((*ControlInfo) + Node->cRights);
                    for (i = 0;i < Node->cRights && dwErr == ERROR_SUCCESS; i++) {

                        dwErr = UuidFromString( Node->RightsList[i],&RightsGuid);

                        if(dwErr == ERROR_SUCCESS)
                        {
                            dwErr = AccctrlLookupIdName(pLDAP,
                                                        pwszDsPath,
                                                        &RightsGuid,
                                                        FALSE,
                                                        FALSE,
                                                        &GuidName);
                        }

                        if(dwErr == ERROR_SUCCESS)
                        {
                            (*ControlInfo)[i].lpControlId = Current;
                            wcscpy(Current, Node->RightsList[i]);
                            Current += wcslen(Node->RightsList[i]);
                            *Current = L'\0';
                            Current++;

                            (*ControlInfo)[i].lpControlName = Current;
                            wcscpy(Current, GuidName);
                            Current += wcslen(GuidName);
                            *Current = L'\0';
                            Current++;
                        }
                    }


                    if(dwErr != ERROR_SUCCESS)
                    {
                        AccFree(*ControlInfo);
                    }
                    else
                    {
                        *pCount = Node->cRights;
                    }
                }

            }

        }
    }

    RtlReleaseResource(&RightsCacheLock);

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\regctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 2000.
//
//  File:       registry.cpp
//
//  Contents:   NtMarta registry functions
//
//  History:    4/99    philh       Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <kernel.h>
#include <assert.h>
#include <ntstatus.h>

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <stddef.h>


#include <registry.h>
#include <wow64reg.h>

#ifdef STATIC
#undef STATIC
#endif
#define STATIC

// Registry object names returned by NtQueryObject are prefixed by
// the following
#define REG_OBJ_TAG L"\\REGISTRY\\"
#define REG_OBJ_TAG_LEN (sizeof(REG_OBJ_TAG) / sizeof(WCHAR) - 1)

//+-------------------------------------------------------------------------
//  Registry Context data structures
//--------------------------------------------------------------------------
typedef struct _REG_FIND_DATA REG_FIND_DATA, *PREG_FIND_DATA;

typedef struct _REG_CONTEXT {
    DWORD               dwRefCnt;
    DWORD               dwFlags;

    // Only closed when REG_CONTEXT_CLOSE_HKEY_FLAG is set
    HKEY                hKey;
    LPWSTR              pwszObject;     // optional, allocated

    // Following is allocated and updated for FindFirst, FindNext
    PREG_FIND_DATA      pRegFindData;
} REG_CONTEXT, *PREG_CONTEXT;

#define REG_CONTEXT_CLOSE_HKEY_FLAG     0x1

struct _REG_FIND_DATA {
    PREG_CONTEXT        pRegParentContext;  // ref counted
    DWORD               cSubKeys;
    DWORD               cchMaxSubKey;
    DWORD               iSubKey;            // index of next FindNext

    // Following isn't allocated separately, it follows this data structure
    LPWSTR              pwszSubKey;
};

//+-------------------------------------------------------------------------
//  Registry allocation functions
//--------------------------------------------------------------------------
#define I_MartaRegZeroAlloc(size)     \
            LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, size)
#define I_MartaRegNonzeroAlloc(size)  \
            LocalAlloc(LMEM_FIXED, size)

STATIC
inline
VOID
I_MartaRegFree(
    IN LPVOID pv
    )
{
    if (pv)
        LocalFree(pv);
}

STATIC
DWORD
I_MartaRegDupString(
    IN LPCWSTR pwszOrig,
    OUT LPWSTR *ppwszDup
    )

/*++

Routine Description:

    Allocate memory and copy the given name into it.

Arguments:

    pwszOrig - String to be duplicated.
    
    ppwszDup - To return the duplicate.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_NOT_ENOUGH_MEMORY if allocation failed.

--*/

{
    DWORD dwErr;
    DWORD cchOrig;
    LPWSTR pwszDup;

    cchOrig = wcslen(pwszOrig);
    if (NULL == (pwszDup = (LPWSTR) I_MartaRegNonzeroAlloc(
            (cchOrig + 1) * sizeof(WCHAR)))) {
        *ppwszDup = NULL;
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    } else {
        memcpy(pwszDup, pwszOrig, (cchOrig + 1) * sizeof(WCHAR));
        *ppwszDup = pwszDup;
        dwErr = ERROR_SUCCESS;
    }

    return dwErr;
}

STATIC
DWORD
I_MartaRegGetParentString(
    IN OUT LPWSTR pwszParent
    )

/*++

Routine Description:

    Given the name for a registry key, get the name of its parent. Does not allocate
    memory. Scans till the first '\' from the right and deletes the name after
    that.

Arguments:

    pwszParent - Object name which will be converted to its parent name.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    DWORD cch;
    LPWSTR pwsz;

    if (NULL == pwszParent)
        return ERROR_INVALID_NAME;

    cch = wcslen(pwszParent);
    pwsz = pwszParent + cch;
    if (0 == cch)
        goto InvalidNameReturn;
    pwsz--;

    //
    // Remove any trailing '\'s
    //

    while (L'\\' == *pwsz) {
        if (pwsz == pwszParent)
            goto InvalidNameReturn;
        pwsz--;
    }

    //
    // Peal off the last path name component
    //

    while (L'\\' != *pwsz) {
        if (pwsz == pwszParent)
            goto InvalidNameReturn;
        pwsz--;
    }

    //
    // Remove all trailing '\'s from the parent.
    // This could also be the leading '\\'s for a computer name.
    //

    while (L'\\' == *pwsz) {
        if (pwsz == pwszParent)
            goto InvalidNameReturn;
        pwsz--;
    }
    pwsz++;
    assert(L'\\' == *pwsz);

    dwErr = ERROR_SUCCESS;
CommonReturn:
    *pwsz = L'\0';
    return dwErr;
InvalidNameReturn:
    dwErr = ERROR_INVALID_NAME;
    goto CommonReturn;
}

STATIC
DWORD
I_MartaRegCreateChildString(
    IN LPCWSTR pwszParent,
    IN LPCWSTR pwszSubKey,
    OUT LPWSTR *ppwszChild
    )

/*++

Routine Description:

    Given the name of the parent and the name of the subkey, create the full
    name of the child.

Arguments:

    pwszParent - Name of the parent.
    
    pwszSubKey - Name of the subkey.
    
    ppwszChild - To return the name of the child.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_NOT_ENOUGH_MEMORY if allocation failed.

--*/

{
    DWORD dwErr;
    DWORD cchParent;
    DWORD cchSubKey;
    DWORD cchChild;
    LPWSTR pwszChild = NULL;

    if (NULL == pwszParent || NULL == pwszSubKey)
        goto InvalidNameReturn;

    cchParent = wcslen(pwszParent);

    //
    // Remove any trailing '\'s from parent
    //

    while (0 < cchParent && L'\\' == pwszParent[cchParent - 1])
        cchParent--;
    if (0 == cchParent)
        goto InvalidNameReturn;

    cchSubKey = wcslen(pwszSubKey);
    if (0 == cchSubKey)
        goto InvalidNameReturn;

    cchChild = cchParent + 1 + cchSubKey;
    if (NULL == (pwszChild = (LPWSTR) I_MartaRegNonzeroAlloc(
            (cchChild + 1) * sizeof(WCHAR))))
        goto NotEnoughMemoryReturn;

    //
    // Construct the name of the child from the given strings.
    //

    memcpy(pwszChild, pwszParent, cchParent * sizeof(WCHAR));
    pwszChild[cchParent] = L'\\';
    memcpy(pwszChild + cchParent + 1, pwszSubKey, cchSubKey * sizeof(WCHAR));
    pwszChild[cchChild] = L'\0';

    dwErr = ERROR_SUCCESS;
CommonReturn:
    *ppwszChild = pwszChild;
    return dwErr;

InvalidNameReturn:
    dwErr = ERROR_INVALID_NAME;
    goto CommonReturn;
NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto CommonReturn;
}


STATIC
DWORD
I_MartaRegParseName(
    IN OUT  LPWSTR  pwszObject,
    OUT     LPWSTR *ppwszMachine,
    OUT     LPWSTR *ppwszRemaining
    )

/*++

Routine Description:

    Parses a registry object name for the machine name.

Arguments:

    pwszObject - the name of the object

    ppwszMachine - the machine the object is on

    ppwszRemaining - the remaining name after the machine name

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_NOT_ENOUGH_MEMORY if allocation failed.

--*/

{
    if (pwszObject == wcsstr(pwszObject, L"\\\\")) {
        *ppwszMachine = pwszObject + 2;
        *ppwszRemaining =  wcschr(*ppwszMachine, L'\\');
        if (*ppwszRemaining != NULL) {
            **ppwszRemaining = L'\0';
            *ppwszRemaining += 1;
        }
    } else {
        *ppwszMachine = NULL;
        *ppwszRemaining = pwszObject;
    }

    return ERROR_SUCCESS;
}


STATIC
DWORD
I_MartaRegInitContext(
    OUT PREG_CONTEXT *ppRegContext
    )

/*++

Routine Description:

    Allocate and initialize memory for the context.

Arguments:

    ppRegContext - To return the pointer to the allcoated memory.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    PREG_CONTEXT pRegContext;

    if (pRegContext = (PREG_CONTEXT) I_MartaRegZeroAlloc(
            sizeof(REG_CONTEXT))) {
        pRegContext->dwRefCnt = 1;
        dwErr = ERROR_SUCCESS;
    } else {
        pRegContext = NULL;
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }

    *ppRegContext = pRegContext;
    return dwErr;
}

DWORD
MartaOpenRegistryKeyNamedObject(
    IN  LPCWSTR              pwszObject,
    IN  ACCESS_MASK          AccessMask,
    OUT PMARTA_CONTEXT       pContext
    )

/*++

Routine Description:

    Open the given registry key with desired access mask and return a context
    handle.

Arguments:

    pwszObject - Name of the registry key which will be opened.
    
    AccessMask - Desired access mask with which the registry key will be opened.
    
    pContext - To return a context handle.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    PREG_CONTEXT pRegContext = NULL;
    LPWSTR pwszDupObject = NULL;
    HKEY hKeyRemote = NULL;
    HKEY hKeyBase;              // not opened, don't close at return

    //
    // Following aren't allocated
    //

    LPWSTR pwszMachine, pwszRemaining, pwszBaseKey, pwszSubKey;

    if (NULL == pwszObject)
        goto InvalidNameReturn;

    if (ERROR_SUCCESS != (dwErr = I_MartaRegInitContext(&pRegContext)))
        goto ErrorReturn;

    //
    // Allocate and copy the name into the context
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaRegDupString(pwszObject,
            &pRegContext->pwszObject)))
        goto ErrorReturn;

    //
    // Save another copy of the name since we must crack it.
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaRegDupString(pwszObject,
            &pwszDupObject)))
        goto ErrorReturn;

    //
    // Get the optional machine name and the remaining name
    //

    if (ERROR_SUCCESS != (dwErr = I_MartaRegParseName(pwszDupObject,
            &pwszMachine, &pwszRemaining)))
        goto ErrorReturn;
    if (NULL == pwszRemaining)
        goto InvalidNameReturn;

    //
    // Get the base key name and the subkey name
    //

    pwszBaseKey = pwszRemaining;
    pwszSubKey = wcschr(pwszRemaining, L'\\');
    if (NULL != pwszSubKey) {
        *pwszSubKey = L'\0';

        pwszSubKey++;

        //
        // Advance past any more '\'s separating the BaseKey from the SubKey
        //

        while (L'\\' == *pwszSubKey)
            pwszSubKey++;
    }

    if (0 == _wcsicmp(pwszBaseKey, L"MACHINE")) {
        hKeyBase = HKEY_LOCAL_MACHINE;
    } else if (0 == _wcsicmp(pwszBaseKey, L"USERS") ||
               0 == _wcsicmp(pwszBaseKey, L"USER")) {
        hKeyBase = HKEY_USERS;
    } else if (NULL == pwszMachine) {

        //
        // these are only valid on the local machine
        //

        if (0 == _wcsicmp(pwszBaseKey, L"CLASSES_ROOT")) {
            hKeyBase = HKEY_CLASSES_ROOT;
        } else if (0 == _wcsicmp(pwszBaseKey, L"CURRENT_USER")) {
            hKeyBase = HKEY_CURRENT_USER;
        } else if (0 == _wcsicmp(pwszBaseKey, L"CONFIG")) {
            hKeyBase = HKEY_CURRENT_CONFIG;
        } else {
            goto InvalidParameterReturn;
        }
    } else {
        goto InvalidParameterReturn;
    }

    //
    // If it is a remote name, connect to that registry
    //

    if (pwszMachine) {
        if (ERROR_SUCCESS != (dwErr = RegConnectRegistryW(
                pwszMachine,
                hKeyBase,
                &hKeyRemote
                )))
            goto ErrorReturn;
        hKeyBase = hKeyRemote;
    }

    if (NULL == pwszMachine && (NULL == pwszSubKey || L'\0' == *pwszSubKey))

        //
        // Opening a predefined handle causes the previously opened handle
        // to be closed. Therefore, we won't reopen here.
        //

        pRegContext->hKey = hKeyBase;
    else {
        if (ERROR_SUCCESS != (dwErr = RegOpenKeyExW(
                hKeyBase,
                pwszSubKey,
                0,              // dwReversed
                AccessMask,
                &pRegContext->hKey)))
            goto ErrorReturn;
        pRegContext->dwFlags |= REG_CONTEXT_CLOSE_HKEY_FLAG;
    }

    dwErr = ERROR_SUCCESS;
CommonReturn:
    I_MartaRegFree(pwszDupObject);
    if (hKeyRemote)
        RegCloseKey(hKeyRemote);
    *pContext = (MARTA_CONTEXT) pRegContext;
    return dwErr;

ErrorReturn:
    if (pRegContext) {
        MartaCloseRegistryKeyContext((MARTA_CONTEXT) pRegContext);
        pRegContext = NULL;
    }
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

InvalidNameReturn:
    dwErr = ERROR_INVALID_NAME;
    goto ErrorReturn;
InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
}

void
I_MartaRegFreeFindData(
    IN PREG_FIND_DATA pRegFindData
    )

/*++

Routine Description:

    Free up the memory associated with the internal structure.

Arguments:

    pRegFindData - Internal structure to be freed.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    if (NULL == pRegFindData)
        return;
    if (pRegFindData->pRegParentContext)
        MartaCloseRegistryKeyContext(pRegFindData->pRegParentContext);

    I_MartaRegFree(pRegFindData);
}

DWORD
MartaCloseRegistryKeyContext(
    IN MARTA_CONTEXT Context
    )

/*++

Routine Description:

    Close the context.

Arguments:

    Context - Context to be closed.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;

    if (NULL == pRegContext || 0 == pRegContext->dwRefCnt)
        return ERROR_INVALID_PARAMETER;

    //
    // If the ref cnt goes to zero then free the handle as well as all other
    // associated structures.
    //

    if (0 == --pRegContext->dwRefCnt) {
        if (pRegContext->pRegFindData)
            I_MartaRegFreeFindData(pRegContext->pRegFindData);

        if (pRegContext->dwFlags & REG_CONTEXT_CLOSE_HKEY_FLAG)
            RegCloseKey(pRegContext->hKey);
        I_MartaRegFree(pRegContext->pwszObject);

        I_MartaRegFree(pRegContext);
    }

    return ERROR_SUCCESS;
}

DWORD
MartaAddRefRegistryKeyContext(
    IN MARTA_CONTEXT Context
    )

/*++

Routine Description:

    Bump up the ref count for this context.

Arguments:

    Context - Context whose ref count should be bumped up.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;

    if (NULL == pRegContext || 0 == pRegContext->dwRefCnt)
        return ERROR_INVALID_PARAMETER;

    pRegContext->dwRefCnt++;

    return ERROR_SUCCESS;
}


STATIC
inline
BOOL
I_MartaRegIsPredefinedKey(
    IN HKEY hKey
    )

/*++

Routine Description:

    Find if the given key is a predefined key.

Arguments:

    key - Handle to the key.
    
Return Value:

   TRUE - if the key is a predefined key.
   FALSE - Otherwise.

--*/

{
    if (HKEY_CURRENT_USER == hKey ||
            HKEY_LOCAL_MACHINE == hKey ||
            HKEY_USERS == hKey ||
            HKEY_CLASSES_ROOT == hKey ||
            HKEY_CURRENT_CONFIG == hKey)
        return TRUE;
    else
        return FALSE;
}


DWORD
MartaOpenRegistryKeyHandleObject(
    IN  HANDLE               Handle,
    IN  ACCESS_MASK          AccessMask,
    OUT PMARTA_CONTEXT       pContext
    )

/*++

Routine Description:

    Given a registry key handle, open the context with the desired access mask and 
    return a context handle.

Arguments:

    Handle - Existing registry key handle.
    
    AccessMask - Desired access mask for open.
    
    pContext - To return a handle to the context.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/


{
    DWORD dwErr;
    HKEY hKey = (HKEY) Handle;
    PREG_CONTEXT pRegContext = NULL;

    if (ERROR_SUCCESS != (dwErr = I_MartaRegInitContext(&pRegContext)))
        goto ErrorReturn;
    if (0 == AccessMask || I_MartaRegIsPredefinedKey(hKey))
        pRegContext->hKey = hKey;
    else {
        if (ERROR_SUCCESS != (dwErr = RegOpenKeyExW(
                hKey,
                NULL,           // pwszSubKey
                0,              // dwReversed
                AccessMask,
                &pRegContext->hKey)))
            goto ErrorReturn;
        pRegContext->dwFlags |= REG_CONTEXT_CLOSE_HKEY_FLAG;
    }

    dwErr = ERROR_SUCCESS;
CommonReturn:
    *pContext = (MARTA_CONTEXT) pRegContext;
    return dwErr;

ErrorReturn:
    if (pRegContext) {
        MartaCloseRegistryKeyContext((MARTA_CONTEXT) pRegContext);
        pRegContext = NULL;
    }
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;
}


DWORD
MartaGetRegistryKeyParentContext(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pParentContext
    )

/*++

Routine Description:

    Given the context for a registry key, get the context for its parent.

Arguments:

    Context - Context for the registry key.
    
    AccessMask - Desired access mask with which the parent will be opened.
    
    pParentContext - To return the context for the parent.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/



{
    DWORD dwErr;
    LPWSTR pwszParentObject = NULL;

    if (ERROR_SUCCESS != (dwErr = MartaConvertRegistryKeyContextToName(
            Context, &pwszParentObject)))
        goto ErrorReturn;
    if (ERROR_SUCCESS != (dwErr = I_MartaRegGetParentString(
            pwszParentObject)))
        goto NoParentReturn;

    MartaOpenRegistryKeyNamedObject(
        pwszParentObject,
        AccessMask,
        pParentContext
        );

    //
    // Ignore any open errors
    //

    dwErr = ERROR_SUCCESS;

CommonReturn:
    I_MartaRegFree(pwszParentObject);
    return dwErr;

NoParentReturn:
    dwErr = ERROR_SUCCESS;
ErrorReturn:
    *pParentContext = NULL;
    goto CommonReturn;
}


DWORD
MartaFindFirstRegistryKey(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pChildContext
    )

/*++

Routine Description:

    FInd the first registry key in the given container.

Arguments:

    Context - Context for the container.
    
    AccessMask - Desired access mask for opening the child registry key.

    pChildContext - To return the context for the first child in the given container.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

Note:
    Does not free up the current context. 

--*/

{
    DWORD dwErr;
    PREG_CONTEXT pRegParentContext = (PREG_CONTEXT) Context;
    HKEY hKeyParent = pRegParentContext->hKey;

    PREG_CONTEXT pRegFirstContext = NULL;
    PREG_FIND_DATA pRegFindData;    // freed as part of pRegFirstContext
    DWORD cSubKeys;
    DWORD cchMaxSubKey;

    if (ERROR_SUCCESS != (dwErr = I_MartaRegInitContext(&pRegFirstContext)))
        goto ErrorReturn;

    if (ERROR_SUCCESS != (dwErr = RegQueryInfoKeyW(
            hKeyParent,
            NULL,       // lpszClass
            NULL,       // lpcchClass
            NULL,       // lpdwReserved
            &cSubKeys,
            &cchMaxSubKey,
            NULL,       // lpcchMaxClass
            NULL,       // lpcValues
            NULL,       // lpcchMaxValuesName
            NULL,       // lpcbMaxValueData
            NULL,       // lpcbSecurityDescriptor
            NULL        // lpftLastWriteTime
            )))
        goto ErrorReturn;

    //
    // Above returned count doesn't include the terminating null character
    //

    cchMaxSubKey++;

    //
    // Note: HKEY_CURRENT_CONFIG returns a cchMaxSubKey of 0 ????
    //

    if (MAX_PATH > cchMaxSubKey)
        cchMaxSubKey = MAX_PATH;

    if (NULL == (pRegFindData = (PREG_FIND_DATA) I_MartaRegZeroAlloc(
            sizeof(REG_FIND_DATA) + cchMaxSubKey * sizeof(WCHAR))))
        goto NotEnoughMemoryReturn;

    pRegFirstContext->pRegFindData = pRegFindData;
    MartaAddRefRegistryKeyContext((MARTA_CONTEXT) pRegParentContext);
    pRegFindData->pRegParentContext = pRegParentContext;
    pRegFindData->cSubKeys = cSubKeys;
    pRegFindData->cchMaxSubKey = cchMaxSubKey;
    pRegFindData->pwszSubKey =
        (LPWSTR) (((BYTE *) pRegFindData) + sizeof(REG_FIND_DATA));

    //
    // Following closes / frees pRegFirstContext
    //

    dwErr = MartaFindNextRegistryKey(
        (MARTA_CONTEXT) pRegFirstContext,
        AccessMask,
        pChildContext
        );
CommonReturn:
    return dwErr;
ErrorReturn:
    if (pRegFirstContext)
        MartaCloseRegistryKeyContext((MARTA_CONTEXT) pRegFirstContext);
    *pChildContext = NULL;

    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;
}

DWORD
MartaFindNextRegistryKey(
    IN  MARTA_CONTEXT  Context,
    IN  ACCESS_MASK    AccessMask,
    OUT PMARTA_CONTEXT pSiblingContext
    )

/*++

Routine Description:

    Get the next object in the tree. This is the sibling for the current context.

Arguments:

    Context - Context for the current object.

    AccessMask - Desired access mask for the opening the sibling.
    
    pSiblingContext - To return a handle for the sibling.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

Note:

    Closes the current context.
    
--*/

{
    DWORD dwErr;

    PREG_CONTEXT pRegPrevContext = (PREG_CONTEXT) Context;
    PREG_CONTEXT pRegSiblingContext = NULL;

    //
    // Following don't need to be freed or closed
    //

    PREG_CONTEXT pRegParentContext;
    PREG_FIND_DATA pRegFindData;
    HKEY hKeyParent;
    DWORD cchMaxSubKey;
    LPWSTR pwszSubKey;

    if (ERROR_SUCCESS != (dwErr = I_MartaRegInitContext(&pRegSiblingContext)))
        goto ErrorReturn;

    //
    // Move the FindData on to the sibling context
    //

    pRegFindData = pRegPrevContext->pRegFindData;
    if (NULL == pRegFindData)
        goto InvalidParameterReturn;
    pRegPrevContext->pRegFindData = NULL;
    pRegSiblingContext->pRegFindData = pRegFindData;

    if (pRegFindData->iSubKey >= pRegFindData->cSubKeys)
        goto NoMoreItemsReturn;

    pRegParentContext = pRegFindData->pRegParentContext;
    hKeyParent = pRegParentContext->hKey;
    pwszSubKey = pRegFindData->pwszSubKey;
    cchMaxSubKey = pRegFindData->cchMaxSubKey;
    if (ERROR_SUCCESS != (dwErr = RegEnumKeyExW(
            hKeyParent,
            pRegFindData->iSubKey,
            pwszSubKey,
            &cchMaxSubKey,
            NULL,               // lpdwReserved
            NULL,               // lpszClass
            NULL,               // lpcchClass
            NULL                // lpftLastWriteTime
            )))
        goto ErrorReturn;
    pRegFindData->iSubKey++;

    if (pRegParentContext->pwszObject)

        //
        // Ignore errors. Mainly here for testing purposes.
        //

        I_MartaRegCreateChildString(
            pRegParentContext->pwszObject,
            pwszSubKey,
            &pRegSiblingContext->pwszObject
            );

    if (ERROR_SUCCESS == (dwErr = RegOpenKeyExW(
            hKeyParent,
            pwszSubKey,
            0,              // dwReversed
            AccessMask,
            &pRegSiblingContext->hKey)))
        pRegSiblingContext->dwFlags |= REG_CONTEXT_CLOSE_HKEY_FLAG;

    // 
    //  For an error still return this context. This allows the caller
    //  to continue on to the next sibling object and know there was an
    //  error with this sibling object
    //

CommonReturn:
    MartaCloseRegistryKeyContext(Context);
    *pSiblingContext = (MARTA_CONTEXT) pRegSiblingContext;
    return dwErr;

ErrorReturn:
    if (pRegSiblingContext) {
        MartaCloseRegistryKeyContext((MARTA_CONTEXT) pRegSiblingContext);
        pRegSiblingContext = NULL;
    }

    // kedar wants this mapped to success
    if (ERROR_NO_MORE_ITEMS == dwErr)
        dwErr = ERROR_SUCCESS;
    goto CommonReturn;

InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
NoMoreItemsReturn:
    dwErr = ERROR_NO_MORE_ITEMS;
    goto ErrorReturn;
}


DWORD
MartaConvertRegistryKeyContextToName(
    IN MARTA_CONTEXT        Context,
    OUT LPWSTR              *ppwszObject
    )

/*++

Routine Description:

    Returns the NT Object Name for the given context. Allocates memory.

Arguments:

    Context - Context for the registry key.

    ppwszObject - To return the name of the registry key.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/


{
    DWORD dwErr = ERROR_SUCCESS;
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;
    LPWSTR pwszObject = NULL;

    BYTE Buff[512];
    ULONG cLen = 0;
    POBJECT_NAME_INFORMATION pNI;                   // not allocated
    POBJECT_NAME_INFORMATION pAllocNI = NULL;
    NTSTATUS Status;

    if (NULL == pRegContext || 0 == pRegContext->dwRefCnt)
        goto InvalidParameterReturn;

    if (pRegContext->pwszObject) {

        //
        // Already have the object's name
        //

        if (ERROR_SUCCESS != (dwErr = I_MartaRegDupString(
                pRegContext->pwszObject, &pwszObject)))
            goto ErrorReturn;
        else
            goto SuccessReturn;
    } else {
        HKEY hKey = pRegContext->hKey;
        LPWSTR pwszPath;
        DWORD cchPath;

        //
        // First, determine the size of the buffer we need...
        //

        pNI = (POBJECT_NAME_INFORMATION) Buff;
        Status = NtQueryObject(hKey,
            ObjectNameInformation,
            pNI,
            sizeof(Buff),
            &cLen);
        if (!NT_SUCCESS(Status) || sizeof(*pNI) > cLen ||
                0 == pNI->Name.Length) {
            if (Status == STATUS_BUFFER_TOO_SMALL ||
                    Status == STATUS_INFO_LENGTH_MISMATCH ||
                    Status == STATUS_BUFFER_OVERFLOW) {

                //
                // Allocate a big enough buffer
                //

                if (NULL == (pAllocNI = (POBJECT_NAME_INFORMATION)
                        I_MartaRegNonzeroAlloc(cLen)))
                    goto NotEnoughMemoryReturn;
                pNI = pAllocNI;

                Status = NtQueryObject(hKey,
                                       ObjectNameInformation,
                                       pNI,
                                       cLen,
                                       NULL);
                if (!NT_SUCCESS(Status))
                    goto StatusErrorReturn;
            } else {

                //
                // Check if one of the predefined base keys
                //

                LPCWSTR pwszBaseKey = NULL;

                if (HKEY_LOCAL_MACHINE == hKey)
                    pwszBaseKey = L"MACHINE";
                else if (HKEY_USERS == hKey)
                    pwszBaseKey = L"USERS";
                else if (HKEY_CLASSES_ROOT == hKey)
                    pwszBaseKey = L"CLASSES_ROOT";
                else if (HKEY_CURRENT_USER == hKey)
                    pwszBaseKey = L"CURRENT_USER";
                else if (HKEY_CURRENT_CONFIG == hKey)
                    pwszBaseKey = L"CONFIG";
                else if (!NT_SUCCESS(Status))
                    goto StatusErrorReturn;
                else
                    goto InvalidHandleReturn;

                if (ERROR_SUCCESS != (dwErr = I_MartaRegDupString(
                        pwszBaseKey, &pwszObject)))
                    goto ErrorReturn;
                else
                    goto SuccessReturn;
            }
        }

        pwszPath = pNI->Name.Buffer;
        cchPath = pNI->Name.Length / sizeof(WCHAR);

        if (REG_OBJ_TAG_LEN > cchPath ||
                0 != _wcsnicmp(pwszPath, REG_OBJ_TAG, REG_OBJ_TAG_LEN))
            goto BadPathnameReturn;

        pwszPath += REG_OBJ_TAG_LEN;
        cchPath -= REG_OBJ_TAG_LEN;

        if (NULL == (pwszObject = (LPWSTR) I_MartaRegNonzeroAlloc(
                (cchPath + 1) * sizeof(WCHAR))))
            goto NotEnoughMemoryReturn;

        memcpy(pwszObject, pwszPath, cchPath * sizeof(WCHAR));
        pwszObject[cchPath] = L'\0';
    }

SuccessReturn:
    dwErr = ERROR_SUCCESS;

CommonReturn:
    I_MartaRegFree(pAllocNI);
    *ppwszObject = pwszObject;
    return dwErr;

StatusErrorReturn:
    dwErr = RtlNtStatusToDosError(Status);
ErrorReturn:
    assert(NULL == pwszObject);
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;

InvalidHandleReturn:
    dwErr = ERROR_INVALID_HANDLE;
    goto ErrorReturn;

BadPathnameReturn:
    dwErr = ERROR_BAD_PATHNAME;
    goto ErrorReturn;

InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
}

DWORD
MartaConvertRegistryKeyContextToHandle(
    IN MARTA_CONTEXT        Context,
    OUT HANDLE              *pHandle
    )

/*++

Routine Description:

    The following is for testing

    The returned Handle isn't duplicated. It has the same lifetime as
    the Context

Arguments:

    Context - Context whose properties the caller has asked for.
    
    pHandle - To return the handle.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_NOT_ENOUGH_MEMORY if allocation failed.

--*/

{
    DWORD dwErr;
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;

    if (NULL == pRegContext || 0 == pRegContext->dwRefCnt) {
        *pHandle = NULL;
        dwErr = ERROR_INVALID_PARAMETER;
    } else {
        *pHandle = (HANDLE) pRegContext->hKey;
        dwErr = ERROR_SUCCESS;
    }

    return dwErr;
}

DWORD
MartaGetRegistryKeyProperties(
    IN     MARTA_CONTEXT            Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    )

/*++

Routine Description:

    Return the properties for registry key represented by the context.

Arguments:

    Context - Context whose properties the caller has asked for.
    
    pProperties - To return the properties for this registry key.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    pProperties->dwFlags |= MARTA_OBJECT_IS_CONTAINER;
    return ERROR_SUCCESS;
}

DWORD
MartaGetRegistryKeyTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    )

/*++

Routine Description:

    Return the properties of registry key objects.

Arguments:

    pProperties - To return the properties of registry key objects.

Return Value:

    ERROR_SUCCESS.

--*/

{
    const GENERIC_MAPPING GenMap = {
        KEY_READ,
        KEY_WRITE,
        KEY_EXECUTE,
        KEY_ALL_ACCESS
        };

    pProperties->dwFlags |= MARTA_OBJECT_TYPE_MANUAL_PROPAGATION_NEEDED_FLAG;
    pProperties->dwFlags |= MARTA_OBJECT_TYPE_INHERITANCE_MODEL_PRESENT_FLAG;
    pProperties->GenMap = GenMap;

    return ERROR_SUCCESS;
}

DWORD
MartaGetRegistryKeyRights(
    IN  MARTA_CONTEXT          Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )

/*++

Routine Description:

    Get the security descriptor for the given handle.

Arguments:

    Context - Context for registry key.
    
    SecurityInfo - Type of security information to be read.
    
    ppSecurityDescriptor - To return a self-relative security decriptor pointer.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;
    DWORD cbSize;
    PISECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    if (NULL == pRegContext || 0 == pRegContext->dwRefCnt)
        goto InvalidParameterReturn;

    //
    // First, get the size we need
    //

    cbSize = 0;
    dwErr = RegGetKeySecurity(
        pRegContext->hKey,
        SecurityInfo,
        NULL,                       // pSecDesc
        &cbSize
        );

    if (ERROR_INSUFFICIENT_BUFFER == dwErr) {
        if (NULL == (pSecurityDescriptor =
                (PISECURITY_DESCRIPTOR) I_MartaRegNonzeroAlloc(cbSize)))
            goto NotEnoughMemoryReturn;

        dwErr = RegGetKeySecurity(
            pRegContext->hKey,
            SecurityInfo,
            pSecurityDescriptor,
            &cbSize
            );
    } else if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;

    if (ERROR_SUCCESS != dwErr)
        goto ErrorReturn;

CommonReturn:
    *ppSecurityDescriptor = pSecurityDescriptor;
    return dwErr;

ErrorReturn:
    if (pSecurityDescriptor) {
        I_MartaRegFree(pSecurityDescriptor);
        pSecurityDescriptor = NULL;
    }
    assert(ERROR_SUCCESS != dwErr);
    if (ERROR_SUCCESS == dwErr)
        dwErr = ERROR_INTERNAL_ERROR;
    goto CommonReturn;

NotEnoughMemoryReturn:
    dwErr = ERROR_NOT_ENOUGH_MEMORY;
    goto ErrorReturn;
InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto ErrorReturn;
}


DWORD
MartaSetRegistryKeyRights(
    IN MARTA_CONTEXT        Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )


/*++

Routine Description:

    Set the given security descriptor on the registry key represented by the context.

Arguments:

    Context - Context for the registry key.

    SecurityInfo - Type of security info to be stamped on the registry key.

    pSecurityDescriptor - Security descriptor to be stamped.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;

    if (NULL == pRegContext || 0 == pRegContext->dwRefCnt)
        goto InvalidParameterReturn;

    dwErr = RegSetKeySecurity(
        pRegContext->hKey,
        SecurityInfo,
        pSecurityDescriptor
        );

CommonReturn:
    return dwErr;
InvalidParameterReturn:
    dwErr = ERROR_INVALID_PARAMETER;
    goto CommonReturn;
}

ACCESS_MASK
MartaGetRegistryKeyDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    )

/*++

Routine Description:

    Gets the access required to open object to be able to set or get the 
    specified security info.

Arguments:

    OpenType - Flag indicating if the object is to be opened to read or write
        the security information

    Attribs - TRUE indicates that additional access bits should be returned.

    SecurityInfo - owner/group/dacl/sacl

Return Value:

    Desired access mask with which open should be called.

--*/

{
    ACCESS_MASK DesiredAccess = 0;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    }

    if (TRUE == Attribs)
    {
        DesiredAccess |= KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE;
    }

    return (DesiredAccess);
}

ACCESS_MASK
MartaGetRegistryKey32DesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    )

/*++

Routine Description:

    Gets the access required to open object to be able to set or get the 
    specified security info.

Arguments:

    OpenType - Flag indicating if the object is to be opened to read or write
        the security information

    Attribs - TRUE indicates that additional access bits should be returned.

    SecurityInfo - owner/group/dacl/sacl

Return Value:

    Desired access mask with which open should be called.

--*/

{
    ACCESS_MASK DesiredAccess = KEY_WOW64_32KEY;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= READ_CONTROL | ACCESS_SYSTEM_SECURITY;
    }

    if (TRUE == Attribs)
    {
        DesiredAccess |= KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE;
    }

    return (DesiredAccess);
}
ACCESS_MASK
MartaGetDefaultDesiredAccess(
    IN SECURITY_OPEN_TYPE   OpenType,
    IN BOOL                 Attribs,
    IN SECURITY_INFORMATION SecurityInfo
    )

/*++

Routine Description:

    Gets the access required to open object to be able to set or get the 
    specified security info. This default routine is used for all resource
    managers except for files/reg.

Arguments:

    OpenType - Flag indicating if the object is to be opened to read or write
        the security information

    Attribs - TRUE indicates that additional access bits should be returned.

    SecurityInfo - owner/group/dacl/sacl

Return Value:

    Desired access mask with which open should be called.

--*/

{
    ACCESS_MASK DesiredAccess = 0;

    if ( (SecurityInfo & OWNER_SECURITY_INFORMATION) ||
         (SecurityInfo & GROUP_SECURITY_INFORMATION) )
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_OWNER;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_OWNER;
            break;
        }
    }

    if (SecurityInfo & DACL_SECURITY_INFORMATION)
    {
        switch (OpenType)
        {
        case READ_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL;
            break;
        case WRITE_ACCESS_RIGHTS:
            DesiredAccess |= WRITE_DAC;
            break;
        case MODIFY_ACCESS_RIGHTS:
            DesiredAccess |= READ_CONTROL | WRITE_DAC;
            break;
        }
    }

    if (SecurityInfo & SACL_SECURITY_INFORMATION)
    {
        DesiredAccess |= ACCESS_SYSTEM_SECURITY;
    }

    return (DesiredAccess);
}

DWORD
MartaReopenRegistryKeyContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    )

/*++

Routine Description:

    Given the context for a registry key, close the existing handle if one exists 
    and reopen the context with new permissions.

Arguments:

    Context - Context to be reopened.
    
    AccessMask - Permissions for the reopen.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    DWORD dwErr;
    HKEY hKey;
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;
    PREG_FIND_DATA pRegFindData = pRegContext->pRegFindData;
    PREG_CONTEXT pRegParentContext = pRegFindData->pRegParentContext;

    dwErr = RegOpenKeyExW(
                pRegParentContext->hKey,
                pRegFindData->pwszSubKey,
                0,              // dwReversed
                AccessMask,
                &hKey);

    if (ERROR_SUCCESS == dwErr) {
        if (pRegContext->dwFlags & REG_CONTEXT_CLOSE_HKEY_FLAG)
            RegCloseKey(pRegContext->hKey);
        pRegContext->hKey = hKey;
        pRegContext->dwFlags |= REG_CONTEXT_CLOSE_HKEY_FLAG;
    }

    return dwErr;
}

DWORD
MartaReopenRegistryKeyOrigContext(
    IN OUT MARTA_CONTEXT Context,
    IN     ACCESS_MASK   AccessMask
    )

/*++

Routine Description:

    Reopen the original context with a new access mask. Close the original 
    handle.

Arguments:

    Context - Context to reopen.
    
    AccessMask - Desired access for open.
    
Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_NOT_ENOUGH_MEMORY if allocation failed.

--*/

{
    DWORD dwErr;
    HKEY hKey;
    PREG_CONTEXT pRegContext = (PREG_CONTEXT) Context;

    dwErr = RegOpenKeyExW(
                pRegContext->hKey,
                NULL,           // pwszSubKey
                0,              // dwReversed
                AccessMask,
                &hKey);

    if (ERROR_SUCCESS == dwErr) {
        if (pRegContext->dwFlags & REG_CONTEXT_CLOSE_HKEY_FLAG)
            RegCloseKey(pRegContext->hKey);
        pRegContext->hKey = hKey;
        pRegContext->dwFlags |= REG_CONTEXT_CLOSE_HKEY_FLAG;
    }

    return dwErr;
}

DWORD
MartaGetRegistryKeyNameFromContext(
    IN LPWSTR Ignore1,
    IN LPWSTR Ignore2,
    IN MARTA_CONTEXT Context,
    OUT LPWSTR *pObjectName
    )

/*++

Routine Description:

    Get the name of the registry key from the context. This routine allocates 
    memory required to hold the name of the object.

Arguments:

    Ignore1 - To be ignored. Useful in file system.

    Ignore2 - To be ignored. Useful in file system.

    Context - Handle to the context.
    
    pObjectName - To return the pointer to the allocated string.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    return MartaConvertRegistryKeyContextToName(
               Context,
               pObjectName
               );
}

DWORD
MartaGetRegistryKeyParentName(
    IN LPWSTR ObjectName,
    OUT LPWSTR *pParentName
    )

/*++

Routine Description:

    Given the name of a registry key return the name of its parent. The routine 
    allocates memory required to hold the parent name.

Arguments:

    ObjectName - Name of the registry key.
    
    pParentName - To return the pointer to the allocated parent name.
        In case of the root of the tree, we return NULL parent with ERROR_SUCCESS.

Return Value:

    ERROR_SUCCESS in case of success.
    ERROR_* otherwise

--*/

{
    ULONG Length = wcslen(ObjectName) + 1;
    PWCHAR Name = (PWCHAR) I_MartaRegNonzeroAlloc(sizeof(WCHAR) * Length);
    DWORD dwErr = ERROR_SUCCESS;

    *pParentName = NULL;

    if (!Name)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy((WCHAR *) Name, ObjectName);

    dwErr = I_MartaRegGetParentString(Name);

    if (ERROR_SUCCESS != dwErr)
    {
        I_MartaRegFree(Name);

        if (ERROR_INVALID_NAME == dwErr)
            return ERROR_SUCCESS;

        return dwErr;
    }

    *pParentName = Name;

    return dwErr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\sidcache.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1997.
//
//  File:        sidcache.cxx
//
//  Contents:    Implementation of the sid/name lookup cache
//
//  History:     2-Feb-97       MacM        Created
//
//--------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

//
// Global name/sid cache
//
PACTRL_NAME_CACHE    grgNameCache[ACTRL_NAME_TABLE_SIZE];
PACTRL_NAME_CACHE    grgSidCache[ACTRL_NAME_TABLE_SIZE];

//
// Local function prototypes
//
PACTRL_NAME_CACHE AccctrlpLookupNameInCache(PWSTR   pwszName);

PACTRL_NAME_CACHE AccctrlpLookupSidInCache(PSID     pSid);

DWORD   AccctrlpNewNameSidNode(PWSTR                pwszName,
                               PSID                 pSid,
                               SID_NAME_USE         SidNameUse,
                               PACTRL_NAME_CACHE   *ppNewNode);

VOID    AccctrlpInsertNameNode(PACTRL_NAME_CACHE *ppRootNode,
                               PACTRL_NAME_CACHE  pNewNode);

VOID    AccctrlpInsertSidNode(PACTRL_NAME_CACHE *ppRootNode,
                              PACTRL_NAME_CACHE  pNewNode);

DWORD   AccctrlpConvertUserToCacheName(PWSTR      pwszServer,
                                       PWSTR      pwszName,
                                       PWSTR     *ppwszCacheName);

VOID    AccctrlpFreeUserCacheName(PWSTR      pwszName,
                                  PWSTR      pwszCacheName);

static RTL_RESOURCE gSidCacheLock;
BOOL bSidCacheLockInitialized = FALSE;

//+----------------------------------------------------------------------------
//
//  Function:   ActrlHashName
//
//  Synopsis:   Determines the hash index for the given name
//
//  Arguments:  pwszName        --      Name to hash
//
//  Returns:    Hash index of the string
//
//-----------------------------------------------------------------------------
INT
ActrlHashName(PWSTR pwszName)
{
    //
    // We'll hash off of just the user name, not the domain name or
    // any other name format
    //
    PWSTR   pwszUser = wcschr(pwszName, L'\\');
    if(pwszUser == NULL)
    {
        pwszUser = pwszName;
    }
    else
    {
        pwszUser++;
    }

    INT Hash = 0;
    if(pwszUser != NULL)
    {
        while(*pwszUser != L'\0')
        {
            Hash = (Hash * 16 + ( *pwszUser++)) % ACTRL_NAME_TABLE_SIZE;
        }
    }

    acDebugOut((DEB_TRACE_LOOKUP,"Hashing %ws to %lu\n", pwszName, Hash));

    return(Hash);
}




//+----------------------------------------------------------------------------
//
//  Function:   ActrlHashSid
//
//  Synopsis:   Determines the hash index for the given sid
//
//  Arguments:  pSid            --      Sid to hash
//
//  Returns:    Hash index of the Sid
//
//-----------------------------------------------------------------------------
INT
ActrlHashSid(PSID   pSid)
{
    DWORD   dwTotal = 0;

    //
    // Just deal with the sub authorities
    //
    for(INT i = 0; i < (INT)(((PISID)pSid)->SubAuthorityCount); i++)
    {
        dwTotal += ((PISID)pSid)->SubAuthority[i];
    }

#if DBG

    UNICODE_STRING SidString;

    memset(&SidString, 0, sizeof(UNICODE_STRING));

    if(pSid != NULL)
    {
        NTSTATUS Status = RtlConvertSidToUnicodeString(&SidString,
                                                       pSid,
                                                       TRUE);
        if(!NT_SUCCESS(Status))
        {
            acDebugOut((DEB_ERROR, "Can't convert sid to string: 0x%lx\n", Status));
        }
        else
        {
            acDebugOut((DEB_TRACE_LOOKUP,"Hashing %wZ (Total %lu) to %lu\n", &SidString,
                       dwTotal, dwTotal % ACTRL_NAME_TABLE_SIZE));
        }
    }


#endif
    return(dwTotal % ACTRL_NAME_TABLE_SIZE);
}





//+----------------------------------------------------------------------------
//
//  Function:   AccctrlInitializeSidNameCache
//
//  Synopsis:   Initialize the name/sid lookup cache
//
//  Arguments:  VOID
//
//  Returns:    ERROR_SUCCESS   --      Success
//
//-----------------------------------------------------------------------------
DWORD AccctrlInitializeSidNameCache(VOID)
{
    DWORD dwErr;

    if (TRUE == bSidCacheLockInitialized)
    {
        //
        // Just a precautionary measure to make sure that we do not initialize
        // multiple times.
        //

        ASSERT(FALSE);
        return ERROR_SUCCESS;
    }

    memset(grgNameCache, 0, sizeof(PACTRL_NAME_CACHE) * ACTRL_NAME_TABLE_SIZE);
    memset(grgSidCache, 0, sizeof(PACTRL_NAME_CACHE) * ACTRL_NAME_TABLE_SIZE);

    __try
    {
        RtlInitializeResource(&gSidCacheLock);
        dwErr = ERROR_SUCCESS;
        bSidCacheLockInitialized = TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        dwErr = RtlNtStatusToDosError(GetExceptionCode());
    }

    return dwErr;
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlFreeSidNameCache
//
//  Synopsis:   Frees any memory allocated for the name/sid cache
//
//  Arguments:  VOID
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID AccctrlFreeSidNameCache(VOID)
{
    INT i;
    PACTRL_NAME_CACHE   pNode, pNext;

    if (FALSE == bSidCacheLockInitialized)
    {
        return;
    }

    for(i = 0; i < ACTRL_NAME_TABLE_SIZE; i++)
    {
        //
        // Nodes are only inserted into the name cache, so that is the only
        // place we delete them from
        //
        pNode = grgNameCache[i];
        while(pNode != NULL)
        {
            pNext = pNode->pNextName;
            AccFree(pNode->pwszName);
            AccFree(pNode->pSid);
            AccFree(pNode);
            pNode = pNext;
        }
    }

    RtlDeleteResource(&gSidCacheLock);

    bSidCacheLockInitialized = FALSE;

}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpLookupNameInCache
//
//  Synopsis:   Determines if the given name exists in the cache or not
//
//  Arguments:  [pwszName]      --      Name to be looked up
//
//  Returns:    Matching node if found, NULL if not
//
//-----------------------------------------------------------------------------
PACTRL_NAME_CACHE AccctrlpLookupNameInCache(PWSTR   pwszName)
{
    PACTRL_NAME_CACHE   pNode = NULL;

    pNode =  grgNameCache[ActrlHashName(pwszName)];

    while(pNode != NULL)
    {
        if(_wcsicmp(pwszName, pNode->pwszName) == 0)
        {
            break;
        }
        pNode = pNode->pNextName;
    }

    return(pNode);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpLookupSidInCache
//
//  Synopsis:   Determines if the given sid exists in the cache or not
//
//  Arguments:  [pSid]          --      Sid to be looked up
//
//  Returns:    Matching node if found, NULL if not
//
//-----------------------------------------------------------------------------
PACTRL_NAME_CACHE AccctrlpLookupSidInCache(PSID     pSid)
{
    PACTRL_NAME_CACHE   pNode = grgSidCache[ActrlHashSid(pSid)];

    while(pNode != NULL)
    {
        if(RtlEqualSid(pSid, pNode->pSid) == TRUE)
        {
            break;
        }
        pNode = pNode->pNextSid;
    }

    return(pNode);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpNewNameSidNode
//
//  Synopsis:   Allocates a new node and inserts them into the caches
//
//  Arguments:  [pwszName]      --      Name to insert
//              [pSid]          --      Sid to insert
//              [SidNameUse]    --      Name use
//              [pNewNode]      --      Newly added node
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//-----------------------------------------------------------------------------
DWORD   AccctrlpNewNameSidNode(PWSTR                pwszName,
                               PSID                 pSid,
                               SID_NAME_USE         SidNameUse,
                               PACTRL_NAME_CACHE   *ppNewNode)
{
    DWORD   dwErr = ERROR_SUCCESS;

    PACTRL_NAME_CACHE   pNewNode = (PACTRL_NAME_CACHE)AccAlloc(
                                                    sizeof(ACTRL_NAME_CACHE));
    if(pNewNode == NULL)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
    }
    else
    {
        pNewNode->pwszName = pwszName;
        pNewNode->pSid     = pSid;
        pNewNode->SidUse   = SidNameUse;
        pNewNode->pNextName= NULL;
        pNewNode->pNextSid = NULL;

        AccctrlpInsertNameNode(&(grgNameCache[ActrlHashName(pwszName)]),
                               pNewNode);

        AccctrlpInsertSidNode(&(grgSidCache[ActrlHashSid(pSid)]),
                              pNewNode);

        *ppNewNode = pNewNode;

    }
    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpInsertNameNode
//
//  Synopsis:   Inserts the specified new node into the caches
//
//  Arguments:  [ppRootNode]    --      Root node in the name cache
//              [pNewNode]      --      Node to insert
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID    AccctrlpInsertNameNode(PACTRL_NAME_CACHE *ppRootNode,
                               PACTRL_NAME_CACHE  pNewNode)
{
    PACTRL_NAME_CACHE   pNext = NULL;

    if(*ppRootNode == NULL)
    {
        *ppRootNode = pNewNode;
    }
    else
    {
        acDebugOut((DEB_TRACE_LOOKUP, "Collision inserting %ws with:\n", pNewNode->pwszName));

        pNext = *ppRootNode;
        acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        while(pNext->pNextName != NULL)
        {
#if DBG
            if(_wcsicmp(pNewNode->pwszName, pNext->pwszName) == 0)
            {
                acDebugOut((DEB_ERROR, "Name %ws already in list: 0x%lx\n",
                            pNewNode->pwszName,
                            *ppRootNode));
//                ASSERT(FALSE);
            }
#endif

            pNext = pNext->pNextName;
            acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        }
        pNext->pNextName = pNewNode;
    }
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpInsertSidNode
//
//  Synopsis:   Inserts the specified new node into the caches
//
//  Arguments:  [ppRootNode]    --      Root node in the name cache
//              [pNewNode]      --      Node to insert
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID    AccctrlpInsertSidNode(PACTRL_NAME_CACHE *ppRootNode,
                              PACTRL_NAME_CACHE  pNewNode)
{
    PACTRL_NAME_CACHE   pNext = NULL;

    if(*ppRootNode == NULL)
    {
        *ppRootNode = pNewNode;
    }
    else
    {
        acDebugOut((DEB_TRACE_LOOKUP, "Collision inserting %ws with:\n", pNewNode->pwszName));

        pNext = *ppRootNode;
        acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        while(pNext->pNextSid != NULL)
        {
#if DBG
            if(RtlEqualSid(pNewNode->pSid, pNext->pSid) == TRUE)
            {
                acDebugOut((DEB_ERROR, "Sid for %ws already in list: 0x%lx\n",
                            pNewNode->pwszName,
                            *ppRootNode));
//                ASSERT(FALSE);
            }
#endif

            pNext = pNext->pNextSid;

            acDebugOut((DEB_TRACE_LOOKUP, "\t%ws\n", pNext->pwszName));
        }
        pNext->pNextSid = pNewNode;
    }
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlLookupName
//
//  Synopsis:   Looks up the name for the specified SID
//
//  Arguments:  [pwszServer]    --      Name of the server to remote the call to
//              [pSid]          --      Sid to lookup
//              [fAllocateReturn]-      If true, the name returned is allocated
//                                      into a new buffer.  Otherwise, a
//                                      reference is returned.
//              [ppwszName]     --      Where the name is returned.
//              [pSidNameUse]   --      Type of the name that's returned.
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
DWORD
AccctrlLookupName(IN  PWSTR          pwszServer,
                  IN  PSID           pSid,
                  IN  BOOL           fAllocateReturn,
                  OUT PWSTR         *ppwszName,
                  OUT PSID_NAME_USE  pSidNameUse)
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(pSid == NULL)
    {
        return(ERROR_NONE_MAPPED);
    }

    RtlAcquireResourceShared(&gSidCacheLock, TRUE);

#if DBG
    UNICODE_STRING SidString;

    memset(&SidString, 0, sizeof(UNICODE_STRING));

    if(pSid != NULL)
    {
        NTSTATUS Status = RtlConvertSidToUnicodeString(&SidString,
                                                       pSid,
                                                       TRUE);
        if(!NT_SUCCESS(Status))
        {
            acDebugOut((DEB_ERROR, "Can't convert sid to string: 0x%lx\n", Status));
        }
    }
#endif

    //
    // First, see if the sid alreadt exists in our cache
    //
    PACTRL_NAME_CACHE pNode = AccctrlpLookupSidInCache(pSid);
    if(pNode == NULL)
    {
#if DBG
        acDebugOut((DEB_TRACE_LOOKUP, "Sid %wZ not found in cache\n", &SidString));
#endif
        //
        // Grab a write lock
        //
        RtlConvertSharedToExclusive(&gSidCacheLock);


        //
        // We'll have to look it up...
        //
        PWSTR   pwszName, pwszDomain;
        dwErr = AccLookupAccountName(pwszServer,
                                     pSid,
                                     &pwszName,
                                     &pwszDomain,
                                     pSidNameUse);
        if(dwErr == ERROR_SUCCESS)
        {
            PSID    pNewSid = NULL;
            ACC_ALLOC_AND_COPY_SID(pSid, pNewSid, dwErr);
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = AccctrlpNewNameSidNode(pwszName,
                                               pNewSid,
                                               *pSidNameUse,
                                               &pNode);
            }

            if(dwErr != ERROR_SUCCESS)
            {
                AccFree(pwszName);
                AccFree(pNewSid);
            }
            AccFree(pwszDomain);
        }
    }
#if DBG
    else
    {
        acDebugOut((DEB_TRACE_LOOKUP, "Sid %wZ found in cache\n", &SidString));
    }
#endif

    //
    // Finally, return the information
    //
    if(dwErr == ERROR_SUCCESS)
    {
        if(fAllocateReturn == TRUE)
        {
            ACC_ALLOC_AND_COPY_STRINGW(pNode->pwszName, *ppwszName, dwErr);
        }
        else
        {
            *ppwszName = pNode->pwszName;
        }

        *pSidNameUse = pNode->SidUse;
    }

    RtlReleaseResource(&gSidCacheLock);

    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlLookupSid
//
//  Synopsis:   Looks up the SID for the specified name
//
//  Arguments:  [pwszServer]    --      Name of the server to remote the call to
//              [pwszName]      --      Name to lookup
//              [fAllocateReturn]-      If true, the name returned is allocated
//                                      into a new buffer.  Otherwise, a
//                                      reference is returned.
//              [ppwszName]     --      Where the name is returned.
//              [pSidNameUse]   --      Type of the sid that's returned.
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
DWORD
AccctrlLookupSid(IN  PWSTR          pwszServer,
                 IN  PWSTR          pwszName,
                 IN  BOOL           fAllocateReturn,
                 OUT PSID          *ppSid,
                 OUT PSID_NAME_USE  pSidNameUse)
{
    DWORD   dwErr = ERROR_SUCCESS;
    PWSTR   pwszLookupName = pwszName;

    RtlAcquireResourceShared(&gSidCacheLock, TRUE);

    //
    // If we get a local name, convert it into machine/domain relative, so we can
    // look it up properly.
    //
    dwErr = AccctrlpConvertUserToCacheName(pwszServer, pwszName, &pwszLookupName);

    //
    // Just return if the conversion failed.
    //

    if (pwszLookupName == NULL)
    {
        if (dwErr == ERROR_SUCCESS)
        {
            dwErr = ERROR_ACCESS_DENIED;
        }
    }

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, see if the sid already exists in our cache
        //
        PACTRL_NAME_CACHE pNode = AccctrlpLookupNameInCache(pwszLookupName);
        if(pNode == NULL)
        {
            //
            // Grab a write lock
            //
            RtlConvertSharedToExclusive(&gSidCacheLock);

            acDebugOut((DEB_TRACE_LOOKUP,"Name %ws not found in cache\n", pwszLookupName));
            //
            // We'll have to look it up...
            //
            TRUSTEE_W   Trustee;
            memset(&Trustee, 0, sizeof(TRUSTEE_W));
            Trustee.TrusteeForm = TRUSTEE_IS_NAME;
            Trustee.ptstrName = pwszLookupName;

            dwErr = AccLookupAccountSid(pwszServer,
                                        &Trustee,
                                        ppSid,
                                        pSidNameUse);
            if(dwErr == ERROR_SUCCESS)
            {
                PWSTR   pwszNewName = NULL;
                ACC_ALLOC_AND_COPY_STRINGW(pwszLookupName, pwszNewName, dwErr);
                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = AccctrlpNewNameSidNode(pwszNewName,
                                                   *ppSid,
                                                   *pSidNameUse,
                                                   &pNode);
                }

                if(dwErr != ERROR_SUCCESS)
                {
                    AccFree(pwszNewName);
                    AccFree(*ppSid);
                }
            }
        }
    #if DBG
        else
        {
            acDebugOut((DEB_TRACE_LOOKUP,"Name %ws found in cache\n", pwszLookupName));
        }
    #endif

        //
        // Finally, return the information
        //
        if(dwErr == ERROR_SUCCESS)
        {
            if(fAllocateReturn == TRUE)
            {
                ACC_ALLOC_AND_COPY_SID(pNode->pSid, *ppSid, dwErr);
            }
            else
            {
                *ppSid = pNode->pSid;
            }

            *pSidNameUse = pNode->SidUse;
        }

        AccctrlpFreeUserCacheName(pwszName, pwszLookupName);
    }

    RtlReleaseResource(&gSidCacheLock);


    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpConvertUserToCacheName
//
//  Synopsis:   Converts an input name that could be domain relative into a
//              standard format for caching/returning
//
//  Arguments:  [pwszServer]    --      Server to lookup the name on
//              [pwszName]      --      Original name format
//              [ppwszCacheName]--      Name in the proper format
//
//  Returns:    ERROR_SUCCESS   --      Success
//              ERROR_NOT_ENOUGH_MEMORY A memory allocation failed
//
//-----------------------------------------------------------------------------
DWORD   AccctrlpConvertUserToCacheName(PWSTR      pwszServer,
                                       PWSTR      pwszName,
                                       PWSTR     *ppwszCacheName)
{
    DWORD   dwErr = ERROR_SUCCESS;

    //
    // This is temporary until the name conversion APIs come into being
    //
    PSID    pSid;
    SID_NAME_USE    SNE;
    TRUSTEE_W   Trustee;
    memset(&Trustee, 0, sizeof(TRUSTEE_W));
    Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    Trustee.ptstrName = pwszName;

    dwErr = AccLookupAccountSid(pwszServer,
                                &Trustee,
                                &pSid,
                                &SNE);
    if(dwErr == ERROR_SUCCESS)
    {
        PWSTR   pwszDomain;
        dwErr = AccLookupAccountName(pwszServer,
                                     pSid,
                                     ppwszCacheName,
                                     &pwszDomain,
                                     &SNE);
        if(dwErr == ERROR_SUCCESS)
        {
            AccFree(pwszDomain);
        }

        AccFree(pSid);
    }


    return(dwErr);
}




//+----------------------------------------------------------------------------
//
//  Function:   AccctrlpFreeUserCacheName
//
//  Synopsis:   Frees any memory potentially allocated by
//              AccctrlpConvertUserToCacheName
//
//  Arguments:  [pwszName]      --      Original name format
//              [pwszCacheName] --      Name returned by
//                                      AccctrlpConvertUserToCacheName
//
//  Returns:    VOID
//
//-----------------------------------------------------------------------------
VOID    AccctrlpFreeUserCacheName(PWSTR      pwszName,
                                  PWSTR      pwszCacheName)
{
    if(pwszName != pwszCacheName)
    {
        AccFree(pwszCacheName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\window.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       window.cxx
//
//  Contents:   local functions
//
//  History:    8/94    davemont    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   ReadWindowPropertyRights
//
//  Synopsis:   Gets the specified security info from the specified handle's
//              window
//
//  Arguments:  [IN  hWindow]           --      Handle to the open window to
//                                              read the info on
//              [IN  pRightsList]       --      SecurityInfo to read based
//                                              on properties
//              [IN  cRights]           --      Number of items in rights list
//              [IN  AccessList]        --      Access List to fill in
//
//  Returns:    ERROR_SUCCESS           --      Success
//              ERROR_INVALID_PARAMETER --      A bad property was encountered
//              ERROR_NOT_ENOUGH_MEMORY --      A memory allocation failed
//
//----------------------------------------------------------------------------
DWORD
ReadWindowPropertyRights(IN  HANDLE               hWindow,
                         IN  PACTRL_RIGHTS_INFO   pRightsList,
                         IN  ULONG                cRights,
                         IN  CAccessList&         AccessList)
{

    acDebugOut((DEB_TRACE, "In ReadWindowPropertyRights\n"));

    //
    // For the moment, there is only service property itself...
    //
    ASSERT(cRights == 1 && pRightsList[0].pwszProperty == NULL);
    if(cRights != 1 || pRightsList[0].pwszProperty != NULL)
    {
        return(ERROR_INVALID_PARAMETER);
    }

    UCHAR                   SDBuff[PSD_BASE_LENGTH];
    PISECURITY_DESCRIPTOR   pSD = (PISECURITY_DESCRIPTOR)SDBuff;
    DWORD                   dwErr = ERROR_SUCCESS;
    ULONG                   cSize = 0;

    //
    // Get the security descriptor
    //
    if(GetUserObjectSecurity(hWindow,
                             &(pRightsList[0].SeInfo),
                             pSD,
                             PSD_BASE_LENGTH,
                             &cSize) == FALSE)
    {
        dwErr = GetLastError();
        if(dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            pSD = (PISECURITY_DESCRIPTOR)AccAlloc(cSize);
            if(pSD == NULL)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                dwErr = ERROR_SUCCESS;

                //
                // Let's read it again
                //
                if(GetUserObjectSecurity(hWindow,
                                         &(pRightsList[0].SeInfo),
                                         pSD,
                                         cSize,
                                         &cSize) == FALSE)
                {
                    dwErr = GetLastError();
                }
            }
        }
    }


    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Add it
        //
        dwErr = AccessList.AddSD(pSD,
                                 pRightsList->SeInfo,
                                 pRightsList->pwszProperty);
    }

    //
    // Free our buffer, if necessary
    //
    if(cSize > PSD_BASE_LENGTH)
    {
        AccFree(pSD);
    }

    acDebugOut((DEB_TRACE, "Out ReadWindowPropertyRights: %lu\n", dwErr));
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\svcctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       svcctx.h
//
//  Contents:   NT Marta service context class
//
//  History:    4-1-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__SVCCTX_H__)
#define __SVCCTX_H__

#include <windows.h>
#include <service.h>
#include <assert.h>

//
// CServiceContext.  This represents a service object to the NT Marta
// infrastructure
//

class CServiceContext
{
public:

    //
    // Construction
    //

    CServiceContext ();

    ~CServiceContext ();

    DWORD InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask);

    DWORD InitializeByHandle (HANDLE Handle);

    //
    // Dispatch methods
    //

    DWORD AddRef ();

    DWORD Release ();

    DWORD GetServiceProperties (
             PMARTA_OBJECT_PROPERTIES pProperties
             );

    DWORD GetServiceRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR* ppSecurityDescriptor
             );

    DWORD SetServiceRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR pSecurityDescriptor
             );

private:

    //
    // Reference count
    //

    DWORD     m_cRefs;

    //
    // Service handles
    //

    SC_HANDLE m_hService;

    //
    // Were we initialized by name or handle?
    //

    BOOL      m_fNameInitialized;
};

//
// Private functions
//

DWORD
ServiceContextParseServiceName (
       LPCWSTR pwszName,
       LPWSTR* ppMachine,
       LPWSTR* ppService
       );

DWORD
StandardContextParseName (
        LPCWSTR pwszName,
        LPWSTR* ppMachine,
        LPWSTR* ppRest
        );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\test\ds\ds.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       DS.C
//
//  Contents:   Unit test for DS propagation, issues
//
//  History:    14-Sep-96       MacM        Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define LDAP_UNICODE 0
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <aclapi.h>
#include <seopaque.h>
#include <ntrtl.h>
#include <winldap.h>

#define FLAG_ON(flags,bit)        ((flags) & (bit))

#define DEFAULT_ACCESS  ACTRL_STD_RIGHTS_ALL | ACTRL_DIR_TRAVERSE | ACTRL_DS_OPEN |         \
        ACTRL_DS_CREATE_CHILD | ACTRL_DS_DELETE_CHILD | ACTRL_DS_LIST| ACTRL_DS_SELF |      \
        ACTRL_DS_READ_PROP | ACTRL_DS_WRITE_PROP

//
// The following is the list of OUs in the tree, relative to the root
//
PSTR    gpszTreeList[] = {"OU=subou1,", "OU=subou2,OU=subou1,", "OU=subou3,OU=subou1,",
                          "OU=subou4,OU=subou2,OU=subou1,", "OU=subou5,OU=subou2,OU=subou1,",
                          "OU=subou6,OU=subou5,OU=subou2,OU=subou1,"};
//
// The following is the list of the items in the tree to be created.  They are all printers because
// they are easy to create
//
PSTR    gpszPrintList[] = {"CN=printer1,OU=subou1,",
                           "CN=printer2,OU=subou4,OU=subou2,OU=subou1,",
                           "CN=printer3,OU=subou6,OU=subou5,OU=subou2,OU=subou1,"};

ULONG   cTree = sizeof(gpszTreeList) / sizeof(PWSTR);
ULONG   cPrint = sizeof(gpszPrintList) / sizeof(PWSTR);


//
// Flags for tests
//
#define DSTEST_READ         0x00000001
#define DSTEST_TREE         0x00000002
#define DSTEST_INTERRUPT    0x00000004
#define DSTEST_NOACCESS     0x00000008
#define DSTEST_GETACCESS    0x00000010

#define RandomIndex(Max)    (rand() % (Max))
#define RandomIndexNotRoot(Max)  (rand() % (Max - 1) + 1)





VOID
Usage (
    IN  PSTR    pszExe
    )
/*++

Routine Description:

    Displays the usage

Arguments:

    pszExe - Name of the exe

Return Value:

    VOID

--*/
{
    printf("%s machine path user [/C] [/O] [/I] [/P] [/test]\n", pszExe);
    printf("    where machine is the name of the DC to bind to\n");
    printf("          path is the root DS path to use\n");
    printf("            PATH MUST BE IN FQDN 1779 FORMAT (ou=x,o=y,c=z)!\n");
    printf("          user is the name of a user to set access for\n");
    printf("          /test indicates which test to run:\n");
    printf("                /READ (Simple read test)\n");
    printf("                /TREE (Propagation of entries through tree)\n");
    printf("                /INTERRUPT (Propagation interruptus and continuation)\n");
    printf("                /NOACCESS (Propagation across a ds subtree w/ no traverse access)\n");
    printf("                /GETACCESS (GetAccessForObject type on object and object type)\n");
    printf("            if test is not specified, all variations are run\n");
    printf("          /C is Container Inherit\n");
    printf("          /O is Object Inherit\n");
    printf("          /I is InheritOnly\n");
    printf("          /P is Inherit No Propagate\n");

    return;
}




DWORD
AddAE (
    IN  PSTR            pszUser,
    IN  ACCESS_RIGHTS   AccessRights,
    IN  INHERIT_FLAGS   Inherit,
    IN  ULONG           fAccess,
    IN  PACTRL_ACCESSA  pExistingAccess,
    OUT PACTRL_ACCESSA *ppNewAccess
    )
/*++

Routine Description:

    Initialize an access entry

Arguments:

    pszUser - User to set
    AccessRights - Access rights to set
    Inherit - Any inheritance flags
    fAccess - Allowed or denied node?
    pExistingAccess - Access Entry to add to
    ppNewAccess - Where the new access is returned

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD               dwErr = ERROR_SUCCESS;
    ACTRL_ACCESS_ENTRYA AAE;

    BuildTrusteeWithNameA(&(AAE.Trustee),
                          pszUser);
    AAE.fAccessFlags       = fAccess;
    AAE.Access             = AccessRights;
    AAE.ProvSpecificAccess = 0;
    AAE.Inheritance        = Inherit;
    AAE.lpInheritProperty  = NULL;

    dwErr = SetEntriesInAccessListA(1,
                                    &AAE,
                                    GRANT_ACCESS,
                                    NULL,
                                    pExistingAccess,
                                    ppNewAccess);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    Failed to add new access entry: %lu\n", dwErr);
    }

    return(dwErr);
}



DWORD
BindToDC (
    IN  PSTR    pszDC,
    OUT PLDAP  *ppLDAP
    )
/*++

Routine Description:

    Sets up an LDAP connection to the specified server

Arguments:

    pwszDC - DS DC to bind to
    ppLDAP - The LDAP connection information is returned here

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;

    *ppLDAP = ldap_open(pszDC, LDAP_PORT);

    if(*ppLDAP == NULL)
    {
        dwErr = ERROR_PATH_NOT_FOUND;
    }
    else
    {
        //
        // Do a bind...
        //
        dwErr = ldap_bind_s(*ppLDAP,
                            NULL,
                            NULL,
                            LDAP_AUTH_SSPI);
    }

    return(dwErr);
}



DWORD
BuildTree (
    IN  PSTR    pszDC,
    IN  PSTR    pszRoot
    )
/*++

Routine Description:

    Builds the test tree


Arguments:

    pszDC - DS DC on which to do the creation
    pwszRoot - Root directory under which to create the tree

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD       dwErr = ERROR_SUCCESS;
    ULONG       i;
    CHAR        szPath[MAX_PATH + 1];
    PLDAP       pLDAP;
    PSTR        rgszValues[2] = {NULL, NULL};
    PLDAPMod    rgMods[2];
    LDAPMod     Mod;

    dwErr = BindToDC(pszDC, &pLDAP);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("Bind to %s failed with 0x%lx\n", pszDC, dwErr);
        return(dwErr);
    }

    rgMods[0] = &Mod;
    rgMods[1] = NULL;
    rgszValues[0]     = "organizationalUnit";

    Mod.mod_op      = LDAP_MOD_ADD;
    Mod.mod_type    = "objectClass";
    Mod.mod_values  = (PCHAR *)rgszValues;

    for(i = 0; i < cTree && dwErr == ERROR_SUCCESS; i++)
    {
        sprintf(szPath,
                "%s%s",
                gpszTreeList[i],
                pszRoot);

        //
        // Now, create the object...
        //
        dwErr = ldap_add_s(pLDAP, szPath, rgMods);

        if(dwErr == LDAP_ALREADY_EXISTS)
        {
            dwErr = ERROR_SUCCESS;
        }
    }

    rgszValues[0]     = "printQueue";

    //
    // If all of that worked, we'll create the printers
    //
    for(i = 0; i < cPrint && dwErr == ERROR_SUCCESS; i++)
    {
        sprintf(szPath,
                "%s%s",
                gpszPrintList[i],
                pszRoot);
        dwErr = ldap_add_s(pLDAP, szPath, rgMods);
        if(dwErr == LDAP_ALREADY_EXISTS)
        {
            dwErr = ERROR_SUCCESS;
        }
    }

    if(dwErr != ERROR_SUCCESS)
    {
        printf("Failed to create %s: %ld\n", szPath, dwErr);
    }

    ldap_unbind(pLDAP);

    return(dwErr);
}




DWORD
DeleteTree (
    IN  PSTR    pszDC,
    IN  PSTR    pszRoot
    )
/*++

Routine Description:

    Removes the test tree

Arguments:

    pszDC - DS DC on which to do the deletion
    pwszRoot - Root directory under which the tree was created

Return Value:

    VOID

--*/
{
    ULONG   i;
    CHAR    szPath[MAX_PATH + 1];
    DWORD   dwErr = ERROR_SUCCESS;
    PLDAP   pLDAP;

    dwErr = BindToDC(pszDC, &pLDAP);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("Bind to %s failed with %ld\n", pszDC, dwErr);
        return(dwErr);
    }

    for(i = cPrint; i != 0 && dwErr == ERROR_SUCCESS; i--)
    {
        sprintf(szPath,
                "%s%s",
                gpszPrintList[i - 1],
                pszRoot);
        dwErr = ldap_delete_s(pLDAP, szPath);
    }

    for(i = cTree; i != 0 && dwErr == ERROR_SUCCESS; i--)
    {
        sprintf(szPath,
                "%s%s",
                gpszTreeList[i - 1],
                pszRoot);
        dwErr = ldap_delete_s(pLDAP, szPath);
    }

    if(dwErr != ERROR_SUCCESS)
    {
        printf("Failed to delete %s: %ld (0x%lx)\n", szPath, dwErr, dwErr);
    }

    ldap_unbind(pLDAP);

    return(dwErr);
}




DWORD
VerifyTreeSet (
    IN  PSTR            pszPath,
    IN  PSTR            pszUser,
    IN  INHERIT_FLAGS   Inherit
    )
/*++

Routine Description:

    Reads the dacl off the specified path

Arguments:

    pszPath --  Root path to verify
    pszUser --  User to verify
    Inherit -- Expected inheritance

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD                   dwErr = ERROR_SUCCESS;
    CHAR                    rgszPaths[3][MAX_PATH];
    INT                     i,j;
    PACTRL_ACCESSA          pAccess;
    PACTRL_ACCESS_ENTRYA    pAE;
    BOOL                    fInNoP = FALSE;
    BOOL                    fInherited;
    BOOL                    fInheritable;

    if(FLAG_ON(Inherit, INHERIT_NO_PROPAGATE))
    {
        fInNoP = TRUE;
    }

    //
    // Now, verify it...
    //
    if(fInNoP == TRUE)
    {
        i = rand() % 2 + 1;
    }
    else
    {
        i = RandomIndexNotRoot(cTree);
    }
    sprintf(rgszPaths[0],
            "%s%s",
            gpszTreeList[i],
            pszPath);


    if(fInNoP == TRUE)
    {
        i = 0;
    }
    else
    {
        i = RandomIndex(cPrint);
    }
    sprintf(rgszPaths[1],
            "%s%s",
            gpszPrintList[i],
            pszPath);

    //
    // Finally, if this is an inherit, no propagate, check one of the
    // leaf entries for non-compliance
    //
    if(fInNoP == TRUE)
    {
        i = rand() % 3 + 3;
        sprintf(rgszPaths[2],
                "%s%s",
                gpszTreeList[i],
                pszPath);
        Inherit &= ~(SUB_CONTAINERS_AND_OBJECTS_INHERIT);

    }

    for(i = 0; i < (fInNoP == TRUE ? 3 : 2) && dwErr == ERROR_SUCCESS; i++)
    {
        fInherited = FALSE;
        fInheritable = FALSE;

        //
        // Get the security off the node, find the entry we added, and verify
        // that the entry is correct
        //
        dwErr = GetNamedSecurityInfoExA(rgszPaths[i],
                                        SE_DS_OBJECT_ALL,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        NULL,
                                        &pAccess,
                                        NULL,
                                        NULL,
                                        NULL);
        if(dwErr != ERROR_SUCCESS)
        {
            printf("    Failed to get the security for %s: %lu\n",
                   rgszPaths[i], dwErr);
            break;
        }

        pAE = NULL;
        for(j = 0;
            j < (INT)pAccess->pPropertyAccessList[0].pAccessEntryList->cEntries;
            j++)
        {
            if(_stricmp(pszUser,
                        pAccess->pPropertyAccessList[0].pAccessEntryList->
                                       pAccessList[j].Trustee.ptstrName) == 0)
            {
                pAE = &(pAccess->pPropertyAccessList[0].pAccessEntryList->
                                                              pAccessList[j]);

                if(pAE->Inheritance == ( INHERITED_PARENT | INHERITED_ACCESS_ENTRY ) )
                {
                    fInherited = TRUE;
                }

                if(pAE->Inheritance == ( Inherit | INHERITED_PARENT | INHERITED_ACCESS_ENTRY ) )
                {
                    fInheritable = TRUE;
                }
            }
        }

        if(pAE == NULL)
        {
            if((i == 0 && FLAG_ON(Inherit,SUB_CONTAINERS_ONLY_INHERIT)) ||
               (i == 1 && FLAG_ON(Inherit,SUB_OBJECTS_ONLY_INHERIT)))
            {
                printf("    Failed to find entry for %s on path %s\n",
                       pszUser, rgszPaths[i]);
                dwErr = ERROR_INVALID_FUNCTION;
            }
        }
        else
        {
            //
            // Verify that the info is correct
            //
            if(Inherit != 0)
            {
                if(!fInherited)
                {
                    printf("    Inherited entry missing for %s!\n", rgszPaths[i]);
                    dwErr = ERROR_INVALID_FUNCTION;
                }

                if(fInNoP == TRUE)
                {
                    if(fInheritable)
                    {
                        printf("    Found unexpected inheritable entry for %s\n", rgszPaths[i]);
                    }
                }
                else
                {
                    if(!fInheritable)
                    {
                        printf("    Inheritable entry missing for %s!\n", rgszPaths[i]);
                    }
                }
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            printf("    Successfully verified %s\n", rgszPaths[i]);
        }

        LocalFree(pAccess);
    }


    return(dwErr);
}




DWORD
DoReadTest (
    IN  PSTR    pszPath,
    IN  PSTR    pszUser
    )
/*++

Routine Description:

    Does the simple read test

Arguments:

    pszPath --  Root path
    pszUser --  User to run with

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    CHAR            rgszPaths[2][MAX_PATH];
    INT             i;
    PACTRL_ACCESSA  pCurrent;
    PACTRL_ACCESSA  pNew;

    printf("Simple read/write test\n");

    sprintf(rgszPaths[0],
            "%s%s",
            gpszTreeList[RandomIndex(cTree)],
            pszPath);

    sprintf(rgszPaths[1],
            "%s%s",
            gpszPrintList[RandomIndex(cPrint)],
            pszPath);

    for(i = 0; i < 2; i++)
    {
        printf("    Processing path %s\n", rgszPaths[i]);

        dwErr = GetNamedSecurityInfoExA(rgszPaths[i], SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                        NULL, NULL, &pCurrent, NULL, NULL, NULL);
        if(dwErr != ERROR_SUCCESS)
        {
            printf("    Failed to read the DACL off %s: %lu\n", rgszPaths[i], dwErr);
        }
        else
        {
            //
            // Ok, now add the entry for our user
            //
            dwErr = AddAE(pszUser,
                          DEFAULT_ACCESS,
                          0,
                          ACTRL_ACCESS_ALLOWED,
                          pCurrent,
                          &pNew);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Set it
                //
                dwErr = SetNamedSecurityInfoExA(rgszPaths[i], SE_DS_OBJECT_ALL,
                                                DACL_SECURITY_INFORMATION, NULL, pNew, NULL,
                                                NULL, NULL, NULL);

                if(dwErr != ERROR_SUCCESS)
                {
                    printf("    Set failed: %lu\n", dwErr);
                }
                LocalFree(pNew);
            }

            //
            // If that worked, reread the new security, and see if it's correct
            //
            if(dwErr == ERROR_SUCCESS)
            {

                dwErr = GetNamedSecurityInfoExA(rgszPaths[i], SE_DS_OBJECT_ALL,
                                                DACL_SECURITY_INFORMATION, NULL, NULL,
                                                &pNew, NULL, NULL, NULL);
                if(dwErr != ERROR_SUCCESS)
                {
                    printf("    Failed to read the 2nd DACL off %s: %lu\n", rgszPaths[i], dwErr);
                }
                else
                {
                    //
                    // We should only have one property, so cheat...
                    //
                    ULONG cExpected = 1 + pCurrent->pPropertyAccessList[0].
                                                   pAccessEntryList->cEntries;
                    ULONG cGot = pNew->pPropertyAccessList[0].
                                                   pAccessEntryList->cEntries;
                    if(cExpected != cGot)
                    {
                        printf("     Expected %lu entries, got %lu\n",
                               cExpected, cGot);
                        dwErr = ERROR_INVALID_FUNCTION;
                    }

                    LocalFree(pNew);
                }

                //
                // Restore the current security
                //
                dwErr = SetNamedSecurityInfoExA(rgszPaths[i], SE_DS_OBJECT_ALL,
                                                DACL_SECURITY_INFORMATION, NULL, pCurrent, NULL,
                                                NULL, NULL, NULL);
            }

            LocalFree(pCurrent);
        }

        if(dwErr != ERROR_SUCCESS)
        {
            break;
        }
    }
    return(dwErr);
}




DWORD
DoTreeTest (
    IN  PSTR            pszPath,
    IN  PSTR            pszUser,
    IN  INHERIT_FLAGS   Inherit
    )
/*++

Routine Description:

    Does the simple tree test

Arguments:

    pszPath --  Root path
    pszUser --  User to run with
    Inherit -- Inheritance flags

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS, dwErr2;
    INT             i,j;
    PACTRL_ACCESSA  pCurrent;
    PACTRL_ACCESSA  pNew;
    CHAR            szPath[MAX_PATH + 1];

    printf("Tree propagation test\n");


    sprintf(szPath,
            "%s%s",
            gpszTreeList[0],
            pszPath);

    //
    // Set the access on the root, and then we'll read the child and look for
    // the appropratie access
    //
    dwErr = GetNamedSecurityInfoExA(szPath, SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                    NULL, NULL, &pCurrent, NULL, NULL, NULL);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    Failed to get the security for %ws: %lu\n",
               szPath, dwErr);
        return(dwErr);
    }

    //
    // Ok, add the access
    //
    dwErr = AddAE(pszUser,
                  DEFAULT_ACCESS,
                  Inherit,
                  ACTRL_ACCESS_ALLOWED,
                  pCurrent,
                  &pNew);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Set it
        //
        dwErr = SetNamedSecurityInfoExA(szPath, SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                        NULL, pNew, NULL, NULL, NULL, NULL);
        if(dwErr != ERROR_SUCCESS)
        {
            printf("Set failed: %lu\n", dwErr);
        }
        LocalFree(pNew);
    }


    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = VerifyTreeSet(pszPath,
                              pszUser,
                              Inherit);
        if(dwErr != ERROR_SUCCESS)
        {
            printf("    VerifyTreeSet failed with %lu\n", dwErr);
        }
    }

    //
    // Restore the current security
    //
    dwErr2 = SetNamedSecurityInfoExA(szPath, SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                     NULL, pCurrent, NULL, NULL, NULL, NULL);
    if(dwErr2 != ERROR_SUCCESS)
    {
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }
        printf("Failed to restore the security for %s: %lu\n",
               szPath, dwErr2);
    }
    LocalFree(pCurrent);


    return(dwErr);
}




DWORD
DoInterruptTest (
    IN  PSTR            pszPath,
    IN  PSTR            pszUser,
    IN  INHERIT_FLAGS   Inherit
    )
/*++

Routine Description:

    Does the interrupt tree/repeat tree test

Arguments:

    pszPath --  Root path
    pszUser --  User to run with
    Inherit -- Inheritance flags

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD                   dwErr = ERROR_SUCCESS, dwErr2;
    PACTRL_ACCESSA          pCurrent;
    PACTRL_ACCESSA          pNew;
    HANDLE                  hObj = NULL;
    CHAR                    szPath[MAX_PATH + 1];
    ACTRL_OVERLAPPED        Overlapped;

    printf("Tree propagation with interruption\n");

    sprintf(szPath,
            "%s%s",
            gpszTreeList[0],
            pszPath);

    //
    // Set the access on the root, and then we'll read the child and look for
    // the appropratie access
    //
    dwErr = GetNamedSecurityInfoExA(szPath, SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                    NULL, NULL, &pCurrent, NULL, NULL, NULL);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    Failed to get the security for %s: %lu\n",
               szPath, dwErr);
        return(dwErr);
    }

    //
    // Ok, add the access
    //
    dwErr = AddAE(pszUser,
                  DEFAULT_ACCESS,
                  Inherit,
                  ACTRL_ACCESS_ALLOWED,
                  pCurrent,
                  &pNew);

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Set it, interrupt it, and set it again
        //
        dwErr = SetNamedSecurityInfoExA(szPath, SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                        NULL, pNew, NULL, NULL, NULL, &Overlapped);

        //
        // Immeadiately cancel it...
        //
        if(dwErr == ERROR_SUCCESS)
        {
            WaitForSingleObject(Overlapped.hEvent,
                                100);
            dwErr = CancelOverlappedAccess(&Overlapped);
            if(dwErr != ERROR_SUCCESS)
            {
                printf("Cancel failed with %lu\n", dwErr);
            }
        }

        //
        // Now, reset it and verify it
        //
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = SetNamedSecurityInfoExA(szPath, SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                            NULL, pNew, NULL, NULL, NULL, NULL);
            if(dwErr != ERROR_SUCCESS)
            {
                printf("Set failed: %lu\n", dwErr);
            }
        }

        LocalFree(pNew);
    }


    dwErr = VerifyTreeSet(pszPath,
                          pszUser,
                          Inherit);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    VerifyTreeSet failed with %lu\n", dwErr);
    }

    //
    // Restore the current security
    //
    dwErr2 = SetNamedSecurityInfoExA(szPath, SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                    NULL, pCurrent, NULL, NULL, NULL, NULL);
    if(dwErr2 != ERROR_SUCCESS)
    {
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }
        printf("Failed to restore the security for %s: %lu\n",
               szPath, dwErr2);
    }
    LocalFree(pCurrent);

    return(dwErr);
}




DWORD
DoNoAccessTest (
    IN  PSTR            pszPath,
    IN  PSTR            pszUser,
    IN  INHERIT_FLAGS   Inherit
    )
/*++

Routine Description:

    Does the NoAccess tree test, where some child node does not have access
    to its children

Arguments:

    pwszPath --  Root path
    pwszUser --  User to run with
    Inherit -- Inheritance flags

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD                   dwErr = ERROR_SUCCESS, dwErr2;
    INT                     i,j, iChild;
    PACTRL_ACCESSA          pCurrent;
    PACTRL_ACCESSA          pCurrentChild;
    PACTRL_ACCESSA          pNew;
    PACTRL_ACCESSA          pNewChild;
    CHAR                    szPath[MAX_PATH + 1];
    CHAR                    szChildPath[MAX_PATH + 1];
    CHAR                    rgszPaths[2][MAX_PATH];
    PACTRL_ACCESS_ENTRYA    pAE;
    PSECURITY_DESCRIPTOR    pSD;

    printf("NoAccess Tree test\n");

    sprintf(szPath,
            "%s%s",
            gpszTreeList[0],
            pszPath);

    iChild = RandomIndexNotRoot(cTree);
    if(iChild == (INT)(cTree - 1))
    {
        iChild--;
    }

    //
    // Set the access on the root, and then we'll read the child and look for
    // the appropratie access
    //
    dwErr = GetNamedSecurityInfoExA(szPath, SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                    NULL, NULL, &pCurrent, NULL, NULL, NULL);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    Failed to get the security for %s: %lu\n", szPath, dwErr);
        return(dwErr);
    }
    else
    {
        sprintf(szChildPath,
                "%s%s",
                gpszTreeList[iChild],
                pszPath);

        dwErr = GetNamedSecurityInfoExA(szChildPath, SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                        NULL, NULL, &pCurrentChild, NULL, NULL, NULL);
        if(dwErr != ERROR_SUCCESS)
        {
            printf("    Failed to get the security for %s: %lu\n",
                   szChildPath, dwErr);
            LocalFree(pCurrent);
            return(dwErr);
        }

    }

    //
    // Ok, add the access to the child
    //
    dwErr = AddAE("Everyone",
                  ACTRL_DS_LIST | ACTRL_DS_OPEN,
                  0,
                  ACTRL_ACCESS_DENIED,
                  pCurrentChild,
                  &pNewChild);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Set it
        //
        dwErr = SetNamedSecurityInfoExA(szChildPath, SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                        NULL, pNewChild, NULL, NULL, NULL, NULL);
        if(dwErr != ERROR_SUCCESS)
        {
            printf("Child set failed: %lu\n", dwErr);
        }

        LocalFree(pNewChild);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AddAE(pszUser,
                      DEFAULT_ACCESS,
                      Inherit,
                      ACTRL_ACCESS_ALLOWED,
                      pCurrent,
                      &pNew);

        //
        // Set it
        //
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = SetNamedSecurityInfoExA(szPath, SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                            NULL, pNew, NULL, NULL, NULL, NULL);
            if(dwErr != ERROR_SUCCESS)
            {
                printf("Set failed with %lu as expected\n", dwErr);
                if(dwErr == ERROR_ACCESS_DENIED)
                {
                    dwErr = ERROR_SUCCESS;
                }
            }
            else
            {
                printf("Set succeeded when it should have failed!\n");
                dwErr = ERROR_INVALID_FUNCTION;
            }
        }
        LocalFree(pNew);
    }


    //
    // Restore the current child security.
    //
    dwErr2 = SetNamedSecurityInfoExA(szChildPath, SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                     NULL, pCurrentChild, NULL, NULL, NULL, NULL);

    if(dwErr2 != ERROR_SUCCESS)
    {
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }
        printf("Failed to restore the security for %s: %lu\n",
               szChildPath, dwErr2);
    }
    LocalFree(pCurrentChild);


    //
    // Restore the current security
    //
    dwErr2 = SetNamedSecurityInfoExA(szPath, SE_DS_OBJECT_ALL, DACL_SECURITY_INFORMATION,
                                     NULL, pCurrent, NULL, NULL, NULL, NULL);
    if(dwErr2 != ERROR_SUCCESS)
    {
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }
        printf("Failed to restore the security for %s: %lu\n",
               szPath, dwErr2);
    }
    LocalFree(pCurrent);


    return(dwErr);
}




DWORD
DoGetAccessTest (
    IN  PSTR            pszPath,
    IN  PSTR            pszUser,
    IN  INHERIT_FLAGS   Inherit
    )
/*++

Routine Description:

    Does the NoAccess tree test, where some child node does not have access
    to its children

Arguments:

    pwszPath --  Root path
    pwszUser --  Ignored
    Inherit -- Ignored

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD                   dwErr = ERROR_SUCCESS, dwErr2;
    CHAR                    szPath[MAX_PATH + 1];
    PACTRL_ACCESS_INFOA     pInfo;
    PACTRL_CONTROL_INFOA    pRights = NULL;
    DWORD                   cItems, Info, cRights;
    INT                     i,j;
    LPCSTR                  ppszSpecificObjectTypes[  ] = { "domainDNS",
                                                            "19195a5b-6da0-11d0-afd3-00c04fd930c9",
                                                            "user",
                                                            "bf967aba-0de6-11d0-a285-00aa003049e2" };

    printf("GetAccessForObjectType test\n");

    //
    // We'll use the root path as passed in..
    //

    dwErr = GetAccessPermissionsForObjectA(pszPath,
                                           SE_DS_OBJECT,
                                           NULL,
                                           NULL,
                                           &cItems,
                                           &pInfo,
                                           &cRights,
                                           &pRights,
                                           &Info);
    if(dwErr == ERROR_SUCCESS)
    {
       printf("\tFlags: %lu\n\tcItems: %lu\n", Info, cItems);

       for(i = 0; i < (INT)cItems; i++)
       {
           printf("\t0x%08lx\t%s\n", pInfo[i].fAccessPermission, pInfo[i].lpAccessPermissionName);
       }
       LocalFree(pInfo);

       for(i = 0; i < (INT)cRights; i++)
       {
           printf("\t%s\t%s\n", pRights[i].lpControlId, pRights[i].lpControlName);
       }
       LocalFree(pRights);

    }
    else
    {
        printf("Failed to get access permissions for %s: %lu\n", pszPath, dwErr);
    }

    //
    // Try it for specific object types
    //
    if(dwErr == ERROR_SUCCESS)
    {
        for(j = 0; j < sizeof( ppszSpecificObjectTypes ) / sizeof( PSTR ); j++ )
        {
            dwErr2 = GetAccessPermissionsForObjectA(pszPath,
                                                    SE_DS_OBJECT,
                                                    ppszSpecificObjectTypes[ j ],
                                                    NULL,
                                                    &cItems,
                                                    &pInfo,
                                                    &cRights,
                                                    &pRights,
                                                    &Info);
            if(dwErr2 == ERROR_SUCCESS)
            {
                printf("Object %s\n", ppszSpecificObjectTypes[ j ]);
                printf("\tFlags: %lu\n\tcItems: %lu\n", Info, cItems);

                for(i = 0; i < (INT)cItems; i++)
                {
                   printf("\t0x%08lx\t%s\n", pInfo[i].fAccessPermission, pInfo[i].lpAccessPermissionName);
                }

                LocalFree(pInfo);

                for(i = 0; i < (INT)cRights; i++)
                {
                    printf("\t%s\t%s\n", pRights[i].lpControlId, pRights[i].lpControlName);
                }
                LocalFree(pRights);
            }
            else
            {
                printf("Failed to get access permissions for %s: %lu\n",
                       ppszSpecificObjectTypes[ j ], dwErr2);

                if(dwErr == ERROR_SUCCESS)
                {
                    dwErr = dwErr2;
                }
            }

        }
    }




    return(dwErr);
}




__cdecl main (
    IN  INT argc,
    IN  CHAR *argv[])
/*++

Routine Description:

    The main

Arguments:

    argc --  Count of arguments
    argv --  List of arguments

Return Value:

    0     --  Success
    non-0 --  Failure

--*/
{

    DWORD           dwErr = ERROR_SUCCESS, dwErr2;
    INHERIT_FLAGS   Inherit = 0;
    ULONG           Tests = 0;
    INT             i;

    srand((ULONG)(GetTickCount() * GetCurrentThreadId()));

    if(argc < 4)
    {
        Usage(argv[0]);
        exit(1);
    }

    //
    // DC is argv[1]
    // Path is argv[2]
    // User is argv[3]
    //

    //
    // process the command line
    //
    for(i = 4; i < argc; i++)
    {
        if(_stricmp(argv[i],"/C") == 0)
        {
            Inherit |= SUB_CONTAINERS_ONLY_INHERIT;
        }
        else if(_stricmp(argv[i],"/O") == 0)
        {
            Inherit |= SUB_OBJECTS_ONLY_INHERIT;
        }
        else if(_stricmp(argv[i],"/I") == 0)
        {
            Inherit |= INHERIT_ONLY;
        }
        else if(_stricmp(argv[i],"/P") == 0)
        {
            Inherit |= INHERIT_NO_PROPAGATE;
        }
        else if(_stricmp(argv[i],"/READ") == 0)
        {
            Tests |= DSTEST_READ;
        }
        else if(_stricmp(argv[i],"/TREE") == 0)
        {
            Tests |= DSTEST_TREE;
        }
        else if(_stricmp(argv[i],"/INTERRUPT") == 0)
        {
            Tests |= DSTEST_INTERRUPT;
        }
        else if(_stricmp(argv[i],"/NOACCESS") == 0)
        {
            Tests |= DSTEST_NOACCESS;
        }
        else if(_stricmp(argv[i],"/GETACCESS") == 0)
        {
            Tests |= DSTEST_GETACCESS;
        }
        else
        {
            Usage(argv[0]);
            exit(1);
            break;
        }
    }

    if(Tests == 0)
    {
        Tests = DSTEST_READ | DSTEST_TREE | DSTEST_INTERRUPT | DSTEST_NOACCESS | DSTEST_GETACCESS;
    }

    //
    // Build the tree
    //
    if(Tests != DSTEST_GETACCESS)
    {
        dwErr = BuildTree(argv[1],argv[2]);
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, DSTEST_READ))
    {
        dwErr = DoReadTest(argv[2], argv[3]);
    }
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, DSTEST_TREE))
    {
        dwErr = DoTreeTest(argv[2], argv[3], Inherit);
    }
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, DSTEST_INTERRUPT))
    {
        dwErr = DoInterruptTest(argv[2], argv[3], Inherit);
    }
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, DSTEST_NOACCESS))
    {
        dwErr = DoNoAccessTest(argv[2], argv[3], Inherit);
    }
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, DSTEST_GETACCESS))
    {
        dwErr = DoGetAccessTest(argv[2], argv[3], Inherit);
    }


    if(Tests != DSTEST_GETACCESS)
    {
        dwErr2 = DeleteTree(argv[1], argv[2]);

        if(dwErr2 != ERROR_SUCCESS)
        {
            printf("Failed to delete the tree: %lu\n", dwErr2);
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = dwErr2;
            }
        }
    }

    printf("%s\n", dwErr == ERROR_SUCCESS ?
                                    "success" :
                                    "failed");
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\wmiguid.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       wmiguid.cpp
//
//  Contents:   Implementation of NT Marta WMI Functions
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#include <krnctx.h>
#include <wmiguid.h>

//
// Functions from wmiguid.h which dispatch unto the CKernelContext class
//

DWORD
MartaAddRefWMIGuidContext(
   IN MARTA_CONTEXT Context
   )
{
    return( ( (CKernelContext *)Context )->AddRef() );
}

DWORD
MartaCloseWMIGuidContext(
     IN MARTA_CONTEXT Context
     )
{
    return( ( (CKernelContext *)Context )->Release() );
}

DWORD
MartaGetWMIGuidProperties(
   IN MARTA_CONTEXT Context,
   IN OUT PMARTA_OBJECT_PROPERTIES pProperties
   )
{
    return( ( (CKernelContext *)Context )->GetKernelProperties( pProperties ) );
}

DWORD
MartaGetWMIGuidTypeProperties(
   IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
   )
{
    if ( pProperties->cbSize < sizeof( MARTA_OBJECT_TYPE_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

DWORD
MartaGetWMIGuidRights(
   IN  MARTA_CONTEXT Context,
   IN  SECURITY_INFORMATION   SecurityInfo,
   OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
   )
{
    return( ( (CKernelContext *)Context )->GetKernelRights(
                                               SecurityInfo,
                                               ppSecurityDescriptor
                                               ) );
}

DWORD
MartaOpenWMIGuidNamedObject(
    IN  LPCWSTR pObjectName,
    IN  ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CKernelContext* pKernelContext;

    pKernelContext = new CKernelContext;
    if ( pKernelContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pKernelContext->InitializeByWmiName( pObjectName, AccessMask );
    if ( Result != ERROR_SUCCESS )
    {
        pKernelContext->Release();
        return( Result );
    }

    *pContext = pKernelContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaOpenWMIGuidHandleObject(
    IN  HANDLE   Handle,
    IN ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CKernelContext* pKernelContext;

    pKernelContext = new CKernelContext;
    if ( pKernelContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pKernelContext->InitializeByHandle( Handle );
    if ( Result != ERROR_SUCCESS )
    {
        pKernelContext->Release();
        return( Result );
    }

    *pContext = pKernelContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaSetWMIGuidRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return( ( (CKernelContext *)Context )->SetKernelRights(
                                               SecurityInfo,
                                               pSecurityDescriptor
                                               ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\wndctx.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       wndctx.h
//
//  Contents:   NT Marta window context class
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop

#if !defined(__WNDCTX_H__)
#define __WNDCTX_H__

#include <windows.h>
#include <window.h>
#include <assert.h>

//
// CWindowContext.  This represents a window station to the NT Marta
// infrastructure
//

class CWindowContext
{
public:

    //
    // Construction
    //

    CWindowContext ();

    ~CWindowContext ();

    DWORD InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask);

    DWORD InitializeByHandle (HANDLE Handle);

    //
    // Dispatch methods
    //

    DWORD AddRef ();

    DWORD Release ();

    DWORD GetWindowProperties (
             PMARTA_OBJECT_PROPERTIES pProperties
             );

    DWORD GetWindowRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR* ppSecurityDescriptor
             );

    DWORD SetWindowRights (
             SECURITY_INFORMATION SecurityInfo,
             PSECURITY_DESCRIPTOR pSecurityDescriptor
             );

private:

    //
    // Reference count
    //

    DWORD   m_cRefs;

    //
    // Window station handle
    //

    HWINSTA m_hWindowStation;

    //
    // Were we initialized by name or handle?
    //

    BOOL    m_fNameInitialized;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\svcctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       svcctx.cpp
//
//  Contents:   Implementation of CServiceContext and NT Marta Service Functions
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <svcctx.h>
//+---------------------------------------------------------------------------
//
//  Member:     CServiceContext::CServiceContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CServiceContext::CServiceContext ()
{
    m_cRefs = 1;
    m_hService = NULL;
    m_fNameInitialized = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceContext::~CServiceContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CServiceContext::~CServiceContext ()
{
    if ( ( m_hService != NULL ) && ( m_fNameInitialized == TRUE ) )
    {
        CloseServiceHandle( m_hService );
    }

    assert( m_cRefs == 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceContext::InitializeByName, public
//
//  Synopsis:   initialize the context given the name of the service
//
//----------------------------------------------------------------------------
DWORD
CServiceContext::InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask)
{
    DWORD     Result;
    LPWSTR    pwszMachine = NULL;
    LPWSTR    pwszService = NULL;
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;

    Result = ServiceContextParseServiceName(
                    pObjectName,
                    &pwszMachine,
                    &pwszService
                    );

    if ( Result == ERROR_SUCCESS )
    {
        hSCM = OpenSCManagerW( pwszMachine, NULL, AccessMask );
        if ( hSCM == NULL )
        {
            delete pwszMachine;
            delete pwszService;
            return( GetLastError() );
        }

        if ( AccessMask & GENERIC_WRITE )
        {
            AccessMask |= ( WRITE_DAC | WRITE_OWNER );
        }

        m_hService = OpenServiceW( hSCM, pwszService, AccessMask );
        if ( m_hService != NULL )
        {
            m_fNameInitialized = TRUE;
        }
        else
        {
            Result = GetLastError();
        }

        CloseServiceHandle( hSCM );

        delete pwszMachine;
        delete pwszService;
    }

    return( Result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceContext::InitializeByHandle, public
//
//  Synopsis:   initialize the context given a service handle
//
//----------------------------------------------------------------------------
DWORD
CServiceContext::InitializeByHandle (HANDLE Handle)
{
    m_hService = (SC_HANDLE)Handle;
    assert( m_fNameInitialized == FALSE );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceContext::AddRef, public
//
//  Synopsis:   add a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CServiceContext::AddRef ()
{
    m_cRefs += 1;
    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceContext::Release, public
//
//  Synopsis:   release a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CServiceContext::Release ()
{
    m_cRefs -= 1;

    if ( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceContext::GetServiceProperties, public
//
//  Synopsis:   get properties about the context
//
//----------------------------------------------------------------------------
DWORD
CServiceContext::GetServiceProperties (
                    PMARTA_OBJECT_PROPERTIES pObjectProperties
                    )
{
    if ( pObjectProperties->cbSize < sizeof( MARTA_OBJECT_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pObjectProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceContext::GetServiceRights, public
//
//  Synopsis:   get the service security descriptor
//
//----------------------------------------------------------------------------
DWORD
CServiceContext::GetServiceRights (
                    SECURITY_INFORMATION SecurityInfo,
                    PSECURITY_DESCRIPTOR* ppSecurityDescriptor
                    )
{
    BOOL                 fResult;
    UCHAR                   SDBuff[1];
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD                cb = 0;

    assert( m_hService != NULL );

    fResult = QueryServiceObjectSecurity(
                   m_hService,
                   SecurityInfo,
                   (PSECURITY_DESCRIPTOR) SDBuff,
                   0,
                   &cb
                   );

    if ( ( fResult == FALSE ) && ( cb > 0 ) )
    {
        assert( ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) ||
                ( GetLastError() == STATUS_BUFFER_TOO_SMALL ) );

        pSecurityDescriptor = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
        if ( pSecurityDescriptor == NULL )
        {
            return( ERROR_OUTOFMEMORY );
        }

        fResult = QueryServiceObjectSecurity(
                       m_hService,
                       SecurityInfo,
                       pSecurityDescriptor,
                       cb,
                       &cb
                       );
    }
    else
    {
        assert( fResult == FALSE );

        return( GetLastError() );
    }

    if ( fResult == TRUE )
    {
        *ppSecurityDescriptor = pSecurityDescriptor;
    }
    else
    {
        LocalFree(pSecurityDescriptor);
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CServiceContext::SetServiceRights, public
//
//  Synopsis:   set the window security descriptor
//
//----------------------------------------------------------------------------
DWORD
CServiceContext::SetServiceRights (
                   SECURITY_INFORMATION SecurityInfo,
                   PSECURITY_DESCRIPTOR pSecurityDescriptor
                   )
{
    assert( m_hService != NULL );

    if ( SetServiceObjectSecurity(
            m_hService,
            SecurityInfo,
            pSecurityDescriptor
            ) == FALSE )
    {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Function:   ServiceContextParseServiceName
//
//  Synopsis:   parse the service name and machine
//
//----------------------------------------------------------------------------
DWORD
ServiceContextParseServiceName (
       LPCWSTR pwszName,
       LPWSTR* ppMachine,
       LPWSTR* ppService
       )
{
    return( StandardContextParseName( pwszName, ppMachine, ppService ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   StandardContextParseName
//
//  Synopsis:   parse the name and machine
//
//----------------------------------------------------------------------------
DWORD
StandardContextParseName (
        LPCWSTR pwszName,
        LPWSTR* ppMachine,
        LPWSTR* ppRest
        )
{
    LPWSTR pwszMachine = NULL;
    LPWSTR pwszNameLocal = NULL;
    LPWSTR pwszRest = NULL;
    DWORD  cwName = 0;
    DWORD  cw = 0;
    DWORD  rc = ERROR_SUCCESS;

    //
    // VishnuP: 392334 AV because IN parameter pwszName could be constant and is written
    // to inside here. Irrespective of whether it is a constant, this IN parameter is coming
    // from GetNamedSecurityInfo and should not be mangled.
    // So, create a local copy of the IN parameter and mangle it if needeed.
    //

    cwName = wcslen( pwszName );

    pwszNameLocal = new WCHAR [ cwName + 1 ];

    if ( pwszNameLocal == NULL )
    {
        rc = ERROR_OUTOFMEMORY ;
        goto CleanUp;
    }

    wcscpy( pwszNameLocal, pwszName);
    
    if ( cwName  > 2 )
    {
        if ( ( pwszNameLocal[0] == L'\\' ) && ( pwszNameLocal[1] == L'\\' ) )
        {
            LPWSTR pwsz, tmp;

            pwsz = (LPWSTR)&pwszNameLocal[2];
            while ( ( *pwsz != L'\0' ) && ( *pwsz != L'\\' ) )
            {
                pwsz++;
                cw++;
            }

            if ( *pwsz == L'\0' )
            {
                rc = ERROR_INVALID_PARAMETER ;
                goto CleanUp;
            }

            *pwsz = L'\0';
            tmp = pwsz;
            pwsz++;

            pwszMachine = new WCHAR [ cw + 1 ];
            if ( pwszMachine == NULL )
            {
                rc = ERROR_OUTOFMEMORY ;
                goto CleanUp;
            }

            cw = wcslen( pwsz );
            if ( cw == 0 )
            {
                delete pwszMachine;
                rc = ERROR_INVALID_PARAMETER ;
                goto CleanUp;
            }

            pwszRest = new WCHAR [ cw + 1 ];
            if ( pwszRest == NULL )
            {
                delete pwszMachine;
                rc = ERROR_OUTOFMEMORY ;
                goto CleanUp;
            }

            wcscpy( pwszMachine, &pwszNameLocal[2] );
            wcscpy( pwszRest, pwsz );
            *tmp = L'\\';
        }
    }
    else if ( ( pwszNameLocal[0] == L'\\' ) || ( pwszNameLocal[1] == L'\\' ) )
    {
        rc = ERROR_INVALID_PARAMETER ;
        goto CleanUp;
    }

    if ( pwszRest == NULL )
    {
        assert( pwszMachine == NULL );

        pwszRest = new WCHAR [ cwName + 1 ];
        if ( pwszRest == NULL )
        {
            rc = ERROR_OUTOFMEMORY ;
            goto CleanUp;
        }

        wcscpy( pwszRest, pwszNameLocal );
    }

    *ppMachine = pwszMachine;
    *ppRest = pwszRest;

CleanUp:

    if (pwszNameLocal) 
        delete pwszNameLocal;
    return( rc );
}

//
// Functions from service.h which dispatch unto the CServiceContext class
//

DWORD
MartaAddRefServiceContext(
   IN MARTA_CONTEXT Context
   )
{
    return( ( (CServiceContext *)Context )->AddRef() );
}

DWORD
MartaCloseServiceContext(
     IN MARTA_CONTEXT Context
     )
{
    return( ( (CServiceContext *)Context )->Release() );
}

DWORD
MartaGetServiceProperties(
   IN MARTA_CONTEXT Context,
   IN OUT PMARTA_OBJECT_PROPERTIES pProperties
   )
{
    return( ( (CServiceContext *)Context )->GetServiceProperties( pProperties ) );
}

DWORD
MartaGetServiceTypeProperties(
   IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
   )
{
    if ( pProperties->cbSize < sizeof( MARTA_OBJECT_TYPE_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

DWORD
MartaGetServiceRights(
   IN  MARTA_CONTEXT Context,
   IN  SECURITY_INFORMATION   SecurityInfo,
   OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
   )
{
    return( ( (CServiceContext *)Context )->GetServiceRights(
                                               SecurityInfo,
                                               ppSecurityDescriptor
                                               ) );
}

DWORD
MartaOpenServiceNamedObject(
    IN  LPCWSTR pObjectName,
    IN  ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CServiceContext* pServiceContext;

    pServiceContext = new CServiceContext;
    if ( pServiceContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pServiceContext->InitializeByName( pObjectName, AccessMask );
    if ( Result != ERROR_SUCCESS )
    {
        pServiceContext->Release();
        return( Result );
    }

    *pContext = pServiceContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaOpenServiceHandleObject(
    IN  HANDLE   Handle,
    IN ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CServiceContext* pServiceContext;

    pServiceContext = new CServiceContext;
    if ( pServiceContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pServiceContext->InitializeByHandle( Handle );
    if ( Result != ERROR_SUCCESS )
    {
        pServiceContext->Release();
        return( Result );
    }

    *pContext = pServiceContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaSetServiceRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return( ( (CServiceContext *)Context )->SetServiceRights(
                                               SecurityInfo,
                                               pSecurityDescriptor
                                               ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\newsrc\wndctx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       wndctx.cpp
//
//  Contents:   Implementation of CWindowContext and NT Marta Window Functions
//
//  History:    3-31-1999    kirtd    Created
//
//----------------------------------------------------------------------------
#include <aclpch.hxx>
#pragma hdrstop
#include <wndctx.h>
//+---------------------------------------------------------------------------
//
//  Member:     CWindowContext::CWindowContext, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CWindowContext::CWindowContext ()
{
    m_cRefs = 1;
    m_hWindowStation = NULL;
    m_fNameInitialized = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWindowContext::~CWindowContext, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CWindowContext::~CWindowContext ()
{
    if ( ( m_hWindowStation != NULL ) && ( m_fNameInitialized == TRUE ) )
    {
        CloseWindowStation( m_hWindowStation );
    }

    assert( m_cRefs == 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWindowContext::InitializeByName, public
//
//  Synopsis:   initialize the context given the name of the window station
//
//----------------------------------------------------------------------------
DWORD
CWindowContext::InitializeByName (LPCWSTR pObjectName, ACCESS_MASK AccessMask)
{
    DWORD dwDesiredAccess = 0;

    if ( AccessMask & GENERIC_READ )
    {
        dwDesiredAccess |= WINSTA_READATTRIBUTES;
    }

    if ( AccessMask & GENERIC_WRITE )
    {
        dwDesiredAccess |= WINSTA_WRITEATTRIBUTES;
    }

    m_hWindowStation = OpenWindowStationW(
                           pObjectName,
                           FALSE,
                           dwDesiredAccess
                           );

    if ( m_hWindowStation == NULL )
    {
        return( GetLastError() );
    }

    m_fNameInitialized = TRUE;

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWindowContext::InitializeByHandle, public
//
//  Synopsis:   initialize the context given a window station handle
//
//----------------------------------------------------------------------------
DWORD
CWindowContext::InitializeByHandle (HANDLE Handle)
{
    m_hWindowStation = (HWINSTA)Handle;
    assert( m_fNameInitialized == FALSE );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWindowContext::AddRef, public
//
//  Synopsis:   add a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CWindowContext::AddRef ()
{
    m_cRefs += 1;
    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWindowContext::Release, public
//
//  Synopsis:   release a reference to the context
//
//----------------------------------------------------------------------------
DWORD
CWindowContext::Release ()
{
    m_cRefs -= 1;

    if ( m_cRefs == 0 )
    {
        delete this;
        return( 0 );
    }

    return( m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWindowContext::GetWindowProperties, public
//
//  Synopsis:   get properties about the context
//
//----------------------------------------------------------------------------
DWORD
CWindowContext::GetWindowProperties (
                   PMARTA_OBJECT_PROPERTIES pObjectProperties
                   )
{
    if ( pObjectProperties->cbSize < sizeof( MARTA_OBJECT_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pObjectProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWindowContext::GetWindowRights, public
//
//  Synopsis:   get the window security descriptor
//
//----------------------------------------------------------------------------
DWORD
CWindowContext::GetWindowRights (
                   SECURITY_INFORMATION SecurityInfo,
                   PSECURITY_DESCRIPTOR* ppSecurityDescriptor
                   )
{
    BOOL                 fResult;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD                cb = 0;

    assert( m_hWindowStation != NULL );

    fResult = GetUserObjectSecurity(
                 m_hWindowStation,
                 &SecurityInfo,
                 pSecurityDescriptor,
                 0,
                 &cb
                 );

    if ( ( fResult == FALSE ) && ( cb > 0 ) )
    {
        assert( ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) ||
                ( GetLastError() == STATUS_BUFFER_TOO_SMALL ) );

        pSecurityDescriptor = (PSECURITY_DESCRIPTOR)LocalAlloc( LPTR, cb );
        if ( pSecurityDescriptor == NULL )
        {
            return( ERROR_OUTOFMEMORY );
        }

        fResult = GetUserObjectSecurity(
                     m_hWindowStation,
                     &SecurityInfo,
                     pSecurityDescriptor,
                     cb,
                     &cb
                     );
    }
    else
    {
        assert( fResult == FALSE );

        return( GetLastError() );
    }

    if ( fResult == TRUE )
    {
        *ppSecurityDescriptor = pSecurityDescriptor;
    }
    else
    {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWindowContext::SetWindowRights, public
//
//  Synopsis:   set the window security descriptor
//
//----------------------------------------------------------------------------
DWORD
CWindowContext::SetWindowRights (
                   SECURITY_INFORMATION SecurityInfo,
                   PSECURITY_DESCRIPTOR pSecurityDescriptor
                   )
{
    assert( m_hWindowStation != NULL );

    if ( SetUserObjectSecurity(
            m_hWindowStation,
            &SecurityInfo,
            pSecurityDescriptor
            ) == FALSE )
    {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}

//
// Functions from window.h which dispatch unto the CWindowContext class
//

DWORD
MartaAddRefWindowContext(
    IN MARTA_CONTEXT Context
    )
{
    return( ( (CWindowContext *)Context )->AddRef() );
}

DWORD
MartaCloseWindowContext(
    IN MARTA_CONTEXT Context
    )
{
    return( ( (CWindowContext *)Context )->Release() );
}

DWORD
MartaGetWindowProperties(
    IN MARTA_CONTEXT Context,
    IN OUT PMARTA_OBJECT_PROPERTIES pProperties
    )
{
    return( ( (CWindowContext *)Context )->GetWindowProperties( pProperties ) );
}

DWORD
MartaGetWindowTypeProperties(
    IN OUT PMARTA_OBJECT_TYPE_PROPERTIES pProperties
    )
{
    if ( pProperties->cbSize < sizeof( MARTA_OBJECT_TYPE_PROPERTIES ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    assert( pProperties->dwFlags == 0 );

    return( ERROR_SUCCESS );
}

DWORD
MartaGetWindowRights(
    IN  MARTA_CONTEXT Context,
    IN  SECURITY_INFORMATION   SecurityInfo,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
{
    return( ( (CWindowContext *)Context )->GetWindowRights(
                                              SecurityInfo,
                                              ppSecurityDescriptor
                                              ) );
}

DWORD
MartaOpenWindowNamedObject(
    IN  LPCWSTR pObjectName,
    IN  ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CWindowContext* pWindowContext;

    pWindowContext = new CWindowContext;
    if ( pWindowContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pWindowContext->InitializeByName( pObjectName, AccessMask );
    if ( Result != ERROR_SUCCESS )
    {
        pWindowContext->Release();
        return( Result );
    }

    *pContext = pWindowContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaOpenWindowHandleObject(
    IN  HANDLE   Handle,
    IN ACCESS_MASK AccessMask,
    OUT PMARTA_CONTEXT pContext
    )
{
    DWORD           Result;
    CWindowContext* pWindowContext;

    pWindowContext = new CWindowContext;
    if ( pWindowContext == NULL )
    {
        return( ERROR_OUTOFMEMORY );
    }

    Result = pWindowContext->InitializeByHandle( Handle );
    if ( Result != ERROR_SUCCESS )
    {
        pWindowContext->Release();
        return( Result );
    }

    *pContext = pWindowContext;
    return( ERROR_SUCCESS );
}

DWORD
MartaSetWindowRights(
    IN MARTA_CONTEXT              Context,
    IN SECURITY_INFORMATION SecurityInfo,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
{
    return( ( (CWindowContext *)Context )->SetWindowRights(
                                              SecurityInfo,
                                              pSecurityDescriptor
                                              ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\test\file\file.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       FILE.C
//
//  Contents:   Unit test for file propagation, issues
//
//  History:    14-Sep-96       MacM        Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <aclapi.h>
#include <seopaque.h>
#include <ntrtl.h>

#define FLAG_ON(flags,bit)        ((flags) & (bit))

#define DEFAULT_ACCESS  ACTRL_STD_RIGHTS_ALL | ACTRL_DIR_TRAVERSE | ACTRL_DIR_LIST

//
// The following is the list of the directory tree to possibly be created
//
PWSTR   gpwszTreeList[] = {L"\\dir1", L"\\dir1\\dir2",L"\\dir1\\dir3",
                           L"\\dir1\\dir2\\dir4", L"\\dir1\\dir3\\dir5",
                           L"\\dir1\\dir3\\dir6", L"\\dir1\\dir2\\dir4\\dir7",
                           L"\\dir1\\dir2\\dir4\\dir7\\dir8",
                           L"\\dir1\\dir2\\dir4\\dir7\\dir9"};
PWSTR   gpwszFileList[] = {L"\\dir1\\file1", L"\\dir1\\dir3\\dir6\\file2",
                           L"\\dir1\\dir2\\dir4\\dir7\\dir9\\file3"};

ULONG   cTree = sizeof(gpwszTreeList) / sizeof(PWSTR);
ULONG   cFile = sizeof(gpwszFileList) / sizeof(PWSTR);


//
// Flags for tests
//
#define FTEST_READ      0x00000001
#define FTEST_TREE      0x00000002
#define FTEST_INTERRUPT 0x00000004
#define FTEST_COMPRESS  0x00000008
#define FTEST_NOACCESS  0x00000010
#define FTEST_OPENDIR   0x00000020
#define FTEST_COMPRESS2 0x00000040
#define FTEST_PROTECT   0x00000080
#define FTEST_GET3      0x00000100
#define FTEST_GETOWNER  0x00000200

#define RandomIndex(Max)    (rand() % (Max))
#define RandomIndexNotRoot(Max)  (rand() % (Max - 1) + 1)
#define HANDLE_CLOSE(h) if((h) != NULL) { CloseHandle(h); (h) = NULL;}

DWORD
AddAE (
    IN  PWSTR           pwszUser,
    IN  ACCESS_RIGHTS   AccessRights,
    IN  INHERIT_FLAGS   Inherit,
    IN  ULONG           fAccess,
    IN  PACTRL_ACCESS   pExistingAccess,
    OUT PACTRL_ACCESS  *ppNewAccess
    )
/*++

Routine Description:

    Initialize an access entry

Arguments:

    pwszUser - User to set
    AccessRights - Access rights to set
    Inherit - Any inheritance flags
    fAccess - Allowed or denied node?
    pExistingAccess - Access Entry to add to
    ppNewAccess - Where the new access is returned

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD               dwErr = ERROR_SUCCESS;
    ACTRL_ACCESS_ENTRY  AAE;

    BuildTrusteeWithNameW(&(AAE.Trustee),
                          pwszUser);
    AAE.fAccessFlags       = fAccess;
    AAE.Access             = AccessRights;
    AAE.ProvSpecificAccess = 0;
    AAE.Inheritance        = Inherit;
    AAE.lpInheritProperty  = NULL;

    dwErr = SetEntriesInAccessListW(1,
                                   &AAE,
                                   GRANT_ACCESS,
                                   NULL,
                                   pExistingAccess,
                                   ppNewAccess);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    FAILED to add new access entry: %lu\n", dwErr);
    }

    return(dwErr);
}



DWORD
BuildTree (
    IN  PWSTR   pwszRoot
    )
/*++

Routine Description:

    Builds the test tree


Arguments:

    pwszRoot - Root directory under which to create the tree

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;
    ULONG   i;
    WCHAR   wszPath[MAX_PATH + 1];
    HANDLE  hFile;

    for(i = 0; i < cTree; i++)
    {
        swprintf(wszPath,
                 L"%ws%ws",
                 pwszRoot,
                 gpwszTreeList[i]);
        //
        // Now, create the directory...
        //
        if(CreateDirectory(wszPath, NULL) == FALSE)
        {
            dwErr = GetLastError();
            break;
        }
    }

    //
    // If all of that worked, we'll create the files
    //
    for(i = 0; i < cFile && dwErr == ERROR_SUCCESS; i++)
    {
        swprintf(wszPath,
                 L"%ws%ws",
                 pwszRoot,
                 gpwszFileList[i]);
        hFile = CreateFile(wszPath,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
        if(hFile == INVALID_HANDLE_VALUE)
        {
            dwErr = GetLastError();
        }
        else
        {
            CloseHandle(hFile);
        }
    }

    if(dwErr != ERROR_SUCCESS)
    {
        printf("FAILED to create %ws: %lu\n",
               wszPath,
               dwErr);
    }
    return(dwErr);
}




DWORD
DeleteTree (
    IN  PWSTR   pwszRoot
    )
/*++

Routine Description:

    Removes the test tree


Arguments:

    pwszRoot - Root directory under which the tree was created

Return Value:

    VOID

--*/
{
    ULONG   i;
    WCHAR   wszPath[MAX_PATH + 1];
    DWORD   dwErr = ERROR_SUCCESS;

    for(i = cFile; i != 0 && dwErr == ERROR_SUCCESS; i--)
    {
        swprintf(wszPath,
                 L"%ws%ws",
                 pwszRoot,
                 gpwszFileList[i - 1]);
        if(DeleteFile(wszPath) == FALSE)
        {
            dwErr = GetLastError();
            printf("FAILED to delete %ws: 0x%lx\n",
                   wszPath,
                   dwErr);
            break;
        }
    }

    for(i = cTree; i != 0 && dwErr == ERROR_SUCCESS; i--)
    {
        swprintf(wszPath,
                 L"%ws%ws",
                 pwszRoot,
                 gpwszTreeList[i - 1]);
        if(RemoveDirectory(wszPath) == FALSE)
        {
            dwErr = GetLastError();
            if(dwErr == ERROR_PATH_NOT_FOUND || dwErr == ERROR_FILE_NOT_FOUND)
            {
                dwErr = ERROR_SUCCESS;
            }
            else
            {
                printf("FAILED to remove %ws: 0x%lx\n",
                       wszPath,
                       GetLastError());
            }
        }
    }

    return(dwErr);
}




VOID
Usage (
    IN  PSTR    pszExe
    )
/*++

Routine Description:

    Displays the usage

Arguments:

    pszExe - Name of the exe

Return Value:

    VOID

--*/
{
    printf("%s path user [/C] [/O] [/I] [/P] [/test] [/H]\n", pszExe);
    printf("    where path is the root path to use\n");
    printf("          user is the name of a user to set access for\n");
    printf("          /test indicates which test to run:\n");
    printf("                /READ (Simple read/write)\n");
    printf("                /TREE (Propagation of entries through tree)\n");
    printf("                /INTERRUPT (Propagation interruptus and continuation)\n");
    printf("                /COMPRESS (Compression of access entries)\n");
    printf("                /NOACCESS (Propagation across a directory w/ no traverse access)\n");
    printf("                /OPENDIR (Propagation with the directory already open\n");
    printf("                /COMPRESS2 (Compression of big list of access entries)\n");
    printf("                /PROTECT (Protected child acls)\n");
    printf("                /GET3 (Get Dacl/Owner/Group)\n");
    printf("                /GETOWNER (Get Owner test)\n");
    printf("            if test is not specified, all variations are run\n");
    printf("          /H indicates to use the handle version of the APIs\n");
    printf("          /C is Container Inherit\n");
    printf("          /O is Object Inherit\n");
    printf("          /I is InheritOnly\n");
    printf("          /P is Inherit No Propagate\n");

    return;
}


//
// Conceptually, this is a companion function for GetSecurityForPath
//
#define SetSecurityForPath(path,usehandle,handle,access)            \
(usehandle == TRUE ?                                                \
    SetSecurityInfoExW(handle,                                      \
                       SE_FILE_OBJECT,                              \
                       DACL_SECURITY_INFORMATION,                   \
                       NULL,                                        \
                       access,                                      \
                       NULL,                                        \
                       NULL,                                        \
                       NULL,                                        \
                       NULL)        :                               \
    SetNamedSecurityInfoExW(path,                                   \
                            SE_FILE_OBJECT,                         \
                            DACL_SECURITY_INFORMATION,              \
                            NULL,                                   \
                            access,                                 \
                            NULL,                                   \
                            NULL,                                   \
                            NULL,                                   \
                            NULL))


DWORD
GetSecurityForPath (
    IN  PWSTR           pwszPath,
    IN  BOOL            fUseHandle,
    IN  ULONG           OpenFlags,
    OUT HANDLE         *phObj,
    OUT PACTRL_ACCESSW *ppAccess
    )
/*++

Routine Description:

    Reads the dacl off the specified path

Arguments:

    pwszPath --  Path to read
    fUseHandle -- Use handle or path based API
    OpenFlags -- Flags to use if opening the object
    phObj -- Handle to object
    ppAccess -- Where the access is returned

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;

    if(fUseHandle == TRUE)
    {
        //
        // Open the object
        //
        if(*phObj == NULL)
        {
            *phObj = CreateFile(pwszPath,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                OpenFlags | READ_CONTROL | WRITE_DAC,
                                NULL);
            if(*phObj == INVALID_HANDLE_VALUE)
            {
                dwErr = GetLastError();
                *phObj = NULL;
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = GetSecurityInfoExW(*phObj,
                                       SE_FILE_OBJECT,
                                       DACL_SECURITY_INFORMATION,
                                       NULL,
                                       NULL,
                                       ppAccess,
                                       NULL,
                                       NULL,
                                       NULL);
            if(dwErr != ERROR_SUCCESS)
            {
                HANDLE_CLOSE(*phObj);
            }

        }

    }
    else
    {
        dwErr = GetNamedSecurityInfoExW(pwszPath,
                                        SE_FILE_OBJECT,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        NULL,
                                        ppAccess,
                                        NULL,
                                        NULL,
                                        NULL);
        if(phObj != NULL)
        {
            *phObj = NULL;
        }
    }

    return(dwErr);
}




DWORD
VerifyTreeSet (
    IN  PWSTR           pwszPath,
    IN  PWSTR           pwszUser,
    IN  INHERIT_FLAGS   Inherit
    )
/*++

Routine Description:

    Reads the dacl off the specified path

Arguments:

    pwszPath --  Root path to verify
    pwszUser --  User to verify
    Inherit -- Expected inheritance

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD                   dwErr = ERROR_SUCCESS;
    WCHAR                   rgwszPaths[3][MAX_PATH];
    INT                     i,j;
    PACTRL_ACCESSW          pAccess;
    PACTRL_ACCESS_ENTRYW    pAE;
    BOOL                    fInNoP = FALSE;

    if(FLAG_ON(Inherit, INHERIT_NO_PROPAGATE))
    {
        fInNoP = TRUE;
    }

    //
    // Now, verify it...
    //
    if(fInNoP == TRUE)
    {
        i = rand() % 2 + 1;
    }
    else
    {
        i = RandomIndexNotRoot(cTree);
    }
    swprintf(rgwszPaths[0],
             L"%ws%ws",
             pwszPath,
             gpwszTreeList[i]);


    if(fInNoP == TRUE)
    {
        i = 0;
    }
    else
    {
        i = RandomIndex(cFile);
    }
    swprintf(rgwszPaths[1],
             L"%ws%ws",
             pwszPath,
             gpwszFileList[i]);

    //
    // Finally, if this is an inherit, no propagate, check one of the
    // leaf entries for non-compliance
    //
    if(fInNoP == TRUE)
    {
        i = rand() % 6 + 3;
        swprintf(rgwszPaths[2],
                 L"%ws%ws",
                 pwszPath,
                 gpwszTreeList[i]);
        Inherit &= ~(SUB_CONTAINERS_AND_OBJECTS_INHERIT);

    }

    for(i = 0; i < (fInNoP == TRUE ? 3 : 2) && dwErr == ERROR_SUCCESS; i++)
    {
        //
        // Get the security off the node, find the entry we added, and verify
        // that the entry is correct
        //
        dwErr = GetSecurityForPath(rgwszPaths[i],
                                   FALSE,
                                   FILE_FLAG_BACKUP_SEMANTICS,
                                   NULL,
                                   &pAccess);
        if(dwErr != ERROR_SUCCESS)
        {
            printf("    FAILED to get the security for %ws: %lu\n",
                   rgwszPaths[i], dwErr);
            break;
        }

        pAE = NULL;
        for(j = 0;
            j < (INT)pAccess->pPropertyAccessList[0].pAccessEntryList->cEntries;
            j++)
        {
            if(_wcsicmp(pwszUser,
                        pAccess->pPropertyAccessList[0].pAccessEntryList->
                                       pAccessList[j].Trustee.ptstrName) == 0)
            {
                pAE = &(pAccess->pPropertyAccessList[0].pAccessEntryList->
                                                              pAccessList[j]);
                break;
            }
        }

        if(pAE == NULL)
        {
            if((i == 0 && FLAG_ON(Inherit,SUB_CONTAINERS_ONLY_INHERIT)) ||
               (i == 1 && FLAG_ON(Inherit,SUB_OBJECTS_ONLY_INHERIT)))
            {
                printf("    FAILED to find entry for %ws on path %ws\n",
                       pwszUser, rgwszPaths[i]);
                dwErr = ERROR_INVALID_FUNCTION;
            }
        }
        else
        {
            //
            // Verify that the info is correct
            //
            if(!FLAG_ON(pAE->Inheritance, INHERITED_ACCESS_ENTRY))
            {
                printf("    Access entry on %ws is not inherited!\n",
                       rgwszPaths[i]);
                dwErr = ERROR_INVALID_FUNCTION;
            }

            if(i == 0)
            {
                if(FLAG_ON(Inherit, SUB_CONTAINERS_ONLY_INHERIT) &&
                      !FLAG_ON(pAE->Inheritance, SUB_CONTAINERS_ONLY_INHERIT))
                {
                    printf("    No container inherit on %ws!\n",
                           rgwszPaths[i]);
                    dwErr = ERROR_INVALID_FUNCTION;
                }
            }
            else if(i == 1)
            {
                if(FLAG_ON(Inherit, SUB_OBJECTS_ONLY_INHERIT) &&
                      FLAG_ON(pAE->Inheritance, SUB_OBJECTS_ONLY_INHERIT))
                {
                    printf("    Object inherit bit on object on %ws!\n",
                           rgwszPaths[i]);
                    dwErr = ERROR_INVALID_FUNCTION;
                }
            }
            else
            {
                printf("    Inherit No Propagate node found on child %ws\n",
                       rgwszPaths[i]);
                dwErr = ERROR_INVALID_FUNCTION;
            }

        }

        if(dwErr == ERROR_SUCCESS)
        {
            printf("    Successfully verified %ws\n", rgwszPaths[i]);
        }

        LocalFree(pAccess);
    }


    return(dwErr);
}




DWORD
DoReadTest (
    IN  PWSTR   pwszPath,
    IN  PWSTR   pwszUser,
    IN  BOOL    fDoHandle
    )
/*++

Routine Description:

    Does the simple read test

Arguments:

    pwszPath --  Root path
    pwszUser --  User to run with
    fDoHandle -- If true, use the handle based APIs

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    WCHAR           rgwszPaths[2][MAX_PATH];
    INT             i;
    PACTRL_ACCESS   pCurrent;
    PACTRL_ACCESS   pNew;
    HANDLE          hObj;
    ULONG           OpenFlags[] = {FILE_FLAG_BACKUP_SEMANTICS, 0};

    printf("Simple read/write test\n");

    swprintf(rgwszPaths[0],
             L"%ws%ws",
             pwszPath,
             gpwszTreeList[RandomIndex(cTree)]);

    swprintf(rgwszPaths[1],
             L"%ws%ws",
             pwszPath,
             gpwszFileList[RandomIndex(cFile)]);

    for(i = 0; i < 2; i++)
    {
        printf("    Processing path %ws\n", rgwszPaths[i]);
        hObj = NULL;


        dwErr = GetSecurityForPath(rgwszPaths[i],
                                   fDoHandle,
                                   OpenFlags[i],
                                   &hObj,
                                   &pCurrent);
        if(dwErr != ERROR_SUCCESS)
        {
            printf("    FAILED to read the DACL off %ws: %lu\n",
                   rgwszPaths[i], dwErr);
        }
        else
        {
            //
            // Ok, now add the entry for our user
            //
            dwErr = AddAE(pwszUser,
                          DEFAULT_ACCESS,
                          0,
                          ACTRL_ACCESS_ALLOWED,
                          pCurrent,
                          &pNew);
            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Set it
                //
                dwErr = SetSecurityForPath(rgwszPaths[i],
                                           fDoHandle,
                                           hObj,pNew);

                if(dwErr != ERROR_SUCCESS)
                {
                    printf("    Set FAILED: %lu\n", dwErr);
                }
                LocalFree(pNew);
            }

            //
            // If that worked, reread the new security, and see if it's correct
            //
            if(dwErr == ERROR_SUCCESS)
            {
                HANDLE_CLOSE(hObj);

                dwErr = GetSecurityForPath(rgwszPaths[i],
                                           fDoHandle,
                                           OpenFlags[i],
                                           &hObj,
                                           &pNew);
                if(dwErr != ERROR_SUCCESS)
                {
                    printf("    FAILED to read the 2nd DACL off %ws: %lu\n",
                           rgwszPaths[i], dwErr);
                }
                else
                {
                    //
                    // We should only have one property, so cheat...
                    //
                    ULONG cExpected = 1 + pCurrent->pPropertyAccessList[0].
                                                   pAccessEntryList->cEntries;
                    ULONG cGot = pNew->pPropertyAccessList[0].
                                                   pAccessEntryList->cEntries;
                    if(cExpected != cGot)
                    {
                        printf("     Expected %lu entries, got %lu\n",
                               cExpected, cGot);
                        dwErr = ERROR_INVALID_FUNCTION;
                    }

                    LocalFree(pNew);
                }

                //
                // Restore the current security
                //
                SetNamedSecurityInfoExW(rgwszPaths[i],
                                        SE_FILE_OBJECT,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        pCurrent,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);
            }

            LocalFree(pCurrent);
        }

        HANDLE_CLOSE(hObj);

        if(dwErr != ERROR_SUCCESS)
        {
            break;
        }
    }
    return(dwErr);
}




DWORD
DoTreeTest (
    IN  PWSTR           pwszPath,
    IN  PWSTR           pwszUser,
    IN  INHERIT_FLAGS   Inherit,
    IN  BOOL            fDoHandle
    )
/*++

Routine Description:

    Does the simple tree test

Arguments:

    pwszPath --  Root path
    pwszUser --  User to run with
    Inherit -- Inheritance flags
    fDoHandle -- If true, use the handle based APIs

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS, dwErr2;
    INT             i,j;
    PACTRL_ACCESS   pCurrent;
    PACTRL_ACCESS   pNew;
    HANDLE          hObj = NULL;
    WCHAR           wszPath[MAX_PATH + 1];
    WCHAR           rgwszPaths[2][MAX_PATH];
    PACTRL_ACCESS_ENTRYW    pAE;

    printf("Tree propagation test\n");

    swprintf(wszPath,
             L"%ws%ws",
             pwszPath,
             gpwszTreeList[0]);

    //
    // Set the access on the root, and then we'll read the child and look for
    // the appropratie access
    //
    dwErr = GetSecurityForPath(wszPath,
                               fDoHandle,
                               FILE_FLAG_BACKUP_SEMANTICS,
                               &hObj,
                               &pCurrent);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    FAILED to get the security for %ws: %lu\n",
               wszPath, dwErr);
        return(dwErr);
    }

    //
    // Ok, add the access
    //
    dwErr = AddAE(pwszUser,
                  DEFAULT_ACCESS,
                  Inherit,
                  ACTRL_ACCESS_ALLOWED,
                  pCurrent,
                  &pNew);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Set it
        //
        dwErr = SetSecurityForPath(wszPath,fDoHandle,hObj,pNew);

        if(dwErr != ERROR_SUCCESS)
        {
            printf("Set FAILED: %lu\n", dwErr);
        }
        LocalFree(pNew);
    }


    dwErr = VerifyTreeSet(pwszPath,
                          pwszUser,
                          Inherit);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    VerifyTreeSet FAILED with %lu\n", dwErr);
    }

    //
    // Restore the current security
    //
    dwErr2 = SetNamedSecurityInfoExW(wszPath,
                                     SE_FILE_OBJECT,
                                     DACL_SECURITY_INFORMATION,
                                     NULL,
                                     pCurrent,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);
    if(dwErr2 != ERROR_SUCCESS)
    {
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }
        printf("FAILED to restore the security for %ws: %lu\n",
               wszPath, dwErr2);
    }
    LocalFree(pCurrent);

    HANDLE_CLOSE(hObj);

    return(dwErr);
}




DWORD
DoInterruptTest (
    IN  PWSTR           pwszPath,
    IN  PWSTR           pwszUser,
    IN  INHERIT_FLAGS   Inherit,
    IN  BOOL            fDoHandle
    )
/*++

Routine Description:

    Does the interrupt tree/repeat tree test

Arguments:

    pwszPath --  Root path
    pwszUser --  User to run with
    Inherit -- Inheritance flags
    fDoHandle -- If true, use the handle based APIs

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD                   dwErr = ERROR_SUCCESS, dwErr2;
    PACTRL_ACCESS           pCurrent;
    PACTRL_ACCESS           pNew;
    HANDLE                  hObj = NULL;
    WCHAR                   wszPath[MAX_PATH + 1];
    ACTRL_OVERLAPPED        Overlapped;

    printf("Tree propagation with interruption\n");

    swprintf(wszPath,
             L"%ws%ws",
             pwszPath,
             gpwszTreeList[0]);

    //
    // Set the access on the root, and then we'll read the child and look for
    // the appropratie access
    //
    dwErr = GetSecurityForPath(wszPath,
                               fDoHandle,
                               FILE_FLAG_BACKUP_SEMANTICS,
                               &hObj,
                               &pCurrent);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    FAILED to get the security for %ws: %lu\n",
               wszPath, dwErr);
        return(dwErr);
    }

    //
    // Ok, add the access
    //
    dwErr = AddAE(pwszUser,
                  DEFAULT_ACCESS,
                  Inherit,
                  ACTRL_ACCESS_ALLOWED,
                  pCurrent,
                  &pNew);

    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Set it, interrupt it, and set it again
        //
        if(fDoHandle == TRUE)
        {
            dwErr = SetSecurityInfoExW(hObj,
                                       SE_FILE_OBJECT,
                                       DACL_SECURITY_INFORMATION,
                                       NULL,
                                       pNew,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &Overlapped);
        }
        else
        {
            dwErr = SetNamedSecurityInfoExW(wszPath,
                                            SE_FILE_OBJECT,
                                            DACL_SECURITY_INFORMATION,
                                            NULL,
                                            pNew,
                                            NULL,
                                            NULL,
                                            NULL,
                                            &Overlapped);
        }

        //
        // Immeadiately cancel it...
        //
        if(dwErr == ERROR_SUCCESS)
        {
            WaitForSingleObject(Overlapped.hEvent,
                                100);
            dwErr = CancelOverlappedAccess(&Overlapped);
            if(dwErr != ERROR_SUCCESS)
            {
                printf("Cancel FAILED with %lu\n", dwErr);
            }
        }

        //
        // Now, reset it and verify it
        //
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = SetSecurityForPath(wszPath,fDoHandle,hObj,pNew);

            if(dwErr != ERROR_SUCCESS)
            {
                printf("Set FAILED: %lu\n", dwErr);
            }
        }

        LocalFree(pNew);
    }


    dwErr = VerifyTreeSet(pwszPath,
                          pwszUser,
                          Inherit);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    VerifyTreeSet FAILED with %lu\n", dwErr);
    }

    //
    // Restore the current security
    //
    dwErr2 = SetNamedSecurityInfoExW(wszPath,
                                     SE_FILE_OBJECT,
                                     DACL_SECURITY_INFORMATION,
                                     NULL,
                                     pCurrent,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);
    if(dwErr2 != ERROR_SUCCESS)
    {
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }
        printf("FAILED to restore the security for %ws: %lu\n",
               wszPath, dwErr2);
    }
    LocalFree(pCurrent);

    HANDLE_CLOSE(hObj);

    return(dwErr);
}




DWORD
DoCompressTest (
    IN  PWSTR   pwszPath,
    IN  PWSTR   pwszUser,
    IN  BOOL    fDoHandle
    )
/*++

Routine Description:

    Does the entry compression test

Arguments:

    pwszPath --  Root path
    pwszUser --  User to run with
    fDoHandle -- Do the handle based API

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    WCHAR           rgwszPaths[2][MAX_PATH];
    INT             i,j;
    ULONG           cOrigCnt;
    PACTRL_ACCESS   pCurrent;
    PACTRL_ACCESS   pNew;
    HANDLE          hObj;
    ULONG           OpenFlags[] = {FILE_FLAG_BACKUP_SEMANTICS, 0};
    ACCESS_RIGHTS   Rights[] = {ACTRL_DELETE,
                                ACTRL_READ_CONTROL,
                                ACTRL_CHANGE_ACCESS,
                                ACTRL_CHANGE_OWNER,
                                ACTRL_SYNCHRONIZE,
                                ACTRL_STD_RIGHTS_ALL};

    printf("Entry compression test\n");

    swprintf(rgwszPaths[0],
             L"%ws%ws",
             pwszPath,
             gpwszTreeList[RandomIndex(cTree)]);

    swprintf(rgwszPaths[1],
             L"%ws%ws",
             pwszPath,
             gpwszFileList[RandomIndex(cFile)]);

    for(i = 0; i < 2; i++)
    {
        cOrigCnt = 0;
        printf("    Processing path %ws\n", rgwszPaths[i]);

        for(j = 0; j < sizeof(Rights) / sizeof(ACCESS_RIGHTS); j++)
        {
            hObj = NULL;
            printf("        Processing right 0x%lx\n", Rights[j]);

            dwErr = GetSecurityForPath(rgwszPaths[i],
                                       fDoHandle,
                                       OpenFlags[i],
                                       &hObj,
                                       &pCurrent);
            if(dwErr != ERROR_SUCCESS)
            {
                printf("    FAILED to read the DACL off %ws: %lu\n",
                       rgwszPaths[i], dwErr);
            }
            else
            {
                if(cOrigCnt == 0)
                {
                    cOrigCnt = pCurrent->pPropertyAccessList[0].
                                                   pAccessEntryList->cEntries;
                }

                //
                // Ok, now add the entry for our user
                //
                dwErr = AddAE(pwszUser,
                              Rights[0] | ACTRL_DIR_TRAVERSE | ACTRL_DIR_LIST,
                              0,
                              ACTRL_ACCESS_ALLOWED,
                              pCurrent,
                              &pNew);

                if(dwErr == ERROR_SUCCESS)
                {
                    //
                    // Set it
                    //
                    dwErr = SetSecurityForPath(rgwszPaths[i], fDoHandle,
                                               hObj, pNew);
                    if(dwErr != ERROR_SUCCESS)
                    {
                        printf("Set FAILED: %lu\n", dwErr);
                    }
                    LocalFree(pNew);
                }

                //
                // If that worked, reread the new security, and see if it's
                // correct
                //
                if(dwErr == ERROR_SUCCESS)
                {
                    HANDLE_CLOSE(hObj);
                    dwErr = GetSecurityForPath(rgwszPaths[i],
                                               fDoHandle,
                                               OpenFlags[i],
                                               &hObj,
                                               &pNew);
                    if(dwErr != ERROR_SUCCESS)
                    {
                        printf("    FAILED to read the 2nd DACL off %ws: %lu\n",
                               rgwszPaths[i], dwErr);
                    }
                    else
                    {
                        //
                        // We should only have one property, so cheat...
                        //
                        ULONG cGot = pNew->pPropertyAccessList[0].
                                                   pAccessEntryList->cEntries;
                        if(cOrigCnt + 1 != cGot)
                        {
                            printf("     Expected %lu entries, got %lu\n",
                                   cOrigCnt + 1, cGot);
                            dwErr = ERROR_INVALID_FUNCTION;
                        }

                        LocalFree(pNew);
                    }

                    //
                    // Restore the current security
                    //
                    SetNamedSecurityInfoExW(rgwszPaths[i],
                                            SE_FILE_OBJECT,
                                            DACL_SECURITY_INFORMATION,
                                            NULL,
                                            pCurrent,
                                            NULL,
                                            NULL,
                                            NULL,
                                            NULL);
                }

                LocalFree(pCurrent);
            }

            HANDLE_CLOSE(hObj);

            if(dwErr != ERROR_SUCCESS)
            {
                break;
            }
        }
    }

    return(dwErr);
}




DWORD
DoCompress2Test (
    IN  PWSTR   pwszPath,
    IN  PWSTR   pwszUser,
    IN  BOOL    fDoHandle
    )
/*++

Routine Description:

    Does the big list entry compression test

Arguments:

    pwszPath --  Root path
    pwszUser --  User to run with
    fDoHandle -- Do the handle based API

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    WCHAR           rgwszPaths[2][MAX_PATH];
    INT             i,j;
    ULONG           cOrigCnt;
    PACTRL_ACCESS   pCurrent;
    PACTRL_ACCESS   pNew;
    HANDLE          hObj;
    ULONG           OpenFlags[] = {FILE_FLAG_BACKUP_SEMANTICS, 0};
    ACCESS_RIGHTS   Rights[] = {ACTRL_DELETE,
                                ACTRL_READ_CONTROL,
                                ACTRL_CHANGE_ACCESS,
                                ACTRL_CHANGE_OWNER,
                                ACTRL_SYNCHRONIZE,
                                ACTRL_STD_RIGHTS_ALL,
                                ACTRL_DIR_TRAVERSE | ACTRL_DIR_LIST};
    INT             cItems = sizeof(Rights) / sizeof(ACCESS_RIGHTS);
    ACTRL_ACCESS_ENTRY  AAEList[sizeof(Rights) / sizeof(ACCESS_RIGHTS)];
    PACTRL_ACCESS_ENTRY pAE;

    printf("Entry compression test\n");

    swprintf(rgwszPaths[0],
             L"%ws%ws",
             pwszPath,
             gpwszTreeList[RandomIndex(cTree)]);

    swprintf(rgwszPaths[1],
             L"%ws%ws",
             pwszPath,
             gpwszFileList[RandomIndex(cFile)]);

    for(i = 0; i < 2; i++)
    {
        printf("    Processing path %ws\n", rgwszPaths[i]);
        cOrigCnt = 0;

        hObj = NULL;

        dwErr = GetSecurityForPath(rgwszPaths[i],
                                   fDoHandle,
                                   OpenFlags[i],
                                   &hObj,
                                   &pCurrent);
        if(dwErr != ERROR_SUCCESS)
        {
            printf("    FAILED to read the DACL off %ws: %lu\n",
                   rgwszPaths[i], dwErr);
        }
        else
        {
            if(cOrigCnt == 0)
            {
                cOrigCnt = pCurrent->pPropertyAccessList[0].
                                               pAccessEntryList->cEntries;
            }

            //
            // Ok, now add the entries for our user
            //
            for(j = 0; j < sizeof(Rights) / sizeof(ACCESS_RIGHTS); j++)
            {
                printf("        Processing right 0x%lx\n", Rights[j]);

                BuildTrusteeWithNameW(&(AAEList[j].Trustee),
                                      pwszUser);
                AAEList[j].fAccessFlags       = ACTRL_ACCESS_ALLOWED;
                AAEList[j].Access             = Rights[j];
                AAEList[j].ProvSpecificAccess = 0;
                AAEList[j].Inheritance        = 0;
                AAEList[j].lpInheritProperty  = NULL;
            }

            //
            // Now, add 'em
            //
            dwErr = SetEntriesInAccessListW(cItems,
                                            AAEList,
                                            GRANT_ACCESS,
                                            NULL,
                                            pCurrent,
                                            &pNew);

            if(dwErr == ERROR_SUCCESS)
            {
                //
                // Set it
                //
                dwErr = SetSecurityForPath(rgwszPaths[i], fDoHandle,
                                           hObj, pNew);
                if(dwErr != ERROR_SUCCESS)
                {
                    printf("Set FAILED: %lu\n", dwErr);
                }
                LocalFree(pNew);
            }

            //
            // If that worked, reread the new security, and see if it's
            // correct
            //
            if(dwErr == ERROR_SUCCESS)
            {
                HANDLE_CLOSE(hObj);
                dwErr = GetSecurityForPath(rgwszPaths[i],
                                           fDoHandle,
                                           OpenFlags[i],
                                           &hObj,
                                           &pNew);
                if(dwErr != ERROR_SUCCESS)
                {
                    printf("    FAILED to read the 2nd DACL off %ws: %lu\n",
                           rgwszPaths[i], dwErr);
                }
                else
                {
                    //
                    // We should only have one property, so cheat...
                    //
                    ULONG cGot = pNew->pPropertyAccessList[0].
                                               pAccessEntryList->cEntries;
                    if(cOrigCnt + 1 != cGot)
                    {
                        printf("     Expected %lu entries, got %lu\n",
                               cOrigCnt + 1, cGot);
                        dwErr = ERROR_INVALID_FUNCTION;
                    }
                    else
                    {
                        //
                        // Find the added entry...
                        //
                        pAE = NULL;
                        for(j = 0;
                            j < (INT)pNew->pPropertyAccessList[0].
                                                pAccessEntryList->cEntries;
                            j++)
                        {
                            if(_wcsicmp(pwszUser,
                                        pNew->pPropertyAccessList[0].
                                            pAccessEntryList->pAccessList[j].
                                                        Trustee.ptstrName) == 0)
                            {
                                pAE = &(pNew->pPropertyAccessList[0].
                                                    pAccessEntryList->pAccessList[j]);
                                break;
                            }
                        }

                        if(pAE == NULL)
                        {
                            printf("    Couldn't find entry for %ws\n", pwszUser);
                            dwErr = ERROR_INVALID_FUNCTION;
                        }
                        else
                        {
                            ACCESS_RIGHTS   ExpectedAR = 0;
                            for(j = 0; j < cItems; j++)
                            {
                                ExpectedAR |= Rights[j];
                            }

                            if(pAE->Access != ExpectedAR)
                            {
                                printf("    Expected compressed rights of 0x%lx, not 0x%lx\n",
                                       ExpectedAR, pAE->Access);
                                dwErr = ERROR_INVALID_FUNCTION;
                            }

                        }
                    }

                    LocalFree(pNew);
                }

                //
                // Restore the current security
                //
                SetNamedSecurityInfoExW(rgwszPaths[i],
                                        SE_FILE_OBJECT,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        pCurrent,
                                        NULL,
                                        NULL,
                                        NULL,
                                        NULL);
            }

            LocalFree(pCurrent);
        }

        HANDLE_CLOSE(hObj);

        if(dwErr != ERROR_SUCCESS)
        {
            break;
        }
    }

    return(dwErr);
}




DWORD
DoNoAccessTest (
    IN  PWSTR           pwszPath,
    IN  PWSTR           pwszUser,
    IN  INHERIT_FLAGS   Inherit,
    IN  BOOL            fDoHandle
    )
/*++

Routine Description:

    Does the NoAccess tree test, where some child node does not have access
    to its children

Arguments:

    pwszPath --  Root path
    pwszUser --  User to run with
    Inherit -- Inheritance flags
    fDoHandle -- If true, use the handle based APIs

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS, dwErr2;
    INT             i,j, iChild;
    PACTRL_ACCESS   pCurrent;
    PACTRL_ACCESS   pCurrentChild;
    PACTRL_ACCESS   pNew;
    PACTRL_ACCESS   pNewChild;
    HANDLE          hObj = NULL;
    HANDLE          hChildObj = NULL;
    WCHAR           wszPath[MAX_PATH + 1];
    WCHAR           wszChildPath[MAX_PATH + 1];
    WCHAR           rgwszPaths[2][MAX_PATH];
    PACTRL_ACCESS_ENTRYW    pAE;
    PSECURITY_DESCRIPTOR    pSD;

    printf("NoAccess Tree test\n");

    swprintf(wszPath,
             L"%ws%ws",
             pwszPath,
             gpwszTreeList[0]);

    iChild = RandomIndexNotRoot(cTree);
    if(iChild == (INT)(cTree - 1))
    {
        iChild--;
    }

    //
    // Set the access on the root, and then we'll read the child and look for
    // the appropratie access
    //
    dwErr = GetSecurityForPath(wszPath,
                               fDoHandle,
                               FILE_FLAG_BACKUP_SEMANTICS,
                               &hObj,
                               &pCurrent);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    FAILED to get the security for %ws: %lu\n",
               wszPath, dwErr);
        return(dwErr);
    }
    else
    {
        swprintf(wszChildPath,
                 L"%ws%ws",
                 pwszPath,
                 gpwszTreeList[iChild]);

        dwErr = GetSecurityForPath(wszChildPath,
                                   fDoHandle,
                                   FILE_FLAG_BACKUP_SEMANTICS,
                                   &hChildObj,
                                   &pCurrentChild);
        if(dwErr != ERROR_SUCCESS)
        {
            printf("    FAILED to get the security for %ws: %lu\n",
                   wszPath, dwErr);
            HANDLE_CLOSE(hObj);
            LocalFree(pCurrent);
            return(dwErr);
        }

    }

    //
    // Ok, add the access to the child
    //
    dwErr = AddAE(L"Everyone",
                  ACTRL_DIR_LIST | ACTRL_DIR_TRAVERSE,
                  0,
                  ACTRL_ACCESS_DENIED,
                  pCurrentChild,
                  &pNewChild);
    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Set it
        //
        dwErr = SetSecurityForPath(wszChildPath,fDoHandle,hChildObj,pNewChild);

        if(dwErr != ERROR_SUCCESS)
        {
            printf("Child set FAILED: %lu\n", dwErr);
        }
        LocalFree(pNewChild);
    }

    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AddAE(pwszUser,
                      DEFAULT_ACCESS,
                      Inherit,
                      ACTRL_ACCESS_ALLOWED,
                      pCurrent,
                      &pNew);

        //
        // Set it
        //
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = SetSecurityForPath(wszPath,fDoHandle,hObj,pNew);

            if(dwErr != ERROR_SUCCESS)
            {
                printf("Set returned %lu as expected\n", dwErr);
                if(dwErr == ERROR_ACCESS_DENIED)
                {
                    dwErr = ERROR_SUCCESS;
                }
            }
            else
            {
                printf("Set succeeded when it should have FAILED!\n");
                dwErr = ERROR_INVALID_FUNCTION;
            }
        }
        LocalFree(pNew);
    }


    //
    // Restore the current child security.  Use the old APIs so we don't
    // end up trying to do propagation
    //
    dwErr2 = ConvertAccessToSecurityDescriptor(pCurrentChild,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &pSD);
    if(dwErr2 == ERROR_SUCCESS)
    {
        if(SetFileSecurity(wszChildPath,
                           DACL_SECURITY_INFORMATION,
                           pSD) == FALSE)
        {
            dwErr2 = GetLastError();
            printf("SetFileSecurity on %ws FAILED with %lu\n",
                   wszChildPath, dwErr2);
        }

        LocalFree(pSD);
    }
    else
    {
        printf("ConvertAccessToSecurityDescriptor FAILED with %lu\n",
               dwErr2);
    }

    if(dwErr2 != ERROR_SUCCESS)
    {
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }
        printf("FAILED to restore the security for %ws: %lu\n",
               wszChildPath, dwErr2);
    }
    LocalFree(pCurrentChild);


    //
    // Restore the current security
    //
    dwErr2 = SetNamedSecurityInfoExW(wszPath,
                                     SE_FILE_OBJECT,
                                     DACL_SECURITY_INFORMATION,
                                     NULL,
                                     pCurrent,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);
    if(dwErr2 != ERROR_SUCCESS)
    {
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }
        printf("FAILED to restore the security for %ws: %lu\n",
               wszPath, dwErr2);
    }
    LocalFree(pCurrent);


    HANDLE_CLOSE(hObj);
    HANDLE_CLOSE(hChildObj);

    return(dwErr);
}




DWORD
DoOpenDirTest (
    IN  PWSTR           pwszPath,
    IN  PWSTR           pwszUser,
    IN  INHERIT_FLAGS   Inherit,
    IN  BOOL            fDoHandle
    )
/*++

Routine Description:

    Does the OpenDir tree test, where some child node has been opened

Arguments:

    pwszPath --  Root path
    pwszUser --  User to run with
    Inherit -- Inheritance flags
    fDoHandle -- If true, use the handle based APIs

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS, dwErr2;
    INT             i,iChild;
    PACTRL_ACCESS   pCurrent;
    PACTRL_ACCESS   pNew;
    HANDLE          hObj = NULL;
    HANDLE          hChild = NULL;
    WCHAR           wszPath[MAX_PATH + 1];
    WCHAR           wszChildPath[MAX_PATH + 1];
    ULONG           ShareFlags[] = {0, FILE_SHARE_WRITE, FILE_SHARE_READ};
    PSTR            rgszShareFlags[] = {"None", "Write", "Read"};
    ULONG           ExpectedReturn[] = {ERROR_SHARING_VIOLATION,
                                        ERROR_SHARING_VIOLATION,
                                        ERROR_SUCCESS};

    printf("Open Directory test\n");

    swprintf(wszPath,
             L"%ws%ws",
             pwszPath,
             gpwszTreeList[0]);

    iChild = RandomIndex(cTree);

    //
    // Set the access on the root, and then we'll read the child and look for
    // the appropratie access
    //
    dwErr = GetSecurityForPath(wszPath,
                               fDoHandle,
                               FILE_FLAG_BACKUP_SEMANTICS,
                               &hObj,
                               &pCurrent);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    FAILED to get the security for %ws: %lu\n",
               wszPath, dwErr);
        return(dwErr);
    }
    else
    {
        swprintf(wszChildPath,
                 L"%ws%ws",
                 pwszPath,
                 gpwszTreeList[iChild]);
    }

    //
    // Do this through all our flags
    //
    for(i = 0;
        i < sizeof(ShareFlags) / sizeof(ULONG) && dwErr == ERROR_SUCCESS;
        i++)
    {

        printf("    Opening %ws with share flags %s\n",
               wszChildPath, rgszShareFlags[i]);

        //
        // Open the child
        //
        hChild = CreateFile(wszChildPath,
                            GENERIC_READ | GENERIC_WRITE,
                            ShareFlags[i],
                            NULL,
                            OPEN_EXISTING,
                            FILE_FLAG_BACKUP_SEMANTICS,
                            NULL);
        if(hChild == INVALID_HANDLE_VALUE)
        {
            dwErr = GetLastError();
        }

        //
        // Create the new entry
        //
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = AddAE(pwszUser,
                          DEFAULT_ACCESS,
                          Inherit,
                          ACTRL_ACCESS_ALLOWED,
                          pCurrent,
                          &pNew);

            //
            // Set it
            //
            if(dwErr == ERROR_SUCCESS)
            {
                dwErr = SetSecurityForPath(wszPath,fDoHandle,hObj,pNew);

                if(dwErr == ExpectedReturn[i])
                {
                    printf("    Set returned %lu as expected\n", dwErr);
                    dwErr = ERROR_SUCCESS;
                }
                else
                {
                    printf("    Set returned an unexpected %lu instead of %lu!\n",
                           dwErr, ExpectedReturn[i]);
                    if(dwErr == ERROR_SUCCESS)
                    {
                        dwErr = ERROR_INVALID_FUNCTION;
                    }
                }
            }
            LocalFree(pNew);
        }
        HANDLE_CLOSE(hChild);
    }

    //
    // Restore the current security
    //
    dwErr2 = SetNamedSecurityInfoExW(wszPath,
                                     SE_FILE_OBJECT,
                                     DACL_SECURITY_INFORMATION,
                                     NULL,
                                     pCurrent,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);
    if(dwErr2 != ERROR_SUCCESS)
    {
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }
        printf("FAILED to restore the security for %ws: %lu\n",
               wszPath, dwErr2);
    }
    LocalFree(pCurrent);


    HANDLE_CLOSE(hObj);

    return(dwErr);
}




DWORD
DoProtectedTest (
    IN  PWSTR           pwszPath,
    IN  PWSTR           pwszUser,
    IN  INHERIT_FLAGS   Inherit,
    IN  BOOL            fDoHandle
    )
/*++

Routine Description:

    Does the protected child test.

Arguments:

    pwszPath --  Root path
    pwszUser --  User to run with
    Inherit -- Inheritance flags
    fDoHandle -- If true, use the handle based APIs

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS, dwErr2;
    WCHAR           wszPath[MAX_PATH + 1];
    WCHAR           wszChildPath[MAX_PATH + 1];
    PACTRL_ACCESS   pCurrent, pCurrentChild, pNew;
    HANDLE          hObj = NULL;

    printf("Propagation with protected child test\n");

    //
    // Pick a file
    //
    swprintf(wszChildPath,
             L"%ws%ws",
             pwszPath,
             gpwszFileList[RandomIndex(cFile)]);


    //
    // Build the parent
    //
    wcscpy(wszPath, wszChildPath);
    *(wcsrchr(wszPath, L'\\')) = L'\0';

    //
    // Get the current security off of both
    //
    dwErr = GetSecurityForPath(wszPath, fDoHandle, FILE_FLAG_BACKUP_SEMANTICS, &hObj, &pCurrent);
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = GetSecurityForPath(wszChildPath, FALSE, 0, NULL, &pCurrentChild);
        if(dwErr != ERROR_SUCCESS)
        {
            LocalFree(pCurrent);
        }
    }



    if(dwErr == ERROR_SUCCESS)
    {
        //
        // Set a NULL security descriptor on child
        //
        SECURITY_DESCRIPTOR SD;

        InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION);
        SetSecurityDescriptorDacl(&SD, TRUE, NULL, FALSE);
        //
        // Stamp it on the object directly
        //
        if(SetFileSecurity(wszChildPath, DACL_SECURITY_INFORMATION, &SD) == FALSE)
        {
            dwErr = GetLastError();
            printf("    Setting NULL DACL on %ws FAILED with %lu\n", wszChildPath, dwErr);
        }
    }
    else
    {
        printf("    FAILED to read the security: %lu\n", dwErr);
        return(dwErr);
    }

    //
    // Ok, now we'll set on the parent, and then look at the child
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = AddAE(pwszUser,
                      DEFAULT_ACCESS,
                      Inherit,
                      ACTRL_ACCESS_ALLOWED,
                      pCurrent,
                      &pNew);

        //
        // Set it
        //
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = SetSecurityForPath(wszPath,fDoHandle,hObj,pNew);

            if(dwErr != ERROR_SUCCESS)
            {
                printf("    Setting security on %ws FAILED with %lu\n", wszPath, dwErr);
            }

            LocalFree(pNew);
        }
    }

    //
    // Now, if all of that worked, we'll read the security off the child, and make sure that
    // it is correct
    //
    if(dwErr == ERROR_SUCCESS)
    {
        dwErr = GetSecurityForPath(wszChildPath, FALSE, 0, NULL, &pNew);
        if(dwErr != ERROR_SUCCESS)
        {
            printf("    GetSecurity on child %ws FAILED with %lu\n", wszChildPath, dwErr);
        }
        else
        {
            //
            // We should have a protected acl and an empty list
            //
            ASSERT(pNew->pPropertyAccessList != NULL);
            if(!FLAG_ON(pNew->pPropertyAccessList[0].fListFlags, ACTRL_ACCESS_PROTECTED))
            {
                printf("    Child list not protected\n");
                dwErr = ERROR_INVALID_FUNCTION;
            }

            if(pNew->pPropertyAccessList[0].pAccessEntryList != NULL)
            {
                printf("    Child list not NULL\n");
                dwErr = ERROR_INVALID_FUNCTION;
            }
        }
    }


    //
    // Restore the current security, child first
    //
    dwErr2 = SetNamedSecurityInfoExW(wszChildPath,
                                     SE_FILE_OBJECT,
                                     DACL_SECURITY_INFORMATION,
                                     NULL,
                                     pCurrentChild,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);
    if(dwErr2 != ERROR_SUCCESS)
    {
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }
        printf("FAILED to restore the security for %ws: %lu\n",
               wszChildPath, dwErr2);
    }

    dwErr2 = SetNamedSecurityInfoExW(wszPath,
                                     SE_FILE_OBJECT,
                                     DACL_SECURITY_INFORMATION,
                                     NULL,
                                     pCurrent,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL);
    if(dwErr2 != ERROR_SUCCESS)
    {
        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }
        printf("FAILED to restore the security for %ws: %lu\n",
               wszPath, dwErr2);
    }

    LocalFree(pCurrent);
    LocalFree(pCurrentChild);


    HANDLE_CLOSE(hObj);

    return(dwErr);
}




DWORD
DoGet3Test (
    IN  PWSTR   pwszPath,
    IN  PWSTR   pwszUser,
    IN  BOOL    fDoHandle
    )
/*++

Routine Description:

    Does the simple read test

Arguments:

    pwszPath --  Root path
    pwszUser --  User to run with
    fDoHandle -- If true, use the handle based APIs

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    WCHAR           rgwszPaths[MAX_PATH];
    PACTRL_ACCESS   pAccessList = NULL, pAuditList = NULL;
    LPWSTR          lpOwner = NULL, lpGroup = NULL;
    ULONG   SeInfo = DACL_SECURITY_INFORMATION;


    printf("Get3 Test\n");

    swprintf(rgwszPaths,
             L"%ws%ws",
             pwszPath,
             gpwszTreeList[RandomIndex(cTree)]);

    printf("    Processing path %ws\n", rgwszPaths);


    if(rand() % 2 == 1)
    {
        SeInfo |= OWNER_SECURITY_INFORMATION;
    }

    if(rand() % 2 == 1 || SeInfo == DACL_SECURITY_INFORMATION)
    {
        SeInfo |= GROUP_SECURITY_INFORMATION;
    }

    dwErr = GetNamedSecurityInfoEx( rgwszPaths, SE_FILE_OBJECT,
                                        SeInfo,
                                        NULL,NULL,&pAccessList,&pAuditList,
                                        &lpOwner,&lpGroup);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    FAILED: %lu\n", dwErr);
    }
    else
    {
        printf("    SeInfo: %lu\n", SeInfo);

        if ((SeInfo & OWNER_SECURITY_INFORMATION) != 0) {

            printf("    Owner: %ws\n", lpOwner);
            LocalFree(lpOwner);
        }

        if ((SeInfo & GROUP_SECURITY_INFORMATION) != 0) {

            printf("    Group: %ws\n", lpGroup);
            LocalFree(lpGroup);

        }

        LocalFree(pAccessList);
        LocalFree(pAuditList);
    }
    return(dwErr);
}




DWORD
DoGetOwnerTest (
    IN  PWSTR   pwszPath,
    IN  PWSTR   pwszUser,
    IN  BOOL    fDoHandle
    )
/*++

Routine Description:

    Gets the owner from a file

Arguments:

    pwszPath --  Root path
    pwszUser --  User to run with
    fDoHandle -- If true, use the handle based APIs

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    WCHAR           rgwszPaths[MAX_PATH];
    PACTRL_ACCESS   pAccessList = NULL, pAuditList = NULL;
    LPWSTR          lpOwner = NULL, lpGroup = NULL;
    ULONG   SeInfo = DACL_SECURITY_INFORMATION;


    printf("GetOwner Test\n");

    swprintf(rgwszPaths,
             L"%ws%ws",
             pwszPath,
             gpwszTreeList[RandomIndex(cTree)]);

    printf("    Processing path %ws\n", rgwszPaths);


    dwErr = GetNamedSecurityInfoEx( rgwszPaths, SE_FILE_OBJECT,
                                    OWNER_SECURITY_INFORMATION,
                                    NULL,NULL,&pAccessList,&pAuditList,
                                    &lpOwner,&lpGroup);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    FAILED: %lu\n", dwErr);
    }
    else
    {
        printf("    Owner: %ws\n", lpOwner);
        LocalFree(lpOwner);
    }
    return(dwErr);
}




__cdecl main (
    IN  INT argc,
    IN  CHAR *argv[])
/*++

Routine Description:

    The main

Arguments:

    argc --  Count of arguments
    argv --  List of arguments

Return Value:

    0     --  Success
    non-0 --  Failure

--*/
{

    DWORD           dwErr = ERROR_SUCCESS, dwErr2;
    WCHAR           wszPath[MAX_PATH + 1];
    WCHAR           wszUser[MAX_PATH + 1];
    INHERIT_FLAGS   Inherit = 0;
    ULONG           Tests = 0;
    INT             i;
    BOOL            fHandle = FALSE;

    srand((ULONG)(GetTickCount() * GetCurrentThreadId()));

    if(argc < 3)
    {
        Usage(argv[0]);
        exit(1);
    }

    mbstowcs(wszPath, argv[1], strlen(argv[1]) + 1);
    mbstowcs(wszUser, argv[2], strlen(argv[2]) + 1);

    //
    // process the command line
    //
    for(i = 3; i < argc; i++)
    {
        if(_stricmp(argv[i], "/h") == 0)
        {
            fHandle = TRUE;
        }
        else if(_stricmp(argv[i],"/C") == 0)
        {
            Inherit |= SUB_CONTAINERS_ONLY_INHERIT;
        }
        else if(_stricmp(argv[i],"/O") == 0)
        {
            Inherit |= SUB_OBJECTS_ONLY_INHERIT;
        }
        else if(_stricmp(argv[i],"/I") == 0)
        {
            Inherit |= INHERIT_ONLY;
        }
        else if(_stricmp(argv[i],"/P") == 0)
        {
            Inherit |= INHERIT_NO_PROPAGATE;
        }
        else if(_stricmp(argv[i],"/READ") == 0)
        {
            Tests |= FTEST_READ;
        }
        else if(_stricmp(argv[i],"/TREE") == 0)
        {
            Tests |= FTEST_TREE;
        }
        else if(_stricmp(argv[i],"/INTERRUPT") == 0)
        {
            Tests |= FTEST_INTERRUPT;
        }
        else if(_stricmp(argv[i],"/COMPRESS") == 0)
        {
            Tests |= FTEST_COMPRESS;
        }
        else if(_stricmp(argv[i],"/NOACCESS") == 0)
        {
            Tests |= FTEST_NOACCESS;
        }
        else if(_stricmp(argv[i],"/OPENDIR") == 0)
        {
            Tests |= FTEST_OPENDIR;
        }
        else if(_stricmp(argv[i],"/COMPRESS2") == 0)
        {
            Tests |= FTEST_COMPRESS2;
        }
        else if(_stricmp(argv[i],"/PROTECT") == 0)
        {
            Tests |= FTEST_PROTECT;
        }
        else if(_stricmp(argv[i],"/GET3") == 0)
        {
            Tests |= FTEST_GET3;
        }
        else if(_stricmp(argv[i],"/GETOWNER") == 0)
        {
            Tests |= FTEST_GETOWNER;
        }
        else
        {
            Usage(argv[0]);
            exit(1);
            break;
        }
    }

    if(Tests == 0)
    {
        Tests = FTEST_READ          |
                    FTEST_TREE      |
                    FTEST_INTERRUPT |
                    FTEST_COMPRESS  |
                    FTEST_NOACCESS  |
                    FTEST_OPENDIR   |
                    FTEST_COMPRESS2 |
                    FTEST_PROTECT   |
                    FTEST_GET3      |
                    FTEST_GETOWNER;
    }

    //
    // Build the tree
    //
    dwErr = BuildTree(wszPath);
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, FTEST_READ))
    {
        dwErr = DoReadTest(wszPath, wszUser, fHandle);
    }
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, FTEST_TREE))
    {
        dwErr = DoTreeTest(wszPath, wszUser, Inherit, fHandle);
    }
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, FTEST_INTERRUPT))
    {
        dwErr = DoInterruptTest(wszPath, wszUser, Inherit, fHandle);
    }
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, FTEST_COMPRESS))
    {
        dwErr = DoCompressTest(wszPath, wszUser, fHandle);
    }
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, FTEST_NOACCESS))
    {
        dwErr = DoNoAccessTest(wszPath, wszUser, Inherit, fHandle);
    }
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, FTEST_OPENDIR))
    {
        dwErr = DoOpenDirTest(wszPath, wszUser, Inherit, fHandle);
    }
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, FTEST_COMPRESS2))
    {
        dwErr = DoCompress2Test(wszPath, wszUser, fHandle);
    }
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, FTEST_PROTECT))
    {
        dwErr = DoProtectedTest(wszPath, wszUser, Inherit, fHandle);
    }
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, FTEST_GET3))
    {
        dwErr = DoGet3Test(wszPath, wszUser, fHandle);
    }
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, FTEST_GETOWNER))
    {
        dwErr = DoGetOwnerTest(wszPath, wszUser, fHandle);
    }

    dwErr2 = DeleteTree(wszPath);
    if(dwErr2 != ERROR_SUCCESS)
    {
        printf("FAILED to delete the tree: %lu\n", dwErr);

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = dwErr2;
        }
    }

    printf("%s\n", dwErr == ERROR_SUCCESS ?
                                    "success" :
                                    "failed");
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\test\unc\unc.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       UNC.C
//
//  Contents:   Unit test for file propagation, issues
//
//  History:    05-Mar-98       MacM        Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <aclapi.h>

#define UTEST_DOUBLE_UNC    0x00000001

#define FLAG_ON(flags,bit)        ((flags) & (bit))


VOID
Usage (
    IN  PSTR    pszExe
    )
/*++

Routine Description:

    Displays the usage

Arguments:

    pszExe - Name of the exe

Return Value:

    VOID

--*/
{
    printf("%s path [/test]\n", pszExe);
    printf("    where path is the UNC path to use\n");
    printf("          /test indicates which test to run:\n");
    printf("                /DOUBLE (Double Read from UNC path)\n");

    return;
}

DWORD
DoubleUncTest(
    IN PWSTR pwszUNCPath
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    PACTRL_ACCESS pAccess;

    dwErr = GetNamedSecurityInfoExW(pwszUNCPath,
                                    SE_FILE_OBJECT,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    NULL,
                                    &pAccess,
                                    NULL,
                                    NULL,
                                    NULL);
    if ( dwErr != ERROR_SUCCESS ) {

        printf("Initial GetNamedSecurityInfoExW on %ws failed with %lu\n",
               pwszUNCPath, dwErr );

    } else {

        LocalFree( pAccess );
        dwErr = GetNamedSecurityInfoExW(pwszUNCPath,
                                        SE_FILE_OBJECT,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        NULL,
                                        &pAccess,
                                        NULL,
                                        NULL,
                                        NULL);
        if ( dwErr != ERROR_SUCCESS ) {

            printf( "Second GetNamedSecurityInfoExW on %ws failed with %lu\n",
                    pwszUNCPath, dwErr );

        } else {

            LocalFree( pAccess );
        }

    }


    return( dwErr );
}


__cdecl main (
    IN  INT argc,
    IN  CHAR *argv[])
/*++

Routine Description:

    The main

Arguments:

    argc --  Count of arguments
    argv --  List of arguments

Return Value:

    0     --  Success
    non-0 --  Failure

--*/
{

    DWORD           dwErr = ERROR_SUCCESS, dwErr2;
    WCHAR           wszPath[MAX_PATH + 1];
    WCHAR           wszUser[MAX_PATH + 1];
    INHERIT_FLAGS   Inherit = 0;
    ULONG           Tests = 0;
    INT             i;
    BOOL            fHandle = FALSE;

    srand((ULONG)(GetTickCount() * GetCurrentThreadId()));

    if(argc < 2)
    {
        Usage(argv[0]);
        exit(1);
    }

    mbstowcs(wszPath, argv[1], strlen(argv[1]) + 1);

    //
    // process the command line
    //
    for(i = 3; i < argc; i++)
    {
        if(_stricmp(argv[i],"/DOUBLE") == 0)
        {
            Tests |= UTEST_DOUBLE_UNC;
        }
        else
        {
            Usage(argv[0]);
            exit(1);
            break;
        }
    }

    if(Tests == 0)
    {
        Tests = UTEST_DOUBLE_UNC;
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, UTEST_DOUBLE_UNC))
    {
        dwErr = DoubleUncTest(wszPath);
    }

    printf("%s\n", dwErr == ERROR_SUCCESS ?
                                    "success" :
                                    "failed");
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\test\service\service.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       FILE.C
//
//  Contents:   Unit test for file propagation, issues
//
//  History:    14-Sep-96       MacM        Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <aclapi.h>
#include <seopaque.h>
#include <ntrtl.h>

#define FLAG_ON(flags,bit)        ((flags) & (bit))

#define DEFAULT_ACCESS  ACTRL_SVC_GET_INFO | ACTRL_SVC_SET_INFO |           \
                        ACTRL_SVC_STATUS   | ACTRL_SVC_LIST     |           \
                        ACTRL_SVC_START    | ACTRL_SVC_STOP     |           \
                        ACTRL_SVC_PAUSE    | ACTRL_SVC_INTERROGATE


#define HANDLE_CLOSE(h) if((h) != NULL) { CloseServiceHandle(h); (h) = NULL;}

//
// Flags for tests
//
#define STEST_READ      0x00000001
#define STEST_CACHE     0x00000002


DWORD
AddAE (
    IN  PWSTR           pwszUser,
    IN  ACCESS_RIGHTS   AccessRights,
    IN  INHERIT_FLAGS   Inherit,
    IN  ULONG           fAccess,
    IN  PACTRL_ACCESS   pExistingAccess,
    OUT PACTRL_ACCESS  *ppNewAccess
    )
/*++

Routine Description:

    Initialize an access entry

Arguments:

    pwszUser - User to set
    AccessRights - Access rights to set
    Inherit - Any inheritance flags
    fAccess - Allowed or denied node?
    pExistingAccess - Access Entry to add to
    ppNewAccess - Where the new access is returned

Return Value:

    ERROR_SUCCESS - Success

--*/
{
    DWORD               dwErr = ERROR_SUCCESS;
    ACTRL_ACCESS_ENTRY  AAE;

    BuildTrusteeWithNameW(&(AAE.Trustee),
                          pwszUser);
    AAE.fAccessFlags       = fAccess;
    AAE.Access             = AccessRights;
    AAE.ProvSpecificAccess = 0;
    AAE.Inheritance        = Inherit;
    AAE.lpInheritProperty  = NULL;

    dwErr = SetEntriesInAccessListW(1,
                                   &AAE,
                                   GRANT_ACCESS,
                                   NULL,
                                   pExistingAccess,
                                   ppNewAccess);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    Failed to add new access entry: %lu\n", dwErr);
    }

    return(dwErr);
}




VOID
Usage (
    IN  PSTR    pszExe
    )
/*++

Routine Description:

    Displays the usage

Arguments:

    pszExe - Name of the exe

Return Value:

    VOID

--*/
{
    printf("%s service user [/C] [/O] [/I] [/P] [/test] [/H]\n", pszExe);
    printf("    where services is the display name of the service\n");
    printf("          user is the name of a user to set access for\n");
    printf("          /test indicates which test to run:\n");
    printf("                /READ (Simple read/write)\n");
    printf("                /CACHE (Cache matching)\n");
    printf("            if test is not specified, all variations are run\n");
    printf("          /H indicates to use the handle version of the APIs\n");
    printf("          /C is Container Inherit\n");
    printf("          /O is Object Inherit\n");
    printf("          /I is InheritOnly\n");
    printf("          /P is Inherit No Propagate\n");

    return;
}


//
// Conceptually, this is a companion function for GetSecurityForPath
//
#define SetSecurityForService(svc,usehandle,handle,access)          \
(usehandle == TRUE ?                                                \
    SetSecurityInfoExW(handle,                                      \
                       SE_SERVICE,                                  \
                       DACL_SECURITY_INFORMATION,                   \
                       NULL,                                        \
                       access,                                      \
                       NULL,                                        \
                       NULL,                                        \
                       NULL,                                        \
                       NULL)        :                               \
    SetNamedSecurityInfoExW(svc,                                    \
                            SE_SERVICE,                             \
                            DACL_SECURITY_INFORMATION,              \
                            NULL,                                   \
                            access,                                 \
                            NULL,                                   \
                            NULL,                                   \
                            NULL,                                   \
                            NULL))


DWORD
GetSecurityForService (
    IN  PWSTR           pwszService,
    IN  BOOL            fUseHandle,
    OUT HANDLE         *phObj,
    OUT PACTRL_ACCESSW *ppAccess
    )
/*++

Routine Description:

    Reads the dacl off the specified service object

Arguments:

    pwszService --  Service to read
    fUseHandle -- Use handle or path based API
    phObj -- Handle to object
    ppAccess -- Where the access is returned

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD       dwErr = ERROR_SUCCESS;
    SC_HANDLE   hSC;

    if(fUseHandle == TRUE)
    {
        //
        // Open the object
        //
        if(*phObj == NULL)
        {
             hSC = OpenSCManager(NULL,
                                 NULL,
                                 GENERIC_READ);
            if(hSC == NULL)
            {
                dwErr = GetLastError();
            }
            else
            {
                //
                // Open the service
                //
                *phObj = OpenService(hSC,
                                     pwszService,
                                     READ_CONTROL | WRITE_DAC);
                if(*phObj == NULL)
                {
                    dwErr = GetLastError();
                }
            }
        }

        if(dwErr == ERROR_SUCCESS)
        {
            dwErr = GetSecurityInfoExW(*phObj,
                                       SE_SERVICE,
                                       DACL_SECURITY_INFORMATION,
                                       NULL,
                                       NULL,
                                       ppAccess,
                                       NULL,
                                       NULL,
                                       NULL);
            if(dwErr != ERROR_SUCCESS)
            {
                HANDLE_CLOSE(*phObj);
            }

        }

    }
    else
    {
        dwErr = GetNamedSecurityInfoExW(pwszService,
                                        SE_SERVICE,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        NULL,
                                        ppAccess,
                                        NULL,
                                        NULL,
                                        NULL);
        if(phObj != NULL)
        {
            *phObj = NULL;
        }
    }

    return(dwErr);
}




DWORD
DoReadTest (
    IN  PWSTR   pwszService,
    IN  PWSTR   pwszUser,
    IN  BOOL    fDoHandle
    )
/*++

Routine Description:

    Does the simple read test

Arguments:

    pwszService --  Service name
    pwszUser --  User to run with
    fDoHandle -- If true, use the handle based APIs

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    PACTRL_ACCESS   pCurrent;
    PACTRL_ACCESS   pNew;
    HANDLE          hObj;

    printf("Simple read/write test\n");

    printf("    Processing service %ws\n", pwszService);
    hObj = NULL;

    dwErr = GetSecurityForService(pwszService,
                                  fDoHandle,
                                  &hObj,
                                  &pCurrent);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    Failed to read the DACL off %ws: %lu\n", pwszService, dwErr);
    }
    else
    {
        //
        // Ok, now add the entry for our user
        //
        dwErr = AddAE(pwszUser,
                      DEFAULT_ACCESS,
                      0,
                      ACTRL_ACCESS_ALLOWED,
                      pCurrent,
                      &pNew);
        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Set it
            //
            dwErr = SetSecurityForService(pwszService, fDoHandle, hObj, pNew);

            if(dwErr != ERROR_SUCCESS)
            {
                printf("    Set failed: %lu\n", dwErr);
            }
            LocalFree(pNew);
        }

        //
        // If that worked, reread the new security, and see if it's correct
        //
        if(dwErr == ERROR_SUCCESS)
        {
            HANDLE_CLOSE(hObj);

            dwErr = GetSecurityForService(pwszService,
                                          fDoHandle,
                                          &hObj,
                                          &pNew);
            if(dwErr != ERROR_SUCCESS)
            {
                printf("    Failed to read the 2nd DACL off %ws: %lu\n", pwszService, dwErr);
            }
            else
            {
                //
                // We should only have one property, so cheat...
                //
                ULONG cExpected = 1 + pCurrent->pPropertyAccessList[0].
                                               pAccessEntryList->cEntries;
                ULONG cGot = pNew->pPropertyAccessList[0].
                                               pAccessEntryList->cEntries;
                if(cExpected != cGot)
                {
                    printf("     Expected %lu entries, got %lu\n",
                           cExpected, cGot);
                    dwErr = ERROR_INVALID_FUNCTION;
                }

                LocalFree(pNew);
            }

            //
            // Restore the current security
            //
            SetNamedSecurityInfoExW(pwszService,
                                    SE_SERVICE,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    pCurrent,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL);
        }

        LocalFree(pCurrent);
    }

    HANDLE_CLOSE(hObj);

    return(dwErr);
}




DWORD
DoCacheTest (
    IN  PWSTR   pwszService,
    IN  PWSTR   pwszUser,
    IN  BOOL    fDoHandle
    )
/*++

Routine Description:

    Does the marta cache matching test

Arguments:

    pwszService --  Service name
    pwszUser --  User to run with
    fDoHandle -- If true, use the handle based APIs

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    PACTRL_ACCESS   pCurrent;
    INT             i;
    SE_OBJECT_TYPE  SeList[] = {SE_FILE_OBJECT, SE_SERVICE, SE_PRINTER,
                                SE_REGISTRY_KEY, SE_LMSHARE, SE_KERNEL_OBJECT,
                                SE_WINDOW_OBJECT, SE_DS_OBJECT, SE_DS_OBJECT_ALL};
    PSTR            pszSeList[] = {"SE_FILE_OBJECT", "SE_SERVICE", "SE_PRINTER",
                                   "SE_REGISTRY_KEY", "SE_LMSHARE", "SE_KERNEL_OBJECT",
                                   "SE_WINDOW_OBJECT", "SE_DS_OBJECT", "SE_DS_OBJECT_ALL"};

    ASSERT(sizeof(SeList) / sizeof(SE_OBJECT_TYPE) == sizeof(pszSeList) / sizeof(PSTR));

    printf("Marta cache matching test\n");

    printf("    Processing service %ws\n", pwszService);

    //
    // Prime the cache...
    //
    dwErr = GetNamedSecurityInfoExW(pwszService,
                                    SE_SERVICE,
                                    DACL_SECURITY_INFORMATION,
                                    NULL,
                                    NULL,
                                    &pCurrent,
                                    NULL,
                                    NULL,
                                    NULL);
    if(dwErr != ERROR_SUCCESS)
    {
        printf("    Failed to read the DACL off %ws: %lu\n", pwszService, dwErr);
    }
    else
    {
        LocalFree(pCurrent);

        //
        // Now, open it as an another object type...
        //
        for(i = 0; i < sizeof(pszSeList) / sizeof(PSTR); i++)
        {
            printf("    Processing %ws as a %s\n", pwszService, pszSeList[i]);

            if(GetNamedSecurityInfoExW(pwszService,
                                       SeList[i],
                                       DACL_SECURITY_INFORMATION,
                                       NULL,
                                       NULL,
                                       &pCurrent,
                                       NULL,
                                       NULL,
                                       NULL) == ERROR_SUCCESS)
            {
                LocalFree(pCurrent);
            }
        }

        //
        // In order to check this, we'll set the debugger on NTMARTA, turn on cache tracing,
        // and see how many hits we have.  Tacky, no doubt, but we have little choice
        //
    }

    //
    // Now, create a file of the same name, and do the same code
    //
    if(dwErr == ERROR_SUCCESS)
    {
        HANDLE  hFile;
        printf("    Processing file %ws\n", pwszService);

        hFile = CreateFile(pwszService, GENERIC_READ | GENERIC_WRITE, 0, NULL,
                           OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if(hFile == INVALID_HANDLE_VALUE)
        {
            dwErr = GetLastError();
            printf("    CreateEvent on %ws failed with %lu\n", pwszService, dwErr);
        }
        else
        {
            for(i = 0; i < sizeof(pszSeList) / sizeof(PSTR); i++)
            {
                printf("    Processing %ws as a %s\n", pwszService, pszSeList[i]);

                if(GetNamedSecurityInfoExW(pwszService,
                                           SeList[i],
                                           DACL_SECURITY_INFORMATION,
                                           NULL,
                                           NULL,
                                           &pCurrent,
                                           NULL,
                                           NULL,
                                           NULL) == ERROR_SUCCESS)
                {
                    LocalFree(pCurrent);
                }
            }

            if(GetNamedSecurityInfoExW(pwszService,
                                       SE_FILE_OBJECT,
                                       DACL_SECURITY_INFORMATION,
                                       NULL,
                                       NULL,
                                       &pCurrent,
                                       NULL,
                                       NULL,
                                       NULL) == ERROR_SUCCESS)
            {
                LocalFree(pCurrent);
            }
            CloseHandle(hFile);
            DeleteFile(pwszService);
        }
    }

    return(dwErr);
}




__cdecl main (
    IN  INT argc,
    IN  CHAR *argv[])
/*++

Routine Description:

    The main

Arguments:

    argc --  Count of arguments
    argv --  List of arguments

Return Value:

    0     --  Success
    non-0 --  Failure

--*/
{

    DWORD           dwErr = ERROR_SUCCESS;
    WCHAR           wszService[MAX_PATH + 1];
    WCHAR           wszUser[MAX_PATH + 1];
    INHERIT_FLAGS   Inherit = 0;
    ULONG           Tests = 0;
    INT             i;
    BOOL            fHandle = FALSE;

    srand((ULONG)(GetTickCount() * GetCurrentThreadId()));

    if(argc < 3)
    {
        Usage(argv[0]);
        exit(1);
    }

    mbstowcs(wszService, argv[1], strlen(argv[1]) + 1);
    mbstowcs(wszUser, argv[2], strlen(argv[2]) + 1);

    //
    // process the command line
    //
    for(i = 3; i < argc; i++)
    {
        if(_stricmp(argv[i], "/h") == 0)
        {
            fHandle = TRUE;
        }
        else if(_stricmp(argv[i],"/C") == 0)
        {
            Inherit |= SUB_CONTAINERS_ONLY_INHERIT;
        }
        else if(_stricmp(argv[i],"/O") == 0)
        {
            Inherit |= SUB_OBJECTS_ONLY_INHERIT;
        }
        else if(_stricmp(argv[i],"/I") == 0)
        {
            Inherit |= INHERIT_ONLY;
        }
        else if(_stricmp(argv[i],"/P") == 0)
        {
            Inherit |= INHERIT_NO_PROPAGATE;
        }
        else if(_stricmp(argv[i],"/READ") == 0)
        {
            Tests |= STEST_READ;
        }
        else if(_stricmp(argv[i],"/CACHE") == 0)
        {
            Tests |= STEST_CACHE;
        }
        else
        {
            Usage(argv[0]);
            exit(1);
            break;
        }
    }

    if(Tests == 0)
    {
        Tests = STEST_READ;
    }

    //
    // Build the tree
    //
    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, STEST_READ))
    {
        dwErr = DoReadTest(wszService, wszUser, fHandle);
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, STEST_CACHE))
    {
        dwErr = DoCacheTest(wszService, wszUser, fHandle);
    }

    printf("%s\n", dwErr == ERROR_SUCCESS ?
                                    "success" :
                                    "failed");
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\utest\ntmartat.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1996.
//
//  File:       NTMARTAT.C
//
//  Contents:   NT Marta provider unit test
//
//  History:    29-Aug-96       MacM        Created
//
//----------------------------------------------------------------------------

#include <windows.h>

#include <accprov.h>
#include <stdlib.h>
#include <stdio.h>

//
// These come from access.hxx
//
#define SLEN(x)  ((sizeof(x) / sizeof(CHAR)) - 1)
void *AccAlloc(ULONG cSize);
#if DBG == 1
void AccFree(PVOID   pv);
#else
    #define AccFree LocalFree
#endif



//
// Object types
//
#define OT_FILEA            "FILE"
#define OT_SERVICEA         "SERVICE"
#define OT_PRINTERA         "PRINTER"
#define OT_REGISTRYA        "REGISTRY"
#define OT_SHAREA           "SHARE"
#define OT_KERNELA          "KERNEL"
#define OT_DSA              "DS"
#define OT_DSALLA           "DS_ALL"

#define OT_CAPLEVELA        "capclass"
#define OT_CAPLEVELA_LEN    SLEN(OT_CAPLEVELA)
#define OT_TRUSTEEA         "set"
#define OT_TRUSTEEA_LEN     SLEN(OT_TRUSTEEA)
#define OT_ACCESSA          "setaccess"
#define OT_ACCESSA_LEN      SLEN(OT_ACCESSA)
#define OT_SEINFOA          "seinfo"
#define OT_SEINFOA_LEN      SLEN(OT_SEINFOA)
#define OT_GTRUSTEEA        "grant"
#define OT_GTRUSTEEA_LEN    SLEN(OT_GTRUSTEEA)
#define OT_GACCESSA         "grantaccess"
#define OT_GACCESSA_LEN     SLEN(OT_GACCESSA)
#define OT_RTRUSTEEA        "revoke"
#define OT_RTRUSTEEA_LEN    SLEN(OT_RTRUSTEEA)


//
// Macro to determine if a command line parameter matches
//
#define CMDLINE_MATCH(index, str, len)                      \
(_strnicmp(argv[index],str,len) == 0 && argv[index][len] == ':')

//+---------------------------------------------------------------------------
//
//  Function:   Usage
//
//  Synopsis:   Displays the expected usage
//
//  Arguments:  None
//
//  Returns:    VOID
//
//  Notes:
//
//----------------------------------------------------------------------------
void Usage()
{
    printf("USAGE: NTMARTA objectname objecttype <%s:x> <%s:x> [<%s:x> <%s:x>] "
    "[<%s:x> <%s:x>] <%s:x>\n",
           OT_CAPLEVELA,
           OT_SEINFOA,
           OT_TRUSTEEA,
           OT_ACCESSA,
           OT_GTRUSTEEA,
           OT_GACCESSA,
           OT_RTRUSTEEA);

    printf("       tests NT MARTA provider\n");
    printf("       objectname = path to the object\n");
    printf("       objecttype = %s\n",OT_FILEA);
    printf("                    %s\n",OT_SERVICEA);
    printf("                    %s\n",OT_PRINTERA);
    printf("                    %s\n",OT_REGISTRYA);
    printf("                    %s\n",OT_SHAREA);
    printf("                    %s\n",OT_KERNELA);
    printf("                    %s\n",OT_DSA);
    printf("                    %s\n",OT_DSALLA);
    printf("        <%s:x> where x is the capabilities class to query for\n",
          OT_CAPLEVELA);
    printf("        <%s:x> where x is the SeInfo to get/set\n",
          OT_SEINFOA);
    printf("        <%s:x> where x is the trustee to set\n",
          OT_TRUSTEEA);
    printf("        <%s:x> where x is the access to set\n",
          OT_ACCESSA);
    printf("        <%s:x> where x is the trustee to grant\n",
          OT_GTRUSTEEA);
    printf("        <%s:x> where x is the access to grant\n",
          OT_GACCESSA);
    printf("        <%s:x> where x is the trustee to revoke\n",
          OT_RTRUSTEEA);
}



//+---------------------------------------------------------------------------
//
//  Function:   DumpAccessEntry
//
//  Synopsis:   Displays the access entry to the screen
//
//  Arguments:  [IN  pAE]       --      Access entry to display
//
//  Returns:    VOID
//
//  Notes:
//
//----------------------------------------------------------------------------
void DumpAccessEntry(PACTRL_ACCESS_ENTRY    pAE)
{
    printf("\tPACTRL_ACCESS_ENTRY@%lu\n",pAE);
    printf("\t\tTrustee:              %ws\n", pAE->Trustee.ptstrName);
    printf("\t\tfAccessFlags:       0x%lx\n", pAE->fAccessFlags);
    printf("\t\tAccess:             0x%lx\n", pAE->Access);
    printf("\t\tProvSpecificAccess: 0x%lx\n", pAE->ProvSpecificAccess);
    printf("\t\tInheritance:        0x%lx\n", pAE->Inheritance);
    printf("\t\tlpInheritProperty:  0x%lx\n", pAE->lpInheritProperty);
}




//+---------------------------------------------------------------------------
//
//  Function:   DumpAList
//
//  Synopsis:   Displays an access or audit list
//
//  Arguments:  [IN  pAList]    --      AList to display
//
//  Returns:    VOID
//
//  Notes:
//
//----------------------------------------------------------------------------
void DumpAList(PACTRL_ALIST pAList)
{
    ULONG iIndex, iAE;

    for(iIndex = 0; iIndex < pAList->cEntries; iIndex++)
    {
        printf("\tProperty: %ws\n",
               pAList->pPropertyAccessList[iIndex].lpProperty);

        for(iAE = 0;
            iAE < pAList->pPropertyAccessList[iIndex].pAccessEntryList->
                                                                     cEntries;
            iAE++)
        {
            DumpAccessEntry(&(pAList->pPropertyAccessList[iIndex].
                                         pAccessEntryList->pAccessList[iAE]));
        }
    }

}




//+---------------------------------------------------------------------------
//
//  Function:   GetAndDumpInfo
//
//  Synopsis:   Gets and displays the access info for the specified object
//
//  Arguments:  [IN  pwszObject]    --      Object path
//              [IN  ObjType]       --      Object type
//              [IN  SeInfo]        --      Security info to get
//              [OUT ppAccess]      --      Where to return access list
//              [OUT ppAudit]       --      Where to return audit list
//              [OUT ppOwner]       --      Where to return owner
//              [OUT ppGroup]       --      Where to return group
//
//  Returns:    ERRORS_SUCCESS      --      Success
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD   GetAndDumpInfo(PCWSTR                   pwszObject,
                       SE_OBJECT_TYPE           ObjType,
                       SECURITY_INFORMATION     SeInfo,
                       PACTRL_ACCESS           *ppAccess,
                       PACTRL_AUDIT            *ppAudit,
                       PTRUSTEE                *ppOwner,
                       PTRUSTEE                *ppGroup)

{
    DWORD   dwErr;
    ULONG   iIndex;

    *ppAccess = NULL;
    *ppAudit  = NULL;
    *ppOwner  = NULL;
    *ppGroup  = NULL;

    dwErr = AccProvGetAllRights((LPCWSTR)pwszObject,
                                ObjType,
                                NULL,
                                (SeInfo & DACL_SECURITY_INFORMATION) != 0 ?
                                                                ppAccess :
                                                                NULL,
                                (SeInfo & SACL_SECURITY_INFORMATION) != 0 ?
                                                                ppAudit :
                                                                NULL,
                                (SeInfo & OWNER_SECURITY_INFORMATION) != 0 ?
                                                                ppOwner :
                                                                NULL,
                                (SeInfo & GROUP_SECURITY_INFORMATION) != 0 ?
                                                                ppGroup :
                                                                NULL);
    if(dwErr == ERROR_SUCCESS)
    {
        if(*ppOwner != NULL)
        {
            printf("\tOwner: %ws\n",
                   (*ppOwner)->ptstrName);
        }

        if(*ppGroup != NULL)
        {
            printf("\tGroup: %ws\n",
                   (*ppGroup)->ptstrName);
        }

        if(*ppAccess != NULL)
        {
            DumpAList(*ppAccess);
        }

        if(*ppAudit != NULL)
        {
            DumpAList(*ppAudit);
        }
    }

    return(dwErr);

}


//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   The main
//
//  Arguments:  [IN argc]           --      Count of arguments
//              [IN argv]           --      List of arguments
//
//  Returns:    0                   --      Success
//              1                   --      Failure
//
//  Notes:
//
//----------------------------------------------------------------------------
__cdecl main(INT argc,
             CHAR *argv[])
{
    WCHAR   wszPath[MAX_PATH + 1];
    SE_OBJECT_TYPE ObjType= SE_UNKNOWN_OBJECT_TYPE;
    ULONG   dwCapsClass = 0;
    ULONG   dwAccess    = 0;
    ULONG   dwGrantAcc  = 0;
    WCHAR   wszTrustee[MAX_PATH + 1];
    WCHAR   wszGrant[MAX_PATH + 1];
    WCHAR   wszRevoke[MAX_PATH + 1];

    ULONG   cAccess = 0;   // Used to do argument validation
    ULONG   cGrant = 0;
    ULONG   cRevoke = 0;
    DWORD   dwCaps;
    ULONG   iIndex;
    DWORD   dwErr;

    SECURITY_INFORMATION    SeInfo = DACL_SECURITY_INFORMATION |
                                            OWNER_SECURITY_INFORMATION;


    PACTRL_ACCESS_INFO  pAccInfo;
    ULONG               cAccInfo;
    ULONG               fAccFlags;

    PACTRL_ACCESS   pAccess = NULL;
    PACTRL_AUDIT    pAudit  = NULL;
    PTRUSTEE        pOwner  = NULL;
    PTRUSTEE        pGroup  = NULL;

    if(argc < 3)
    {
        Usage();
        exit(1);
    }

    if(strcmp(argv[1], "-?") == 0 ||
       strcmp(argv[1], "/?") == 0)
    {
        Usage();
        exit(1);
    }


    mbstowcs(wszPath,
             argv[1],
             strlen(argv[1]) + 1);

    //
    // Figure out what the object type is
    //
    if(_stricmp(argv[2], OT_FILEA) == 0)
    {
        ObjType = SE_FILE_OBJECT;
    }
    else if (_stricmp(argv[2],OT_SERVICEA) == 0)
    {
        ObjType = SE_SERVICE;
    }
    else if (_stricmp(argv[2],OT_PRINTERA) == 0)
    {
        ObjType = SE_PRINTER;
    }
    else if (_stricmp(argv[2],OT_REGISTRYA) == 0)
    {
        ObjType = SE_REGISTRY_KEY;
    }
    else if (_stricmp(argv[2],OT_SHAREA) == 0)
    {
        ObjType = SE_LMSHARE;
    }
    else if (_stricmp(argv[2],OT_KERNELA) == 0)
    {
        ObjType = SE_KERNEL_OBJECT;
    }
    else if (_stricmp(argv[2],OT_DSA) == 0)
    {
        ObjType = SE_DS_OBJECT;
    }
    else if (_stricmp(argv[2],OT_DSALLA) == 0)
    {
        ObjType = SE_DS_OBJECT_ALL;
    }


    for(iIndex = 3; iIndex < (ULONG)argc; iIndex++)
    {
        printf("processing cmdline entry: %s\n", argv[iIndex]);
        if(CMDLINE_MATCH(iIndex, OT_CAPLEVELA, OT_CAPLEVELA_LEN))
        {
            dwCapsClass = atol(argv[iIndex] + OT_CAPLEVELA_LEN + 1);
        }
        else if(CMDLINE_MATCH(iIndex,OT_ACCESSA,OT_ACCESSA_LEN))
        {
            dwAccess = atol(argv[iIndex] + OT_ACCESSA_LEN + 1);
            cAccess++;
        }
        else if(CMDLINE_MATCH(iIndex,OT_TRUSTEEA,OT_TRUSTEEA_LEN))
        {
            mbstowcs(wszTrustee,
                     argv[iIndex] + OT_TRUSTEEA_LEN + 1,
                     strlen(argv[iIndex] + OT_TRUSTEEA_LEN + 1) + 1);
            cAccess++;
        }
        else if(CMDLINE_MATCH(iIndex, OT_SEINFOA, OT_SEINFOA_LEN))
        {
            SeInfo = (SECURITY_INFORMATION)
                                     atol(argv[iIndex] + OT_SEINFOA_LEN + 1);
        }
        else if (CMDLINE_MATCH(iIndex, OT_GTRUSTEEA, OT_GTRUSTEEA_LEN))
        {
            mbstowcs(wszGrant,
                     argv[iIndex] + OT_GTRUSTEEA_LEN + 1,
                     strlen(argv[iIndex] + OT_GTRUSTEEA_LEN + 1) + 1);
            cGrant++;
        }
        else if (CMDLINE_MATCH(iIndex, OT_RTRUSTEEA, OT_RTRUSTEEA_LEN))
        {
            mbstowcs(wszRevoke,
                     argv[iIndex] + OT_RTRUSTEEA_LEN + 1,
                     strlen(argv[iIndex] + OT_RTRUSTEEA_LEN + 1) + 1);
            cRevoke++;
        }
        else if(CMDLINE_MATCH(iIndex,OT_GACCESSA,OT_GACCESSA_LEN))
        {
            dwGrantAcc = atol(argv[iIndex] + OT_GACCESSA_LEN + 1);
            cGrant++;
        }
        else
        {
            printf("Unknown argument \"%s\" being ignorned\n", argv[iIndex]);
        }
    }


    //
    // Ok, first, we'll try the capabilities
    //
    printf("\nCAPABILITIES: dwCapsClass: %ld\n", dwCapsClass);
    AccProvGetCapabilities(dwCapsClass,
                           &dwCaps);
    printf("AccProvGetCapabilities returned capabilities %ld\n",
           dwCaps);

    //
    // Then, get the list of supported rights
    //
    dwErr = AccProvGetAccessInfoPerObjectType((LPCWSTR)wszPath,
                                              ObjType,
                                              &cAccInfo,
                                              &pAccInfo,
                                              &fAccFlags);
    if(dwErr == ERROR_SUCCESS)
    {
        printf("AccessInfo: %lu objects\n",
               cAccInfo);
        printf("AccessFlags: %lu\n",
               fAccFlags);

        for(iIndex = 0; iIndex < cAccInfo; iIndex++)
        {
            printf("\t%ws\t\t0x%08lx\n",
                   pAccInfo[iIndex].lpAccessPermissionName,
                   pAccInfo[iIndex].fAccessPermission);
        }

        AccFree(pAccInfo);
    }

    printf("\nACCESSIBILITY\n");
    //
    // Then, the accessibility stuff
    //
    dwErr = AccProvIsObjectAccessible((LPCWSTR)wszPath,
                                      ObjType);
    if(dwErr == ERROR_SUCCESS)
    {
        printf("Object %ws is accessible\n",
                wszPath);

        //
        // Do it again, for caching purposes
        //
        dwErr = AccProvIsObjectAccessible((LPCWSTR)wszPath,
                                          ObjType);
        if(dwErr == ERROR_SUCCESS)
        {
            printf("Object %ws is still accessible\n",
                    wszPath);
        }
        else
        {
            printf("Second access attempt on %ws failed with %lu\n",
                   wszPath,
                   dwErr);
        }
    }
    else
    {
        printf("First access attempt on %ws failed with %lu\n",
               wszPath,
               dwErr);
    }


    if(dwErr == ERROR_SUCCESS)
    {
        //
        // First, get the rights for the object
        //
        printf("\nACCESS - GetAllRights\n");
        dwErr =  GetAndDumpInfo((LPCWSTR)wszPath,
                                ObjType,
                                SeInfo,
                                &pAccess,
                                &pAudit,
                                &pOwner,
                                &pGroup);
        if(dwErr != ERROR_SUCCESS)
        {
            printf("GetAllRights failed with %lu\n",
                   dwErr);
        }
    }

    //
    // If that worked, try setting it...
    //
    if(dwErr == ERROR_SUCCESS && cAccess == 2)
    {
        DWORD                   dwErr2;
        ACTRL_ALIST             NewAccess;
        ACTRL_PROPERTY_ENTRY    APE;
        ACTRL_ACCESS_ENTRY_LIST AAEL;
        PACTRL_ACCESS_ENTRY     pNewList;

        NewAccess.cEntries = 1;
        NewAccess.pPropertyAccessList = &APE;

        APE.lpProperty = NULL;
        APE.fListFlags = 0;
        APE.pAccessEntryList = &AAEL;

        AAEL.cEntries = 1;
        if(pAccess != NULL)
        {
            AAEL.cEntries += pAccess->pPropertyAccessList[0].pAccessEntryList->cEntries;
        }

        pNewList = (PACTRL_ACCESS_ENTRY)
                AccAlloc(AAEL.cEntries * sizeof(ACTRL_ACCESS_ENTRY));
        if(pNewList == NULL)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            printf("Failed to allocate for %lu nodes\n",
                   AAEL.cEntries);
        }
        else
        {
            if(pAccess != NULL)
            {
                memcpy(pNewList,
                       pAccess->pPropertyAccessList[0].pAccessEntryList->pAccessList,
                       (AAEL.cEntries - 1) * sizeof(ACTRL_ACCESS_ENTRY));
            }

            printf("Adding %lu for trustee %ws to %ws\n",
                    dwAccess,
                    wszTrustee,
                    wszPath);

            pNewList[AAEL.cEntries - 1].Trustee.ptstrName =
                                                          wszTrustee;
            pNewList[AAEL.cEntries - 1].Trustee.TrusteeForm =
                                                          TRUSTEE_IS_NAME;
            pNewList[AAEL.cEntries - 1].Trustee.TrusteeType =
                                                          TRUSTEE_IS_USER;
            pNewList[AAEL.cEntries - 1].Access = dwAccess;
            pNewList[AAEL.cEntries - 1].fAccessFlags =
                                                     ACTRL_ACCESS_ALLOWED;
            pNewList[AAEL.cEntries - 1].ProvSpecificAccess = 0;
            pNewList[AAEL.cEntries - 1].Inheritance = 0;
            pNewList[AAEL.cEntries - 1].lpInheritProperty = NULL;



        }
        AAEL.pAccessList = pNewList;


        if(dwErr == ERROR_SUCCESS)
        {
            //
            // Get a valid event to wait on...
            //
            ACTRL_OVERLAPPED    Overlapped;
            Overlapped.hEvent = CreateEvent(NULL,
                                            TRUE,
                                            FALSE,
                                            NULL);

            printf("\nACCESS - SetAccessRights\n");
            dwErr = AccProvSetAccessRights((LPCWSTR)wszPath,
                                           ObjType,
                                           SeInfo,
                                           &NewAccess,
                                           NULL,
                                           pOwner,
                                           pGroup,
                                           &Overlapped);
            if(dwErr == ERROR_SUCCESS)
            {
                printf("SetAccessRights on %ws succeeded!\n",
                       wszPath);
                WaitForSingleObject(Overlapped.hEvent,
                                    INFINITE);
                Sleep(1000);

                //
                // Get the results
                //

                dwErr = AccProvGetOperationResults(&Overlapped,
                                                   &dwErr2);
                if(dwErr2 == ERROR_SUCCESS)
                {
                    printf("AccProvGetOperationResults succeeded!\n");
                    printf("Operation results: %lu\n",
                           dwErr2);
                }
                else
                {
                    printf("AccProvGetOperationResults failed with %lu\n",
                           dwErr2);
                    dwErr = dwErr2;
                }
            }
            else
            {
                printf("SetAccessRights on %ws failed with %lu\n",
                       wszPath,
                       dwErr);
            }

            AccFree(pNewList);
        }

        //
        // If it worked, get the results again and display them
        //
        if(dwErr == ERROR_SUCCESS)
        {
            AccFree(pAccess);
            AccFree(pAudit);
            AccFree(pOwner);
            AccFree(pGroup);

            pAccess = NULL;
            pAudit  = NULL;
            pOwner  = NULL;
            pGroup  = NULL;

            dwErr =  GetAndDumpInfo((LPCWSTR)wszPath,
                                    ObjType,
                                    SeInfo,
                                    &pAccess,
                                    &pAudit,
                                    &pOwner,
                                    &pGroup);
            if(dwErr != ERROR_SUCCESS)
            {
                printf("GetAllRights failed with %lu\n",
                       dwErr);
            }
        }
    }

#if 0
    //
    // Now, see if we can do a grant...
    //
    if(dwErr == ERROR_SUCCESS && cGrant == 2)
    {
        ACTRL_ACCESS        NewAccess;
        ACTRL_ACCESS_ENTRY  NewAccessList[1];
        NewAccess.cEntries = 1;
        NewAccess.pAccessList = NewAccessList;


        memset(NewAccessList, 0, sizeof(NewAccessList));

        printf("Granting %lu for trustee %ws to %ws\n",
                dwGrantAcc,
                wszGrant,
                wszPath);

        NewAccessList[0].Trustee.ptstrName   = wszGrant;
        NewAccessList[0].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
        NewAccessList[0].Trustee.TrusteeType = TRUSTEE_IS_USER;
        NewAccessList[0].Access              = dwGrantAcc;
        NewAccessList[0].fAEFlags            = ACTRL_ACCESS_ALLOWED;


        //
        // Get a valid event to wait on...
        //
        ACTRL_OVERLAPPED    Overlapped;
        Overlapped.hEvent = CreateEvent(NULL,
                                        TRUE,
                                        FALSE,
                                        NULL);

        printf("\nACCESS - GrantAccessRights\n");
        dwErr = AccProvGrantAccessRights((LPCWSTR)wszPath,
                                         ObjType,
                                         &NewAccess,
                                         NULL,
                                         &Overlapped);
        if(dwErr == ERROR_SUCCESS)
        {
            printf("GrantAccessRights on %ws succeeded!\n",
                   wszPath);
            WaitForSingleObject(Overlapped.hEvent,
                                INFINITE);
            Sleep(1000);

            //
            // Get the results
            //
            DWORD   dwErr2;
            dwErr = AccProvGetOperationResults(&Overlapped,
                                               &dwErr2);
            if(dwErr2 == ERROR_SUCCESS)
            {
                printf("AccProvGetOperationResults succeeded!\n");
                printf("Operation results: %lu\n",
                       dwErr2);
            }
            else
            {
                printf("AccProvGetOperationResults failed with %lu\n",
                       dwErr2);
                dwErr = dwErr2;
            }
        }
        else
        {
            printf("GrantAccessRights on %ws failed with %lu\n",
                   wszPath,
                   dwErr);
        }

        //
        // If it worked, get the results again and display them
        //
        if(dwErr == ERROR_SUCCESS)
        {
            AccFree(pAccess);
            AccFree(pAudit);
            AccFree(pOwner);
            AccFree(pGroup);

            pAccess = NULL;
            pAudit  = NULL;
            pOwner  = NULL;
            pGroup  = NULL;

            dwErr =  GetAndDumpInfo((LPCWSTR)wszPath,
                                    ObjType,
                                    SeInfo,
                                    &pAccess,
                                    &pAudit,
                                    &pOwner,
                                    &pGroup);
            if(dwErr != ERROR_SUCCESS)
            {
                printf("GetAllRights failed with %lu\n",
                       dwErr);
            }
        }
    }


    //
    // Finally, a revoke...
    //
    if(dwErr == ERROR_SUCCESS)
    {
        TRUSTEE     rgTrustees[2];

        memset(rgTrustees, 0, sizeof(TRUSTEE) * 2);

        printf("Revoking accessfor trustee %ws to %ws\n",
                wszRevoke,
                wszPath);

        ULONG iRevoke = 0;

        if(cAccess == 2)
        {
            rgTrustees[iRevoke].ptstrName   = wszRevoke;
            rgTrustees[iRevoke].TrusteeForm = TRUSTEE_IS_NAME;
            rgTrustees[iRevoke].TrusteeType = TRUSTEE_IS_USER;
            iRevoke++;
        }

        if(cGrant == 2)
        {
            rgTrustees[iRevoke].ptstrName   = wszGrant;
            rgTrustees[iRevoke].TrusteeForm = TRUSTEE_IS_NAME;
            rgTrustees[iRevoke].TrusteeType = TRUSTEE_IS_USER;
            iRevoke++;
        }


        if(iRevoke != 0)
        {
            //
            // Get a valid event to wait on...
            //
            ACTRL_OVERLAPPED    Overlapped;
            Overlapped.hEvent = CreateEvent(NULL,
                                            TRUE,
                                            FALSE,
                                            NULL);

            printf("\nACCESS - RevokeAccessRights\n");
            dwErr = AccProvRevokeAccessRights((LPCWSTR)wszPath,
                                              ObjType,
                                              NULL,
                                              iRevoke,
                                              rgTrustees,
                                              &Overlapped);
            if(dwErr == ERROR_SUCCESS)
            {
                printf("RevokeAccessRights on %ws succeeded!\n",
                       wszPath);
                WaitForSingleObject(Overlapped.hEvent,
                                    INFINITE);
                Sleep(1000);

                //
                // Get the results
                //
                DWORD   dwErr2;
                dwErr = AccProvGetOperationResults(&Overlapped,
                                                   &dwErr2);
                if(dwErr2 == ERROR_SUCCESS)
                {
                    printf("AccProvGetOperationResults succeeded!\n");
                    printf("Operation results: %lu\n",
                           dwErr2);
                }
                else
                {
                    printf("AccProvGetOperationResults failed with %lu\n",
                           dwErr2);
                    dwErr = dwErr2;
                }
            }
            else
            {
                printf("RevokeAccessRights on %ws failed with %lu\n",
                       wszPath,
                       dwErr);
            }

            //
            // If it worked, get the results again and display them
            //
            if(dwErr == ERROR_SUCCESS)
            {
                AccFree(pAccess);
                AccFree(pAudit);
                AccFree(pOwner);
                AccFree(pGroup);

                pAccess = NULL;
                pAudit  = NULL;
                pOwner  = NULL;
                pGroup  = NULL;

                dwErr =  GetAndDumpInfo((LPCWSTR)wszPath,
                                        ObjType,
                                        SeInfo,
                                        &pAccess,
                                        &pAudit,
                                        &pOwner,
                                        &pGroup);
                if(dwErr != ERROR_SUCCESS)
                {
                    printf("GetAllRights failed with %lu\n",
                           dwErr);
                }
            }
        }
    }

#endif

    AccFree(pAccess);
    AccFree(pAudit);
    AccFree(pOwner);
    AccFree(pGroup);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\ntmarta\test\util\martatst.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       MARTATST.C
//
//  Contents:   Unit test for file propagation, issues
//
//  History:    14-Jan-97       MacM        Created
//
//  Notes:
//
//----------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <aclapi.h>
#include <ntrtl.h>


#define FLAG_ON(flags,bit)        ((flags) & (bit))

//
// Flags for tests
//
#define MTEST_CONVERT       0x00000001
#define MTEST_GETOWNER      0x00000002
#define MTEST_GETSACL       0x00000004
#define MTEST_BUILDSD       0x00000008
#define MTEST_GETEXPL       0x00000010
#define MTEST_GETEFF        0x00000020
#define MTEST_GETEFF2       0x00000040
#define MTEST_GETEFF3       0x00000080
#define MTEST_GETAUD        0x00000100
#define MTEST_BUILDSD2      0x00000200

void
DumpAccessEntry (
    PACTRL_ACCESS_ENTRY    pAE
    )
{
    printf("\tPACTRL_ACCESS_ENTRY@%lu\n",pAE);
    printf("\t\tTrustee:              %ws\n", pAE->Trustee.ptstrName);
    printf("\t\tfAccessFlags:       0x%lx\n", pAE->fAccessFlags);
    printf("\t\tAccess:             0x%lx\n", pAE->Access);
    printf("\t\tProvSpecificAccess: 0x%lx\n", pAE->ProvSpecificAccess);
    printf("\t\tInheritance:        0x%lx\n", pAE->Inheritance);
    printf("\t\tlpInheritProperty:  0x%lx\n", pAE->lpInheritProperty);
}




void
DumpAList (
    PACTRL_ACCESSW pAList
    )
{
    ULONG iIndex, iAE;

    for ( iIndex = 0; iIndex < pAList->cEntries; iIndex++ )  {

        printf("\tProperty: %ws\n",
               pAList->pPropertyAccessList[iIndex].lpProperty);

        for( iAE = 0;
             iAE < pAList->pPropertyAccessList[iIndex].pAccessEntryList->
                                                                     cEntries;
             iAE++) {

            DumpAccessEntry(&(pAList->pPropertyAccessList[iIndex].
                                         pAccessEntryList->pAccessList[iAE]));
        }
    }
}




VOID
Usage (
    IN  PSTR    pszExe
    )
/*++

Routine Description:

    Displays the usage

Arguments:

    pszExe - Name of the exe

Return Value:

    VOID

--*/
{
    printf("%s path user seinfo [/test] \n", pszExe);
    printf("    where path is the root path to use\n");
    printf("          user is the name of the trustee to use\n");
    printf("          seinfo is the seinfo to use for reads/writes:\n");
    printf("                    OWNER_SECURITY_INFORMATION       (0x00000001L)\n");
    printf("                    GROUP_SECURITY_INFORMATION       (0x00000002L)\n");
    printf("                    DACL_SECURITY_INFORMATION        (0x00000004L)\n");
    printf("                    SACL_SECURITY_INFORMATION        (0x00000008L)\n");
    printf("          /test indicates which test to run:\n");
    printf("                /CONVERT (ConvertSecurityDescriptorToAccessNamed)\n");
    printf("                /GETOWNER (Get owner for the file)\n");
    printf("                /GETSACL (Get sacl for the file)\n");
    printf("                /BUILDSD (BuildSecurityDescriptor with deny)\n");
    printf("                /BUILDSD2 (BuildSDA with NULL parameters)\n");
    printf("                /GETEXPL (GetExplicitEntriesFromAcl)\n");
    printf("                /GETEFF  (GetEffectiveRightsFromAcl)\n");
    printf("                /GETEFF2 (GetEffectiveRightsFromAcl2)\n");
    printf("                /GETEFF3 (GetEffectiveRightsFromAcl3 [Administrators])\n");
    printf("                /GETAUD  (GetAuditedPermissionsFromAcl on NULL SACL)\n");

    return;
}




DWORD
DoConvertSecurityDescriptorToAccessNamedTest (
    IN  PWSTR           pwszPath,
    IN  DWORD           SeInfo
    )
/*++

Routine Description:

    Reads the SD off of the object, and converts it to a Access structure

Arguments:

    pwszPath --  Root path

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR    pSD;

    printf("ConvertSecurityDescriptorToAccessNamed\n");

    dwErr = GetNamedSecurityInfo( pwszPath, SE_FILE_OBJECT, SeInfo,
                                  NULL, NULL, NULL, NULL, &pSD);

    if (dwErr != ERROR_SUCCESS) {

        fprintf(stderr, "GetNamedSecurityInfo on %ws failed with %lu\n", pwszPath, dwErr);

    } else {

        PACTRL_ACCESS pAccess = NULL;
        PACTRL_AUDIT  pAudit = NULL;
        LPTSTR pOwner = NULL;
        LPTSTR pGroup = NULL;

        dwErr = ConvertSecurityDescriptorToAccessNamed(
                    pwszPath, SE_FILE_OBJECT, pSD,
                    FLAG_ON(SeInfo, DACL_SECURITY_INFORMATION) ?
                                                            &pAccess    :
                                                            NULL,
                    FLAG_ON(SeInfo, SACL_SECURITY_INFORMATION) ?
                                                            &pAudit     :
                                                            NULL,
                    FLAG_ON(SeInfo, OWNER_SECURITY_INFORMATION) ?
                                                            &pOwner     :
                                                            NULL,
                    FLAG_ON(SeInfo, GROUP_SECURITY_INFORMATION) ?
                                                            &pGroup     :
                                                            NULL );
        if (dwErr != ERROR_SUCCESS) {

            fprintf( stderr,"ConvertSecurityDescriptor failed with %lu\n", dwErr );

        } else {

            if (pAccess != NULL ) {

                fprintf(stdout, "Access list\n");
                DumpAList( pAccess );
                LocalFree( pAccess );
            }

            if (pAudit != NULL ) {

                fprintf(stdout, "Audit list\n");
                DumpAList( pAudit );
                LocalFree( pAudit );
            }

            if (pOwner != NULL ) {

                fprintf(stdout, "Owner: %ws\n", pOwner);
                LocalFree( pOwner );
            }

            if (pGroup != NULL ) {

                fprintf(stdout, "Group: %ws\n", pGroup);
                LocalFree( pGroup );
            }

        }

        LocalFree( pSD );
    }

    return(dwErr);
}




DWORD
DoGetOwnerTest (
    IN  PWSTR           pwszPath,
    IN  DWORD           SeInfo
    )
/*++

Routine Description:

    Reads the SD off of the object, and gets the owner for from it

Arguments:

    pwszPath --  Root path
    SeInfo -- Ignored

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    PSECURITY_DESCRIPTOR    pSD;
    LPWSTR          pwszOwner;

    printf("GetOwner\n");

    dwErr = GetNamedSecurityInfoEx( pwszPath, SE_FILE_OBJECT, OWNER_SECURITY_INFORMATION,
                                    NULL, NULL, NULL, NULL, &pwszOwner, NULL );

    if ( dwErr == ERROR_SUCCESS ) {

        fprintf(stdout, "GetNamedSecurityInfoExW returned %ws\n", pwszOwner);
        LocalFree( pwszOwner );

    } else {

        fprintf(stderr, "GetNamedSecurityInfoEx on %ws failed with %lu\n", pwszPath, dwErr );
    }

    return( dwErr );
}




DWORD
DoGetSaclTest (
    IN  PWSTR           pwszPath,
    IN  DWORD           SeInfo
    )
/*++

Routine Description:

    Reads the SACL off of the object

Arguments:

    pwszPath --  Root path
    SeInfo -- Ignored

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD           dwErr = ERROR_SUCCESS;
    PACTRL_AUDIT    pAudit = NULL;
    HANDLE          hProcessToken;

    printf("GetSacl\n");

    //
    // Enable the read sacl privs
    //
    if ( OpenProcessToken(GetCurrentProcess(), MAXIMUM_ALLOWED, &hProcessToken ) == FALSE) {

        dwErr = GetLastError();

    } else {

        TOKEN_PRIVILEGES EnableSeSecurity;
        TOKEN_PRIVILEGES Previous;
        DWORD PreviousSize;

        EnableSeSecurity.PrivilegeCount = 1;
        EnableSeSecurity.Privileges[0].Luid.LowPart = SE_SECURITY_PRIVILEGE;
        EnableSeSecurity.Privileges[0].Luid.HighPart = 0;
        EnableSeSecurity.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        PreviousSize = sizeof(Previous);

        if (AdjustTokenPrivileges( hProcessToken, FALSE, &EnableSeSecurity,
                                   sizeof(EnableSeSecurity), &Previous,
                                   &PreviousSize ) == FALSE) {

            dwErr = GetLastError();
        }
    }


    if ( dwErr != ERROR_SUCCESS ) {

        fprintf( stderr, "AdjustTokenPrivileges failed with %lu\n", dwErr );

    } else {

        dwErr = GetNamedSecurityInfoEx( pwszPath, SE_FILE_OBJECT, SACL_SECURITY_INFORMATION,
                                        NULL, NULL, NULL, &pAudit, NULL, NULL);

        if (dwErr != ERROR_SUCCESS) {

            fprintf(stderr, "GetNamedSecurityInfoEx on %ws failed with %lu\n", pwszPath, dwErr);

        } else {

            fprintf(stdout, "Audit list\n");
            DumpAList( pAudit );
            LocalFree( pAudit );
        }
    }

    return(dwErr);
}




DWORD
DoBuildSDTest (
    IN  PWSTR           pwszPath,
    IN  PWSTR           pwszUser
    )
/*++

Routine Description:

    Builds a security descriptor

Arguments:

    pwszPath --  Root path
    pwszUser -- User to add

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD                   dwErr = ERROR_SUCCESS;
    EXPLICIT_ACCESS         EA[2];
    PSECURITY_DESCRIPTOR    pNewSD = NULL;
    ULONG                   cSDSize;

    printf("BuildSecurityDescriptor with DENY\n");

    BuildExplicitAccessWithName( &(EA[0]),
                                 pwszUser,
                                 STANDARD_RIGHTS_ALL,
                                 GRANT_ACCESS,
                                 0 );

    BuildExplicitAccessWithName( &(EA[1]),
                                 pwszUser,
                                 FILE_WRITE_EA,
                                 DENY_ACCESS,
                                 0 );

    dwErr = BuildSecurityDescriptorW( NULL, NULL, 2, EA, 0, NULL, NULL, &cSDSize, &pNewSD );

    if ( dwErr != ERROR_SUCCESS ) {

        fprintf( stderr, "BuildSecurityDescriptorW failed with %lu\n", dwErr );

    } else {

        LocalFree( pNewSD );
    }


    return(dwErr);
}




DWORD
DoBuildSD2Test (
    IN  PWSTR           pwszPath,
    IN  PWSTR           pwszUser
    )
/*++

Routine Description:

    Builds a security descriptor

Arguments:

    pwszPath --  Root path
    pwszUser -- User to add

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD                   dwErr = ERROR_SUCCESS;
    EXPLICIT_ACCESS         EA[2];
    PSECURITY_DESCRIPTOR    pNewSD = NULL;
    ULONG                   cSDSize;

    printf("BuildSecurityDescriptor with NULL parameters\n");


    dwErr = BuildSecurityDescriptorW( NULL, NULL, 0, NULL, 0, NULL, NULL, &cSDSize, &pNewSD );

    if ( dwErr != ERROR_SUCCESS ) {

        fprintf( stderr, "BuildSecurityDescriptorW failed with %lu\n", dwErr );

    } else {

        LocalFree( pNewSD );
    }


    return(dwErr);
}




DWORD
DoGetExplicitTest (
    IN  PWSTR           pwszPath,
    IN  ULONG           SeInfo
    )
/*++

Routine Description:

    Builds a security descriptor

Arguments:

    pwszPath --  Root path
    SeInfo -- ignored

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD   dwErr = ERROR_SUCCESS;

    PSECURITY_DESCRIPTOR    pSD = NULL;
    PACL                    pDAcl;

    printf("GetExplicitEntriesFromAcl\n");

    //
    // First, get the existing security descriptor
    //
    dwErr = GetNamedSecurityInfo( pwszPath, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION,
                                  NULL, NULL, &pDAcl, NULL, &pSD);

    if ( dwErr != ERROR_SUCCESS ) {

        fprintf( stderr, "Failed to get the access for %ws: %lu\n", pwszPath, dwErr );

    } else {

        PEXPLICIT_ACCESS    pExplicit;
        DWORD               cItems;
        //
        // Get the explicit accesses
        //
        dwErr = GetExplicitEntriesFromAcl(pDAcl, &cItems, &pExplicit);

        if ( dwErr != ERROR_SUCCESS ) {

            fprintf( stderr, "GetExplicitEntries failed with %lu\n", dwErr );

        } else {

            LocalFree( pExplicit );
        }

        LocalFree( pSD );
    }


    return(dwErr);
}




DWORD
DoGetEffectiveTest (
    IN  PWSTR           pwszPath,
    IN  PWSTR           pwszUser
    )
/*++

Routine Description:

    Builds a security descriptor

Arguments:

    pwszPath --  Root path
    pwszUser -- User to add

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD                   dwErr = ERROR_SUCCESS;
    EXPLICIT_ACCESS         EA[2];
    PSECURITY_DESCRIPTOR    pNewSD = NULL;
    ULONG                   cSDSize;

    printf("GetEffectiveRightsFromAcl test\n");

    BuildExplicitAccessWithName( &(EA[0]),
                                 pwszUser,
                                 GENERIC_ALL,
                                 GRANT_ACCESS,
                                 0x9 );

    BuildExplicitAccessWithName( &(EA[1]),
                                 pwszUser,
                                 0x1f01ff,
                                 GRANT_ACCESS,
                                 0x2 );



    dwErr = BuildSecurityDescriptorW( NULL, NULL, 2, EA, 0, NULL, NULL, &cSDSize, &pNewSD );

    if ( dwErr != ERROR_SUCCESS ) {

        fprintf( stderr, "BuildSecurityDescriptorW failed with %lu\n", dwErr );

    } else {

        PACL    pDAcl;
        BOOL    f1, f2;
        //
        // Get the ACL
        //
        if ( GetSecurityDescriptorDacl( pNewSD, &f1, &pDAcl, &f2) == FALSE ) {

            dwErr = GetLastError();

        } else {

            ACCESS_RIGHTS   Rights;
            TRUSTEE Trustee;

            BuildTrusteeWithName( &Trustee, pwszUser );

            //
            // Go ahead and get the effect access, and make sure it isn't NULL
            //
            dwErr = GetEffectiveRightsFromAcl( pDAcl, &Trustee, &Rights );

            if ( dwErr != ERROR_SUCCESS ) {

                printf( "GetEffectiveRightsFromAcl failed with %lu\n", dwErr );

            } else {

                ACCESS_RIGHTS Expected = 0x1f01ff;
                if ( Rights != Expected) {

                    printf( "Expected 0x%lx, got 0x%lx\n",
                            Expected, Rights );
                    dwErr = ERROR_INVALID_ACL;
                }
            }


        }


        LocalFree( pNewSD );
    }


    return(dwErr);
}




DWORD
DoGetEffectiveTest2 (
    IN  PWSTR           pwszPath,
    IN  PWSTR           pwszUser
    )
/*++

Routine Description:

    Builds a security descriptor

Arguments:

    pwszPath --  Root path
    pwszUser -- User to add

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD                   dwErr = ERROR_SUCCESS;
    BYTE                    Buffer[100];
    PACL                    pAcl = (PACL)Buffer;
    SID EveryoneSid = {SID_REVISION,1 ,SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID};

    printf("GetEffectiveRightsFromAcl test 2\n");

    if(InitializeAcl(pAcl, 100, ACL_REVISION) == FALSE)
    {
        printf("InitializeAcl failed: 0x%lx\n", GetLastError());
        return(GetLastError());
    }

    if(AddAccessAllowedAce(pAcl, ACL_REVISION, 0x10000000, &EveryoneSid) != TRUE)
    {
        dwErr = GetLastError();
    }
    else
    {
        if(AddAccessAllowedAce(pAcl, ACL_REVISION, 0x1f01ff, &EveryoneSid) != TRUE)
        {
            dwErr = GetLastError();
        }
    }

    if(dwErr != ERROR_SUCCESS)
    {
        printf("Failed to add acls: %lu\n", dwErr);
    }
    else
    {
        ACCESS_RIGHTS   Rights;
        TRUSTEE Trustee;

        BuildTrusteeWithName( &Trustee, L"S-1-1-0" );

        //
        // Go ahead and get the effect access, and make sure it isn't NULL
        //
        dwErr = GetEffectiveRightsFromAcl( pAcl, &Trustee, &Rights );

        if ( dwErr != ERROR_SUCCESS ) {

            printf( "GetEffectiveRightsFromAcl failed with %lu\n", dwErr );

        } else {

            printf( "got 0x%lx\n", Rights );
        }
    }


    return(dwErr);
}




DWORD
DoGetEffectiveTest3 (
    IN  PWSTR           pwszPath,
    IN  PWSTR           pwszUser
    )
/*++

Routine Description:

    Builds a security descriptor

Arguments:

    pwszPath --  Root path
    pwszUser -- User to add

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD                   dwErr = ERROR_SUCCESS;
    BYTE                    Buffer[100];
    PACL                    pAcl = (PACL)Buffer;
    static SID_IDENTIFIER_AUTHORITY UaspBuiltinAuthority = SECURITY_NT_AUTHORITY;
    DWORD BuiltSid[sizeof(SID)/sizeof(DWORD) + 2 ];
    PSID pSid = (PSID)BuiltSid;

    printf("GetEffectiveRightsFromAcl test 3\n");

    RtlInitializeSid( pSid, &UaspBuiltinAuthority, 2 );

    *(RtlSubAuthoritySid(pSid, 0)) = SECURITY_BUILTIN_DOMAIN_RID;
    *(RtlSubAuthoritySid(pSid, 1)) = DOMAIN_ALIAS_RID_ADMINS;

    if(InitializeAcl(pAcl, 100, ACL_REVISION) == FALSE)
    {
        printf("InitializeAcl failed: 0x%lx\n", GetLastError());
        return(GetLastError());
    }

    if(AddAccessAllowedAce(pAcl, ACL_REVISION, 0x1f01ff, pSid) != TRUE)
    {
        dwErr = GetLastError();
    }

    if(dwErr != ERROR_SUCCESS)
    {
        printf("Failed to add acls: %lu\n", dwErr);
    }
    else
    {
        ACCESS_RIGHTS   Rights;
        TRUSTEE Trustee;

        BuildTrusteeWithName( &Trustee, L"S-1-1-0" );

        //
        // Go ahead and get the effect access, and make sure it isn't NULL
        //
        dwErr = GetEffectiveRightsFromAcl( pAcl, &Trustee, &Rights );

        if ( dwErr != ERROR_SUCCESS ) {

            printf( "GetEffectiveRightsFromAcl failed with %lu\n", dwErr );

        } else {

            printf( "got 0x%lx\n", Rights );
        }
    }

    return(dwErr);
}




DWORD
DoGetAudTest (
    IN  PWSTR           pwszPath,
    IN  PWSTR           pwszUser
    )
/*++

Routine Description:



Arguments:

    pwszPath --  Root path
    pwszUser -- User to add

Return Value:

    ERROR_SUCCESS --  Success

--*/
{
    DWORD       dwErr = ERROR_SUCCESS;
    ACCESS_MASK Success, Failure;
    TRUSTEE     Trustee;
    BuildTrusteeWithName(&Trustee, pwszUser);

    printf("GetAuditedPermissionsFromAcl on NULL SACL\n");

    dwErr = GetAuditedPermissionsFromAcl(NULL, &Trustee, &Success, &Failure);

    if ( dwErr != ERROR_SUCCESS ) {

        printf( "GetAuditedPermissionsFromAcl failed with %lu\n", dwErr );

    } else {

        if (Success == 0 && Failure == 0 ) {

            printf("Success\n");

        } else {

            printf( "Got Success: %lu, Failure: %lu\n", Success, Failure );

        }
    }

    return(dwErr);
}




__cdecl main (
    IN  INT argc,
    IN  CHAR *argv[])
/*++

Routine Description:

    The main

Arguments:

    argc --  Count of arguments
    argv --  List of arguments

Return Value:

    0     --  Success
    non-0 --  Failure

--*/
{

    DWORD           dwErr = ERROR_SUCCESS, dwErr2;
    WCHAR           wszPath[MAX_PATH + 1];
    WCHAR           wszUser[MAX_PATH + 1];
    ULONG           Tests = 0;
    DWORD           SeInfo = 0xFFFFFFFF;
    INT             i;

    srand((ULONG)(GetTickCount() * GetCurrentThreadId()));

    if(argc < 4) {

        Usage( argv[0] );
        exit( 1 );
    }

    mbstowcs(wszPath, argv[1], strlen(argv[1]) + 1);
    mbstowcs(wszUser, argv[2], strlen(argv[2]) + 1);
    SeInfo = atol(argv[3]);
    if ( SeInfo == 0xFFFFFFFF ) {

        Usage( argv[0] );
        exit( 1 );
    }

    //
    // process the command line
    //
    for( i = 4; i < argc; i++ ) {

        if ( _stricmp( argv[i],"/CONVERT") == 0 ) {

            Tests |= MTEST_CONVERT;

        } else if ( _stricmp( argv[i],"/GETOWNER") == 0 ) {

            Tests |= MTEST_GETOWNER;

        } else if ( _stricmp( argv[i],"/GETSACL") == 0 ) {

            Tests |= MTEST_GETSACL;

        } else if ( _stricmp( argv[i],"/BUILDSD") == 0 ) {

            Tests |= MTEST_BUILDSD;

        } else if ( _stricmp( argv[i],"/BUILDSD2") == 0 ) {

            Tests |= MTEST_BUILDSD2;

        } else if ( _stricmp( argv[i],"/GETEXPL") == 0 ) {

            Tests |= MTEST_GETEXPL;

        } else if ( _stricmp( argv[i],"/GETEFF") == 0 ) {

            Tests |= MTEST_GETEFF;

        } else if ( _stricmp( argv[i],"/GETEFF2") == 0 ) {

            Tests |= MTEST_GETEFF2;

        } else if ( _stricmp( argv[i],"/GETEFF3") == 0 ) {

            Tests |= MTEST_GETEFF3;

        } else if ( _stricmp( argv[i],"/GETAUD") == 0 ) {

            Tests |= MTEST_GETAUD;

        } else {

            Usage( argv[0] );
            exit( 1 );
            break;
        }
    }

    if(Tests == 0) {

        Tests = MTEST_CONVERT       |
                    MTEST_GETOWNER  |
                    MTEST_GETSACL   |
                    MTEST_BUILDSD   |
                    MTEST_BUILDSD2  |
                    MTEST_GETEXPL   |
                    MTEST_GETEFF    |
                    MTEST_GETEFF2   |
                    MTEST_GETEFF3   |
                    MTEST_GETAUD;
    }


    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, MTEST_CONVERT)) {

        dwErr = DoConvertSecurityDescriptorToAccessNamedTest(wszPath, SeInfo);
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, MTEST_GETOWNER)) {

        dwErr = DoGetOwnerTest(wszPath, SeInfo);
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, MTEST_GETSACL)) {

        dwErr = DoGetSaclTest(wszPath, SeInfo);
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, MTEST_BUILDSD)) {

        dwErr = DoBuildSDTest(wszPath, wszUser);
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, MTEST_BUILDSD2)) {

        dwErr = DoBuildSD2Test(wszPath, wszUser);
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, MTEST_GETEXPL)) {

        dwErr = DoGetExplicitTest(wszPath, SeInfo);
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, MTEST_GETEFF)) {

        dwErr = DoGetEffectiveTest(wszPath, wszUser);
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, MTEST_GETEFF2)) {

        dwErr = DoGetEffectiveTest2(wszPath, wszUser);
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, MTEST_GETEFF3)) {

        dwErr = DoGetEffectiveTest3(wszPath, wszUser);
    }

    if(dwErr == ERROR_SUCCESS && FLAG_ON(Tests, MTEST_GETAUD)) {

        dwErr = DoGetAudTest(wszPath, wszUser);
    }

    printf( "%s\n", dwErr == ERROR_SUCCESS ?
                                     "success" :
                                     "failed" );
    return( dwErr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atlmfc\atlbase.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#ifndef __ATLBASE_H__
#define __ATLBASE_H__

#pragma once

#ifdef _ATL_ALL_WARNINGS
#pragma warning( push )
#endif

#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4097) // typedef name used as synonym for class-name
#pragma warning(disable: 4786) // identifier was truncated in the debug information
#pragma warning(disable: 4291) // allow placement new
#pragma warning(disable: 4201) // nameless unions are part of C++
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4268) // const static/global data initialized to zeros

#pragma warning (push)

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atldef.h>
#ifndef _WINSOCKAPI_
#include <winsock2.h>
#endif
#include <windows.h>
#include <winnls.h>
#include <ole2.h>
#include <oleauto.h>

#include <comcat.h>
#include <stddef.h>
#include <winsvc.h>

#include <tchar.h>
#include <malloc.h>
#include <limits.h>
#include <errno.h>

//REVIEW: Lame definition of InterlockedExchangePointer in system headers
#ifdef _M_IX86
#undef InterlockedExchangePointer
inline void* InterlockedExchangePointer(void** pp, void* pNew) throw()
{
	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );
}
#endif

#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
        #include <crtdbg.h>
#endif

#include <olectl.h>
#include <winreg.h>
#include <atliface.h>

#include <errno.h>
#include <process.h>    // for _beginthreadex, _endthreadex

#ifdef _DEBUG
#include <stdio.h>
#include <stdarg.h>
#endif

#include <atlconv.h>

#include <shlwapi.h>

#include <atlsimpcoll.h>

#pragma pack(push, _ATL_PACKING)

#ifndef _ATL_NO_DEFAULT_LIBS

#ifdef _DEBUG
#pragma comment(lib, "atlsd.lib")
#else
#pragma comment(lib, "atls.lib")
#endif
#endif  // !_ATL_NO_DEFAULT_LIBS

// {394C3DE0-3C6F-11d2-817B-00C04F797AB7}
_declspec(selectany) GUID GUID_ATLVer70 = { 0x394c3de0, 0x3c6f, 0x11d2, { 0x81, 0x7b, 0x0, 0xc0, 0x4f, 0x79, 0x7a, 0xb7 } };


namespace ATL
{

struct _ATL_CATMAP_ENTRY
{
   int iType;
   const CATID* pcatid;
};

#define _ATL_CATMAP_ENTRY_END 0
#define _ATL_CATMAP_ENTRY_IMPLEMENTED 1
#define _ATL_CATMAP_ENTRY_REQUIRED 2


typedef HRESULT (WINAPI _ATL_CREATORFUNC)(void* pv, REFIID riid, LPVOID* ppv);
typedef HRESULT (WINAPI _ATL_CREATORARGFUNC)(void* pv, REFIID riid, LPVOID* ppv, DWORD_PTR dw);
typedef HRESULT (WINAPI _ATL_MODULEFUNC)(DWORD_PTR dw);
typedef LPCTSTR (WINAPI _ATL_DESCRIPTIONFUNC)();
typedef const struct _ATL_CATMAP_ENTRY* (_ATL_CATMAPFUNC)();
typedef void (__stdcall _ATL_TERMFUNC)(DWORD_PTR dw);

// perfmon registration/unregistration function definitions
typedef HRESULT (*_ATL_PERFREGFUNC)(HINSTANCE hDllInstance);
typedef HRESULT (*_ATL_PERFUNREGFUNC)();
__declspec(selectany) _ATL_PERFREGFUNC _pPerfRegFunc = NULL;
__declspec(selectany) _ATL_PERFUNREGFUNC _pPerfUnRegFunc = NULL;

struct _ATL_TERMFUNC_ELEM
{
	_ATL_TERMFUNC* pFunc;
	DWORD_PTR dw;
	_ATL_TERMFUNC_ELEM* pNext;
};


// Can't inherit from _ATL_OBJMAP_ENTRY20 
// because it messes up the OBJECT_MAP macros
struct _ATL_OBJMAP_ENTRY30 
{
	const CLSID* pclsid;
	HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
	_ATL_CREATORFUNC* pfnGetClassObject;
	_ATL_CREATORFUNC* pfnCreateInstance;
	IUnknown* pCF;
	DWORD dwRegister;
        _ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
	_ATL_CATMAPFUNC* pfnGetCategoryMap;

// Added in ATL 3.0
	void (WINAPI *pfnObjectMain)(bool bStarting);
};

typedef _ATL_OBJMAP_ENTRY30 _ATL_OBJMAP_ENTRY;

#if defined(_M_IA64) || defined(_M_IX86)

#pragma data_seg(push)
#pragma data_seg("ATL$__a")
__declspec(selectany) _ATL_OBJMAP_ENTRY* __pobjMapEntryFirst = NULL;
#pragma data_seg("ATL$__z")
__declspec(selectany) _ATL_OBJMAP_ENTRY* __pobjMapEntryLast = NULL;
#pragma data_seg("ATL$__m")
#if !defined(_M_IA64)
#pragma comment(linker, "/merge:ATL=.data")
#endif
#pragma data_seg(pop)

#else

//REVIEW: data_seg(push/pop)?
__declspec(selectany) _ATL_OBJMAP_ENTRY* __pobjMapEntryFirst = NULL;
__declspec(selectany) _ATL_OBJMAP_ENTRY* __pobjMapEntryLast = NULL;

#endif  // defined(_M_IA64) || defined(_M_IX86)

struct _ATL_REGMAP_ENTRY
{
	LPCOLESTR     szKey;
	LPCOLESTR     szData;
};


/////////////////////////////////////////////////////////////////////////////
// Threading Model Support

class CComCriticalSection
{
public:
	CComCriticalSection() throw()
	{
		memset(&m_sec, 0, sizeof(CRITICAL_SECTION));
	}
	HRESULT Lock() throw()
	{
		EnterCriticalSection(&m_sec);
		return S_OK;
	}
	HRESULT Unlock() throw()
	{
		LeaveCriticalSection(&m_sec);
		return S_OK;
	}
	HRESULT Init() throw()
	{
		HRESULT hRes = S_OK;
		__try
		{
			InitializeCriticalSection(&m_sec);
		}
		// structured exception may be raised in low memory situations
		__except(EXCEPTION_EXECUTE_HANDLER)
		{
			if (STATUS_NO_MEMORY == GetExceptionCode())
				hRes = E_OUTOFMEMORY;
			else
				hRes = E_FAIL;
		}
		return hRes;
	}

	HRESULT Term() throw()
	{
		DeleteCriticalSection(&m_sec);
		return S_OK;
	}	
	CRITICAL_SECTION m_sec;
};

// Module 

// Used by any project that uses ATL
struct _ATL_BASE_MODULE70
{
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
	DWORD dwAtlBuildVer;
	GUID* pguidVer;
	CComCriticalSection m_csResource;
};
typedef _ATL_BASE_MODULE70 _ATL_BASE_MODULE;


// Used by COM related code in ATL
struct _ATL_COM_MODULE70
{
	UINT cbSize;
	HINSTANCE m_hInstTypeLib;
	_ATL_OBJMAP_ENTRY** m_ppAutoObjMapFirst;
	_ATL_OBJMAP_ENTRY** m_ppAutoObjMapLast;
	CComCriticalSection m_csObjMap;
};
typedef _ATL_COM_MODULE70 _ATL_COM_MODULE;


// Used by Windowing code in ATL
struct _ATL_WIN_MODULE70
{
	UINT cbSize;
	CComCriticalSection m_csWindowCreate;
	ATOM m_rgWindowClassAtoms[128];
	int m_nAtomIndex;
};
typedef _ATL_WIN_MODULE70 _ATL_WIN_MODULE;

struct _ATL_MODULE70
{
	UINT cbSize;
	LONG m_nLockCnt;
	_ATL_TERMFUNC_ELEM* m_pTermFuncs;
	CComCriticalSection m_csStaticDataInitAndTypeInfo;
};

typedef _ATL_MODULE70 _ATL_MODULE;

/////////////////////////////////////////////////////////////////////////////
//This define makes debugging asserts easier.
#define _ATL_SIMPLEMAPENTRY ((ATL::_ATL_CREATORARGFUNC*)1)

struct _ATL_INTMAP_ENTRY
{
	const IID* piid;       // the interface id (IID)
	DWORD_PTR dw;
	_ATL_CREATORARGFUNC* pFunc; //NULL:end, 1:offset, n:ptr
};


/////////////////////////////////////////////////////////////////////////////
// QI Support

ATLAPI AtlInternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject);

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp);
ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid);

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc,
	DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes,
	HINSTANCE hInst);

/////////////////////////////////////////////////////////////////////////////
// Module


ATLAPI AtlComModuleGetClassObject(_ATL_COM_MODULE* pComModule, REFCLSID rclsid, REFIID riid, LPVOID* ppv);

ATLAPI AtlComModuleRegisterServer(_ATL_COM_MODULE* pComModule, BOOL bRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlComModuleUnregisterServer(_ATL_COM_MODULE* pComModule, BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL);

ATLAPI AtlRegisterClassCategoriesHelper( REFCLSID clsid, const struct _ATL_CATMAP_ENTRY* pCatMap, BOOL bRegister );

ATLAPI AtlRegisterTypeLib(HINSTANCE hInstTypeLib, LPCOLESTR lpszIndex);
ATLAPI AtlUnRegisterTypeLib(HINSTANCE hInstTypeLib, LPCOLESTR lpszIndex);
ATLAPI AtlLoadTypeLib(HINSTANCE hInstTypeLib, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib);

ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pModule, _ATL_TERMFUNC* pFunc, DWORD_PTR dw);
ATLAPI_(void) AtlCallTermFunc(_ATL_MODULE* pModule);

}; //namespace ATL

/////////////////////////////////////////////////////////////////////////////
// GUID comparison


namespace ATL
{

inline BOOL InlineIsEqualUnknown(REFGUID rguid1)
{
   return (
	  ((PLONG) &rguid1)[0] == 0 &&
	  ((PLONG) &rguid1)[1] == 0 &&
	  ((PLONG) &rguid1)[2] == 0x000000C0 &&
	  ((PLONG) &rguid1)[3] == 0x46000000);
}


};  // namespace ATL

namespace ATL
{

ATL_NOINLINE inline HRESULT AtlHresultFromLastError() throw()
{
	DWORD dwErr = ::GetLastError();
	return HRESULT_FROM_WIN32(dwErr);
}

ATL_NOINLINE inline HRESULT AtlHresultFromWin32(DWORD nError) throw()
{
	return( HRESULT_FROM_WIN32( nError ) );
}

};  // namespace ATL

#include <atlexcept.h>

namespace ATL
{

template <class T>
class _NoAddRefReleaseOnCComPtr : public T
{
        private:
                STDMETHOD_(ULONG, AddRef)()=0;
                STDMETHOD_(ULONG, Release)()=0;
};

template< typename T >
class CAutoVectorPtr
{
public:
	CAutoVectorPtr() throw() :
		m_p( NULL )
	{
	}
	CAutoVectorPtr( CAutoVectorPtr< T >& p ) throw()
	{
		m_p = p.Detach();  // Transfer ownership
	}
	explicit CAutoVectorPtr( T* p ) throw() :
		m_p( p )
	{
	}
	~CAutoVectorPtr() throw()
	{
		Free();
	}

	operator T*() const throw()
	{
		return( m_p );
	}

	CAutoVectorPtr< T >& operator=( CAutoVectorPtr< T >& p ) throw()
	{
		Free();
		Attach( p.Detach() );  // Transfer ownership

		return( *this );
	}

	// Allocate the vector
	bool Allocate( size_t nElements ) throw()
	{
		ATLASSERT( m_p == NULL );
		ATLTRY( m_p = new T[nElements] );
		if( m_p == NULL )
		{
			return( false );
		}

		return( true );
	}
	// Attach to an existing pointer (takes ownership)
	void Attach( T* p ) throw()
	{
		ATLASSERT( m_p == NULL );
		m_p = p;
	}


	// Detach the pointer (releases ownership)
	T* Detach() throw()
	{
		T* p;

		p = m_p;
		m_p = NULL;

		return( p );
	}
	// Delete the vector pointed to, and set the pointer to NULL
	void Free() throw()
	{
		delete[] m_p;
		m_p = NULL;
	}

public:
	T* m_p;
};


//CComPtrBase provides the basis for all other smart pointers
//The other smartpointers add their own constructors and operators
template <class T>
class CComPtrBase
{
protected:
	CComPtrBase() throw()
	{
		p = NULL;
	}
	CComPtrBase(int nNull) throw()
	{
		ATLASSERT(nNull == 0);
		(void)nNull;
		p = NULL;
	}
	CComPtrBase(T* lp) throw()
	{
		p = lp;
		if (p != NULL)
			p->AddRef();
	}
public:
	typedef T _PtrClass;
	~CComPtrBase() throw()
	{
		if (p)
			p->Release();
	}
	operator T*() const throw()
	{
		return p;
	}
	T& operator*() const throw()
	{
		ATLASSERT(p!=NULL);
		return *p;
	}
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	T** operator&() throw()
	{
		ATLASSERT(p==NULL);
		return &p;
	}

        _NoAddRefReleaseOnCComPtr<T>* operator->() const throw()
        {
                ATLASSERT(p!=NULL);
                return (_NoAddRefReleaseOnCComPtr<T>*)p;
        }

	bool operator!() const throw()
	{
		return (p == NULL);
	}
	bool operator<(T* pT) const throw()
	{
		return p < pT;
	}
	bool operator==(T* pT) const throw()
	{
		return p == pT;
	}

	// Release the interface and set to NULL
	void Release() throw()
	{
		T* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	// Compare two objects for equivalence
	bool IsEqualObject(IUnknown* pOther) throw()
	{
		if (p == pOther)
			return true;

		if (p == NULL || pOther == NULL)
			return false; // One is NULL the other is not

		CComPtr<IUnknown> punk1;
		CComPtr<IUnknown> punk2;
		p->QueryInterface(__uuidof(IUnknown), (void**)&punk1);
		pOther->QueryInterface(__uuidof(IUnknown), (void**)&punk2);
		return punk1 == punk2;
	}
	// Attach to an existing interface (does not AddRef)
	void Attach(T* p2) throw()
	{
		if (p)
			p->Release();
		p = p2;
	}
	// Detach the interface (does not Release)
	T* Detach() throw()
	{
		T* pt = p;
		p = NULL;
		return pt;
	}
	HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw()
	{
		ATLASSERT(p == NULL);
		return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
	}
	HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) throw()
	{
		CLSID clsid;
		HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
		ATLASSERT(p == NULL);
		if (SUCCEEDED(hr))
			hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
		return hr;
	}
	template <class Q>
	HRESULT QueryInterface(Q** pp) const throw()
	{
		ATLASSERT(pp != NULL);
		return p->QueryInterface(__uuidof(Q), (void**)pp);
	}
	T* p;
};

template <class T>
class CComPtr : public CComPtrBase<T>
{
public:
	CComPtr() throw()
	{
	}

	CComPtr(int nNull) throw() :
		CComPtrBase<T>(nNull)
	{
	}

	CComPtr(T* lp) throw() :
		CComPtrBase<T>(lp)
	{
	}

	CComPtr(const CComPtr<T>& lp) throw() :
		CComPtrBase<T>(lp.p)
	{
	}

	template <typename Q>
	T* operator=(const CComPtr<Q>& lp) throw()
	{
		return static_cast<T*>(AtlComQIPtrAssign((IUnknown**)&p, lp, __uuidof(T)));
	}
};


template <class T, const IID* piid = &__uuidof(T)>
class CComQIPtr : public CComPtr<T>
{
public:
	CComQIPtr() throw()
	{
	}
	CComQIPtr(T* lp) throw() :
		CComPtr<T>(lp)
	{
	}
	CComQIPtr(const CComQIPtr<T,piid>& lp) throw() :
		CComPtr<T>(lp.p)
	{
	}
	CComQIPtr(IUnknown* lp) throw()
	{
		if (lp != NULL)
			lp->QueryInterface(*piid, (void **)&p);
	}
	T* operator=(T* lp) throw()
	{
		return static_cast<T*>(AtlComPtrAssign((IUnknown**)&p, lp));
	}
	T* operator=(const CComQIPtr<T,piid>& lp) throw()
	{
		return static_cast<T*>(AtlComPtrAssign((IUnknown**)&p, lp.p));
	}
	T* operator=(IUnknown* lp) throw()
	{
		return static_cast<T*>(AtlComQIPtrAssign((IUnknown**)&p, lp, *piid));
	}
};

//Specialization to make it work
template<>
class CComQIPtr<IUnknown, &IID_IUnknown> : public CComPtr<IUnknown>
{
public:
	CComQIPtr() throw()
	{
	}
	CComQIPtr(IUnknown* lp) throw()
	{
		//Actually do a QI to get identity
		if (lp != NULL)
			lp->QueryInterface(__uuidof(IUnknown), (void **)&p);
	}
	CComQIPtr(const CComQIPtr<IUnknown,&IID_IUnknown>& lp) throw() :
		CComPtr<IUnknown>(lp.p)
	{
	}
	IUnknown* operator=(IUnknown* lp) throw()
	{
		//Actually do a QI to get identity
		return AtlComQIPtrAssign((IUnknown**)&p, lp, __uuidof(IUnknown));
	}
	IUnknown* operator=(const CComQIPtr<IUnknown,&IID_IUnknown>& lp) throw()
	{
		return AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
};

/////////////////////////////////////////////////////////////////////////////
// Threading Model Support

class CComAutoCriticalSection : public CComCriticalSection
{
public:
	CComAutoCriticalSection()
	{
		HRESULT hr = CComCriticalSection::Init();
		if (FAILED(hr))
			AtlThrow(hr);
	}
	~CComAutoCriticalSection() throw()
	{
		CComCriticalSection::Term();
	}
private :
	HRESULT Init();	// Not implemented. CComAutoCriticalSection::Init should never be called
	HRESULT Term(); // Not implemented. CComAutoCriticalSection::Term should never be called
};

class CComFakeCriticalSection
{
public:
	HRESULT Lock() throw() { return S_OK; }
	HRESULT Unlock() throw() { return S_OK; }
	HRESULT Init() throw() { return S_OK; }
	HRESULT Term() throw() { return S_OK; }
};

template< class TLock >
class CComCritSecLock
{
public:
	CComCritSecLock( TLock& cs, bool bInitialLock = true );
	~CComCritSecLock() throw();

	HRESULT Lock() throw();
	void Unlock() throw();

// Implementation
private:
	TLock& m_cs;
	bool m_bLocked;

// Private to avoid accidental use
	CComCritSecLock( const CComCritSecLock& ) throw();
	CComCritSecLock& operator=( const CComCritSecLock& ) throw();
};

template< class TLock >
inline CComCritSecLock< TLock >::CComCritSecLock( TLock& cs, bool bInitialLock ) :
	m_cs( cs ),
	m_bLocked( false )
{
	if( bInitialLock )
	{
		HRESULT hr;

		hr = Lock();
		if( FAILED( hr ) )
		{
			AtlThrow( hr );
		}
	}
}

template< class TLock >
inline CComCritSecLock< TLock >::~CComCritSecLock() throw()
{
	if( m_bLocked )
	{
		Unlock();
	}
}

template< class TLock >
inline HRESULT CComCritSecLock< TLock >::Lock() throw()
{
	HRESULT hr;

	ATLASSERT( !m_bLocked );
	hr = m_cs.Lock();
	if( FAILED( hr ) )
	{
		return( hr );
	}
	m_bLocked = true;

	return( S_OK );
}

template< class TLock >
inline void CComCritSecLock< TLock >::Unlock() throw()
{
	ATLASSERT( m_bLocked );
	m_cs.Unlock();
	m_bLocked = false;
}

class CComMultiThreadModelNoCS
{
public:
	static ULONG WINAPI Increment(LPLONG p) throw() {return InterlockedIncrement(p);}
	static ULONG WINAPI Decrement(LPLONG p) throw() {return InterlockedDecrement(p);}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
	typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComMultiThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) throw() {return InterlockedIncrement(p);}
	static ULONG WINAPI Decrement(LPLONG p) throw() {return InterlockedDecrement(p);}
	typedef CComAutoCriticalSection AutoCriticalSection;
	typedef CComCriticalSection CriticalSection;
	typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComSingleThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) throw() {return ++(*p);}
	static ULONG WINAPI Decrement(LPLONG p) throw() {return --(*p);}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
	typedef CComSingleThreadModel ThreadModelNoCS;
};

#if defined(_ATL_APARTMENT_THREADED)

#if defined(_ATL_SINGLE_THREADED) || defined(_ATL_FREE_THREADED)
#pragma message ("More than one global threading model defined.")
#endif

	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;

#elif defined(_ATL_FREE_THREADED)

#if defined(_ATL_SINGLE_THREADED) || defined(_ATL_APARTMENT_THREADED)
#pragma message ("More than one global threading model defined.")
#endif

	typedef CComMultiThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;

#else
#pragma message ("No global threading model defined")
#endif

};  // namespace ATL

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Dual argument helper classes

#define UpdateRegistryFromResource UpdateRegistryFromResourceS

#ifndef _delayimp_h
extern "C" IMAGE_DOS_HEADER __ImageBase;
#endif

class CAtlBaseModule : public _ATL_BASE_MODULE
{
public :
	static bool m_bInitFailed;
	CAtlBaseModule() throw()
	{
		cbSize = sizeof(_ATL_BASE_MODULE);

		m_hInst = m_hInstResource = reinterpret_cast<HINSTANCE>(&__ImageBase);

		dwAtlBuildVer = _ATL_VER;
		pguidVer = &GUID_ATLVer70;

		if (FAILED(m_csResource.Init()))
		{
			ATLASSERT(0);
			CAtlBaseModule::m_bInitFailed = true;
		}
	}

	~CAtlBaseModule() throw ()
	{
	}

	HINSTANCE GetModuleInstance() throw()
	{
		return m_hInst;
	}
	HINSTANCE GetResourceInstance() throw()
	{
		return m_hInstResource;
	}
};

__declspec(selectany) bool CAtlBaseModule::m_bInitFailed = false;
extern CAtlBaseModule _AtlBaseModule;

class CAtlComModule : public _ATL_COM_MODULE
{
public:

	CAtlComModule() throw()
	{
		cbSize = sizeof(_ATL_COM_MODULE);

		m_hInstTypeLib = reinterpret_cast<HINSTANCE>(&__ImageBase);

		m_ppAutoObjMapFirst = &__pobjMapEntryFirst + 1;
		m_ppAutoObjMapLast = &__pobjMapEntryLast;

		if (FAILED(m_csObjMap.Init()))
		{
			ATLASSERT(0);
			CAtlBaseModule::m_bInitFailed = true;
		}
	}

	~CAtlComModule()
	{
		Term();
	}

	// Called from ~CAtlComModule or from ~CAtlExeModule.
	void Term()
	{
		if (cbSize == 0)
			return;

		for (_ATL_OBJMAP_ENTRY** ppEntry = m_ppAutoObjMapFirst; ppEntry < m_ppAutoObjMapLast; ppEntry++)
		{
			if (*ppEntry != NULL)
			{
				_ATL_OBJMAP_ENTRY* pEntry = *ppEntry;
				if (pEntry->pCF != NULL)
					pEntry->pCF->Release();
				pEntry->pCF = NULL;
			}
		}
		// Set to 0 to indicate that this function has been called
		// At this point no one should be concerned about cbsize
		// having the correct value
		cbSize = 0;
	}

	// RegisterServer walks the ATL Autogenerated object map and registers each object in the map
	// If pCLSID is not NULL then only the object referred to by pCLSID is registered (The default case)
	// otherwise all the objects are registered
	HRESULT RegisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL)
	{
		return AtlComModuleRegisterServer(this, bRegTypeLib, pCLSID);
	}

	// UnregisterServer walks the ATL Autogenerated object map and unregisters each object in the map
	// If pCLSID is not NULL then only the object referred to by pCLSID is unregistered (The default case)
	// otherwise all the objects are unregistered.
	HRESULT UnregisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL)
	{
		return AtlComModuleUnregisterServer(this, bRegTypeLib, pCLSID);
	}
};

class CAtlModule;
__declspec(selectany) CAtlModule* _pAtlModule = NULL;

class CRegObject;

class ATL_NO_VTABLE CAtlModule : public _ATL_MODULE
{
public :
	static GUID m_libid;
	IGlobalInterfaceTable* m_pGIT;

	CAtlModule() throw()
	{
		// Should have only one instance of a class 
		// derived from CAtlModule in a project.
		ATLASSERT(_pAtlModule == NULL);
		cbSize = sizeof(_ATL_MODULE);
		m_pTermFuncs = NULL;

		m_nLockCnt = 0;
		_pAtlModule = this;
		if (FAILED(m_csStaticDataInitAndTypeInfo.Init()))
		{
			ATLASSERT(0);
			CAtlBaseModule::m_bInitFailed = true;
		}

		m_pGIT = NULL;
	}

	void Term() throw()
	{
		// cbSize == 0 indicates that Term has already been called
		if (cbSize == 0)
			return;

		// Call term functions
		if (m_pTermFuncs != NULL)
		{
			AtlCallTermFunc(this);
			m_pTermFuncs = NULL;
		}

		if (m_pGIT != NULL)
			m_pGIT->Release();

		cbSize = 0;
	}

	~CAtlModule() throw()
	{
		Term();
	}

	virtual LONG Lock() throw()
	{
		return CComGlobalsThreadModel::Increment(&m_nLockCnt);
	}

	virtual LONG Unlock() throw()
	{
		return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
	}
	
	virtual LONG GetLockCount() throw()
	{
		return m_nLockCnt;
	}

	HRESULT AddTermFunc(_ATL_TERMFUNC* pFunc, DWORD_PTR dw) throw()
	{
		return AtlModuleAddTermFunc(this, pFunc, dw);
	}

	virtual HRESULT AddCommonRGSReplacements(IRegistrarBase* /*pRegistrar*/) throw()
	{
		return S_OK;
	}


	// Statically linking to Registry component
	HRESULT WINAPI UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw();
	HRESULT WINAPI UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw();

	// Implementation

	static void EscapeSingleQuote(LPOLESTR lpDest, LPCOLESTR lp) throw()
	{
		while (*lp)
		{
			*lpDest++ = *lp;
			if (*lp == '\'')
				*lpDest++ = *lp;
			lp++;
		}
		*lpDest = NULL;
	}
};

__declspec(selectany) GUID CAtlModule::m_libid = {0x0, 0x0, 0x0, {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0} };

template <class T>
class ATL_NO_VTABLE CAtlModuleT : public CAtlModule
{
public :
	CAtlModuleT() throw()
	{
		T::InitLibId();
	}

	static void InitLibId() throw()
	{
	}

	HRESULT RegisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL) throw();
	HRESULT UnregisterServer(BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL) throw();
};


class CComModule;
__declspec(selectany) CComModule* _pModule = NULL;
class CComModule : public CAtlModuleT<CComModule>
{
public :

	CComModule()
	{
		// Should have only one instance of a class 
		// derived from CComModule in a project.
		ATLASSERT(_pModule == NULL);
		_pModule = this;
	}

	HINSTANCE m_hInst;
	HINSTANCE m_hInstTypeLib;

	// For Backward compatibility
	_ATL_OBJMAP_ENTRY* m_pObjMap;

	HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL) throw();
	void Term() throw();

	HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) throw();
	// Registry support (helpers)
	HRESULT RegisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL) throw();
	HRESULT UnregisterServer(BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL) throw();
	HRESULT UnregisterServer(const CLSID* pCLSID = NULL) throw();

	// Statically linking to Registry Ponent
	virtual HRESULT WINAPI UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
	{
		return CAtlModuleT<CComModule>::UpdateRegistryFromResourceS(lpszRes, bRegister, pMapEntries);
	}
	virtual HRESULT WINAPI UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL) throw()
	{
		return CAtlModuleT<CComModule>::UpdateRegistryFromResourceS(nResID, bRegister, pMapEntries);
	}

};

#define ATL_VARIANT_TRUE VARIANT_BOOL( -1 )
#define ATL_VARIANT_FALSE VARIANT_BOOL( 0 )

/////////////////////////////////////////////////////////////////////////////
// CComBSTR

class CComBSTR
{
public:
	BSTR m_str;
	CComBSTR() throw()
	{
		m_str = NULL;
	}
	CComBSTR(int nSize)
	{
		if (nSize == 0)
			m_str = NULL;
		else
		{
			m_str = ::SysAllocStringLen(NULL, nSize);
			if (m_str == NULL)
				AtlThrow(E_OUTOFMEMORY);
		}
	}
	CComBSTR(LPCOLESTR pSrc)
	{
		if (pSrc == NULL)
			m_str = NULL;
		else
		{
			m_str = ::SysAllocString(pSrc);
			if (m_str == NULL)
				AtlThrow(E_OUTOFMEMORY);
		}
	}

	CComBSTR(const CComBSTR& src)
	{
		m_str = src.Copy();
		if (!!src && m_str == NULL)
			AtlThrow(E_OUTOFMEMORY);

	}
	CComBSTR& operator=(const CComBSTR& src)
	{
		if (m_str != src.m_str)
		{
			::SysFreeString(m_str);
			m_str = src.Copy();
			if (!!src && m_str == NULL)
				AtlThrow(E_OUTOFMEMORY);
		}
		return *this;
	}

	CComBSTR& operator=(LPCOLESTR pSrc)
	{
		::SysFreeString(m_str);
		if (pSrc != NULL)
		{
			m_str = ::SysAllocString(pSrc);
			if (m_str == NULL)
				AtlThrow(E_OUTOFMEMORY);
		}
		else
			m_str = NULL;
		return *this;
	}
 
	~CComBSTR() throw()
	{
		::SysFreeString(m_str);
	}
	unsigned int Length() const throw()
	{
		return (m_str == NULL)? 0 : SysStringLen(m_str);
	}
	unsigned int ByteLength() const throw()
	{
		return (m_str == NULL)? 0 : SysStringByteLen(m_str);
	}
	operator BSTR() const throw()
	{
		return m_str;
	}
	BSTR* operator&() throw()
	{
		return &m_str;
	}
	BSTR Copy() const throw()
	{
		if (m_str == NULL)
			return NULL;
		return ::SysAllocStringByteLen((char*)m_str, ::SysStringByteLen(m_str));
	}
	void Attach(BSTR src) throw()
	{
		::SysFreeString(m_str);
		m_str = src;
	}
	BSTR Detach() throw()
	{
		BSTR s = m_str;
		m_str = NULL;
		return s;
	}
	void Empty() throw()
	{
		::SysFreeString(m_str);
		m_str = NULL;
	}
	bool operator!() const throw()
	{
		return (m_str == NULL);
	}

	HRESULT Append(LPCOLESTR lpsz) throw()
	{
		return Append(lpsz, UINT(lstrlenW(lpsz)));
	}

	// a BSTR is just a LPCOLESTR so we need a special version to signify
	// that we are appending a BSTR
	HRESULT AppendBSTR(BSTR p) throw()
	{
		if (p == NULL)
			return S_OK;
		BSTR bstrNew = NULL;
		HRESULT hr;
		hr = VarBstrCat(m_str, p, &bstrNew);
		if (SUCCEEDED(hr))
		{
			::SysFreeString(m_str);
			m_str = bstrNew;
		}
		return hr;
	}
	HRESULT Append(LPCOLESTR lpsz, int nLen) throw()
	{
		if (lpsz == NULL || (m_str != NULL && nLen == 0))
			return S_OK;
		int n1 = Length();
		BSTR b;
		b = ::SysAllocStringLen(NULL, n1+nLen);
		if (b == NULL)
			return E_OUTOFMEMORY;
		memcpy(b, m_str, n1*sizeof(OLECHAR));
		memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR));
		b[n1+nLen] = NULL;
		SysFreeString(m_str);
		m_str = b;
		return S_OK;
	}

	CComBSTR& operator+=(LPCOLESTR pszSrc)
	{
		HRESULT hr;
		hr = Append(pszSrc);
		if (FAILED(hr))
			AtlThrow(hr);
		return *this;
	}
	
	bool operator<(const CComBSTR& bstrSrc) const throw()
	{
		return VarBstrCmp(m_str, bstrSrc.m_str, LOCALE_USER_DEFAULT, 0) == VARCMP_LT;
	}
	bool operator<(LPCOLESTR pszSrc) const
	{
		CComBSTR bstr2(pszSrc);
		return operator<(bstr2);
	}
	bool operator>(const CComBSTR& bstrSrc) const throw()
	{
		return VarBstrCmp(m_str, bstrSrc.m_str, LOCALE_USER_DEFAULT, 0) == VARCMP_GT;
	}
	bool operator>(LPCOLESTR pszSrc) const
	{
		CComBSTR bstr2(pszSrc);
		return operator>(bstr2);
	}
	bool operator==(const CComBSTR& bstrSrc) const throw()
	{
		return VarBstrCmp(m_str, bstrSrc.m_str, LOCALE_USER_DEFAULT, 0) == VARCMP_EQ;
	}
	bool operator==(LPCOLESTR pszSrc) const
	{
		CComBSTR bstr2(pszSrc);
		return operator==(bstr2);
	}
};


/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
// Constructors
public:
	CComVariant() throw()
	{
		::VariantInit(this);
	}
	~CComVariant() throw()
	{
		Clear();
	}

	CComVariant(LPCOLESTR lpszSrc)
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}

// Assignment Operators
public:

	CComVariant& operator=(const VARIANT& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}

	CComVariant& operator=(LPCOLESTR lpszSrc)
	{
		Clear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(lpszSrc);

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}

	CComVariant& operator=(long nSrc) throw()
	{
		if (vt != VT_I4)
		{
			Clear();
			vt = VT_I4;
		}
		lVal = nSrc;
		return *this;
	}

	CComVariant& operator=(unsigned long nSrc) throw()
	{
		if (vt != VT_UI4)
		{
			Clear();
			vt = VT_UI4;
		}
		ulVal = nSrc;
		return *this;
	}


// Operations
public:
	HRESULT Clear() { return ::VariantClear(this); }
	HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); }

	HRESULT Detach(VARIANT* pDest)
	{
		ATLASSERT(pDest != NULL);
		// Clear out the variant
		HRESULT hr = ::VariantClear(pDest);
		if (!FAILED(hr))
		{
			// Copy the contents and remove control from CComVariant
			memcpy(pDest, this, sizeof(VARIANT));
			vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

// Implementation
private:

	void InternalCopy(const VARIANT* pSrc)
	{
		HRESULT hr = Copy(pSrc);
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
		}
	}
};


/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
	CRegKey() throw();
	~CRegKey() throw();

// Attributes
public:
	operator HKEY() const throw();
	HKEY m_hKey;

// Operations
public:
	LONG SetValue(LPCTSTR pszValueName, DWORD dwType, const void* pValue, ULONG nBytes) throw();
	LONG SetDWORDValue(LPCTSTR pszValueName, DWORD dwValue) throw();
	LONG SetStringValue(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD dwType = REG_SZ) throw();
	LONG SetMultiStringValue(LPCTSTR pszValueName, LPCTSTR pszValue) throw();

	LONG QueryValue(LPCTSTR pszValueName, DWORD* pdwType, void* pData, ULONG* pnBytes) throw();
	LONG QueryDWORDValue(LPCTSTR pszValueName, DWORD& dwValue) throw();
	LONG QueryStringValue(LPCTSTR pszValueName, LPTSTR pszValue, ULONG* pnChars) throw();

	// Create a new registry key (or open an existing one).
	LONG Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPTSTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE,
		REGSAM samDesired = KEY_READ | KEY_WRITE,
		LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
		LPDWORD lpdwDisposition = NULL) throw();

	// Open an existing registry key.
	LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
		REGSAM samDesired = KEY_READ | KEY_WRITE) throw();
	// Close the registry key.
	LONG Close() throw();

	// Detach the CRegKey object from its HKEY.  Releases ownership.
	HKEY Detach() throw();
	// Attach the CRegKey object to an existing HKEY.  Takes ownership.
	void Attach(HKEY hKey) throw();

	LONG DeleteSubKey(LPCTSTR lpszSubKey) throw();
	LONG RecurseDeleteKey(LPCTSTR lpszKey) throw();
	LONG DeleteValue(LPCTSTR lpszValue) throw();
};

inline CRegKey::CRegKey() :
	m_hKey( NULL )
{
}
inline CRegKey::~CRegKey()
{
    Close();
}
inline CRegKey::operator HKEY() const
{
    return m_hKey;
}

inline HKEY CRegKey::Detach()
{
	HKEY hKey = m_hKey;
	m_hKey = NULL;
	return hKey;
}

inline void CRegKey::Attach(HKEY hKey)
{
	ATLASSERT(m_hKey == NULL);
	m_hKey = hKey;
}

inline LONG CRegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
	ATLASSERT(m_hKey != NULL);
	return RegDeleteKey(m_hKey, lpszSubKey);
}

inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue)
{
	ATLASSERT(m_hKey != NULL);
	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}

inline LONG CRegKey::Close()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	return lRes;
}

inline LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	ATLASSERT(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
	}
	return lRes;
}

inline LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	ATLASSERT(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		ATLASSERT(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
	}
	return lRes;
}

inline LONG CRegKey::QueryValue(LPCTSTR pszValueName, DWORD* pdwType, void* pData, ULONG* pnBytes) throw()
{
	ATLASSERT(m_hKey != NULL);

	return( ::RegQueryValueEx(m_hKey, pszValueName, NULL, pdwType, static_cast< LPBYTE >( pData ), pnBytes) );
}

inline LONG CRegKey::QueryDWORDValue(LPCTSTR pszValueName, DWORD& dwValue)
{
	LONG lRes;
	ULONG nBytes;
	DWORD dwType;

	ATLASSERT(m_hKey != NULL);

	nBytes = sizeof(DWORD);
	lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(&dwValue),
		&nBytes);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	if (dwType != REG_DWORD)
		return ERROR_INVALID_DATA;

	return ERROR_SUCCESS;
}

inline LONG CRegKey::QueryStringValue(LPCTSTR pszValueName, LPTSTR pszValue, ULONG* pnChars)
{
	LONG lRes;
	DWORD dwType;
	ULONG nBytes;

	ATLASSERT(m_hKey != NULL);
	ATLASSERT(pnChars != NULL);

	nBytes = (*pnChars)*sizeof(TCHAR);
	*pnChars = 0;
	lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(pszValue),
		&nBytes);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	if (dwType != REG_SZ)
		return ERROR_INVALID_DATA;
	*pnChars = nBytes/sizeof(TCHAR);

	return ERROR_SUCCESS;
}

inline LONG CRegKey::SetValue(LPCTSTR pszValueName, DWORD dwType, const void* pValue, ULONG nBytes) throw()
{
	ATLASSERT(m_hKey != NULL);
	return ::RegSetValueEx(m_hKey, pszValueName, NULL, dwType, static_cast<const BYTE*>(pValue), nBytes);
}

inline LONG CRegKey::SetDWORDValue(LPCTSTR pszValueName, DWORD dwValue)
{
	ATLASSERT(m_hKey != NULL);
	return ::RegSetValueEx(m_hKey, pszValueName, NULL, REG_DWORD, reinterpret_cast<const BYTE*>(&dwValue), sizeof(DWORD));
}

inline LONG CRegKey::SetStringValue(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD dwType)
{
	ATLASSERT(m_hKey != NULL);
	ATLASSERT(pszValue != NULL);
	ATLASSERT((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ));

	return ::RegSetValueEx(m_hKey, pszValueName, NULL, dwType, reinterpret_cast<const BYTE*>(pszValue), (lstrlen(pszValue)+1)*sizeof(TCHAR));
}

inline LONG CRegKey::SetMultiStringValue(LPCTSTR pszValueName, LPCTSTR pszValue)
{
	LPCTSTR pszTemp;
	ULONG nBytes;
	ULONG nLength;

	ATLASSERT(m_hKey != NULL);
	ATLASSERT(pszValue != NULL);

	// Find the total length (in bytes) of all of the strings, including the
	// terminating '\0' of each string, and the second '\0' that terminates
	// the list.
	nBytes = 0;
	pszTemp = pszValue;
	do
	{
		nLength = lstrlen(pszTemp)+1;
		pszTemp += nLength;
		nBytes += nLength*sizeof(TCHAR);
	} while (nLength != 1);

	return ::RegSetValueEx(m_hKey, pszValueName, NULL, REG_MULTI_SZ, reinterpret_cast<const BYTE*>(pszValue),
		nBytes);
}

inline LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
	CRegKey key;
	LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE);
	if (lRes != ERROR_SUCCESS)
	{
		return lRes;
	}
	FILETIME time;
	DWORD dwSize = 256;
	TCHAR szBuffer[256];
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}

#ifdef _ATL_STATIC_REGISTRY
}; //namespace ATL

#include <statreg.h>

namespace ATL
{
// Statically linking to Registry Ponent
inline HRESULT WINAPI CAtlModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries /*= NULL*/) throw()
{
	CRegObject ro;

	if (pMapEntries != NULL)
	{
		while (pMapEntries->szKey != NULL)
		{
			ATLASSERT(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	HRESULT hr = AddCommonRGSReplacements(&ro);
	if (FAILED(hr))
		return hr;

	USES_CONVERSION;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_AtlBaseModule.GetModuleInstance(), szModule, _MAX_PATH);
    szModule[_MAX_PATH - 1] = TEXT('\0');

	LPOLESTR pszModule;
	pszModule = szModule;

	OLECHAR pszModuleQuote[_MAX_PATH * 2];
	EscapeSingleQuote(pszModuleQuote, pszModule);
	ro.AddReplacement(OLESTR("Module"), pszModuleQuote);

	LPCOLESTR szType = OLESTR("REGISTRY");
	hr = (bRegister) ? ro.ResourceRegisterSz(pszModule, lpszRes, szType) :
		ro.ResourceUnregisterSz(pszModule, lpszRes, szType);
	return hr;
}
inline HRESULT WINAPI CAtlModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries /*= NULL*/) throw()
{
	CRegObject ro;

	if (pMapEntries != NULL)
	{
		while (pMapEntries->szKey != NULL)
		{
			ATLASSERT(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	HRESULT hr = AddCommonRGSReplacements(&ro);
	if (FAILED(hr))
		return hr;

	USES_CONVERSION;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_AtlBaseModule.GetModuleInstance(), szModule, _MAX_PATH);
    szModule[_MAX_PATH - 1] = TEXT('\0');

	LPOLESTR pszModule;
	pszModule = szModule;

	OLECHAR pszModuleQuote[_MAX_PATH * 2];
	EscapeSingleQuote(pszModuleQuote, pszModule);
	ro.AddReplacement(OLESTR("Module"), pszModuleQuote);

	LPCOLESTR szType = OLESTR("REGISTRY");
	hr = (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
		ro.ResourceUnregister(pszModule, nResID, szType);
	return hr;
}
#endif //_ATL_STATIC_REGISTRY

#pragma pack(pop)

}; //namespace ATL

#include <atlbase.inl>

#ifndef _ATL_NO_AUTOMATIC_NAMESPACE
using namespace ATL;
#endif //!_ATL_NO_AUTOMATIC_NAMESPACE

//only suck in definition if static linking
#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLBASE_IMPL
#endif
#endif

#ifdef _ATL_ATTRIBUTES
#include <atlplus.h>
#endif

//All exports go here
#ifdef _ATLBASE_IMPL

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName)
{
	ATLASSERT(lpszPathName != NULL);

	// always capture the complete file name including extension (if present)
	LPCOLESTR lpszTemp = lpszPathName;
	for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )
	{
		LPCOLESTR lp = CharNextW(lpsz);
		// remember last directory/drive separator
		if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
			lpszTemp = lp;
		lpsz = lp;
	}

	return UINT( lpszTemp-lpszPathName );
}

/////////////////////////////////////////////////////////////////////////////
// QI support

ATLINLINE ATLAPI AtlInternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
	ATLASSERT(pThis != NULL);
	// First entry in the com map should be a simple map entry
	ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
	if (ppvObject == NULL)
		return E_POINTER;
	*ppvObject = NULL;
	if (InlineIsEqualUnknown(iid)) // use first interface
	{
			IUnknown* pUnk = (IUnknown*)((INT_PTR)pThis+pEntries->dw);
			pUnk->AddRef();
			*ppvObject = pUnk;
			return S_OK;
	}
	while (pEntries->pFunc != NULL)
	{
		BOOL bBlind = (pEntries->piid == NULL);
		if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
		{
			if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset
			{
				ATLASSERT(!bBlind);
				IUnknown* pUnk = (IUnknown*)((INT_PTR)pThis+pEntries->dw);
				pUnk->AddRef();
				*ppvObject = pUnk;
				return S_OK;
			}
			else //actual function call
			{
				HRESULT hRes = pEntries->pFunc(pThis,
					iid, ppvObject, pEntries->dw);
				if (hRes == S_OK || (!bBlind && FAILED(hRes)))
					return hRes;
			}
		}
		pEntries++;
	}
	return E_NOINTERFACE;
}


ATLINLINE ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
	IUnknown* pTemp = *pp;
	*pp = NULL;
	if (lp != NULL)
		lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}


/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLINLINE ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
	USES_CONVERSION;
	TCHAR szDesc[1024];
	szDesc[0] = NULL;
	// For a valid HRESULT the id should be in the range [0x0200, 0xffff]
	if (IS_INTRESOURCE(lpszDesc)) //id
	{
		UINT nID = LOWORD((DWORD_PTR)lpszDesc);
		ATLASSERT((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
		if (LoadString(hInst, nID, szDesc, 1024) == 0)
		{
			ATLASSERT(FALSE);
			lstrcpy(szDesc, _T("Unknown Error"));
		}
		lpszDesc = szDesc;
		if (hRes == 0)
			hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
	}

	CComPtr<ICreateErrorInfo> pICEI;
	if (SUCCEEDED(CreateErrorInfo(&pICEI)))
	{
		CComPtr<IErrorInfo> pErrorInfo;
		pICEI->SetGUID(iid);
		LPOLESTR lpsz;
		ProgIDFromCLSID(clsid, &lpsz);
		if (lpsz != NULL)
			pICEI->SetSource(lpsz);
		if (dwHelpID != 0 && lpszHelpFile != NULL)
		{
			pICEI->SetHelpContext(dwHelpID);
			pICEI->SetHelpFile(const_cast<LPOLESTR>(lpszHelpFile));
		}
		CoTaskMemFree(lpsz);
		pICEI->SetDescription((LPOLESTR)lpszDesc);
		if (SUCCEEDED(pICEI->QueryInterface(__uuidof(IErrorInfo), (void**)&pErrorInfo)))
			SetErrorInfo(0, pErrorInfo);
	}
	return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}

/////////////////////////////////////////////////////////////////////////////
// Module

//Although these functions are big, they are only used once in a module
//so we should make them inline.


ATLINLINE ATLAPI AtlComModuleGetClassObject(_ATL_COM_MODULE* pComModule, REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	ATLASSERT(pComModule != NULL);
	if (pComModule == NULL)
		return E_INVALIDARG;

#ifndef _ATL_OLEDB_CONFORMANCE_TESTS

	ATLASSERT(ppv != NULL);

#endif

	if (ppv == NULL)
		return E_POINTER;
	*ppv = NULL;

	HRESULT hr = S_OK;

	for (_ATL_OBJMAP_ENTRY** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)
	{
		if (*ppEntry != NULL)
		{
			_ATL_OBJMAP_ENTRY* pEntry = *ppEntry;
			if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))
			{
				if (pEntry->pCF == NULL)
				{
					CComCritSecLock<CComCriticalSection> lock(pComModule->m_csObjMap, false);
					hr = lock.Lock();
					if (FAILED(hr))
					{
						ATLASSERT(0);
						break;
					}
					if (pEntry->pCF == NULL)
						hr = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, __uuidof(IUnknown), (LPVOID*)&pEntry->pCF);
				}
				if (pEntry->pCF != NULL)
					hr = pEntry->pCF->QueryInterface(riid, ppv);
				break;
			}
		}
	}

	if (*ppv == NULL && hr == S_OK)
		hr = CLASS_E_CLASSNOTAVAILABLE;
	return hr;
}

ATLINLINE ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pModule, _ATL_TERMFUNC* pFunc, DWORD_PTR dw)
{
	HRESULT hr = S_OK;
	_ATL_TERMFUNC_ELEM* pNew = NULL;
	ATLTRY(pNew = new _ATL_TERMFUNC_ELEM);
	if (pNew == NULL)
		hr = E_OUTOFMEMORY;
	else
	{
		pNew->pFunc = pFunc;
		pNew->dw = dw;
		CComCritSecLock<CComCriticalSection> lock(pModule->m_csStaticDataInitAndTypeInfo, false);
		hr = lock.Lock();
		if (SUCCEEDED(hr))
		{
			pNew->pNext = pModule->m_pTermFuncs;
			pModule->m_pTermFuncs = pNew;
		}
		else
		{
			delete pNew;
			ATLASSERT(0);
		}
	}
	return hr;
}

ATLINLINE ATLAPI_(void) AtlCallTermFunc(_ATL_MODULE* pModule)
{
	_ATL_TERMFUNC_ELEM* pElem = pModule->m_pTermFuncs;
	_ATL_TERMFUNC_ELEM* pNext = NULL;
	while (pElem != NULL)
	{
		pElem->pFunc(pElem->dw);
		pNext = pElem->pNext;
		delete pElem;
		pElem = pNext;
	}
	pModule->m_pTermFuncs = NULL;
}

ATLINLINE ATLAPI AtlRegisterClassCategoriesHelper( REFCLSID clsid,
   const struct _ATL_CATMAP_ENTRY* pCatMap, BOOL bRegister )
{
   CComPtr< ICatRegister > pCatRegister;
   HRESULT hResult;
   const struct _ATL_CATMAP_ENTRY* pEntry;
   CATID catid;

   if( pCatMap == NULL )
   {
	  return( S_OK );
   }

   if (InlineIsEqualGUID(clsid, GUID_NULL))
   {
       ATLASSERT(0 && _T("Use OBJECT_ENTRY_NON_CREATEABLE_EX macro if you want to register class categories for non creatable objects."));
       return S_OK;
   }

   hResult = CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL,
	  CLSCTX_INPROC_SERVER, __uuidof(ICatRegister), (void**)&pCatRegister );
   if( FAILED( hResult ) )
   {
	  // Since not all systems have the category manager installed, we'll allow
	  // the registration to succeed even though we didn't register our
	  // categories.  If you really want to register categories on a system
	  // without the category manager, you can either manually add the
	  // appropriate entries to your registry script (.rgs), or you can
	  // redistribute comcat.dll.
	  return( S_OK );
   }

   hResult = S_OK;
   pEntry = pCatMap;
   while( pEntry->iType != _ATL_CATMAP_ENTRY_END )
   {
	  catid = *pEntry->pcatid;
	  if( bRegister )
	  {
		 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
		 {
			hResult = pCatRegister->RegisterClassImplCategories( clsid, 1,
			   &catid );
		 }
		 else
		 {
			ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
			hResult = pCatRegister->RegisterClassReqCategories( clsid, 1,
			   &catid );
		 }
		 if( FAILED( hResult ) )
		 {
			return( hResult );
		 }
	  }
	  else
	  {
		 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
		 {
			pCatRegister->UnRegisterClassImplCategories( clsid, 1, &catid );
		 }
		 else
		 {
			ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
			pCatRegister->UnRegisterClassReqCategories( clsid, 1, &catid );
		 }
	  }
	  pEntry++;
   }

   // When unregistering remove "Implemented Categories" and "Required Categories" subkeys if they are empty.
   if (!bRegister)
   {
	OLECHAR szGUID[64];
	::StringFromGUID2(clsid, szGUID, 64);
	USES_CONVERSION;
	TCHAR* pszGUID = szGUID;

	if (pszGUID != NULL)
	{
		TCHAR szKey[128];
		lstrcpy(szKey, _T("CLSID\\"));
		lstrcat(szKey, pszGUID);
		lstrcat(szKey, _T("\\Required Categories"));

		HKEY  key;
		DWORD cbSubKeys = 0;

		LRESULT lRes = RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                            szKey,
                                            0,
                                            KEY_READ,
                                            &key);

		if (lRes == ERROR_SUCCESS)
		{
			lRes = RegQueryInfoKey(key, NULL, NULL, NULL, &cbSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
			RegCloseKey(key);

			if (lRes == ERROR_SUCCESS && cbSubKeys == 0)
			{
				RegDeleteKey(HKEY_CLASSES_ROOT, szKey);
			}
		}

		lstrcpy(szKey, _T("CLSID\\"));
		lstrcat(szKey, pszGUID);
		lstrcat(szKey, _T("\\Implemented Categories"));

		lRes = RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                    szKey,
                                    0,
                                    KEY_READ,
                                    &key);

		if (lRes == ERROR_SUCCESS)
		{
			lRes = RegQueryInfoKey(key, NULL, NULL, NULL, &cbSubKeys, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
			RegCloseKey(key);
			if (lRes == ERROR_SUCCESS && cbSubKeys == 0)
			{
				RegDeleteKey(HKEY_CLASSES_ROOT, szKey);
			}
		}
	}
   }

   return( S_OK );
}

// AtlComModuleRegisterServer walks the ATL Autogenerated Object Map and registers each object in the map
// If pCLSID is not NULL then only the object referred to by pCLSID is registered (The default case)
// otherwise all the objects are registered
ATLINLINE ATLAPI AtlComModuleRegisterServer(_ATL_COM_MODULE* pComModule, BOOL bRegTypeLib, const CLSID* pCLSID)
{
	ATLASSERT(pComModule != NULL);
	if (pComModule == NULL)
		return E_INVALIDARG;
	ATLASSERT(pComModule->m_hInstTypeLib != NULL);

	HRESULT hr = S_OK;

	for (_ATL_OBJMAP_ENTRY** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)
	{
		if (*ppEntry != NULL)
		{
			_ATL_OBJMAP_ENTRY* pEntry = *ppEntry;
			if (pCLSID != NULL)
			{
				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
					continue;
			}
			hr = pEntry->pfnUpdateRegistry(TRUE);
			if (FAILED(hr))
				break;
			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
				pEntry->pfnGetCategoryMap(), TRUE );
			if (FAILED(hr))
				break;
		}
	}

	if (SUCCEEDED(hr) && bRegTypeLib)
		hr = AtlRegisterTypeLib(pComModule->m_hInstTypeLib, 0);

	return hr;
}

// AtlComUnregisterServer walks the ATL Object Map and unregisters each object in the map
// If pCLSID is not NULL then only the object referred to by pCLSID is unregistered (The default case)
// otherwise all the objects are unregistered.
ATLINLINE ATLAPI AtlComModuleUnregisterServer(_ATL_COM_MODULE* pComModule, BOOL bUnRegTypeLib, const CLSID* pCLSID)
{
	ATLASSERT(pComModule != NULL);
	if (pComModule == NULL)
		return E_INVALIDARG;
	
	HRESULT hr = S_OK;

	for (_ATL_OBJMAP_ENTRY** ppEntry = pComModule->m_ppAutoObjMapFirst; ppEntry < pComModule->m_ppAutoObjMapLast; ppEntry++)
	{
		if (*ppEntry != NULL)
		{
			_ATL_OBJMAP_ENTRY* pEntry = *ppEntry;
			if (pCLSID != NULL)
			{
				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
					continue;
			}
			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid, pEntry->pfnGetCategoryMap(), FALSE );
			if (FAILED(hr))
				break;
			hr = pEntry->pfnUpdateRegistry(FALSE); //unregister
			if (FAILED(hr))
				break;
		}
	}
	if (SUCCEEDED(hr) && bUnRegTypeLib)
		hr = AtlUnRegisterTypeLib(pComModule->m_hInstTypeLib, 0);

	return hr;
}


/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

ATLINLINE ATLAPI AtlLoadTypeLib(HINSTANCE hInstTypeLib, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib)
{
	ATLASSERT(pbstrPath != NULL && ppTypeLib != NULL);
	if (pbstrPath == NULL || ppTypeLib == NULL)
		return E_POINTER;

	*pbstrPath = NULL;
	*ppTypeLib = NULL;

	USES_CONVERSION;
	ATLASSERT(hInstTypeLib != NULL);
	TCHAR szModule[_MAX_PATH+10];

	ATLVERIFY( GetModuleFileName(hInstTypeLib, szModule, _MAX_PATH) != 0 );

	// get the extension pointer in case of fail
	LPTSTR lpszExt = NULL;

	lpszExt = PathFindExtension(szModule);

	if (lpszIndex != NULL)
		lstrcat(szModule, lpszIndex);
	LPOLESTR lpszModule = szModule;
	HRESULT hr = LoadTypeLib(lpszModule, ppTypeLib);
	if (!SUCCEEDED(hr))
	{
		// typelib not in module, try <module>.tlb instead
		lstrcpy(lpszExt, _T(".tlb"));
		lpszModule = szModule;
		hr = LoadTypeLib(lpszModule, ppTypeLib);
	}
	if (SUCCEEDED(hr))
	{
		*pbstrPath = ::SysAllocString(lpszModule);
		if (*pbstrPath == NULL)
			hr = E_OUTOFMEMORY;
	}
	return hr;
}

ATLINLINE ATLAPI AtlUnRegisterTypeLib(HINSTANCE hInstTypeLib, LPCOLESTR lpszIndex)
{
	CComBSTR bstrPath;
	CComPtr<ITypeLib> pTypeLib;
	HRESULT hr = AtlLoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);
	if (SUCCEEDED(hr))
	{
		TLIBATTR* ptla;
		hr = pTypeLib->GetLibAttr(&ptla);
		if (SUCCEEDED(hr))
		{
			hr = UnRegisterTypeLib(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);
			pTypeLib->ReleaseTLibAttr(ptla);
		}
	}
	return hr;
}

ATLINLINE ATLAPI AtlRegisterTypeLib(HINSTANCE hInstTypeLib, LPCOLESTR lpszIndex)
{
	CComBSTR bstrPath;
	CComPtr<ITypeLib> pTypeLib;
	HRESULT hr = AtlLoadTypeLib(hInstTypeLib, lpszIndex, &bstrPath, &pTypeLib);
	if (SUCCEEDED(hr))
	{
		OLECHAR szDir[_MAX_PATH];
		lstrcpyW(szDir, bstrPath);
		// If index is specified remove it from the path
		if (lpszIndex != NULL)
		{
			size_t nLenPath = lstrlenW(szDir);
			size_t nLenIndex = lstrlenW(lpszIndex);
			if (memcmp(szDir + nLenPath - nLenIndex, lpszIndex, nLenIndex) == 0)
				szDir[nLenPath - nLenIndex] = 0;
		}
		szDir[AtlGetDirLen(szDir)] = 0;
		hr = ::RegisterTypeLib(pTypeLib, bstrPath, szDir);
	}
	return hr;
}

}; //namespace ATL

#endif // _ATLBASE_IMPL

#pragma warning( pop )

#ifdef _ATL_ALL_WARNINGS
#pragma warning( pop )
#endif

/////////////////////////////////////////////////////////////////////////////

#endif // __ATLBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atlmfc\atlbase.inl ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#ifndef __ATLBASE_INL__
#define __ATLBASE_INL__

#pragma once

#ifndef __ATLBASE_H__
	#error atlbase.inl requires atlbase.h to be included first
#endif

namespace ATL
{

extern CAtlComModule _AtlComModule;

template <class T>
inline HRESULT CAtlModuleT<T>::RegisterServer(BOOL bRegTypeLib, const CLSID* pCLSID)
{
	pCLSID;
	bRegTypeLib;

	HRESULT hr = S_OK;

#ifndef _ATL_NO_COM_SUPPORT

	hr = _AtlComModule.RegisterServer(bRegTypeLib, pCLSID);

#endif	// _ATL_NO_COM_SUPPORT
	

#ifndef _ATL_NO_PERF_SUPPORT

	if (SUCCEEDED(hr) && _pPerfRegFunc != NULL)
		hr = (*_pPerfRegFunc)(_AtlBaseModule.m_hInst);

#endif

	return hr;
}

template <class T>
inline HRESULT CAtlModuleT<T>::UnregisterServer(BOOL bUnRegTypeLib, const CLSID* pCLSID)
{
	bUnRegTypeLib;
	pCLSID;

	HRESULT hr = S_OK;

#ifndef _ATL_NO_PERF_SUPPORT

	if (_pPerfUnRegFunc != NULL)
		hr = (*_pPerfUnRegFunc)();

#endif

#ifndef _ATL_NO_COM_SUPPORT

	if (SUCCEEDED(hr))
		hr = _AtlComModule.UnregisterServer(bUnRegTypeLib, pCLSID);

#endif	// _ATL_NO_COM_SUPPORT

	return hr;

}

inline HRESULT CComModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE /*h*/, const GUID* plibid)
{
	if (plibid != NULL)
		m_libid = *plibid;

	_ATL_OBJMAP_ENTRY* pEntry;
	if (p != (_ATL_OBJMAP_ENTRY*)-1)
	{
		m_pObjMap = p;
		if (m_pObjMap != NULL)
		{
			pEntry = m_pObjMap;
			while (pEntry->pclsid != NULL)
			{
				pEntry->pfnObjectMain(true); //initialize class resources
				pEntry++;
			}
		}
	}
	for (_ATL_OBJMAP_ENTRY** ppEntry = _AtlComModule.m_ppAutoObjMapFirst; ppEntry < _AtlComModule.m_ppAutoObjMapLast; ppEntry++)
	{
		if (*ppEntry != NULL)
			(*ppEntry)->pfnObjectMain(true); //initialize class resources
	}
	return S_OK;
}
inline void CComModule::Term()
{
	_ATL_OBJMAP_ENTRY* pEntry;
	if (m_pObjMap != NULL)
	{
		pEntry = m_pObjMap;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pCF != NULL)
				pEntry->pCF->Release();
			pEntry->pCF = NULL;
			pEntry->pfnObjectMain(false); //cleanup class resources
			pEntry++;
		}
	}
	for (_ATL_OBJMAP_ENTRY** ppEntry = _AtlComModule.m_ppAutoObjMapFirst; ppEntry < _AtlComModule.m_ppAutoObjMapLast; ppEntry++)
	{
		if (*ppEntry != NULL)
			(*ppEntry)->pfnObjectMain(false); //cleanup class resources
	}
	CAtlModuleT<CComModule>::Term();
}

inline HRESULT CComModule::GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	if (ppv == NULL)
		return E_POINTER;
	HRESULT hr = S_OK;
	_ATL_OBJMAP_ENTRY* pEntry;
	if (m_pObjMap != NULL)
	{
		pEntry = m_pObjMap;
		while (pEntry->pclsid != NULL)
		{
			if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))
			{
				if (pEntry->pCF == NULL)
				{
					CComCritSecLock<CComCriticalSection> lock(_AtlComModule.m_csObjMap, false);
					hr = lock.Lock();
					if (FAILED(hr))
					{
						ATLASSERT(0);
						break;
					}
					if (pEntry->pCF == NULL)
						hr = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, __uuidof(IUnknown), (LPVOID*)&pEntry->pCF);
				}
				if (pEntry->pCF != NULL)
					hr = pEntry->pCF->QueryInterface(riid, ppv);
				break;
			}
			pEntry++;
		}
	}
	if (*ppv == NULL && hr == S_OK)
		hr = AtlComModuleGetClassObject(&_AtlComModule, rclsid, riid, ppv);
	return hr;
}


// Registry support (helpers)

inline HRESULT CComModule::RegisterServer(BOOL bRegTypeLib /*= FALSE*/, const CLSID* pCLSID /*= NULL*/)
{
	HRESULT hr = S_OK;
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	if (pEntry != NULL)
	{
		for (;pEntry->pclsid != NULL; pEntry++)
		{
			if (pCLSID != NULL)
			{
				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
					continue;
			}
			hr = pEntry->pfnUpdateRegistry(TRUE);
			if (FAILED(hr))
				break;
			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
				pEntry->pfnGetCategoryMap(), TRUE );
			if (FAILED(hr))
				break;
		}
	}
	if (SUCCEEDED(hr))
		hr = CAtlModuleT<CComModule>::RegisterServer(bRegTypeLib, pCLSID);
	return hr;
}

inline HRESULT CComModule::UnregisterServer(BOOL bUnRegTypeLib, const CLSID* pCLSID /*= NULL*/)
{
	HRESULT hr = S_OK;	
	_ATL_OBJMAP_ENTRY* pEntry = m_pObjMap;
	if (pEntry != NULL)
	{
		for (;pEntry->pclsid != NULL; pEntry++)
		{
			if (pCLSID != NULL)
			{
				if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
					continue;
			}
			hr = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
				pEntry->pfnGetCategoryMap(), FALSE );
			if (FAILED(hr))
				break;
			hr = pEntry->pfnUpdateRegistry(FALSE); //unregister
			if (FAILED(hr))
				break;
		}
	}
	if (SUCCEEDED(hr))
		hr = CAtlModuleT<CComModule>::UnregisterServer(bUnRegTypeLib, pCLSID);
	return hr;
}

inline HRESULT CComModule::UnregisterServer(const CLSID* pCLSID /*= NULL*/)
{
	return UnregisterServer(FALSE, pCLSID);
}

} // namespace ATL

#endif // __ATLBASE_INL__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atlmfc\atlcoll.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCOLL_H__
#define __ATLCOLL_H__

#pragma once

#pragma warning(push)
#pragma warning(disable: 4702)  // Unreachable code.  This file will have lots of it, especially without EH enabled.
#pragma warning(disable: 4512)  // assignment operator could not be generated
#pragma warning(disable: 4290)  // C++ Exception Specification ignored

// abstract iteration position
#ifndef _AFX
struct __POSITION
{
};
#endif
typedef __POSITION* POSITION;

#include <atlbase.h>

//REVIEW: Just to fix VSEE
#pragma push_macro("min")
#pragma push_macro("max")
#undef min
#undef max
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#define max(a,b)            (((a) > (b)) ? (a) : (b))

#include <new.h>

#ifndef _AFX_PACKING
#define _AFX_PACKING 4
#endif

namespace ATL {

struct CAtlPlex     // warning variable length structure
{
	CAtlPlex* pNext;
#if (_AFX_PACKING >= 8)
	DWORD dwReserved[1];    // align on 8 byte boundary
#endif
	// BYTE data[maxNum*elementSize];

	void* data() { return this+1; }

	static CAtlPlex* Create(CAtlPlex*& head, size_t nMax, size_t cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};

inline CAtlPlex* CAtlPlex::Create( CAtlPlex*& pHead, size_t nMax, size_t nElementSize )
{
	CAtlPlex* pPlex;

	ATLASSERT( nMax > 0 );
	ATLASSERT( nElementSize > 0 );

	pPlex = static_cast< CAtlPlex* >( malloc( sizeof( CAtlPlex )+(nMax*nElementSize) ) );
	if( pPlex == NULL )
	{
		return( NULL );
	}

	pPlex->pNext = pHead;
	pHead = pPlex;

	return( pPlex );
}

inline void CAtlPlex::FreeDataChain()
{
	CAtlPlex* pPlex;

	pPlex = this;
	while( pPlex != NULL )
	{
		CAtlPlex* pNext;

		pNext = pPlex->pNext;
		free( pPlex );
		pPlex = pNext;
	}
}

template< typename T >
class CElementTraitsBase
{
public:
	typedef const T& INARGTYPE;
	typedef T& OUTARGTYPE;
	
	static void CopyElements( T* pDest, const T* pSrc, size_t nElements )
	{
		for( size_t iElement = 0; iElement < nElements; iElement++ )
		{
			pDest[iElement] = pSrc[iElement];
		}
	}

	static void RelocateElements( T* pDest, T* pSrc, size_t nElements )
	{
		// A simple memmove works for nearly all types.
		// You'll have to override this for types that have pointers to their
		// own members.
		memmove( pDest, pSrc, nElements*sizeof( T ) );
	}
};

template< typename T >
class CDefaultHashTraits
{
public:
	static ULONG Hash( const T& element ) throw()
	{
		return( ULONG( ULONG_PTR( element ) ) );
	}
};

template< typename T >
class CDefaultCompareTraits
{
public:
	static bool CompareElements( const T& element1, const T& element2 )
	{
		return( (element1 == element2) != 0 );  // != 0 to handle overloads of operator== that return BOOL instead of bool
	}

	static int CompareElementsOrdered( const T& element1, const T& element2 )
	{
		if( element1 < element2 )
		{
			return( -1 );
		}
		else if( element1 == element2 )
		{
			return( 0 );
		}
		else
		{
			ATLASSERT( element1 > element2 );
			return( 1 );
		}
	}
};

template< typename T >
class CDefaultElementTraits :
	public CElementTraitsBase< T >,
	public CDefaultHashTraits< T >,
	public CDefaultCompareTraits< T >
{
};

template< typename T >
class CElementTraits :
	public CDefaultElementTraits< T >
{
};

template<>
class CElementTraits< GUID > :
	public CElementTraitsBase< GUID >
{
public:
	static ULONG Hash( INARGTYPE guid )
	{
		const DWORD* pdwData = reinterpret_cast< const DWORD* >( &guid );

		return( pdwData[0]^pdwData[1]^pdwData[2]^pdwData[3] );
	}

	static bool CompareElements( INARGTYPE element1, INARGTYPE element2 )
	{
		return( (element1 == element2) != 0 );  // != 0 to handle overloads of operator== that return BOOL instead of bool
	}

	static int CompareElementsOrdered( INARGTYPE element1, INARGTYPE element2 )
	{
		const DWORD* pdwData1 = reinterpret_cast< const DWORD* >( &element1 );
		const DWORD* pdwData2 = reinterpret_cast< const DWORD* >( &element2 );

		for( int iDWORD = 3; iDWORD >= 0; iDWORD-- )
		{
			if( pdwData1[iDWORD] > pdwData2[iDWORD] )
			{
				return( 1 );
			}
			else if( pdwData1[iDWORD] < pdwData2[iDWORD] )
			{
				return( -1 );
			}
		}

		return( 0 );
	}
};

template<>
class CElementTraits< CComVariant > :
	public CElementTraitsBase< CComVariant >
{
public:
	typedef const VARIANT& INARGTYPE;

//	static ULONG Hash( INARGTYPE t );  // variant hashing is problematic

	static bool CompareElements( INARGTYPE element1, INARGTYPE element2 )
	{
		return VarCmp(const_cast<VARIANT*>(&element1), const_cast<VARIANT*>(&element2), LOCALE_USER_DEFAULT, 0)==VARCMP_EQ;
	}

	static int CompareElementsOrdered( INARGTYPE element1, INARGTYPE element2 )
	{
		HRESULT hr = VarCmp(const_cast<VARIANT*>(&element1), const_cast<VARIANT*>(&element2), LOCALE_USER_DEFAULT, 0);
		if( hr == VARCMP_LT )
		{
			return( -1 );
		}
		else if( hr == VARCMP_GT )
		{
			return( 1 );
		}
		else
		{
			ATLASSERT( hr == VARCMP_EQ || hr == VARCMP_NULL );
			return( 0 );
		}
	}
};

template<>
class CElementTraits< CComBSTR > :
	public CElementTraitsBase< CComBSTR >
{
public:
	static ULONG Hash( INARGTYPE bstr ) throw()
	{
		ULONG nHash = 0;
		const OLECHAR* pch = bstr;
		ULONG nLength = bstr.Length();
		for( ULONG iChar = 0; iChar < nLength; iChar++ )
		{
			nHash = (nHash<<5)+nHash+pch[iChar];
		}

		return( nHash );
	}

	static bool CompareElements( INARGTYPE bstr1, INARGTYPE bstr2 ) throw()
	{
		return( bstr1 == bstr2 );
	}

	static int CompareElementsOrdered( INARGTYPE bstr1, INARGTYPE bstr2 ) throw()
	{
		if( bstr1 == NULL )
		{
			return( (bstr2 == NULL) ? 0 : -1 );
		}
		else if( bstr2 == NULL )
		{
			return( 1 );
		}

		HRESULT hr = VarBstrCmp( bstr1, bstr2, LOCALE_SYSTEM_DEFAULT, 0 );
		switch( hr )
		{
		case VARCMP_LT:
			return( -1 );
			break;

		case VARCMP_GT:
			return( 1 );
			break;

		case VARCMP_EQ:
			return( 0 );
			break;

		default:
			ATLASSERT( false );
			return( 0 );
			break;
		}
	}
};

template< typename I, const IID* piid = &__uuidof( I ) >
class CComQIPtrElementTraits :
	public CDefaultElementTraits< ATL::CComQIPtr< I, piid > >
{
public:
	typedef I* INARGTYPE;
};

template< typename T >
class CAutoPtrElementTraits :
	public CDefaultElementTraits< ATL::CAutoPtr< T > >
{
public:
	typedef ATL::CAutoPtr< T >& INARGTYPE;
	typedef T*& OUTARGTYPE;
};

template< typename T >
class CAutoVectorPtrElementTraits :
	public CDefaultElementTraits< ATL::CAutoVectorPtr< T > >
{
public:
	typedef ATL::CAutoVectorPtr< T >& INARGTYPE;
	typedef T*& OUTARGTYPE;
};

template< typename T, class Allocator = ATL::CCRTAllocator >
class CHeapPtrElementTraits :
	public CDefaultElementTraits< ATL::CHeapPtr< T, Allocator > >
{
public:
	typedef ATL::CHeapPtr< T, Allocator >& INARGTYPE;
	typedef T*& OUTARGTYPE;
};

template< typename T >
class CStringElementTraits :
	public CElementTraitsBase< T >
{
public:
	typedef T::PCXSTR INARGTYPE;
	typedef T& OUTARGTYPE;
	
	static ULONG Hash( INARGTYPE str )
	{
		ATLASSERT( str != NULL );
		ULONG nHash = 0;
		const T::XCHAR* pch = str;
		while( *pch != 0 )
		{
			nHash = (nHash<<5)+nHash+(*pch);
			pch++;
		}

		return( nHash );
	}

	static bool CompareElements( INARGTYPE str1, INARGTYPE str2 )
	{
		return( T::StrTraits::StringCompare( str1, str2 ) == 0 );
	}

	static int CompareElementsOrdered( INARGTYPE str1, INARGTYPE str2 )
	{
		return( T::StrTraits::StringCompare( str1, str2 ) );
	}
};

template < typename T >
class CDefaultCharTraits
{
};

template <>
class CDefaultCharTraits<char>
{
public:
    static char CharToUpper(char x)
    {
        return (char)toupper(x);
    }

    static char CharToLower(char x)
    {
        return (char)tolower(x);
    }
};

template <>
class CDefaultCharTraits<wchar_t>
{
public:
    static wchar_t CharToUpper(wchar_t x)
    {
        return (wchar_t)towupper(x);
    }

    static wchar_t CharToLower(wchar_t x)
    {
        return (wchar_t)towlower(x);
    }
};

template< typename T, class CharTraits = CDefaultCharTraits<T::XCHAR> >
class CStringElementTraitsI :
	public CElementTraitsBase< T >
{
public:
	typedef typename T::PCXSTR INARGTYPE;
	typedef T& OUTARGTYPE;

	static ULONG Hash( INARGTYPE str )
	{
		const T::XCHAR* pch;
		ULONG nHash;

		ATLASSERT( str != NULL );
		nHash = 0;
		pch = str;
		while( *pch != 0 )
		{
			nHash = (nHash<<5)+nHash+CharTraits::CharToUpper(*pch);
			pch++;
		}

		return( nHash );
	}

	static bool CompareElements( INARGTYPE str1, INARGTYPE str2 )
	{
		return( T::StrTraits::StringCompareIgnore( str1, str2 ) == 0 );
	}

	static int CompareElementsOrdered( INARGTYPE str1, INARGTYPE str2 )
	{
		return( T::StrTraits::StringCompareIgnore( str1, str2 ) );
	}
};

template< typename T >
class CStringRefElementTraits :
	public CElementTraitsBase< T >
{
public:
	static ULONG Hash( INARGTYPE str ) throw()
	{
		ULONG nHash = 0;
		const T::XCHAR* pch = str;
		while( *pch != 0 )
		{
			nHash = (nHash<<5)+nHash+(*pch);
			pch++;
		}

		return( nHash );
	}

	static bool CompareElements( INARGTYPE element1, INARGTYPE element2 ) throw()
	{
		return( element1 == element2 );
	}

	static int CompareElementsOrdered( INARGTYPE str1, INARGTYPE str2 ) throw()
	{
		return( str1.Compare( str2 ) );
	}
};

template< typename T >
class CPrimitiveElementTraits :
	public CDefaultElementTraits< T >
{
public:
	typedef T INARGTYPE;
	typedef T& OUTARGTYPE;
};

#define _DECLARE_PRIMITIVE_TRAITS( T ) \
	template<> \
	class CElementTraits< T > : \
		public CPrimitiveElementTraits< T > \
	{ \
	};

_DECLARE_PRIMITIVE_TRAITS( unsigned char )
_DECLARE_PRIMITIVE_TRAITS( unsigned short )
_DECLARE_PRIMITIVE_TRAITS( unsigned int )
_DECLARE_PRIMITIVE_TRAITS( unsigned long )
_DECLARE_PRIMITIVE_TRAITS( unsigned __int64 )
_DECLARE_PRIMITIVE_TRAITS( signed char )
_DECLARE_PRIMITIVE_TRAITS( char )
_DECLARE_PRIMITIVE_TRAITS( short )
_DECLARE_PRIMITIVE_TRAITS( int )
_DECLARE_PRIMITIVE_TRAITS( long )
_DECLARE_PRIMITIVE_TRAITS( __int64 )
_DECLARE_PRIMITIVE_TRAITS( float )
_DECLARE_PRIMITIVE_TRAITS( double )
_DECLARE_PRIMITIVE_TRAITS( bool )
#ifdef _NATIVE_WCHAR_T_DEFINED
_DECLARE_PRIMITIVE_TRAITS( wchar_t )
#endif
_DECLARE_PRIMITIVE_TRAITS( void* )

template< typename E, class ETraits = CElementTraits< E > >
class CAtlArray
{
public:
	typedef typename ETraits::INARGTYPE INARGTYPE;
	typedef typename ETraits::OUTARGTYPE OUTARGTYPE;

public:
	CAtlArray() throw();

	size_t GetCount() const throw();
	bool IsEmpty() const throw();
	bool SetCount( size_t nNewSize, int nGrowBy = -1 );

	void FreeExtra() throw();
	void RemoveAll() throw();

	const E& GetAt( size_t iElement ) const throw();
	void SetAt( size_t iElement, INARGTYPE element );
	E& GetAt( size_t iElement ) throw();

	const E* GetData() const throw();
	E* GetData() throw();

	void SetAtGrow( size_t iElement, INARGTYPE element );
	// Add an empty element to the end of the array
	size_t Add();
	// Add an element to the end of the array
	size_t Add( INARGTYPE element );
	size_t Append( const CAtlArray< E, ETraits >& aSrc );
	void Copy( const CAtlArray< E, ETraits >& aSrc );

	const E& operator[]( size_t iElement ) const throw();
	E& operator[]( size_t iElement ) throw();

	void InsertAt( size_t iElement, INARGTYPE element, size_t nCount = 1 );
	void InsertArrayAt( size_t iStart, const CAtlArray< E, ETraits >* paNew );
	void RemoveAt( size_t iElement, size_t nCount = 1 );

#ifdef _DEBUG
	void AssertValid() const;
#endif  // _DEBUG

private:
	bool GrowBuffer( size_t nNewSize );

// Implementation
private:
	E* m_pData;
	size_t m_nSize;
	size_t m_nMaxSize;
	int m_nGrowBy;

private:
	static void CallConstructors( E* pElements, size_t nElements );
	static void CallDestructors( E* pElements, size_t nElements );
	
public:
	~CAtlArray() throw();

private:
	// Private to prevent use
	CAtlArray( const CAtlArray& ) throw();
	CAtlArray& operator=( const CAtlArray& ) throw();
};

template< class I, const IID* piid = &__uuidof( I ) >
class CInterfaceArray :
	public CAtlArray< ATL::CComQIPtr< I, piid >, CComQIPtrElementTraits< I, piid > >
{
public:
	CInterfaceArray() throw()
	{
	}

private:
	// Private to prevent use
	CInterfaceArray( const CInterfaceArray& ) throw();
	CInterfaceArray& operator=( const CInterfaceArray& ) throw();
};

template< typename E >
class CAutoPtrArray :
	public CAtlArray< ATL::CAutoPtr< E >, CAutoPtrElementTraits< E > >
{
public:
	CAutoPtrArray() throw()
	{
	}

private:
	// Private to prevent use
	CAutoPtrArray( const CAutoPtrArray& ) throw();
	CAutoPtrArray& operator=( const CAutoPtrArray& ) throw();
};

template< typename E, class Allocator = ATL::CCRTAllocator >
class CHeapPtrArray :
	public CAtlArray< ATL::CHeapPtr< E, Allocator >, CHeapPtrElementTraits< E, Allocator > >
{
public:
	CHeapPtrArray() throw()
	{
	}

private:
	// Private to prevent use
	CHeapPtrArray( const CHeapPtrArray& ) throw();
	CHeapPtrArray& operator=( const CHeapPtrArray& ) throw();
};

template< typename E, class ETraits >
inline size_t CAtlArray< E, ETraits >::GetCount() const
{
	return( m_nSize );
}

template< typename E, class ETraits >
inline bool CAtlArray< E, ETraits >::IsEmpty() const
{
	return( m_nSize == 0 );
}

template< typename E, class ETraits >
inline void CAtlArray< E, ETraits >::RemoveAll()
{
	SetCount( 0, -1 );
}

template< typename E, class ETraits >
inline const E& CAtlArray< E, ETraits >::GetAt( size_t iElement ) const
{
	ATLASSERT( iElement < m_nSize );
	return( m_pData[iElement] );
}

template< typename E, class ETraits >
inline void CAtlArray< E, ETraits >::SetAt( size_t iElement, INARGTYPE element )
{
	ATLASSERT( iElement < m_nSize );
	m_pData[iElement] = element;
}

template< typename E, class ETraits >
inline E& CAtlArray< E, ETraits >::GetAt( size_t iElement )
{
	ATLASSERT( iElement < m_nSize );
	return( m_pData[iElement] );
}

template< typename E, class ETraits >
inline const E* CAtlArray< E, ETraits >::GetData() const
{
	return( m_pData );
}

template< typename E, class ETraits >
inline E* CAtlArray< E, ETraits >::GetData()
{
	return( m_pData );
}

template< typename E, class ETraits >
inline size_t CAtlArray< E, ETraits >::Add()
{
	size_t iElement;

	iElement = m_nSize;
	SetCount( m_nSize+1 );

	return( iElement );
}

#pragma push_macro("new")
#undef new

template< typename E, class ETraits >
inline size_t CAtlArray< E, ETraits >::Add( INARGTYPE element )
{
	size_t iElement;

	iElement = m_nSize;
	if( iElement >= m_nMaxSize )
	{
		bool bSuccess = GrowBuffer( iElement+1 );
		if( !bSuccess )
		{
			ATL::AtlThrow( E_OUTOFMEMORY );
		}
	}
	::new( m_pData+iElement ) E( element );
	m_nSize++;

	return( iElement );
}

#pragma pop_macro("new")

template< typename E, class ETraits >
inline const E& CAtlArray< E, ETraits >::operator[]( size_t iElement ) const
{
	ATLASSERT( iElement < m_nSize );
	return( m_pData[iElement] );
}

template< typename E, class ETraits >
inline E& CAtlArray< E, ETraits >::operator[]( size_t iElement )
{
	ATLASSERT( iElement < m_nSize );
	return( m_pData[iElement] );
}

template< typename E, class ETraits >
CAtlArray< E, ETraits >::CAtlArray() :
	m_pData( NULL ),
	m_nSize( 0 ),
	m_nMaxSize( 0 ),
	m_nGrowBy( 0 )
{
}

template< typename E, class ETraits >
CAtlArray< E, ETraits >::~CAtlArray()
{
	if( m_pData != NULL )
	{
		CallDestructors( m_pData, m_nSize );
		free( m_pData );
	}
}

template< typename E, class ETraits >
bool CAtlArray< E, ETraits >::GrowBuffer( size_t nNewSize )
{
	if( nNewSize > m_nMaxSize )
	{
		if( m_pData == NULL )
		{
			size_t nAllocSize = max( size_t( m_nGrowBy ), nNewSize );
			m_pData = static_cast< E* >( malloc( nAllocSize*sizeof( E ) ) );
			if( m_pData == NULL )
			{
				return( false );
			}
			m_nMaxSize = nAllocSize;
		}
		else
		{
			// otherwise, grow array
			size_t nGrowBy = m_nGrowBy;
			if( nGrowBy == 0 )
			{
				// heuristically determine growth when nGrowBy == 0
				//  (this avoids heap fragmentation in many situations)
				nGrowBy = m_nSize/8;
				nGrowBy = (nGrowBy < 4) ? 4 : ((nGrowBy > 1024) ? 1024 : nGrowBy);
			}
			size_t nNewMax;
			if( nNewSize < (m_nMaxSize+nGrowBy) )
				nNewMax = m_nMaxSize+nGrowBy;  // granularity
			else
				nNewMax = nNewSize;  // no slush

			ATLASSERT( nNewMax >= m_nMaxSize );  // no wrap around
#ifdef SIZE_T_MAX
			ATLASSERT( nNewMax <= SIZE_T_MAX/sizeof( E ) ); // no overflow
#endif
			E* pNewData = static_cast< E* >( malloc( nNewMax*sizeof( E ) ) );
			if( pNewData == NULL )
			{
				return false;
			}

			// copy new data from old
			ETraits::RelocateElements( pNewData, m_pData, m_nSize );

			// get rid of old stuff (note: no destructors called)
			free( m_pData );
			m_pData = pNewData;
			m_nMaxSize = nNewMax;
		}
	}

	return true;
}	

template< typename E, class ETraits >
bool CAtlArray< E, ETraits >::SetCount( size_t nNewSize, int nGrowBy )
{
	ATLASSERT_VALID(this);

	if( nGrowBy != -1 )
	{
		m_nGrowBy = nGrowBy;  // set new size
	}

	if( nNewSize == 0 )
	{
		// shrink to nothing
		if( m_pData != NULL )
		{
			CallDestructors( m_pData, m_nSize );
			free( m_pData );
			m_pData = NULL;
		}
		m_nSize = 0;
		m_nMaxSize = 0;
	}
	else if( nNewSize <= m_nMaxSize )
	{
		// it fits
		if( nNewSize > m_nSize )
		{
			// initialize the new elements
			CallConstructors( m_pData+m_nSize, nNewSize-m_nSize );
		}
		else if( m_nSize > nNewSize )
		{
			// destroy the old elements
			CallDestructors( m_pData+nNewSize, m_nSize-nNewSize );
		}
		m_nSize = nNewSize;
	}
	else
	{
		bool bSuccess;
		
		bSuccess = GrowBuffer( nNewSize );
		if( !bSuccess )
		{
			return( false );
		}

		// construct new elements
		ATLASSERT( nNewSize > m_nSize );
		CallConstructors( m_pData+m_nSize, nNewSize-m_nSize );

		m_nSize = nNewSize;
	}

	return true;
}

template< typename E, class ETraits >
size_t CAtlArray< E, ETraits >::Append( const CAtlArray< E, ETraits >& aSrc )
{
	ATLASSERT_VALID(this);
	ATLASSERT( this != &aSrc );   // cannot append to itself

	size_t nOldSize = m_nSize;
	SetCount( m_nSize+aSrc.m_nSize );
	ETraits::CopyElements( m_pData+nOldSize, aSrc.m_pData, aSrc.m_nSize );

	return( nOldSize );
}

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::Copy( const CAtlArray< E, ETraits >& aSrc )
{
	ATLASSERT_VALID(this);
	ATLASSERT( this != &aSrc );   // cannot append to itself

	SetCount( aSrc.m_nSize );
	ETraits::CopyElements( m_pData, aSrc.m_pData, aSrc.m_nSize );
}

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::FreeExtra()
{
	ATLASSERT_VALID(this);

	if( m_nSize != m_nMaxSize )
	{
		// shrink to desired size
#ifdef SIZE_T_MAX
		ATLASSERT( m_nSize <= (SIZE_T_MAX/sizeof( E )) ); // no overflow
#endif
		E* pNewData = NULL;
		if( m_nSize != 0 )
		{
			pNewData = (E*)malloc( m_nSize*sizeof( E ) );
			if( pNewData == NULL )
			{
				return;
			}

			// copy new data from old
			ETraits::RelocateElements( pNewData, m_pData, m_nSize );
		}

		// get rid of old stuff (note: no destructors called)
		free( m_pData );
		m_pData = pNewData;
		m_nMaxSize = m_nSize;
	}
}

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::SetAtGrow( size_t iElement, INARGTYPE element )
{
	ATLASSERT_VALID(this);
	size_t nOldSize;

	nOldSize = m_nSize;
	if( iElement >= m_nSize )
		SetCount( iElement+1, -1 );
	_ATLTRY
	{
		m_pData[iElement] = element;
	}
	_ATLCATCHALL()
	{
		if( m_nSize != nOldSize )
		{
			SetCount( nOldSize, -1 );
		}
		_ATLRETHROW;
	}
}

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::InsertAt( size_t iElement, INARGTYPE element, size_t nElements /*=1*/)
{
	ATLASSERT_VALID(this);
	ATLASSERT( nElements > 0 );     // zero size not allowed

	if( iElement >= m_nSize )
	{
		// adding after the end of the array
		SetCount( iElement+nElements, -1 );   // grow so nIndex is valid
	}
	else
	{
		// inserting in the middle of the array
		size_t nOldSize = m_nSize;
		SetCount( m_nSize+nElements, -1 );  // grow it to new size
		// destroy intial data before copying over it
		CallDestructors( m_pData+nOldSize, nElements );
		// shift old data up to fill gap
		ETraits::RelocateElements( m_pData+(iElement+nElements), m_pData+iElement,
			nOldSize-iElement );

		_ATLTRY
		{
			// re-init slots we copied from
			CallConstructors( m_pData+iElement, nElements );
		}
		_ATLCATCHALL()
		{
			ETraits::RelocateElements( m_pData+iElement, m_pData+(iElement+nElements),
				nOldSize-iElement );
			SetCount( nOldSize, -1 );
			_ATLRETHROW;
		}
	}

	// insert new value in the gap
	ATLASSERT( (iElement+nElements) <= m_nSize );
	for( size_t iNewElement = iElement; iNewElement < (iElement+nElements); iNewElement++ )
	{
		m_pData[iNewElement] = element;
	}
}

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::RemoveAt( size_t iElement, size_t nElements )
{
	ATLASSERT_VALID(this);
	ATLASSERT( (iElement+nElements) <= m_nSize );

	// just remove a range
	size_t nMoveCount = m_nSize-(iElement+nElements);
	CallDestructors( m_pData+iElement, nElements );
	if( nMoveCount > 0 )
	{
		ETraits::RelocateElements( m_pData+iElement, m_pData+(iElement+nElements),
			nMoveCount );
	}
	m_nSize -= nElements;
}

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::InsertArrayAt( size_t iStartElement, 
	const CAtlArray< E, ETraits >* paNew )
{
	ATLASSERT_VALID(this);
	ATLASSERT( paNew != NULL );
	ATLASSERT_VALID(paNew);

	if( paNew->GetCount() > 0 )
	{
		InsertAt( iStartElement, paNew->GetAt( 0 ), paNew->GetCount() );
		for( size_t iElement = 0; iElement < paNew->GetCount(); iElement++ )
			SetAt( iStartElement+iElement, paNew->GetAt( iElement ) );
	}
}

#ifdef _DEBUG
template< typename E, class ETraits >
void CAtlArray< E, ETraits >::AssertValid() const
{
	if( m_pData == NULL )
	{
		ATLASSERT( m_nSize == 0 );
		ATLASSERT( m_nMaxSize == 0 );
	}
	else
	{
		ATLASSERT( m_nSize <= m_nMaxSize );
		ATLASSERT( AtlIsValidAddress( m_pData, m_nMaxSize * sizeof( E ) ) );
	}
}
#endif

#pragma push_macro("new")
#undef new

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::CallConstructors( E* pElements, size_t nElements )
{
	size_t iElement;

	_ATLTRY
	{
		for( iElement = 0; iElement < nElements; iElement++ )
		{
			::new( pElements+iElement ) E;
		}
	}
	_ATLCATCHALL()
	{
		while( iElement > 0 )
		{
			iElement--;
			pElements[iElement].~E();
		}

		_ATLRETHROW;
	}
}

#pragma pop_macro("new")

template< typename E, class ETraits >
void CAtlArray< E, ETraits >::CallDestructors( E* pElements, size_t nElements )
{
	(void)pElements;  //REVIEW: Unreferenced formal warning if T doesn't have a real destructor

	for( size_t iElement = 0; iElement < nElements; iElement++ )
	{
		pElements[iElement].~E();
	}
}


template< typename E, class ETraits = CElementTraits< E > >
class CAtlList
{
public:
	typedef typename ETraits::INARGTYPE INARGTYPE;

private:
	class CNode :
		public __POSITION
	{
	public:
		CNode()
		{
		}
		CNode( INARGTYPE element ) :
			m_element( element )
		{
		}
		~CNode() throw()
		{
		}

	public:
		CNode* m_pNext;
		CNode* m_pPrev;
		E m_element;

	private:
		CNode( const CNode& ) throw();
	};

public:
	CAtlList( UINT nBlockSize = 10 ) throw();

	size_t GetCount() const throw();
	bool IsEmpty() const throw();

	E& GetHead() throw();
	const E& GetHead() const throw();
	E& GetTail() throw();
	const E& GetTail() const throw();

	E RemoveHead();
	E RemoveTail();
	void RemoveHeadNoReturn() throw();
	void RemoveTailNoReturn() throw();

	POSITION AddHead();
	POSITION AddHead( INARGTYPE element );
	void AddHeadList( const CAtlList< E, ETraits >* plNew );
	POSITION AddTail();
	POSITION AddTail( INARGTYPE element );
	void AddTailList( const CAtlList< E, ETraits >* plNew );

	void RemoveAll() throw();

	POSITION GetHeadPosition() const throw();
	POSITION GetTailPosition() const throw();
	E& GetNext( POSITION& pos ) throw();
	const E& GetNext( POSITION& pos ) const throw();
	E& GetPrev( POSITION& pos ) throw();
	const E& GetPrev( POSITION& pos ) const throw();

	E& GetAt( POSITION pos ) throw();
	const E& GetAt( POSITION pos ) const throw();
	void SetAt( POSITION pos, INARGTYPE element );
	void RemoveAt( POSITION pos ) throw();

	POSITION InsertBefore( POSITION pos, INARGTYPE element );
	POSITION InsertAfter( POSITION pos, INARGTYPE element );

	POSITION Find( INARGTYPE element, POSITION posStartAfter = NULL ) const throw();
	POSITION FindIndex( size_t iElement ) const throw();

	void MoveToHead( POSITION pos ) throw();
	void MoveToTail( POSITION pos ) throw();
	void SwapElements( POSITION pos1, POSITION pos2 ) throw();

#ifdef _DEBUG
	void AssertValid() const;
#endif  // _DEBUG

// Implementation
private:
	CNode* m_pHead;
	CNode* m_pTail;
	size_t m_nElements;
	CAtlPlex* m_pBlocks;
	CNode* m_pFree;
	UINT m_nBlockSize;

private:
	void GetFreeNode();
	CNode* NewNode( CNode* pPrev, CNode* pNext );
	CNode* NewNode( INARGTYPE element, CNode* pPrev, CNode* pNext );
	void FreeNode( CNode* pNode ) throw();

public:
	~CAtlList() throw();

private:
	// Private to prevent use
	CAtlList( const CAtlList& ) throw();
	CAtlList& operator=( const CAtlList& ) throw();
};

template< class I, const IID* piid = &__uuidof( I ) >
class CInterfaceList :
	public CAtlList< ATL::CComQIPtr< I, piid >, CComQIPtrElementTraits< I, piid > >
{
public:
	CInterfaceList( UINT nBlockSize = 10 ) throw() :
		CAtlList< ATL::CComQIPtr< I, piid >, CComQIPtrElementTraits< I, piid > >( nBlockSize )
	{
	}

private:
	// Private to prevent use
	CInterfaceList( const CInterfaceList& ) throw();
	CInterfaceList& operator=( const CInterfaceList& ) throw();
};

template< typename E >
class CAutoPtrList :
	public CAtlList< ATL::CAutoPtr< E >, CAutoPtrElementTraits< E > >
{
public:
	CAutoPtrList( UINT nBlockSize = 10 ) throw() :
		CAtlList< ATL::CAutoPtr< E >, CAutoPtrElementTraits< E > >( nBlockSize )
	{
	}

private:
	// Private to prevent use
	CAutoPtrList( const CAutoPtrList& ) throw();
	CAutoPtrList& operator=( const CAutoPtrList& ) throw();
};

template< typename E, class Allocator = ATL::CCRTAllocator >
class CHeapPtrList :
	public CAtlList< ATL::CHeapPtr< E, Allocator >, CHeapPtrElementTraits< E, Allocator > >
{
public:
	CHeapPtrList( UINT nBlockSize = 10 ) throw() :
		CAtlList< ATL::CHeapPtr< E, Allocator >, CHeapPtrElementTraits< E, Allocator > >( nBlockSize )
	{
	}

private:
	// Private to prevent use
	CHeapPtrList( const CHeapPtrList& ) throw();
	CHeapPtrList& operator=( const CHeapPtrList& ) throw();
};

template< typename E, class ETraits >
inline size_t CAtlList< E, ETraits >::GetCount() const
{
	return( m_nElements );
}

template< typename E, class ETraits >
inline bool CAtlList< E, ETraits >::IsEmpty() const
{
	return( m_nElements == 0 );
}

template< typename E, class ETraits >
inline E& CAtlList< E, ETraits >::GetHead() 
{
	ATLASSERT( m_pHead != NULL );
	return( m_pHead->m_element );
}

template< typename E, class ETraits >
inline const E& CAtlList< E, ETraits >::GetHead() const
{
	ATLASSERT( m_pHead != NULL );
	return( m_pHead->m_element );
}

template< typename E, class ETraits >
inline E& CAtlList< E, ETraits >::GetTail() 
{
	ATLASSERT( m_pTail != NULL );
	return( m_pTail->m_element );
}

template< typename E, class ETraits >
inline const E& CAtlList< E, ETraits >::GetTail() const
{
	ATLASSERT( m_pTail != NULL );
	return( m_pTail->m_element );
}

template< typename E, class ETraits >
inline POSITION CAtlList< E, ETraits >::GetHeadPosition() const
{
	return( POSITION( m_pHead ) );
}

template< typename E, class ETraits >
inline POSITION CAtlList< E, ETraits >::GetTailPosition() const
{
	return( POSITION( m_pTail ) );
}

template< typename E, class ETraits >
inline E& CAtlList< E, ETraits >::GetNext( POSITION& pos )
{
	CNode* pNode;

	ATLASSERT( pos != NULL );
	pNode = (CNode*)pos;
	pos = POSITION( pNode->m_pNext );
	
	return( pNode->m_element );
}

template< typename E, class ETraits >
inline const E& CAtlList< E, ETraits >::GetNext( POSITION& pos ) const
{
	CNode* pNode;

	ATLASSERT( pos != NULL );
	pNode = (CNode*)pos;
	pos = POSITION( pNode->m_pNext );
	
	return( pNode->m_element );
}

template< typename E, class ETraits >
inline E& CAtlList< E, ETraits >::GetPrev( POSITION& pos )
{
	CNode* pNode;

	ATLASSERT( pos != NULL );
	pNode = (CNode*)pos;
	pos = POSITION( pNode->m_pPrev );
	
	return( pNode->m_element );
}

template< typename E, class ETraits >
inline const E& CAtlList< E, ETraits >::GetPrev( POSITION& pos ) const
{
	CNode* pNode;

	ATLASSERT( pos != NULL );
	pNode = (CNode*)pos;
	pos = POSITION( pNode->m_pPrev );
	
	return( pNode->m_element );
}

template< typename E, class ETraits >
inline E& CAtlList< E, ETraits >::GetAt( POSITION pos )
{
	CNode* pNode;

	ATLASSERT( pos != NULL );
	pNode = (CNode*)pos;
	
	return( pNode->m_element );
}

template< typename E, class ETraits >
inline const E& CAtlList< E, ETraits >::GetAt( POSITION pos ) const
{
	CNode* pNode;

	ATLASSERT( pos != NULL );
	pNode = (CNode*)pos;
	
	return( pNode->m_element );
}

template< typename E, class ETraits >
inline void CAtlList< E, ETraits >::SetAt( POSITION pos, INARGTYPE element )
{
	CNode* pNode;

	ATLASSERT( pos != NULL );
	pNode = (CNode*)pos;
	pNode->m_element = element;
}

template< typename E, class ETraits >
CAtlList< E, ETraits >::CAtlList( UINT nBlockSize ) :
	m_nElements( 0 ),
	m_pHead( NULL ),
	m_pTail( NULL ),
	m_nBlockSize( nBlockSize ),
	m_pBlocks( NULL ),
	m_pFree( NULL )
{
	ATLASSERT( nBlockSize > 0 );
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::RemoveAll()
{
	while( m_nElements > 0 )
	{
		CNode* pKill;

		pKill = m_pHead;
		ATLASSERT( pKill != NULL );
		m_pHead = m_pHead->m_pNext;
		FreeNode( pKill );
	}
	ATLASSERT( m_nElements == 0 );
	m_pHead = NULL;
	m_pTail = NULL;
	m_pFree = NULL;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
}

template< typename E, class ETraits >
CAtlList< E, ETraits >::~CAtlList()
{
	RemoveAll();
	ATLASSERT( m_nElements == 0 );
}

#pragma push_macro("new")
#undef new

template< typename E, class ETraits >
void CAtlList< E, ETraits >::GetFreeNode()
{
	if( m_pFree == NULL )
	{
		CAtlPlex* pPlex;
		CNode* pNode;

		pPlex = CAtlPlex::Create( m_pBlocks, m_nBlockSize, sizeof( CNode ) );
		if( pPlex == NULL )
		{
			ATL::AtlThrow( E_OUTOFMEMORY );
		}
		pNode = (CNode*)pPlex->data();
		pNode += m_nBlockSize-1;
		for( int iBlock = m_nBlockSize-1; iBlock >= 0; iBlock-- )
		{
			pNode->m_pNext = m_pFree;
			m_pFree = pNode;
			pNode--;
		}
	}
	ATLASSERT( m_pFree != NULL );
}

template< typename E, class ETraits >
CAtlList< E, ETraits >::CNode* CAtlList< E, ETraits >::NewNode( CNode* pPrev, CNode* pNext )
{
	GetFreeNode();

	CNode* pNewNode = m_pFree;
	CNode* pNextFree = m_pFree->m_pNext;

	::new( pNewNode ) CNode;

	m_pFree = pNextFree;
	pNewNode->m_pPrev = pPrev;
	pNewNode->m_pNext = pNext;
	m_nElements++;
	ATLASSERT( m_nElements > 0 );

	return( pNewNode );
}

template< typename E, class ETraits >
CAtlList< E, ETraits >::CNode* CAtlList< E, ETraits >::NewNode( INARGTYPE element, CNode* pPrev, 
	CNode* pNext )
{
	GetFreeNode();

	CNode* pNewNode = m_pFree;
	CNode* pNextFree = m_pFree->m_pNext;

	::new( pNewNode ) CNode( element );

	m_pFree = pNextFree;
	pNewNode->m_pPrev = pPrev;
	pNewNode->m_pNext = pNext;
	m_nElements++;
	ATLASSERT( m_nElements > 0 );

	return( pNewNode );
}

#pragma pop_macro("new")

template< typename E, class ETraits >
void CAtlList< E, ETraits >::FreeNode( CNode* pNode )
{
	pNode->~CNode();
	pNode->m_pNext = m_pFree;
	m_pFree = pNode;
	ATLASSERT( m_nElements > 0 );
	m_nElements--;
	if( m_nElements == 0 )
	{
		RemoveAll();
	}
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::AddHead()
{
	CNode* pNode = NewNode( NULL, m_pHead );
	if( m_pHead != NULL )
	{
		m_pHead->m_pPrev = pNode;
	}
	else
	{
		m_pTail = pNode;
	}
	m_pHead = pNode;

	return( POSITION( pNode ) );
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::AddHead( INARGTYPE element )
{
	CNode* pNode;

	pNode = NewNode( element, NULL, m_pHead );
	
	if( m_pHead != NULL )
	{
		m_pHead->m_pPrev = pNode;
	}
	else
	{
		m_pTail = pNode;
	}
	m_pHead = pNode;

	return( POSITION( pNode ) );
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::AddTail()
{
	CNode* pNode = NewNode( m_pTail, NULL );
	if( m_pTail != NULL )
	{
		m_pTail->m_pNext = pNode;
	}
	else
	{
		m_pHead = pNode;
	}
	m_pTail = pNode;

	return( POSITION( pNode ) );
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::AddTail( INARGTYPE element )
{
	CNode* pNode;

	pNode = NewNode( element, m_pTail, NULL );
	
	if( m_pTail != NULL )
	{
		m_pTail->m_pNext = pNode;
	}
	else
	{
		m_pHead = pNode;
	}
	m_pTail = pNode;

	return( POSITION( pNode ) );
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::AddHeadList( const CAtlList< E, ETraits >* plNew )
{
	POSITION pos;

	ATLASSERT( plNew != NULL );

	pos = plNew->GetTailPosition();
	while( pos != NULL )
	{
		INARGTYPE element = plNew->GetPrev( pos );
		AddHead( element );
	}
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::AddTailList( const CAtlList< E, ETraits >* plNew )
{
	POSITION pos;

	ATLASSERT( plNew != NULL );

	pos = plNew->GetHeadPosition();
	while( pos != NULL )
	{
		INARGTYPE element = plNew->GetNext( pos );
		AddTail( element );
	}
}

template< typename E, class ETraits >
E CAtlList< E, ETraits >::RemoveHead()
{
	CNode* pNode;

	ATLASSERT( m_pHead != NULL );

	pNode = m_pHead;
	E element( pNode->m_element );

	m_pHead = pNode->m_pNext;
	if( m_pHead != NULL )
	{
		m_pHead->m_pPrev = NULL;
	}
	else
	{
		m_pTail = NULL;
	}
	FreeNode( pNode );

	return( element );
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::RemoveHeadNoReturn() throw()
{
	ATLASSERT( m_pHead != NULL );

	CNode* pNode = m_pHead;
	m_pHead = pNode->m_pNext;
	if( m_pHead != NULL )
	{
		m_pHead->m_pPrev = NULL;
	}
	else
	{
		m_pTail = NULL;
	}
	FreeNode( pNode );
}

template< typename E, class ETraits >
E CAtlList< E, ETraits >::RemoveTail()
{
	CNode* pNode;

	ATLASSERT( m_pTail != NULL );

	pNode = m_pTail;
	E element( pNode->m_element );

	m_pTail = pNode->m_pPrev;
	if( m_pTail != NULL )
	{
		m_pTail->m_pNext = NULL;
	}
	else
	{
		m_pHead = NULL;
	}
	FreeNode( pNode );

	return( element );
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::RemoveTailNoReturn() throw()
{
	ATLASSERT( m_pTail != NULL );

	CNode* pNode = m_pTail;

	m_pTail = pNode->m_pPrev;
	if( m_pTail != NULL )
	{
		m_pTail->m_pNext = NULL;
	}
	else
	{
		m_pHead = NULL;
	}
	FreeNode( pNode );
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::InsertBefore( POSITION pos, INARGTYPE element )
{
	ATLASSERT_VALID(this);

	if( pos == NULL )
		return AddHead( element ); // insert before nothing -> head of the list

	// Insert it before position
	CNode* pOldNode = (CNode*)pos;
	CNode* pNewNode = NewNode( element, pOldNode->m_pPrev, pOldNode );

	if( pOldNode->m_pPrev != NULL )
	{
		ATLASSERT(AtlIsValidAddress(pOldNode->m_pPrev, sizeof(CNode)));
		pOldNode->m_pPrev->m_pNext = pNewNode;
	}
	else
	{
		ATLASSERT( pOldNode == m_pHead );
		m_pHead = pNewNode;
	}
	pOldNode->m_pPrev = pNewNode;

	return( POSITION( pNewNode ) );
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::InsertAfter( POSITION pos, INARGTYPE element )
{
	ATLASSERT_VALID(this);

	if( pos == NULL )
		return AddTail( element ); // insert after nothing -> tail of the list

	// Insert it after position
	CNode* pOldNode = (CNode*)pos;
	CNode* pNewNode = NewNode( element, pOldNode, pOldNode->m_pNext );

	if( pOldNode->m_pNext != NULL )
	{
		ATLASSERT(AtlIsValidAddress(pOldNode->m_pNext, sizeof(CNode)));
		pOldNode->m_pNext->m_pPrev = pNewNode;
	}
	else
	{
		ATLASSERT( pOldNode == m_pTail );
		m_pTail = pNewNode;
	}
	pOldNode->m_pNext = pNewNode;

	return( POSITION( pNewNode ) );
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::RemoveAt( POSITION pos )
{
	ATLASSERT_VALID(this);

	CNode* pOldNode = (CNode*)pos;
	ATLASSERT(AtlIsValidAddress(pOldNode, sizeof(CNode)));

	// remove pOldNode from list
	if( pOldNode == m_pHead )
	{
		m_pHead = pOldNode->m_pNext;
	}
	else
	{
		ATLASSERT(AtlIsValidAddress(pOldNode->m_pPrev, sizeof(CNode)));
		pOldNode->m_pPrev->m_pNext = pOldNode->m_pNext;
	}
	if( pOldNode == m_pTail )
	{
		m_pTail = pOldNode->m_pPrev;
	}
	else
	{
		ATLASSERT(AtlIsValidAddress(pOldNode->m_pNext, sizeof(CNode)));
		pOldNode->m_pNext->m_pPrev = pOldNode->m_pPrev;
	}
	FreeNode( pOldNode );
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::FindIndex( size_t iElement ) const
{
	ATLASSERT_VALID(this);

	if( iElement >= m_nElements )
		return NULL;  // went too far

	CNode* pNode = m_pHead;
	for( size_t iSearch = 0; iSearch < iElement; iSearch++ )
	{
		pNode = pNode->m_pNext;
	}

	return( POSITION( pNode ) );
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::MoveToHead( POSITION pos ) throw()
{
	ATLASSERT( pos != NULL );

	CNode* pNode = static_cast< CNode* >( pos );
	if( pNode == m_pHead )
	{
		// Already at the head
		return;
	}

	if( pNode->m_pNext == NULL )
	{
		ATLASSERT( pNode == m_pTail );
		m_pTail = pNode->m_pPrev;
	}
	else
	{
		pNode->m_pNext->m_pPrev = pNode->m_pPrev;
	}
	ATLASSERT( pNode->m_pPrev != NULL );  // This node can't be the head, since we already checked that case
	pNode->m_pPrev->m_pNext = pNode->m_pNext;

	m_pHead->m_pPrev = pNode;
	pNode->m_pNext = m_pHead;
	pNode->m_pPrev = NULL;
	m_pHead = pNode;
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::MoveToTail( POSITION pos ) throw()
{
	ATLASSERT( pos != NULL );

	CNode* pNode = static_cast< CNode* >( pos );
	if( pNode == m_pTail )
	{
		// Already at the tail
		return;
	}

	if( pNode->m_pPrev == NULL )
	{
		ATLASSERT( pNode == m_pHead );
		m_pHead = pNode->m_pNext;
	}
	else
	{
		pNode->m_pPrev->m_pNext = pNode->m_pNext;
	}
	ATLASSERT( pNode->m_pNext != NULL );  // This node can't be the tail, since we already checked that case
	pNode->m_pNext->m_pPrev = pNode->m_pPrev;

	m_pTail->m_pNext = pNode;
	pNode->m_pPrev = m_pTail;
	pNode->m_pNext = NULL;
	m_pTail = pNode;
}

template< typename E, class ETraits >
void CAtlList< E, ETraits >::SwapElements( POSITION pos1, POSITION pos2 ) throw()
{
	ATLASSERT( pos1 != NULL );
	ATLASSERT( pos2 != NULL );

	if( pos1 == pos2 )
	{
		// Nothing to do
		return;
	}

	CNode* pNode1 = static_cast< CNode* >( pos1 );
	CNode* pNode2 = static_cast< CNode* >( pos2 );
	if( pNode2->m_pNext == pNode1 )
	{
		// Swap pNode2 and pNode1 so that the next case works
		CNode* pNodeTemp = pNode1;
		pNode1 = pNode2;
		pNode2 = pNodeTemp;
	}
	if( pNode1->m_pNext == pNode2 )
	{
		// Node1 and Node2 are adjacent
		pNode2->m_pPrev = pNode1->m_pPrev;
		if( pNode1->m_pPrev != NULL )
		{
			pNode1->m_pPrev->m_pNext = pNode2;
		}
		else
		{
			ATLASSERT( m_pHead == pNode1 );
			m_pHead = pNode2;
		}
		pNode1->m_pNext = pNode2->m_pNext;
		if( pNode2->m_pNext != NULL )
		{
			pNode2->m_pNext->m_pPrev = pNode1;
		}
		else
		{
			ATLASSERT( m_pTail == pNode2 );
			m_pTail = pNode1;
		}
		pNode2->m_pNext = pNode1;
		pNode1->m_pPrev = pNode2;
	}
	else
	{
		// The two nodes are not adjacent
		CNode* pNodeTemp;

		pNodeTemp = pNode1->m_pPrev;
		pNode1->m_pPrev = pNode2->m_pPrev;
		pNode2->m_pPrev = pNodeTemp;

		pNodeTemp = pNode1->m_pNext;
		pNode1->m_pNext = pNode2->m_pNext;
		pNode2->m_pNext = pNodeTemp;

		if( pNode1->m_pNext != NULL )
		{
			pNode1->m_pNext->m_pPrev = pNode1;
		}
		else
		{
			ATLASSERT( m_pTail == pNode2 );
			m_pTail = pNode1;
		}
		if( pNode1->m_pPrev != NULL )
		{
			pNode1->m_pPrev->m_pNext = pNode1;
		}
		else
		{
			ATLASSERT( m_pHead == pNode2 );
			m_pHead = pNode1;
		}
		if( pNode2->m_pNext != NULL )
		{
			pNode2->m_pNext->m_pPrev = pNode2;
		}
		else
		{
			ATLASSERT( m_pTail == pNode1 );
			m_pTail = pNode2;
		}
		if( pNode2->m_pPrev != NULL )
		{
			pNode2->m_pPrev->m_pNext = pNode2;
		}
		else
		{
			ATLASSERT( m_pHead == pNode1 );
			m_pHead = pNode2;
		}
	}
}

template< typename E, class ETraits >
POSITION CAtlList< E, ETraits >::Find( INARGTYPE element, POSITION posStartAfter ) const
{
	ATLASSERT_VALID(this);

	CNode* pNode = (CNode*)posStartAfter;
	if( pNode == NULL )
	{
		pNode = m_pHead;  // start at head
	}
	else
	{
		ATLASSERT(AtlIsValidAddress(pNode, sizeof(CNode)));
		pNode = pNode->m_pNext;  // start after the one specified
	}

	for( ; pNode != NULL; pNode = pNode->m_pNext )
	{
		if( ETraits::CompareElements( pNode->m_element, element ) )
			return( POSITION( pNode ) );
	}

	return( NULL );
}

#ifdef _DEBUG
template< typename E, class ETraits >
void CAtlList< E, ETraits >::AssertValid() const
{
	if( IsEmpty() )
	{
		// empty list
		ATLASSERT(m_pHead == NULL);
		ATLASSERT(m_pTail == NULL);
	}
	else
	{
		// non-empty list
		ATLASSERT(AtlIsValidAddress(m_pHead, sizeof(CNode)));
		ATLASSERT(AtlIsValidAddress(m_pTail, sizeof(CNode)));
	}
}
#endif

template< typename K, typename V, class KTraits = CElementTraits< K >, class VTraits = CElementTraits< V > >
class CAtlMap
{
public:
	typedef typename KTraits::INARGTYPE KINARGTYPE;
	typedef typename KTraits::OUTARGTYPE KOUTARGTYPE;
	typedef typename VTraits::INARGTYPE VINARGTYPE;
	typedef typename VTraits::OUTARGTYPE VOUTARGTYPE;

	class CPair :
		public __POSITION
	{
	protected:
		CPair( KINARGTYPE key ) :
			m_key( key )
		{
		}

	public:
		const K m_key;
		V m_value;
	};

private:
	class CNode :
		public CPair
	{
	public:
		CNode( KINARGTYPE key, UINT nHash ) :
			CPair( key ),
			m_nHash( nHash )
		{
		}

	public:
		UINT GetHash() const throw()
		{
			return( m_nHash );
		}

	public:
		CNode* m_pNext;
		UINT m_nHash;
	};

public:
	CAtlMap( UINT nBins = 17, float fOptimalLoad = 0.75f, 
		float fLoThreshold = 0.25f, float fHiThreshold = 2.25f, UINT nBlockSize = 10 ) throw();

	size_t GetCount() const throw();
	bool IsEmpty() const throw();

	bool Lookup( KINARGTYPE key, VOUTARGTYPE value ) const;
	const CPair* Lookup( KINARGTYPE key ) const throw();
	CPair* Lookup( KINARGTYPE key ) throw();
	V& operator[]( KINARGTYPE key ) throw();

	POSITION SetAt( KINARGTYPE key, VINARGTYPE value );
	void SetValueAt( POSITION pos, VINARGTYPE value );

	bool RemoveKey( KINARGTYPE key ) throw();
	void RemoveAll() throw();
	void RemoveAtPos( POSITION pos ) throw();

	POSITION GetStartPosition() const throw();
	void GetNextAssoc( POSITION& pos, KOUTARGTYPE key, VOUTARGTYPE value ) const;
	const CPair* GetNext( POSITION& pos ) const throw();
	CPair* GetNext( POSITION& pos ) throw();
	const K& GetNextKey( POSITION& pos ) const throw();
	const V& GetNextValue( POSITION& pos ) const throw();
	V& GetNextValue( POSITION& pos ) throw();
	void GetAt( POSITION pos, KOUTARGTYPE key, VOUTARGTYPE value ) const;
	CPair* GetAt( POSITION pos ) throw();
	const CPair* GetAt( POSITION pos ) const throw();
	const K& GetKeyAt( POSITION pos ) const throw();
	const V& GetValueAt( POSITION pos ) const throw();
	V& GetValueAt( POSITION pos ) throw();

	UINT GetHashTableSize() const throw();
	bool InitHashTable( UINT nBins, bool bAllocNow = true );
	void EnableAutoRehash() throw();
	void DisableAutoRehash() throw();
	void Rehash( UINT nBins = 0 );
	void SetOptimalLoad( float fOptimalLoad, float fLoThreshold, float fHiThreshold, 
		bool bRehashNow = false );

#ifdef _DEBUG
	void AssertValid() const;
#endif  // _DEBUG

// Implementation
private:
	CNode** m_ppBins;
	size_t m_nElements;
	UINT m_nBins;
	float m_fOptimalLoad;
	float m_fLoThreshold;
	float m_fHiThreshold;
	size_t m_nHiRehashThreshold;
	size_t m_nLoRehashThreshold;
	ULONG m_nLockCount;
	UINT m_nBlockSize;
	CAtlPlex* m_pBlocks;
	CNode* m_pFree;

private:
	bool IsLocked() const throw();
	UINT PickSize( size_t nElements ) const throw();
	CNode* NewNode( KINARGTYPE key, UINT iBin, UINT nHash );
	void FreeNode( CNode* pNode ) throw();
	void FreePlexes() throw();
	CNode* GetNode( KINARGTYPE key, UINT& iBin, UINT& nHash, CNode*& pPrev ) const throw();
	CNode* CreateNode( KINARGTYPE key, UINT iBin, UINT nHash );
	void RemoveNode( CNode* pNode, CNode* pPrev ) throw();
	CNode* FindNextNode( CNode* pNode ) const throw();
	void UpdateRehashThresholds() throw();

public:
	~CAtlMap() throw();

private:
	// Private to prevent use
	CAtlMap( const CAtlMap& ) throw();
	CAtlMap& operator=( const CAtlMap& ) throw();
};

template< typename K, typename I, class KTraits = CElementTraits< K > >
class CMapToInterface :
	public CAtlMap< K, ATL::CComQIPtr< I >, KTraits, CComQIPtrElementTraits< I > >
{
public:
	CMapToInterface( UINT nBins = 17 ) throw();

private:
	// Private to prevent use
	CMapToInterface( const CMapToInterface& ) throw();
	CMapToInterface& operator=( const CMapToInterface& ) throw();
};

template< typename K, typename I, class KTraits >
inline CMapToInterface< K, I, KTraits >::CMapToInterface( UINT nBins ) :
	CAtlMap< K, ATL::CComQIPtr< I >, KTraits, CComQIPtrElementTraits< I > >( nBins )
{
}

template< typename K, typename V, class KTraits = CElementTraits< K > >
class CMapToAutoPtr :
	public CAtlMap< K, ATL::CAutoPtr< V >, KTraits, CAutoPtrElementTraits< V > >
{
public:
	CMapToAutoPtr( UINT nBins = 17 ) throw();

private:
	// Private to prevent use
	CMapToAutoPtr( const CMapToAutoPtr& ) throw();
	CMapToAutoPtr& operator=( const CMapToAutoPtr& ) throw();
};

template< typename K, typename V, class KTraits >
inline CMapToAutoPtr< K, V, KTraits >::CMapToAutoPtr( UINT nBins ) :
	CAtlMap< K, ATL::CAutoPtr< V >, KTraits, CAutoPtrElementTraits< V > >( nBins )
{
}

template< typename K, typename V, class KTraits, class VTraits >
inline size_t CAtlMap< K, V, KTraits, VTraits >::GetCount() const
{
	return( m_nElements );
}

template< typename K, typename V, class KTraits, class VTraits >
inline bool CAtlMap< K, V, KTraits, VTraits >::IsEmpty() const
{
	return( m_nElements == 0 );
}

template< typename K, typename V, class KTraits, class VTraits >
inline V& CAtlMap< K, V, KTraits, VTraits >::operator[]( KINARGTYPE key )
{
	CNode* pNode;
	UINT iBin;
	UINT nHash;
	CNode* pPrev;

	pNode = GetNode( key, iBin, nHash, pPrev );
	if( pNode == NULL )
	{
		pNode = CreateNode( key, iBin, nHash );
	}

	return( pNode->m_value );
}

template< typename K, typename V, class KTraits, class VTraits >
inline UINT CAtlMap< K, V, KTraits, VTraits >::GetHashTableSize() const
{
	return( m_nBins );
}

template< typename K, typename V, class KTraits, class VTraits >
inline void CAtlMap< K, V, KTraits, VTraits >::GetAt( POSITION pos, KOUTARGTYPE key, VOUTARGTYPE value ) const
{
	CNode* pNode;

	ATLASSERT( pos != NULL );

	pNode = static_cast< CNode* >( pos );
	key = pNode->m_key;
	value = pNode->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
inline CAtlMap< K, V, KTraits, VTraits >::CPair* CAtlMap< K, V, KTraits, VTraits >::GetAt( POSITION pos ) throw()
{
	ATLASSERT( pos != NULL );

	return( static_cast< CPair* >( pos ) );
}

template< typename K, typename V, class KTraits, class VTraits >
inline const CAtlMap< K, V, KTraits, VTraits >::CPair* CAtlMap< K, V, KTraits, VTraits >::GetAt( POSITION pos ) const throw()
{
	ATLASSERT( pos != NULL );

	return( static_cast< const CPair* >( pos ) );
}

template< typename K, typename V, class KTraits, class VTraits >
inline const K& CAtlMap< K, V, KTraits, VTraits >::GetKeyAt( POSITION pos ) const
{
	CNode* pNode;

	ATLASSERT( pos != NULL );
	
	pNode = (CNode*)pos;

	return( pNode->m_key );
}

template< typename K, typename V, class KTraits, class VTraits >
inline const V& CAtlMap< K, V, KTraits, VTraits >::GetValueAt( POSITION pos ) const
{
	CNode* pNode;

	ATLASSERT( pos != NULL );
	
	pNode = (CNode*)pos;

	return( pNode->m_value );
}

template< typename K, typename V, class KTraits, class VTraits >
inline V& CAtlMap< K, V, KTraits, VTraits >::GetValueAt( POSITION pos )
{
	CNode* pNode;

	ATLASSERT( pos != NULL );
	
	pNode = (CNode*)pos;

	return( pNode->m_value );
}

template< typename K, typename V, class KTraits, class VTraits >
inline void CAtlMap< K, V, KTraits, VTraits >::DisableAutoRehash() throw()
{
	m_nLockCount++;
}

template< typename K, typename V, class KTraits, class VTraits >
inline void CAtlMap< K, V, KTraits, VTraits >::EnableAutoRehash() throw()
{
	ATLASSERT( m_nLockCount > 0 );
	m_nLockCount--;
}

template< typename K, typename V, class KTraits, class VTraits >
inline bool CAtlMap< K, V, KTraits, VTraits >::IsLocked() const
{
	return( m_nLockCount != 0 );
}

template< typename K, typename V, class KTraits, class VTraits >
UINT CAtlMap< K, V, KTraits, VTraits >::PickSize( size_t nElements ) const
{
	// List of primes such that s_anPrimes[i] is the smallest prime greater than 2^(5+i/3)
	static const UINT s_anPrimes[] =
	{
		17, 23, 29, 37, 41, 53, 67, 83, 103, 131, 163, 211, 257, 331, 409, 521, 647, 821, 
		1031, 1291, 1627, 2053, 2591, 3251, 4099, 5167, 6521, 8209, 10331, 
		13007, 16411, 20663, 26017, 32771, 41299, 52021, 65537, 82571, 104033, 
		131101, 165161, 208067, 262147, 330287, 416147, 524309, 660563, 
		832291, 1048583, 1321139, 1664543, 2097169, 2642257, 3329023, 4194319, 
		5284493, 6658049, 8388617, 10568993, 13316089, UINT_MAX
	};

	UINT nBinsEstimate = UINT( min( UINT_MAX, (size_t)(nElements/m_fOptimalLoad) ) );

	// Find the smallest prime greater than our estimate
	int iPrime = 0;
	while( nBinsEstimate > s_anPrimes[iPrime] )
	{
		iPrime++;
	}

	if( s_anPrimes[iPrime] == UINT_MAX )
	{
		return( nBinsEstimate );
	}
	else
	{
		return( s_anPrimes[iPrime] );
	}
}

template< typename K, typename V, class KTraits, class VTraits >
CAtlMap< K, V, KTraits, VTraits >::CNode* CAtlMap< K, V, KTraits, VTraits >::CreateNode( 
	KINARGTYPE key, UINT iBin, UINT nHash )
{
	CNode* pNode;

	if( m_ppBins == NULL )
	{
		bool bSuccess;

		bSuccess = InitHashTable( m_nBins );
		if( !bSuccess )
		{
			ATL::AtlThrow( E_OUTOFMEMORY );
		}
	}

	pNode = NewNode( key, iBin, nHash );

	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CAtlMap< K, V, KTraits, VTraits >::GetStartPosition() const
{
	if( IsEmpty() )
	{
		return( NULL );
	}

	for( UINT iBin = 0; iBin < m_nBins; iBin++ )
	{
		if( m_ppBins[iBin] != NULL )
		{
			return( POSITION( m_ppBins[iBin] ) );
		}
	}
	ATLASSERT( false );

	return( NULL );
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CAtlMap< K, V, KTraits, VTraits >::SetAt( KINARGTYPE key, VINARGTYPE value )
{
	CNode* pNode;
	UINT iBin;
	UINT nHash;
	CNode* pPrev;

	pNode = GetNode( key, iBin, nHash, pPrev );
	if( pNode == NULL )
	{
		pNode = CreateNode( key, iBin, nHash );
		_ATLTRY
		{
			pNode->m_value = value;
		}
		_ATLCATCHALL()
		{
			RemoveAtPos( POSITION( pNode ) );
			_ATLRETHROW;
		}
	}
	else
	{
		pNode->m_value = value;
	}

	return( POSITION( pNode ) );
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::SetValueAt( POSITION pos, VINARGTYPE value )
{
	ATLASSERT( pos != NULL );

	CNode* pNode = static_cast< CNode* >( pos );
	pNode->m_value = value;
}

template< typename K, typename V, class KTraits, class VTraits >
CAtlMap< K, V, KTraits, VTraits >::CAtlMap( UINT nBins, float fOptimalLoad, 
	float fLoThreshold, float fHiThreshold, UINT nBlockSize ) :
	m_ppBins( NULL ),
	m_nBins( nBins ),
	m_nElements( 0 ),
	m_nLockCount( 0 ),  // Start unlocked
	m_fOptimalLoad( fOptimalLoad ),
	m_fLoThreshold( fLoThreshold ),
	m_fHiThreshold( fHiThreshold ),
	m_nHiRehashThreshold( UINT_MAX ),
	m_nLoRehashThreshold( 0 ),
	m_pBlocks( NULL ),
	m_pFree( NULL ),
	m_nBlockSize( nBlockSize )
{
	ATLASSERT( nBins > 0 );
	ATLASSERT( nBlockSize > 0 );

	SetOptimalLoad( fOptimalLoad, fLoThreshold, fHiThreshold, false );
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::SetOptimalLoad( float fOptimalLoad, float fLoThreshold,
	float fHiThreshold, bool bRehashNow )
{
	ATLASSERT( fOptimalLoad > 0 );
	ATLASSERT( (fLoThreshold >= 0) && (fLoThreshold < fOptimalLoad) );
	ATLASSERT( fHiThreshold > fOptimalLoad );

	m_fOptimalLoad = fOptimalLoad;
	m_fLoThreshold = fLoThreshold;
	m_fHiThreshold = fHiThreshold;

	UpdateRehashThresholds();

	if( bRehashNow && ((m_nElements > m_nHiRehashThreshold) || 
		(m_nElements < m_nLoRehashThreshold)) )
	{
		Rehash( PickSize( m_nElements ) );
	}
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::UpdateRehashThresholds() throw()
{
	m_nHiRehashThreshold = size_t( m_fHiThreshold*m_nBins );
	m_nLoRehashThreshold = size_t( m_fLoThreshold*m_nBins );
	if( m_nLoRehashThreshold < 17 )
	{
		m_nLoRehashThreshold = 0;
	}
}

template< typename K, typename V, class KTraits, class VTraits >
bool CAtlMap< K, V, KTraits, VTraits >::InitHashTable( UINT nBins, bool bAllocNow )
{
	ATLASSERT( m_nElements == 0 );
	ATLASSERT( nBins > 0 );

	if( m_ppBins != NULL )
	{
		delete[] m_ppBins;
		m_ppBins = NULL;
	}

	if( bAllocNow )
	{
		ATLTRY( m_ppBins = new CNode*[nBins] );
		if( m_ppBins == NULL )
		{
			return false;
		}
		memset( m_ppBins, 0, sizeof( CNode* )*nBins );
	}
	m_nBins = nBins;

	UpdateRehashThresholds();

	return true;
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::RemoveAll()
{
	DisableAutoRehash();
	if( m_ppBins != NULL )
	{
		for( UINT iBin = 0; iBin < m_nBins; iBin++ )
		{
			CNode* pNext;

			pNext = m_ppBins[iBin];
			while( pNext != NULL )
			{
				CNode* pKill;

				pKill = pNext;
				pNext = pNext->m_pNext;
				FreeNode( pKill );
			}
		}
	}

	delete[] m_ppBins;
	m_ppBins = NULL;
	m_nElements = 0;

	if( !IsLocked() )
	{
		InitHashTable( PickSize( m_nElements ), false );
	}

	FreePlexes();
	EnableAutoRehash();
}

template< typename K, typename V, class KTraits, class VTraits >
CAtlMap< K, V, KTraits, VTraits >::~CAtlMap()
{
	RemoveAll();
}

#pragma push_macro("new")
#undef new

template< typename K, typename V, class KTraits, class VTraits >
CAtlMap< K, V, KTraits, VTraits >::CNode* CAtlMap< K, V, KTraits, VTraits >::NewNode( 
	KINARGTYPE key, UINT iBin, UINT nHash )
{
	CNode* pNewNode;

	if( m_pFree == NULL )
	{
		CAtlPlex* pPlex;
		CNode* pNode;

		pPlex = CAtlPlex::Create( m_pBlocks, m_nBlockSize, sizeof( CNode ) );
		if( pPlex == NULL )
		{
			ATL::AtlThrow( E_OUTOFMEMORY );
		}
		pNode = (CNode*)pPlex->data();
		pNode += m_nBlockSize-1;
		for( int iBlock = m_nBlockSize-1; iBlock >= 0; iBlock-- )
		{
			pNode->m_pNext = m_pFree;
			m_pFree = pNode;
			pNode--;
		}
	}
	ATLASSERT( m_pFree != NULL );
	pNewNode = m_pFree;
	m_pFree = pNewNode->m_pNext;

	_ATLTRY
	{
		::new( pNewNode ) CNode( key, nHash );
	}
	_ATLCATCHALL()
	{
		pNewNode->m_pNext = m_pFree;
		m_pFree = pNewNode;

		_ATLRETHROW;
	}
	m_nElements++;

	pNewNode->m_pNext = m_ppBins[iBin];
	m_ppBins[iBin] = pNewNode;

	if( (m_nElements > m_nHiRehashThreshold) && !IsLocked() )
	{
		Rehash( PickSize( m_nElements ) );
	}

	return( pNewNode );
}

#pragma pop_macro("new")

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::FreeNode( CNode* pNode )
{
	ATLASSERT( pNode != NULL );

	pNode->~CNode();
	pNode->m_pNext = m_pFree;
	m_pFree = pNode;

	ATLASSERT( m_nElements > 0 );
	m_nElements--;

	if( (m_nElements < m_nLoRehashThreshold) && !IsLocked() )
	{
		Rehash( PickSize( m_nElements ) );
	}

	if( m_nElements == 0 )
	{
		FreePlexes();
	}
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::FreePlexes() throw()
{
	m_pFree = NULL;
	if( m_pBlocks != NULL )
	{
		m_pBlocks->FreeDataChain();
		m_pBlocks = NULL;
	}
}

template< typename K, typename V, class KTraits, class VTraits >
CAtlMap< K, V, KTraits, VTraits >::CNode* CAtlMap< K, V, KTraits, VTraits >::GetNode(
	KINARGTYPE key, UINT& iBin, UINT& nHash, CNode*& pPrev ) const
{
	CNode* pFollow;

	nHash = KTraits::Hash( key );
	iBin = nHash%m_nBins;

	if( m_ppBins == NULL )
	{
		return( NULL );
	}

	pFollow = NULL;
	pPrev = NULL;
	for( CNode* pNode = m_ppBins[iBin]; pNode != NULL; pNode = pNode->m_pNext )
	{
		if( (pNode->GetHash() == nHash) && KTraits::CompareElements( pNode->m_key, key ) )
		{
			pPrev = pFollow;
			return( pNode );
		}
		pFollow = pNode;
	}

	return( NULL );
}

template< typename K, typename V, class KTraits, class VTraits >
bool CAtlMap< K, V, KTraits, VTraits >::Lookup( KINARGTYPE key, VOUTARGTYPE value ) const
{
	UINT iBin;
	UINT nHash;
	CNode* pNode;
	CNode* pPrev;

	pNode = GetNode( key, iBin, nHash, pPrev );
	if( pNode == NULL )
	{
		return( false );
	}

	value = pNode->m_value;

	return( true );
}

template< typename K, typename V, class KTraits, class VTraits >
const CAtlMap< K, V, KTraits, VTraits >::CPair* CAtlMap< K, V, KTraits, VTraits >::Lookup( KINARGTYPE key ) const
{
	UINT iBin;
	UINT nHash;
	CNode* pNode;
	CNode* pPrev;

	pNode = GetNode( key, iBin, nHash, pPrev );
	
	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
CAtlMap< K, V, KTraits, VTraits >::CPair* CAtlMap< K, V, KTraits, VTraits >::Lookup( KINARGTYPE key )
{
	UINT iBin;
	UINT nHash;
	CNode* pNode;
	CNode* pPrev;

	pNode = GetNode( key, iBin, nHash, pPrev );
	
	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
bool CAtlMap< K, V, KTraits, VTraits >::RemoveKey( KINARGTYPE key )
{
	CNode* pNode;
	UINT iBin;
	UINT nHash;
	CNode* pPrev;

	pPrev = NULL;
	pNode = GetNode( key, iBin, nHash, pPrev );
	if( pNode == NULL )
	{
		return( false );
	}

	RemoveNode( pNode, pPrev );

	return( true );
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::RemoveNode( CNode* pNode, CNode* pPrev )
{
	UINT iBin;

	ATLASSERT( pNode != NULL );

	iBin = pNode->GetHash()%m_nBins;
	if( pPrev == NULL )
	{
		ATLASSERT( m_ppBins[iBin] == pNode );
		m_ppBins[iBin] = pNode->m_pNext;
	}
	else
	{
		ATLASSERT( pPrev->m_pNext == pNode );
		pPrev->m_pNext = pNode->m_pNext;
	}
	FreeNode( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::RemoveAtPos( POSITION pos )
{
	CNode* pNode;
	CNode* pPrev;
	UINT iBin;

	ATLASSERT( pos != NULL );
	pNode = static_cast< CNode* >( pos );
	iBin = pNode->GetHash()%m_nBins;

	ATLASSERT( m_ppBins[iBin] != NULL );
	if( pNode == m_ppBins[iBin] )
	{
		pPrev = NULL;
	}
	else
	{
		pPrev = m_ppBins[iBin];
		while( pPrev->m_pNext != pNode )
		{
			pPrev = pPrev->m_pNext;
			ATLASSERT( pPrev != NULL );
		}
	}
	RemoveNode( pNode, pPrev );
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::Rehash( UINT nBins )
{
	CNode** ppBins = NULL;

	if( nBins == 0 )
	{
		nBins = PickSize( m_nElements );
	}

	if( nBins == m_nBins )
	{
		return;
	}

	ATLTRACE(atlTraceMap, 2, _T("Rehash: %u bins\n"), nBins );

	if( m_ppBins == NULL )
	{
		// Just set the new number of bins
		InitHashTable( nBins, false );
		return;
	}

	ATLTRY(ppBins = new CNode*[nBins]);
	if (ppBins == NULL)
	{
		ATL::AtlThrow( E_OUTOFMEMORY );
	}

	memset( ppBins, 0, nBins*sizeof( CNode* ) );

	// Nothing gets copied.  We just rewire the old nodes
	// into the new bins.
	for( UINT iSrcBin = 0; iSrcBin < m_nBins; iSrcBin++ )
	{
		CNode* pNode;

		pNode = m_ppBins[iSrcBin];
		while( pNode != NULL )
		{
			CNode* pNext;
			UINT iDestBin;

			pNext = pNode->m_pNext;  // Save so we don't trash it
			iDestBin = pNode->GetHash()%nBins;
			pNode->m_pNext = ppBins[iDestBin];
			ppBins[iDestBin] = pNode;

			pNode = pNext;
		}
	}

	delete[] m_ppBins;
	m_ppBins = ppBins;
	m_nBins = nBins;

	UpdateRehashThresholds();
}

template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::GetNextAssoc( POSITION& pos, KOUTARGTYPE key,
	VOUTARGTYPE value ) const
{
	CNode* pNode;
	CNode* pNext;

	ATLASSERT( m_ppBins != NULL );
	ATLASSERT( pos != NULL );

	pNode = (CNode*)pos;
	pNext = FindNextNode( pNode );

	pos = POSITION( pNext );
	key = pNode->m_key;
	value = pNode->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
const CAtlMap< K, V, KTraits, VTraits >::CPair* CAtlMap< K, V, KTraits, VTraits >::GetNext( POSITION& pos ) const
{
	CNode* pNode;
	CNode* pNext;

	ATLASSERT( m_ppBins != NULL );
	ATLASSERT( pos != NULL );

	pNode = (CNode*)pos;
	pNext = FindNextNode( pNode );

	pos = POSITION( pNext );

	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
CAtlMap< K, V, KTraits, VTraits >::CPair* CAtlMap< K, V, KTraits, VTraits >::GetNext( 
	POSITION& pos ) throw()
{
	ATLASSERT( m_ppBins != NULL );
	ATLASSERT( pos != NULL );

	CNode* pNode = static_cast< CNode* >( pos );
	CNode* pNext = FindNextNode( pNode );

	pos = POSITION( pNext );

	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
const K& CAtlMap< K, V, KTraits, VTraits >::GetNextKey( POSITION& pos ) const
{
	CNode* pNode;
	CNode* pNext;

	ATLASSERT( m_ppBins != NULL );
	ATLASSERT( pos != NULL );

	pNode = (CNode*)pos;
	pNext = FindNextNode( pNode );

	pos = POSITION( pNext );
	
	return( pNode->m_key );
}

template< typename K, typename V, class KTraits, class VTraits >
const V& CAtlMap< K, V, KTraits, VTraits >::GetNextValue( POSITION& pos ) const
{
	CNode* pNode;
	CNode* pNext;

	ATLASSERT( m_ppBins != NULL );
	ATLASSERT( pos != NULL );

	pNode = (CNode*)pos;
	pNext = FindNextNode( pNode );

	pos = POSITION( pNext );
	
	return( pNode->m_value );
}

template< typename K, typename V, class KTraits, class VTraits >
V& CAtlMap< K, V, KTraits, VTraits >::GetNextValue( POSITION& pos )
{
	CNode* pNode;
	CNode* pNext;

	ATLASSERT( m_ppBins != NULL );
	ATLASSERT( pos != NULL );

	pNode = (CNode*)pos;
	pNext = FindNextNode( pNode );

	pos = POSITION( pNext );
	
	return( pNode->m_value );
}

template< typename K, typename V, class KTraits, class VTraits >
CAtlMap< K, V, KTraits, VTraits >::CNode* CAtlMap< K, V, KTraits, VTraits >::FindNextNode( CNode* pNode ) const
{
	CNode* pNext;

	if( pNode->m_pNext != NULL )
	{
		pNext = pNode->m_pNext;
	}
	else
	{
		UINT iBin;

		pNext = NULL;
		iBin = (pNode->GetHash()%m_nBins)+1;
		while( (pNext == NULL) && (iBin < m_nBins) )
		{
			if( m_ppBins[iBin] != NULL )
			{
				pNext = m_ppBins[iBin];
			}

			iBin++;
		}
	}

	return( pNext );
}

#ifdef _DEBUG
template< typename K, typename V, class KTraits, class VTraits >
void CAtlMap< K, V, KTraits, VTraits >::AssertValid() const
{
	ATLASSERT( m_nBins > 0 );
	// non-empty map should have hash table
	ATLASSERT( IsEmpty() || (m_ppBins != NULL) );
}
#endif

#pragma push_macro("new")
#undef new

//
// The red-black tree code is based on the the descriptions in
// "Introduction to Algorithms", by Cormen, Leiserson, and Rivest
//
template< typename K, typename V, class KTraits = CElementTraits< K >, class VTraits = CElementTraits< V > >
class CRBTree
{
public:
	typedef typename KTraits::INARGTYPE KINARGTYPE;
	typedef typename KTraits::OUTARGTYPE KOUTARGTYPE;
	typedef typename VTraits::INARGTYPE VINARGTYPE;
	typedef typename VTraits::OUTARGTYPE VOUTARGTYPE;

public:
	class CPair : 
		public __POSITION
	{
	protected:

		CPair( KINARGTYPE key, VINARGTYPE value ) : 
			m_key( key ),
			m_value( value )
		{
		}
		~CPair() throw()
		{
		}

	public:
		const K m_key;
		V m_value;
	};

private:

	class CNode : 
		public CPair
	{
	public:
		enum RB_COLOR
		{
			RB_RED, 
			RB_BLACK
		};

	public:
		RB_COLOR m_eColor;
		CNode* m_pLeft;
		CNode* m_pRight;
		CNode* m_pParent;

		CNode( KINARGTYPE key, VINARGTYPE value ) : 
			CPair( key, value ),
			m_pParent( NULL ),
			m_eColor( RB_BLACK )
		{
		}
		~CNode() throw()
		{
		}
	};

private:
	CNode* m_pRoot;
	size_t m_nCount;
	CNode* m_pFree;
	CAtlPlex* m_pBlocks;
	size_t m_nBlockSize;

	// sentinel node
	CNode *m_pNil;

	// methods
	bool IsNil(CNode *p) const throw();
	void SetNil(CNode **p) throw();

	CNode* NewNode( KINARGTYPE key, VINARGTYPE value ) throw( ... );
	void FreeNode(CNode* pNode) throw();
	void RemovePostOrder(CNode* pNode) throw();
	CNode* LeftRotate(CNode* pNode) throw();
	CNode* RightRotate(CNode* pNode) throw();
	void SwapNode(CNode* pDest, CNode* pSrc) throw();
	CNode* InsertImpl( KINARGTYPE key, VINARGTYPE value ) throw( ... );
	void RBDeleteFixup(CNode* pNode) throw();
	bool RBDelete(CNode* pZ) throw();

#ifdef _DEBUG

	// internal debugging code to verify red-black properties of tree:
	// 1) Every node is either red or black
	// 2) Every leaf (NIL) is black
	// 3) If a node is red, both its children are black
	// 4) Every simple path from a node to a descendant leaf node contains 
	//    the same number of black nodes
private:
	void VerifyIntegrity(const CNode *pNode, int nCurrBlackDepth, int &nBlackDepth) const throw();

public:
	void VerifyIntegrity() const throw();

#endif // _DEBUG
	
protected:
	CNode* Minimum(CNode* pNode) const throw();
	CNode* Maximum(CNode* pNode) const throw();
	CNode* Predecessor( CNode* pNode ) const throw();
	CNode* Successor(CNode* pNode) const throw();
	CNode* RBInsert( KINARGTYPE key, VINARGTYPE value ) throw( ... );
	CNode* Find(KINARGTYPE key) const throw();
	CNode* FindPrefix( KINARGTYPE key ) const throw();

protected:
	explicit CRBTree( size_t nBlockSize = 10 ) throw();  // protected to prevent instantiation

public:
	~CRBTree() throw();

	void RemoveAll() throw();
	void RemoveAt(POSITION pos) throw();

	size_t GetCount() const throw();
	bool IsEmpty() const throw();

	POSITION FindFirstKeyAfter( KINARGTYPE key ) const throw();

	POSITION GetHeadPosition() const throw();
	POSITION GetTailPosition() const throw();
	void GetNextAssoc( POSITION& pos, KOUTARGTYPE key, VOUTARGTYPE value ) const;
	const CPair* GetNext(POSITION& pos) const throw();
	CPair* GetNext(POSITION& pos) throw();
	const CPair* GetPrev(POSITION& pos) const throw();
	CPair* GetPrev(POSITION& pos) throw();
	const K& GetNextKey(POSITION& pos) const throw();
	const V& GetNextValue(POSITION& pos) const throw();
	V& GetNextValue(POSITION& pos) throw();

	CPair* GetAt( POSITION pos ) throw();
	const CPair* GetAt( POSITION pos ) const throw();
	void GetAt(POSITION pos, KOUTARGTYPE key, VOUTARGTYPE value) const;
	const K& GetKeyAt(POSITION pos) const throw();
	const V& GetValueAt(POSITION pos) const throw();
	V& GetValueAt(POSITION pos) throw();
	void SetValueAt(POSITION pos, VINARGTYPE value);

private:
	// Private to prevent use
	CRBTree( const CRBTree& ) throw();
	CRBTree& operator=( const CRBTree& ) throw();
};

template< typename K, typename V, class KTraits, class VTraits >
inline bool CRBTree< K, V, KTraits, VTraits >::IsNil(CNode *p) const
{
	return ( p == m_pNil );
}

template< typename K, typename V, class KTraits, class VTraits >
inline void CRBTree< K, V, KTraits, VTraits >::SetNil(CNode **p)
{
	ATLASSERT( p != NULL );

	*p = m_pNil;
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CRBTree( size_t nBlockSize ) throw() :
	m_pRoot( NULL ),
	m_nCount( 0 ),
	m_nBlockSize( nBlockSize ),
	m_pFree( NULL ),
	m_pBlocks( NULL ),
	m_pNil( NULL )
{
	ATLASSERT( nBlockSize > 0 );
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::~CRBTree() throw()
{
	RemoveAll();
	if (m_pNil != NULL)
	{
		free(m_pNil);
	}
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::RemoveAll() throw()
{
	if (!IsNil(m_pRoot))
		RemovePostOrder(m_pRoot);
	m_nCount = 0;
	m_pBlocks->FreeDataChain();
	m_pBlocks = NULL;
	m_pFree = NULL;
	m_pRoot = m_pNil;
}

template< typename K, typename V, class KTraits, class VTraits >
size_t CRBTree< K, V, KTraits, VTraits >::GetCount() const throw()
{
	return m_nCount;
}

template< typename K, typename V, class KTraits, class VTraits >
bool CRBTree< K, V, KTraits, VTraits >::IsEmpty() const throw()
{
	return( m_nCount == 0 );
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CRBTree< K, V, KTraits, VTraits >::FindFirstKeyAfter( KINARGTYPE key ) const throw()
{
	return( FindPrefix( key ) );
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::RemoveAt(POSITION pos) throw()
{
	ATLASSERT(pos != NULL);
	RBDelete(static_cast<CNode*>(pos));
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CRBTree< K, V, KTraits, VTraits >::GetHeadPosition() const throw()
{
	return( Minimum( m_pRoot ) );
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CRBTree< K, V, KTraits, VTraits >::GetTailPosition() const throw()
{
	return( Maximum( m_pRoot ) );
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::GetNextAssoc( POSITION& pos, KOUTARGTYPE key, VOUTARGTYPE value ) const
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast< CNode* >(pos);
	
	key = pNode->m_key;
	value = pNode->m_value;

	pos = Successor(pNode);
}

template< typename K, typename V, class KTraits, class VTraits >
const CRBTree< K, V, KTraits, VTraits >::CPair* CRBTree< K, V, KTraits, VTraits >::GetNext(POSITION& pos) const throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast< CNode* >(pos);
	pos = Successor(pNode);
	return pNode;
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CPair* CRBTree< K, V, KTraits, VTraits >::GetNext(POSITION& pos) throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast< CNode* >(pos);
	pos = Successor(pNode);
	return pNode;
}

template< typename K, typename V, class KTraits, class VTraits >
const CRBTree< K, V, KTraits, VTraits >::CPair* CRBTree< K, V, KTraits, VTraits >::GetPrev(POSITION& pos) const throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast< CNode* >(pos);
	pos = Predecessor(pNode);
	
	return pNode;
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CPair* CRBTree< K, V, KTraits, VTraits >::GetPrev(POSITION& pos) throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast< CNode* >(pos);
	pos = Predecessor(pNode);
	
	return pNode;
}

template< typename K, typename V, class KTraits, class VTraits >
const K& CRBTree< K, V, KTraits, VTraits >::GetNextKey(POSITION& pos) const throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast<CNode*>(pos);
	pos = Successor(pNode);
	
	return pNode->m_key;
}

template< typename K, typename V, class KTraits, class VTraits >
const V& CRBTree< K, V, KTraits, VTraits >::GetNextValue(POSITION& pos) const throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast<CNode*>(pos);
	pos = Successor(pNode);
	
	return pNode->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
V& CRBTree< K, V, KTraits, VTraits >::GetNextValue(POSITION& pos) throw()
{
	ATLASSERT(pos != NULL);
	CNode* pNode = static_cast<CNode*>(pos);
	pos = Successor(pNode);
	
	return pNode->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CPair* CRBTree< K, V, KTraits, VTraits >::GetAt( POSITION pos ) throw()
{
	ATLASSERT( pos != NULL );

	return( static_cast< CPair* >( pos ) );
}

template< typename K, typename V, class KTraits, class VTraits >
const CRBTree< K, V, KTraits, VTraits >::CPair* CRBTree< K, V, KTraits, VTraits >::GetAt( POSITION pos ) const throw()
{
	ATLASSERT( pos != NULL );

	return( static_cast< const CPair* >( pos ) );
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::GetAt(POSITION pos, KOUTARGTYPE key, VOUTARGTYPE value) const
{
	ATLASSERT(pos != NULL);
	key = static_cast<CNode*>(pos)->m_key;
	value = static_cast<CNode*>(pos)->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
const K& CRBTree< K, V, KTraits, VTraits >::GetKeyAt(POSITION pos) const throw()
{
	ATLASSERT(pos != NULL);
	return static_cast<CNode*>(pos)->m_key;
}

template< typename K, typename V, class KTraits, class VTraits >
const V& CRBTree< K, V, KTraits, VTraits >::GetValueAt(POSITION pos) const throw()
{
	ATLASSERT(pos != NULL);
	return static_cast<CNode*>(pos)->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
V& CRBTree< K, V, KTraits, VTraits >::GetValueAt(POSITION pos) throw()
{
	ATLASSERT(pos != NULL);
	return static_cast<CNode*>(pos)->m_value;
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::SetValueAt(POSITION pos, VINARGTYPE value)
{
	ATLASSERT(pos != NULL);
	static_cast<CNode*>(pos)->m_value = value;
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::NewNode( KINARGTYPE key, VINARGTYPE value ) throw( ... )
{
	if( m_pFree == NULL )
	{
		if (m_pNil == NULL)
		{
			m_pNil = reinterpret_cast<CNode *>(malloc(sizeof( CNode )));
			if (m_pNil == NULL)
			{
				AtlThrow( E_OUTOFMEMORY );
			}
			memset(m_pNil, 0x00, sizeof(CNode));
			m_pNil->m_eColor = CNode::RB_BLACK;
			m_pNil->m_pParent = m_pNil->m_pLeft = m_pNil->m_pRight = m_pNil;
			m_pRoot = m_pNil;
		}

		CAtlPlex* pPlex = CAtlPlex::Create( m_pBlocks, m_nBlockSize, sizeof( CNode ) );
		if( pPlex == NULL )
		{
			AtlThrow( E_OUTOFMEMORY );
		}
		CNode* pNode = static_cast< CNode* >( pPlex->data() );
		pNode += m_nBlockSize-1;
		for( INT_PTR iBlock = m_nBlockSize-1; iBlock >= 0; iBlock-- )
		{
			pNode->m_pLeft = m_pFree;
			m_pFree = pNode;
			pNode--;
		}
	}
	ATLASSERT( m_pFree != NULL );
	
	CNode* pNewNode = m_pFree;
	::new( pNewNode ) CNode( key, value );

	m_pFree = m_pFree->m_pLeft;
	pNewNode->m_eColor = CNode::RB_RED;
	SetNil(&pNewNode->m_pLeft);
	SetNil(&pNewNode->m_pRight);
	SetNil(&pNewNode->m_pParent);

	m_nCount++;
	ATLASSERT( m_nCount > 0 );

	return( pNewNode );
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::FreeNode(CNode* pNode) throw()
{
	ATLASSERT(pNode != NULL);
	pNode->~CNode();
	pNode->m_pLeft = m_pFree;
	m_pFree = pNode;
	ATLASSERT( m_nCount > 0 );
	m_nCount--;
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::RemovePostOrder(CNode* pNode) throw()
{
	if (IsNil(pNode))
		return;
	RemovePostOrder(pNode->m_pLeft);
	RemovePostOrder(pNode->m_pRight);
	FreeNode( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::LeftRotate(CNode* pNode) throw()
{
	ATLASSERT(pNode != NULL);
	CNode* pRight = pNode->m_pRight;
	pNode->m_pRight = pRight->m_pLeft;
	if (!IsNil(pRight->m_pLeft))
		pRight->m_pLeft->m_pParent = pNode;

	pRight->m_pParent = pNode->m_pParent;
	if (IsNil(pNode->m_pParent))
		m_pRoot = pRight;
	else if (pNode == pNode->m_pParent->m_pLeft)
		pNode->m_pParent->m_pLeft = pRight;
	else 
		pNode->m_pParent->m_pRight = pRight;

	pRight->m_pLeft = pNode;
	pNode->m_pParent = pRight;
	return pNode;

}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::RightRotate(CNode* pNode) throw()
{
	ATLASSERT(pNode != NULL);
	CNode* pLeft = pNode->m_pLeft;
	pNode->m_pLeft = pLeft->m_pRight;
	if (!IsNil(pLeft->m_pRight))
		pLeft->m_pRight->m_pParent = pNode;

	pLeft->m_pParent = pNode->m_pParent;
	if (IsNil(pNode->m_pParent))
		m_pRoot = pLeft;
	else if (pNode == pNode->m_pParent->m_pRight)
		pNode->m_pParent->m_pRight = pLeft;
	else
		pNode->m_pParent->m_pLeft = pLeft;

	pLeft->m_pRight = pNode;
	pNode->m_pParent = pLeft;
	return pNode;
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::Find(KINARGTYPE key) const throw()
{
	CNode* pKey = NULL;
	CNode* pNode = m_pRoot;
	while( !IsNil(pNode) && (pKey == NULL) )
	{
		int nCompare = KTraits::CompareElementsOrdered( key, pNode->m_key );
		if( nCompare == 0 )
		{
			pKey = pNode;
		}
		else
		{
			if( nCompare < 0 )
			{
				pNode = pNode->m_pLeft;
			}
			else
			{
				pNode = pNode->m_pRight;
			}
		}
	}

	if( pKey == NULL )
	{
		return( NULL );
	}

#pragma warning(push)
#pragma warning(disable:4127)

	while( true )
	{
		CNode* pPrev = Predecessor( pKey );
		if( (pPrev != NULL) && KTraits::CompareElements( key, pPrev->m_key ) )
		{
			pKey = pPrev;
		}
		else
		{
			return( pKey );
		}
	}

#pragma warning(pop)
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::FindPrefix( KINARGTYPE key ) const throw()
{
	// First, attempt to find a node that matches the key exactly
	CNode* pParent = NULL;
	CNode* pKey = NULL;
	CNode* pNode = m_pRoot;
	while( !IsNil(pNode) && (pKey == NULL) )
	{
		pParent = pNode;
		int nCompare = KTraits::CompareElementsOrdered( key, pNode->m_key );
		if( nCompare == 0 )
		{
			pKey = pNode;
		}
		else if( nCompare < 0 )
		{
			pNode = pNode->m_pLeft;
		}
		else
		{
			pNode = pNode->m_pRight;
		}
	}

	if( pKey != NULL )
	{
		// We found a node with the exact key, so find the first node in 
		// the tree with that key by walking backwards until we find a node
		// that doesn't match the key
		while( true )
		{
			CNode* pPrev = Predecessor( pKey );
			if( (pPrev != NULL) && KTraits::CompareElements( key, pPrev->m_key ) )
			{
				pKey = pPrev;
			}
			else
			{
				return( pKey );
			}
		}
	}
	else if (pParent != NULL)
	{
		// No node matched the key exactly, so pick the first node with 
		// a key greater than the given key
		int nCompare = KTraits::CompareElementsOrdered( key, pParent->m_key );
		if( nCompare < 0 )
		{
			pKey = pParent;
		}
		else
		{
			ATLASSERT( nCompare > 0 );
			pKey = Successor( pParent );
		}
	}

	return( pKey );
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::SwapNode(CNode* pDest, CNode* pSrc) throw()
{
	ATLASSERT(pDest != NULL);
	ATLASSERT(pSrc != NULL);

	pDest->m_pParent = pSrc->m_pParent;
	if (pSrc->m_pParent->m_pLeft == pSrc)
		pSrc->m_pParent->m_pLeft = pDest;
	else
		pSrc->m_pParent->m_pRight = pDest;

	pDest->m_pRight = pSrc->m_pRight;
	pDest->m_pLeft = pSrc->m_pLeft;
	pDest->m_eColor = pSrc->m_eColor;
	pDest->m_pRight->m_pParent = pDest;
	pDest->m_pLeft->m_pParent = pDest;
	if (m_pRoot == pSrc)
	{
		m_pRoot = pDest;
	}
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::InsertImpl( KINARGTYPE key, VINARGTYPE value ) throw( ... )
{
	CNode* pNew = NewNode( key, value );

	CNode* pY = NULL;
	CNode* pX = m_pRoot;

	while (!IsNil(pX))
	{
		pY = pX;
		if( KTraits::CompareElementsOrdered( key, pX->m_key ) <= 0 )
			pX = pX->m_pLeft;
		else
			pX = pX->m_pRight;
	}

	pNew->m_pParent = pY;
	if (pY == NULL)
	{
		m_pRoot = pNew;
	}
	else if( KTraits::CompareElementsOrdered( key, pY->m_key ) <= 0 )
		pY->m_pLeft = pNew;
	else
		pY->m_pRight = pNew;

	return pNew;
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::RBDeleteFixup(CNode* pNode) throw()
{
	CNode* pX = pNode;
	CNode* pW = NULL;

	while (pX != m_pRoot && pX->m_eColor == CNode::RB_BLACK)
	{
		if (pX == pX->m_pParent->m_pLeft)
		{
			pW = pX->m_pParent->m_pRight;
			if (pW->m_eColor == CNode::RB_RED)
			{
				pW->m_eColor = CNode::RB_BLACK;
				pW->m_pParent->m_eColor = CNode::RB_RED;
				LeftRotate(pX->m_pParent);
				pW = pX->m_pParent->m_pRight;
			}
			if (pW->m_pLeft->m_eColor == CNode::RB_BLACK && pW->m_pRight->m_eColor == CNode::RB_BLACK)
			{
				pW->m_eColor = CNode::RB_RED;
				pX = pX->m_pParent;
			}
			else
			{
				if (pW->m_pRight->m_eColor == CNode::RB_BLACK)
				{
					pW->m_pLeft->m_eColor = CNode::RB_BLACK;
					pW->m_eColor = CNode::RB_RED;
					RightRotate(pW);
					pW = pX->m_pParent->m_pRight;
				}
				pW->m_eColor = pX->m_pParent->m_eColor;
				pX->m_pParent->m_eColor = CNode::RB_BLACK;
				pW->m_pRight->m_eColor = CNode::RB_BLACK;
				LeftRotate(pX->m_pParent);
				pX = m_pRoot;
			}
		}
		else
		{
			pW = pX->m_pParent->m_pLeft;
			if (pW->m_eColor == CNode::RB_RED)
			{
				pW->m_eColor = CNode::RB_BLACK;
				pW->m_pParent->m_eColor = CNode::RB_RED;
				RightRotate(pX->m_pParent);
				pW = pX->m_pParent->m_pLeft;
			}
			if (pW->m_pRight->m_eColor == CNode::RB_BLACK && pW->m_pLeft->m_eColor == CNode::RB_BLACK)
			{
				pW->m_eColor = CNode::RB_RED;
				pX = pX->m_pParent;
			}
			else
			{
				if (pW->m_pLeft->m_eColor == CNode::RB_BLACK)
				{
					pW->m_pRight->m_eColor = CNode::RB_BLACK;
					pW->m_eColor = CNode::RB_RED;
					LeftRotate(pW);
					pW = pX->m_pParent->m_pLeft;
				}
				pW->m_eColor = pX->m_pParent->m_eColor;
				pX->m_pParent->m_eColor = CNode::RB_BLACK;
				pW->m_pLeft->m_eColor = CNode::RB_BLACK;
				RightRotate(pX->m_pParent);
				pX = m_pRoot;
			}
		}
	}

	pX->m_eColor = CNode::RB_BLACK;
}


template< typename K, typename V, class KTraits, class VTraits >
bool CRBTree< K, V, KTraits, VTraits >::RBDelete(CNode* pZ) throw()
{
	if (pZ == NULL)
		return false;

	CNode* pY = NULL;
	CNode* pX = NULL;
	if (IsNil(pZ->m_pLeft) || IsNil(pZ->m_pRight))
		pY = pZ;
	else
		pY = Successor(pZ);

	if (!IsNil(pY->m_pLeft))
		pX = pY->m_pLeft;
	else
		pX = pY->m_pRight;

	pX->m_pParent = pY->m_pParent;

	if (IsNil(pY->m_pParent))
		m_pRoot = pX;
	else if (pY == pY->m_pParent->m_pLeft)
		pY->m_pParent->m_pLeft = pX;
	else
		pY->m_pParent->m_pRight = pX;

	if (pY->m_eColor == CNode::RB_BLACK)
		RBDeleteFixup(pX);

	if (pY != pZ)
		SwapNode(pY, pZ);

	if (m_pRoot != NULL)
		SetNil(&m_pRoot->m_pParent);

	FreeNode( pZ );

	return true;
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::Minimum(CNode* pNode) const throw()
{
	if (pNode == NULL || IsNil(pNode))
	{
		return NULL;
	}

	CNode* pMin = pNode;
	while (!IsNil(pMin->m_pLeft))
	{
		pMin = pMin->m_pLeft;
	}

	return pMin;
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::Maximum(CNode* pNode) const throw()
{
	if (pNode == NULL || IsNil(pNode))
	{
		return NULL;
	}

	CNode* pMax = pNode;
	while (!IsNil(pMax->m_pRight))
	{
		pMax = pMax->m_pRight;
	}

	return pMax;
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::Predecessor( CNode* pNode ) const throw()
{
	if( pNode == NULL )
	{
		return( NULL );
	}
	if( !IsNil(pNode->m_pLeft) )
	{
		return( Maximum( pNode->m_pLeft ) );
	}

	CNode* pParent = pNode->m_pParent;
	CNode* pLeft = pNode;
	while( !IsNil(pParent) && (pLeft == pParent->m_pLeft) )
	{
		pLeft = pParent;
		pParent = pParent->m_pParent;
	}

	if (IsNil(pParent))
	{
		pParent = NULL;
	}
	return( pParent );
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::Successor(CNode* pNode) const throw()
{
	if ( pNode == NULL )
	{
		return NULL;
	}
	if ( !IsNil(pNode->m_pRight) )
	{
		return Minimum(pNode->m_pRight);
	}
	
	CNode* pParent = pNode->m_pParent;
	CNode* pRight = pNode;
	while ( !IsNil(pParent) && (pRight == pParent->m_pRight) )
	{
		pRight = pParent;
		pParent = pParent->m_pParent;
	}

	if (IsNil(pParent))
	{
		pParent = NULL;
	}
	return pParent;
}

template< typename K, typename V, class KTraits, class VTraits >
CRBTree< K, V, KTraits, VTraits >::CNode* CRBTree< K, V, KTraits, VTraits >::RBInsert( KINARGTYPE key, VINARGTYPE value ) throw( ... )
{
	CNode* pNewNode = InsertImpl( key, value );

	CNode* pX = pNewNode;
	pX->m_eColor = CNode::RB_RED;
	CNode* pY = NULL;
	while (pX != m_pRoot && pX->m_pParent->m_eColor == CNode::RB_RED)
	{
		if (pX->m_pParent == pX->m_pParent->m_pParent->m_pLeft)
		{
			pY = pX->m_pParent->m_pParent->m_pRight;
			if (pY != NULL && pY->m_eColor == CNode::RB_RED)
			{
				pX->m_pParent->m_eColor = CNode::RB_BLACK;
				pY->m_eColor = CNode::RB_BLACK;
				pX->m_pParent->m_pParent->m_eColor = CNode::RB_RED;
				pX = pX->m_pParent->m_pParent;
			}
			else
			{
				if (pX == pX->m_pParent->m_pRight)
				{
					pX = pX->m_pParent;
					LeftRotate(pX);
				}
				pX->m_pParent->m_eColor = CNode::RB_BLACK;
				pX->m_pParent->m_pParent->m_eColor = CNode::RB_RED;
				RightRotate(pX->m_pParent->m_pParent);
			}
		}
		else
		{
			pY = pX->m_pParent->m_pParent->m_pLeft;
			if (pY != NULL && pY->m_eColor == CNode::RB_RED)
			{
				pX->m_pParent->m_eColor = CNode::RB_BLACK;
				pY->m_eColor = CNode::RB_BLACK;
				pX->m_pParent->m_pParent->m_eColor = CNode::RB_RED;
				pX = pX->m_pParent->m_pParent;
			}
			else
			{
				if (pX == pX->m_pParent->m_pLeft)
				{
					pX = pX->m_pParent;
					RightRotate(pX);
				}
				pX->m_pParent->m_eColor = CNode::RB_BLACK;
				pX->m_pParent->m_pParent->m_eColor = CNode::RB_RED;
				LeftRotate(pX->m_pParent->m_pParent);
			}
		}
	}

	m_pRoot->m_eColor = CNode::RB_BLACK;
	SetNil(&m_pRoot->m_pParent);

	return( pNewNode );
}

#ifdef _DEBUG

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::VerifyIntegrity(const CNode *pNode, int nCurrBlackDepth, int &nBlackDepth) const
{
	bool bCheckForBlack = false;
	bool bLeaf = true;

	if (pNode->m_eColor == CNode::RB_RED) 
		bCheckForBlack = true;
	else
		nCurrBlackDepth++;

	ATLASSERT(pNode->m_pLeft != NULL);
	if (!IsNil(pNode->m_pLeft))
	{
		bLeaf = false;
		if (bCheckForBlack)
		{
			ATLASSERT(pNode->m_pLeft->m_eColor == CNode::RB_BLACK);
		}

		VerifyIntegrity(pNode->m_pLeft, nCurrBlackDepth, nBlackDepth);
	}

	ATLASSERT(pNode->m_pRight != NULL);
	if (!IsNil(pNode->m_pRight))
	{
		bLeaf = false;
		if (bCheckForBlack)
		{
			ATLASSERT(pNode->m_pRight->m_eColor == CNode::RB_BLACK);
		}

		VerifyIntegrity(pNode->m_pRight, nCurrBlackDepth, nBlackDepth);
	}

	ATLASSERT( pNode->m_pParent != NULL );
	ATLASSERT( ( IsNil(pNode->m_pParent) ) ||
			( pNode->m_pParent->m_pLeft == pNode ) ||
			( pNode->m_pParent->m_pRight == pNode ) );

	if (bLeaf) 
	{
		if (nBlackDepth == 0)
		{
			nBlackDepth = nCurrBlackDepth;
		}
		else 
		{
			ATLASSERT(nBlackDepth == nCurrBlackDepth);
		}
	}
}

template< typename K, typename V, class KTraits, class VTraits >
void CRBTree< K, V, KTraits, VTraits >::VerifyIntegrity() const
{
	if ((m_pRoot == NULL) || (IsNil(m_pRoot)))
		return;

	ATLASSERT(m_pRoot->m_eColor == CNode::RB_BLACK);
	int nBlackDepth = 0;
	VerifyIntegrity(m_pRoot, 0, nBlackDepth);
}

#endif // _DEBUG

template< typename K, typename V, class KTraits = CElementTraits< K >, class VTraits = CElementTraits< V > >
class CRBMap :
	public CRBTree< K, V, KTraits, VTraits >
{
public:
	explicit CRBMap( size_t nBlockSize = 10 ) throw();
	~CRBMap() throw();

	bool Lookup( KINARGTYPE key, VOUTARGTYPE value ) const throw( ... );
	const CPair* Lookup( KINARGTYPE key ) const throw();
	CPair* Lookup( KINARGTYPE key ) throw();
	POSITION SetAt( KINARGTYPE key, VINARGTYPE value ) throw( ... );
	bool RemoveKey( KINARGTYPE key ) throw();
};

template< typename K, typename V, class KTraits, class VTraits >
CRBMap< K, V, KTraits, VTraits >::CRBMap( size_t nBlockSize ) throw() :
	CRBTree< K, V, KTraits, VTraits >( nBlockSize )
{
}

template< typename K, typename V, class KTraits, class VTraits >
CRBMap< K, V, KTraits, VTraits >::~CRBMap() throw()
{
}

template< typename K, typename V, class KTraits, class VTraits >
const CRBMap< K, V, KTraits, VTraits >::CPair* CRBMap< K, V, KTraits, VTraits >::Lookup( KINARGTYPE key ) const throw()
{
	return Find(key);
}

template< typename K, typename V, class KTraits, class VTraits >
CRBMap< K, V, KTraits, VTraits >::CPair* CRBMap< K, V, KTraits, VTraits >::Lookup( KINARGTYPE key ) throw()
{
	return Find(key);
}

template< typename K, typename V, class KTraits, class VTraits >
bool CRBMap< K, V, KTraits, VTraits >::Lookup( KINARGTYPE key, VOUTARGTYPE value ) const throw( ... )
{
	const CPair* pLookup = Find( key );
	if( pLookup == NULL )
		return false;

	value = pLookup->m_value;
	return true;
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CRBMap< K, V, KTraits, VTraits >::SetAt( KINARGTYPE key, VINARGTYPE value ) throw( ... )
{
	CPair* pNode = Find( key );
	if( pNode == NULL )
	{
		return( RBInsert( key, value ) );
	}
	else
	{
		pNode->m_value = value;

		return( pNode );
	}
}

template< typename K, typename V, class KTraits, class VTraits >
bool CRBMap< K, V, KTraits, VTraits >::RemoveKey( KINARGTYPE key ) throw()
{
	POSITION pos = Lookup( key );
	if( pos != NULL )
	{
		RemoveAt( pos );

		return( true );
	}
	else
	{
		return( false );
	}
}

template< typename K, typename V, class KTraits = CElementTraits< K >, class VTraits = CElementTraits< V > >
class CRBMultiMap :
	public CRBTree< K, V, KTraits, VTraits >
{
public:
	explicit CRBMultiMap( size_t nBlockSize = 10 ) throw();
	~CRBMultiMap() throw();

	POSITION Insert( KINARGTYPE key, VINARGTYPE value ) throw( ... );
	size_t RemoveKey( KINARGTYPE key ) throw();

	POSITION FindFirstWithKey( KINARGTYPE key ) const throw();
	const CPair* GetNextWithKey( POSITION& pos, KINARGTYPE key ) const throw();
	CPair* GetNextWithKey( POSITION& pos, KINARGTYPE key ) throw();
	const V& GetNextValueWithKey( POSITION& pos, KINARGTYPE key ) const throw();
	V& GetNextValueWithKey( POSITION& pos, KINARGTYPE key ) throw();
};

template< typename K, typename V, class KTraits, class VTraits >
CRBMultiMap< K, V, KTraits, VTraits >::CRBMultiMap( size_t nBlockSize ) throw() :
	CRBTree< K, V, KTraits, VTraits >( nBlockSize )
{
}

template< typename K, typename V, class KTraits, class VTraits >
CRBMultiMap< K, V, KTraits, VTraits >::~CRBMultiMap() throw()
{
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CRBMultiMap< K, V, KTraits, VTraits >::Insert( KINARGTYPE key, VINARGTYPE value ) throw( ... )
{
	return( RBInsert( key, value ) );
}

template< typename K, typename V, class KTraits, class VTraits >
size_t CRBMultiMap< K, V, KTraits, VTraits >::RemoveKey( KINARGTYPE key ) throw()
{
	size_t nElementsDeleted = 0;

	POSITION pos = FindFirstWithKey( key );
	while( pos != NULL )
	{
		POSITION posDelete = pos;
		GetNextWithKey( pos, key );
		RemoveAt( posDelete );
		nElementsDeleted++;
	}

	return( nElementsDeleted );
}

template< typename K, typename V, class KTraits, class VTraits >
POSITION CRBMultiMap< K, V, KTraits, VTraits >::FindFirstWithKey( KINARGTYPE key ) const throw()
{
	return( Find( key ) );
}

template< typename K, typename V, class KTraits, class VTraits >
const CRBMultiMap< K, V, KTraits, VTraits >::CPair* CRBMultiMap< K, V, KTraits, VTraits >::GetNextWithKey( POSITION& pos, KINARGTYPE key ) const throw()
{
	ATLASSERT( pos != NULL );
	const CPair* pNode = GetNext( pos );
	if( (pos == NULL) || !KTraits::CompareElements( static_cast< CPair* >( pos )->m_key, key ) )
	{
		pos = NULL;
	}

	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
CRBMultiMap< K, V, KTraits, VTraits >::CPair* CRBMultiMap< K, V, KTraits, VTraits >::GetNextWithKey( POSITION& pos, KINARGTYPE key ) throw()
{
	ATLASSERT( pos != NULL );
	CPair* pNode = GetNext( pos );
	if( (pos == NULL) || !KTraits::CompareElements( static_cast< CPair* >( pos )->m_key, key ) )
	{
		pos = NULL;
	}

	return( pNode );
}

template< typename K, typename V, class KTraits, class VTraits >
const V& CRBMultiMap< K, V, KTraits, VTraits >::GetNextValueWithKey( POSITION& pos, KINARGTYPE key ) const throw()
{
	const CPair* pPair = GetNextWithKey( pos, key );

	return( pPair->m_value );
}

template< typename K, typename V, class KTraits, class VTraits >
V& CRBMultiMap< K, V, KTraits, VTraits >::GetNextValueWithKey( POSITION& pos, KINARGTYPE key ) throw()
{
	CPair* pPair = GetNextWithKey( pos, key );

	return( pPair->m_value );
}

#pragma pop_macro("new")

}; // namespace ATL

//REVIEW: Just to fix VSEE
#pragma pop_macro("min")
#pragma pop_macro("max")

#pragma warning(pop)

#endif  // __ATLCOLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atlmfc\atlexcept.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLEXCEPT_H__
#define __ATLEXCEPT_H__

#pragma once

#include <atldef.h>

namespace ATL
{

class CAtlException
{
public:
	CAtlException() throw() :
		m_hr( E_FAIL )
	{
	}

	CAtlException( HRESULT hr ) throw() :
		m_hr( hr )
	{
	}

	operator HRESULT() const throw()
	{
		return( m_hr );
	}

public:
	HRESULT m_hr;
};

#ifndef _ATL_NO_EXCEPTIONS

// Throw a CAtlException with the given HRESULT
#if defined( AtlThrow ) || defined( _ATL_CUSTOM_THROW )  // You can define your own AtlThrow to throw a custom exception.
#ifdef _AFX
#error MFC projects must use default implementation of AtlThrow()
#endif
#else
ATL_NOINLINE __declspec(noreturn) inline void AtlThrow( HRESULT hr )
{
#ifdef _AFX
	if( hr == E_OUTOFMEMORY )
	{
		AfxThrowMemoryException();
	}
	else
	{
		AfxThrowOleException( hr );
	}
#else
	throw CAtlException( hr );
#endif
};
#endif

// Throw a CAtlException corresponding to the result of ::GetLastError
ATL_NOINLINE __declspec(noreturn) inline void AtlThrowLastWin32()
{
	DWORD dwError = ::GetLastError();
	AtlThrow( HRESULT_FROM_WIN32( dwError ) );
}

#else  // no exception handling

// Throw a CAtlException with the given HRESULT
#if !defined( AtlThrow ) && !defined( _ATL_CUSTOM_THROW )  // You can define your own AtlThrow
ATL_NOINLINE inline void AtlThrow( HRESULT hr )
{
	(void)hr;
	ATLASSERT( false );
}
#endif

// Throw a CAtlException corresponding to the result of ::GetLastError
ATL_NOINLINE inline void AtlThrowLastWin32()
{
	DWORD dwError = ::GetLastError();
	AtlThrow( HRESULT_FROM_WIN32( dwError ) );
}

#endif  // no exception handling

};  // namespace ATL

#endif  // __ATLEXCEPT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atlmfc\atliface.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0342 */
/* at Mon Feb 12 21:31:09 2001
 */
/* Compiler settings for atliface.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __atliface_h__
#define __atliface_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IRegistrarBase_FWD_DEFINED__
#define __IRegistrarBase_FWD_DEFINED__
typedef interface IRegistrarBase IRegistrarBase;
#endif 	/* __IRegistrarBase_FWD_DEFINED__ */


#ifndef __IRegistrar_FWD_DEFINED__
#define __IRegistrar_FWD_DEFINED__
typedef interface IRegistrar IRegistrar;
#endif 	/* __IRegistrar_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

#ifndef __IRegistrarBase_INTERFACE_DEFINED__
#define __IRegistrarBase_INTERFACE_DEFINED__

/* interface IRegistrarBase */
/* [unique][helpstring][uuid][object] */ 


#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e21f8a85-b05d-4243-8183-c7cb405588f7")
    IRegistrarBase : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddReplacement( 
            /* [in] */ LPCOLESTR key,
            /* [in] */ LPCOLESTR item) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearReplacements( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegistrarBaseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegistrarBase * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegistrarBase * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegistrarBase * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddReplacement )( 
            IRegistrarBase * This,
            /* [in] */ LPCOLESTR key,
            /* [in] */ LPCOLESTR item);
        
        HRESULT ( STDMETHODCALLTYPE *ClearReplacements )( 
            IRegistrarBase * This);
        
        END_INTERFACE
    } IRegistrarBaseVtbl;

    interface IRegistrarBase
    {
        CONST_VTBL struct IRegistrarBaseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegistrarBase_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegistrarBase_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegistrarBase_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegistrarBase_AddReplacement(This,key,item)	\
    (This)->lpVtbl -> AddReplacement(This,key,item)

#define IRegistrarBase_ClearReplacements(This)	\
    (This)->lpVtbl -> ClearReplacements(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRegistrarBase_AddReplacement_Proxy( 
    IRegistrarBase * This,
    /* [in] */ LPCOLESTR key,
    /* [in] */ LPCOLESTR item);


void __RPC_STUB IRegistrarBase_AddReplacement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrarBase_ClearReplacements_Proxy( 
    IRegistrarBase * This);


void __RPC_STUB IRegistrarBase_ClearReplacements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegistrarBase_INTERFACE_DEFINED__ */


#ifndef __IRegistrar_INTERFACE_DEFINED__
#define __IRegistrar_INTERFACE_DEFINED__

/* interface IRegistrar */
/* [unique][helpstring][uuid][object] */ 


#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44EC053B-400F-11D0-9DCD-00A0C90391D3")
    IRegistrar : public IRegistrarBase
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ResourceRegisterSz( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResourceUnregisterSz( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FileRegister( 
            /* [in] */ LPCOLESTR fileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FileUnregister( 
            /* [in] */ LPCOLESTR fileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StringRegister( 
            /* [in] */ LPCOLESTR data) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StringUnregister( 
            /* [in] */ LPCOLESTR data) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResourceRegister( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResourceUnregister( 
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRegistrar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRegistrar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRegistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddReplacement )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR key,
            /* [in] */ LPCOLESTR item);
        
        HRESULT ( STDMETHODCALLTYPE *ClearReplacements )( 
            IRegistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *ResourceRegisterSz )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType);
        
        HRESULT ( STDMETHODCALLTYPE *ResourceUnregisterSz )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ LPCOLESTR szID,
            /* [in] */ LPCOLESTR szType);
        
        HRESULT ( STDMETHODCALLTYPE *FileRegister )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR fileName);
        
        HRESULT ( STDMETHODCALLTYPE *FileUnregister )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR fileName);
        
        HRESULT ( STDMETHODCALLTYPE *StringRegister )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR data);
        
        HRESULT ( STDMETHODCALLTYPE *StringUnregister )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR data);
        
        HRESULT ( STDMETHODCALLTYPE *ResourceRegister )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType);
        
        HRESULT ( STDMETHODCALLTYPE *ResourceUnregister )( 
            IRegistrar * This,
            /* [in] */ LPCOLESTR resFileName,
            /* [in] */ UINT nID,
            /* [in] */ LPCOLESTR szType);
        
        END_INTERFACE
    } IRegistrarVtbl;

    interface IRegistrar
    {
        CONST_VTBL struct IRegistrarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRegistrar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRegistrar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRegistrar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRegistrar_AddReplacement(This,key,item)	\
    (This)->lpVtbl -> AddReplacement(This,key,item)

#define IRegistrar_ClearReplacements(This)	\
    (This)->lpVtbl -> ClearReplacements(This)


#define IRegistrar_ResourceRegisterSz(This,resFileName,szID,szType)	\
    (This)->lpVtbl -> ResourceRegisterSz(This,resFileName,szID,szType)

#define IRegistrar_ResourceUnregisterSz(This,resFileName,szID,szType)	\
    (This)->lpVtbl -> ResourceUnregisterSz(This,resFileName,szID,szType)

#define IRegistrar_FileRegister(This,fileName)	\
    (This)->lpVtbl -> FileRegister(This,fileName)

#define IRegistrar_FileUnregister(This,fileName)	\
    (This)->lpVtbl -> FileUnregister(This,fileName)

#define IRegistrar_StringRegister(This,data)	\
    (This)->lpVtbl -> StringRegister(This,data)

#define IRegistrar_StringUnregister(This,data)	\
    (This)->lpVtbl -> StringUnregister(This,data)

#define IRegistrar_ResourceRegister(This,resFileName,nID,szType)	\
    (This)->lpVtbl -> ResourceRegister(This,resFileName,nID,szType)

#define IRegistrar_ResourceUnregister(This,resFileName,nID,szType)	\
    (This)->lpVtbl -> ResourceUnregister(This,resFileName,nID,szType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegisterSz_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ LPCOLESTR szID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegisterSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregisterSz_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ LPCOLESTR szID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregisterSz_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_FileRegister_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_FileUnregister_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR fileName);


void __RPC_STUB IRegistrar_FileUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_StringRegister_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_StringUnregister_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR data);


void __RPC_STUB IRegistrar_StringUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_ResourceRegister_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ UINT nID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceRegister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IRegistrar_ResourceUnregister_Proxy( 
    IRegistrar * This,
    /* [in] */ LPCOLESTR resFileName,
    /* [in] */ UINT nID,
    /* [in] */ LPCOLESTR szType);


void __RPC_STUB IRegistrar_ResourceUnregister_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRegistrar_INTERFACE_DEFINED__ */


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atlmfc\atlres.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.


#define ATL_RESID_BASE						0xD800
#define ATL_STRING_BASE						ATL_RESID_BASE

#define ATL_IDS_DATETIME_INVALID			(ATL_STRING_BASE + 0)
#define ATL_IDS_DATETIMESPAN_INVALID		(ATL_STRING_BASE + 1)

#define ATL_SERIVCE_MANAGER_OPEN_ERROR		(ATL_STRING_BASE + 10)
#define ATL_SERIVCE_START_ERROR				(ATL_STRING_BASE + 11)
#define ATL_SERIVCE_OPEN_ERROR				(ATL_STRING_BASE + 12)
#define ATL_SERIVCE_DELETE_ERROR			(ATL_STRING_BASE + 13)
#define ATL_SERIVCE_STOP_ERROR				(ATL_STRING_BASE + 14)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atlmfc\atlmem.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLMEM_H__
#define __ATLMEM_H__

#pragma once

#include <atlbase.h>

#include <limits.h>

namespace ATL
{

template< typename N >
inline N AtlAlignUp( N n, ULONG nAlign ) throw()
{
	return( N( (n+(nAlign-1))&~(N( nAlign )-1) ) );
}

__interface __declspec(uuid("654F7EF5-CFDF-4df9-A450-6C6A13C622C0")) IAtlMemMgr
{
public:
	void* Allocate( size_t nBytes ) throw();
	void Free( void* p ) throw();
	void* Reallocate( void* p, size_t nBytes ) throw();
	size_t GetSize( void* p ) throw();
};


class CWin32Heap :
	public IAtlMemMgr
{
public:

	CWin32Heap( HANDLE hHeap ) throw() :
		m_hHeap( hHeap ),
		m_bOwnHeap( false )
	{
		ATLASSERT( hHeap != NULL );
	}

	~CWin32Heap() throw()
	{
		if( m_bOwnHeap && (m_hHeap != NULL) )
		{
			BOOL bSuccess;

			bSuccess = ::HeapDestroy( m_hHeap );
			ATLASSERT( bSuccess );
		}
	}

// IAtlMemMgr
	virtual void* Allocate( size_t nBytes ) throw()
	{
		return( ::HeapAlloc( m_hHeap, 0, nBytes ) );
	}
	virtual void Free( void* p ) throw()
	{
		if( p != NULL )
		{
			BOOL bSuccess;

			bSuccess = ::HeapFree( m_hHeap, 0, p );
			ATLASSERT( bSuccess );
		}
	}

	virtual void* Reallocate( void* p, size_t nBytes ) throw()
	{
		if( p == NULL )
		{
			return( Allocate( nBytes ) );
		}
		else
		{
			return( ::HeapReAlloc( m_hHeap, 0, p, nBytes ) );
		}
	}

	virtual size_t GetSize( void* p ) throw()
	{
		return( ::HeapSize( m_hHeap, 0, p ) );
	}

public:
	HANDLE m_hHeap;
	bool m_bOwnHeap;
};

};  // namespace ATL

#endif  //__ATLMEM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atlmfc\atlconv.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCONV_H__
#define __ATLCONV_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4127) // unreachable code
#endif //!_ATL_NO_PRAGMA_WARNINGS

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atldef.h>

#include <objbase.h>

namespace ATL
{

inline UINT _AtlGetConversionACP()
{
	return( CP_ACP );
}

};  // namespace ATL

#pragma pack(push,8)

#ifndef _DEBUG
	#define USES_CONVERSION int _convert; _convert; UINT _acp = ATL::_AtlGetConversionACP() /*CP_THREAD_ACP*/; _acp; LPCWSTR _lpw; _lpw; LPCSTR _lpa; _lpa
#else
	#define USES_CONVERSION int _convert = 0; _convert; UINT _acp = ATL::_AtlGetConversionACP() /*CP_THREAD_ACP*/; _acp; LPCWSTR _lpw = NULL; _lpw; LPCSTR _lpa = NULL; _lpa
#endif


/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers
inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars, UINT acp)
{
	ATLASSERT(lpa != NULL);
	ATLASSERT(lpw != NULL);
	if (lpw == NULL)
		return NULL;
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
	return lpw;
}

inline LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars, UINT acp)
{
	ATLASSERT(lpw != NULL);
	ATLASSERT(lpa != NULL);
	if (lpa == NULL)
		return NULL;
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(acp, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

#ifndef ATLA2WHELPER
	#define ATLA2WHELPER AtlA2WHelper
	#define ATLW2AHELPER AtlW2AHelper
#endif

#define A2W(lpa) (\
	((_lpa = lpa) == NULL) ? NULL : (\
		_convert = (lstrlenA(_lpa)+1),\
		ATLA2WHELPER((LPWSTR) alloca(_convert*2), _lpa, _convert, _acp)))

#define W2A(lpw) (\
	((_lpw = lpw) == NULL) ? NULL : (\
		_convert = (lstrlenW(_lpw)+1)*2,\
		ATLW2AHELPER((LPSTR) alloca(_convert), _lpw, _convert, _acp)))

#pragma pack(pop)

#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLCONV_IMPL
#endif
#endif

#endif // __ATLCONV_H__

/////////////////////////////////////////////////////////////////////////////

#ifdef _ATLCONV_IMPL

//Prevent pulling in second time
#undef _ATLCONV_IMPL

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif //!_ATL_NO_PRAGMA_WARNINGS

#endif // _ATLCONV_IMPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atlmfc\atlcom.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCOM_H__
#define __ATLCOM_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4355) // 'this' used in initializer list
#pragma warning(disable: 4511) // copy constructor could not be generated
#pragma warning(disable: 4512) // assignment operator could not be generated
#endif //!_ATL_NO_PRAGMA_WARNINGS

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlcom.h requires atlbase.h to be included first
#endif

//REVIEW: Just to fix VSEE
#pragma push_macro("min")
#pragma push_macro("max")
#undef min
#undef max
#define min(a,b)            (((a) < (b)) ? (a) : (b))
#define max(a,b)            (((a) > (b)) ? (a) : (b))

#pragma pack(push, _ATL_PACKING)

EXTERN_C const IID IID_ITargetFrame;

#include <atlbase.inl>
#include <limits.h>

namespace ATL
{

#define _ATLDUMPIID(iid, name, hr) hr

/////////////////////////////////////////////////////////////////////////////
// AtlReportError

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, const IID& iid = GUID_NULL,
	HRESULT hRes = 0, HINSTANCE hInst = _AtlBaseModule.GetResourceInstance())
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), 0, NULL, iid, hRes, hInst);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0, 
	HINSTANCE hInst = _AtlBaseModule.GetResourceInstance())
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), dwHelpID,
		lpszHelpFile, iid, hRes, hInst);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
	const IID& iid = GUID_NULL, HRESULT hRes = 0)
{
	return AtlSetErrorInfo(clsid, lpszDesc, 0, NULL, iid, hRes, NULL);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0)
{
	return AtlSetErrorInfo(clsid, lpszDesc, dwHelpID, lpszHelpFile, iid, hRes, NULL);
}


/////////////////////////////////////////////////////////////////////////////
// COM Objects

#define DECLARE_PROTECT_FINAL_CONSTRUCT()\
	void InternalFinalConstructAddRef() {InternalAddRef();}\
	void InternalFinalConstructRelease() {InternalRelease();}

template <class T1>
class CComCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		ATLASSERT(ppv != NULL);
		if (ppv == NULL)
			return E_POINTER;
		*ppv = NULL;

		HRESULT hRes = E_OUTOFMEMORY;
		T1* p = NULL;
		ATLTRY(p = new T1(pv))
		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			if (SUCCEEDED(hRes))
				hRes = p->_AtlFinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};


template <HRESULT hr>
class CComFailCreator
{
public:
	static HRESULT WINAPI CreateInstance(void*, REFIID, LPVOID* ppv)
	{
		if (ppv == NULL)
			return E_POINTER;
		*ppv = NULL;

		return hr;
	}
};

template <class T1, class T2>
class CComCreator2
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
		ATLASSERT(ppv != NULL);

		return (pv == NULL) ? 
			T1::CreateInstance(NULL, riid, ppv) : 
			T2::CreateInstance(pv, riid, ppv);
	}
};

#define DECLARE_NOT_AGGREGATABLE(x) public:\
	typedef ATL::CComCreator2< ATL::CComCreator< ATL::CComObject< x > >, ATL::CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DECLARE_AGGREGATABLE(x) public:\
	typedef ATL::CComCreator2< ATL::CComCreator< ATL::CComObject< x > >, ATL::CComCreator< ATL::CComAggObject< x > > > _CreatorClass;

struct _ATL_CREATORDATA
{
        _ATL_CREATORFUNC* pFunc;
};

template <class Creator>
class _CComCreatorData
{
public:
        static _ATL_CREATORDATA data;
};

template <class Creator>
_ATL_CREATORDATA _CComCreatorData<Creator>::data = {Creator::CreateInstance};

struct _ATL_CACHEDATA
{
        DWORD dwOffsetVar;
        _ATL_CREATORFUNC* pFunc;
};

template <class Creator, DWORD dwVar>
class _CComCacheData
{
public:
        static _ATL_CACHEDATA data;
};

template <class Creator, DWORD dwVar>
_ATL_CACHEDATA _CComCacheData<Creator, dwVar>::data = {dwVar, Creator::CreateInstance};

struct _ATL_CHAINDATA
{
        DWORD_PTR dwOffset;
        const _ATL_INTMAP_ENTRY* (WINAPI *pFunc)();
};

template <class base, class derived>
class _CComChainData
{
public:
        static _ATL_CHAINDATA data;
};

template <class base, class derived>
_ATL_CHAINDATA _CComChainData<base, derived>::data =
        {offsetofclass(base, derived), base::_GetEntries};


#ifdef _ATL_DEBUG
#define DEBUG_QI_ENTRY(x) \
		{NULL, \
		(DWORD_PTR)_T(#x), \
		(ATL::_ATL_CREATORARGFUNC*)0},
#else
#define DEBUG_QI_ENTRY(x)
#endif //_ATL_DEBUG

#define _ATL_DECLARE_GET_UNKNOWN(x) IUnknown* GetUnknown() throw() {return _GetRawUnknown();}

//If you get a message that FinalConstruct is ambiguous then you need to
// override it in your class and call each base class' version of this
#define BEGIN_COM_MAP(x) public: \
	typedef x _ComMapClass; \
	static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw) throw()\
	{\
		_ComMapClass* p = (_ComMapClass*)pv;\
		p->Lock();\
		HRESULT hRes = ATL::CComObjectRootBase::_Cache(pv, iid, ppvObject, dw);\
		p->Unlock();\
		return hRes;\
	}\
	IUnknown* _GetRawUnknown() throw() \
	{ ATLASSERT(_GetEntries()[0].pFunc == _ATL_SIMPLEMAPENTRY); return (IUnknown*)((INT_PTR)this+_GetEntries()->dw); } \
	_ATL_DECLARE_GET_UNKNOWN(x)\
	HRESULT _InternalQueryInterface(REFIID iid, void** ppvObject) throw() \
	{ return InternalQueryInterface(this, _GetEntries(), iid, ppvObject); } \
	const static ATL::_ATL_INTMAP_ENTRY* WINAPI _GetEntries() throw() { \
	static const ATL::_ATL_INTMAP_ENTRY _entries[] = { DEBUG_QI_ENTRY(x)

#define DECLARE_GET_CONTROLLING_UNKNOWN() public:\
	virtual IUnknown* GetControllingUnknown() throw() {return GetUnknown();}

#define COM_INTERFACE_ENTRY(x)\
	{&_ATL_IIDOF(x), \
	offsetofclass(x, _ComMapClass), \
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY2(x, x2)\
	{&_ATL_IIDOF(x),\
	reinterpret_cast<DWORD_PTR>(static_cast<x*>(static_cast<x2*>(reinterpret_cast<_ComMapClass*>(8))))-8,\
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_AGGREGATE(iid, punk)\
	{&iid,\
	(DWORD_PTR)offsetof(_ComMapClass, punk),\
	_Delegate},

#ifdef _ATL_DEBUG
#define END_COM_MAP() \
	__if_exists(_GetAttrEntries) {{NULL, (DWORD_PTR)_GetAttrEntries, _ChainAttr }, }\
	{NULL, 0, 0}}; return &_entries[1];} \
	virtual ULONG STDMETHODCALLTYPE AddRef( void) throw() = 0; \
	virtual ULONG STDMETHODCALLTYPE Release( void) throw() = 0; \
	STDMETHOD(QueryInterface)(REFIID, void**) throw() = 0;
#else
#define END_COM_MAP() \
	__if_exists(_GetAttrEntries) {{NULL, (DWORD_PTR)_GetAttrEntries, _ChainAttr }, }\
	{NULL, 0, 0}}; return _entries;} \
	virtual ULONG STDMETHODCALLTYPE AddRef( void) throw() = 0; \
	virtual ULONG STDMETHODCALLTYPE Release( void) throw() = 0; \
	STDMETHOD(QueryInterface)(REFIID, void**) throw() = 0;
#endif // _ATL_DEBUG


#define BEGIN_OBJECT_MAP(x) static ATL::_ATL_OBJMAP_ENTRY x[] = {
#define END_OBJECT_MAP()   {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}};
#define OBJECT_ENTRY(clsid, class) {&clsid, class::UpdateRegistry, class::_ClassFactoryCreatorClass::CreateInstance, class::_CreatorClass::CreateInstance, NULL, 0, class::GetObjectDescription, class::GetCategoryMap, class::ObjectMain },

#ifndef OBJECT_ENTRY_PRAGMA

#if defined(_M_IX86)
#define OBJECT_ENTRY_PRAGMA(class) __pragma(comment(linker, "/include:___pobjMap_" #class))
#elif defined(_M_AMD64) || defined(_M_IA64)
#define OBJECT_ENTRY_PRAGMA(class) __pragma(comment(linker, "/include:__pobjMap_" #class))
#else
#error Unknown Platform. define OBJECT_ENTRY_PRAGMA
#endif

#endif	//OBJECT_ENTRY_PRAGMA


// the functions in this class don't need to be virtual because
// they are called from CComObject
class CComObjectRootBase
{
public:
	CComObjectRootBase()
	{
		m_dwRef = 0L;
	}
	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	// For library initialization only
	HRESULT _AtlFinalConstruct()
	{
		return S_OK;
	}
	void FinalRelease() {}

	//ObjectMain is called during Module::Init and Module::Term
	static void WINAPI ObjectMain(bool /* bStarting */) {}
	
	static const struct _ATL_CATMAP_ENTRY* GetCategoryMap() {return NULL;};
	static HRESULT WINAPI InternalQueryInterface(void* pThis,
		const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
	{
		// Only Assert here. AtlInternalQueryInterface will return the correct HRESULT if ppvObject == NULL
#ifndef _ATL_OLEDB_CONFORMANCE_TESTS
		ATLASSERT(ppvObject != NULL);
#endif
		ATLASSERT(pThis != NULL);
		// First entry in the com map should be a simple map entry
		ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);

		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);
		return _ATLDUMPIID(iid, pszClassName, hRes);
	}

//Outer funcs
        ULONG OuterAddRef()
        {
                return m_pOuterUnknown->AddRef();
        }
        ULONG OuterRelease()
        {
                return m_pOuterUnknown->Release();
        }
	HRESULT OuterQueryInterface(REFIID iid, void ** ppvObject)
	{
		return m_pOuterUnknown->QueryInterface(iid, ppvObject);
	}

	void SetVoid(void*) {}
	void InternalFinalConstructAddRef() {}
	void InternalFinalConstructRelease()
	{
		ATLASSERT(m_dwRef == 0);
	}
	// If this assert occurs, your object has probably been deleted
	// Try using DECLARE_PROTECT_FINAL_CONSTRUCT()


	static HRESULT WINAPI _Delegate(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
	{
		HRESULT hRes = E_NOINTERFACE;
		IUnknown* p = *(IUnknown**)((DWORD_PTR)pv + dw);
		if (p != NULL)
			hRes = p->QueryInterface(iid, ppvObject);
		return hRes;
	}
	static HRESULT WINAPI _ChainAttr(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
	{
		const _ATL_INTMAP_ENTRY* (WINAPI *pFunc)() = (const _ATL_INTMAP_ENTRY* (WINAPI *)())dw;
		const _ATL_INTMAP_ENTRY *pEntries = pFunc();
		if (pEntries == NULL)
			return S_OK;
		return InternalQueryInterface(pv, pEntries, iid, ppvObject);
	}
	static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
	{
		HRESULT hRes = E_NOINTERFACE;
		_ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)dw;
		IUnknown** pp = (IUnknown**)((DWORD_PTR)pv + pcd->dwOffsetVar);
		if (*pp == NULL)
			hRes = pcd->pFunc(pv, __uuidof(IUnknown), (void**)pp);
		if (*pp != NULL)
			hRes = (*pp)->QueryInterface(iid, ppvObject);
		return hRes;
	}

	union
	{
		long m_dwRef;
		IUnknown* m_pOuterUnknown;
	};
};


template <class ThreadModel>
class CComObjectRootEx : public CComObjectRootBase
{
public:
	typedef ThreadModel _ThreadModel;
	typedef typename _ThreadModel::AutoCriticalSection _CritSec;

	ULONG InternalAddRef()
	{
		ATLASSERT(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
#ifdef _DEBUG
		LONG nRef = _ThreadModel::Decrement(&m_dwRef);
		if (nRef < -(LONG_MAX / 2))
		{
			ATLASSERT(0 && _T("Release called on a pointer that has already been released"));
		}
		return nRef;
#else
		return _ThreadModel::Decrement(&m_dwRef);
#endif
	}

	void Lock() {m_critsec.Lock();}
	void Unlock() {m_critsec.Unlock();}
private:
	_CritSec m_critsec;
};


// don't let class factory refcount influence lock count
#define DECLARE_CLASSFACTORY_EX(cf) typedef ATL::CComCreator< ATL::CComObjectNoLock< cf > > _ClassFactoryCreatorClass;

#define DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(ATL::CComClassFactory)

#define DECLARE_REGISTRY_RESOURCEID(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) throw()\
	{\
		__if_exists(_GetMiscStatus) \
		{ \
			ATL::_ATL_REGMAP_ENTRY regMapEntries[2]; \
			memset(&regMapEntries[1], 0, sizeof(ATL::_ATL_REGMAP_ENTRY)); \
			regMapEntries[0].szKey = L"OLEMISC"; \
			TCHAR szOleMisc[10]; \
			wsprintf(szOleMisc, _T("%d"), _GetMiscStatus()); \
			USES_CONVERSION; \
			regMapEntries[0].szData = szOleMisc; \
			__if_exists(_Module) \
			{ \
				return _Module.UpdateRegistryFromResource(x, bRegister, regMapEntries); \
			} \
			__if_not_exists(_Module) \
			{ \
				return ATL::_pAtlModule->UpdateRegistryFromResource(x, bRegister, regMapEntries); \
			} \
		} \
		__if_not_exists(_GetMiscStatus) \
		{ \
			__if_exists(_Module) \
			{ \
				return _Module.UpdateRegistryFromResource(x, bRegister); \
			} \
			__if_not_exists(_Module) \
			{ \
				return ATL::_pAtlModule->UpdateRegistryFromResource(x, bRegister); \
			} \
		} \
	}


//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObject : public Base
{
public:
	typedef Base _BaseClass;
	CComObject(void* = NULL) throw()
	{
		_pAtlModule->Lock();
	}
	// Set refcount to -(LONG_MAX/2) to protect destruction and 
	// also catch mismatched Release in debug builds
	~CComObject() throw()
	{
		m_dwRef = -(LONG_MAX/2);
		FinalRelease();
		_pAtlModule->Unlock();
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() throw() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)() throw()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject) throw()
	{return _InternalQueryInterface(iid, ppvObject);}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp) throw()
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}

	static HRESULT WINAPI CreateInstance(CComObject<Base>** pp) throw();
};

template <class Base>
HRESULT WINAPI CComObject<Base>::CreateInstance(CComObject<Base>** pp) throw()
{
	ATLASSERT(pp != NULL);
	if (pp == NULL)
		return E_POINTER;
	*pp = NULL;

	HRESULT hRes = E_OUTOFMEMORY;
	CComObject<Base>* p = NULL;
	ATLTRY(p = new CComObject<Base>())
	if (p != NULL)
	{
		p->SetVoid(NULL);
		p->InternalFinalConstructAddRef();
		hRes = p->FinalConstruct();
		if (SUCCEEDED(hRes))
			hRes = p->_AtlFinalConstruct();
		p->InternalFinalConstructRelease();
		if (hRes != S_OK)
		{
			delete p;
			p = NULL;
		}
	}
	*pp = p;
	return hRes;
}


//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObjectNoLock : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectNoLock(void* = NULL){}
	// Set refcount to -(LONG_MAX/2) to protect destruction and 
	// also catch mismatched Release in debug builds
	~CComObjectNoLock()
	{
		m_dwRef = -(LONG_MAX/2);
		FinalRelease();
	}

	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
};


template <class Base> //Base must be derived from CComObjectRoot
class CComContainedObject : public Base
{
public:
	typedef Base _BaseClass;
	CComContainedObject(void* pv) {m_pOuterUnknown = (IUnknown*)pv;}

        STDMETHOD_(ULONG, AddRef)() {return OuterAddRef();}
        STDMETHOD_(ULONG, Release)() {return OuterRelease();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		return OuterQueryInterface(iid, ppvObject);
	}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	//GetControllingUnknown may be virtual if the Base class has declared
	//DECLARE_GET_CONTROLLING_UNKNOWN()
	IUnknown* GetControllingUnknown()
	{
		return m_pOuterUnknown;
	}
};

//contained is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class contained>
class CComAggObject :
	public IUnknown,
	public CComObjectRootEx< typename contained::_ThreadModel::ThreadModelNoCS >
{
public:
	typedef contained _BaseClass;
	CComAggObject(void* pv) : m_contained(pv)
	{
		_pAtlModule->Lock();
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		return m_contained.FinalConstruct();
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to -(LONG_MAX/2) to protect destruction and 
	// also catch mismatched Release in debug builds
	~CComAggObject()
	{
		m_dwRef = -(LONG_MAX/2);
		FinalRelease();
		_pAtlModule->Unlock();
	}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		ATLASSERT(ppvObject != NULL);
		if (ppvObject == NULL)
			return E_POINTER;
		*ppvObject = NULL;

		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	static HRESULT WINAPI CreateInstance(LPUNKNOWN pUnkOuter, CComAggObject<contained>** pp)
	{
		ATLASSERT(pp != NULL);
		HRESULT hRes = E_OUTOFMEMORY;
		CComAggObject<contained>* p = NULL;
		ATLTRY(p = new CComAggObject<contained>(pUnkOuter))
		if (p != NULL)
		{
			p->SetVoid(NULL);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			if (SUCCEEDED(hRes))
				hRes = p->_AtlFinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes != S_OK)
			{
				delete p;
				p = NULL;
			}
		}
		*pp = p;
		return hRes;
	}

	CComContainedObject<contained> m_contained;
};


class CComClassFactory :
	public IClassFactory,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
	BEGIN_COM_MAP(CComClassFactory)
		COM_INTERFACE_ENTRY(IClassFactory)
	END_COM_MAP()

	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
	{
		ATLASSERT(m_pfnCreateInstance != NULL);
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// can't ask for anything other than IUnknown when aggregating
			
			if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			{
				hRes = CLASS_E_NOAGGREGATION;
			}
			else
				hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
		}
		return hRes;
	}

	STDMETHOD(LockServer)(BOOL fLock)
	{
		if (fLock)
			_pAtlModule->Lock();
		else
			_pAtlModule->Unlock();
		return S_OK;
	}
	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};


template <class T, const CLSID* pclsid = &CLSID_NULL>
class CComCoClass
{
public:
	DECLARE_CLASSFACTORY()
	DECLARE_AGGREGATABLE(T)
	typedef T _CoClass;
	static const CLSID& WINAPI GetObjectCLSID() {return *pclsid;}
	static LPCTSTR WINAPI GetObjectDescription() {return NULL;}
	static HRESULT WINAPI Error(LPCOLESTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
	}
	static HRESULT WINAPI Error(LPCOLESTR lpszDesc, DWORD dwHelpID,
		LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID, lpszHelpFile,
			iid, hRes);
	}
	static HRESULT WINAPI Error(UINT nID, const IID& iid = GUID_NULL,
		HRESULT hRes = 0, HINSTANCE hInst = _AtlBaseModule.GetResourceInstance())
	{
		return AtlReportError(GetObjectCLSID(), nID, iid, hRes, hInst);
	}
	static HRESULT WINAPI Error(UINT nID, DWORD dwHelpID,
		LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL,
		HRESULT hRes = 0, HINSTANCE hInst = _AtlBaseModule.GetResourceInstance())
	{
		return AtlReportError(GetObjectCLSID(), nID, dwHelpID, lpszHelpFile,
			iid, hRes, hInst);
	}
	static HRESULT WINAPI Error(LPCSTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
	}
	static HRESULT WINAPI Error(LPCSTR lpszDesc, DWORD dwHelpID,
		LPCSTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID,
			lpszHelpFile, iid, hRes);
	}
	template <class Q>
	static HRESULT CreateInstance(IUnknown* punkOuter, Q** pp)
	{
		return T::_CreatorClass::CreateInstance(punkOuter, __uuidof(Q), (void**) pp);
	}
	template <class Q>
	static HRESULT CreateInstance(Q** pp)
	{
		return T::_CreatorClass::CreateInstance(NULL, __uuidof(Q), (void**) pp);
	}
};

// ATL doesn't support multiple LCID's at the same time
// Whatever LCID is queried for first is the one that is used.
class CComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wMajor;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;
	struct stringdispid
	{
		CComBSTR bstr;
		int nLen;
		DISPID id;
	};
	stringdispid* m_pMap;
	int m_nCount;

public:

	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
		ATLASSERT(ppInfo != NULL);
		if (ppInfo == NULL)
			return E_POINTER;

		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		*ppInfo = m_pInfo;
		if (m_pInfo != NULL)
		{
			m_pInfo->AddRef();
			hr = S_OK;
		}
		return hr;
	}
	HRESULT GetTI(LCID lcid);
	HRESULT EnsureTI(LCID lcid)
	{
		HRESULT hr = S_OK;
		if (m_pInfo == NULL || m_pMap == NULL)
			hr = GetTI(lcid);
		return hr;
	}

	// This function is called by the module on exit
	// It is registered through _pAtlModule->AddTermFunc()
	static void __stdcall Cleanup(DWORD_PTR dw)
	{
		CComTypeInfoHolder* p = (CComTypeInfoHolder*) dw;
		if (p->m_pInfo != NULL)
			p->m_pInfo->Release();
		p->m_pInfo = NULL;
		delete [] p->m_pMap;
		p->m_pMap = NULL;
	}

	HRESULT GetTypeInfo(UINT /* itinfo */, LCID lcid, ITypeInfo** pptinfo)
	{
		HRESULT hRes = E_POINTER;
		if (pptinfo != NULL)
			hRes = GetTI(lcid, pptinfo);
		return hRes;
	}
	HRESULT GetIDsOfNames(REFIID /* riid */, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
		{
			if (m_pMap != NULL)
			{
				for (int i=0; i<(int)cNames; i++)
				{
					int n = int( lstrlenW(rgszNames[i]) );
					int j;
					for (j=m_nCount-1; j>=0; j--)
					{
						if ((n == m_pMap[j].nLen) &&
							(memcmp(m_pMap[j].bstr, rgszNames[i], m_pMap[j].nLen * sizeof(OLECHAR)) == 0))
						{
							rgdispid[i] = m_pMap[j].id;
							break;
						}
					}
					// if name is not in cache, delegate to ITypeInfo::GetIDsOfNames
					if (j < 0)
					{
						hRes = m_pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
						// since we've gotten all names, break out of loop
						break;
					}
				}
			}
			else
				hRes = m_pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
		}
		return hRes;
	}

	HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID /* riid */,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
		HRESULT hRes = EnsureTI(lcid);
		if (m_pInfo != NULL)
			hRes = m_pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
		return hRes;
	}
	HRESULT LoadNameCache(ITypeInfo* pTypeInfo)
	{
		TYPEATTR* pta;
		HRESULT hr = pTypeInfo->GetTypeAttr(&pta);
		if (SUCCEEDED(hr))
		{
			m_nCount = pta->cFuncs;
			m_pMap = NULL;
			if (m_nCount != 0)
			{
				ATLTRY(m_pMap = new stringdispid[m_nCount]);
				if (m_pMap == NULL)
				{
					pTypeInfo->ReleaseTypeAttr(pta);
					return E_OUTOFMEMORY;
				}
			}
			for (int i=0; i<m_nCount; i++)
			{
				FUNCDESC* pfd;
				if (SUCCEEDED(pTypeInfo->GetFuncDesc(i, &pfd)))
				{
					CComBSTR bstrName;
					if (SUCCEEDED(pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL)))
					{
						m_pMap[i].bstr.Attach(bstrName.Detach());
						m_pMap[i].nLen = SysStringLen(m_pMap[i].bstr);
						m_pMap[i].id = pfd->memid;
					}
					pTypeInfo->ReleaseFuncDesc(pfd);
				}
			}
			pTypeInfo->ReleaseTypeAttr(pta);
		}
		return S_OK;
	}
};


inline HRESULT CComTypeInfoHolder::GetTI(LCID lcid)
{
	//If this assert occurs then most likely didn't initialize properly
	ATLASSERT(m_plibid != NULL && m_pguid != NULL);
	ATLASSERT(!InlineIsEqualGUID(*m_plibid, GUID_NULL) && "Did you forget to pass the LIBID to CComModule::Init?");

	if (m_pInfo != NULL && m_pMap != NULL)
		return S_OK;

	CComCritSecLock<CComCriticalSection> lock(_pAtlModule->m_csStaticDataInitAndTypeInfo, false);
	HRESULT hRes = lock.Lock();
	if (FAILED(hRes))
	{
		ATLASSERT(0);
		return hRes;
	}
	hRes = E_FAIL;
	if (m_pInfo == NULL)
	{
		ITypeLib* pTypeLib;
		hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
		if (SUCCEEDED(hRes))
		{
			CComPtr<ITypeInfo> spTypeInfo;
			hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);
			if (SUCCEEDED(hRes))
			{
				CComPtr<ITypeInfo> spInfo(spTypeInfo);
				CComPtr<ITypeInfo2> spTypeInfo2;
				if (SUCCEEDED(spTypeInfo->QueryInterface(&spTypeInfo2)))
					spInfo = spTypeInfo2;

				m_pInfo = spInfo.Detach();
			}
			pTypeLib->Release();
			_pAtlModule->AddTermFunc(Cleanup, (DWORD_PTR)this);
		}
	}
	else
	{
		// Another thread has loaded the typeinfo so we're OK.
		hRes = S_OK;
	}

	if (m_pInfo != NULL && m_pMap == NULL)
		LoadNameCache(m_pInfo);

	return hRes;
}


#ifndef _ATL_MAX_VARTYPES
#define _ATL_MAX_VARTYPES 8
#endif


/////////////////////////////////////////////////////////////////////////////
// IDispatchImpl

template <class T, const IID* piid = &__uuidof(T), const GUID* plibid = &CAtlModule::m_libid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDispatchImpl : public T
{
public:
	typedef tihclass _tihclass;
// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{
		*pctinfo = 1;
		return S_OK;
	}
	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(itinfo, lcid, pptinfo);
	}
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{
		return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
	}
	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
		return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
		wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
	}


protected:
	static _tihclass _tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
		return _tih.GetTI(lcid, ppInfo);
	}

};

template <class T, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
typename IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
{piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0};


#pragma pack(pop)

}; //namespace ATL

//REVIEW: Just to fix VSEE
#pragma pop_macro("min")
#pragma pop_macro("max")

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif

#endif // __ATLCOM_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atlmfc\atldef.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLDEF_H__
#define __ATLDEF_H__

#pragma once

#include <atlres.h>

#ifndef RC_INVOKED

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifdef UNDER_CE
	#error ATL not currently supported for CE
#endif

#ifdef _UNICODE
#ifndef UNICODE
#define UNICODE         // UNICODE is used by Windows headers
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#define _UNICODE        // _UNICODE is used by C-runtime/MFC headers
#endif
#endif

#ifdef _DEBUG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#ifdef _WIN64
#define _ATL_SUPPORT_VT_I8  // Always support VT_I8 on Win64.
#endif

#ifndef ATLASSERT
#define ATLASSERT(expr) _ASSERTE(expr)
#endif

#ifndef ATLVERIFY
#ifdef _DEBUG
#define ATLVERIFY(expr) ATLASSERT(expr)
#else
#define ATLVERIFY(expr) (expr)
#endif // DEBUG
#endif // ATLVERIFY

///////////////////////////////////////////////////////////////////////////////
// __declspec(novtable) is used on a class declaration to prevent the vtable
// pointer from being initialized in the constructor and destructor for the
// class.  This has many benefits because the linker can now eliminate the
// vtable and all the functions pointed to by the vtable.  Also, the actual
// constructor and destructor code are now smaller.
///////////////////////////////////////////////////////////////////////////////
// This should only be used on a class that is not directly createable but is
// rather only used as a base class.  Additionally, the constructor and
// destructor (if provided by the user) should not call anything that may cause
// a virtual function call to occur back on the object.
///////////////////////////////////////////////////////////////////////////////
// By default, the wizards will generate new ATL object classes with this
// attribute (through the ATL_NO_VTABLE macro).  This is normally safe as long
// the restriction mentioned above is followed.  It is always safe to remove
// this macro from your class, so if in doubt, remove it.
///////////////////////////////////////////////////////////////////////////////

#ifdef _ATL_DISABLE_NO_VTABLE
#define ATL_NO_VTABLE
#else
#define ATL_NO_VTABLE __declspec(novtable)
#endif

#ifdef _ATL_DISABLE_NOTHROW
#define ATL_NOTHROW
#else
#define ATL_NOTHROW __declspec(nothrow)
#endif

#ifdef _ATL_DISABLE_NOINLINE
#define ATL_NOINLINE
#else
#define ATL_NOINLINE __declspec( noinline )
#endif

#ifdef _ATL_DISABLE_DEPRECATED
#define ATL_DEPRECATED
#else
#define ATL_DEPRECATED __declspec( deprecated )
#endif

// If ATL70.DLL is being used then _ATL_STATIC_REGISTRY doesn't really make sense
#ifdef _ATL_DLL
#undef _ATL_STATIC_REGISTRY
#else
// If not linking to ATL70.DLL, use the static registrar and not building atl.dll
#ifndef _ATL_DLL_IMPL
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif
#endif
#endif

#ifdef _DEBUG
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _DEBUG

#ifndef _ATL_HEAPFLAGS
#ifdef _MALLOC_ZEROINIT
#define _ATL_HEAPFLAGS HEAP_ZERO_MEMORY
#else
#define _ATL_HEAPFLAGS 0
#endif
#endif

#ifndef _ATL_PACKING
#define _ATL_PACKING 8
#endif

#if defined(_ATL_DLL)
	#define ATLAPI extern "C" HRESULT __declspec(dllimport) __stdcall
	#define ATLAPI_(x) extern "C" __declspec(dllimport) x __stdcall
	#define ATLINLINE
#elif defined(_ATL_DLL_IMPL)
	#define ATLAPI extern "C" inline HRESULT __stdcall
	#define ATLAPI_(x) extern "C" inline x __stdcall
	#define ATLINLINE
#else
	#define ATLAPI ATL_NOTHROW HRESULT __stdcall
	#define ATLAPI_(x) ATL_NOTHROW x __stdcall
	#define ATLINLINE inline
#endif

#ifdef _ATL_NO_EXCEPTIONS
	#ifdef _AFX
	#error MFC projects cannot define _ATL_NO_EXCEPTIONS
	#endif
#else
	#ifndef _CPPUNWIND
	#define _ATL_NO_EXCEPTIONS
	#endif
#endif

#ifdef _CPPUNWIND

#ifndef ATLTRYALLOC

#ifdef _AFX
#define ATLTRYALLOC(x) try{x;} catch(CException* e){e->Delete();}
#else
#define ATLTRYALLOC(x) try{x;} catch(...){}
#endif	//__AFX

#endif	//ATLTRYALLOC


#else //_CPPUNWIND

#ifndef ATLTRYALLOC
#define ATLTRYALLOC(x) x;
#endif	//ATLTRYALLOC

#endif	//_CPPUNWIND

#ifndef ATLTRY
#define ATLTRY(x) ATLTRYALLOC(x)
#endif	//ATLTRY

#define offsetofclass(base, derived) ((DWORD_PTR)(static_cast<base*>((derived*)_ATL_PACKING))-_ATL_PACKING)

/////////////////////////////////////////////////////////////////////////////
// Master version numbers

#define _ATL     1      // Active Template Library
#define _ATL_VER 0x0700 // Active Template Library version 7.0

/////////////////////////////////////////////////////////////////////////////
// Threading

#ifndef _ATL_SINGLE_THREADED
#ifndef _ATL_APARTMENT_THREADED
#ifndef _ATL_FREE_THREADED
#define _ATL_FREE_THREADED
#endif
#endif
#endif

// UUIDOF
#ifndef _ATL_NO_UUIDOF
#define _ATL_IIDOF(x) __uuidof(x)
#else
#define _ATL_IIDOF(x) IID_##x
#endif

#endif // RC_INVOKED

#define ATLAXWIN_CLASS	"AtlAxWin7"
#define ATLAXWINLIC_CLASS "AtlAxWinLic7"

#endif // __ATLDEF_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atlmfc\atlsimpcoll.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLSIMPCOLL_H__
#define __ATLSIMPCOLL_H__

#pragma once

#include <atldef.h>
#include <wtypes.h>

#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
	#include <crtdbg.h>
#endif


#pragma warning(push)
#pragma warning(disable: 4800) // forcing 'int' value to bool

namespace ATL
{

#pragma push_macro("new")
#undef new

/////////////////////////////////////////////////////////////////////////////
// Collection helper - CSimpleMap

template <class TKey, class TVal>
class CSimpleMapEqualHelper
{
public:
	static bool IsEqualKey(const TKey& k1, const TKey& k2)
	{
		return CSimpleArrayEqualHelper<TKey>::IsEqual(k1, k2);
	}

	static bool IsEqualValue(const TVal& v1, const TVal& v2)
	{
		return CSimpleArrayEqualHelper<TVal>::IsEqual(v1, v2);
	}
};


// intended for small number of simple types or pointers
template <class TKey, class TVal, class TEqual = CSimpleMapEqualHelper< TKey, TVal > >
class CSimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

	typedef TKey _ArrayKeyType;
	typedef TVal _ArrayElementType;

// Construction/destruction
	CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CSimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(const TKey& key, const TVal& val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		InternalSetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(const TKey& key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		if (nIndex < 0 || nIndex >= m_nSize)
			return FALSE;
		m_aKey[nIndex].~TKey();
		m_aVal[nIndex].~TVal();
		if(nIndex != (m_nSize - 1))
		{
			memmove((void*)(m_aKey + nIndex), (void*)(m_aKey + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)(m_aVal + nIndex), (void*)(m_aVal + nIndex + 1), (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aKey != NULL)
		{
			for(int i = 0; i < m_nSize; i++)
			{
				m_aKey[i].~TKey();
				m_aVal[i].~TVal();
			}
			free(m_aKey);
			m_aKey = NULL;
		}
		if(m_aVal != NULL)
		{
			free(m_aVal);
			m_aVal = NULL;
		}

		m_nSize = 0;
	}
	BOOL SetAt(const TKey& key, const TVal& val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		m_aKey[nIndex].~TKey();
		m_aVal[nIndex].~TVal();
		InternalSetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(const TKey& key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;    // must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(const TVal& val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;    // must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

	int FindKey(const TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(TEqual::IsEqualKey(m_aKey[i], key))
				return i;
		}
		return -1;  // not found
	}
	int FindVal(const TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(TEqual::IsEqualValue(m_aVal[i], val))
				return i;
		}
		return -1;  // not found
	}

	BOOL SetAtIndex(int nIndex, const TKey& key, const TVal& val)
	{
		if (nIndex < 0 || nIndex >= m_nSize)
			return FALSE;
		InternalSetAtIndex(nIndex, key, val);
		return TRUE;
	}


// Implementation

	template <typename T>
	class Wrapper
	{
	public:
		Wrapper(const T& _t) : t(_t)
		{
		}
		template <class _Ty>
		void *operator new(size_t, _Ty* p)
		{
			return p;
		}
		template <class _Ty>
		void operator delete(void* /* pv */, _Ty* /* p */)
		{
		}
		T t;
	};
	void InternalSetAtIndex(int nIndex, const TKey& key, const TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		new(m_aKey + nIndex) Wrapper<TKey>(key);
		new(m_aVal + nIndex) Wrapper<TVal>(val);
	}
};

#pragma pop_macro("new")

};  // namespace ATL

#pragma warning(pop)

#endif  // __ATLSIMPCOLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atls\atlbase.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CAtlBaseModule	_AtlBaseModule;

};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\commd5\atl.cpp ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        atl.cpp

    Abstract:

        Includes ATL class and function implementations.

    Author:

        Darren L. Anderson (darrenan) 29-Jun-1998

    Revision History:

        29-Jun-1998 darrenan

            Created.
--*/

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atlmfc\statreg.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __STATREG_H__
#define __STATREG_H__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error statreg.h requires atlbase.h to be included first
#endif

#define E_ATL_REGISTRAR_DESC              0x0201
#define E_ATL_NOT_IN_MAP                  0x0202
#define E_ATL_UNEXPECTED_EOS              0x0203
#define E_ATL_VALUE_SET_FAILED            0x0204
#define E_ATL_RECURSE_DELETE_FAILED       0x0205
#define E_ATL_EXPECTING_EQUAL             0x0206
#define E_ATL_CREATE_KEY_FAILED           0x0207
#define E_ATL_DELETE_KEY_FAILED           0x0208
#define E_ATL_OPEN_KEY_FAILED             0x0209
#define E_ATL_CLOSE_KEY_FAILED            0x020A
#define E_ATL_UNABLE_TO_COERCE            0x020B
#define E_ATL_BAD_HKEY                    0x020C
#define E_ATL_MISSING_OPENKEY_TOKEN       0x020D
#define E_ATL_CONVERT_FAILED              0x020E
#define E_ATL_TYPE_NOT_SUPPORTED          0x020F
#define E_ATL_COULD_NOT_CONCAT            0x0210
#define E_ATL_COMPOUND_KEY                0x0211
#define E_ATL_INVALID_MAPKEY              0x0212
#define E_ATL_UNSUPPORTED_VT              0x0213
#define E_ATL_VALUE_GET_FAILED            0x0214
#define E_ATL_VALUE_TOO_LARGE             0x0215
#define E_ATL_MISSING_VALUE_DELIMETER     0x0216
#define E_ATL_DATA_NOT_BYTE_ALIGNED       0x0217

namespace ATL
{
const TCHAR  chDirSep            = _T('\\');
const TCHAR  chRightBracket      = _T('}');
const TCHAR  chLeftBracket       = _T('{');
const TCHAR  chQuote             = _T('\'');
const TCHAR  chEquals            = _T('=');
const LPCTSTR  szStringVal       = _T("S");
const LPCTSTR  multiszStringVal  = _T("M");
const LPCTSTR  szDwordVal        = _T("D");
const LPCTSTR  szBinaryVal       = _T("B");
const LPCTSTR  szValToken        = _T("Val");
const LPCTSTR  szForceRemove     = _T("ForceRemove");
const LPCTSTR  szNoRemove        = _T("NoRemove");
const LPCTSTR  szDelete          = _T("Delete");


// Implementation helper
class CExpansionVectorEqualHelper
{
public:
	static bool IsEqualKey(const LPTSTR k1, const LPTSTR k2)
	{
		if (lstrcmpi(k1, k2) == 0)
			return true;
		return false;
	}
};

// Implementation helper
class CExpansionVector : public CSimpleMap<LPTSTR, LPOLESTR, CExpansionVectorEqualHelper >
{
public:
	~CExpansionVector()
	{
		 ClearReplacements();
	}

	BOOL Add(LPCTSTR lpszKey, LPCOLESTR lpszValue)
	{
		ATLASSERT(lpszKey != NULL && lpszValue != NULL);
		if (lpszKey == NULL || lpszValue == NULL)
			return FALSE;

		HRESULT hRes = S_OK;

		size_t cbKey = (lstrlen(lpszKey)+1)*sizeof(TCHAR);
		TCHAR* szKey = NULL;
		
		ATLTRY(szKey = new TCHAR[cbKey];)

		size_t cbValue = (lstrlenW(lpszValue)+1)*sizeof(OLECHAR);
		LPOLESTR szValue = NULL;
		ATLTRY(szValue = new OLECHAR[cbValue];)
		
		if (szKey == NULL || szValue == NULL)
			hRes = E_OUTOFMEMORY;
		else
		{
			memcpy(szKey, lpszKey, cbKey);
			memcpy(szValue, lpszValue, cbValue);
			if (!CSimpleMap<LPTSTR, LPOLESTR, CExpansionVectorEqualHelper>::Add(szKey, szValue))
				hRes = E_OUTOFMEMORY;
		}
		if (FAILED(hRes))
		{
			delete []szKey;
			delete []szValue;
		}
		return SUCCEEDED(hRes);
	}
	HRESULT ClearReplacements()
	{
		for (int i = 0; i < GetSize(); i++)
		{
			delete []GetKeyAt(i);
			delete []GetValueAt(i);
		}
		RemoveAll();
		return S_OK;
	}
};

class CRegObject;

class CRegParser
{
public:
	CRegParser(CRegObject* pRegObj);

	HRESULT  PreProcessBuffer(LPTSTR lpszReg, LPTSTR* ppszReg);
	HRESULT  RegisterBuffer(LPTSTR szReg, BOOL bRegister);

protected:

	void    SkipWhiteSpace();
	HRESULT NextToken(LPTSTR szToken);
	HRESULT AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken);
	BOOL    CanForceRemoveKey(LPCTSTR szKey);
	BOOL    HasSubKeys(HKEY hkey);
	HRESULT RegisterSubkeys(LPTSTR szToken, HKEY hkParent, BOOL bRegister, BOOL bInRecovery = FALSE);
	BOOL    IsSpace(TCHAR ch);
	LPTSTR  m_pchCur;

	CRegObject*     m_pRegObj;

	HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}
	HRESULT SkipAssignment(LPTSTR szToken);

	BOOL    EndOfVar() { return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur); }
	static LPTSTR StrChr(LPTSTR lpsz, TCHAR ch);
	static HKEY HKeyFromString(LPTSTR szToken);
	static BYTE ChToByte(const TCHAR ch);
	static BOOL VTFromRegType(LPCTSTR szValueType, VARTYPE& vt);
	static LPCTSTR rgszNeverDelete[];
	static const int cbNeverDelete;
	static const int MAX_VALUE = 4096;
	static const int MAX_TYPE = 4096;
	
	// Implementation Helper
	class CParseBuffer
	{
	public:
		int nPos;
		int nSize;
		LPTSTR p;
		CParseBuffer(int nInitial)
		{
			if (nInitial < 100)
				nInitial = 1000;
			nPos = 0;
			nSize = nInitial;
			p = (LPTSTR) CoTaskMemAlloc(nSize*sizeof(TCHAR));
			if (p != NULL)
				*p = NULL;
		}
		~CParseBuffer()
		{
			CoTaskMemFree(p);
		}
		BOOL Append(const TCHAR* pch, int nChars)
		{
                        if (p == NULL)
                        {
                            return FALSE;
                        }

			if ((nPos + nChars + 1) >= nSize)
			{
				while ((nPos + nChars + 1) >= nSize)
					nSize *=2;
				LPTSTR pTemp = (LPTSTR) CoTaskMemRealloc(p, nSize*sizeof(TCHAR));
				if (pTemp == NULL)
					return FALSE;
				p = pTemp;
			}
			memcpy(p + nPos, pch, int(nChars * sizeof(TCHAR)));
			nPos += nChars;
			*(p + nPos) = NULL;
			return TRUE;			
		}
		
		BOOL AddChar(const TCHAR* pch)
		{
			int nChars = 1;
			return Append(pch, nChars);

		}
		BOOL AddString(LPCOLESTR lpsz)
		{
			if (lpsz == NULL)
				return FALSE;
			USES_CONVERSION;
			LPCTSTR lpszT = lpsz;
			if (lpszT == NULL)
				return FALSE;
			return Append(lpszT, (int)lstrlen(lpszT));
		}
		LPTSTR Detach()
		{
			LPTSTR lp = p;
			p = NULL;
			nSize = nPos = 0;
			return lp;
		}

	};
};

class CRegObject  : public IRegistrarBase
{
public:

	STDMETHOD(QueryInterface)(const IID &,void ** )
	{
		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
		return E_NOTIMPL;
	}

	STDMETHOD_(ULONG, AddRef)(void)
	{
		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
		return 1;
	}
	STDMETHOD_(ULONG, Release)(void)
	{
		ATLASSERT(_T("statically linked in CRegObject is not a com object. Do not callthis function"));
		return 0;
	}

	~CRegObject(){ClearReplacements();}
	HRESULT FinalConstruct() {return S_OK;}
	void FinalRelease() {}


	// Map based methods
	HRESULT STDMETHODCALLTYPE AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem);
	HRESULT STDMETHODCALLTYPE ClearReplacements();
	LPCOLESTR StrFromMap(LPTSTR lpszKey);

	// Register via a given mechanism
	HRESULT STDMETHODCALLTYPE ResourceRegister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceRegisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE FileRegister(LPCOLESTR bstrFileName)
	{
		return CommonFileRegister(bstrFileName, TRUE);
	}

	HRESULT STDMETHODCALLTYPE FileUnregister(LPCOLESTR bstrFileName)
	{
		return CommonFileRegister(bstrFileName, FALSE);
	}

	HRESULT STDMETHODCALLTYPE StringRegister(LPCOLESTR bstrData)
	{
		return RegisterWithString(bstrData, TRUE);
	}

	HRESULT STDMETHODCALLTYPE StringUnregister(LPCOLESTR bstrData)
	{
		return RegisterWithString(bstrData, FALSE);
	}

protected:

	HRESULT CommonFileRegister(LPCOLESTR pszFileName, BOOL bRegister);
	HRESULT RegisterFromResource(LPCOLESTR pszFileName, LPCTSTR pszID, LPCTSTR pszType, BOOL bRegister);
	HRESULT RegisterWithString(LPCOLESTR pszData, BOOL bRegister);

	static HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}

	CExpansionVector                                m_RepMap;
	CComObjectThreadModel::AutoCriticalSection      m_csMap;
};

inline HRESULT STDMETHODCALLTYPE CRegObject::AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem)
{
	if (lpszKey == NULL || lpszItem == NULL)
		return E_INVALIDARG;
	m_csMap.Lock();
	USES_CONVERSION;
	BOOL bRet = m_RepMap.Add(lpszKey, lpszItem);
	m_csMap.Unlock();
	return bRet ? S_OK : E_OUTOFMEMORY;
}

inline HRESULT CRegObject::RegisterFromResource(LPCOLESTR bstrFileName, LPCTSTR szID,
										 LPCTSTR szType, BOOL bRegister)
{
	USES_CONVERSION;

	HRESULT     hr;
	CRegParser  parser(this);
	HINSTANCE   hInstResDll;
	HRSRC       hrscReg;
	HGLOBAL     hReg;
	DWORD       dwSize;
	LPSTR       szRegA;
	LPTSTR      szReg;

	hInstResDll = LoadLibraryEx(bstrFileName, NULL, LOAD_LIBRARY_AS_DATAFILE);

	if (NULL == hInstResDll)
	{
		hr = AtlHresultFromLastError();
		goto ReturnHR;
	}

	hrscReg = FindResource((HMODULE)hInstResDll, szID, szType);

	if (NULL == hrscReg)
	{
		hr = AtlHresultFromLastError();
		goto ReturnHR;
	}

	hReg = LoadResource((HMODULE)hInstResDll, hrscReg);

	if (NULL == hReg)
	{
		hr = AtlHresultFromLastError();
		goto ReturnHR;
	}

	dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg);
	szRegA = (LPSTR)hReg;
	if (szRegA[dwSize] != NULL)
	{
		szRegA = (LPSTR) LocalAlloc(LMEM_FIXED, dwSize+1);

		if (szRegA == NULL)
		{
			hr = AtlHresultFromLastError();
			goto ReturnHR;
		}

		memcpy(szRegA, (void*)hReg, dwSize+1);
		szRegA[dwSize] = NULL;
	}

	szReg = A2W(szRegA);

	hr = parser.RegisterBuffer(szReg, bRegister);

        if (szRegA != (LPSTR)hReg)
        {
            LocalFree(szRegA);
        }

ReturnHR:

	if (NULL != hInstResDll)
		FreeLibrary((HMODULE)hInstResDll);
	return hr;
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), szType, TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;
	return RegisterFromResource(szFileName, szID, szType, TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), szType, FALSE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;

	return RegisterFromResource(szFileName, szID, szType, FALSE);
}

inline HRESULT CRegObject::RegisterWithString(LPCOLESTR bstrData, BOOL bRegister)
{
	USES_CONVERSION;
	CRegParser  parser(this);

	LPCTSTR szReg = bstrData;
	if (szReg == NULL)
		return E_OUTOFMEMORY;

	HRESULT hr = parser.RegisterBuffer((LPTSTR)szReg, bRegister);

	return hr;
}

inline HRESULT CRegObject::ClearReplacements()
{
	m_csMap.Lock();
	HRESULT hr = m_RepMap.ClearReplacements();
	m_csMap.Unlock();
	return hr;
}


inline LPCOLESTR CRegObject::StrFromMap(LPTSTR lpszKey)
{
	USES_CONVERSION;
	m_csMap.Lock();
	LPCOLESTR lpsz = m_RepMap.Lookup(lpszKey);
	m_csMap.Unlock();
	return lpsz;
}

inline HRESULT CRegObject::CommonFileRegister(LPCOLESTR bstrFileName, BOOL bRegister)
{
	USES_CONVERSION;

	CRegParser  parser(this);

	HANDLE hFile = CreateFile(bstrFileName, GENERIC_READ, 0, NULL,
							  OPEN_EXISTING,
							  FILE_ATTRIBUTE_READONLY,
							  NULL);
	if (INVALID_HANDLE_VALUE == hFile)
	{
		return AtlHresultFromLastError();
	}

	HRESULT hRes = S_OK;
	DWORD cbRead;
	DWORD cbFile = GetFileSize(hFile, NULL); // No HiOrder DWORD required

	char* szReg = (char*) LocalAlloc(LMEM_FIXED, cbFile + 1);

	if (szReg == NULL)
	{
		hRes =  AtlHresultFromLastError();
	}
	else if (ReadFile(hFile, szReg, cbFile, &cbRead, NULL) == 0)
	{
		hRes =  AtlHresultFromLastError();
	}

	if (SUCCEEDED(hRes))
	{
		szReg[cbRead] = NULL;
		LPTSTR szConverted = A2W(szReg);
		hRes = parser.RegisterBuffer(szConverted, bRegister);
	}

	LocalFree(szReg);
	CloseHandle(hFile);
	return hRes;
}

__declspec(selectany) LPCTSTR CRegParser::rgszNeverDelete[] =
{
	_T("AppID"),
	_T("CLSID"),
	_T("Component Categories"),
	_T("FileType"),
	_T("Interface"),
	_T("Hardware"),
	_T("Mime"),
	_T("SAM"),
	_T("SECURITY"),
	_T("SYSTEM"),
	_T("Software"),
	_T("TypeLib")
};

__declspec(selectany) const int CRegParser::cbNeverDelete = sizeof(rgszNeverDelete) / sizeof(LPCTSTR*);


inline BOOL CRegParser::VTFromRegType(LPCTSTR szValueType, VARTYPE& vt)
{
	struct typemap
	{
		LPCTSTR lpsz;
		VARTYPE vt;
	};
	static const typemap map[] = {
		{szStringVal, VT_BSTR},
		{multiszStringVal, VT_BSTR | VT_BYREF},
		{szDwordVal,  VT_UI4},
		{szBinaryVal, VT_UI1}
	};

	for (int i=0;i<sizeof(map)/sizeof(typemap);i++)
	{
		if (!lstrcmpi(szValueType, map[i].lpsz))
		{
			vt = map[i].vt;
			return TRUE;
		}
	}

	return FALSE;

}

inline BYTE CRegParser::ChToByte(const TCHAR ch)
{
	switch (ch)
	{
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
				return (BYTE) (ch - '0');
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
				return (BYTE) (10 + (ch - 'A'));
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
				return (BYTE) (10 + (ch - 'a'));
		default:
				ATLASSERT(FALSE);
				return 0;
	}
}

inline HKEY CRegParser::HKeyFromString(LPTSTR szToken)
{
	struct keymap
	{
		LPCTSTR lpsz;
		HKEY hkey;
	};
	static const keymap map[] = {
		{_T("HKCR"), HKEY_CLASSES_ROOT},
		{_T("HKCU"), HKEY_CURRENT_USER},
		{_T("HKLM"), HKEY_LOCAL_MACHINE},
		{_T("HKU"),  HKEY_USERS},
		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
		{_T("HKDD"), HKEY_DYN_DATA},
		{_T("HKCC"), HKEY_CURRENT_CONFIG},
		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
		{_T("HKEY_USERS"), HKEY_USERS},
		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
	};

	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)
	{
		if (!lstrcmpi(szToken, map[i].lpsz))
			return map[i].hkey;
	}
	return NULL;
}

inline LPTSTR CRegParser::StrChr(LPTSTR lpsz, TCHAR ch)
{
	LPTSTR p = NULL;
	while (*lpsz)
	{
		if (*lpsz == ch)
		{
			p = lpsz;
			break;
		}
		lpsz = CharNext(lpsz);
	}
	return p;
}

inline CRegParser::CRegParser(CRegObject* pRegObj)
{
	m_pRegObj           = pRegObj;
	m_pchCur            = NULL;
}

inline BOOL CRegParser::IsSpace(TCHAR ch)
{
	switch (ch)
	{
		case _T(' '):
		case _T('\t'):
		case _T('\r'):
		case _T('\n'):
				return TRUE;
	}

	return FALSE;
}

inline void CRegParser::SkipWhiteSpace()
{
	while(IsSpace(*m_pchCur))
		m_pchCur = CharNext(m_pchCur);
}

inline HRESULT CRegParser::NextToken(LPTSTR szToken)
{
	USES_CONVERSION;

	SkipWhiteSpace();

	// NextToken cannot be called at EOS
	if (NULL == *m_pchCur)
		return GenerateError(E_ATL_UNEXPECTED_EOS);

	// handle quoted value / key
	if (chQuote == *m_pchCur)
	{
		LPCTSTR szOrig = szToken;

		m_pchCur = CharNext(m_pchCur);

		while (NULL != *m_pchCur && !EndOfVar())
		{
			if (chQuote == *m_pchCur) // If it is a quote that means we must skip it
				m_pchCur = CharNext(m_pchCur);

			LPTSTR pchPrev = m_pchCur;
			m_pchCur = CharNext(m_pchCur);

			if (szToken + sizeof(WORD) >= MAX_VALUE + szOrig)
				return GenerateError(E_ATL_VALUE_TOO_LARGE);
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		if (NULL == *m_pchCur)
		{
			return GenerateError(E_ATL_UNEXPECTED_EOS);
		}

		*szToken = NULL;
		m_pchCur = CharNext(m_pchCur);
	}

	else
	{   // Handle non-quoted ie parse up till first "White Space"
		while (NULL != *m_pchCur && !IsSpace(*m_pchCur))
		{
			LPTSTR pchPrev = m_pchCur;
			m_pchCur = CharNext(m_pchCur);
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		*szToken = NULL;
	}
	return S_OK;
}

inline HRESULT CRegParser::AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken)
{
	USES_CONVERSION;
	HRESULT hr;

	TCHAR       szTypeToken[MAX_TYPE];
	VARTYPE     vt = VT_EMPTY;
	LONG        lRes = ERROR_SUCCESS;
	UINT        nIDRes = 0;

	if (FAILED(hr = NextToken(szTypeToken)))
		return hr;
	if (!VTFromRegType(szTypeToken, vt))
	{
		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);
	}

	TCHAR szValue[MAX_VALUE];
	SkipWhiteSpace();
	if (FAILED(hr = NextToken(szValue)))
		return hr;
	ULONG ulVal;

	switch (vt)
	{
	case VT_BSTR:
		lRes = rkParent.SetStringValue(szValueName, szValue);
		break;
	case VT_BSTR | VT_BYREF:
		{
			int nLen = lstrlen(szValue);
			TCHAR* pszDestValue = (TCHAR *) LocalAlloc(LMEM_FIXED, nLen * sizeof(TCHAR));

			if (pszDestValue != NULL)
			{
				TCHAR* p = pszDestValue;
				TCHAR* q = szValue;
				nLen = 0;
				while (*q != NULL)
				{
					TCHAR* r = CharNext(q);
					if (*q == '\\' && *r == '0')
					{
						*p++ = NULL;
						q = CharNext(r);
					}
					else
					{
						*p = *q;
						p++;
						q++;
					}
					nLen ++;
				}
				*p = NULL;
				lRes = rkParent.SetMultiStringValue(szValueName, pszDestValue);

                                LocalFree(pszDestValue);
			}
			else
			{
				lRes = ERROR_OUTOFMEMORY;
			}
		}
		break;
	case VT_UI4:
		VarUI4FromStr(szValue, 0, 0, &ulVal);
		lRes = rkParent.SetDWORDValue(szValueName, ulVal);
		break;
	case VT_UI1:
		{
			int cbValue = lstrlen(szValue);
			if (cbValue & 0x00000001)
			{
				return E_FAIL;
			}
			int cbValDiv2 = cbValue/2;
			BYTE* rgBinary = (BYTE*) LocalAlloc(LMEM_ZEROINIT, cbValDiv2*sizeof(BYTE));

                        if (rgBinary == NULL)
                        {
                            return E_FAIL;
                        }
                        else
                        {
				for (int irg = 0; irg < cbValue; irg++)
					rgBinary[(irg/2)] |= (ChToByte(szValue[irg]))
								<< (4*(1 - (irg & 0x00000001)));
				lRes = RegSetValueEx(rkParent, szValueName, 0, REG_BINARY, rgBinary, cbValDiv2);

                                LocalFree(rgBinary);
			}

			break;
		}
	}

	if (ERROR_SUCCESS != lRes)
	{
		nIDRes = E_ATL_VALUE_SET_FAILED;
		return AtlHresultFromWin32(lRes);
	}

	if (FAILED(hr = NextToken(szToken)))
		return hr;

	return S_OK;
}

inline BOOL CRegParser::CanForceRemoveKey(LPCTSTR szKey)
{
	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)
		if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel]))
			 return FALSE;                       // We cannot delete it

	return TRUE;
}

inline BOOL CRegParser::HasSubKeys(HKEY hkey)
{
	DWORD       cbSubKeys = 0;

	if (RegQueryInfoKey(hkey, NULL, NULL, NULL,
			    &cbSubKeys, NULL, NULL,
			    NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
	{
		ATLASSERT(FALSE);
		return FALSE;
	}

	return cbSubKeys > 0;
}


inline HRESULT CRegParser::SkipAssignment(LPTSTR szToken)
{
	HRESULT hr;
	TCHAR szValue[MAX_VALUE];

	if (*szToken == chEquals)
	{
		if (FAILED(hr = NextToken(szToken)))
			return hr;
		// Skip assignment
		SkipWhiteSpace();
		if (FAILED(hr = NextToken(szValue)))
			return hr;
		if (FAILED(hr = NextToken(szToken)))
			return hr;
	}

	return S_OK;
}

inline HRESULT CRegParser::PreProcessBuffer(LPTSTR lpszReg, LPTSTR* ppszReg)
{
	USES_CONVERSION;
	ATLASSERT(lpszReg != NULL);
	ATLASSERT(ppszReg != NULL);
	*ppszReg = NULL;
	int nSize = lstrlen(lpszReg) * sizeof(WCHAR);
	CParseBuffer pb(nSize);
	if (pb.p == NULL)
		return E_OUTOFMEMORY;
	m_pchCur = lpszReg;
	HRESULT hr = S_OK;

	while (*m_pchCur != NULL) // look for end
	{
		if (*m_pchCur == _T('%'))
		{
			m_pchCur = CharNext(m_pchCur);
			if (*m_pchCur == _T('%'))
			{
				if (!pb.AddChar(m_pchCur))
				{
					hr = E_OUTOFMEMORY;
					break;
				}
			}
			else
			{
				LPTSTR lpszNext = StrChr(m_pchCur, _T('%'));
				if (lpszNext == NULL)
				{
					hr = GenerateError(E_ATL_UNEXPECTED_EOS);
					break;
				}

				//
				// 32 is max length of an int as a string + NULL
				//

				if ((lpszNext-m_pchCur) > 31)
				{
					hr = E_FAIL;
					break;
				}

				int nLength = int(lpszNext - m_pchCur);
				TCHAR buf[32];

				lstrcpyn(buf, m_pchCur, nLength+1);

				LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);

				if (lpszVar == NULL)
				{
					hr = GenerateError(E_ATL_NOT_IN_MAP);
					break;
				}
				if (!pb.AddString(lpszVar))
				{
					hr = E_OUTOFMEMORY;
					break;
				}

				while (m_pchCur != lpszNext)
					m_pchCur = CharNext(m_pchCur);
			}
		}
		else
		{
			if (!pb.AddChar(m_pchCur))
			{
				hr = E_OUTOFMEMORY;
				break;
			}
		}

		m_pchCur = CharNext(m_pchCur);
	}
	if (SUCCEEDED(hr))
		*ppszReg = pb.Detach();
	return hr;
}

inline HRESULT CRegParser::RegisterBuffer(LPTSTR szBuffer, BOOL bRegister)
{
	TCHAR   szToken[MAX_VALUE];
	HRESULT hr = S_OK;

	LPTSTR szReg;
	hr = PreProcessBuffer(szBuffer, &szReg);
	if (FAILED(hr))
		return hr;

	m_pchCur = szReg;

	// Preprocess szReg

	while (NULL != *m_pchCur)
	{
		if (FAILED(hr = NextToken(szToken)))
			break;
		HKEY hkBase;
		if ((hkBase = HKeyFromString(szToken)) == NULL)
		{
			hr = GenerateError(E_ATL_BAD_HKEY);
			break;
		}

		if (FAILED(hr = NextToken(szToken)))
			break;

		if (chLeftBracket != *szToken)
		{
			hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);
			break;
		}
		if (bRegister)
		{
			LPTSTR szRegAtRegister = m_pchCur;
			hr = RegisterSubkeys(szToken, hkBase, bRegister);
			if (FAILED(hr))
			{
				m_pchCur = szRegAtRegister;
				RegisterSubkeys(szToken, hkBase, FALSE);
				break;
			}
		}
		else
		{
			if (FAILED(hr = RegisterSubkeys(szToken, hkBase, bRegister)))
				break;
		}

		SkipWhiteSpace();
	}
	CoTaskMemFree(szReg);
	return hr;
}

inline HRESULT CRegParser::RegisterSubkeys(LPTSTR szToken, HKEY hkParent, BOOL bRegister, BOOL bRecover)
{
	CRegKey keyCur;
	LONG    lRes;
	LPTSTR  szKey = NULL;
	BOOL    bDelete = TRUE;
	BOOL    bInRecovery = bRecover;
	HRESULT hr = S_OK;

	if (FAILED(hr = NextToken(szToken)))
		return hr;


	while (*szToken != chRightBracket) // Continue till we see a }
	{
		bDelete = TRUE;
		BOOL bTokenDelete = !lstrcmpi(szToken, szDelete);

		if (bTokenDelete || !lstrcmpi(szToken, szForceRemove))
		{
			if (FAILED(hr = NextToken(szToken)))
				break;

			if (bRegister)
			{
				CRegKey rkForceRemove;

				if (StrChr(szToken, chDirSep) != NULL)
				{
					hr = GenerateError(E_ATL_COMPOUND_KEY);
					break;
				}

				if (CanForceRemoveKey(szToken))
				{
					rkForceRemove.Attach(hkParent);
					// Error not returned. We will overwrite the values any way.
					rkForceRemove.RecurseDeleteKey(szToken);
					rkForceRemove.Detach();
				}

				if (bTokenDelete)
				{
					if (FAILED(hr = NextToken(szToken)))
						break;
					if (FAILED(hr = SkipAssignment(szToken)))
						break;
					goto EndCheck;
				}
			}

		}

		if (!lstrcmpi(szToken, szNoRemove))
		{
			bDelete = FALSE;    // set even for register
			if (FAILED(hr = NextToken(szToken)))
				break;
		}

		if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent
		{
			TCHAR  szValueName[_MAX_PATH];

			if (FAILED(hr = NextToken(szValueName)))
				break;
			if (FAILED(hr = NextToken(szToken)))
				break;


			if (*szToken != chEquals)
			{
				hr = GenerateError(E_ATL_EXPECTING_EQUAL);
				break;
			}

			if (bRegister)
			{
				CRegKey rk;

				rk.Attach(hkParent);
				hr = AddValue(rk, szValueName, szToken);
				rk.Detach();

				if (FAILED(hr))
				{
					break;
				}

				goto EndCheck;
			}
			else
			{
				if (!bRecover && bDelete)
				{
					// We have to open the key for write to be able to delete.
					CRegKey rkParent;
					lRes = rkParent.Open(hkParent, NULL, KEY_WRITE);
					if (lRes == ERROR_SUCCESS)
					{
						lRes = rkParent.DeleteValue(szValueName);
						if (lRes != ERROR_SUCCESS && lRes != ERROR_FILE_NOT_FOUND)
						{
							// Value not present is not an error
							hr = AtlHresultFromWin32(lRes);
							break;
						}
					}
					else
					{
						hr = AtlHresultFromWin32(lRes);
						break;
					}
				}
				if (FAILED(hr = SkipAssignment(szToken)))
					break;
				continue;  // can never have a subkey
			}
		}

		if (StrChr(szToken, chDirSep) != NULL)
		{
			hr = GenerateError(E_ATL_COMPOUND_KEY);
			break;
		}

		if (bRegister)
		{
			lRes = keyCur.Open(hkParent, szToken, KEY_READ | KEY_WRITE);
			if (ERROR_SUCCESS != lRes)
			{
				// Failed all access try read only
				lRes = keyCur.Open(hkParent, szToken, KEY_READ);
				if (ERROR_SUCCESS != lRes)
				{
					// Finally try creating it
					lRes = keyCur.Create(hkParent, szToken, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE);
					if (lRes != ERROR_SUCCESS)
					{
						hr = AtlHresultFromWin32(lRes);
						break;
					}
				}
			}

			if (FAILED(hr = NextToken(szToken)))
				break;


			if (*szToken == chEquals)
			{
				if (FAILED(hr = AddValue(keyCur, NULL, szToken))) // NULL == default
					break;
			}
		}
		else
		{
			if (!bRecover)
				lRes = keyCur.Open(hkParent, szToken, KEY_READ);
			else
				lRes = ERROR_FILE_NOT_FOUND;


			// Open failed set recovery mode
			if (lRes != ERROR_SUCCESS)
				bRecover = true;

			// Remember Subkey
			if (szKey == NULL)
			{
				szKey = (LPTSTR) LocalAlloc(LMEM_FIXED, sizeof(TCHAR)*_MAX_PATH);

				if (szKey == NULL)
				{
					hr = AtlHresultFromWin32(ERROR_OUTOFMEMORY);
					break;
				}
			}

			lstrcpyn(szKey, szToken, _MAX_PATH);

			if (FAILED(hr = NextToken(szToken)))
				break;
			if (FAILED(hr = SkipAssignment(szToken)))
				break;

			if (*szToken == chLeftBracket)
			{
				hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, bRecover);
				// In recover mode ignore error
				if (FAILED(hr) && !bRecover)
					break;
				// Skip the }
				if (FAILED(hr = NextToken(szToken)))
					break;
			}

			bRecover = bInRecovery;
			
			if (lRes == ERROR_FILE_NOT_FOUND)
				// Key already not present so not an error.
				continue;

			if (lRes != ERROR_SUCCESS)
			{
				// We are recovery mode continue on errors else break
				if (bRecover)
					continue;
				else
				{
					hr = AtlHresultFromWin32(lRes);
					break;
				}
			}

			// If in recovery mode
			if (bRecover && HasSubKeys(keyCur))
			{
				// See if the KEY is in the NeverDelete list and if so, don't
				if (CanForceRemoveKey(szKey) && bDelete)
				{
					// Error not returned since we are in recovery mode.
					// The error that caused recovery mode is returned

					keyCur.RecurseDeleteKey(szKey);
				}
				continue;
			}

			lRes = keyCur.Close();
			if (lRes != ERROR_SUCCESS)
			{
				hr = AtlHresultFromWin32(lRes);
				break;
			}

			if (bDelete)
			{
				CRegKey rkParent;
				rkParent.Attach(hkParent);
				lRes = rkParent.DeleteSubKey(szKey);
				rkParent.Detach();
				if (lRes != ERROR_SUCCESS)
				{
					hr = AtlHresultFromWin32(lRes);
					break;
				}
			}
		}

EndCheck:

		if (bRegister)
		{
			if (*szToken == chLeftBracket && lstrlen(szToken) == 1)
			{
				if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, FALSE)))
					break;
				if (FAILED(hr = NextToken(szToken)))
					break;
			}
		}
	}

	LocalFree(szKey);

	return hr;
}

}; //namespace ATL

#endif //__STATREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\commd5\comd5.cpp ===
// CoMD5.cpp : Implementation of CCoMD5
#include "stdafx.h"
#include "ComMD5.h"
#include "CoMD5.h"
#include "pperr.h"

/////////////////////////////////////////////////////////////////////////////
// CCoMD5

VOID
ToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    )

/*++

Routine Description:

    Convert binary data to ASCII hex representation

Arguments:

    pSrc - binary data to convert
    cSrc - length of binary data
    pDst - buffer receiving ASCII representation of pSrc

Return Value:

    Nothing

--*/

{
#define TOHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( UINT x = 0, y = 0 ; x < cSrc ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        pDst[y++] = TOHEX( v );
        v = pSrc[x]&0x0f;
        pDst[y++] = TOHEX( v );
    }
    pDst[y] = '\0';
}

LONG MD5(UCHAR* pBuf, UINT nBuf, UCHAR* digest)
{
    MD5_CTX context;

    if(pBuf==NULL || IsBadReadPtr((CONST VOID*)pBuf, (UINT)nBuf))
    {
        return ERROR_INVALID_PARAMETER;
    }

    MD5Init (&context);
    MD5Update (&context, pBuf, nBuf);
    MD5Final (&context);

    memcpy(digest, context.digest, 16);

    return ERROR_SUCCESS;
}

STDMETHODIMP
CCoMD5::MD5HashASCII(
    BSTR    bstrSource,
    BSTR*   pbstrDigest
    )
{
    HRESULT hr;
    LONG    lResult;
    UCHAR   achDigest[20];
    CHAR    achDigestStr[36];

    if (NULL == pbstrDigest)
    {
        return E_POINTER;
    }
    lResult = MD5((UCHAR*)(CHAR*)bstrSource, 
                    ::SysStringByteLen(bstrSource), 
                    achDigest);
    if(lResult != ERROR_SUCCESS)
    {
        hr = PP_E_MD5_HASH_FAILED;
        goto Cleanup;
    }

    ToHex(achDigest, 16, achDigestStr);

    *pbstrDigest = ::SysAllocStringByteLen(achDigestStr, ::strlen(achDigestStr));
    if(*pbstrDigest == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}

STDMETHODIMP
CCoMD5::MD5Hash(
    BSTR    bstrSource,
    BSTR*   pbstrDigest
    )
{
    HRESULT hr;
    BSTR asciiDigest = NULL;

    if (NULL == pbstrDigest)
    {
        return E_POINTER;
    }
    hr = MD5HashASCII(bstrSource, &asciiDigest);

    if (S_OK != hr)
        goto Cleanup;
    
    *pbstrDigest = ::SysAllocString((WCHAR*)_bstr_t((CHAR*)asciiDigest));
    if(*pbstrDigest == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    if (asciiDigest)
    {
        SysFreeString(asciiDigest);
    }

    return hr;
}

// this hashes only the half of the bstrSource.  It is provided for backword compatility only
STDMETHODIMP CCoMD5::MD5HashAsp(
    BSTR    bstrSource,
    BSTR*   pbstrDigest
    )
{
    HRESULT hr;
    LONG    lResult;
    UCHAR   achDigest[20];
    CHAR    achDigestStr[36];
    
    if (NULL == pbstrDigest)
    {
        return E_POINTER;
    }
    lResult = MD5((UCHAR*)(
                    CHAR*)_bstr_t(bstrSource), 
                    ::SysStringLen(bstrSource), 
                    achDigest);
    if(lResult != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    ToHex(achDigest, 16, achDigestStr);

    *pbstrDigest = ::SysAllocString((WCHAR*)_bstr_t((CHAR*)achDigestStr));
    if(*pbstrDigest == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IPassportService implementation

STDMETHODIMP CCoMD5::Initialize(BSTR configfile, IServiceProvider* p)
{
    return S_OK;
}


STDMETHODIMP CCoMD5::Shutdown()
{
    return S_OK;
}


STDMETHODIMP CCoMD5::ReloadState(IServiceProvider*)
{
    return S_OK;
}


STDMETHODIMP CCoMD5::CommitState(IServiceProvider*)
{
    return S_OK;
}


STDMETHODIMP CCoMD5::DumpState(BSTR* pbstrState)
{
	ATLASSERT( *pbstrState != NULL && 
               "CCoMD5:DumpState - "
               "Are you sure you want to hand me a non-null BSTR?" );

	HRESULT hr = S_OK;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atls\stdafx.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include <atlbase.h>
#include <atlmem.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\atls\atlcommodule.cpp ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the	
// Active Template Library product.

#include "StdAfx.H"

#pragma warning( disable: 4073 )  // initializers put in library initialization area

namespace ATL
{

#pragma init_seg( lib )

CAtlComModule	_AtlComModule;
};  // namespace ATL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\commd5\comd5.h ===
// CoMD5.h : Declaration of the CCoMD5

#ifndef __COMD5_H_
#define __COMD5_H_

#include "resource.h"       // main symbols
#include "passportservice.h"

/////////////////////////////////////////////////////////////////////////////
// CCoMD5
class ATL_NO_VTABLE CCoMD5 : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CCoMD5, &CLSID_CoMD5>,
    public IPassportService,
	public IDispatchImpl<IMD5, &IID_IMD5, &LIBID_COMMD5Lib>
{
public:
	CCoMD5()
	{
		m_pUnkMarshaler = NULL;
	}


DECLARE_REGISTRY_RESOURCEID(IDR_COMD5)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CCoMD5)
	COM_INTERFACE_ENTRY(IMD5)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IPassportService)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

public:
// IMD5
    STDMETHOD(MD5Hash)(BSTR bstrSource, BSTR* pbstrDigest);
    STDMETHOD(MD5HashASCII)(BSTR bstrSource, BSTR* pbstrDigest);
	STDMETHOD(MD5HashAsp)(BSTR bstrSource, BSTR* pbstrDigest);
  
// IPassportService
public:
	STDMETHOD(Initialize)(BSTR configfile, IServiceProvider* p);
	STDMETHOD(Shutdown)();
	STDMETHOD(ReloadState)(IServiceProvider*);
	STDMETHOD(CommitState)(IServiceProvider*);
	STDMETHOD(DumpState)( BSTR* );

};

#endif //__COMD5_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\commd5\commd5.cpp ===
// ComMD5.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f ComMD5ps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "ComMD5.h"

#include "ComMD5_i.c"
#include "CoMD5.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CoMD5, CCoMD5)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\commd5\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B8C3079D_1B55_11D2_BED2_00C04FB6FA0D__INCLUDED_)
#define AFX_STDAFX_H__B8C3079D_1B55_11D2_BED2_00C04FB6FA0D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif


#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <comdef.h>

#include "md5.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B8C3079D_1B55_11D2_BED2_00C04FB6FA0D__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\commd5\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\commd5\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ComMD5.rc
//
#define IDS_PROJNAME                    100
#define IDR_COMD5                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        203
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\alertlibrary\corealertstuff\passportalertinterface.cpp ===
//////////////////////////////////////////////////////////////////////
//
// 
//
//////////////////////////////////////////////////////////////////////

#define _PassportExport_
#include "PassportExport.h"

#include "PassportAlertInterface.h"
#include "PassportAlertEvent.h"

PassportExport PassportAlertInterface * CreatePassportAlertObject ( 
						PassportAlertInterface::OBJECT_TYPE type )
{
	switch (type)
	{
	case PassportAlertInterface::EVENT_TYPE:
		return ( PassportAlertInterface * ) new PassportAlertEvent();
	default:
		return NULL;
	}
}


PassportExport void 
DeletePassportAlertObject ( PassportAlertInterface * pObject )
{
	
	if (pObject)
		delete pObject;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\alertlibrary\corealertstuff\passportalertevent.h ===
// PassportAlertEvent.h: interface for the PassportAlertEvent class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PASSPORTALERTEVENT_H)
#define AFX_PASSPORTALERTEVENT_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "PassportAlertInterface.h"

class PassportAlertEventImpl;

class PassportExport PassportAlertEvent : public PassportAlertInterface 
{
public:
	PassportAlertEvent();
	virtual ~PassportAlertEvent();

	virtual BOOL	initLog(LPCTSTR applicationName,
							const DWORD defaultCategoryID = 0,
							LPCTSTR eventResourceDllName = NULL,  // full path
							const DWORD numberCategories = 0);

	virtual PassportAlertInterface::OBJECT_TYPE type() const;

	virtual BOOL	status() const;

	virtual BOOL	closeLog ();

 	virtual BOOL	report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId );

 	virtual BOOL	report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId, 
							LPCTSTR errorString);

	virtual BOOL	report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId, 
							const WORD numberErrorStrings, 
							LPCTSTR *errorStrings, 
							const DWORD binaryErrorBytes = 0,
							const LPVOID binaryError = NULL );
private:

    BOOL                      m_bDisabled;

	BOOL	inited;
	DWORD	m_defaultCategoryID;
	HANDLE  m_EventSource;


	static WORD convertEvent ( 
		const PassportAlertInterface::LEVEL level )
	{
	   switch (level)
	   {
			case PassportAlertInterface::ERROR_TYPE:
				return EVENTLOG_ERROR_TYPE;
			case PassportAlertInterface::WARNING_TYPE:
				return EVENTLOG_WARNING_TYPE;
			case PassportAlertInterface::INFORMATION_TYPE:
				return EVENTLOG_INFORMATION_TYPE;
			default:
				return EVENTLOG_ERROR_TYPE;
	   }
	}

};

#endif // !defined(PASSPORTALERTEVENT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\alertlibrary\corealertstuff\passportalertevent.cpp ===
// PassportAlertEvent.cpp: implementation of the PassportEvent class.
//
//////////////////////////////////////////////////////////////////////

#define _PassportExport_
#include "PassportExport.h"

#include <windows.h>
#include <TCHAR.h>
#include "PassportAlertEvent.h"

#define HKEY_EVENTLOG	_T("System\\CurrentControlSet\\Services\\Eventlog\\Application")
#define TYPES_SUPPORTED	_T("TypesSupported")
#define EVENT_MSGFILE	_T("EventMessageFile")
#define CATEGORY_MSGFILE _T("CategoryMessageFile")
#define CATEGORY_COUNT	_T("CategoryCount")
#define DISABLE_EVENTS  _T("DisableEvents")

#define HKEY_EVENTLOG_LENGTH    (sizeof(HKEY_EVENTLOG) / sizeof(TCHAR) - 1)

#define BUFFER_SIZE     512
const DWORD DefaultTypesSupported = 7;
const DWORD DefaultCategoryCount = 7;

const WORD DEFAULT_EVENT_CATEGORY = 0;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
PassportAlertEvent::PassportAlertEvent()
 : m_bDisabled(FALSE)
{
		inited = FALSE;
		m_EventSource = NULL;
		m_defaultCategoryID = 0;
}

PassportAlertEvent::~PassportAlertEvent()
{
}

//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::initLog
//
//////////////////////////////////////////////////////////////////////
BOOL	
PassportAlertEvent::initLog(LPCTSTR applicationName,
							const DWORD defaultCategoryID,
							LPCTSTR eventResourceDllName,  // full path
							const DWORD numberCategories )
{
	HKEY    hkResult2 = NULL;
    HANDLE  hToken = NULL;
    BOOL    fRet = FALSE;

	if (inited)
	{
		return FALSE;
	}

    if (OpenThreadToken(GetCurrentThread(),
                        MAXIMUM_ALLOWED,
                        TRUE,
                        &hToken))
    {
        RevertToSelf();
    }


	m_defaultCategoryID = defaultCategoryID;

	TCHAR szEventLogKey[512];
    TCHAR *pLogKey = NULL;
    DWORD dwLen = HKEY_EVENTLOG_LENGTH + lstrlen(applicationName);

    if ( dwLen > 510) {

        //
        // This is not likely to happen. If it happens, just allocate. 
        // 510 = 512 - 2
        // 2 is for \ and NULL
        //

        pLogKey = new TCHAR [dwLen + 2];

    } else {

        pLogKey = szEventLogKey;

    }

    if (pLogKey) {
        wsprintf(pLogKey, _T("%s\\%s"), HKEY_EVENTLOG, applicationName);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         pLogKey,
                         0,
                         KEY_READ,
                         &hkResult2) == ERROR_SUCCESS)
        {
            DWORD dwLen = sizeof(DWORD);
            RegQueryValueEx(hkResult2, DISABLE_EVENTS, 0, NULL, (UCHAR*)&m_bDisabled, &dwLen);
        
            RegCloseKey(hkResult2);
        }
    
        if (pLogKey && (pLogKey != szEventLogKey)) {
            delete [] pLogKey; 
        }
    }


	m_EventSource = RegisterEventSource(NULL, applicationName);
    if ( m_EventSource != NULL )
	{
		inited = TRUE;
		fRet= TRUE;
	}
//Cleanup:
    if (hToken)
    {
        // put the impersonation token back
        if (!SetThreadToken(NULL, hToken))
        {
            fRet = FALSE;
        }
        CloseHandle(hToken);
    }

    return fRet;
}


//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::type
//
//////////////////////////////////////////////////////////////////////
PassportAlertInterface::OBJECT_TYPE 
PassportAlertEvent::type() const
{
	return PassportAlertInterface::EVENT_TYPE;
};

//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::status
//
//////////////////////////////////////////////////////////////////////
BOOL	
PassportAlertEvent::status() const
{
	return inited;

}

//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::closeLog
//
//////////////////////////////////////////////////////////////////////
BOOL	
PassportAlertEvent::closeLog ()
{
    BOOL bRet;
    
    if ( NULL == m_EventSource) {
        return TRUE;

    }

    bRet = DeregisterEventSource (m_EventSource);
    if (bRet) {

        //
        // Preventing further use of the handle.
        // It would be better to put this function in the destructor
        // if the object is destroyed after closeLog is called.
        //

        m_EventSource = NULL;
        inited = FALSE;
    }

	return bRet;

}

//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::report
//
//////////////////////////////////////////////////////////////////////
BOOL	
PassportAlertEvent::report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId )
{
    if(m_bDisabled)
        return TRUE;

    if (NULL == m_EventSource) {

        //
        // Not initialized. Fail.
        //

        return FALSE;
    }

	return ReportEvent ( 
						m_EventSource,
						(WORD)convertEvent(level),
						(WORD)m_defaultCategoryID,
						alertId,
						0, // optional security user Sid
						(WORD)0,
						0,
						NULL,
						NULL );

}


//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::report
//
//////////////////////////////////////////////////////////////////////
BOOL	
PassportAlertEvent::report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId, 
							LPCTSTR errorString)
{
    if(m_bDisabled)
        return TRUE;

    if ((NULL == m_EventSource) || (errorString == NULL)) {

        //
        // Not initialized. Fail.
        //

        return FALSE;
    }

	return ReportEvent ( 
						m_EventSource,
						(WORD)convertEvent(level),
						(WORD)m_defaultCategoryID,
						alertId,
						0, // optional security user Sid
						(WORD)1,
						0,
						(LPCTSTR*)&errorString,
						NULL );

}

//////////////////////////////////////////////////////////////////////
// 
// PassportAlertEvent::report
//
//////////////////////////////////////////////////////////////////////
BOOL	
PassportAlertEvent::report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId, 
							const WORD numberErrorStrings, 
							LPCTSTR *errorStrings, 
							const DWORD binaryErrorBytes,
							const LPVOID binaryError )
{

    if(m_bDisabled)
        return TRUE;

    if ((NULL == m_EventSource) || ((numberErrorStrings > 0) && (errorStrings == NULL))) {

        //
        // Not initialized. Fail. Or the passin parameter is invalid.
        // ReportEvent will further validate the errorStrings.
        //

        return FALSE;
    }

	return ReportEvent ( 
						m_EventSource,
						(WORD)convertEvent(level),
						(WORD)m_defaultCategoryID,
						alertId,
						0, // optional security user Sid
						(WORD)numberErrorStrings,
						binaryErrorBytes,
						(LPCTSTR*)errorStrings,
						binaryError );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\alertlibrary\pmalerts\pmalertsdefs.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PMAlertsDefs.h

    Abstract:

		Defines the Registry Key used by the PMAlerts.dll

    Author:

		Christopher Bergh (cbergh) 14-Oct-1988

    Revision History:


--*/

#if !defined(PMALERTSDEFS_H)
#define PMALERTSDEFS_H

//
// defs
//
const TCHAR PM_ALERTS_REGISTRY_KEY[]	= _T("PassportManager");

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\alertlibrary\pmalerts\pmalerts.c ===
#include <windows.h>

BOOL WINAPI DllMain( 
    HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved )
{
    return TRUE;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\alertlibrary\pmalerts\dllregisterserver.cpp ===
#include <windows.h>
#include <TCHAR.h>
#include "PMAlertsDefs.h"


#define BLOB_DLLFILE         TEXT("\\msppmalr.dll")
#define BLOB_DLLFILE_LENGTH  (sizeof(BLOB_DLLFILE) / sizeof(BLOB_DLLFILE[0]))

STDAPI DllRegisterServer(void)
{

	DWORD	dwAllocBufferLength=MAX_PATH + BLOB_DLLFILE_LENGTH;
	LPTSTR	lpszBuffer= new TCHAR[dwAllocBufferLength];
	HKEY	hKey=HKEY_LOCAL_MACHINE;	// handle of open key
	HKEY	hkResult1; 					// address of handle of open key 
	HKEY	hkResult2; 					// address of handle of open key 
	DWORD	ulOptions=0;
	REGSAM	samDesired=KEY_ALL_ACCESS;
	DWORD	Reserved=0;
	DWORD	dwTypesSupported=7;	
	DWORD	dwCategoryCount=2;	

        if (lpszBuffer == NULL)
        {
            goto Error;
        }

	// Get DLL File Location

	if(!GetCurrentDirectory(MAX_PATH,lpszBuffer))
        {
		goto Error;
        }

    _tcscat(lpszBuffer,_T("\\msppmalr.dll"));

	// Event Logging Registry Settings

	if (RegOpenKeyEx(hKey,
		_T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application"),
		ulOptions,samDesired,&hkResult1)!=ERROR_SUCCESS)
		goto Error;
	
	if (RegCreateKey(hkResult1,PM_ALERTS_REGISTRY_KEY,
		&hkResult2)!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		goto Error;
	}

	if (RegSetValueEx(hkResult2,_T("EventMessageFile"),
		Reserved,REG_EXPAND_SZ,(CONST BYTE *)lpszBuffer,
		_tcslen(lpszBuffer)*sizeof(TCHAR))!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		RegCloseKey(hkResult2);
		goto Error;
	}

	if (RegSetValueEx(hkResult2,_T("CategoryMessageFile"),
		Reserved,REG_EXPAND_SZ,(CONST BYTE *)lpszBuffer,
		_tcslen(lpszBuffer)*sizeof(TCHAR))!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		RegCloseKey(hkResult2);
		goto Error;
	}

	if (RegSetValueEx(hkResult2,_T("TypesSupported"),
		Reserved,REG_DWORD,(CONST BYTE *)&dwTypesSupported,
		sizeof(DWORD))!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		RegCloseKey(hkResult2);
		goto Error;
	}

	if (RegSetValueEx(hkResult2,_T("CategoryCount"),
		Reserved,REG_DWORD,(CONST BYTE *)&dwCategoryCount,
		sizeof(DWORD))!=ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		RegCloseKey(hkResult2);
		goto Error;
	}

	RegCloseKey(hkResult1);
	RegCloseKey(hkResult2);

	delete[] lpszBuffer;

	return(S_OK);

Error:

        if (lpszBuffer)
        {
            delete[] lpszBuffer;
        }

	return(E_UNEXPECTED);
}

STDAPI DllUnregisterServer(void)
{

	HKEY	hKey=HKEY_LOCAL_MACHINE, hkResult1;
	DWORD	ulOptions=0;
	REGSAM	samDesired=KEY_ALL_ACCESS;
	DWORD	Reserved=0;

	if (RegOpenKeyEx(hKey,
		_T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application"),
		ulOptions,samDesired,&hkResult1) != ERROR_SUCCESS)
	{
		return (E_UNEXPECTED);
	}

	if (RegDeleteKey(hkResult1,PM_ALERTS_REGISTRY_KEY) != ERROR_SUCCESS)
	{
		RegCloseKey(hkResult1);
		return (E_UNEXPECTED);
	}
	
	RegCloseKey(hkResult1);
	return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\alertlibrary\corealertstuff\passportalertinterface.h ===
// AlertInterface.h: interface for the AlertInterface class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(ALERTINTERFACE_H)
#define ALERTINTERFACE_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>
#include "PassportExport.h"

class PassportExport PassportAlertInterface  
{
public:
	inline PassportAlertInterface(void)	{};
	inline virtual ~PassportAlertInterface(void) {};

	enum LEVEL
	{
		INFORMATION_TYPE	= 0,	// on NT, EVENTLOG_INFORMATION_TYPE,
		WARNING_TYPE		= 1,	//		  EVENTLOG_WARNING_TYPE,
		ERROR_TYPE			= 2		//		  EVENTLOG_ERROR_TYPE
	};

	enum OBJECT_TYPE
	{
		EVENT_TYPE		= 100,		// Alerts Logged to Event Log,
		SNMP_TYPE		= 101,		// Alerts Logged to SNMP Traps,
		LOGFILE_TYPE	= 102		// Alerts Logged to disk file
	};

	virtual BOOL	initLog(LPCTSTR applicationName,
							const DWORD defaultCategoryID = 0,
							LPCTSTR eventResourceDllName = NULL,  // full path
							const DWORD numberCategories = 0 ) = 0;

	virtual PassportAlertInterface::OBJECT_TYPE type() const = 0;

	virtual BOOL	status() const = 0;

	virtual BOOL	closeLog ()	= 0;

 	virtual BOOL	report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId ) = 0;

 	virtual BOOL	report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId, 
							LPCTSTR errorString) = 0;

	virtual BOOL	report(	const PassportAlertInterface::LEVEL level, 
							const DWORD alertId, 
							const WORD numberErrorStrings, 
							LPCTSTR *errorStrings, 
							const DWORD binaryErrorBytes = 0,
							const LPVOID binaryError = NULL ) = 0;


};

// create and returns a pointer to the relevant implementation,
// NULL if none exists (FYI- extern "C" to stop name mangling)
extern "C" PassportExport PassportAlertInterface * 
					CreatePassportAlertObject ( PassportAlertInterface::OBJECT_TYPE type );

extern "C" PassportExport void DeletePassportAlertObject ( PassportAlertInterface * pObject );

#endif // !defined(ALERTINTERFACE_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\crypt\hmac.h ===
#ifndef _HMAC_H
#define _HMAC_H

void hmac_sha(unsigned char *secretKey, int keyLen,
	      unsigned char *data, int dataLen,
	      unsigned char *out, int outLen);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\crypt\cocrypt.cpp ===
// CoCrypt.cpp: implementation of the CCoCrypt class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CoCrypt.h"
#include "hmac.h"
#include "BstrDebug.h"
#include <winsock2.h> // ntohl, htonl
#include <time.h>
#include <crypt.h>

#define PASSPORT_MAC_LEN 10

BOOL
GenTextIV(unsigned char *pIV)  // makes the assumption that IV is 8 bytes long
                      // since the below code uses 3DES this is OK for now
{
    int i;
    BOOL fResult;

    // generate a random IV
    fResult = RtlGenRandom(pIV, 8);
    if (!fResult)
        return FALSE;

    // castrate the random IV into base 64 characters (makes the IV only have
    // ~48 bits of entropy instead of 64 but that should be fine
    for (i = 0; i < 8; i++)
    {
        // mod the character to make sure its less than 62
        pIV[i] = pIV[i] % 62;
        // add the appropriate character value to make it a base 64 character
        if (pIV[i] <= 9)
            pIV[i] = pIV[i] + '0';
        else if (pIV[i] <= 35)
            pIV[i] = pIV[i]  + 'a' - 10 ;
        else
            pIV[i] = pIV[i]  + 'A' - 36 ;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CBinHex CCoCrypt::m_binhex;

CCoCrypt::CCoCrypt() : m_ok(FALSE)
{
}

CCoCrypt::~CCoCrypt()
{

}

BOOL CCoCrypt::Decrypt(LPWSTR rawData,
					   UINT dataSize, 
	            	   BSTR *ppUnencrypted)
{
    unsigned char *pb = NULL;
    unsigned char ivec[9];
    ULONG         lSize, i;
    unsigned char pad;
    unsigned char hmac[10];
	HRESULT       hr;
    BOOL          fResult = FALSE;

	*ppUnencrypted = NULL;

    // must be kv + ivec + bh(hmac) long at LEAST
    if (sizeof(hmac) + sizeof(ivec) + 4 > dataSize)
	{
		goto Cleanup;
	}

    lSize = dataSize - sizeof(WCHAR);

	// allocate a buffer for the resulting data
	pb = new unsigned char[lSize];
	if (NULL == pb)
	{
		goto Cleanup;
	}

	// decode from base 64
    hr = m_binhex.PartFromWideBase64(rawData + 1 + 9, pb, &lSize);
    if (S_OK != hr)
	{
		goto Cleanup;
	}

    for (i = 0; i < 9; i++)
        ivec[i] = (unsigned char) rawData[i + 1];

    pad = ivec[8];

    // Now lsize holds the # of bytes outputted, which after hmac should be %8=0
    if ((lSize - sizeof(hmac)) % 8 || lSize <= sizeof(hmac))
	{
        goto Cleanup;
	}

    for (i = 0; i < lSize - sizeof(hmac); i+=8)
	{
        CBC(tripledes,
			DES_BLOCKLEN,
			pb + sizeof(hmac) + i,
			pb + sizeof(hmac) + i,
			&ks,
			DECRYPT,
			(BYTE*)ivec);
	}

    // Padding must be >0 and <8
    //if (rawData[8]-65 > 7 || rawData[8] < 65)
    if((pad - 65) > 7 || pad < 65)
	{
        goto Cleanup;
	}

    // Now check hmac
    hmac_sha(m_keyMaterial,
		     DES3_KEYSIZE,
			 pb + sizeof(hmac),
			 lSize - sizeof(hmac),
			 hmac, sizeof(hmac));

    if (memcmp(hmac, pb, sizeof(hmac)) != 0)
    {
        goto Cleanup;
    }

    // do a BSTR type allocation to accomodate calling code
    *ppUnencrypted = ALLOC_AND_GIVEAWAY_BSTR_BYTE_LEN((char*)(pb+sizeof(hmac)), lSize - sizeof(hmac) - (pad - 65));
    if (NULL == *ppUnencrypted)
    {
        goto Cleanup;
    }

    fResult = TRUE;
Cleanup:
    if (pb)
    {
        delete[] pb;
    }

    return fResult;
}


BOOL CCoCrypt::Encrypt(int keyVersion, 
                       LPSTR rawData,
					   UINT dataSize,
                       BSTR *ppEncrypted)
{
    int  cbPadding = 0;
    char ivec[9];
    BOOL fResult;

    *ppEncrypted = NULL;

    // Find out how big the encrypted blob needs to be:
    // The final pack is:
    // <KeyVersion><IVEC><PADCOUNT>BINHEX(HMAC+3DES(DATA+PAD))
    //
    // So, we're concerned with the size of HMAC+3DES(DATA+PAD)
    // because BinHex will handle the rest
    if (dataSize % DES_BLOCKLEN)
    {
        cbPadding = (DES_BLOCKLEN - (dataSize % DES_BLOCKLEN));  // + PAD, if necessary
    }

    // gen the IV
    fResult = GenTextIV((unsigned char*)ivec);
    if (!fResult)
    {
        goto Cleanup;
    }

    encrypt(ivec, cbPadding, keyVersion, rawData, dataSize, ppEncrypted);

    fResult = TRUE;
Cleanup:
    return fResult;
}

BOOL CCoCrypt::encrypt(char ivec[9],
					   int cbPadding,
					   int keyVersion, 
			           LPSTR rawData,
					   UINT cbData,
			           BSTR *ppEncrypted)
{
    unsigned char *pb = NULL;
    char          ivec2[8];
    HRESULT       hr;
    BOOL          fResult = FALSE;

    // Compute HMAC+3DES(DATA+PAD)

    ivec[8] = (char) cbPadding + 65;

	// allocate a buffer for the resulting data
	// length of data + length of padding + size of HMAC + size of IV 
    pb = new unsigned char[cbData + cbPadding + 10 + 8];
    if (NULL == pb)
	{
		goto Cleanup;
	}

    memcpy(ivec2, ivec, DES_BLOCKLEN);

    memcpy(pb + PASSPORT_MAC_LEN, rawData, cbData); // copy data after the HMAC

    //randomize padding
    fResult = RtlGenRandom(pb + PASSPORT_MAC_LEN + cbData, cbPadding);
    if (!fResult)
    {
        fResult = FALSE;
        goto Cleanup;
    }

    // Compute HMAC
    hmac_sha(m_keyMaterial, DES3_KEYSIZE, pb + PASSPORT_MAC_LEN, cbData + cbPadding, pb, PASSPORT_MAC_LEN);

    for (int i = 0; i < (int)cbData + cbPadding; i+=8)
    {
        CBC(tripledes, DES_BLOCKLEN, pb + PASSPORT_MAC_LEN + i, pb + PASSPORT_MAC_LEN + i, &ks, ENCRYPT, (BYTE*)ivec2);
    }

    // Now we've got a buffer of blockSize ready to be binhexed, and have the key
    // version prepended
    keyVersion = keyVersion % 36; // 0 - 9 & A - Z
    char v = (char) ((keyVersion > 9) ? (55+keyVersion) : (48+keyVersion));

    hr = m_binhex.ToBase64(pb, cbData + cbPadding + PASSPORT_MAC_LEN, v, ivec, ppEncrypted);
	if (S_OK != hr)
    {
        fResult = FALSE;
        goto Cleanup;
    }

    fResult = TRUE;
Cleanup:
    if (NULL != pb)
    {
        delete[] pb;
    }

    return fResult;
}


void CCoCrypt::setKeyMaterial(BSTR newVal)
{
  if (SysStringByteLen(newVal) != 24)
    {
      m_ok = FALSE;
      return;
    }

  memcpy(m_keyMaterial, (LPSTR)newVal, 24);

  tripledes3key(&ks, (BYTE*) m_keyMaterial);
  m_ok = TRUE;
}


unsigned char *CCoCrypt::getKeyMaterial(DWORD *pdwLen)
{
    if (pdwLen)
        *pdwLen = 24;
    return m_keyMaterial;
}


int CCoCrypt::getKeyVersion(BSTR encrypted)
{
  char c = (char) encrypted[0];

  if (isdigit(c))
    return (c-48);

  if(isalpha(c)) // Key version can be 0 - 9 & A - Z (36)
  {
    if(c > 'Z') //convert to uppert case w/o using rt lib.
        c -= ('a' - 'A'); 

    return c - 65 + 10;
    //return (toupper(c)-65+10);
  }

  return -1;
}


int CCoCrypt::getKeyVersion(BYTE *encrypted)
{
  char c = (char) encrypted[0];

  if (isdigit(c))
    return (c-48);

  if(isalpha(c)) // Key version can be 0 - 9 & A - Z (36)
  {
    if(c > 'Z') //convert to uppert case w/o using rt lib.
        c -= ('a' - 'A'); 

    return c - 65 + 10;
    //return (toupper(c)-65+10);
  }

  return -1;
}

void CCoCrypt::setWideMaterial(BSTR kvalue)
{
    m_bstrWideMaterial = kvalue;
}

BSTR CCoCrypt::getWideMaterial()
{
    return m_bstrWideMaterial;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\crypt\binhex.cpp ===
// BinHex.cpp: implementation of the CBinHex class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "BinHex.h"
#include "BstrDebug.h"

// These characters are the legal digits, in order, that are 
// used in Base64 encoding 
//  

const WCHAR rgwchBase64[] = 
    L"ABCDEFGHIJKLMNOPQ" 
    L"RSTUVWXYZabcdefgh" 
    L"ijklmnopqrstuvwxy" 
    L"z0123456789!*"; 

const char rgwchBase64ASCII[] = 
    "ABCDEFGHIJKLMNOPQ" 
    "RSTUVWXYZabcdefgh" 
    "ijklmnopqrstuvwxy" 
    "z0123456789!*"; 


CBinHex::CBinHex()
{
  unsigned char i;
  // 
  // Initialize our decoding array 
  // 
  memset(m_decodeArray, BBAD, 256); 
  for (i = 0; i < 64; i++) 
  { 
    WCHAR wch = rgwchBase64[i];
    m_decodeArray[wch] = i;
  }
}

// This function takes IN a single-char buffer, and puts the binhex
// output into a bstr -- in the bstr, it's ASCII string
//
// Function name    : ToBase64
// Description	    : 
// Return type	    : HRESULT 
// Argument         : LPVOID pv
// Argument         : ULONG cbSize
// Argument         : char prepend
// Argument         : BSTR* pbstr
//
HRESULT CBinHex::ToBase64ASCII(LPVOID pv, UINT cbSize, char prepend, char ivecnpad[9], BSTR* pbstr) 
// 
// Encode and return the bytes in base 64 
// 
{ 
    UINT cb = cbSize, cbSafe, cchNeeded, cbNeeded, i;
    HRESULT hr = S_OK;

    *pbstr = NULL; 
    if (cb % 3)
      cbSafe = cb + 3 - (cb % 3); // For padding
    else
      cbSafe = cb;
    // cbSafe is now a multiple of 3

    cchNeeded  = (cbSafe*4/3);   // 3 normal bytes --> 4 chars
    cbNeeded   = cchNeeded; 

    if (prepend != 0)
      {
	if (ivecnpad != NULL)
	  *pbstr = ALLOC_BSTR_BYTE_LEN(NULL, cbNeeded+2+18); // ivec & kv
	else
	  *pbstr = ALLOC_BSTR_BYTE_LEN(NULL, cbNeeded+2);    // just kv
      }
    else
      *pbstr = ALLOC_BSTR_BYTE_LEN(NULL, cbNeeded);
    if (*pbstr) 
    { 
        BYTE*  pb   = (BYTE*)pv; 
        char* pch = (char*)*pbstr;
        int cchLine = 0; 

	if (prepend != 0)
	  { 
	    *pch++ = (char) prepend;
	    if (ivecnpad != NULL)
	      {
		for (i = 0; i < 9; i++)
		  *pch++ = (char) ivecnpad[i];
	      }
	  }
        // 
        // Main encoding loop 
        // 
        while (cb >= 3) 
        { 
            BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
            BYTE b1 = ((pb[0]&0x03)<<4) | ((pb[1]>>4) & 0x0F); 
            BYTE b2 = ((pb[1]&0x0F)<<2) | ((pb[2]>>6) & 0x03); 
            BYTE b3 = ((pb[2]&0x3F)); 
 
            *pch++ = rgwchBase64ASCII[b0]; 
            *pch++ = rgwchBase64ASCII[b1]; 
            *pch++ = rgwchBase64ASCII[b2]; 
            *pch++ = rgwchBase64ASCII[b3]; 
 
            pb += 3; 
            cb -= 3; 
            
        } 

        if (cb==0) 
        { 
            // nothing to do 
        } 
        else if (cb==1) 
        { 
            BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
            BYTE b1 = ((pb[0]&0x03)<<4) | 0; 
            *pch++ = rgwchBase64ASCII[b0]; 
            *pch++ = rgwchBase64ASCII[b1]; 
            *pch++ = '$'; 
            *pch++ = '$'; 
        } 
        else if (cb==2) 
        { 
            BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
            BYTE b1 = ((pb[0]&0x03)<<4) | ((pb[1]>>4) & 0x0F); 
            BYTE b2 = ((pb[1]&0x0F)<<2) | 0; 
            *pch++ = rgwchBase64ASCII[b0]; 
            *pch++ = rgwchBase64ASCII[b1]; 
            *pch++ = rgwchBase64ASCII[b2]; 
            *pch++ = '$'; 
        } 
         
     } 
    else 
        hr = E_OUTOFMEMORY; 
 
    GIVEAWAY_BSTR(*pbstr);
    return hr; 
} 
 
// This function takes IN a single-char buffer, and puts the binhex
// output into a bstr, but using only ASCII chars
//
// Function name    : ToBase64
// Description	    : 
// Return type	    : HRESULT 
// Argument         : LPVOID pv
// Argument         : ULONG cbSize
// Argument         : char prepend
// Argument         : BSTR* pbstr
//
HRESULT CBinHex::ToBase64(LPVOID pv, UINT cbSize, char prepend, char ivecnpad[9], BSTR* pbstr) 
// 
// Encode and return the bytes in base 64 
// 
{ 
    UINT cb = cbSize, cbSafe, cchNeeded, cbNeeded, i;
    HRESULT hr = S_OK;

    *pbstr = NULL; 
    if (cb % 3)
      cbSafe = cb + 3 - (cb % 3); // For padding
    else
      cbSafe = cb;
    // cbSafe is now a multiple of 3

    cchNeeded  = (cbSafe*4/3);   // 3 normal bytes --> 4 chars
    cbNeeded   = cchNeeded * sizeof(WCHAR); 

    if (prepend != 0)
      {
	if (ivecnpad != NULL)
	  *pbstr = ALLOC_BSTR_BYTE_LEN(NULL, cbNeeded+2+18); // ivec & kv
	else
	  *pbstr = ALLOC_BSTR_BYTE_LEN(NULL, cbNeeded+2);    // just kv
      }
    else
      *pbstr = ALLOC_BSTR_BYTE_LEN(NULL, cbNeeded);
    if (*pbstr) 
    { 
        BYTE*  pb   = (BYTE*)pv; 
        WCHAR* pch = *pbstr;
        int cchLine = 0; 

	if (prepend != 0)
	  { 
	    *pch++ = (WCHAR) prepend;
	    if (ivecnpad != NULL)
	      {
		for (i = 0; i < 9; i++)
		  *pch++ = (WCHAR) ivecnpad[i];
	      }
	  }
        // 
        // Main encoding loop 
        // 
        while (cb >= 3) 
        { 
            BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
            BYTE b1 = ((pb[0]&0x03)<<4) | ((pb[1]>>4) & 0x0F); 
            BYTE b2 = ((pb[1]&0x0F)<<2) | ((pb[2]>>6) & 0x03); 
            BYTE b3 = ((pb[2]&0x3F)); 
 
            *pch++ = rgwchBase64[b0]; 
            *pch++ = rgwchBase64[b1]; 
            *pch++ = rgwchBase64[b2]; 
            *pch++ = rgwchBase64[b3]; 
 
            pb += 3; 
            cb -= 3; 
            
        } 

        if (cb==0) 
        { 
            // nothing to do 
        } 
        else if (cb==1) 
        { 
            BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
            BYTE b1 = ((pb[0]&0x03)<<4) | 0; 
            *pch++ = rgwchBase64[b0]; 
            *pch++ = rgwchBase64[b1]; 
            *pch++ = L'$'; 
            *pch++ = L'$'; 
        } 
        else if (cb==2) 
        { 
            BYTE b0 =                     ((pb[0]>>2) & 0x3F); 
            BYTE b1 = ((pb[0]&0x03)<<4) | ((pb[1]>>4) & 0x0F); 
            BYTE b2 = ((pb[1]&0x0F)<<2) | 0; 
            *pch++ = rgwchBase64[b0]; 
            *pch++ = rgwchBase64[b1]; 
            *pch++ = rgwchBase64[b2]; 
            *pch++ = L'$'; 
        } 
         
     } 
    else 
        hr = E_OUTOFMEMORY; 
 
    GIVEAWAY_BSTR(*pbstr);
    return hr; 
} 
 
 
HRESULT CBinHex::PartFromBase64(LPSTR lpStr, BYTE *output, ULONG *numOutBytes)
{
  HRESULT hr = S_OK;

  if (!output) return E_INVALIDARG;

  // 
  // Loop over the input buffer until we get numOutBytes in output
  // 
  ULONG bCurrent = 0;         // what we're in the process of filling up 
  int  cbitFilled = 0;        // how many bits in it we've filled 
  ULONG numOut = 0;
  BYTE* pb = (BYTE*) output;  // current destination (not filled) 

  for (CHAR* pch=lpStr; *pch && numOut < *numOutBytes; pch++) 
    { 
      CHAR ch = *pch;
      // 
      // Have we reached the end? 
      // 
      if (ch=='$')
	break; 
      // 
      // How much is this character worth? 
      // 
      BYTE bDigit = m_decodeArray[ch]; 
      if (bDigit==BBAD) 
        { 
	  hr = E_INVALIDARG; 
	  break; 
        } 
      // 
      // Add in its contribution 
      // 
      bCurrent <<= 6; 
      bCurrent |= bDigit; 
      cbitFilled += 6; 
      // 
      // If we've got enough, output a byte 
      // 
      if (cbitFilled >= 8) 
        { 
	  ULONG b = (bCurrent >> (cbitFilled-8));     // get's top eight valid bits 
	  *pb++ = (BYTE)(b&0xFF);                     // store the byte away 
	  cbitFilled -= 8; 
	  numOut++;
        }
    } // for 
  
  _ASSERT(numOut <= *numOutBytes);

  if (hr!=S_OK)
    { 
      *numOutBytes = 0;
    }
  else
    {
      if (numOut < *numOutBytes)
	*numOutBytes = numOut;
    }

  return hr; 
}

HRESULT CBinHex::PartFromWideBase64(LPWSTR bStr, BYTE *output, ULONG *numOutBytes)
{
  HRESULT hr = S_OK;

  if (!output) return E_INVALIDARG;

  // 
  // Loop over the input buffer until we get numOutBytes in output
  // 
  ULONG bCurrent = 0;         // what we're in the process of filling up 
  int  cbitFilled = 0;        // how many bits in it we've filled 
  ULONG numOut = 0;
  BYTE* pb = (BYTE*) output;  // current destination (not filled) 

  for (WCHAR* pwch=bStr; *pwch && numOut < *numOutBytes; pwch++) 
    { 
      WCHAR wch = *pwch;
      // 
      // Have we reached the end? 
      // 
      if (wch==L'$')
	break; 
      // 
      // How much is this character worth? 
      // 
      if (wch > 255)
	{
	  hr = E_INVALIDARG;
	  break;
	}
      BYTE bDigit = m_decodeArray[wch]; 
      if (bDigit==BBAD) 
        { 
	  hr = E_INVALIDARG; 
	  break; 
        } 
      // 
      // Add in its contribution 
      // 
      bCurrent <<= 6; 
      bCurrent |= bDigit; 
      cbitFilled += 6; 
      // 
      // If we've got enough, output a byte 
      // 
      if (cbitFilled >= 8) 
        { 
	  ULONG b = (bCurrent >> (cbitFilled-8));     // get's top eight valid bits 
	  *pb++ = (BYTE)(b&0xFF);                     // store the byte away 
	  cbitFilled -= 8; 
	  numOut++;
        }
    } // for 
  
  _ASSERT(numOut <= *numOutBytes);

  if (hr!=S_OK)
    { 
      *numOutBytes = 0;
    }
  else if (numOut < *numOutBytes)
    {
      *numOutBytes = numOut;
    }

  return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\crypt\hmac.cpp ===
#include "stdafx.h"

#ifdef UNIX
  #include "sha.cpp"
#else
  #include <sha.h>
#endif

#define SHA_BLOCKSIZE 64

void hmac_sha(unsigned char *k, int lk,
	      unsigned char *d, int ld,
	      unsigned char *out, int t)
{
  A_SHA_CTX ictx, octx ;
  unsigned char    isha[A_SHA_DIGEST_LEN], osha[A_SHA_DIGEST_LEN] ;
  unsigned char    key[A_SHA_DIGEST_LEN] ;
  unsigned char    buf[SHA_BLOCKSIZE] ;
  int     i ;

  if (lk > SHA_BLOCKSIZE) {
    
    A_SHA_CTX         tctx ;
    
    A_SHAInit(&tctx) ;
    A_SHAUpdate(&tctx, k, lk) ;
    A_SHAFinal(&tctx, key) ;
    
    k = key ;
    lk = A_SHA_DIGEST_LEN ;
  }
  
  /**** Inner Digest ****/
  
  A_SHAInit(&ictx) ;

  /* Pad the key for inner digest */
  for (i = 0 ; i < lk ; ++i) buf[i] = k[i] ^ 0x36 ;
  for (i = lk ; i < SHA_BLOCKSIZE ; ++i) buf[i] = 0x36 ;
  
  A_SHAUpdate(&ictx, buf, SHA_BLOCKSIZE) ;
  A_SHAUpdate(&ictx, d, ld) ;
  
  A_SHAFinal(&ictx, isha);

  /**** Outter Digest ****/
  
  A_SHAInit(&octx) ;
  
  /* Pad the key for outter digest */

  for (i = 0 ; i < lk ; ++i) buf[i] = k[i] ^ 0x5C ;
  for (i = lk ; i < SHA_BLOCKSIZE ; ++i) buf[i] = 0x5C ;

  A_SHAUpdate(&octx, buf, SHA_BLOCKSIZE) ;
  A_SHAUpdate(&octx, isha, A_SHA_DIGEST_LEN) ;

  A_SHAFinal(&octx, osha) ;
  
  /* truncate and print the results */
  memcpy(out, osha, (t > A_SHA_DIGEST_LEN) ? A_SHA_DIGEST_LEN : t);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\crypt\keycrypto.cpp ===
// KeyManager.cpp: implementation of the CKeyManager class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "keycrypto.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

// this is a optional Entropy ... 
static const BYTE __STR_CRAP[] = "1^k\0\x99$\0\\*m$\0.)\nj#\t&H\0%!FhLG%@-<v";
static LPCWSTR __STR_DESC = L"passport2.0";

CKeyCrypto::CKeyCrypto()
{
    m_EntropyBlob.pbData = (PBYTE)__STR_CRAP;
    m_EntropyBlob.cbData = (DWORD)sizeof(__STR_CRAP);
}

HRESULT CKeyCrypto::encryptKey(DATA_BLOB* input, DATA_BLOB* output)
{
    if (!input || !output)
       return E_INVALIDARG;

    HRESULT     hr = S_OK;

    if(!::CryptProtectData(input, __STR_DESC, &m_EntropyBlob, NULL, NULL, 
                     CRYPTPROTECT_LOCAL_MACHINE | CRYPTPROTECT_UI_FORBIDDEN,
                     output))
    {
      hr = HRESULT_FROM_WIN32(::GetLastError());
    }

    return hr;
}

HRESULT CKeyCrypto::decryptKey(DATA_BLOB* input, DATA_BLOB* output)
{
    if (!input || !output)
       return E_INVALIDARG;

    HRESULT     hr = S_OK;
    LPWSTR      pstrDesc = NULL;

    if(!::CryptUnprotectData(input, &pstrDesc, &m_EntropyBlob, NULL, NULL, 
                     CRYPTPROTECT_UI_FORBIDDEN, output))
    {
       hr = HRESULT_FROM_WIN32(::GetLastError());
    }

    // this error case should never happen -- if crytoAPI doing the right things
    if(!pstrDesc) 
       hr = E_FAIL;
    else
    {
      if ( wcscmp(pstrDesc, __STR_DESC) != 0)
         hr = E_FAIL;
      ::LocalFree(pstrDesc);
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\crypt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	crypt.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\crypt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__70EC6ECA_9549_11D2_95DE_00C04F8E7A70__INCLUDED_)
#define AFX_STDAFX_H__70EC6ECA_9549_11D2_95DE_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0403
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <comdef.h>
#include <crtdbg.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__70EC6ECA_9549_11D2_95DE_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\lkrhash\irtldbg.cpp ===
/*++

   Copyright    (c)    1998-2002    Microsoft Corporation

   Module  Name :
       IrtlDbg.cpp

   Abstract:
       Implementation of debug support functions

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/


#include "precomp.hxx"

#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <malloc.h>

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <irtldbg.h>

IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vsntprintf(tszBuff, sizeof(tszBuff) / sizeof(TCHAR), ptszFormat, args);
    tszBuff[2047] = TEXT('\0');
    va_end(args);

    OutputDebugString(tszBuff);
}



#ifdef IRTLDEBUG

# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef IRTLDBG_RUNNING_AS_SERVICE

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate LKRhash,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    int nResult = FALSE;
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        // If using MFC's TRACE macro (AfxTrace), the report hook
        // (AspAssertHandler) will get called with _CRT_WARN.  Ignore.
        pszMessageTitle = "Warning";
        *pnReturn = 0;
        return FALSE;

    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;

    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(malloc(strlen(pszErrorText) + strlen(szInfo) + 1));

    if (NULL == pszMessageText)
        return FALSE;

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        nResult = TRUE;  // tell _CrtDbgReport to run
    }

    free(pszMessageText);
    
    return nResult;
}

#  endif // IRTLDBG_RUNNING_AS_SERVICE
# endif // _MSC_VER >= 1000



void
IrtlDebugInit()
{
# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef IRTLDBG_RUNNING_AS_SERVICE
    // If we end up in _CrtDbgReport, don't put up a message box
    // _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // IRTLDBG_RUNNING_AS_SERVICE

    
    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
IrtlDebugTerm()
{
# if defined(USE_DEBUG_CRTS)  &&  defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef IRTLDBG_RUNNING_AS_SERVICE
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // IRTLDBG_RUNNING_AS_SERVICE
# endif // _MSC_VER >= 1000
}

#endif //IRTLDEBUG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\lkrhash\lkrhash.cpp ===
/*++

   Copyright    (c) 1998-2002    Microsoft Corporation

   Module  Name :
       LKRhash.cpp

   Abstract:
       Implements LKRhash: a fast, scalable, cache- and MP-friendly hash table

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       Jan 1998   - Massive cleanup and rewrite.  Templatized.
       10/01/1998 - Change name from LKhash to LKRhash

--*/

#include "precomp.hxx"


#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <lkrhash.h>

#ifndef __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS LKRhash
#else  // __LKRHASH_NO_NAMESPACE__
 #define LKRHASH_NS
#endif // __LKRHASH_NO_NAMESPACE__

#include "_locks.h"


#ifdef LKRHASH_ALLOCATOR_NEW

# define DECLARE_ALLOCATOR(CLASS)                        \
  CLKRhashAllocator* LKRHASH_NS::CLASS::sm_palloc = NULL

# define DECLARE_ALLOCATOR_LHTSUBCLASS(CLASS)            \
  CLKRhashAllocator* LKRHASH_NS::CLKRLinearHashTable::CLASS::sm_palloc = NULL


  // DECLARE_ALLOCATOR(CLKRLinearHashTable);
  // DECLARE_ALLOCATOR(CLKRHashTable);
  DECLARE_ALLOCATOR(CNodeClump);
  DECLARE_ALLOCATOR(CSmallSegment);
  DECLARE_ALLOCATOR(CMediumSegment);
  DECLARE_ALLOCATOR(CLargeSegment);

#endif // LKRHASH_ALLOCATOR_NEW


static bool s_fInitialized = false;
static LONG g_nLkrInitCount = 0;
CSimpleLock g_lckLkrInit;


// -------------------------------------------------------------------------
// Initialize per-class allocators
// -------------------------------------------------------------------------

bool
LKRHashTableInit()
{
    bool f = true;

#define INIT_ALLOCATOR(CLASS, N)                                \
    LKRHASH_ALLOCATOR_INIT(LKRHASH_NS::CLASS, N, f)

#define INIT_ALLOCATOR_LHTSUBCLASS(CLASS, N)                    \
    LKRHASH_ALLOCATOR_INIT(LKRHASH_NS::CLKRLinearHashTable::CLASS, N, f)


    g_lckLkrInit.Enter();

    LONG nCount = g_nLkrInitCount;

    UNREFERENCED_PARAMETER(nCount);
    IRTLTRACE1("LKRHashTableInit, %ld\n", nCount);

    if (++g_nLkrInitCount == 1)
    {
        // INIT_ALLOCATOR(CLKRLinearHashTable,        20);
        // INIT_ALLOCATOR(CLKRHashTable,               4);
        INIT_ALLOCATOR(CNodeClump,    200);
        INIT_ALLOCATOR(CSmallSegment,   5);
        INIT_ALLOCATOR(CMediumSegment,  5);
        INIT_ALLOCATOR(CLargeSegment,   5);

        s_fInitialized = f;
    }

    g_lckLkrInit.Leave();

    return f;
} // LKRHashTableInit



// -------------------------------------------------------------------------
// Destroy per-class allocators
// -------------------------------------------------------------------------

void
LKRHashTableUninit()
{
#define UNINIT_ALLOCATOR(CLASS)                        \
    LKRHASH_ALLOCATOR_UNINIT(LKRHASH_NS::CLASS)

#define UNINIT_ALLOCATOR_LHTSUBCLASS(CLASS)            \
    LKRHASH_ALLOCATOR_UNINIT(LKRHASH_NS::CLKRLinearHashTable::CLASS)

    g_lckLkrInit.Enter();

    LONG nCount = g_nLkrInitCount;

    UNREFERENCED_PARAMETER(nCount);

    if (--g_nLkrInitCount == 0)
    {
        // UNINIT_ALLOCATOR(CLKRLinearHashTable);
        // UNINIT_ALLOCATOR(CLKRHashTable);
        UNINIT_ALLOCATOR(CNodeClump);
        UNINIT_ALLOCATOR(CSmallSegment);
        UNINIT_ALLOCATOR(CMediumSegment);
        UNINIT_ALLOCATOR(CLargeSegment);
        
        s_fInitialized = false;
    }

    g_lckLkrInit.Leave();

    IRTLTRACE1("LKRHashTableUninit done, %ld\n", nCount);

} // LKRHashTableUninit



#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

// See if countdown loops are faster than countup loops for traversing
// a CNodeClump
#ifdef LKR_COUNTDOWN
 #define  FOR_EACH_NODE(x)    for (x = NODES_PER_CLUMP;  --x >= 0;  )
#else // !LKR_COUNTDOWN
 #define  FOR_EACH_NODE(x)    for (x = 0;  x < NODES_PER_CLUMP;  ++x)
#endif // !LKR_COUNTDOWN


// -------------------------------------------------------------------------
// class static member variables
// -------------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION
LONG CBucket::sm_cBuckets    = 0;

LONG CLKRLinearHashTable::sm_cTables              = 0;
#endif // LOCK_INSTRUMENTATION


#ifndef LKR_NO_GLOBAL_LIST
CLockedDoubleList CLKRLinearHashTable::sm_llGlobalList;
CLockedDoubleList CLKRHashTable::sm_llGlobalList;
#endif // LKR_NO_GLOBAL_LIST



// CLKRLinearHashTable --------------------------------------------------------
// Public Constructor for class CLKRLinearHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    DWORD         /*num_subtbls*/,  // for compatiblity with CLKRHashTable
    bool            fMultiKeys      // Allow multiple identical keys?
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_nTableLockType(static_cast<BYTE>(TableLock::LockType())),
      m_nBucketLockType(static_cast<BYTE>(BucketLock::LockType())),
      m_phtParent(NULL),    // directly created, no owning table
      m_fMultiKeys(fMultiKeys)
{
#ifndef LOCK_INSTRUMENTATION
    STATIC_ASSERT(1 <= LK_DFLT_MAXLOAD  && LK_DFLT_MAXLOAD <= NODES_PER_CLUMP);
#endif // !LOCK_INSTRUMENTATION
    STATIC_ASSERT(0 <= NODE_BEGIN  &&  NODE_BEGIN < NODES_PER_CLUMP);
    STATIC_ASSERT(!(0 <= NODE_END  &&  NODE_END < NODES_PER_CLUMP));

    IRTLVERIFY(LK_SUCCESS
               == _Initialize(pfnExtractKey, pfnCalcKeyHash, pfnEqualKeys,
                              pfnAddRefRecord, pszName, maxload, initsize));

    _InsertThisIntoGlobalList();
} // CLKRLinearHashTable::CLKRLinearHashTable



// CLKRLinearHashTable --------------------------------------------------------
// Private Constructor for class CLKRLinearHashTable, used by CLKRHashTable.
// -------------------------------------------------------------------------

CLKRLinearHashTable::CLKRLinearHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    CLKRHashTable*  phtParent,      // Owning table.
    bool            fMultiKeys      // Allow multiple identical keys?
    )
    :
#ifdef LOCK_INSTRUMENTATION
      m_Lock(_LockName()),
#endif // LOCK_INSTRUMENTATION
      m_nTableLockType(static_cast<BYTE>(TableLock::LockType())),
      m_nBucketLockType(static_cast<BYTE>(BucketLock::LockType())),
      m_phtParent(phtParent),
      m_fMultiKeys(fMultiKeys)
{
    IRTLASSERT(m_phtParent != NULL);
    IRTLVERIFY(LK_SUCCESS
               == _Initialize(pfnExtractKey, pfnCalcKeyHash, pfnEqualKeys,
                              pfnAddRefRecord, pszName, maxload, initsize));

    _InsertThisIntoGlobalList();
} // CLKRLinearHashTable::CLKRLinearHashTable



// _Initialize -------------------------------------------------------------
// Do all the real work of constructing a CLKRLinearHashTable
// -------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Initialize(
    PFnExtractKey   pfnExtractKey,
    PFnCalcKeyHash  pfnCalcKeyHash,
    PFnEqualKeys    pfnEqualKeys,
    PFnAddRefRecord pfnAddRefRecord,
    LPCSTR          pszName,
    double          maxload,
    DWORD           initsize)
{
    m_dwSignature =     SIGNATURE;
    m_dwBktAddrMask0 =  0;
    m_dwBktAddrMask1 =  0;
    m_iExpansionIdx =   0;
    m_paDirSegs =       NULL;
    m_lkts =            LK_MEDIUM_TABLESIZE;
    m_dwSegBits =       0;
    m_dwSegSize =       0;
    m_dwSegMask =       0;
    m_lkrcState =       LK_UNUSABLE;
    m_MaxLoad =         LK_DFLT_MAXLOAD;
    m_nLevel =          0;
    m_cDirSegs =        0;
    m_cRecords =        0;
    m_cActiveBuckets =  0;
    m_wBucketLockSpins= LOCK_USE_DEFAULT_SPINS;
    m_pfnExtractKey =   pfnExtractKey;
    m_pfnCalcKeyHash =  pfnCalcKeyHash;
    m_pfnEqualKeys =    pfnEqualKeys;
    m_pfnAddRefRecord = pfnAddRefRecord;

    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    IRTLASSERT(m_pfnExtractKey != NULL
               && m_pfnCalcKeyHash != NULL
               && m_pfnEqualKeys != NULL
               && m_pfnAddRefRecord != NULL);

    IRTLASSERT(s_fInitialized);

    if (!s_fInitialized)
        return (m_lkrcState = LK_NOT_INITIALIZED);

    if (m_pfnExtractKey == NULL
            || m_pfnCalcKeyHash == NULL
            || m_pfnEqualKeys == NULL
            || m_pfnAddRefRecord == NULL)
        return (m_lkrcState = LK_BAD_PARAMETERS);

    // TODO: better sanity check for ridiculous values?
    m_MaxLoad = (maxload <= 1.0)  ?  LK_DFLT_MAXLOAD  :  maxload;
    m_MaxLoad = min(m_MaxLoad, 10 * NODES_PER_CLUMP);

    // Choose the size of the segments according to the desired "size" of
    // the table, small, medium, or large.
    LK_TABLESIZE lkts;

    if (initsize == LK_SMALL_TABLESIZE)
    {
        lkts = LK_SMALL_TABLESIZE;
        initsize = CSmallSegment::INITSIZE;
    }
    else if (initsize == LK_MEDIUM_TABLESIZE)
    {
        lkts = LK_MEDIUM_TABLESIZE;
        initsize = CMediumSegment::INITSIZE;
    }
    else if (initsize == LK_LARGE_TABLESIZE)
    {
        lkts = LK_LARGE_TABLESIZE;
        initsize = CLargeSegment::INITSIZE;
    }

    // specified an explicit initial size
    else
    {
        // force Small::INITSIZE  <= initsize <=  MAX_DIRSIZE * Large::INITSIZE
        initsize = min(max(initsize, CSmallSegment::INITSIZE),
                       (MAX_DIRSIZE >> CLargeSegment::SEGBITS)
                            * CLargeSegment::INITSIZE);

        // Guess a table size
        if (initsize <= 8 * CSmallSegment::INITSIZE)
            lkts = LK_SMALL_TABLESIZE;
        else if (initsize >= CLargeSegment::INITSIZE)
            lkts = LK_LARGE_TABLESIZE;
        else
            lkts = LK_MEDIUM_TABLESIZE;
    }

    return _SetSegVars(lkts, initsize);
} // CLKRLinearHashTable::_Initialize



// CLKRHashTable ----------------------------------------------------------
// Constructor for class CLKRHashTable.
// ---------------------------------------------------------------------

CLKRHashTable::CLKRHashTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Bound on the average chain length
    DWORD           initsize,       // Initial size of hash table.
    DWORD           num_subtbls,    // Number of subordinate hash tables.
    bool            fMultiKeys      // Allow multiple identical keys?
    )
    : m_dwSignature(SIGNATURE),
      m_cSubTables(0),
      m_palhtDir(NULL),
      m_pfnExtractKey(pfnExtractKey),
      m_pfnCalcKeyHash(pfnCalcKeyHash),
      m_lkrcState(LK_BAD_PARAMETERS)
{
    strncpy(m_szName, pszName, NAME_SIZE-1);
    m_szName[NAME_SIZE-1] = '\0';

    _InsertThisIntoGlobalList();

    IRTLASSERT(pfnExtractKey != NULL
               && pfnCalcKeyHash != NULL
               && pfnEqualKeys != NULL
               && pfnAddRefRecord != NULL);

    if (pfnExtractKey == NULL
            || pfnCalcKeyHash == NULL
            || pfnEqualKeys == NULL
            || pfnAddRefRecord == NULL)
        return;

    if (!s_fInitialized)
    {
        m_lkrcState = LK_NOT_INITIALIZED;
        return;
    }

    LK_TABLESIZE lkts = NumSubTables(initsize, num_subtbls);

#ifdef IRTLDEBUG
    int cBuckets = initsize;
    if (initsize == LK_SMALL_TABLESIZE)
        cBuckets = CSmallSegment::INITSIZE;
    else if (initsize == LK_MEDIUM_TABLESIZE)
        cBuckets = CMediumSegment::INITSIZE;
    else if (initsize == LK_LARGE_TABLESIZE)
        cBuckets = CLargeSegment::INITSIZE;

    IRTLTRACE(TEXT("CLKRHashTable: %s, %d subtables, initsize = %d, ")
              TEXT("total #buckets = %d\n"),
              ((lkts == LK_SMALL_TABLESIZE) ? "small" : 
               (lkts == LK_MEDIUM_TABLESIZE) ? "medium" : "large"),
              num_subtbls, initsize, cBuckets * num_subtbls);
#else  // !IRTLDEBUG
    UNREFERENCED_PARAMETER(lkts);
#endif // !IRTLDEBUG

    m_lkrcState = LK_ALLOC_FAIL;
    m_palhtDir  = _AllocateSubTableArray(num_subtbls);

    if (m_palhtDir == NULL)
        return;
    else
    {
        m_cSubTables = num_subtbls;
        for (DWORD i = 0;  i < m_cSubTables;  i++)
            m_palhtDir[i] = NULL;
    }

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i] = _AllocateSubTable(pszName, pfnExtractKey,
                                          pfnCalcKeyHash, pfnEqualKeys,
                                          pfnAddRefRecord, maxload,
                                          initsize, this, fMultiKeys);

        // Failed to allocate a subtable.  Destroy everything allocated so far.
        if (m_palhtDir[i] == NULL  ||  !m_palhtDir[i]->IsValid())
        {
            for (DWORD j = i;  j-- > 0;  )
                _FreeSubTable(m_palhtDir[j]);
            _FreeSubTableArray(m_palhtDir);
            m_cSubTables = 0;
            m_palhtDir   = NULL;

            return;
        }
    }

    m_nSubTableMask = m_cSubTables - 1;
    // power of 2?
    if ((m_nSubTableMask & m_cSubTables) != 0)
        m_nSubTableMask = -1;

    m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail
} // CLKRHashTable::CLKRHashTable



// ~CLKRLinearHashTable ------------------------------------------------------
// Destructor for class CLKRLinearHashTable
//-------------------------------------------------------------------------

CLKRLinearHashTable::~CLKRLinearHashTable()
{
    // must acquire all locks before deleting to make sure
    // that no other threads are using the table
    WriteLock();
    _Clear(false);
    WriteUnlock();

    _RemoveThisFromGlobalList();

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState = LK_UNUSABLE; // so IsUsable will fail
} // CLKRLinearHashTable::~CLKRLinearHashTable



// ~CLKRHashTable ------------------------------------------------------------
// Destructor for class CLKRHashTable
//-------------------------------------------------------------------------
CLKRHashTable::~CLKRHashTable()
{
    // Must delete the subtables in forward order (unlike
    // delete[], which starts at the end and moves backwards) to
    // prevent possibility of deadlock by acquiring the subtable
    // locks in a different order from the rest of the code.
    for (DWORD i = 0;  i < m_cSubTables;  ++i)
        _FreeSubTable(m_palhtDir[i]);

    _FreeSubTableArray(m_palhtDir);

    _RemoveThisFromGlobalList();

    m_dwSignature = SIGNATURE_FREE;
    m_lkrcState = LK_UNUSABLE; // so IsUsable will fail
} // CLKRHashTable::~CLKRHashTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRLinearHashTable::NumSubTables(
    DWORD&, DWORD&)
{
    LK_TABLESIZE lkts = LK_MEDIUM_TABLESIZE;

    return lkts;
} // CLKRLinearHashTable::NumSubTables



//------------------------------------------------------------------------
// Function: CLKRHashTable::NumSubTables
// Synopsis: 
//------------------------------------------------------------------------

LK_TABLESIZE
CLKRHashTable::NumSubTables(
    DWORD& rinitsize,
    DWORD& rnum_subtbls)
{
    LK_TABLESIZE lkts;
    
    // Establish the table size
    if (rinitsize == LK_SMALL_TABLESIZE
        ||  rinitsize == LK_MEDIUM_TABLESIZE
        ||  rinitsize == LK_LARGE_TABLESIZE)
    {
        lkts = static_cast<LK_TABLESIZE>(rinitsize);
    }
    else
    {
        if (rnum_subtbls != LK_DFLT_NUM_SUBTBLS)
        {
            rinitsize = (rinitsize - 1) / rnum_subtbls + 1;

            if (rinitsize <= CSmallSegment::SEGSIZE)
                lkts = LK_SMALL_TABLESIZE;
            else if (rinitsize >= CLargeSegment::SEGSIZE)
                lkts = LK_LARGE_TABLESIZE;
            else
                lkts = LK_MEDIUM_TABLESIZE;
        }
        else
        {
            lkts = LK_MEDIUM_TABLESIZE;
        }
    }

    // Choose a suitable number of subtables
    if (rnum_subtbls == LK_DFLT_NUM_SUBTBLS)
    {
        int nCPUs = NumProcessors();
        switch (lkts)
        {
        case LK_SMALL_TABLESIZE:
            rnum_subtbls = max(1, nCPUs);
            break;
        
        case LK_MEDIUM_TABLESIZE:
            rnum_subtbls = 2 * nCPUs;
            break;
        
        case LK_LARGE_TABLESIZE:
            rnum_subtbls = 4 * nCPUs;
            break;
        }
    }

    rnum_subtbls = min(MAX_SUBTABLES, rnum_subtbls);

    return lkts;
} // CLKRHashTable::NumSubTables



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindBucket
// Synopsis: Find a bucket, given its signature. The bucket is locked
//           before returning. Assumes table is already locked, to avoid
//           race conditions.
//------------------------------------------------------------------------

LOCK_FORCEINLINE
CBucket*
CLKRLinearHashTable::_FindBucket(
    DWORD dwSignature,
    bool  fLockForWrite) const
{
    IRTLASSERT(IsValid());
    IRTLASSERT(m_dwBktAddrMask0 > 0);
    IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0); // 00011..111
    IRTLASSERT(m_dwBktAddrMask0 == (1U << m_nLevel) - 1);
    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
    IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
    IRTLASSERT(m_iExpansionIdx <= m_dwBktAddrMask0);
    IRTLASSERT(2 < m_dwSegBits  &&  m_dwSegBits < 20
               &&  m_dwSegSize == (1U << m_dwSegBits)
               &&  m_dwSegMask == (m_dwSegSize - 1));
    IRTLASSERT(IsReadLocked()  ||  IsWriteLocked());
    
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    IRTLASSERT(dwBktAddr < m_cActiveBuckets);
    
    CBucket* const pbkt = _Bucket(dwBktAddr);
    IRTLASSERT(pbkt != NULL);
    
    if (fLockForWrite)
        pbkt->WriteLock();
    else
        pbkt->ReadLock();
    
    return pbkt;
} // CLKRLinearHashTable::_FindBucket



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_IsNodeCompact
// Synopsis: validates that a node is correctly compacted
//------------------------------------------------------------------------

int
CLKRLinearHashTable::_IsNodeCompact(
    CBucket* const pbkt) const
{
    CNodeClump* pncCurr;
    CNodeClump* pncPrev;
    bool fEmpty  = pbkt->m_ncFirst.InvalidSignature(NODE_BEGIN);
    int  cErrors = fEmpty ? !pbkt->m_ncFirst.IsLastClump() : 0;

    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (fEmpty)
            {
                cErrors += (!pncCurr->InvalidSignature(i));
                cErrors += (!pncCurr->IsEmptyNode(i));
            }
            else if (pncCurr->InvalidSignature(i))
            {
                fEmpty = true;
                cErrors += (!pncCurr->IsEmptyNode(i));
                cErrors += (!pncCurr->IsLastClump());
            }
            else // still in non-empty portion
            {
                cErrors += (pncCurr->InvalidSignature(i));
                cErrors += (pncCurr->IsEmptyNode(i));
            }
        }
    }

    return cErrors;
} // CLKRLinearHashTable::_IsNodeCompact



//------------------------------------------------------------------------
// Function: CLKRHashTable::_SubTable
// Synopsis:
//------------------------------------------------------------------------

LOCK_FORCEINLINE
CLKRHashTable::SubTable*
CLKRHashTable::_SubTable(
    DWORD dwSignature) const
{
    IRTLASSERT(m_lkrcState == LK_SUCCESS
               &&  m_palhtDir != NULL  &&  m_cSubTables > 0);
    
    const DWORD PRIME = 1048583UL;  // used to scramble the hash sig
    DWORD       index = dwSignature;
    
    index = (((index * PRIME + 12345) >> 16)
             | ((index * 69069 + 1) & 0xffff0000));
    
    if (m_nSubTableMask >= 0)
        index &= m_nSubTableMask;
    else
        index %= m_cSubTables;

    return m_palhtDir[index];
} // CLKRHashTable::_SubTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::_SubTableIndex
// Synopsis:
//------------------------------------------------------------------------

int
CLKRHashTable::_SubTableIndex(
    CLKRHashTable::SubTable* pst) const
{
    int index = -1;
    
    for (int i = 0;  i < (int) m_cSubTables;  ++i)
    {
        if (pst == m_palhtDir[i])
        {
            index = i;
            break;
        }
    }

    IRTLASSERT(index >= 0);

    return index;
} // CLKRHashTable::_SubTableIndex



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InsertRecord
// Synopsis: Inserts a new record into the hash table. If this causes the
//           average chain length to exceed the upper bound, the table is
//           expanded by one bucket.
// Output:   LK_SUCCESS,    if the record was inserted.
//           LK_KEY_EXISTS, if the record was not inserted (because a record
//               with the same key value already exists in the table, unless
//               fOverwrite==true).
//           LK_ALLOC_FAIL, if failed to allocate the required space
//           LK_UNUSABLE,   if hash table not in usable state
//           LK_BAD_RECORD, if record is bad.
//
// TODO: honor m_fMultiKeys and allow multiple identical keys.
// This will require keeping all identical signatures contiguously
// within a bucket chain, and keeping all identical keys contigously
// within that set of contigous signatures. With a good hash function,
// there should not be identical signatures without also having
// identical keys. Also, need to modify _DeleteNode. This modification
// is needed for EqualRange and for hash_multiset and hash_multimap
// to work.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InsertRecord(
    const void* pvRecord,   // Pointer to the record to add to table
    DWORD       dwSignature,// hash signature
    bool        fOverwrite  // overwrite record if key already present
#ifdef LKR_STL_ITERATORS
  , Iterator*   piterResult
#endif // LKR_STL_ITERATORS
    )
{
    IRTLASSERT(IsUsable()
               &&  pvRecord != NULL
               &&  dwSignature != HASH_INVALID_SIGNATURE);

    // find the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

#ifdef LKR_STL_ITERATORS
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    IRTLASSERT(dwBktAddr < m_cActiveBuckets);
#endif // LKR_STL_ITERATORS
    
    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    // check that no record with the same key value exists
    // and save a pointer to the last element on the chain
    LK_RETCODE lkrc = LK_SUCCESS;
    CNodeClump* pncFree = NULL;
    int         iFreePos = NODE_BEGIN - NODE_STEP;
    CNodeClump* pncPrev = NULL;
    bool        fUpdate = false;
    const DWORD_PTR pnKey = _ExtractKey(pvRecord);

    // walk down the entire bucket chain, looking for matching hash
    // signatures and keys
    
    CNodeClump* pncCurr = &pbkt->m_ncFirst;

    do
    {
        IRTLASSERT(pncCurr != NULL) ;

        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());

                pncFree  = pncCurr;
                iFreePos = i;
                goto insert;
            }

            if (dwSignature == pncCurr->m_dwKeySigs[i]
                &&  (pvRecord == pncCurr->m_pvNode[i]  ||
                    _EqualKeys(pnKey,  _ExtractKey(pncCurr->m_pvNode[i]))))
            {
                if (fOverwrite)
                {
                    // If we allow overwrites, this is the slot to do it to
                    fUpdate  = true;
                    pncFree  = pncCurr;
                    iFreePos = i;
                    goto insert;
                }
                else
                {
                    // overwrites forbidden: return an error
                    lkrc = LK_KEY_EXISTS;
                    goto exit;
                }
            }
        }

        pncPrev = pncCurr;
        pncCurr = pncCurr->m_pncNext;

    } while (pncCurr != NULL);

  insert:
    if (pncFree != NULL)
    {
        pncCurr = pncFree;
        IRTLASSERT(0 <= iFreePos  &&  iFreePos < NODES_PER_CLUMP);
    }
    else
    {
        // No free slots.  Attach the new node to the end of the chain
        IRTLASSERT(iFreePos == NODE_BEGIN - NODE_STEP);
        pncCurr = _AllocateNodeClump();

        if (pncCurr == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            goto exit;
        }

        IRTLASSERT(pncPrev != NULL  &&  pncPrev->IsLastClump());
        pncPrev->m_pncNext = pncCurr;
        iFreePos = NODE_BEGIN;
    }

    // Bump the new record's reference count upwards
    _AddRefRecord(pvRecord, +1);

    if (fUpdate)
    {
        // We're overwriting an existing record.  Adjust the old record's
        // refcount downwards.  (Doing ++new, --old in this order ensures
        // that the refcount won't briefly go to zero if new and old are
        // the same record.)
        IRTLASSERT(!pncCurr->IsEmptyAndInvalid(iFreePos));
        _AddRefRecord(pncCurr->m_pvNode[iFreePos], -1);
    }
    else
    {
        IRTLASSERT(pncCurr->IsEmptyAndInvalid(iFreePos));
        InterlockedIncrement(reinterpret_cast<LONG*>(&m_cRecords));
    }

    pncCurr->m_dwKeySigs[iFreePos] = dwSignature;
    pncCurr->m_pvNode[iFreePos]    = pvRecord;

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
#ifdef LKR_STL_ITERATORS
        // Don't call _Expand() if we're putting the result into an
        // iterator, as _Expand() tends to invalidate any other
        // iterators that might be in use.
        if (piterResult != NULL)
        {
            piterResult->m_plht =         this;
            piterResult->m_pnc =          pncCurr;
            piterResult->m_dwBucketAddr = dwBktAddr;
            piterResult->m_iNode =        (short) iFreePos;

            // Add an extra reference on the record, as the one added by
            // _InsertRecord will be lost when the iterator's destructor
            // fires or its assignment operator is used
            piterResult->_AddRef(+1);
        }
        else
#endif // LKR_STL_ITERATORS
        {
            // If the average load factor has grown too high, we grow the
            // table one bucket at a time.
            while (m_cRecords > m_MaxLoad * m_cActiveBuckets)
            {
                // If _Expand returns an error code (viz. LK_ALLOC_FAIL), it
                // just means that there isn't enough spare memory to expand
                // the table by one bucket. This is likely to cause problems
                // elsewhere soon, but this hashtable has not been corrupted.
                // If the call to _AllocateNodeClump above failed, then we do
                // have a real error that must be propagated back to the caller
                // because we were unable to insert the element at all.
                if (_Expand() != LK_SUCCESS)
                    break;  // expansion failed
            }
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_InsertRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::InsertRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::InsertRecord(
    const void* pvRecord,
    bool fOverwrite /*=false*/)
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk = pst->_InsertRecord(pvRecord, hash_val, fOverwrite);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRHashTable::InsertRecord



//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteKey
// Synopsis: Deletes the record with the given key value from the hash
//           table (if it exists).
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteKey(
    const DWORD_PTR pnKey,      // Key value of the record, depends on key type
    DWORD           dwSignature
    )
{
    IRTLASSERT(IsUsable());

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (dwSignature != pncCurr->m_dwKeySigs[i])
                continue;

            const DWORD_PTR pnKey2 = _ExtractKey(pncCurr->m_pvNode[i]);

            if (pnKey == pnKey2  ||  _EqualKeys(pnKey,  pnKey2))
            {
                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        unsigned nContractedRecords = m_cRecords; 

        // Hysteresis: add a fudge factor to allow a slightly lower density
        // in the subtable. This reduces the frequency of contractions and
        // expansions in a subtable that gets a lot of deletions and insertions
        nContractedRecords += nContractedRecords >> 4;

        // Always want to have at least m_dwSegSize buckets
        while (m_cActiveBuckets * m_MaxLoad > nContractedRecords
               && m_cActiveBuckets > m_dwSegSize)
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_DeleteKey



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteKey
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::DeleteKey(
    const DWORD_PTR pnKey)
{
    if (!IsUsable())
        return m_lkrcState;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(pnKey);
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk       = pst->_DeleteKey(pnKey, hash_val);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRHashTable::DeleteKey



//-------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteRecord
// Synopsis: Deletes the specified record from the hash table (if it
//           exists).  This is not the same thing as calling
//           DeleteKey(_ExtractKey(pvRecord)).  If _DeleteKey were called for
//           a record that doesn't exist in the table, it could delete some
//           completely unrelated record that happened to have the same key.
// Returns:  LK_SUCCESS, if record found and deleted.
//           LK_NO_SUCH_KEY, if the record is not found in the table.
//           LK_UNUSABLE, if hash table not in usable state.
//-------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_DeleteRecord(
    const void* pvRecord,   // Pointer to the record to delete from the table
    DWORD       dwSignature
    )
{
    IRTLASSERT(IsUsable()  &&  pvRecord != NULL);

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, true);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsWriteLocked());
    WriteUnlock();

    const DWORD_PTR pnKey = _ExtractKey(pvRecord);

    UNREFERENCED_PARAMETER(pnKey);
    IRTLASSERT(dwSignature == _CalcKeyHash(pnKey));

    // scan down the bucket chain, looking for the victim
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(_EqualKeys(pnKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);

                IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                lkrc = LK_SUCCESS;
                goto exit;
            }
        }
    }

  exit:
    pbkt->WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        // contract the table if necessary
        unsigned nContractedRecords = m_cRecords; 

        // Hysteresis: add a fudge factor to allow a slightly lower density
        // in the subtable. This reduces the frequency of contractions and
        // expansions in a subtable that gets a lot of deletions and insertions
        nContractedRecords += nContractedRecords >> 4;

        // Always want to have at least m_dwSegSize buckets
        while (m_cActiveBuckets * m_MaxLoad > nContractedRecords
               && m_cActiveBuckets > m_dwSegSize)
        {
            // If _Contract returns an error code (viz. LK_ALLOC_FAIL), it
            // just means that there isn't enough spare memory to contract
            // the table by one bucket. This is likely to cause problems
            // elsewhere soon, but this hashtable has not been corrupted.
            if (_Contract() != LK_SUCCESS)
                break;
        }
    }

    return lkrc;
} // CLKRLinearHashTable::_DeleteRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::DeleteRecord(
    const void* pvRecord)
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_WRITE_LOCK();    // usu. no-op

    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);
    LK_RETCODE lk       = pst->_DeleteRecord(pvRecord, hash_val);

    LKRHASH_GLOBAL_WRITE_UNLOCK();    // usu. no-op
    return lk;
} // CLKRHashTable::DeleteRecord



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteNode
// Synopsis: Deletes a node; removes the node clump if empty
// Returns:  true if successful
//
// TODO: Is the rpncPrev parameter really necessary?
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_DeleteNode(
    CBucket*     pbkt,      // bucket chain containing node
    CNodeClump*& rpnc,      // actual node
    CNodeClump*& rpncPrev,  // predecessor of actual node, or NULL
    int&         riNode)    // index within node
{
    IRTLASSERT(pbkt != NULL  &&  pbkt->IsWriteLocked());
    IRTLASSERT(rpnc != NULL);
    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);
    IRTLASSERT(0 <= riNode  &&  riNode < NODES_PER_CLUMP);
    IRTLASSERT(!rpnc->IsEmptyAndInvalid(riNode));

#ifdef IRTLDEBUG
    // Check that the node clump really does belong to the bucket
    CNodeClump* pnc1 = &pbkt->m_ncFirst;

    while (pnc1 != NULL  &&  pnc1 != rpnc)
         pnc1 = pnc1->m_pncNext;

    IRTLASSERT(pnc1 == rpnc);
#endif // IRTLDEBUG

    // Release the reference to the record
    _AddRefRecord(rpnc->m_pvNode[riNode], -1);

    IRTLASSERT(0 == _IsNodeCompact(pbkt));

    // TODO: honor m_fMultiKeys

    // Compact the nodeclump by moving the very last node back to the
    // newly freed slot
    CNodeClump* pnc2   = rpnc;
    int         iNode2 = riNode;

    // Find the last nodeclump in the chain
    while (!pnc2->IsLastClump())
    {
         pnc2 = pnc2->m_pncNext;
         iNode2 = NODE_BEGIN;
    }

    IRTLASSERT(0 <= iNode2  &&  iNode2 < NODES_PER_CLUMP);
    IRTLASSERT(!pnc2->IsEmptyAndInvalid(iNode2));

    // Find the first empty slot in the nodeclump
    while (iNode2 != NODE_END  &&  !pnc2->IsEmptySlot(iNode2))
    {
        iNode2 += NODE_STEP;
    }

    // Back up to last non-empty slot
    iNode2 -= NODE_STEP;
    IRTLASSERT(0 <= iNode2  &&  iNode2 < NODES_PER_CLUMP
               &&  !pnc2->IsEmptyAndInvalid(iNode2));
    IRTLASSERT(iNode2+NODE_STEP == NODE_END
               ||  pnc2->IsEmptyAndInvalid(iNode2+NODE_STEP));

#ifdef IRTLDEBUG
    // Check that all the remaining nodes are empty
    IRTLASSERT(pnc2->IsLastClump());
    for (int iNode3 = iNode2 + NODE_STEP;
         iNode3 != NODE_END;
         iNode3 += NODE_STEP)
    {
        IRTLASSERT(pnc2->IsEmptyAndInvalid(iNode3));
    }
#endif // IRTLDEBUG

    // Move the last node's data back to the current node
    rpnc->m_pvNode[riNode]    = pnc2->m_pvNode[iNode2];
    rpnc->m_dwKeySigs[riNode] = pnc2->m_dwKeySigs[iNode2];

    // Blank the old last node.
    // Correct even if (rpnc, riNode) == (pnc2, iNode2).
    pnc2->m_pvNode[iNode2]    = NULL;
    pnc2->m_dwKeySigs[iNode2] = HASH_INVALID_SIGNATURE;

    IRTLASSERT(0 == _IsNodeCompact(pbkt));

    // Back up riNode by one, so that the next iteration of the loop
    // calling _DeleteNode will end up pointing to the same spot.
    if (riNode != NODE_BEGIN)
    {
        riNode -= NODE_STEP;
    }
    else
    {
        // rewind rpnc and rpncPrev to previous node
        if (rpnc == &pbkt->m_ncFirst)
        {
            riNode = NODE_BEGIN - NODE_STEP;
        }
        else
        {
            riNode = NODE_END;
            rpnc = rpncPrev;
            if (rpnc == &pbkt->m_ncFirst)
            {
                rpncPrev = NULL;
            }
            else
            {
                for (rpncPrev = &pbkt->m_ncFirst;
                     rpncPrev->m_pncNext != rpnc;
                     rpncPrev = rpncPrev->m_pncNext)
                {}
            }
        }
    }

    // Is the last node clump now completely empty?  Delete, if possible
    if (iNode2 == NODE_BEGIN  &&  pnc2 != &pbkt->m_ncFirst)
    {
        // Find preceding nodeclump
        CNodeClump* pnc3 = &pbkt->m_ncFirst;
        while (pnc3->m_pncNext != pnc2)
        {
            pnc3 = pnc3->m_pncNext;
            IRTLASSERT(pnc3 != NULL);
        }

        pnc3->m_pncNext = NULL;
#ifdef IRTLDEBUG
        pnc2->m_pncNext = NULL; // or dtor will ASSERT
#endif // IRTLDEBUG
        _FreeNodeClump(pnc2);
    }

    IRTLASSERT(rpncPrev == NULL  ||  rpncPrev->m_pncNext == rpnc);

    InterlockedDecrement(reinterpret_cast<LONG*>(&m_cRecords));

    return true;
} // CLKRLinearHashTable::_DeleteNode



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindKey
// Synopsis: Locate the record associated with the given key value.
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
//           LK_BAD_RECORD, if ppvRecord is invalid
//           LK_NO_SUCH_KEY, if no record with the given key value was found.
//           LK_UNUSABLE, if hash table not in usable state
// Note:     the record is AddRef'd.  You must decrement the reference count
//           when you are finished with the record (if you're implementing
//           refcounting semantics).
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindKey(
    const DWORD_PTR  pnKey,  // Key value of the record, depends on key type
    DWORD        dwSignature,// hash signature
    const void** ppvRecord   // resultant record
#ifdef LKR_STL_ITERATORS
  , Iterator*   piterResult
#endif // LKR_STL_ITERATORS
    ) const
{
    IRTLASSERT(IsUsable()  &&  ppvRecord != NULL);

    *ppvRecord = NULL;
    LK_RETCODE lkrc = LK_NO_SUCH_KEY;
    int iNode = NODE_BEGIN - NODE_STEP;

    // locate the beginning of the correct bucket chain
    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

#ifdef LKR_STL_ITERATORS
    const DWORD dwBktAddr = _BucketAddress(dwSignature);
    IRTLASSERT(dwBktAddr < m_cActiveBuckets);
#endif // LKR_STL_ITERATORS
    
    CBucket* const pbkt = _FindBucket(dwSignature, false);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    _ReadOrWriteUnlock(fReadLocked);

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        FOR_EACH_NODE(iNode)
        {
            if (pncCurr->IsEmptySlot(iNode))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(iNode));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (dwSignature != pncCurr->m_dwKeySigs[iNode])
                continue;

            const DWORD_PTR pnKey2 = _ExtractKey(pncCurr->m_pvNode[iNode]);

            if (pnKey == pnKey2  ||  _EqualKeys(pnKey,  pnKey2))
            {
                    *ppvRecord = pncCurr->m_pvNode[iNode];
                    lkrc = LK_SUCCESS;

                    // bump the reference count before handing the record
                    // back to the user.  The user should decrement the
                    // reference count when finished with this record.
                    _AddRefRecord(*ppvRecord, +1);
                    goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();

#ifdef LKR_STL_ITERATORS
    if (piterResult != NULL  &&  lkrc == LK_SUCCESS)
    {
        piterResult->m_plht =         const_cast<CLKRLinearHashTable*>(this);
        piterResult->m_pnc =          pncCurr;
        piterResult->m_dwBucketAddr = dwBktAddr;
        piterResult->m_iNode =        (short) iNode;
    }
#endif // LKR_STL_ITERATORS

    return lkrc;
} // CLKRLinearHashTable::_FindKey



//------------------------------------------------------------------------
// Function: CLKRHashTable::FindKey
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::FindKey(
    const DWORD_PTR pnKey,
    const void**    ppvRecord) const
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (ppvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op
    DWORD     hash_val   = _CalcKeyHash(pnKey);
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_FindKey(pnKey, hash_val, ppvRecord);
    LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::FindKey



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FindRecord
// Synopsis: Sees if the record is contained in the table
// Returns:  Pointer to the record, if it is found.
//           NULL, if the record is not found.
// Returns:  LK_SUCCESS, if record found
//           LK_BAD_RECORD, if pvRecord is invalid
//           LK_NO_SUCH_KEY, if the record was not found in the table
//           LK_UNUSABLE, if hash table not in usable state
// Note:     The record is *not* AddRef'd.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_FindRecord(
    const void* pvRecord,    // Pointer to the record to find in the table
    DWORD       dwSignature  // hash signature
    ) const
{
    IRTLASSERT(IsUsable()  &&  pvRecord != NULL);

    LK_RETCODE lkrc = LK_NO_SUCH_KEY;

    // locate the beginning of the correct bucket chain
    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    CBucket* const pbkt = _FindBucket(dwSignature, false);
    IRTLASSERT(pbkt != NULL);
    IRTLASSERT(pbkt->IsReadLocked());
    _ReadOrWriteUnlock(fReadLocked);

    const DWORD_PTR pnKey = _ExtractKey(pvRecord);

    UNREFERENCED_PARAMETER(pnKey);
    IRTLASSERT(dwSignature == _CalcKeyHash(pnKey));

    // walk down the bucket chain
    for (CNodeClump* pncCurr = &pbkt->m_ncFirst;
         pncCurr != NULL;
         pncCurr = pncCurr->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pncCurr->IsEmptySlot(i))
            {
                IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                IRTLASSERT(0 == _IsNodeCompact(pbkt));
                IRTLASSERT(pncCurr->IsLastClump());
                goto exit;
            }

            if (pncCurr->m_pvNode[i] == pvRecord)
            {
                IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[i]);
                IRTLASSERT(_EqualKeys(pnKey,
                                      _ExtractKey(pncCurr->m_pvNode[i])));
                lkrc = LK_SUCCESS;

                goto exit;
            }
        }
    }

  exit:
    pbkt->ReadUnlock();
    return lkrc;
} // CLKRLinearHashTable::_FindRecord



//------------------------------------------------------------------------
// Function: CLKRHashTable::FindRecord
// Synopsis: Thin wrapper for the corresponding method in CLKRLinearHashTable
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::FindRecord(
    const void* pvRecord) const
{
    if (!IsUsable())
        return m_lkrcState;
    
    if (pvRecord == NULL)
        return LK_BAD_RECORD;
    
    LKRHASH_GLOBAL_READ_LOCK();    // usu. no-op
    DWORD     hash_val   = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst  = _SubTable(hash_val);
    LK_RETCODE lkrc      = pst->_FindRecord(pvRecord, hash_val);
    LKRHASH_GLOBAL_READ_UNLOCK();    // usu. no-op

    return lkrc;
} // CLKRHashTable::FindRecord



#ifdef LKR_APPLY_IF

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    LK_PREDICATE lkp = LKP_PERFORM;
    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    DWORD dw = _Apply(pfnAction, pvState, lkl, lkp);
    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRLinearHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRHashTable::Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_Apply(pfnAction, pvState, lkl, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRHashTable::Apply



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        dw = _ApplyIf(pfnPredicate, pfnAction, pvState, lkl, lkp);
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();
    return dw;
} // CLKRLinearHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::ApplyIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    if (lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_ApplyIf(pfnPredicate, pfnAction,
                                          pvState, lkl, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    if (lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    return dw;
} // CLKRHashTable::ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::DeleteIf(
    PFnRecordPred pfnPredicate,
    void*         pvState)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    WriteLock();
    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());
    if (IsValid())
        dw = _DeleteIf(pfnPredicate, pvState, lkp);
    WriteUnlock();

    return dw;
} // CLKRLinearHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRHashTable::DeleteIf
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRHashTable::DeleteIf(
    PFnRecordPred pfnPredicate,
    void*         pvState)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    DWORD dw = 0;
    LK_PREDICATE lkp = LKP_PERFORM;

    WriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (IsValid())
    {
        for (DWORD i = 0;  i < m_cSubTables;  i++)
        {
            dw += m_palhtDir[i]->_DeleteIf(pfnPredicate, pvState, lkp);
            if (lkp == LKP_ABORT  ||  lkp == LKP_PERFORM_STOP
                ||  lkp == LKP_DELETE_STOP)
                break;
        }
    }

    WriteUnlock();

    return dw;
} // CLKRHashTable::DeleteIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Apply
// Synopsis:
// Returns:
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_Apply(
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl,
    LK_PREDICATE&  rlkp)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    IRTLASSERT(lkl == LKL_WRITELOCK  ?  IsWriteLocked()  :  IsReadLocked());
    return _ApplyIf(_PredTrue, pfnAction, pvState, lkl, rlkp);
} // CLKRLinearHashTable::_Apply



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_ApplyIf
// Synopsis:
// Returns:  Number of successful actions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_ApplyIf(
    PFnRecordPred   pfnPredicate,
    PFnRecordAction pfnAction,
    void*           pvState,
    LK_LOCKTYPE    lkl,
    LK_PREDICATE&  rlkp)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    IRTLASSERT(lkl == LKL_WRITELOCK  ?  IsWriteLocked()  :  IsReadLocked());
    IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);

    if ((lkl == LKL_WRITELOCK  ?  !IsWriteLocked()  :  !IsReadLocked())
            ||  pfnPredicate == NULL  ||  pfnAction == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);

        if (lkl == LKL_WRITELOCK)
            pbkt->WriteLock();
        else
            pbkt->ReadLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int i;

            FOR_EACH_NODE(i)
            {
                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(0 == _IsNodeCompact(pbkt));
                    IRTLASSERT(pncCurr->IsLastClump());
                    goto unlock;
                }
                else
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        if (lkl == LKL_WRITELOCK)
                            pbkt->WriteUnlock();
                        else
                            pbkt->ReadUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                        if (lkl != LKL_WRITELOCK)
                        {
                            pbkt->ReadUnlock();
                            return cActions;
                        }

                        // fall through

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    {
                        LK_ACTION lka;

                        if (rlkp == LKP_DELETE  ||  rlkp == LKP_DELETE_STOP)
                        {
                            IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                            ++cActions;
                            lka = LKA_SUCCEEDED;
                        }
                        else
                        {
                            lka = (*pfnAction)(pncCurr->m_pvNode[i], pvState);

                            switch (lka)
                            {
                            case LKA_ABORT:
                                if (lkl == LKL_WRITELOCK)
                                    pbkt->WriteUnlock();
                                else
                                    pbkt->ReadUnlock();
                                return cActions;
                                
                            case LKA_FAILED:
                                // nothing to do
                                break;
                                
                            case LKA_SUCCEEDED:
                                ++cActions;
                                break;
                                
                            default:
                                IRTLASSERT(! "Unknown LK_ACTION in ApplyIf");
                                break;
                            }
                        }

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            if (lkl == LKL_WRITELOCK)
                                pbkt->WriteUnlock();
                            else
                                pbkt->ReadUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(! "Unknown LK_PREDICATE in ApplyIf");
                        break;
                    }
                }
            }
        }

      unlock:
        if (lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    return cActions;
} // CLKRLinearHashTable::_ApplyIf



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_DeleteIf
// Synopsis: Deletes all records that match the predicate
// Returns:  Count of successful deletions
//------------------------------------------------------------------------

DWORD
CLKRLinearHashTable::_DeleteIf(
    PFnRecordPred  pfnPredicate,
    void*          pvState,
    LK_PREDICATE& rlkp)
{
    if (!IsUsable())
        return static_cast<DWORD>(LK_UNUSABLE);

    IRTLASSERT(IsWriteLocked());
    IRTLASSERT(pfnPredicate != NULL);

    if (!IsWriteLocked()  ||  pfnPredicate == NULL)
        return 0;

    DWORD cActions = 0;

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int i;

            FOR_EACH_NODE(i)
            {
                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(0 == _IsNodeCompact(pbkt));
                    IRTLASSERT(pncCurr->IsLastClump());
                    goto unlock;
                }
                else
                {
                    rlkp = (*pfnPredicate)(pncCurr->m_pvNode[i], pvState);

                    switch (rlkp)
                    {
                    case LKP_ABORT:
                        pbkt->WriteUnlock();
                        return cActions;
                        break;

                    case LKP_NO_ACTION:
                        // nothing to do
                        break;

                    case LKP_PERFORM:
                    case LKP_PERFORM_STOP:
                    case LKP_DELETE:
                    case LKP_DELETE_STOP:
                    {
                        IRTLVERIFY(_DeleteNode(pbkt, pncCurr, pncPrev, i));

                        ++cActions;

                        if (rlkp == LKP_PERFORM_STOP
                            ||  rlkp == LKP_DELETE_STOP)
                        {
                            pbkt->WriteUnlock();
                            return cActions;
                        }

                        break;
                    }

                    default:
                        IRTLASSERT(! "Unknown LK_PREDICATE in DeleteIf");
                        break;
                    }
                }
            }
        }

      unlock:
        pbkt->WriteUnlock();
    }

    return cActions;
} // CLKRLinearHashTable::_DeleteIf

#endif // LKR_APPLY_IF



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------

int
CLKRLinearHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE;

    bool fReadLocked = _ReadOrWriteLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());

    if (!IsValid())
    {
        _ReadOrWriteUnlock(fReadLocked);
        return LK_UNUSABLE;
    }

    int       cMisplaced = 0;
    DWORD     cRecords = 0;
    int       retcode = 0;

    // Check every bucket
    for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
    {
        CBucket* const pbkt = _Bucket(i);

        IRTLASSERT(pbkt != NULL);
        retcode += !(pbkt != NULL);

        pbkt->ReadLock();

        IRTLASSERT(0 == _IsNodeCompact(pbkt));

        // Walk the bucket chain
        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
        {
            int j;

            FOR_EACH_NODE(j)
            {
                if (pncCurr->IsEmptySlot(j))
                {
                    IRTLASSERT(pncCurr->IsLastClump());
                    retcode += !(pncCurr->IsLastClump());

                    for (int k = j;  k != NODE_END;  k += NODE_STEP)
                    {
                        IRTLASSERT(pncCurr->IsEmptyNode(k));
                        retcode += !pncCurr->IsEmptyNode(k);
                        IRTLASSERT(pncCurr->InvalidSignature(k));
                        retcode += !pncCurr->InvalidSignature(k);
                    }
                    break;
                }

                if (!pncCurr->IsEmptySlot(j))
                {
                    ++cRecords;

                    const DWORD_PTR pnKey = _ExtractKey(pncCurr->m_pvNode[j]);

                    DWORD dwSignature = _CalcKeyHash(pnKey);
                    IRTLASSERT(dwSignature != HASH_INVALID_SIGNATURE);
                    retcode += !(dwSignature != HASH_INVALID_SIGNATURE);
                    IRTLASSERT(dwSignature == pncCurr->m_dwKeySigs[j]);
                    retcode += !(dwSignature == pncCurr->m_dwKeySigs[j]);

                    DWORD address = _BucketAddress(dwSignature);
                    IRTLASSERT(address == i);
                    retcode += !(address == i);

                    if (address != i || dwSignature != pncCurr->m_dwKeySigs[j])
                        cMisplaced++;
                }
                else // pncCurr->IsEmptySlot(j)
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(j));
                    retcode += !pncCurr->IsEmptyAndInvalid(j);
                }
            }
            if (pncPrev != NULL)
            {
                IRTLASSERT(pncPrev->m_pncNext == pncCurr);
                retcode += !(pncPrev->m_pncNext == pncCurr);
            }
        }
        pbkt->ReadUnlock();
    }

    if (cRecords != m_cRecords)
        ++retcode;

    IRTLASSERT(cRecords == m_cRecords);
    retcode += !(cRecords == m_cRecords);

    if (cMisplaced > 0)
        retcode = cMisplaced;

    IRTLASSERT(cMisplaced == 0);
    retcode += !(cMisplaced == 0);

    _ReadOrWriteUnlock(fReadLocked);

    return retcode;
} // CLKRLinearHashTable::CheckTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::CheckTable
// Synopsis: Verify that all records are in the right place and can be located.
// Returns:   0 => hash table is consistent
//           >0 => that many misplaced records
//           <0 => otherwise invalid
//------------------------------------------------------------------------
int
CLKRHashTable::CheckTable() const
{
    if (!IsUsable())
        return LK_UNUSABLE;

    int retcode = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        retcode += m_palhtDir[i]->CheckTable();

    return retcode;
} // CLKRHashTable::CheckTable



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKRLinearHashTable::_Clear(
    bool fShrinkDirectory)  // Shrink to min size but don't destroy entirely?
{
    if (!IsUsable())
        return;

    IRTLASSERT(IsWriteLocked());

    // If we're Clear()ing the table AND the table has no records, we
    // can return immediately. The dtor, however, must clean up completely.
    if (fShrinkDirectory  &&  0 == m_cRecords)
        return;

#ifdef IRTLDEBUG
    DWORD cDeleted = 0;
    DWORD cOldRecords = m_cRecords;
#endif // IRTLDEBUG

    for (DWORD iBkt = 0;  iBkt < m_cActiveBuckets;  ++iBkt)
    {
        CBucket* const pbkt = _Bucket(iBkt);
        IRTLASSERT(pbkt != NULL);
        pbkt->WriteLock();

        IRTLASSERT(0 == _IsNodeCompact(pbkt));

        for (CNodeClump* pncCurr = &pbkt->m_ncFirst, *pncPrev = NULL;
             pncCurr != NULL;
             )
        {
            int i;

            FOR_EACH_NODE(i)
            {

                if (pncCurr->IsEmptySlot(i))
                {
                    IRTLASSERT(pncCurr->IsEmptyAndInvalid(i));
                    IRTLASSERT(pncCurr->IsLastClump());
                    break;
                }
                else
                {
                    _AddRefRecord(pncCurr->m_pvNode[i], -1);
                    pncCurr->m_pvNode[i]    = NULL;
                    pncCurr->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                    m_cRecords--;

#ifdef IRTLDEBUG
                    ++cDeleted;
#endif // IRTLDEBUG
                }
            } // for (i ...

            pncPrev = pncCurr;
            pncCurr = pncCurr->m_pncNext;
            pncPrev->m_pncNext = NULL;

            if (pncPrev != &pbkt->m_ncFirst)
                _FreeNodeClump(pncPrev);
        } // for (pncCurr ...

        pbkt->WriteUnlock();
    } // for (iBkt ...

    IRTLASSERT(m_cRecords == 0  &&  cDeleted == cOldRecords);

    // delete all segments
    for (DWORD iSeg = 0;  iSeg < m_cActiveBuckets;  iSeg += m_dwSegSize)
    {
        _FreeSegment(_Segment(iSeg));
        _Segment(iSeg) = NULL;
    }

    _FreeSegmentDirectory();
    m_nLevel = m_cActiveBuckets = m_iExpansionIdx = 0;
    m_dwBktAddrMask0 = 1;
    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;

    // set directory of segments to minimum size
    if (fShrinkDirectory)
    {
        DWORD cInitialBuckets = 0;

        if (LK_SMALL_TABLESIZE == m_lkts)
            cInitialBuckets = CSmallSegment::INITSIZE;
        else if (LK_MEDIUM_TABLESIZE == m_lkts)
            cInitialBuckets = CMediumSegment::INITSIZE;
        else if (LK_LARGE_TABLESIZE == m_lkts)
            cInitialBuckets = CLargeSegment::INITSIZE;
        else
            IRTLASSERT(! "Unknown LK_TABLESIZE");

        _SetSegVars(m_lkts, cInitialBuckets);
    }
} // CLKRLinearHashTable::_Clear



//------------------------------------------------------------------------
// Function: CLKRHashTable::Clear
// Synopsis: Remove all data from the table
//------------------------------------------------------------------------

void
CLKRHashTable::Clear()
{
    WriteLock();
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->_Clear(true);
    WriteUnlock();
} // CLKRHashTable::Clear



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRLinearHashTable::GetStatistics() const
{
    CLKRHashTableStats stats;

    if (!IsUsable())
        return stats;

    if (m_paDirSegs != NULL)
    {
        stats.RecordCount   = m_cRecords;
        stats.TableSize     = m_cActiveBuckets;
        stats.SplitFactor   = static_cast<double>(m_iExpansionIdx)
                              / (1ui64 << m_nLevel);
        stats.DirectorySize = m_cDirSegs;
        stats.NodeClumpSize = NODES_PER_CLUMP;
        stats.CBucketSize   = sizeof(CBucket);

#ifdef LOCK_INSTRUMENTATION
        stats.m_alsBucketsAvg.m_nContentions     = 0;
        stats.m_alsBucketsAvg.m_nSleeps          = 0;
        stats.m_alsBucketsAvg.m_nContentionSpins = 0;
        stats.m_alsBucketsAvg.m_nAverageSpins    = 0;
        stats.m_alsBucketsAvg.m_nReadLocks       = 0;
        stats.m_alsBucketsAvg.m_nWriteLocks      = 0;
        stats.m_alsBucketsAvg.m_nItems           = 0;
#endif // LOCK_INSTRUMENTATION

        int empty = 0;
        int totacc = 0;
        int low_count = 0;
        int high_count = 0;
        int max_length = 0;

        for (DWORD i = 0;  i < m_cActiveBuckets;  i++)
        {
            int acc = 0;

            for (CNodeClump* pncCurr = &_Bucket(i)->m_ncFirst;
                 pncCurr != NULL;
                 pncCurr = pncCurr->m_pncNext)
            {
                int j;

                FOR_EACH_NODE(j)
                {
                    if (!pncCurr->IsEmptySlot(j))
                    {
                        acc++;
                        totacc += acc;
                        int iBucketIndex = stats.BucketIndex(acc);
                        ++stats.m_aBucketLenHistogram[iBucketIndex];
                    }
                }
            }

#ifdef LOCK_INSTRUMENTATION
            CLockStatistics ls = _Bucket(i)->LockStats();

            stats.m_alsBucketsAvg.m_nContentions     += ls.m_nContentions;
            stats.m_alsBucketsAvg.m_nSleeps          += ls.m_nSleeps;
            stats.m_alsBucketsAvg.m_nContentionSpins += ls.m_nContentionSpins;
            stats.m_alsBucketsAvg.m_nAverageSpins    += ls.m_nAverageSpins;
            stats.m_alsBucketsAvg.m_nReadLocks       += ls.m_nReadLocks;
            stats.m_alsBucketsAvg.m_nWriteLocks      += ls.m_nWriteLocks;
            stats.m_alsBucketsAvg.m_nItems           ++;
#endif // LOCK_INSTRUMENTATION

            max_length = max(max_length, acc);
            if (acc == 0)
                empty++;

            if (_H0(i) < m_iExpansionIdx)
            {
                low_count += acc;
            }
            else
            {
                high_count += acc;
            }
        }

        stats.LongestChain = max_length;
        stats.EmptySlots   = empty;

        if (m_cActiveBuckets > 0)
        {
            if (m_cRecords > 0)
            {
                double x=static_cast<double>(m_iExpansionIdx) /(1ui64 << m_nLevel);
                double alpha= static_cast<double>(m_cRecords)/m_cActiveBuckets;
                double low_sl = 0.0;
                double high_sl = 0.0;
                
                stats.AvgSearchLength= static_cast<double>(totacc) /m_cRecords;
                stats.ExpSearchLength  = 1 + alpha * 0.25 * (2 + x - x*x);
                
                if (m_iExpansionIdx > 0)
                    low_sl  = static_cast<double>(low_count)
                        / (2.0 * m_iExpansionIdx);
                if (m_cActiveBuckets - 2 * m_iExpansionIdx > 0)
                    high_sl = static_cast<double>(high_count)
                        / (m_cActiveBuckets - 2.0 * m_iExpansionIdx);
                stats.AvgUSearchLength = low_sl * x + high_sl * (1.0 - x);
                stats.ExpUSearchLength = alpha * 0.5 * (2 + x - x*x);
            }

#ifdef LOCK_INSTRUMENTATION
            stats.m_alsBucketsAvg.m_nContentions     /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nSleeps          /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nContentionSpins /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nAverageSpins    /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nReadLocks       /= m_cActiveBuckets;
            stats.m_alsBucketsAvg.m_nWriteLocks      /= m_cActiveBuckets;
#endif // LOCK_INSTRUMENTATION

        }
        else
        {
            stats.AvgSearchLength  = 0.0;
            stats.ExpSearchLength  = 0.0;
            stats.AvgUSearchLength = 0.0;
            stats.ExpUSearchLength = 0.0;
        }
    }

#ifdef LOCK_INSTRUMENTATION
    stats.m_gls     = TableLock::GlobalStatistics();
    CLockStatistics ls = _LockStats();

    stats.m_alsTable.m_nContentions     = ls.m_nContentions;
    stats.m_alsTable.m_nSleeps          = ls.m_nSleeps;
    stats.m_alsTable.m_nContentionSpins = ls.m_nContentionSpins;
    stats.m_alsTable.m_nAverageSpins    = ls.m_nAverageSpins;
    stats.m_alsTable.m_nReadLocks       = ls.m_nReadLocks;
    stats.m_alsTable.m_nWriteLocks      = ls.m_nWriteLocks;
    stats.m_alsTable.m_nItems           = 1;
#endif // LOCK_INSTRUMENTATION

    return stats;
} // CLKRLinearHashTable::GetStatistics



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetStatistics
// Synopsis: Gather statistics about the table
//------------------------------------------------------------------------

CLKRHashTableStats
CLKRHashTable::GetStatistics() const
{
    CLKRHashTableStats hts;

    if (!IsUsable())
        return hts;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        CLKRHashTableStats stats = m_palhtDir[i]->GetStatistics();

        hts.RecordCount +=      stats.RecordCount;
        hts.TableSize +=        stats.TableSize;
        hts.DirectorySize +=    stats.DirectorySize;
        hts.LongestChain =      max(hts.LongestChain, stats.LongestChain);
        hts.EmptySlots +=       stats.EmptySlots;
        hts.SplitFactor +=      stats.SplitFactor;
        hts.AvgSearchLength +=  stats.AvgSearchLength;
        hts.ExpSearchLength +=  stats.ExpSearchLength;
        hts.AvgUSearchLength += stats.AvgUSearchLength;
        hts.ExpUSearchLength += stats.ExpUSearchLength;
        hts.NodeClumpSize =     stats.NodeClumpSize;
        hts.CBucketSize =       stats.CBucketSize;

        for (int j = 0;  j < CLKRHashTableStats::MAX_BUCKETS;  ++j)
            hts.m_aBucketLenHistogram[j] += stats.m_aBucketLenHistogram[j];

#ifdef LOCK_INSTRUMENTATION
        hts.m_alsTable.m_nContentions     += stats.m_alsTable.m_nContentions;
        hts.m_alsTable.m_nSleeps          += stats.m_alsTable.m_nSleeps;
        hts.m_alsTable.m_nContentionSpins
            += stats.m_alsTable.m_nContentionSpins;
        hts.m_alsTable.m_nAverageSpins    += stats.m_alsTable.m_nAverageSpins;
        hts.m_alsTable.m_nReadLocks       += stats.m_alsTable.m_nReadLocks;
        hts.m_alsTable.m_nWriteLocks      += stats.m_alsTable.m_nWriteLocks;
        
        hts.m_alsBucketsAvg.m_nContentions
            += stats.m_alsBucketsAvg.m_nContentions;
        hts.m_alsBucketsAvg.m_nSleeps
            += stats.m_alsBucketsAvg.m_nSleeps;
        hts.m_alsBucketsAvg.m_nContentionSpins
            += stats.m_alsBucketsAvg.m_nContentionSpins;
        hts.m_alsBucketsAvg.m_nAverageSpins
            += stats.m_alsBucketsAvg.m_nAverageSpins;
        hts.m_alsBucketsAvg.m_nReadLocks
            += stats.m_alsBucketsAvg.m_nReadLocks;
        hts.m_alsBucketsAvg.m_nWriteLocks
            += stats.m_alsBucketsAvg.m_nWriteLocks;
        hts.m_alsBucketsAvg.m_nItems
            += stats.m_alsBucketsAvg.m_nItems;
        
        hts.m_gls = stats.m_gls;
#endif // LOCK_INSTRUMENTATION
    }

    // Average out the subtables statistics.  (Does this make sense
    // for all of these fields?)
    hts.DirectorySize /=    m_cSubTables;
    hts.SplitFactor /=      m_cSubTables;
    hts.AvgSearchLength /=  m_cSubTables;
    hts.ExpSearchLength /=  m_cSubTables;
    hts.AvgUSearchLength /= m_cSubTables;
    hts.ExpUSearchLength /= m_cSubTables;

#ifdef LOCK_INSTRUMENTATION
    hts.m_alsTable.m_nContentions     /= m_cSubTables;
    hts.m_alsTable.m_nSleeps          /= m_cSubTables;
    hts.m_alsTable.m_nContentionSpins /= m_cSubTables;
    hts.m_alsTable.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsTable.m_nReadLocks       /= m_cSubTables;
    hts.m_alsTable.m_nWriteLocks      /= m_cSubTables;
    hts.m_alsTable.m_nItems            = m_cSubTables;

    hts.m_alsBucketsAvg.m_nContentions     /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nSleeps          /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nContentionSpins /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nAverageSpins    /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nReadLocks       /= m_cSubTables;
    hts.m_alsBucketsAvg.m_nWriteLocks      /= m_cSubTables;
#endif // LOCK_INSTRUMENTATION

    return hts;
} // CLKRHashTable::GetStatistics



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SetSegVars
// Synopsis: sets the size-specific segment variables
//-----------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_SetSegVars(
    LK_TABLESIZE lkts,
    DWORD        cInitialBuckets)
{
    switch (lkts)
    {
    case LK_SMALL_TABLESIZE:
      {
        m_lkts      = LK_SMALL_TABLESIZE;
        m_dwSegBits = CSmallSegment::SEGBITS;
        m_dwSegSize = CSmallSegment::SEGSIZE;
        m_dwSegMask = CSmallSegment::SEGMASK;
        STATIC_ASSERT(CSmallSegment::SEGSIZE == (1U<<CSmallSegment::SEGBITS));
        STATIC_ASSERT(CSmallSegment::SEGMASK == (CSmallSegment::SEGSIZE-1));
        break;
      }
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
      {
        m_lkts      = LK_MEDIUM_TABLESIZE;
        m_dwSegBits = CMediumSegment::SEGBITS;
        m_dwSegSize = CMediumSegment::SEGSIZE;
        m_dwSegMask = CMediumSegment::SEGMASK;
        STATIC_ASSERT(CMediumSegment::SEGSIZE ==(1U<<CMediumSegment::SEGBITS));
        STATIC_ASSERT(CMediumSegment::SEGMASK == (CMediumSegment::SEGSIZE-1));
        break;
      }
        
    case LK_LARGE_TABLESIZE:
      {
        m_lkts      = LK_LARGE_TABLESIZE;
        m_dwSegBits = CLargeSegment::SEGBITS;
        m_dwSegSize = CLargeSegment::SEGSIZE;
        m_dwSegMask = CLargeSegment::SEGMASK;
        STATIC_ASSERT(CLargeSegment::SEGSIZE == (1U<<CLargeSegment::SEGBITS));
        STATIC_ASSERT(CLargeSegment::SEGMASK == (CLargeSegment::SEGSIZE-1));
        break;
      }
    }

    m_dwBktAddrMask0 = m_dwSegMask;
    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
    m_nLevel         = m_dwSegBits;
    m_cActiveBuckets = cInitialBuckets;

    IRTLASSERT(m_cActiveBuckets > 0);

    IRTLASSERT(m_nLevel == m_dwSegBits);
    IRTLASSERT(m_dwBktAddrMask0 == (1U << m_nLevel) - 1);
    IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));

    IRTLASSERT(m_dwSegBits > 0);
    IRTLASSERT(m_dwSegSize == (1U << m_dwSegBits));
    IRTLASSERT(m_dwSegMask == (m_dwSegSize - 1));
    IRTLASSERT(m_dwBktAddrMask0 == m_dwSegMask);

    // adjust m_dwBktAddrMask0 (== m_dwSegMask) to make it large
    // enough to distribute the buckets across the address space
    for (DWORD tmp = m_cActiveBuckets >> m_dwSegBits;  tmp > 1;  tmp >>= 1)
    {
        ++m_nLevel;
        m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
    }

    m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;

    IRTLASSERT(_H1(m_cActiveBuckets) == m_cActiveBuckets);
    m_iExpansionIdx = m_cActiveBuckets & m_dwBktAddrMask0;

    // create and clear directory of segments
    DWORD cDirSegs = MIN_DIRSIZE;
    while (cDirSegs < (m_cActiveBuckets >> m_dwSegBits))
        cDirSegs <<= 1;

    cDirSegs = min(cDirSegs, MAX_DIRSIZE);
    IRTLASSERT((cDirSegs << m_dwSegBits) >= m_cActiveBuckets);

    m_lkrcState = LK_ALLOC_FAIL;
    m_paDirSegs = _AllocateSegmentDirectory(cDirSegs);

    if (m_paDirSegs != NULL)
    {
        m_cDirSegs = cDirSegs;
        IRTLASSERT(m_cDirSegs >= MIN_DIRSIZE
                   &&  (m_cDirSegs & (m_cDirSegs-1)) == 0);  // == (1 << N)

        // create and initialize only the required segments
        DWORD dwMaxSegs = (m_cActiveBuckets + m_dwSegSize - 1) >> m_dwSegBits;
        IRTLASSERT(dwMaxSegs <= m_cDirSegs);

        IRTLTRACE(TEXT("InitSegDir: m_lkts = %d, m_cActiveBuckets = %lu, ")
                  TEXT("m_dwSegSize = %lu, bits = %lu\n")
                  TEXT("m_cDirSegs = %lu, dwMaxSegs = %lu, ")
                  TEXT("segment total size = %lu bytes\n"),
                  m_lkts, m_cActiveBuckets,
                  m_dwSegSize, m_dwSegBits,
                  m_cDirSegs, dwMaxSegs,
                  m_dwSegSize * sizeof(CBucket));

        m_lkrcState = LK_SUCCESS; // so IsValid/IsUsable won't fail

        for (DWORD i = 0;  i < dwMaxSegs;  i++)
        {
            CSegment* pSeg = _AllocateSegment();
            if (pSeg != NULL)
                m_paDirSegs[i].m_pseg = pSeg;
            else
            {
                // problem: deallocate everything
                m_lkrcState = LK_ALLOC_FAIL;
                for (DWORD j = i;  j-- > 0;  )
                {
                    _FreeSegment(m_paDirSegs[j].m_pseg);
                    m_paDirSegs[j].m_pseg = NULL;
                }
                _FreeSegmentDirectory();
                break;
            }
        }
    }

    if (m_lkrcState != LK_SUCCESS)
    {
        m_paDirSegs = NULL;
        m_cDirSegs  = m_cActiveBuckets = m_iExpansionIdx = 0;

        // Propagate error back up to parent (if it exists). This ensures
        // that all of the parent's public methods will start failing.
        if (NULL != m_phtParent)
            m_phtParent->m_lkrcState = m_lkrcState;
    }

    return m_lkrcState;
} // CLKRLinearHashTable::_SetSegVars




#include <stdlib.h>

LONG g_cAllocDirEntry = 0;
LONG g_cAllocNodeClump = 0;
LONG g_cAllocSmallSegment = 0;
LONG g_cAllocMediumSegment = 0;
LONG g_cAllocLargeSegment = 0;

extern "C"
__declspec(dllexport)
bool
GetAllocCounters()
{
return true;
}

// #define LKR_RANDOM_MEMORY_FAILURES 1000  // 1..RAND_MAX (32767)

// Memory allocation wrappers to allow us to simulate allocation
// failures during testing

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

CDirEntry* const
CLKRLinearHashTable::_AllocateSegmentDirectory(
    size_t n)
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    // InterlockedIncrement(&g_cAllocDirEntry);

    CDirEntry* const paDirSegs = new CDirEntry [n];

#ifdef IRTLDEBUG
    for (size_t i = 0;  i < n;  ++i)
        IRTLASSERT(paDirSegs[i].m_pseg == NULL);
#endif // IRTLDEBUG

    return paDirSegs;
} // CLKRLinearHashTable::_AllocateSegmentDirectory



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegmentDirectory
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegmentDirectory()
{
#ifdef IRTLDEBUG
    for (size_t i = 0;  i < m_cDirSegs;  ++i)
        IRTLASSERT(m_paDirSegs[i].m_pseg == NULL);
#endif // IRTLDEBUG

    delete [] m_paDirSegs;
    m_paDirSegs = NULL;
    m_cDirSegs = 0;
    return true;
} // CLKRLinearHashTable::_FreeSegmentDirectory



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateNodeClump
// Synopsis: 
//------------------------------------------------------------------------

CNodeClump* const
CLKRLinearHashTable::_AllocateNodeClump()
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    // InterlockedIncrement(&g_cAllocNodeClump);
    return new CNodeClump;
} // CLKRLinearHashTable::_AllocateNodeClump



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeNodeClump
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeNodeClump(
    CNodeClump* pnc)
{
    delete pnc;
    return true;
} // CLKRLinearHashTable::_FreeNodeClump



//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_AllocateSegment
// Synopsis: creates a new segment of the approriate size
// Output:   pointer to the new segment; NULL => failure
//-----------------------------------------------------------------------

CSegment* const
CLKRLinearHashTable::_AllocateSegment(
    ) const
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES

    STATIC_ASSERT(offsetof(CSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CSmallSegment, m_bktSlots2));

    STATIC_ASSERT(offsetof(CSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CMediumSegment, m_bktSlots2));

    STATIC_ASSERT(offsetof(CSegment, m_bktSlots) + sizeof(CBucket)
                  == offsetof(CLargeSegment, m_bktSlots2));

    CSegment* pseg = NULL;

    switch (m_lkts)
    {
    case LK_SMALL_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CSmallSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW
        // InterlockedIncrement(&g_cAllocSmallSegment);
        pseg = new CSmallSegment;
        break;
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CMediumSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW
        // InterlockedIncrement(&g_cAllocMediumSegment);
        pseg = new CMediumSegment;
        break;
        
    case LK_LARGE_TABLESIZE:
#ifdef LKRHASH_ALLOCATOR_NEW
        IRTLASSERT(CLargeSegment::sm_palloc != NULL);
#endif // LKRHASH_ALLOCATOR_NEW
        // InterlockedIncrement(&g_cAllocLargeSegment);
        pseg = new CLargeSegment;
        break;
    }

    IRTLASSERT(pseg != NULL);

    if (pseg != NULL  &&  BucketLock::PerLockSpin() == LOCK_INDIVIDUAL_SPIN)
    {
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
            pseg->Slot(i).SetSpinCount(m_wBucketLockSpins);
    }

    return pseg;
} // CLKRLinearHashTable::_AllocateSegment



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_FreeSegment
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_FreeSegment(
    CSegment* pseg) const
{
    switch (m_lkts)
    {
    case LK_SMALL_TABLESIZE:
        delete static_cast<CSmallSegment*>(pseg);
        break;
        
    default:
        IRTLASSERT(! "Unknown LK_TABLESIZE");
        // fall-through
        
    case LK_MEDIUM_TABLESIZE:
        delete static_cast<CMediumSegment*>(pseg);
        break;
        
    case LK_LARGE_TABLESIZE:
        delete static_cast<CLargeSegment*>(pseg);
        break;
    }

    return true;
} // CLKRLinearHashTable::_FreeSegment



//------------------------------------------------------------------------
// Function: CLKRHashTable::_AllocateSubTableArray
// Synopsis: 
//------------------------------------------------------------------------

CLKRHashTable::SubTable** const
CLKRHashTable::_AllocateSubTableArray(
    size_t n)
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    return new SubTable* [n];
} // CLKRHashTable::_AllocateSubTableArray



//------------------------------------------------------------------------
// Function: CLKRHashTable::_FreeSubTableArray
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::_FreeSubTableArray(
    CLKRHashTable::SubTable** palht)
{
    delete [] palht;
    return true;
} // CLKRHashTable::_FreeSubTableArray



//------------------------------------------------------------------------
// Function: CLKRHashTable::_AllocateSubTable
// Synopsis: 
//------------------------------------------------------------------------

CLKRHashTable::SubTable* const
CLKRHashTable::_AllocateSubTable(
    LPCSTR          pszName,        // An identifier for debugging
    PFnExtractKey   pfnExtractKey,  // Extract key from record
    PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
    PFnEqualKeys    pfnEqualKeys,   // Compare two keys
    PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
    double          maxload,        // Upperbound on average chain length
    DWORD           initsize,       // Initial size of hash table.
    CLKRHashTable*  phtParent,      // Owning table.
    bool            fMultiKeys      // Allow multiple identical keys?
    )
{
#ifdef LKR_RANDOM_MEMORY_FAILURES
    if (rand() < LKR_RANDOM_MEMORY_FAILURES)
        return NULL;
#endif // LKR_RANDOM_MEMORY_FAILURES
    return new SubTable(pszName, pfnExtractKey, pfnCalcKeyHash,
                        pfnEqualKeys,  pfnAddRefRecord,
                        maxload, initsize, phtParent, fMultiKeys);
} // CLKRHashTable::_AllocateSubTable



//------------------------------------------------------------------------
// Function: CLKRHashTable::_FreeSubTable
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::_FreeSubTable(
    CLKRHashTable::SubTable* plht)
{
    delete plht;
    return true;
} // CLKRHashTable::_FreeSubTable




//-----------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Expand
// Synopsis: Expands the table by one bucket. Done by splitting the
//           bucket pointed to by m_iExpansionIdx.
// Output:   LK_SUCCESS, if expansion was successful.
//           LK_ALLOC_FAIL, if expansion failed due to lack of memory.
//-----------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Expand()
{
    if (m_cActiveBuckets >= MAX_DIRSIZE * m_dwSegSize - 1)
        return LK_ALLOC_FAIL;  // table is not allowed to grow any more

    WriteLock();

    // double segment directory size if necessary
    if (m_cActiveBuckets >= m_cDirSegs * m_dwSegSize)
    {
        IRTLASSERT(m_cDirSegs < MAX_DIRSIZE);
        DWORD cDirSegsNew = (m_cDirSegs == 0) ? MIN_DIRSIZE : m_cDirSegs << 1;
        CDirEntry* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < m_cDirSegs;  j++)
            {
                paDirSegsNew[j] = m_paDirSegs[j];
                m_paDirSegs[j].m_pseg = NULL;
            }

            _FreeSegmentDirectory();
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
        else
        {
            WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
    }

    // locate the new bucket, creating a new segment if necessary
    ++m_cActiveBuckets;

    DWORD     dwOldBkt = m_iExpansionIdx;
    DWORD     dwNewBkt = (1 << m_nLevel) | dwOldBkt;

    IRTLASSERT(dwOldBkt < m_cActiveBuckets);
    IRTLASSERT(dwNewBkt < m_cActiveBuckets);

    IRTLASSERT(_Segment(dwOldBkt) != NULL);
    CSegment* psegNew  = _Segment(dwNewBkt);

    if (psegNew == NULL)
    {
        psegNew = _AllocateSegment();
        if (psegNew == NULL)
        {
            --m_cActiveBuckets;
            WriteUnlock();
            return LK_ALLOC_FAIL;  // expansion failed
        }
        _Segment(dwNewBkt) = psegNew;
    }

    // prepare to relocate records to the new bucket
    CBucket* pbktOld = _Bucket(dwOldBkt);
    CBucket* pbktNew = _Bucket(dwNewBkt);

    // get locks on the two buckets involved
    pbktOld->WriteLock();
    pbktNew->WriteLock();

    // Now work out if we need to allocate any extra CNodeClumps.  We do
    // this up front, before calling _SplitRecordSet, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.

    CNodeClump* pncFreeList = NULL;
    LK_RETCODE  lkrc        = LK_SUCCESS;

    // If the old bucket has more than one CNodeClump, there's a chance that
    // we'll need extra CNodeClumps in the new bucket too.  If it doesn't,
    // we definitely won't. One CNodeClump is enough to prime the freelist.
    if (!pbktOld->m_ncFirst.IsLastClump())
    {
        pncFreeList = _AllocateNodeClump();
        if (pncFreeList == NULL)
        {
            lkrc = LK_ALLOC_FAIL;
            --m_cActiveBuckets;
        }
    }

    // adjust expansion pointer, level, and mask
    if (lkrc == LK_SUCCESS)
    {
        if (++m_iExpansionIdx == (1U << m_nLevel))
        {
            ++m_nLevel;
            m_iExpansionIdx = 0;
            m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
            // m_dwBktAddrMask0 = 00011..111
            IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0);
            m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
            IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
        }
    }

    DWORD iExpansionIdx = m_iExpansionIdx;  // save to avoid race conditions
    DWORD dwBktAddrMask = m_dwBktAddrMask0; // ditto

    // Release the table lock before doing the actual relocation
    WriteUnlock();

    if (lkrc == LK_SUCCESS)
    {
        lkrc = _SplitRecordSet(&pbktOld->m_ncFirst, &pbktNew->m_ncFirst,
                               iExpansionIdx, dwBktAddrMask,
                               dwNewBkt, pncFreeList);
    }

    pbktNew->WriteUnlock();
    pbktOld->WriteUnlock();

    return lkrc;
} // CLKRLinearHashTable::_Expand



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_SplitRecordSet
// Synopsis: Split records between the old and new buckets.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_SplitRecordSet(
    CNodeClump* pncOldTarget,
    CNodeClump* pncNewTarget,
    DWORD       iExpansionIdx,
    DWORD       dwBktAddrMask,
    DWORD       dwNewBkt,
    CNodeClump* pncFreeList     // list of free nodes available for reuse
    )
{
    CNodeClump  ncFirst = *pncOldTarget;    // save head of old target chain
    CNodeClump* pncOldList = &ncFirst;
    CNodeClump* pncTmp;
    int         iOldSlot = NODE_BEGIN;
    int         iNewSlot = NODE_BEGIN;

    // clear target buckets
    pncOldTarget->Clear();
    pncNewTarget->Clear();

    // scan through the old bucket chain and decide where to move each record
    while (pncOldList != NULL)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            // node already empty?
            if (pncOldList->IsEmptySlot(i))
            {
                IRTLASSERT(pncOldList->IsEmptyAndInvalid(i));
                continue;
            }

            // calculate bucket address of this node
            DWORD dwBkt = _H0(pncOldList->m_dwKeySigs[i], dwBktAddrMask);
            if (dwBkt < iExpansionIdx)
                dwBkt = _H1(pncOldList->m_dwKeySigs[i], dwBktAddrMask);

            // record to be moved to the new address?
            if (dwBkt == dwNewBkt)
            {
                // node in new bucket chain full?
                if (iNewSlot == NODE_END)
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = NODE_BEGIN;
                }

                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];
                iNewSlot += NODE_STEP;
            }

            // no, record stays in its current bucket chain
            else
            {
                // node in old bucket chain full?
                if (iOldSlot == NODE_END)
                {
                    // the calling routine has passed in a FreeList adequate
                    // for all needs
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncOldTarget->m_pncNext = pncTmp;
                    pncOldTarget = pncTmp;
                    iOldSlot = NODE_BEGIN;
                }

                pncOldTarget->m_dwKeySigs[iOldSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncOldTarget->m_pvNode[iOldSlot]
                    = pncOldList->m_pvNode[i];
                iOldSlot += NODE_STEP;
            }

            // clear old slot
            pncOldList->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
            pncOldList->m_pvNode[i]    = NULL;
        }

        // keep walking down the original bucket chain
        pncTmp     = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // ncFirst is a stack variable, not allocated on the heap
        if (pncTmp != &ncFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef IRTLDEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG
        _FreeNodeClump(pncTmp);
    }

#ifdef IRTLDEBUG
    ncFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

    return LK_SUCCESS;
} // CLKRLinearHashTable::_SplitRecordSet



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Contract
// Synopsis: Contract the table by deleting the last bucket in the active
//           address space. Return the records to the "buddy" of the
//           deleted bucket.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_Contract()
{
    WriteLock();

    IRTLASSERT(m_cActiveBuckets >= m_dwSegSize);

    // Always keep at least m_dwSegSize buckets in the table;
    // i.e., one segment's worth.
    if (m_cActiveBuckets <= m_dwSegSize)
    {
        WriteUnlock();
        return LK_ALLOC_FAIL;
    }

    // update the state variables (expansion ptr, level and mask)
    if (m_iExpansionIdx > 0)
        --m_iExpansionIdx;
    else
    {
        --m_nLevel;
        m_iExpansionIdx = (1 << m_nLevel) - 1;
        IRTLASSERT(m_nLevel > 0  &&  m_iExpansionIdx > 0);
        m_dwBktAddrMask0 >>= 1;
        IRTLASSERT((m_dwBktAddrMask0 & (m_dwBktAddrMask0+1)) == 0); // 00011..111
        m_dwBktAddrMask1 >>= 1;
        IRTLASSERT(m_dwBktAddrMask1 == ((m_dwBktAddrMask0 << 1) | 1));
        IRTLASSERT((m_dwBktAddrMask1 & (m_dwBktAddrMask1+1)) == 0);
    }

    // The last bucket is the one that will be emptied
    CBucket* pbktLast = _Bucket(m_cActiveBuckets - 1);
    pbktLast->WriteLock();

    // Decrement after calculating pbktLast, or _Bucket() will assert.
    --m_cActiveBuckets;

    // Where the nodes from pbktLast will end up
    CBucket* pbktNew = _Bucket(m_iExpansionIdx);
    pbktNew->WriteLock();

    // Now we work out if we need to allocate any extra CNodeClumps.  We do
    // this up front, before calling _MergeRecordSets, as it's hard to
    // gracefully recover from the depths of that routine should we run
    // out of memory.
    
    CNodeClump* pnc;
    int         c = 0;

    // First, count the number of items in the old bucket
    for (pnc = &pbktLast->m_ncFirst;  pnc != NULL;  pnc = pnc->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (!pnc->IsEmptySlot(i))
            {
                IRTLASSERT(!pnc->IsEmptyAndInvalid(i));
                c++;
            }
        }
    }

    // Then, subtract off the number of empty slots in the new bucket
    for (pnc = &pbktNew->m_ncFirst;  pnc != NULL;  pnc = pnc->m_pncNext)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (pnc->IsEmptySlot(i))
            {
                IRTLASSERT(pnc->IsEmptyAndInvalid(i));
                c--;
            }
        }
    }

    CNodeClump* pncFreeList = NULL;  // list of nodes available for reuse
    LK_RETCODE  lkrc        = LK_SUCCESS;

    // Do we need to allocate CNodeClumps to accommodate the surplus items?
    if (c > 0)
    {
        pncFreeList = _AllocateNodeClump();
        if (pncFreeList == NULL)
            lkrc = LK_ALLOC_FAIL;
        else if (c > NODES_PER_CLUMP)
        {
            // In the worst case, we need a 2-element freelist for
            // _MergeRecordSets. Two CNodeClumps always suffice since the
            // freelist will be augmented by the CNodeClumps from the old
            // bucket as they are processed.
            pnc = _AllocateNodeClump();
            if (pnc == NULL)
            {
                _FreeNodeClump(pncFreeList);
                lkrc = LK_ALLOC_FAIL;
            }
            else
                pncFreeList->m_pncNext = pnc;
        }
    }

    // Abort if we couldn't allocate enough CNodeClumps
    if (lkrc != LK_SUCCESS)
    {
        // undo the changes to the state variables
        if (++m_iExpansionIdx == (1U << m_nLevel))
        {
            ++m_nLevel;
            m_iExpansionIdx  = 0;
            m_dwBktAddrMask0 = (m_dwBktAddrMask0 << 1) | 1;
            m_dwBktAddrMask1 = (m_dwBktAddrMask0 << 1) | 1;
        }
        ++m_cActiveBuckets;

        // Unlock the buckets and the table
        pbktLast->WriteUnlock();
        pbktNew->WriteUnlock();
        WriteUnlock();

        return lkrc;
    }

    // Copy the chain of records from pbktLast
    CNodeClump ncOldFirst = pbktLast->m_ncFirst;

    // destroy pbktLast
    pbktLast->m_ncFirst.Clear();
    pbktLast->WriteUnlock();

    // remove segment, if empty
    if (_SegIndex(m_cActiveBuckets) == 0)
    {
#ifdef IRTLDEBUG
        // double-check that the supposedly empty segment is really empty
        IRTLASSERT(_Segment(m_cActiveBuckets) != NULL);
        for (DWORD i = 0;  i < m_dwSegSize;  ++i)
        {
            CBucket* pbkt = &_Segment(m_cActiveBuckets)->Slot(i);
            IRTLASSERT(pbkt->IsWriteUnlocked()  &&  pbkt->IsReadUnlocked());
            IRTLASSERT(pbkt->m_ncFirst.IsLastClump());

            int j;

            FOR_EACH_NODE(j)
            {
                IRTLASSERT(pbkt->m_ncFirst.IsEmptyAndInvalid(j));
            }
        }
#endif // IRTLDEBUG
        _FreeSegment(_Segment(m_cActiveBuckets));
        _Segment(m_cActiveBuckets) = NULL;
    }

    // reduce directory of segments if possible
    if (m_cActiveBuckets <= (m_cDirSegs * m_dwSegSize) >> 1
        &&  m_cDirSegs > MIN_DIRSIZE)
    {
        DWORD cDirSegsNew = m_cDirSegs >> 1;
        CDirEntry* paDirSegsNew = _AllocateSegmentDirectory(cDirSegsNew);

        // Memory allocation failure here does not require us to abort; it
        // just means that the directory of segments is larger than we'd like.
        if (paDirSegsNew != NULL)
        {
            for (DWORD j = 0;  j < cDirSegsNew;  j++)
                paDirSegsNew[j] = m_paDirSegs[j];
            for (j = 0;  j < m_cDirSegs;  j++)
                m_paDirSegs[j].m_pseg = NULL;

            _FreeSegmentDirectory();
            m_paDirSegs = paDirSegsNew;
            m_cDirSegs  = cDirSegsNew;
        }
    }

    // release the table lock before doing the reorg
    WriteUnlock();

    lkrc = _MergeRecordSets(pbktNew, &ncOldFirst, pncFreeList);

    pbktNew->WriteUnlock();

#ifdef IRTLDEBUG
    ncOldFirst.m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG

    return lkrc;
} // CLKRLinearHashTable::_Contract



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_MergeRecordSets
// Synopsis: Merge two record sets.  Copy the contents of pncOldList
//           into pbktNewTarget.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_MergeRecordSets(
    CBucket*    pbktNewTarget,
    CNodeClump* pncOldList,
    CNodeClump* pncFreeList
    )
{
    IRTLASSERT(pbktNewTarget != NULL  &&  pncOldList != NULL);

    CNodeClump*   pncTmp = NULL;
    CNodeClump* const pncOldFirst = pncOldList;
    CNodeClump*   pncNewTarget = &pbktNewTarget->m_ncFirst;
    int           iNewSlot;

    // find the first nodeclump in the new target bucket with an empty slot
    while (!pncNewTarget->IsLastClump())
    {
        FOR_EACH_NODE(iNewSlot)
        {
            if (pncNewTarget->IsEmptySlot(iNewSlot))
                break;
        }

        if (iNewSlot == NODE_END)
            pncNewTarget = pncNewTarget->m_pncNext;
        else
            break;
    }

    IRTLASSERT(pncNewTarget != NULL);

    // find the first empty slot in pncNewTarget;
    // if none, iNewSlot == NODE_END
    FOR_EACH_NODE(iNewSlot)
    {
        if (pncNewTarget->IsEmptySlot(iNewSlot))
        {
            break;
        }
    }
    
    while (pncOldList != NULL)
    {
        int i;

        FOR_EACH_NODE(i)
        {
            if (!pncOldList->IsEmptySlot(i))
            {
                // any empty slots left in pncNewTarget?
                if (iNewSlot == NODE_END)
                {
                    // no, so walk down pncNewTarget until we find another
                    // empty slot
                    while (!pncNewTarget->IsLastClump())
                    {
                        pncNewTarget = pncNewTarget->m_pncNext;

                        FOR_EACH_NODE(iNewSlot)
                        {
                            if (pncNewTarget->IsEmptySlot(iNewSlot))
                                goto found_slot;
                        }
                    }

                    // Oops, reached the last nodeclump in pncNewTarget
                    // and it's full.  Get a new nodeclump off the free
                    // list, which is big enough to handle all needs.
                    IRTLASSERT(pncNewTarget != NULL);
                    IRTLASSERT(pncFreeList != NULL);
                    pncTmp = pncFreeList;
                    pncFreeList = pncFreeList->m_pncNext;
                    pncTmp->Clear();
                    pncNewTarget->m_pncNext = pncTmp;
                    pncNewTarget = pncTmp;
                    iNewSlot = NODE_BEGIN;
                }

              found_slot:
                // We have an empty slot in pncNewTarget
                IRTLASSERT(0 <= iNewSlot  &&  iNewSlot < NODES_PER_CLUMP
                       &&  pncNewTarget != NULL
                       &&  pncNewTarget->IsEmptyAndInvalid(iNewSlot));

                // Let's copy the node from pncOldList
                pncNewTarget->m_dwKeySigs[iNewSlot]
                    = pncOldList->m_dwKeySigs[i];
                pncNewTarget->m_pvNode[iNewSlot]
                    = pncOldList->m_pvNode[i];

                // Clear old slot
                pncOldList->m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
                pncOldList->m_pvNode[i]    = NULL;

                // find the next free slot in pncNewTarget
                while ((iNewSlot += NODE_STEP) != NODE_END)
                {
                    if (pncNewTarget->IsEmptySlot(iNewSlot))
                    {
                        break;
                    }
                }
            }
            else // iNewSlot != NODE_END
            {
                IRTLASSERT(pncOldList->IsEmptyAndInvalid(i));
            }
        }

        // Move into the next nodeclump in pncOldList
        pncTmp = pncOldList;
        pncOldList = pncOldList->m_pncNext;

        // Append to the free list.  Don't put the first node of
        // pncOldList on the free list, as it's a stack variable.
        if (pncTmp != pncOldFirst)
        {
            pncTmp->m_pncNext = pncFreeList;
            pncFreeList = pncTmp;
        }
    }

    // delete any leftover nodes
    while (pncFreeList != NULL)
    {
        pncTmp = pncFreeList;
        pncFreeList = pncFreeList->m_pncNext;
#ifdef IRTLDEBUG
        pncTmp->m_pncNext = NULL; // or ~CNodeClump will ASSERT
#endif // IRTLDEBUG
        _FreeNodeClump(pncTmp);
    }

    return LK_SUCCESS;
} // CLKRLinearHashTable::_MergeRecordSets



#ifdef LKR_DEPRECATED_ITERATORS

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_InitializeIterator
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    if (piter == NULL  ||  piter->m_plht != NULL)
        return LK_BAD_ITERATOR;

    piter->m_plht = this;
    piter->m_dwBucketAddr = 0;

    CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
    IRTLASSERT(pbkt != NULL);
    if (piter->m_lkl == LKL_WRITELOCK)
        pbkt->WriteLock();
    else
        pbkt->ReadLock();

    piter->m_pnc = &pbkt->m_ncFirst;
    piter->m_iNode = NODE_BEGIN - NODE_STEP;

    // Let IncrementIterator do the hard work of finding the first
    // slot in use.
    return IncrementIterator(piter);
} // CLKRLinearHashTable::_InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::InitializeIterator
// Synopsis: make the iterator point to the first record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::InitializeIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
    if (piter == NULL  ||  piter->m_pht != NULL)
        return LK_BAD_ITERATOR;

    // First, lock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        WriteLock();
    else
        ReadLock();

    // Must call IsValid inside a lock to ensure that none of the state
    // variables change while it's being evaluated
    IRTLASSERT(IsValid());
    if (!IsValid())
        return LK_UNUSABLE;

    piter->m_pht  = this;
    piter->m_ist  = -1;
    piter->m_plht = NULL;

    // Let IncrementIterator do the hard work of finding the first
    // valid node in the subtables.
    return IncrementIterator(piter);
} // CLKRHashTable::InitializeIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr < m_cActiveBuckets);
    IRTLASSERT(piter->m_pnc != NULL);
    IRTLASSERT((0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == piter->m_iNode));

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    const void* pvRecord = NULL;

    if (piter->m_iNode != NODE_BEGIN - NODE_STEP)
    {
        // Release the reference acquired in the previous call to
        // IncrementIterator
        pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
        _AddRefRecord(pvRecord, -1);
    }

    do
    {
        do
        {
            // find the next slot in the nodeclump that's in use
            while ((piter->m_iNode += NODE_STEP) != NODE_END)
            {
                pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
                if (pvRecord != NULL)
                {
                    // Add a new reference
                    _AddRefRecord(pvRecord, +1);
                    return LK_SUCCESS;
                }
                else // pvRecord == NULL
                {
#ifdef IRTLDEBUG
                    // Check that all the remaining nodes are empty
                    IRTLASSERT(piter->m_pnc->IsLastClump());
                    for (int i = piter->m_iNode;
                         i != NODE_END;
                         i += NODE_STEP)
                    {
                        IRTLASSERT(piter->m_pnc->IsEmptyAndInvalid(i));
                    }
#endif // IRTLDEBUG
                    break; // rest of nodeclump is empty
                }
            }

            // try the next nodeclump in the bucket chain
            piter->m_iNode = NODE_BEGIN - NODE_STEP;
            piter->m_pnc = piter->m_pnc->m_pncNext;
        } while (piter->m_pnc != NULL);

        // Exhausted this bucket chain.  Unlock it.
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();

        // Try the next bucket, if there is one
        if (++piter->m_dwBucketAddr < m_cActiveBuckets)
        {
            pbkt = _Bucket(piter->m_dwBucketAddr);
            IRTLASSERT(pbkt != NULL);
            if (piter->m_lkl == LKL_WRITELOCK)
                pbkt->WriteLock();
            else
                pbkt->ReadLock();
            piter->m_pnc = &pbkt->m_ncFirst;
        }
    } while (piter->m_dwBucketAddr < m_cActiveBuckets);

    // We have fallen off the end of the hashtable
    piter->m_iNode = NODE_BEGIN - NODE_STEP;
    piter->m_pnc = NULL;

    return LK_NO_MORE_ELEMENTS;
} // CLKRLinearHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::IncrementIterator
// Synopsis: move the iterator on to the next record in the hash table
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::IncrementIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
               &&  piter->m_ist < static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    // Table is already locked
    if (!IsValid())
        return LK_UNUSABLE;

    LK_RETCODE lkrc;
    CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);

    for (;;)
    {
        // Do we have a valid iterator into a subtable?  If not, get one.
        while (piter->m_plht == NULL)
        {
            while (++piter->m_ist < static_cast<int>(m_cSubTables))
            {
                lkrc = m_palhtDir[piter->m_ist]->_InitializeIterator(piter);
                if (lkrc == LK_SUCCESS)
                {
                    IRTLASSERT(m_palhtDir[piter->m_ist] == piter->m_plht);
                    return lkrc;
                }
                else if (lkrc == LK_NO_MORE_ELEMENTS)
                    lkrc = piter->m_plht->_CloseIterator(pBaseIter);

                if (lkrc != LK_SUCCESS)
                    return lkrc;
            }

            // There are no more subtables left.
            return LK_NO_MORE_ELEMENTS;
        }

        // We already have a valid iterator into a subtable.  Increment it.
        lkrc = piter->m_plht->IncrementIterator(pBaseIter);
        if (lkrc == LK_SUCCESS)
            return lkrc;

        // We've exhausted that subtable.  Move on.
        if (lkrc == LK_NO_MORE_ELEMENTS)
            lkrc = piter->m_plht->_CloseIterator(pBaseIter);

        if (lkrc != LK_SUCCESS)
            return lkrc;
    }
} // CLKRHashTable::IncrementIterator



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRLinearHashTable::_CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_plht == this);
    IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
               ?  IsWriteLocked()
               :  IsReadLocked());
    IRTLASSERT(piter->m_dwBucketAddr <= m_cActiveBuckets);
    IRTLASSERT((0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == piter->m_iNode));

    if (piter == NULL  ||  piter->m_plht != this)
        return LK_BAD_ITERATOR;

    // Are we abandoning the iterator before the end of the table?
    // If so, need to unlock the bucket.
    if (piter->m_dwBucketAddr < m_cActiveBuckets)
    {
        CBucket* pbkt = _Bucket(piter->m_dwBucketAddr);
        IRTLASSERT(pbkt != NULL);
        IRTLASSERT(piter->m_lkl == LKL_WRITELOCK
                   ?  pbkt->IsWriteLocked()
                   :  pbkt->IsReadLocked());
        if (0 <= piter->m_iNode  &&  piter->m_iNode < NODES_PER_CLUMP)
        {
            IRTLASSERT(piter->m_pnc != NULL);
            const void* pvRecord = piter->m_pnc->m_pvNode[piter->m_iNode];
            _AddRefRecord(pvRecord, -1);
        }
        if (piter->m_lkl == LKL_WRITELOCK)
            pbkt->WriteUnlock();
        else
            pbkt->ReadUnlock();
    }

    piter->m_plht = NULL;
    piter->m_pnc  = NULL;

    return LK_SUCCESS;
} // CLKRLinearHashTable::_CloseIterator



//------------------------------------------------------------------------
// Function: CLKRHashTable::CloseIterator
// Synopsis: release the resources held by the iterator
//------------------------------------------------------------------------

LK_RETCODE
CLKRHashTable::CloseIterator(
    CIterator* piter)
{
    if (!IsUsable())
        return LK_UNUSABLE;

    IRTLASSERT(piter != NULL);
    IRTLASSERT(piter->m_pht == this);
    IRTLASSERT(-1 <= piter->m_ist
               &&  piter->m_ist <= static_cast<int>(m_cSubTables));

    if (piter == NULL  ||  piter->m_pht != this)
        return LK_BAD_ITERATOR;

    LK_RETCODE lkrc = LK_SUCCESS;

    if (!IsValid())
        lkrc = LK_UNUSABLE;
    else
    {
        // Are we abandoning the iterator before we've reached the end?
        // If so, close the subtable iterator.
        if (piter->m_plht != NULL)
        {
            IRTLASSERT(piter->m_ist < static_cast<int>(m_cSubTables));
            CLHTIterator* pBaseIter = static_cast<CLHTIterator*>(piter);
            piter->m_plht->_CloseIterator(pBaseIter);
        }
    }

    // Unlock all the subtables
    if (piter->m_lkl == LKL_WRITELOCK)
        WriteUnlock();
    else
        ReadUnlock();

    piter->m_plht = NULL;
    piter->m_pht  = NULL;
    piter->m_ist  = -1;

    return lkrc;
} // CLKRHashTable::CloseIterator

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Begin
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

CLKRLinearHashTable::Iterator
CLKRLinearHashTable::Begin()
{
    Iterator iter(this, &_Bucket(0)->m_ncFirst, 0, NODE_BEGIN - NODE_STEP);

    LKR_ITER_TRACE(_TEXT("  LKLH:Begin(it=%p, plht=%p)\n"), &iter, this);
    
    // Let Increment do the hard work of finding the first slot in use.
    iter._Increment(false);

    IRTLASSERT(iter.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(iter == End()  ||  _IsValidIterator(iter));

    return iter;
} // CLKRLinearHashTable::Begin



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable_Iterator::Increment()
// Synopsis: move iterator to next valid record in table
//------------------------------------------------------------------------

bool
CLKRLinearHashTable_Iterator::_Increment(
    bool fDecrementOldValue)
{
    IRTLASSERT(m_plht != NULL);
    IRTLASSERT(m_dwBucketAddr < m_plht->m_cActiveBuckets);
    IRTLASSERT(m_pnc != NULL);
    IRTLASSERT((0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP)
               || (NODE_BEGIN - NODE_STEP == m_iNode));

    // Release the reference acquired in the previous call to _Increment
    if (fDecrementOldValue)
        _AddRef(-1);

    do
    {
        do
        {
            // find the next slot in the nodeclump that's in use
            while ((m_iNode += NODE_STEP) != NODE_END)
            {
                const void* pvRecord = m_pnc->m_pvNode[m_iNode];

                if (pvRecord != NULL)
                {
                    IRTLASSERT(!m_pnc->InvalidSignature(m_iNode));

                    // Add a new reference
                    _AddRef(+1);

                    LKR_ITER_TRACE(_TEXT("  LKLH:++(this=%p, plht=%p, NC=%p, ")
                                   _TEXT("BA=%u, IN=%d, Rec=%p)\n"),
                                   this, m_plht, m_pnc,
                                   m_dwBucketAddr, m_iNode, pvRecord);

                    return true;
                }
                else // pvRecord == NULL
                {
#if 0 //// #ifdef IRTLDEBUG
                    // Check that all the remaining nodes are empty
                    IRTLASSERT(m_pnc->IsLastClump());

                    for (int i = m_iNode;  i != NODE_END;  i += NODE_STEP)
                    {
                        IRTLASSERT(m_pnc->IsEmptyAndInvalid(i));
                    }
#endif // IRTLDEBUG
                    break; // rest of nodeclump is empty
                }
            }

            // try the next nodeclump in the bucket chain
            m_iNode = NODE_BEGIN - NODE_STEP;
            m_pnc = m_pnc->m_pncNext;

        } while (m_pnc != NULL);

        // Try the next bucket, if there is one
        if (++m_dwBucketAddr < m_plht->m_cActiveBuckets)
        {
            CBucket* pbkt = m_plht->_Bucket(m_dwBucketAddr);
            IRTLASSERT(pbkt != NULL);
            m_pnc = &pbkt->m_ncFirst;
        }

    } while (m_dwBucketAddr < m_plht->m_cActiveBuckets);

    // We have fallen off the end of the hashtable. Set iterator equal
    // to end(), the empty iterator.
    LKR_ITER_TRACE(_TEXT("  LKLH:End(this=%p, plht=%p)\n"), this, m_plht);

    m_plht = NULL;
    m_pnc = NULL;
    m_dwBucketAddr = 0;
    m_iNode = 0;

    //// IRTLASSERT(this->operator==(Iterator())); // == end()

    return false;
} // CLKRLinearHashTable_Iterator::_Increment()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Insert
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Insert(
    const void* pvRecord,
    Iterator&   riterResult,
    bool        fOverwrite)
{
    riterResult = End();

    if (!IsUsable()  ||  pvRecord == NULL)
        return false;
    
    bool fSuccess = (_InsertRecord(pvRecord,
                                  _CalcKeyHash(_ExtractKey(pvRecord)),
                                  fOverwrite,
                                  &riterResult)
                     == LK_SUCCESS);

    IRTLASSERT(riterResult.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fSuccess
               ?  _IsValidIterator(riterResult)
               :  riterResult == End());

    return fSuccess;
} // CLKRLinearHashTable::Insert()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::_Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::_Erase(
    Iterator& riter,
    DWORD     dwSignature)
{
    CNodeClump* pncCurr, *pncPrev;
    CBucket* const pbkt = riter.m_plht->_Bucket(riter.m_dwBucketAddr);

    LKR_ITER_TRACE(_TEXT("  LKLH:_Erase:pre(iter=%p, plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc,
                   riter.m_dwBucketAddr, riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);

    pbkt->WriteLock();

    for (pncCurr = &pbkt->m_ncFirst, pncPrev = NULL;
         pncCurr != NULL;
         pncPrev = pncCurr, pncCurr = pncCurr->m_pncNext)
    {
        if (pncCurr == riter.m_pnc)
            break;
    }
    IRTLASSERT(pncCurr != NULL);

    // Release the iterator's reference on the record
    const void* pvRecord = riter.m_pnc->m_pvNode[riter.m_iNode];
    IRTLASSERT(pvRecord != NULL);
    _AddRefRecord(pvRecord, -1);

    // _DeleteNode will leave iterator members pointing to the
    // preceding record
    int iNode = riter.m_iNode;
    IRTLVERIFY(_DeleteNode(pbkt, riter.m_pnc, pncPrev, iNode));

    if (iNode == NODE_END)
    {
        LKR_ITER_TRACE(_TEXT("\t_Erase(BKT=%p, PNC=%p, PREV=%p, INODE=%d)\n"),
                       pbkt, riter.m_pnc, pncPrev, iNode);
    }
                  
    riter.m_iNode = (short) ((iNode == NODE_END)  ? NODE_END-NODE_STEP : iNode);

    pbkt->WriteUnlock();

    // Don't contract the table. Likely to invalidate the iterator,
    // if iterator is being used in a loop

    return true;
} // CLKRLinearHashTable::_Erase()



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Erase(
    Iterator& riter)
{
    if (!IsUsable()  ||  !_IsValidIterator(riter))
        return false;
    
    DWORD dwSignature = _CalcKeyHash(_ExtractKey(riter.Record()));
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:pre(iter=%p, plht=%p, NC=%p, BA=%u, ")
                   _TEXT("IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc, riter.m_dwBucketAddr,
                   riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);
    
    bool fSuccess = _Erase(riter, dwSignature);
    bool fIncrement = false;
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:post(iter=%p, plht=%p, NC=%p, BA=%u, ")
                   _TEXT("IN=%d, Sig=%x, Rec=%p, Success=%s)\n"),
                   &riter, riter.m_plht, riter.m_pnc, riter.m_dwBucketAddr,
                   riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL,
                   (fSuccess ? "true" : "false"));
    
    // _Erase left riter pointing to the preceding record.
    // Move to next record.
    if (fSuccess)
        fIncrement = riter._Increment(false);

    IRTLASSERT(riter.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fIncrement  ?  _IsValidIterator(riter)  :  riter == End());
    
    LKR_ITER_TRACE(_TEXT("  LKLH:Erase:post++(iter=%p, plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_plht, riter.m_pnc,
                   riter.m_dwBucketAddr, riter.m_iNode, dwSignature,
                   riter.m_pnc ? riter.m_pnc->m_pvNode[riter.m_iNode] : NULL);
    
    return fSuccess;
} // CLKRLinearHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Erase
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Erase(
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2(%p, %p)\n"), &riterFirst, &riterLast);

    bool fSuccess;
    int cRecords = 0;

    do
    {
        LKR_ITER_TRACE(_TEXT("\n  LKLH:Erase2(%d, %p)\n"),
                       ++cRecords, &riterFirst);
        fSuccess = Erase(riterFirst);
    } while (fSuccess  &&  riterFirst != End()  &&  riterFirst != riterLast);

    LKR_ITER_TRACE(_TEXT("  LKLH:Erase2: fSuccess = %s\n"),
                   (fSuccess ? "true" : "false"));

    return fSuccess;
} // CLKRLinearHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::Find
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::Find(
    DWORD_PTR pnKey,
    Iterator& riterResult)
{
    riterResult = End();

    if (!IsUsable())
        return false;
    
    const void* pvRecord = NULL;
    DWORD       hash_val = _CalcKeyHash(pnKey);
    bool        fFound   = (_FindKey(pnKey, hash_val, &pvRecord, &riterResult)
                            == LK_SUCCESS);

    IRTLASSERT(fFound
               ?  _IsValidIterator(riterResult)  &&  riterResult.Key() == pnKey
               :  riterResult == End());
    IRTLASSERT(riterResult.m_iNode != NODE_BEGIN - NODE_STEP);

    return fFound;
} // CLKRLinearHashTable::Find



//------------------------------------------------------------------------
// Function: CLKRLinearHashTable::EqualRange
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRLinearHashTable::EqualRange(
    DWORD_PTR pnKey,
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT("  LKLH:EqualRange: Key=%p)\n"), (void*) pnKey);

    riterLast = End();

    bool fFound = Find(pnKey, riterFirst);

    if (fFound)
    {
        riterLast = riterFirst;
        IRTLASSERT(riterLast != End());

        do
        {
            riterLast._Increment();
        } while (riterLast != End()  &&  riterLast.Key() == pnKey);
    }

    IRTLASSERT(riterFirst.m_iNode != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fFound ?  _IsValidIterator(riterFirst) :  riterFirst == End());

    IRTLASSERT(riterLast.m_iNode  != NODE_BEGIN - NODE_STEP);
    IRTLASSERT(fFound  ||  riterLast == End());

    return fFound;
} // CLKRLinearHashTable::EqualRange



//------------------------------------------------------------------------
// Function: CLKRHashTable::Begin
// Synopsis: Make the iterator point to the first record in the hash table.
//------------------------------------------------------------------------

CLKRHashTable::Iterator
CLKRHashTable::Begin()
{
    Iterator iter(this, -1);

    LKR_ITER_TRACE(_TEXT(" LKHT:Begin(it=%p, pht=%p)\n"), &iter, this);

    // Let Increment do the hard work of finding the first slot in use.
    iter._Increment(false);

    IRTLASSERT(iter.m_ist != -1);
    IRTLASSERT(iter == End()  ||  _IsValidIterator(iter));

    return iter;
} // CLKRHashTable::Begin



//------------------------------------------------------------------------
// Function: CLKRHashTable_Iterator::_Increment()
// Synopsis: move iterator to next valid record in table
//------------------------------------------------------------------------

bool
CLKRHashTable_Iterator::_Increment(
    bool fDecrementOldValue)
{
    IRTLASSERT(m_pht != NULL);
    IRTLASSERT(-1 <= m_ist
               &&  m_ist < static_cast<int>(m_pht->m_cSubTables));

    for (;;)
    {
        // Do we have a valid iterator into a subtable?  If not, get one.
        while (m_subiter.m_plht == NULL)
        {
            while (++m_ist < static_cast<int>(m_pht->m_cSubTables))
            {
                LKR_ITER_TRACE(_TEXT(" LKHT:++IST=%d\n"), m_ist);
                m_subiter = m_pht->m_palhtDir[m_ist]->Begin();

                if (m_subiter.m_plht != NULL)
                {
                    LKR_ITER_TRACE(_TEXT(" LKHT:++(this=%p, pht=%p, IST=%d, ")
                                   _TEXT("LHT=%p, NC=%p, ")
                                   _TEXT("BA=%u, IN=%d, Rec=%p)\n"),
                                   this, m_pht, m_ist,
                                   m_subiter.m_plht, m_subiter.m_pnc,
                                   m_subiter.m_dwBucketAddr, m_subiter.m_iNode,
                                   m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode]
                                  );
                    return true;
                }
            }
            
            // There are no more subtables left.
            LKR_ITER_TRACE(_TEXT(" LKHT:End(this=%p, pht=%p)\n"), this, m_pht);

            m_pht = NULL;
            m_ist = 0;

            //// IRTLASSERT(this->operator==(Iterator())); // == end()
            
            return false;
        }

        // We already have a valid iterator into a subtable.  Increment it.
        m_subiter._Increment(fDecrementOldValue);

        if (m_subiter.m_plht != NULL)
        {
            LKR_ITER_TRACE(_TEXT(" LKHT:++(this=%p, pht=%p, IST=%d, ")
                           _TEXT("LHT=%p, NC=%p, BA=%u, IN=%d, Rec=%p)\n"),
                           this, m_pht, m_ist,
                           m_subiter.m_plht, m_subiter.m_pnc,
                           m_subiter.m_dwBucketAddr, m_subiter.m_iNode, 
                           m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode]);
            return true;
        }
    }
} // CLKRHashTable_Iterator::_Increment()



//------------------------------------------------------------------------
// Function: CLKRHashTable::Insert
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRHashTable::Insert(
    const void* pvRecord,
    Iterator&   riterResult,
    bool        fOverwrite)
{
    riterResult = End();

    if (!IsUsable()  ||  pvRecord == NULL)
        return false;
    
    DWORD     hash_val  = _CalcKeyHash(_ExtractKey(pvRecord));
    SubTable* const pst = _SubTable(hash_val);

    bool f = (pst->_InsertRecord(pvRecord, hash_val, fOverwrite,
                                 &riterResult.m_subiter)
              == LK_SUCCESS);

    if (f)
    {
        riterResult.m_pht = this;
        riterResult.m_ist = (short) _SubTableIndex(pst);
    }

    IRTLASSERT(riterResult.m_ist != -1);
    IRTLASSERT(f  ?  _IsValidIterator(riterResult)  :  riterResult == End());

    return f;
} // CLKRHashTable::Insert



//------------------------------------------------------------------------
// Function: CLKRHashTable::Erase
// Synopsis:
//------------------------------------------------------------------------

bool
CLKRHashTable::Erase(
    Iterator& riter)
{
    if (!IsUsable()  ||  !_IsValidIterator(riter))
        return false;
    
    DWORD     dwSignature = _CalcKeyHash(_ExtractKey(riter.Record()));
    SubTable* const pst   = _SubTable(dwSignature);

    IRTLASSERT(pst == riter.m_subiter.m_plht);

    if (pst != riter.m_subiter.m_plht)
        return false;

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:pre(iter=%p, pht=%p, ist=%d, plht=%p, ")
                   _TEXT("NC=%p, BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   (riter.m_subiter.m_pnc ? riter.Record() : NULL));

    // _Erase left riter pointing to the preceding record. Move to
    // next record.
    bool fSuccess = pst->_Erase(riter.m_subiter, dwSignature);
    bool fIncrement = false;

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:post(iter=%p, pht=%p, ist=%d, plht=%p, ")
                   _TEXT("NC=%p, BA=%u, IN=%d, Sig=%x, Rec=%p, Success=%s)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   ((riter.m_subiter.m_pnc && riter.m_subiter.m_iNode >= 0)
                        ? riter.Record() : NULL),
                   (fSuccess ? "true" : "false"));

    if (fSuccess)
        fIncrement = riter._Increment(false);

    IRTLASSERT(riter.m_ist != -1);
    IRTLASSERT(fIncrement  ?  _IsValidIterator(riter)  :  riter  == End());

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase:post++(iter=%p, pht=%p, ist=%d, ")
                   _TEXT("plht=%p, NC=%p, ")
                   _TEXT("BA=%u, IN=%d, Sig=%x, Rec=%p)\n"),
                   &riter, riter.m_pht, riter.m_ist,
                   riter.m_subiter.m_plht, riter.m_subiter.m_pnc,
                   riter.m_subiter.m_dwBucketAddr, riter.m_subiter.m_iNode,
                   dwSignature,
                   (riter.m_subiter.m_pnc ? riter.Record() : NULL));

    return fSuccess;
} // CLKRHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRHashTable::Erase
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::Erase(
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2(%p, %p)\n"), &riterFirst, &riterLast);

    bool fSuccess;
    int cRecords = 0;

    do
    {
        LKR_ITER_TRACE(_TEXT("\n LKHT:Erase2(%d, %p)\n"),
                       ++cRecords, &riterFirst);
        fSuccess = Erase(riterFirst);
    } while (fSuccess  &&  riterFirst != End()  &&  riterFirst != riterLast);

    LKR_ITER_TRACE(_TEXT(" LKHT:Erase2: fSuccess = %s\n"),
                   (fSuccess ? "true" : "false"));

    return fSuccess;
} // CLKRHashTable::Erase



//------------------------------------------------------------------------
// Function: CLKRHashTable::Find
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::Find(
    DWORD_PTR pnKey,
    Iterator& riterResult)
{
    riterResult = End();

    if (!IsUsable())
        return false;
    
    const void* pvRecord = NULL;
    DWORD       hash_val = _CalcKeyHash(pnKey);
    SubTable* const pst  = _SubTable(hash_val);
    bool        fFound   = (pst->_FindKey(pnKey, hash_val, &pvRecord,
                                          &riterResult.m_subiter)
                            == LK_SUCCESS);
    if (fFound)
    {
        riterResult.m_pht = this;
        riterResult.m_ist = (short) _SubTableIndex(pst);
    }

    IRTLASSERT(riterResult.m_ist != -1);
    IRTLASSERT(fFound
               ?  _IsValidIterator(riterResult)  &&  riterResult.Key() == pnKey
               :  riterResult == End());

    return fFound;
} // CLKRHashTable::Find



//------------------------------------------------------------------------
// Function: CLKRHashTable::EqualRange
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::EqualRange(
    DWORD_PTR pnKey,
    Iterator& riterFirst,
    Iterator& riterLast)
{
    LKR_ITER_TRACE(_TEXT(" LKHT:EqualRange: Key=%p)\n"), (void*) pnKey);

    riterLast = End();

    bool fFound = Find(pnKey, riterFirst);

    if (fFound)
    {
        riterLast = riterFirst;
        IRTLASSERT(riterLast != End());

        do
        {
            riterLast._Increment();
        } while (riterLast != End()  &&  riterLast.Key() == pnKey);
    }

    IRTLASSERT(riterFirst.m_ist != -1);
    IRTLASSERT(fFound ? _IsValidIterator(riterFirst) : riterFirst == End());

    IRTLASSERT(riterLast.m_ist != -1);
    IRTLASSERT(fFound  ||  riterLast == End());

    return fFound;
} // CLKRHashTable::EqualRange


#endif // LKR_STL_ITERATORS



//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteLock
// Synopsis: Lock all subtables for writing
//------------------------------------------------------------------------

void
CLKRHashTable::WriteLock()
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->WriteLock();
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
    }
} // CLKRHashTable::WriteLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadLock
// Synopsis: Lock all subtables for reading
//------------------------------------------------------------------------

void
CLKRHashTable::ReadLock() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ReadLock();
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
    }
} // CLKRHashTable::ReadLock



//------------------------------------------------------------------------
// Function: CLKRHashTable::WriteUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::WriteUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
        m_palhtDir[i]->WriteUnlock();
        IRTLASSERT(m_palhtDir[i]->IsWriteUnlocked());
    }
} // CLKRHashTable::WriteUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::ReadUnlock
// Synopsis: Unlock all subtables
//------------------------------------------------------------------------

void
CLKRHashTable::ReadUnlock() const
{
    // unlock in reverse order: LIFO
    for (DWORD i = m_cSubTables;  i-- > 0;  )
    {
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
        m_palhtDir[i]->ReadUnlock();
        IRTLASSERT(m_palhtDir[i]->IsReadUnlocked());
    }
} // CLKRHashTable::ReadUnlock



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteLocked
// Synopsis: Are all subtables write-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fLocked = fLocked && m_palhtDir[i]->IsWriteLocked();
    }
    return fLocked;
} // CLKRHashTable::IsWriteLocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadLocked
// Synopsis: Are all subtables read-locked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadLocked() const
{
    bool fLocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fLocked = fLocked && m_palhtDir[i]->IsReadLocked();
    }
    return fLocked;
} // CLKRHashTable::IsReadLocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsWriteUnlocked
// Synopsis: Are all subtables write-unlocked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsWriteUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsWriteUnlocked();
    }
    return fUnlocked;
} // CLKRHashTable::IsWriteUnlocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsReadUnlocked
// Synopsis: Are all subtables read-unlocked?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsReadUnlocked() const
{
    bool fUnlocked = (m_cSubTables > 0);
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        fUnlocked = fUnlocked && m_palhtDir[i]->IsReadUnlocked();
    }
    return fUnlocked;
} // CLKRHashTable::IsReadUnlocked



//------------------------------------------------------------------------
// Function: CLKRHashTable::ConvertSharedToExclusive
// Synopsis: Convert the read lock to a write lock
//------------------------------------------------------------------------

void
CLKRHashTable::ConvertSharedToExclusive() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ConvertSharedToExclusive();
        IRTLASSERT(m_palhtDir[i]->IsWriteLocked());
    }
} // CLKRHashTable::ConvertSharedToExclusive



//------------------------------------------------------------------------
// Function: CLKRHashTable::ConvertExclusiveToShared
// Synopsis: Convert the write lock to a read lock
//------------------------------------------------------------------------

void
CLKRHashTable::ConvertExclusiveToShared() const
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
    {
        m_palhtDir[i]->ConvertExclusiveToShared();
        IRTLASSERT(m_palhtDir[i]->IsReadLocked());
    }
} // CLKRHashTable::ConvertExclusiveToShared



//------------------------------------------------------------------------
// Function: CLKRHashTable::Size
// Synopsis: Number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::Size() const
{
    DWORD cSize = 0;

    for (DWORD i = 0;  i < m_cSubTables;  i++)
        cSize += m_palhtDir[i]->Size();

    return cSize;
} // CLKRHashTable::Size



//------------------------------------------------------------------------
// Function: CLKRHashTable::MaxSize
// Synopsis: Maximum possible number of elements in the table
//------------------------------------------------------------------------

DWORD
CLKRHashTable::MaxSize() const
{
    return (m_cSubTables == 0)  ? 0  : m_cSubTables * m_palhtDir[0]->MaxSize();
} // CLKRHashTable::MaxSize



//------------------------------------------------------------------------
// Function: CLKRHashTable::IsValid
// Synopsis: is the table valid?
//------------------------------------------------------------------------

bool
CLKRHashTable::IsValid() const
{
    bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
              &&  (m_palhtDir != NULL  &&  m_cSubTables > 0)
              &&  ValidSignature());

    for (DWORD i = 0;  f  &&  i < m_cSubTables;  i++)
        f = f && m_palhtDir[i]->IsValid();

    if (!f)
        m_lkrcState = LK_UNUSABLE;

    return f;
} // CLKRHashTable::IsValid



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRLinearHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    m_wBucketLockSpins = wSpins;

    if (BucketLock::PerLockSpin() != LOCK_INDIVIDUAL_SPIN)
        return;
    
    for (DWORD i = 0;  i < m_cDirSegs;  i++)
    {
        CSegment* pseg = m_paDirSegs[i].m_pseg;

        if (pseg != NULL)
        {
            for (DWORD j = 0;  j < m_dwSegSize;  ++j)
            {
                pseg->Slot(j).SetSpinCount(wSpins);
            }
        }
    }
} // CLKRLinearHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRLinearHashTable::GetBucketLockSpinCount() const
{
    return m_wBucketLockSpins;
} // CLKRLinearHashTable::GetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetTableLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetTableLockSpinCount(wSpins);
} // CLKRHashTable::SetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetTableLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetTableLockSpinCount() const
{
    return ((m_cSubTables == 0)
            ?  (WORD) LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetTableLockSpinCount());
} // CLKRHashTable::GetTableLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::SetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

void
CLKRHashTable::SetBucketLockSpinCount(
    WORD wSpins)
{
    for (DWORD i = 0;  i < m_cSubTables;  i++)
        m_palhtDir[i]->SetBucketLockSpinCount(wSpins);
} // CLKRHashTable::SetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::GetBucketLockSpinCount
// Synopsis: 
//------------------------------------------------------------------------

WORD
CLKRHashTable::GetBucketLockSpinCount() const
{
    return ((m_cSubTables == 0)
            ?  (WORD) LOCK_DEFAULT_SPINS
            :  m_palhtDir[0]->GetBucketLockSpinCount());
} // CLKRHashTable::GetBucketLockSpinCount



//------------------------------------------------------------------------
// Function: CLKRHashTable::MultiKeys
// Synopsis: 
//------------------------------------------------------------------------

bool
CLKRHashTable::MultiKeys() const
{
    return ((m_cSubTables == 0)
            ?  false
            :  m_palhtDir[0]->MultiKeys());
} // CLKRHashTable::MultiKeys



#ifndef __LKRHASH_NO_NAMESPACE__
}
#endif // !__LKRHASH_NO_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\nexusobjects\nexus.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    nexus.cpp
        implement exported functions from this dll


    FILE HISTORY:

*/

#include "precomp.h"

PpNotificationThread    g_NotificationThread;
LONG                    g_bStarted;

//===========================================================================
//
// DllMain 
//    -- dll entry function
//    -- manage creation/deletion of alert object or event log object
//
BOOL WINAPI DllMain(
    HINSTANCE   hinstDLL,   // handle to DLL module
    DWORD       fdwReason,  // reason for calling function
    LPVOID      lpvReserved // reserved
)
{
    switch(fdwReason)
    {
    case DLL_PROCESS_ATTACH:

        g_bStarted = FALSE;

        DisableThreadLibraryCalls(hinstDLL);

        if(!g_pAlert)
        {
            g_pAlert = CreatePassportAlertObject(PassportAlertInterface::EVENT_TYPE);
            if(g_pAlert)
            {
                g_pAlert->initLog(PM_ALERTS_REGISTRY_KEY, EVCAT_NEXUS, NULL, 1);
            }
            else
                _ASSERT(g_pAlert);
        }

        break;

    case DLL_PROCESS_DETACH:

        if (g_pAlert)
        {
            g_pAlert->closeLog();
            delete g_pAlert;
        }

        if(g_bStarted)
        {
            // DARRENAN 4092
            // Remove lines that wait for thread to stop, a 
            // guaranteed deadlock.
         
            g_NotificationThread.stop();
        }

        break;

    default:

        break;
    }

    return TRUE;
}

//===========================================================================
//
// RegisterCCDUpdateNotification 
//    -- set CCD e.g. partner.xml changing notification sink
//
HANDLE WINAPI
RegisterCCDUpdateNotification(
    LPCTSTR pszCCDName,
    ICCDUpdate* piCCDUpdate
    )
{
    HANDLE  hClientHandle;
    HRESULT hr;

    hr = g_NotificationThread.AddCCDClient(tstring(pszCCDName), piCCDUpdate, &hClientHandle);
    if(hr != S_OK)
    {
        hClientHandle = NULL;
    }

    if(!InterlockedExchange(&g_bStarted, TRUE))    
        g_NotificationThread.start();

    return hClientHandle;
}

//===========================================================================
//
// UnregisterCCDUpdateNotification 
//    -- remove CCD e.g. partner.xml changing notification sink
//    
//
BOOL WINAPI
UnregisterCCDUpdateNotification(
    HANDLE hNotificationHandle
    )
{
    return (g_NotificationThread.RemoveClient(hNotificationHandle) == S_OK);
}

//===========================================================================
//
// RegisterConfigChangeNotification 
//    -- set registry setting change sink
//
HANDLE WINAPI
RegisterConfigChangeNotification(
    IConfigurationUpdate* piConfigUpdate
    )
{
    HANDLE  hClientHandle;
    HRESULT hr;

    hr = g_NotificationThread.AddLocalConfigClient(piConfigUpdate, &hClientHandle);
    if(hr != S_OK)
    {
        hClientHandle = NULL;
    }

    if(!InterlockedExchange(&g_bStarted, TRUE))
        g_NotificationThread.start();

    return hClientHandle;
}

//===========================================================================
//
// UnregisterConfigChangeNotification 
//    -- remove registry setting change sink
//
BOOL WINAPI
UnregisterConfigChangeNotification(
    HANDLE hNotificationHandle
    )
{
    return (g_NotificationThread.RemoveClient(hNotificationHandle) == S_OK);
}

//===========================================================================
//
// GetCCD 
//    -- get CCD, returns IXMLDocument object
//    -- bForchFetch : if to fetch from Nexus server or to use local
//
BOOL WINAPI
GetCCD(
    LPCTSTR         pszCCDName,
    IXMLDocument**  ppiXMLDocument,
    BOOL            bForceFetch
    )
{
    return (g_NotificationThread.GetCCD(tstring(pszCCDName), ppiXMLDocument, bForceFetch) == S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\lkrhash\dllmain.cpp ===
/*++

   Copyright    (c)    1998-2002    Microsoft Corporation

   Module  Name :
       DllMain.cpp

   Abstract:
       DLL initialization and termination

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/


#include <precomp.hxx>

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <irtldbg.h>
#include <lkrhash.h>
#include "_locks.h"


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID /*lpReserved*/)
{
    BOOL  fReturn = TRUE;  // ok
    
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hInstance);
        Locks_Initialize();
        IRTL_DEBUG_INIT();
        IRTLTRACE0("LKRhash::DllMain::DLL_PROCESS_ATTACH\n");
        fReturn = LKRHashTableInit();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        IRTLTRACE0("LKRhash::DllMain::DLL_PROCESS_DETACH\n");
        LKRHashTableUninit();
        IRTL_DEBUG_TERM();
        Locks_Cleanup();
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\lkrhash\_locks.h ===
/*++

   Copyright    (c)    1998-2002    Microsoft Corporation

   Module  Name :
       _locks.h

   Abstract:
       Internal locks header file

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/


#define LOCKS_SWITCH_TO_THREAD

extern "C" {

BOOL
Locks_Initialize();

BOOL
Locks_Cleanup();

}; // extern "C"


class CSimpleLock
{
  public:
    CSimpleLock()
        : m_l(0)
    {}

    void Enter()
    {
        while (Lock_AtomicExchange(const_cast<LONG*>(&m_l), 1) != 0)
            Sleep(0);
    }

    void Leave()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_l), 0);
    }

    volatile LONG m_l;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\lkrhash\locks.cpp ===
/*++

   Copyright    (c)    1998-2002    Microsoft Corporation

   Module  Name :
       locks.cpp

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       LKRhash

   Revision History:

--*/


#include "precomp.hxx"

#define DLL_IMPLEMENTATION
#define IMPLEMENTATION_EXPORT
#include <locks.h>
#include "_locks.h"


//------------------------------------------------------------------------
// Not all Win32 platforms support all the functions we want. Set up dummy
// thunks and use GetProcAddress to find their addresses at runtime.

typedef
BOOL
(WINAPI * PFN_SWITCH_TO_THREAD)(
    VOID
    );

static BOOL WINAPI
FakeSwitchToThread(
    VOID)
{
    return FALSE;
}

PFN_SWITCH_TO_THREAD  g_pfnSwitchToThread = NULL;


typedef
BOOL
(WINAPI * PFN_TRY_ENTER_CRITICAL_SECTION)(
    IN OUT LPCRITICAL_SECTION lpCriticalSection
    );

static BOOL WINAPI
FakeTryEnterCriticalSection(
    LPCRITICAL_SECTION /*lpCriticalSection*/)
{
    return FALSE;
}

PFN_TRY_ENTER_CRITICAL_SECTION g_pfnTryEnterCritSec = NULL;


typedef
DWORD
(WINAPI * PFN_SET_CRITICAL_SECTION_SPIN_COUNT)(
    LPCRITICAL_SECTION lpCriticalSection,
    DWORD dwSpinCount
   );

static DWORD WINAPI
FakeSetCriticalSectionSpinCount(
    LPCRITICAL_SECTION /*lpCriticalSection*/,
    DWORD              /*dwSpinCount*/)
{
    // For faked critical sections, the previous spin count is just ZERO!
    return 0;
}

PFN_SET_CRITICAL_SECTION_SPIN_COUNT  g_pfnSetCSSpinCount = NULL;

DWORD g_cProcessors = 0;


BOOL g_fLocksInitialized = FALSE;
CSimpleLock g_lckInit;

BOOL
Locks_Initialize()
{
    if (!g_fLocksInitialized)
    {
        g_lckInit.Enter();
    
        if (!g_fLocksInitialized)
        {
            // load kernel32 and get NT-specific entry points
            HMODULE hKernel32 = GetModuleHandle(TEXT("kernel32.dll"));

            if (hKernel32 != NULL)
            {
                g_pfnSwitchToThread = (PFN_SWITCH_TO_THREAD)
                    GetProcAddress(hKernel32, "SwitchToThread");
                
                g_pfnTryEnterCritSec = (PFN_TRY_ENTER_CRITICAL_SECTION)
                    GetProcAddress(hKernel32, "TryEnterCriticalSection");
                
                g_pfnSetCSSpinCount = (PFN_SET_CRITICAL_SECTION_SPIN_COUNT)
                    GetProcAddress(hKernel32, "SetCriticalSectionSpinCount");
            }
            
            if (g_pfnSwitchToThread == NULL)
                g_pfnSwitchToThread = FakeSwitchToThread;
            
            if (g_pfnTryEnterCritSec == NULL)
                g_pfnTryEnterCritSec = FakeTryEnterCriticalSection;
            
            if (g_pfnSetCSSpinCount == NULL)
                g_pfnSetCSSpinCount = FakeSetCriticalSectionSpinCount;
            
            g_cProcessors = NumProcessors();

            Lock_AtomicExchange((LONG*) &g_fLocksInitialized, TRUE);
        }
        
        g_lckInit.Leave();
    }

    return TRUE;
}


BOOL
Locks_Cleanup()
{
    return TRUE;
}



#ifdef __LOCKS_NAMESPACE__
namespace Locks {
#endif // __LOCKS_NAMESPACE__


#define LOCK_DEFAULT_SPIN_DATA(CLASS)                       \
  WORD   CLASS::sm_wDefaultSpinCount  = LOCK_DEFAULT_SPINS; \
  double CLASS::sm_dblDfltSpinAdjFctr = 0.5


#ifdef LOCK_INSTRUMENTATION

# define LOCK_STATISTICS_DATA(CLASS)            \
LONG        CLASS::sm_cTotalLocks       = 0;    \
LONG        CLASS::sm_cContendedLocks   = 0;    \
LONG        CLASS::sm_nSleeps           = 0;    \
LONGLONG    CLASS::sm_cTotalSpins       = 0;    \
LONG        CLASS::sm_nReadLocks        = 0;    \
LONG        CLASS::sm_nWriteLocks       = 0


# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)            \
CLockStatistics                 CLASS::Statistics() const       \
{return CLockStatistics();}                                     \
CGlobalLockStatistics           CLASS::GlobalStatistics()       \
{return CGlobalLockStatistics();}                               \
void                            CLASS::ResetGlobalStatistics()  \
{}


# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)             \
                                                                \
/* Per-lock statistics */                                       \
CLockStatistics                                                 \
CLASS::Statistics() const                                       \
{                                                               \
    CLockStatistics ls;                                         \
                                                                \
    ls.m_nContentions     = m_nContentions;                     \
    ls.m_nSleeps          = m_nSleeps;                          \
    ls.m_nContentionSpins = m_nContentionSpins;                 \
    if (m_nContentions > 0)                                     \
        ls.m_nAverageSpins = m_nContentionSpins / m_nContentions;\
    else                                                        \
        ls.m_nAverageSpins = 0;                                 \
    ls.m_nReadLocks       = m_nReadLocks;                       \
    ls.m_nWriteLocks      = m_nWriteLocks;                      \
    _tcscpy(ls.m_tszName, m_tszName);                           \
                                                                \
    return ls;                                                  \
}                                                               \
                                                                \
                                                                \
/* Global statistics for CLASS */                               \
CGlobalLockStatistics                                           \
CLASS::GlobalStatistics()                                       \
{                                                               \
    CGlobalLockStatistics gls;                                  \
                                                                \
    gls.m_cTotalLocks      = sm_cTotalLocks;                    \
    gls.m_cContendedLocks  = sm_cContendedLocks;                \
    gls.m_nSleeps          = sm_nSleeps;                        \
    gls.m_cTotalSpins      = sm_cTotalSpins;                    \
    if (sm_cContendedLocks > 0)                                 \
        gls.m_nAverageSpins = static_cast<LONG>(sm_cTotalSpins / \
                                                sm_cContendedLocks);\
    else                                                        \
        gls.m_nAverageSpins = 0;                                \
    gls.m_nReadLocks       = sm_nReadLocks;                     \
    gls.m_nWriteLocks      = sm_nWriteLocks;                    \
                                                                \
    return gls;                                                 \
}                                                               \
                                                                \
                                                                \
/* Reset global statistics for CLASS */                         \
void                                                            \
CLASS::ResetGlobalStatistics()                                  \
{                                                               \
    sm_cTotalLocks       = 0;                                   \
    sm_cContendedLocks   = 0;                                   \
    sm_nSleeps           = 0;                                   \
    sm_cTotalSpins       = 0;                                   \
    sm_nReadLocks        = 0;                                   \
    sm_nWriteLocks       = 0;                                   \
}


// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.
# define LOCK_INSTRUMENTATION_PROLOG()  \
    ++sm_cContendedLocks;               \
    LONG cTotalSpins = 0;               \
    WORD cSleeps = 0

// Don't need InterlockedIncrement or InterlockedExchangeAdd for 
// member variables, as the lock is now locked by this thread.
# define LOCK_INSTRUMENTATION_EPILOG()  \
    ++m_nContentions;                   \
    m_nSleeps += cSleeps;               \
    m_nContentionSpins += cTotalSpins;  \
    sm_nSleeps += cSleeps;              \
    sm_cTotalSpins += cTotalSpins

#else // !LOCK_INSTRUMENTATION
# define LOCK_STATISTICS_DATA(CLASS)
# define LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CLASS)
# define LOCK_STATISTICS_REAL_IMPLEMENTATION(CLASS)
# define LOCK_INSTRUMENTATION_PROLOG()
# define LOCK_INSTRUMENTATION_EPILOG()
#endif // !LOCK_INSTRUMENTATION



//------------------------------------------------------------------------
// Function: RandomBackoffFactor
// Synopsis: A fudge factor to help avoid synchronization problems
//------------------------------------------------------------------------

double
RandomBackoffFactor()
{
    static const double s_aFactors[] = {
        1.020, 0.965,  0.890, 1.065,
        1.025, 1.115,  0.940, 0.995,
        1.050, 1.080,  0.915, 0.980,
        1.010,
    };
    const int nFactors = sizeof(s_aFactors) / sizeof(s_aFactors[0]);

    // Alternatives for nRand include a static counter
    // or the low DWORD of QueryPerformanceCounter().
    DWORD nRand = ::GetCurrentThreadId();

    return s_aFactors[nRand % nFactors];
}


//------------------------------------------------------------------------
// Function: SwitchOrSleep
// Synopsis: If possible, yields the thread with SwitchToThread. If that
//           doesn't work, calls Sleep.
//------------------------------------------------------------------------

void
SwitchOrSleep(
    DWORD dwSleepMSec)
{
#ifdef LOCKS_SWITCH_TO_THREAD
    if (!g_pfnSwitchToThread())
#endif
        Sleep(dwSleepMSec);
}
    



// CSmallSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSmallSpinLock);

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION

LOCK_STATISTICS_DATA(CSmallSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSmallSpinLock);

#endif // LOCK_SMALL_SPIN_INSTRUMENTATION


//------------------------------------------------------------------------
// Function: CSmallSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock.  Blocks until acquired.
//------------------------------------------------------------------------

void
CSmallSpinLock::_LockSpin()
{
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_PROLOG();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
    
    DWORD dwSleepTime = 0;
    LONG  cBaseSpins  = sm_wDefaultSpinCount;
    LONG  cBaseSpins2 = static_cast<LONG>(cBaseSpins * RandomBackoffFactor());

    // This lock cannot be acquired recursively. Attempting to do so will
    // deadlock this thread forever. Use CSpinLock instead if you need that
    // kind of lock.
    if (m_lTid == _CurrentThreadId())
    {
        IRTLASSERT(
           !"CSmallSpinLock: Illegally attempted to acquire lock recursively");
        DebugBreak();
    }

    while (!_TryLock())
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  cBaseSpins != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins2;
        
            // Check no more than cBaseSpins2 times then yield.
            // It is important not to use the InterlockedExchange in the
            // inner loop in order to minimize system memory bus traffic.
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
                    cTotalSpins += cBaseSpins2;
                    ++cSleeps;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
                    SwitchOrSleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins2 = (int) (cBaseSpins2 * sm_dblDfltSpinAdjFctr);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins2 <= LOCK_MAXIMUM_SPINS
                    cBaseSpins2 = min(LOCK_MAXIMUM_SPINS, cBaseSpins2);
                    cBaseSpins2 = max(cBaseSpins2, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins2;

                    // Using Sleep(0) leads to the possibility of priority
                    // inversion.  Sleep(0) only yields the processor if
                    // there's another thread of the same priority that's
                    // ready to run.  If a high-priority thread is trying to
                    // acquire the lock, which is held by a low-priority
                    // thread, then the low-priority thread may never get
                    // scheduled and hence never free the lock.  NT attempts
                    // to avoid priority inversions by temporarily boosting
                    // the priority of low-priority runnable threads, but the
                    // problem can still occur if there's a medium-priority
                    // thread that's always runnable.  If Sleep(1) is used,
                    // then the thread unconditionally yields the CPU.  We
                    // only do this for the second and subsequent even
                    // iterations, since a millisecond is a long time to wait
                    // if the thread can be scheduled in again sooner
                    // (~100,000 instructions).
                    // Avoid priority inversion: 0, 1, 0, 1,...
                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to do the
            // InterlockedExchange to atomically grab it for ourselves.
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
            cTotalSpins += cBaseSpins2 - cSpins;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
        }

        // On a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
            SwitchOrSleep(dwSleepTime);

            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

    }

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_EPILOG();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION
}



// CSpinLock static member variables

LOCK_DEFAULT_SPIN_DATA(CSpinLock);
LOCK_STATISTICS_DATA(CSpinLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CSpinLock);


//------------------------------------------------------------------------
// Function: CSpinLock::_LockSpin
// Synopsis: Acquire an exclusive lock.  Blocks until acquired.
//------------------------------------------------------------------------

void
CSpinLock::_LockSpin()
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime   = 0;
    bool  fAcquiredLock = false;
    LONG  cBaseSpins    = sm_wDefaultSpinCount;

    cBaseSpins = static_cast<LONG>(cBaseSpins * RandomBackoffFactor());

    while (!fAcquiredLock)
    {
        // Only spin on a multiprocessor machine and then only if
        // spinning is enabled
        if (g_cProcessors > 1  &&  sm_wDefaultSpinCount != LOCK_DONT_SPIN)
        {
            LONG cSpins = cBaseSpins;
        
            // Check no more than cBaseSpins times then yield
            while (m_lTid != 0)
            { 
                if (--cSpins < 0)
                { 
#ifdef LOCK_INSTRUMENTATION
                    cTotalSpins += cBaseSpins;
                    ++cSleeps;
#endif // LOCK_INSTRUMENTATION

                    SwitchOrSleep(dwSleepTime) ;

                    // Backoff algorithm: reduce (or increase) busy wait time
                    cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
                    // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
                    cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
                    cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
                    cSpins = cBaseSpins;
            
                    // Avoid priority inversion: 0, 1, 0, 1,...
                    dwSleepTime = !dwSleepTime;
                }
                else
                {
                    Lock_Yield();
                }
            }

            // Lock is now available, but we still need to atomically
            // update m_cOwners and m_nThreadId to grab it for ourselves.
#ifdef LOCK_INSTRUMENTATION
            cTotalSpins += cBaseSpins - cSpins;
#endif // LOCK_INSTRUMENTATION
        }

        // on a 1P machine, busy waiting is a waste of time
        else
        {
#ifdef LOCK_INSTRUMENTATION
            ++cSleeps;
#endif // LOCK_INSTRUMENTATION
            SwitchOrSleep(dwSleepTime);
            
            // Avoid priority inversion: 0, 1, 0, 1,...
            dwSleepTime = !dwSleepTime;
        }

        // Is the lock unowned?
        if (_TryLock())
            fAcquiredLock = true; // got the lock
    }

    IRTLASSERT((m_lTid & OWNER_MASK) > 0
               &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CCritSec static member variables

LOCK_DEFAULT_SPIN_DATA(CCritSec);
LOCK_STATISTICS_DATA(CCritSec);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CCritSec);

bool
CCritSec::TryWriteLock()
{
    IRTLASSERT(g_pfnTryEnterCritSec != NULL);
    return g_pfnTryEnterCritSec(&m_cs) ? true : false;
}

//------------------------------------------------------------------------
// Function: CCritSec::SetSpinCount
// Synopsis: This function is used to call the appropriate underlying
//           functions to set the spin count for the supplied critical
//           section. The original function is supposed to be exported out
//           of kernel32.dll from NT 4.0 SP3. If the func is not available
//           from the dll, we will use a fake function.
//
// Arguments:
//   lpCriticalSection
//      Points to the critical section object.
//
//   dwSpinCount
//      Supplies the spin count for the critical section object. For UP
//      systems, the spin count is ignored and the critical section spin
//      count is set to 0. For MP systems, if contention occurs, instead of
//      waiting on a semaphore associated with the critical section, the
//      calling thread will spin for spin count iterations before doing the
//      hard wait. If the critical section becomes free during the spin, a
//      wait is avoided.
//
// Returns:
//      The previous spin count for the critical section is returned.
//------------------------------------------------------------------------

DWORD
CCritSec::SetSpinCount(
    LPCRITICAL_SECTION pcs,
    DWORD dwSpinCount)
{
    IRTLASSERT(g_pfnSetCSSpinCount != NULL);
    return g_pfnSetCSSpinCount(pcs, dwSpinCount);
}


// CFakeLock static member variables

LOCK_DEFAULT_SPIN_DATA(CFakeLock);
LOCK_STATISTICS_DATA(CFakeLock);
LOCK_STATISTICS_DUMMY_IMPLEMENTATION(CFakeLock);



// CReaderWriterLock static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock);
LOCK_STATISTICS_DATA(CReaderWriterLock);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock);


void
CReaderWriterLock::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock()  :  _TryReadLock();
            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CReaderWriterLock2 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock2);
LOCK_STATISTICS_DATA(CReaderWriterLock2);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock2);


void
CReaderWriterLock2::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(true);
}


void
CReaderWriterLock2::_LockSpin(
    bool fWrite)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock = fWrite  ?  _TryWriteLock(0)  :  _TryReadLock();

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT(fWrite ? IsWriteLocked() : IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



// CReaderWriterLock3 static member variables

LOCK_DEFAULT_SPIN_DATA(CReaderWriterLock3);
LOCK_STATISTICS_DATA(CReaderWriterLock3);
LOCK_STATISTICS_REAL_IMPLEMENTATION(CReaderWriterLock3);


void
CReaderWriterLock3::_WriteLockSpin()
{
    // Add ourselves to the queue of waiting writers
    for (LONG l = m_lRW;  !_CmpExch(l + SL_WRITER_INCR, l);  l = m_lRW)
    {
        Lock_Yield();
    }
    
    _LockSpin(SPIN_WRITE);
}


void
CReaderWriterLock3::_LockSpin(
    SPIN_TYPE st)
{
    LOCK_INSTRUMENTATION_PROLOG();
    
    DWORD dwSleepTime  = 0;
    LONG  cBaseSpins   = static_cast<LONG>(sm_wDefaultSpinCount
                                           * RandomBackoffFactor());
    LONG  cSpins       = cBaseSpins;
    
    for (;;)
    {
        if (g_cProcessors < 2  ||  sm_wDefaultSpinCount == LOCK_DONT_SPIN)
            cSpins = 1; // must loop once to call _TryRWLock

        for (int i = cSpins;  --i >= 0;  )
        {
            bool fLock;

            if (st == SPIN_WRITE)
                fLock = _TryWriteLock(0);
            else if (st == SPIN_READ)
                fLock = _TryReadLock();
            else
            {
                IRTLASSERT(st == SPIN_READ_RECURSIVE);
                fLock = _TryReadLockRecursive();
            }

            if (fLock)
            {
#ifdef LOCK_INSTRUMENTATION
                cTotalSpins += (cSpins - i - 1);
#endif // LOCK_INSTRUMENTATION
                goto locked;
            }
            Lock_Yield();
        }

#ifdef LOCK_INSTRUMENTATION
        cTotalSpins += cBaseSpins;
        ++cSleeps;
#endif // LOCK_INSTRUMENTATION

        SwitchOrSleep(dwSleepTime) ;
        dwSleepTime = !dwSleepTime; // Avoid priority inversion: 0, 1, 0, 1,...
        
        // Backoff algorithm: reduce (or increase) busy wait time
        cBaseSpins = (int) (cBaseSpins * sm_dblDfltSpinAdjFctr);
        // LOCK_MINIMUM_SPINS <= cBaseSpins <= LOCK_MAXIMUM_SPINS
        cBaseSpins = min(LOCK_MAXIMUM_SPINS, cBaseSpins);
        cBaseSpins = max(cBaseSpins, LOCK_MINIMUM_SPINS);
        cSpins = cBaseSpins;
    }

  locked:
    IRTLASSERT((st == SPIN_WRITE)  ?  IsWriteLocked()  :  IsReadLocked());

    LOCK_INSTRUMENTATION_EPILOG();
}



#ifdef __LOCKS_NAMESPACE__
}
#endif // __LOCKS_NAMESPACE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\nexusobjects\ppnexusclient.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    ppnexusclient.cpp
        implement the method for collection nexus settings, and fetch 
        nexus database from internet


    FILE HISTORY:

*/

#include "precomp.h"
#include <comdef.h>
#include <wininet.h>
#include "BinHex.h"
#include "KeyCrypto.h"
#include "BstrDebug.h"

PassportAlertInterface* g_pAlert    = NULL;

//===========================================================================
//
// PpNexusClient 
//    -- load registry nexus settings  
//
PpNexusClient::PpNexusClient()
{
    LocalConfigurationUpdated();
}


//===========================================================================
//
// ReportBadDocument 
//    -- Log event
//    -- called when there is problem parsing the CCD after fetch
//
void
PpNexusClient::ReportBadDocument(
    tstring&    strURL,
    IStream*    piStream
    )
{
    HGLOBAL         hStreamMem;
    VOID*           pStream;
    ULARGE_INTEGER  liStreamSize;
    DWORD           dwOutputSize;
    LARGE_INTEGER   liZero = { 0, 0 };
    LPCTSTR         apszErrors[] = { strURL.c_str() };
    HRESULT         hr;

    piStream->Seek(liZero, STREAM_SEEK_END, &liStreamSize);

    hr = GetHGlobalFromStream(piStream, &hStreamMem);

    if (FAILED(hr))
    {
        return;
    }

    pStream = GlobalLock(hStreamMem);

    dwOutputSize = (80 < liStreamSize.LowPart) ? 80 : liStreamSize.LowPart;

    if(g_pAlert != NULL)
    {
        g_pAlert->report(PassportAlertInterface::ERROR_TYPE, 
                         NEXUS_INVALIDDOCUMENT, 
                         1, 
                         apszErrors, 
                         dwOutputSize, 
                         pStream);
    }

    GlobalUnlock(hStreamMem);
}


//===========================================================================
//
// FetchCCD 
//    -- fetch a CCD e.g. partner.xml from passport nexus server using WinInet API
//    -- trying different approaches 1. direct, 2. proxy, 3. preconfig, 4. no autoproxy
//    -- use XMLDocument object to parse the fetched file
//
HRESULT
PpNexusClient::FetchCCD(
    tstring&  strURL,
    IXMLDocument**  ppiXMLDocument
    )
{
    HRESULT                 hr;
    HINTERNET               hNexusSession = NULL, hNexusFile = NULL;
    DWORD                   dwBytesRead;
    DWORD                   dwStatusLen;
    DWORD                   dwStatus;
    tstring                 strAuthHeader;
    tstring                 strFullURL;
    CHAR                    achReadBuf[4096];
    TCHAR                   achAfter[64];
    LARGE_INTEGER           liZero = { 0,0 };
    IStreamPtr              xmlStream;
    IPersistStreamInitPtr   xmlPSI;
	UINT                    uiConnectionTypes[4];
	
    USES_CONVERSION;

    achAfter[0] = 0;

    if(ppiXMLDocument == NULL)
    {
        hr = E_INVALIDARG;        
        goto Cleanup;
    }

    *ppiXMLDocument = NULL;

	// This array will contains connection methods for WinInet in the order 
	// we will attempt them.   I am opting for this method instead of just trying
	// the PRECONFIG option as this will cause no change to existing customers who 
	// have no problems so far.
	uiConnectionTypes[0] = INTERNET_OPEN_TYPE_DIRECT;       //This was the original way of doing things
	uiConnectionTypes[1] = INTERNET_OPEN_TYPE_PRECONFIG;    //This pulls proxy info from the registry
    uiConnectionTypes[2] = INTERNET_OPEN_TYPE_PROXY;   
    uiConnectionTypes[3] = INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY;    

	// Loop through the array...
	for (UINT i = 0; i < sizeof(uiConnectionTypes)/sizeof(UINT); i++)
	{
	    if(hNexusSession)
	        InternetCloseHandle(hNexusSession);

        hNexusSession = InternetOpenA(
	                        "Passport Nexus Client", //BUGBUG  Should we just put in IE4's user agent?
	                        uiConnectionTypes[i],    //Use the connection type
	                        NULL,
	                        NULL,
	                        0);
	    if(hNexusSession == NULL)
	    {
	        hr = GetLastError();
	        lstrcpy(achAfter, TEXT("InternetOpen"));
	        goto Cleanup;
	    }

	    //  Get the document
	    strFullURL = strURL;
	    strFullURL += m_strParam;

	    if(hNexusFile)
	        InternetCloseHandle(hNexusFile);

        {  // make it a local scope, the alloca will be freed
	        hNexusFile = InternetOpenUrlA(
	                        hNexusSession,
	                        W2A(const_cast<TCHAR*>(strFullURL.c_str())),
	                        W2A(const_cast<TCHAR*>(m_strAuthHeader.c_str())),
	                        -1,
	                        INTERNET_FLAG_SECURE | INTERNET_FLAG_RELOAD | INTERNET_FLAG_DONT_CACHE,
	                        0);
        }
		// If the file was opened the we hop out of the loop and process it.  If there is
		// and error, we keep looping.  If there is an error on the last run through the loop,
		// it will be handled after the exit of the loop.
	    if (hNexusFile != NULL)
	    	break;
	    	
	}

	// If hNexusFile is NULL when it exits the loop, we process that error.
    if(hNexusFile == NULL)
    {
        hr = GetLastError();
        if(hr == ERROR_INTERNET_SECURITY_CHANNEL_ERROR)
        {
            dwStatusLen = sizeof(HRESULT);
            InternetQueryOption(NULL, INTERNET_OPTION_EXTENDED_ERROR, &hr, &dwStatusLen);
        }

        lstrcpy(achAfter, TEXT("InternetOpenURL"));
        goto Cleanup;
    }
	
    //  Check the status code.
    dwStatusLen = sizeof(DWORD);
    if(!HttpQueryInfoA(hNexusFile,
                       HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                       &dwStatus,
                       &dwStatusLen,
                       NULL))
    {
        hr = GetLastError();
        lstrcpy(achAfter, TEXT("HttpQueryInfo"));
        goto Cleanup;
    }

    if(dwStatus != 200)
    {
        _ultoa(dwStatus, achReadBuf, 10);
        lstrcatA(achReadBuf, " ");

        dwStatusLen = sizeof(achReadBuf) - lstrlenA(achReadBuf);
        HttpQueryInfoA(hNexusFile,
                       HTTP_QUERY_STATUS_TEXT,
                       (LPTSTR)&(achReadBuf[lstrlenA(achReadBuf)]),
                       &dwStatusLen,
                       NULL);

        if(g_pAlert != NULL)
        {
            LPCTSTR apszStrings[] = { strURL.c_str(), A2W(achReadBuf) };

            g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                             NEXUS_ERRORSTATUS,
                             2,
                             apszStrings,
                             0,
                             NULL
                             );
        }

        lstrcpy(achAfter, TEXT("InternetOpenURL"));
        hr = dwStatus;
        goto Cleanup;
    }

    hr = CreateStreamOnHGlobal(NULL, TRUE, &xmlStream);
    if(hr != S_OK)
    {
        lstrcpy(achAfter, TEXT("CreateStreamOnHGlobal"));
        goto Cleanup;
    }

    while(TRUE)
    {
        if(!InternetReadFile(hNexusFile, achReadBuf, sizeof(achReadBuf), &dwBytesRead))
        {
            hr = GetLastError();
            lstrcpy(achAfter, TEXT("InternetReadFile"));
            goto Cleanup;
        }

        if(dwBytesRead == 0)
            break;

        hr = xmlStream->Write(achReadBuf, dwBytesRead, NULL);
        if(hr != S_OK)
        {
            lstrcpy(achAfter, TEXT("IStream::Write"));
            goto Cleanup;
        }
    }

    hr = xmlStream->Seek(liZero, STREAM_SEEK_SET, NULL);
    if(hr != S_OK)
    {
        lstrcpy(achAfter, TEXT("IStream::Seek"));
        goto Cleanup;
    }

    //
    //  Now create an XML object and initialize it using the stream.
    //

    hr = CoCreateInstance(__uuidof(XMLDocument), NULL, CLSCTX_ALL, IID_IPersistStreamInit, (void**)&xmlPSI);
    if(hr != S_OK)
    {
        lstrcpy(achAfter, TEXT("CoCreateInstance"));
        goto Cleanup;
    }

    hr = xmlPSI->Load((IStream*)xmlStream);
    if(hr != S_OK)
    {
        ReportBadDocument(strFullURL, xmlStream);
        lstrcpy(achAfter, TEXT("IPersistStreamInit::Load"));
        goto Cleanup;
    }

    hr = xmlPSI->QueryInterface(__uuidof(IXMLDocument), (void**)ppiXMLDocument);
    lstrcpy(achAfter, TEXT("QueryInterface(IID_IXMLDocument)"));

Cleanup:

    //
    //  Catch-all event for a fetch failure.
    //

    if(hr != S_OK && g_pAlert != NULL)
    {
        TCHAR   achErrBuf[1024];
        LPCTSTR apszStrings[] = { strURL.c_str(), achErrBuf };
        LPVOID  lpMsgBuf = NULL;
        ULONG   cchTmp;

        FormatMessage( 
                     FORMAT_MESSAGE_ALLOCATE_BUFFER |
                     FORMAT_MESSAGE_FROM_SYSTEM | 
                     FORMAT_MESSAGE_IGNORE_INSERTS |
                     FORMAT_MESSAGE_FROM_HMODULE |
                     FORMAT_MESSAGE_MAX_WIDTH_MASK,
                     GetModuleHandle(TEXT("wininet.dll")),
                     hr,
                     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                     (LPTSTR) &lpMsgBuf,
                     0,
                     NULL);

        lstrcpy(achErrBuf, TEXT("0x"));
        _ultot(hr, &(achErrBuf[2]), 16);
        achErrBuf[sizeof(achErrBuf) / sizeof(achErrBuf[0]) - 1] = TEXT('\0');
        if(lpMsgBuf != NULL && *(LPTSTR)lpMsgBuf != TEXT('\0'))
        {
            cchTmp = _tcslen(achErrBuf) + 1;
            _tcsncat(achErrBuf, TEXT(" ("), (sizeof(achErrBuf) / sizeof(achErrBuf[0])) - cchTmp);
            _tcsncat(achErrBuf, (LPTSTR)lpMsgBuf, (sizeof(achErrBuf) / sizeof(achErrBuf[0])) - (cchTmp + 2));
            cchTmp = _tcslen(achErrBuf) + 1;
            _tcsncat(achErrBuf, TEXT(") "), (sizeof(achErrBuf) / sizeof(achErrBuf[0])) - cchTmp);
        }

        if(achAfter[0])
        {
            cchTmp = _tcslen(achErrBuf) + 1;
            _tcsncat(achErrBuf, TEXT(" after a call to "), (sizeof(achErrBuf) / sizeof(achErrBuf[0])) - cchTmp);
            _tcsncat(achErrBuf, achAfter, (sizeof(achErrBuf) / sizeof(achErrBuf[0])) - (cchTmp + 17));
            cchTmp = _tcslen(achErrBuf) + 1;
            _tcsncat(achErrBuf, TEXT("."), (sizeof(achErrBuf) / sizeof(achErrBuf[0])) - cchTmp);
        }


        g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                         NEXUS_FETCHFAILED,
                         2,
                         apszStrings,
                         0,
                         NULL
                         );

        LocalFree(lpMsgBuf);
    }
    else if(g_pAlert != NULL)
    {
        // Emit success event.

        g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                         NEXUS_FETCHSUCCEEDED,
                         strURL.c_str());
    }

    if(hNexusFile != NULL)
        InternetCloseHandle(hNexusFile);
    if(hNexusSession != NULL)
        InternetCloseHandle(hNexusSession);

    return hr;
}

//===========================================================================
//
// LocalConfigurationUpdated 
//    -- Sink for Local registry setting change notification
//    -- Load nexus settings from registry
//    -- it's called once at start up as well
//
void
PpNexusClient::LocalConfigurationUpdated()
{
    LONG            lResult;
    TCHAR           rgchUsername[128];
    TCHAR           rgchPassword[128];
    DWORD           dwBufLen;
    DWORD           dwSiteId;
    CRegKey         NexusRegKey;
    CRegKey         PassportRegKey;
    BSTR            bstrEncodedCreds = NULL;
    CKeyCrypto      kc;
    CBinHex         bh;
    DATA_BLOB       iBlob;
    DATA_BLOB       oBlob = {0};
    LONG            cCreds;
    LPSTR           pszCreds = NULL;

    USES_CONVERSION;

    lResult = PassportRegKey.Open(HKEY_LOCAL_MACHINE,
                                  TEXT("Software\\Microsoft\\Passport"),
                                  KEY_READ);
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;

    lResult = PassportRegKey.QueryDWORDValue(TEXT("SiteId"),
                                        dwSiteId);
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;

    _ultot(dwSiteId, rgchUsername, 10);
    m_strParam = TEXT("?id=");
    m_strParam += rgchUsername;

    lResult = NexusRegKey.Open(HKEY_LOCAL_MACHINE,
                     TEXT("Software\\Microsoft\\Passport\\Nexus"),
                     KEY_READ);
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;

    dwBufLen = sizeof(rgchUsername)/sizeof(rgchUsername[0]);
    lResult = NexusRegKey.QueryStringValue(TEXT("CCDUsername"),
                                     rgchUsername,
                                     &dwBufLen);
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;

    dwBufLen = sizeof(rgchPassword);
    lResult = RegQueryValueEx(NexusRegKey, TEXT("CCDPassword"), NULL,
               NULL, (LPBYTE)rgchPassword, &dwBufLen);
    if(lResult != ERROR_SUCCESS)
        goto Cleanup;

    iBlob.cbData = dwBufLen;
    iBlob.pbData = (PBYTE)rgchPassword;

    if (kc.decryptKey(&iBlob, &oBlob) != S_OK)
    {
        if(g_pAlert != NULL)
            g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                             PM_CANT_DECRYPT_CONFIG);

        goto Cleanup;
    }

    //
    // convert the CCD username to multi byte and then concatenate the password to the result
    // need enough memory for username + ':' + password + NULL char
    cCreds = ((wcslen(rgchUsername) + 1) * 2) + 1 + oBlob.cbData;
    pszCreds = (LPSTR)LocalAlloc(LMEM_FIXED, cCreds);
    if (NULL == pszCreds)
    {
        goto Cleanup;
    }

    if (0 == WideCharToMultiByte(CP_ACP, 0, rgchUsername, -1, pszCreds, (wcslen(rgchUsername) + 1) * 2, NULL, NULL))
    {
        goto Cleanup;
    }
    cCreds = strlen(pszCreds);
    pszCreds[cCreds] = ':';
    CopyMemory(pszCreds + cCreds + 1, oBlob.pbData, oBlob.cbData);
    pszCreds[cCreds + 1 + oBlob.cbData] = '\0';


    // base 64 encode the password, so it may be used with the HTML request
    if (S_OK != bh.ToBase64(pszCreds,
                            strlen(pszCreds),
                            NULL,         //prepend - this is used by CCoCrypto, not needed here
                            NULL,         //IV - this is used by CCoCrypto, not needed here
                            &bstrEncodedCreds))
    {
        if(g_pAlert != NULL)
            g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                             PM_CANT_DECRYPT_CONFIG);
        goto Cleanup;
    }

    m_strAuthHeader =  TEXT("Authorization: Basic ");
    m_strAuthHeader += bstrEncodedCreds;

Cleanup:
    if (NULL != pszCreds)
    {
        LocalFree(pszCreds);
    }

    if(lResult != ERROR_SUCCESS)
    {
        //BUGBUG  Throw an exception and an NT Event here.
    }

    if (NULL != bstrEncodedCreds)
    {
        FREE_BSTR(bstrEncodedCreds);
    }

    if (oBlob.pbData)
      ::LocalFree(oBlob.pbData);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\nexusobjects\ppnexusclient.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    ppnexusclient.h
        implement the method for collection nexus settings, and fetch 
        nexus database from internet


    FILE HISTORY:

*/

#ifndef __PPNEXUSCLIENT_H
#define __PPNEXUSCLIENT_H

#include <msxml.h>
#include "tstring"

#include "nexus.h"

class PpNexusClient : public IConfigurationUpdate
{
public:
    PpNexusClient();

    HRESULT FetchCCD(tstring& strURL, IXMLDocument** ppiXMLDocument);

    void LocalConfigurationUpdated(void);

private:

    void ReportBadDocument(tstring& strURL, IStream* piStream);

    tstring m_strAuthHeader;
    tstring m_strParam;
};

#endif // __PPNEXUSCLIENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\nexusobjects\precomp.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    precomp.cpp


    FILE HISTORY:

*/
#include "precomp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\nexusobjects\ppshadowdocument.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    ppshadowdocument.h


    FILE HISTORY:

*/
#ifndef __PPSHADOWDOCUMENT_H
#define __PPSHADOWDOCUMENT_H

#include <msxml.h>

#include "tstring"

using namespace std;

// 
//
// shadowdocument manages a shadow local CCD
//
//
class PpShadowDocument
{
public:

    PpShadowDocument();
    PpShadowDocument(tstring& strURL);
    PpShadowDocument(tstring& strURL, tstring& strLocalFile);

    void SetURL(tstring& strURL);
    void SetLocalFile(tstring& strLocalFile);

    HRESULT GetDocument(IXMLDocument** ppiXMLDocument, BOOL bForceFetch = TRUE);

private:

    BOOL IsValidCCD(IXMLDocument* piXMLDocument);
    BOOL NoPersist(IXMLDocument* piXMLDocument);

    HRESULT SaveDocument(IXMLDocument* piXMLDocument);
    HRESULT LoadDocument(IXMLDocument** ppiXMLDocument);

    tstring m_strURL;
    tstring m_strLocalFile;
    bool    m_bFailing;
};

#endif // __PPSHADOWDOCUMENT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\nexusobjects\ppnotificationthread.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    ppnotificationthread.cpp
        implement the methods runing a separte thread watching for registry
        changes, and timer for CCD refresh


    FILE HISTORY:

*/
#include "precomp.h"

PassportLockedInteger PpNotificationThread::m_NextHandle;

//
//  Constructor
//

PpNotificationThread::PpNotificationThread()
{
    LocalConfigurationUpdated();

    AddLocalConfigClient(dynamic_cast<IConfigurationUpdate*>(this), NULL);
}

//
//  Destructor
//


PpNotificationThread::~PpNotificationThread()
{
}

//
//  Add a CCD client to the notification list.
//

HRESULT
PpNotificationThread::AddCCDClient(
    tstring& strCCDName,
    ICCDUpdate* piUpdate,
    HANDLE* phClientHandle)
{
    HRESULT hr;
    NOTIFICATION_CLIENT clientInfo;

    try
    {
        clientInfo.dwNotificationType = NOTIF_CCD;
        clientInfo.NotificationInterface.piCCDUpdate = piUpdate;
        clientInfo.strCCDName = strCCDName;
        clientInfo.hClientHandle = (HANDLE)(LONG_PTR)(++m_NextHandle);

        {
            PassportGuard<PassportLock> guard(m_ClientListLock);
            m_ClientList.push_back(clientInfo);
        }

        if(phClientHandle != NULL)
        {
            *phClientHandle = clientInfo.hClientHandle;
        }

        hr = S_OK;
    }
    catch(...)
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//
//  Add a configuration client to the notification list
//

HRESULT
PpNotificationThread::AddLocalConfigClient(
    IConfigurationUpdate* piUpdate,
    HANDLE* phClientHandle)
{
    HRESULT hr;
    NOTIFICATION_CLIENT clientInfo;

    clientInfo.dwNotificationType = NOTIF_CONFIG;
    clientInfo.NotificationInterface.piConfigUpdate = piUpdate;
    clientInfo.hClientHandle = (HANDLE)(LONG_PTR)(++m_NextHandle);

    {
        PassportGuard<PassportLock> guard(m_ClientListLock);
        try
        {
            m_ClientList.push_back(clientInfo);
        }
        catch(...)
        {
            hr = E_OUTOFMEMORY;
            goto Ret;
        }
    }

    if(phClientHandle != NULL)
    {
        *phClientHandle = clientInfo.hClientHandle;
    }

    hr = S_OK;
Ret:
    return hr;
}

//
//  Remove a client (either type) from the notification list.
//

HRESULT
PpNotificationThread::RemoveClient(
    HANDLE hClientHandle)
{
    HRESULT hr;
    PassportGuard<PassportLock> guard(m_ClientListLock);

    for(CLIENT_LIST::iterator it = m_ClientList.begin(); it != m_ClientList.end(); it++)
    {
        if((*it).hClientHandle == hClientHandle)
        {
            m_ClientList.erase(it);
            hr = S_OK;
            goto Cleanup;
        }
    }

    hr = E_FAIL;

Cleanup:

    return hr;
}

//
//  Do a manual refresh of a CCD.
//

HRESULT
PpNotificationThread::GetCCD(
    tstring&        strCCDName,
    IXMLDocument**  ppiXMLDocument,
    BOOL            bForceFetch)
{
    HRESULT                 hr;
    PpShadowDocument*       pShadowDoc;
    CCD_INFO                ccdInfo;

    {
        PassportGuard<PassportLock> guard(m_CCDInfoLock);

        //  Get the CCD Information for the requested CCD
        if(!GetCCDInfo(strCCDName, ccdInfo))
        {
            hr = E_INVALIDARG;
            pShadowDoc = NULL;
            goto Cleanup;
        }

        //  Create a new shadow document for the CCD
        if(ccdInfo.strCCDLocalFile.empty())
            pShadowDoc = new PpShadowDocument(ccdInfo.strCCDURL);
        else
            pShadowDoc = new PpShadowDocument(ccdInfo.strCCDURL, ccdInfo.strCCDLocalFile);
    }

    if(!pShadowDoc)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    //  Do the update.
    hr = pShadowDoc->GetDocument(ppiXMLDocument, bForceFetch);

    //BUGBUG  This is weird because currently other clients of this CCD will NOT get
    //        notified.  I don't want to loop through the notification list here for
    //        two reasons:
    //
    //        1.  The caller might be in the notification list and I don't to notify
    //            unnecessarily.
    //        2.  Don't want to put the overhead of notifying all clients on the
    //            caller's thread.
    //
    //        The ideal solution would be to wake up our dedicated thread and have it
    //        do the notification.  I haven't been able to find a way to signal a
    //        waitable time though.

Cleanup:

    if(pShadowDoc != NULL)
        delete pShadowDoc;

    return hr;
}

//
//
// register configure change notification
// register CCD update timeer
// call client notification sink
//
//
void
PpNotificationThread::run(void)
{
    {
        HANDLE*         pHandleArray    = NULL;
        LONG            lResult;
        PassportEvent   RegChangeEvent(FALSE,FALSE);
        DWORD           dwCurCCDInfo;
        DWORD           dwCurArrayLen;
        DWORD           dwWaitResult;
        DWORD           dwError;
        CCD_INFO_LIST::iterator it;
        CRegKey         PassportKey;
        BOOL            bKeyOpened;
        HRESULT         hr;
    
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
        _ASSERT(hr != S_FALSE);
    
        lResult = PassportKey.Open(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Passport"), KEY_NOTIFY);
        bKeyOpened = (lResult == ERROR_SUCCESS);
    
        m_StartupThread.Set();
    
        while(WaitForSingleObject(m_ShutdownThread, 0) != WAIT_OBJECT_0)
        {
            if(bKeyOpened)
            {
                lResult = RegNotifyChangeKeyValue((HKEY)PassportKey, TRUE,
                                                  REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                                                  (HANDLE)RegChangeEvent,
                                                  TRUE);
                if(lResult != ERROR_SUCCESS)
                    dwError = GetLastError();
            }
    
            {
                PassportGuard<PassportLock> guard(m_CCDInfoLock);
    
                dwCurArrayLen = m_aciCCDInfoList.size() + 2;
    
                pHandleArray = new HANDLE[dwCurArrayLen];
                if(pHandleArray == NULL)
                {
                    //  BUGBUG  Throw a low-memory alert here?
                    continue;
                }
    
                pHandleArray[0] = (HANDLE)m_ShutdownThread; //  Handle 0 always contains the thread shutdown signal.
                pHandleArray[1] = (HANDLE)RegChangeEvent; //  Handle 1 always contains the registry change event.
    
                for(it = m_aciCCDInfoList.begin(), dwCurCCDInfo = 0; it != m_aciCCDInfoList.end(); it++, dwCurCCDInfo++)
                {
                    pHandleArray[dwCurCCDInfo + 2] = (*it).hCCDTimer;
                }
            }
    
            dwWaitResult = WaitForMultipleObjects(dwCurArrayLen,
                                                  pHandleArray,
                                                  FALSE,
                                                  INFINITE);
            switch(dwWaitResult)
            {
            case WAIT_FAILED:
    
                dwError = GetLastError();
    
                break;
    
            //  Thread shutdown has been signalled.  Exit this thread.
            case WAIT_OBJECT_0:
                goto Cleanup;
    
            //  Registry change has been signalled.  Notify all local config clients.
            case WAIT_OBJECT_0 + 1:
    
                {
                    PassportGuard<PassportLock> guard(m_ClientListLock);
    
                    CLIENT_LIST::iterator cl_iter;
                    for(cl_iter = m_ClientList.begin(); cl_iter != m_ClientList.end(); cl_iter++)
                    {
                        if((*cl_iter).dwNotificationType == NOTIF_CONFIG)
                        {
                            (*cl_iter).NotificationInterface.piConfigUpdate->LocalConfigurationUpdated();
                        }
                    }
                }
    
                break;
    
            //  One of the CCD timers has been signalled.  Read the CCD and notify all CCD clients.
            default:
    
                {
                    IXMLDocumentPtr     xmlDoc;
                    PpShadowDocument    ShadowDoc;
                    DWORD               dwInfoIndex = dwWaitResult - WAIT_OBJECT_0 - 2;
    
                    //
                    // Due to the ugly nature of the code an allocation can fail within a constructor
                    // and cause AVs in this code.  So unfortunately we'll wrap this code to
                    // account for that.
                    //
                    try
                    {
                        m_CCDInfoLock.acquire();
                        CCD_INFO_LIST   aciTempCCDInfoList(m_aciCCDInfoList);
                        m_CCDInfoLock.release();
    
                        m_aciCCDInfoList[dwInfoIndex].SetTimer();
    
                         //  Fetch the CCD
                        ShadowDoc.SetURL(aciTempCCDInfoList[dwInfoIndex].strCCDURL);
                        if(!aciTempCCDInfoList[dwInfoIndex].strCCDLocalFile.empty())
                            ShadowDoc.SetLocalFile(aciTempCCDInfoList[dwInfoIndex].strCCDLocalFile);
    
                        if(ShadowDoc.GetDocument(&xmlDoc) == S_OK)
                        {
                            PassportGuard<PassportLock> guard(m_ClientListLock);
    
                            LPCTSTR pszUpdatedName = aciTempCCDInfoList[dwInfoIndex].strCCDName.c_str();
    
                            //  Loop through client list and call any clients registered for the CCD that
                            //  changed.
                            CLIENT_LIST::iterator cl_iter;
                            for(cl_iter = m_ClientList.begin(); cl_iter != m_ClientList.end(); cl_iter++)
                            {
                                if(lstrcmpi(pszUpdatedName, (*cl_iter).strCCDName.c_str()) == 0)
                                {
                                    (*cl_iter).NotificationInterface.piCCDUpdate->CCDUpdated(
                                                pszUpdatedName,
                                                (IXMLDocument*)xmlDoc);
                                }
                            }
                        }
                    }
                    catch(...)
                    {
                        if (g_pAlert)
                        {
                            g_pAlert->report(PassportAlertInterface::ERROR_TYPE, PM_CCD_NOT_LOADED, 0);
                        }
                    }
                }
    
                break;
    
            }
    
            delete [] pHandleArray;
            pHandleArray = NULL;
        }
    
    Cleanup:
    
        if(pHandleArray != NULL)
            delete [] pHandleArray;
    
        CoUninitialize();
    }
    m_ShutdownAck.Set();
}

//
//  Update our configuration.  This is called from the constructor, and
//  from the notification thread whenever the registry changes.
//

void
PpNotificationThread::LocalConfigurationUpdated()
{
    CRegKey NexusRegKey;
    LONG    lResult;
    DWORD   dwIndex;
    DWORD   dwNameLen;
    DWORD   dwDefaultRefreshInterval;
    TCHAR   achNameBuf[64];

    lResult = NexusRegKey.Open(HKEY_LOCAL_MACHINE,
                               TEXT("Software\\Microsoft\\Passport\\Nexus"),
                               KEY_READ);
    if(lResult != ERROR_SUCCESS)
    {
        //BUGBUG  This is a required reg key, throw an event.
        return;
    }

    //  Get the default refresh interval.
    lResult = NexusRegKey.QueryDWORDValue(TEXT("CCDRefreshInterval"), dwDefaultRefreshInterval);
    if(lResult != ERROR_SUCCESS)
    {
        //BUGBUG  This is a required reg value, throw an event.
        return;
    }

    //
    //  Lock down the list.
    //

    {
        PassportGuard<PassportLock> guard(m_CCDInfoLock);

        //
        //  Loop through existing list and remove any items whose corresponding keys
        //  have been removed.
        //

        CCD_INFO_LIST::iterator it;
        for(it = m_aciCCDInfoList.begin(); it != m_aciCCDInfoList.end(); )
        {
            CRegKey CCDRegKey;

            lResult = CCDRegKey.Open((HKEY)NexusRegKey, (*it).strCCDName.c_str(), KEY_READ);
            if(lResult != ERROR_SUCCESS)
            {
                it = m_aciCCDInfoList.erase(it);
            }
            else
                it++;
        }

        //
        //  Loop through each subkey and add/update the CCD info therein.
        //

        dwIndex = 0;
        dwNameLen = sizeof(achNameBuf) / sizeof(achNameBuf[0]);

        while(RegEnumKeyEx((HKEY)NexusRegKey, dwIndex,achNameBuf, &dwNameLen, NULL, NULL, NULL, NULL ) == ERROR_SUCCESS)
        {
            CRegKey CCDRegKey;

            lResult = CCDRegKey.Open((HKEY)NexusRegKey, achNameBuf, KEY_READ);
            if(lResult == ERROR_SUCCESS)
            {
                ReadCCDInfo(tstring(achNameBuf), dwDefaultRefreshInterval, CCDRegKey);
            }

            dwIndex++;
            dwNameLen = sizeof(achNameBuf);
        }
    }
}

//
//  This method starts the thread and then wait for the thread to get going.
//

bool
PpNotificationThread::start(void)
{
    m_StartupThread.Reset();

    bool bReturn = PassportThread::start();

    //
    //  Now wait for the thread to start.
    //

    WaitForSingleObject((HANDLE)m_StartupThread, INFINITE);
    return bReturn;
}

//
//  This method just signals the shutdown event causing the thread to terminate immediately.
//

void
PpNotificationThread::stop(void)
{
    m_ShutdownThread.Set();
    WaitForSingleObject(m_ShutdownAck, 1000);
    //  give it a chance to terminate
    Sleep(20);
}

//
//  Private method for reading the CCD info for a single CCD subkey from
//  the registry.
//

BOOL
PpNotificationThread::ReadCCDInfo(
    tstring&    strCCDName,
    DWORD       dwDefaultRefreshInterval,
    CRegKey&    CCDRegKey
    )
{
    BOOL                    bReturn = TRUE;
    LONG                    lResult;
    DWORD                   dwBufLen = 0;
    DWORD                   dwType;
    CCD_INFO_LIST::iterator it;
    LPTSTR                  pszRemoteFile = NULL;
    LPTSTR                  pszLocalFile = TEXT("");
    BOOL                    fLocalFileAllocated = FALSE;
    DWORD                   dwCCDRefreshInterval;
    LPTSTR                  pszTempFile = NULL;

    //
    //  Read in the remote path to the CCD.
    //  CCDRemoteFile is the only required value.  If it's not there, return FALSE.
    //

    lResult = CCDRegKey.QueryStringValue(TEXT("CCDRemoteFile"), NULL, &dwBufLen);
    if(lResult == ERROR_SUCCESS)
    {
        pszRemoteFile = (LPTSTR)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, dwBufLen * sizeof(TCHAR));
        if (NULL == pszRemoteFile)
        {
            bReturn = FALSE;
            goto Cleanup;
        }

        CCDRegKey.QueryStringValue(TEXT("CCDRemoteFile"), pszRemoteFile, &dwBufLen);
        while(*pszRemoteFile && _istspace(*pszRemoteFile))
            pszRemoteFile++;
    }
    else
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    //
    //  Read in the refresh interval for this CCD.
    //

    lResult = CCDRegKey.QueryDWORDValue(TEXT("CCDRefreshInterval"), dwCCDRefreshInterval);
    if(lResult != ERROR_SUCCESS)
        dwCCDRefreshInterval = 0xFFFFFFFF;

    //
    //  Read in local (backup) path for the CCD.  This is an optional value.  Use
    //  empty string (initialized above) as the default.
    //

    lResult = CCDRegKey.QueryValue(TEXT("CCDLocalFile"), &dwType, NULL, &dwBufLen);

    if(lResult == ERROR_SUCCESS)
    {
        if (dwType == REG_EXPAND_SZ)
        {
            pszTempFile = (LPTSTR) LocalAlloc(LMEM_FIXED, dwBufLen);

            if (pszTempFile)
            {
                lResult = CCDRegKey.QueryValue(TEXT("CCDLocalFile"), &dwType, pszTempFile, &dwBufLen);

                if (lResult == ERROR_SUCCESS)
                {
                    //
                    //  Expand out the environment variable
                    //

                    TCHAR tszTemp;

                    dwBufLen = ExpandEnvironmentStrings(pszTempFile, &tszTemp, 1);

                    if (dwBufLen > 1)
                    {
                        DWORD dwChars;

                        pszLocalFile = (LPTSTR)LocalAlloc(LMEM_FIXED, dwBufLen * sizeof(TCHAR));
                        if (NULL == pszLocalFile)
                        {
                            bReturn = FALSE;
                            goto Cleanup;
                        }
                        else
                        {
                            fLocalFileAllocated = TRUE;
                        }

                        dwChars = ExpandEnvironmentStrings(pszTempFile, pszLocalFile, dwBufLen);

                        if (dwChars > dwBufLen)
                        {
                            LocalFree(pszLocalFile);
                            fLocalFileAllocated = FALSE;
                            pszLocalFile = TEXT("");
                        }

                        while(*pszLocalFile && _istspace(*pszLocalFile)) pszLocalFile++;
                    }
                }
           }
        }
        else if (dwType == REG_SZ)
        {
            pszLocalFile = (LPTSTR)LocalAlloc(LMEM_FIXED, dwBufLen * sizeof(TCHAR));
            if (NULL == pszLocalFile)
            {
                bReturn = FALSE;
                goto Cleanup;
            }
            else
            {
                fLocalFileAllocated = TRUE;
            }

            if (CCDRegKey.QueryValue(TEXT("CCDLocalFile"), &dwType, pszLocalFile, &dwBufLen) != ERROR_SUCCESS)
            {
                LocalFree(pszLocalFile);
                fLocalFileAllocated = FALSE;
                pszLocalFile = TEXT("");
            }

            while(*pszLocalFile && _istspace(*pszLocalFile)) pszLocalFile++;
        }
    }

    //
    //  If this CCD is already in the list, then update it.
    //

    for(it = m_aciCCDInfoList.begin(); it != m_aciCCDInfoList.end(); it++)
    {
        if(lstrcmp((*it).strCCDName.c_str(), strCCDName.c_str()) == 0)
        {
            //  Check to see if the information has changed.
            if(lstrcmpi(pszRemoteFile, (*it).strCCDURL.c_str()) != 0 ||
               lstrcmpi(pszLocalFile,  (*it).strCCDLocalFile.c_str()) != 0 ||
               dwCCDRefreshInterval != (*it).dwCCDRefreshInterval ||
               dwDefaultRefreshInterval != (*it).dwDefaultRefreshInterval
              )
            {
                DWORD   dwOldRefreshInterval = ((*it).dwCCDRefreshInterval == 0xFFFFFFFF ?
                                                (*it).dwDefaultRefreshInterval :
                                                (*it).dwCCDRefreshInterval);
                DWORD   dwNewRefreshInterval = (dwCCDRefreshInterval == 0xFFFFFFFF ?
                                                dwDefaultRefreshInterval :
                                                dwCCDRefreshInterval);

                (*it).strCCDURL                 = pszRemoteFile;
                (*it).strCCDLocalFile           = pszLocalFile;
                (*it).dwCCDRefreshInterval      = dwCCDRefreshInterval;
                (*it).dwDefaultRefreshInterval  = dwDefaultRefreshInterval;

                if(dwOldRefreshInterval != dwNewRefreshInterval)
                    (*it).SetTimer();
            }

            break;
        }
    }

    //
    //  This is a new CCD, add it to the list.
    //

    if(it == m_aciCCDInfoList.end())
    {
        CCD_INFO ccdInfo;

        ccdInfo.strCCDName                  = strCCDName;
        ccdInfo.strCCDURL                   = pszRemoteFile;
        ccdInfo.strCCDLocalFile             = pszLocalFile;
        ccdInfo.dwCCDRefreshInterval        = dwCCDRefreshInterval;
        ccdInfo.dwDefaultRefreshInterval    = dwDefaultRefreshInterval;

        ccdInfo.SetTimer();

        try
        {
            m_aciCCDInfoList.push_back(ccdInfo);
        }
        catch(...)
        {
            bReturn = FALSE;
            goto Cleanup;
        }
    }

    bReturn = TRUE;

Cleanup:
    if (pszTempFile)
    {
        LocalFree(pszTempFile);
    }

    if (pszRemoteFile)
    {
        LocalFree(pszRemoteFile);
    }

    if (fLocalFileAllocated  && pszLocalFile)
    {
        LocalFree(pszLocalFile);
    }

    return bReturn;
}

//
//  Private method for retrieving a CCD_INFO structure given the CCD name.
//

BOOL
PpNotificationThread::GetCCDInfo(
    tstring&    strCCDName,
    CCD_INFO&   ccdInfo
    )
{
    CCD_INFO_LIST::iterator     it;

    for(it = m_aciCCDInfoList.begin(); it != m_aciCCDInfoList.end(); it++)
    {
        if(lstrcmpi((*it).strCCDName.c_str(), strCCDName.c_str()) == 0)
        {
            ccdInfo = (*it);
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\nexusobjects\ppnotificationthread.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    ppnotificationthread.h
        implement the methods runing a separte thread watching for registry
        changes, and timer for CCD refresh


    FILE HISTORY:

*/
#ifndef __PPNOTIFICATIONTHREAD_H
#define __PPNOTIFICATIONTHREAD_H

#include <windows.h>
#include <winbase.h>
#include <atlbase.h>
#include <msxml.h>
#include "tstring"
#include <vector>

using namespace std;

#include "PassportThread.hpp"
#include "PassportLock.hpp"
#include "PassportEvent.hpp"
#include "PassportLockedInteger.hpp"
#include "nexus.h"

// Notification types used in structure below
#define NOTIF_CONFIG 1
#define NOTIF_CCD    2

//////////////////////////////////////////////////////////////////////////
//
// NOTIFICATION_CLIENT -- notification client
//
//
typedef struct
{
    DWORD dwNotificationType;
    union
    {
        IConfigurationUpdate*   piConfigUpdate;
        ICCDUpdate*             piCCDUpdate;
    } NotificationInterface;
    tstring strCCDName; // Will be empty for config notif types
    HANDLE hClientHandle;
}
NOTIFICATION_CLIENT;

typedef vector<NOTIFICATION_CLIENT> CLIENT_LIST;

//////////////////////////////////////////////////////////////////////////
//
// CCD_INFO -- CCD timer element
//
//
class CCD_INFO
{
public:
    tstring strCCDName;
    tstring strCCDURL;
    tstring strCCDLocalFile;
    DWORD   dwCCDRefreshInterval;
    DWORD   dwDefaultRefreshInterval;
    HANDLE  hCCDTimer;

    CCD_INFO()
    {
        strCCDName              = TEXT("");
        strCCDURL               = TEXT("");
        strCCDLocalFile         = TEXT("");
        dwCCDRefreshInterval    = 0;
        dwDefaultRefreshInterval= 0;
        hCCDTimer               = CreateWaitableTimer(NULL, TRUE, NULL);
    };

    CCD_INFO(const CCD_INFO& ci)
    {
        strCCDName              = ci.strCCDName;
        strCCDURL               = ci.strCCDURL;
        strCCDLocalFile         = ci.strCCDLocalFile;
        dwCCDRefreshInterval    = ci.dwCCDRefreshInterval;
        dwDefaultRefreshInterval= ci.dwDefaultRefreshInterval;

        HANDLE hProcess = GetCurrentProcess();
        DuplicateHandle(hProcess,
                        ci.hCCDTimer,
                        hProcess,
                        &hCCDTimer, 0, FALSE, DUPLICATE_SAME_ACCESS);
    };

    ~CCD_INFO()
    {
        CloseHandle(hCCDTimer);
    }

    const CCD_INFO&
    operator = (const CCD_INFO& ci)
    {
        strCCDName              = ci.strCCDName;
        strCCDURL               = ci.strCCDURL;
        strCCDLocalFile         = ci.strCCDLocalFile;
        dwCCDRefreshInterval    = ci.dwCCDRefreshInterval;
        dwDefaultRefreshInterval= ci.dwDefaultRefreshInterval;

        CloseHandle(hCCDTimer);

        HANDLE hProcess = GetCurrentProcess();
        DuplicateHandle(hProcess,
                        ci.hCCDTimer,
                        hProcess,
                        &hCCDTimer, 0, FALSE, DUPLICATE_SAME_ACCESS);

        return ci;
    }

    BOOL SetTimer(DWORD dwOneTimeRefreshInterval = 0xFFFFFFFF)
    {
        //  Reset the timer.
        LARGE_INTEGER   liDueTime;
        DWORD           dwError;
        DWORD           dwRefreshInterval = (dwOneTimeRefreshInterval != 0xFFFFFFFF ?
                                                dwOneTimeRefreshInterval :
                                                (dwCCDRefreshInterval != 0xFFFFFFFF ?
                                                 dwCCDRefreshInterval :
                                                 dwDefaultRefreshInterval
                                                )
                                            );

        liDueTime.QuadPart = -((LONGLONG)(dwRefreshInterval) * 10000000);

        if(!SetWaitableTimer(hCCDTimer, &liDueTime, 0, NULL, NULL, FALSE))
        {
            dwError = GetLastError();
            return FALSE;
        }

        return TRUE;
    }
};

typedef vector<CCD_INFO> CCD_INFO_LIST;

//////////////////////////////////////////////////////////////////////////
//
// PpNotificationThread -- notification thread
//
//
class PpNotificationThread : public PassportThread, public IConfigurationUpdate
{
public:

    PpNotificationThread();
    ~PpNotificationThread();

    HRESULT AddCCDClient(tstring& strCCDName, ICCDUpdate* piUpdate, HANDLE* phClientHandle);
    HRESULT AddLocalConfigClient(IConfigurationUpdate* piUpdate, HANDLE* phClientHandle);
    HRESULT RemoveClient(HANDLE hClientHandle);
    HRESULT GetCCD(tstring& strCCDName, IXMLDocument** ppiStream, BOOL bForceFetch = TRUE);

    void run(void);

    void LocalConfigurationUpdated(void);

    void stop(void);

    bool start(void);

private:
    static PassportLockedInteger m_NextHandle;

    //  Private methods.
    BOOL    GetCCDInfo(tstring& strCCDName, CCD_INFO& ccdInfo);
    BOOL    ReadCCDInfo(tstring& strCCDName, DWORD dwDefaultRefreshInterval, CRegKey& CCDRegKey);

    //  Private data
    CLIENT_LIST             m_ClientList;
    PassportLock            m_ClientListLock;

    CCD_INFO_LIST           m_aciCCDInfoList;
    PassportLock            m_CCDInfoLock;
    PassportEvent           m_StartupThread;
    PassportEvent           m_ShutdownThread;
    PassportEvent           m_ShutdownAck;
};

#endif // __PPNOTIFICATIONTHREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\nexusobjects\ppshadowdocument.cpp ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    ppshadowdocument.cpp
        manages a local shadow of the CCD

    FILE HISTORY:

*/
#include "precomp.h"

//===========================================================================
//
// PpShadowDocument 
//
PpShadowDocument::PpShadowDocument()
{
}

//===========================================================================
//
// PpShadowDocument 
//
PpShadowDocument::PpShadowDocument(
    tstring& strURL) : m_strURL(strURL)
{
}

//===========================================================================
//
// PpShadowDocument 
//
PpShadowDocument::PpShadowDocument(
    tstring& strURL, 
    tstring& strLocalFile) : m_strURL(strURL), m_strLocalFile(strLocalFile)
{
}

//===========================================================================
//
// SetURL -- URL 
//
void
PpShadowDocument::SetURL(
    tstring& strURL)
{
    m_strURL = strURL;
}

//===========================================================================
//
// SetLocalFile -- localfile name 
//
void
PpShadowDocument::SetLocalFile(
    tstring& strLocalFile)
{
    m_strLocalFile = strLocalFile;
}

//===========================================================================
//
// GetDocument -- get CCDs DOM interface
//    -- bForceFetch : force an HTTPs, otherwise using local shadow
//
HRESULT
PpShadowDocument::GetDocument(
    IXMLDocument**  ppiXMLDocument,
    BOOL            bForceFetch
    )
{
    HRESULT                 hr;
    PpNexusClient           nexusClient;
    IPersistStreamInitPtr   xmlStream;
    IXMLDocumentPtr         xmlDoc;

    if(ppiXMLDocument == NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppiXMLDocument = NULL;

    if(bForceFetch)
    {
        //  Fetch the XML document

        if(!m_strURL.empty())
            hr = nexusClient.FetchCCD(m_strURL, ppiXMLDocument);
        else
        {
            tstring strMsg;
            if(!m_strLocalFile.empty())
            {
                strMsg = TEXT("for ");
                strMsg += m_strLocalFile;
            }

            if (NULL != g_pAlert)
            {
                g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                                 NEXUS_EMPTYREMOTENAME,
                                 strMsg.c_str()
                                 );
            }
            hr = S_FALSE;
        }

        if(m_strLocalFile.empty())
        {
            tstring strMsg;
            if(!m_strURL.empty())
            {
                strMsg = TEXT("for ");
                strMsg += m_strURL;
            }

            if (NULL != g_pAlert)
            {
                g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                                 NEXUS_EMPTYLOCALNAME,
                                 strMsg.c_str()
                                 );
            }
            goto Cleanup;
        }

        //  If FetchCCD failed and a local file is configured, read from the file.
        //  If FetchCCD succeeded and a local file is configured, write to the file.

        if(hr == S_OK)
        {
            if(!NoPersist(*ppiXMLDocument))
                SaveDocument(*ppiXMLDocument);
            else
            {
                if (NULL != g_pAlert)
                {
                    g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                                     NEXUS_NOTPERSISTING,
                                     m_strURL.c_str());
                }
            }
        }
        else
        {
            // use new hr variable, not to eat the global one
            HRESULT hr1 = LoadDocument(ppiXMLDocument);

            if (NULL != g_pAlert)
            {
                if (hr1 != S_OK)
                    g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                                     NEXUS_LOADFAILED,
                                     m_strLocalFile.c_str());
                else
                    g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                                     NEXUS_USINGLOCAL,
                                     m_strLocalFile.c_str());
            }
        }
    }
    else
    {
        if(!m_strLocalFile.empty())
        {
            hr = LoadDocument(ppiXMLDocument);
            if(hr == S_OK)
			{
				//  If the file is still valid, then return.
				if(IsValidCCD(*ppiXMLDocument))
                {
                    if (NULL != g_pAlert)
                    {
                        g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                                         NEXUS_USINGLOCAL,
                                         m_strLocalFile.c_str());
                    }
					goto Cleanup;
                }
			}
            else
            {
                if (NULL != g_pAlert)
                {
                    g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                                     NEXUS_LOADFAILED,
                                     m_strLocalFile.c_str());
                }
            }
        }
        else
        {
            tstring strMsg;
            if(!m_strURL.empty())
            {
                strMsg = TEXT("for ");
                strMsg += m_strURL;
            }

            if (NULL != g_pAlert)
            {
                g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                                 NEXUS_EMPTYLOCALNAME,
                                 strMsg.c_str()
                                 );
            }
        }

        //  At this point, we're in one of two states:
        //  1.  *ppiXMLDocument is NULL
        //  2.  *ppiXMLDocument is not NULL, but points to a document that is old

        //  Fetch the XML document, if successful release the document loaded from
        //  disk (if any).

        if(!m_strURL.empty())
            hr = nexusClient.FetchCCD(m_strURL, &xmlDoc);
        else
        {
            tstring strMsg;
            if(!m_strLocalFile.empty())
            {
                strMsg = TEXT("for ");
                strMsg += m_strLocalFile;
            }

            if (NULL != g_pAlert)
            {
                g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                                 NEXUS_EMPTYREMOTENAME,
                                 strMsg.c_str()
                                 );
            }
            hr = S_FALSE;
        }

        if(hr == S_OK)
        {
            if(*ppiXMLDocument) (*ppiXMLDocument)->Release();
            xmlDoc->QueryInterface(IID_IXMLDocument, (void**)ppiXMLDocument);

            //  If FetchCCD succeeded and a local file is configured, write to the file.
            if(!m_strLocalFile.empty())
            {
                if(!NoPersist(*ppiXMLDocument))
                {
                    HANDLE hToken = NULL;
                    //
                    // In certain configurations this code can be run while impersonating a user who
                    // does not have access to the directory to store the partner2.xml.  Therefore 
                    // we revert to self prior to attempting to save the document.
                    //
                    if (OpenThreadToken(GetCurrentThread(),
                                        MAXIMUM_ALLOWED,
                                        TRUE,
                                        &hToken))
                    {
                        RevertToSelf();
                    }

                    SaveDocument(*ppiXMLDocument);

                    if (hToken)
                    {
                        // put the impersonation token back
                        if (!SetThreadToken(NULL, hToken))
                        {
                            hr = E_FAIL;
                        }
                        CloseHandle(hToken);
                    }
                }
                else
                {
                    if (NULL != g_pAlert)
                    {
                        g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                                         NEXUS_NOTPERSISTING,
                                         m_strURL.c_str());
                    }
                }
            }
            else
            {
                tstring strMsg;
                if(!m_strURL.empty())
                {
                    strMsg = TEXT("for ");
                    strMsg += m_strURL;
                }

                if (NULL != g_pAlert)
                {
                    g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                                     NEXUS_EMPTYLOCALNAME,
                                     strMsg.c_str()
                                     );
                }
            }
        }
        else if(*ppiXMLDocument)
        {

         // TODO: the logic is not so clear, on 3.0 timeframe, rewrite this whole func
         
            if (NULL != g_pAlert)
            {
                g_pAlert->report(PassportAlertInterface::INFORMATION_TYPE,
                                 NEXUS_USINGLOCAL,
                                 m_strLocalFile.c_str());
            }
            hr = S_OK;
        }
        else
        {
            //  If we get here it means that the fetch from the nexus failed
            //  and the load from disk failed.  It is sufficient here to simply
            //  fall through because hr will already contain an error code
            //  which should indicate to the caller that no document is 
            //  available.
        }
    }

Cleanup:

    return hr;
}


//===========================================================================
//
// IsValidCCD -- check ValidUntil attribute of the CCD
//
BOOL
PpShadowDocument::IsValidCCD(
    IXMLDocument* piXMLDocument
    )
{
    BOOL            bReturn;
    HRESULT         hr;
    IXMLElementPtr  piRootElement;
    SYSTEMTIME      sysTime;
    DOUBLE          dblTime;
    VARIANT         vAttrValue;
    VARIANT         vAttrDate;

    hr = piXMLDocument->get_root(&piRootElement);
    if(hr != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    VariantInit(&vAttrValue);
    hr = piRootElement->getAttribute(L"ValidUntil", &vAttrValue);
    if(hr != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    VariantInit(&vAttrDate);
    hr = VariantChangeType(&vAttrDate, &vAttrValue, 0, VT_DATE);
    if(hr != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    GetSystemTime(&sysTime);
    SystemTimeToVariantTime(&sysTime, &dblTime);

    bReturn = ((long)V_DATE(&vAttrDate) >= (long)dblTime);

Cleanup:

    VariantClear(&vAttrValue);
    VariantClear(&vAttrDate);

    return bReturn;
}


//===========================================================================
//
// NoPersist -- Check no persist attribute of the document
//
BOOL
PpShadowDocument::NoPersist(
    IXMLDocument* piXMLDocument
    )
{
    BOOL            bReturn;
    HRESULT         hr;
    IXMLElementPtr  piRootElement;
    VARIANT         vAttrValue;

    hr = piXMLDocument->get_root(&piRootElement);
    if(hr != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    VariantInit(&vAttrValue);
    hr = piRootElement->getAttribute(L"NoPersist", &vAttrValue);
    if(hr != S_OK)
    {
        bReturn = FALSE;
        goto Cleanup;
    }

    bReturn = (lstrcmpiW(L"true", V_BSTR(&vAttrValue)) == 0);

Cleanup:

    VariantClear(&vAttrValue);

    return bReturn;
}


//===========================================================================
//
// SaveDocument -- save CCD to local file
//
HRESULT
PpShadowDocument::SaveDocument(
    IXMLDocument* piXMLDoc
    )
{
    HRESULT                 hr;
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    ULARGE_INTEGER          uliSize;
    LARGE_INTEGER           liZero = {0,0};
    IStreamPtr              piStream;
    IPersistStreamInitPtr   piPSI;
    LPBYTE                  lpBuf = NULL;
    DWORD                   dwCurBlock;
    DWORD                   dwBytesWritten;

    hr = CreateStreamOnHGlobal(NULL, TRUE, &piStream);
    if(hr != S_OK)
        goto Cleanup;

    hr = piXMLDoc->QueryInterface(IID_IPersistStreamInit, (void**)&piPSI);
    if(hr != S_OK)
        goto Cleanup;

    piPSI->Save(piStream, TRUE);

    piStream->Seek(liZero, STREAM_SEEK_CUR, &uliSize);
    piStream->Seek(liZero, STREAM_SEEK_SET, NULL);

    if(uliSize.HighPart != 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    lpBuf = new BYTE[uliSize.LowPart];
    if(lpBuf == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hFile = CreateFile(
        m_strLocalFile.c_str(),
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if(hFile == INVALID_HANDLE_VALUE)
    {
        hr = GetLastError();
        goto Cleanup;
    }

    for(dwCurBlock = 0; dwCurBlock < uliSize.HighPart; dwCurBlock++)
    {
        hr = piStream->Read(lpBuf, 0xFFFFFFFF, NULL);
        if(!WriteFile(hFile, lpBuf, 0xFFFFFFFF, NULL, NULL))
        {
            hr = GetLastError();
            goto Cleanup;
        }
    }

    hr = piStream->Read(lpBuf, uliSize.LowPart, NULL);
    if(hr != S_OK)
        goto Cleanup;

    if(!WriteFile(hFile, lpBuf, uliSize.LowPart, &dwBytesWritten, NULL))
    {
        hr = GetLastError();
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:

    if(hr != S_OK)
    {
        TCHAR   achErrBuf[1024];
        LPCTSTR apszStrings[] = { m_strLocalFile.c_str(), achErrBuf };
        LPVOID  lpMsgBuf = NULL;
        ULONG   cchTmp;

        FormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS |
            FORMAT_MESSAGE_FROM_HMODULE |
            FORMAT_MESSAGE_MAX_WIDTH_MASK,
            GetModuleHandle(TEXT("wininet.dll")),
            hr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf,
            0,
            NULL );

        lstrcpy(achErrBuf, TEXT("0x"));
        _ultot(hr, &(achErrBuf[2]), 16);
        achErrBuf[sizeof(achErrBuf) / sizeof(achErrBuf[0]) - 1] = TEXT('\0');
        if(lpMsgBuf != NULL && *(LPTSTR)lpMsgBuf != TEXT('\0'))
        {
            cchTmp = _tcslen(achErrBuf) + 1;
            _tcsncat(achErrBuf, TEXT(" ("), (sizeof(achErrBuf) / sizeof(achErrBuf[0])) - cchTmp);
            _tcsncat(achErrBuf, (LPTSTR)lpMsgBuf, (sizeof(achErrBuf) / sizeof(achErrBuf[0])) - (cchTmp + 2));
            cchTmp = _tcslen(achErrBuf) + 1;
            _tcsncat(achErrBuf, TEXT(") "), (sizeof(achErrBuf) / sizeof(achErrBuf[0])) - cchTmp);
        }

        lstrcat(achErrBuf, TEXT(" when trying to save the fetched file to disk."));

        g_pAlert->report(PassportAlertInterface::ERROR_TYPE,
                         NEXUS_LOCALSAVEFAILED,
                         2,
                         apszStrings,
                         0,
                         NULL
                         );

        LocalFree(lpMsgBuf);

        hr = E_FAIL;
    }

    if(lpBuf != NULL)
        delete [] lpBuf;

    if(hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return hr;
}


//===========================================================================
//
// LoadDocument -- get CCDs from local
//
HRESULT
PpShadowDocument::LoadDocument(
    IXMLDocument** ppiXMLDocument
    )
{
    HRESULT                 hr;
    HANDLE                  hFile = INVALID_HANDLE_VALUE;
    DWORD                   dwFileSizeLow;
    DWORD                   dwBytesRead;
    LPBYTE                  lpBuf = NULL;
    IStreamPtr              piStream;
    IPersistStreamInitPtr   piPSI;
    LARGE_INTEGER           liZero = {0,0};

    hFile = CreateFile(
        m_strLocalFile.c_str(),
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if(hFile == INVALID_HANDLE_VALUE)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    dwFileSizeLow = GetFileSize(hFile, NULL);
    if(dwFileSizeLow == 0xFFFFFFFF)
    {
        hr = GetLastError();
        goto Cleanup;
    }

    lpBuf = new BYTE[dwFileSizeLow];
    if(lpBuf == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = CreateStreamOnHGlobal(NULL, TRUE, &piStream);
    if(hr != S_OK)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if(ReadFile(hFile, lpBuf, dwFileSizeLow, &dwBytesRead, NULL) == 0)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    try
    {
        hr = piStream->Write(lpBuf, dwFileSizeLow, NULL);

        hr = piStream->Seek(liZero, STREAM_SEEK_SET, NULL);
    }
    catch(...)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Now create an XML object and initialize it using the stream.
    //

    hr = CoCreateInstance(__uuidof(XMLDocument), NULL, CLSCTX_ALL, IID_IPersistStreamInit, (void**)&piPSI);
    if(hr != S_OK)
        goto Cleanup;

    hr = piPSI->Load((IStream*)piStream);
    if(hr != S_OK)
        goto Cleanup;

    hr = piPSI->QueryInterface(__uuidof(IXMLDocument), (void**)ppiXMLDocument);

Cleanup:

    if(lpBuf != NULL)
        delete [] lpBuf;

    if(hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return hr;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\nexusobjects\precomp.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    precomp.h


    FILE HISTORY:

*/
#ifndef __PRECOMP_H
#define __PRECOMP_H

#pragma warning ( disable : 4242 )

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <assert.h>
#include <comdef.h>

#include "digest.h"
#include "passporttypes.h"

#include "PassportEvent.hpp"
#include "PassportGuard.hpp"
#include "PpNexusClient.h"
#include "PpNotificationThread.h"
#include "PpShadowDocument.h"
#include "PMAlertsDefs.h"
#include "PassportAlertInterface.h"
#include "pmalerts.h"

extern PassportAlertInterface* g_pAlert;

#endif // __PRECOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\passportperf.cpp ===
#define _PassportExport_
#include "PassportExport.h"

#include <string.h>
#include <tchar.h>

#include "PassportPerf.h"
#include "PassportPerfObjects.h" 

#include "PerfSharedMemory.h"
#include "PerfUtils.h"

#include <loadperf.h>

#include <crtdbg.h>

#define PASSPORT_NAME_KEY _T("SYSTEM\\CurrentControlSet\\Services\\%s\\Performance")
#define UNLOAD_NAME       _T("unlodctr %s")
#define LOAD_NAME         _T("lodctr ")
#define INI_EXT           _T(".ini")

#define NAME_KEY_LEN        (sizeof(PASSPORT_NAME_KEY)/sizeof(TCHAR))
#define UNLOAD_NAME_LEN     (sizeof(UNLOAD_NAME)/sizeof(TCHAR))
#define LOAD_NAME_LEN       (sizeof(LOAD_NAME)/sizeof(TCHAR))
#define INI_EXT_LEN         (sizeof(INI_EXT)/sizeof(TCHAR))

DWORD   dwOpenCount = 0;			// count of "Open" threads
BOOL    bInitOK = FALSE;			// true = DLL initialized OK


//-------------------------------------------------------------
//
// OpenPassportPerformanceData
//
// Arguments:    
//		Pointer to object ID of each device to be opened (VGA)
//
// Return Value:    always ERROR_SUCCESS
//
//-------------------------------------------------------------
DWORD APIENTRY OpenPassportPerformanceData(LPWSTR lpDeviceNames)
{
    TCHAR   lpszBuffer[MAX_PATH];
    TCHAR   *lpKeyName;
    LONG    status;
    HKEY    hKeyDriverPerf;
    DWORD	dwFirstCounter = 0, dwFirstHelp = 0, 
            dwLastCounter = 0, dwLastHelp  = 0, 
            dwNumCounters = 0,
            size = 0, i;

	// here we need to find out the number of counters (remeber,
	// this code not support counter instances) from the registry
    if (dwOpenCount == 0)
    {
        for (i = 0; i < NUM_PERFMON_OBJECTS; i++)
        {
            DWORD dwStrLen;
    
            _ASSERT(g_PObject[i]);
            g_PObject[i]->PSM = new PerfSharedMemory();
            if (g_PObject[i]->PSM == NULL)
            {
                g_PObject[i]->active = FALSE;
                continue;
            }
            
            // get counter and help index base values from registry
            //      Open key to registry entry
            //      read First Counter and First Help values
            
            dwStrLen = lstrlen(g_PObject[i]->szPassportName); 
            
            if ((NAME_KEY_LEN + dwStrLen) > (MAX_PATH+2)) 
            {
            
                //
                // The buffer size is MAX_PATH
                // PASSPORT_NAME_KEY has %s in it, which will be replaced by g_PObject[i]->szPassportName
                // So the length checking should be MAX_PATH + 2. THe NULL space is included in NAME_KEY_LEN. 
                //
            
                lpKeyName = new TCHAR [ NAME_KEY_LEN + dwStrLen - 2];
            
                if (NULL == lpKeyName) {
            
                    g_PObject[i]->active = FALSE;
                    continue;
            
                }
            
            } else {
            
                lpKeyName = &lpszBuffer[0];  
            }
            
            wsprintf(lpKeyName, PASSPORT_NAME_KEY, g_PObject[i]->szPassportName);
            
            status = RegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                lpszBuffer,
                0L,            
                KEY_READ,            
                &hKeyDriverPerf);
            
            if (lpKeyName != &lpszBuffer[0]) {
            
                delete [] lpKeyName;
                lpKeyName = NULL;
            
            }
            
            if (status != ERROR_SUCCESS) 
            {
                delete g_PObject[i]->PSM;
                g_PObject[i]->PSM = NULL;
                g_PObject[i]->active = FALSE;
                continue;
            }
            
            size = sizeof (DWORD);        
            status = RegQueryValueEx(
                hKeyDriverPerf,                     
                _T("First Counter"),
                0L,                    
                NULL,
                (LPBYTE)&dwFirstCounter,                    
                &size);
            if (status != ERROR_SUCCESS) 
            {
                delete g_PObject[i]->PSM;
                g_PObject[i]->PSM = NULL;
                g_PObject[i]->active = FALSE;
                RegCloseKey(hKeyDriverPerf);
                continue;
            }
            
            status = RegQueryValueEx(
                hKeyDriverPerf,                     
                _T("First Help"),
                0L,                    
                NULL,
                (LPBYTE)&dwFirstHelp,            
                &size);
            if (status != ERROR_SUCCESS) 
            {
                delete g_PObject[i]->PSM;
                g_PObject[i]->PSM = NULL;
                g_PObject[i]->active = FALSE;
                RegCloseKey(hKeyDriverPerf);
                continue;
            }
            
            status = RegQueryValueEx(
                hKeyDriverPerf,                     
                _T("Last Counter"),
                0L,                    
                NULL,
                (LPBYTE)&dwLastCounter,                    
                &size);
            if (status != ERROR_SUCCESS) 
            {
                delete g_PObject[i]->PSM;
                g_PObject[i]->PSM = NULL;
                g_PObject[i]->active = FALSE;
                RegCloseKey(hKeyDriverPerf);
                continue;
            }
            
            status = RegQueryValueEx(
                hKeyDriverPerf,                     
                _T("Last Help"),
                0L,                    
                NULL,
                (LPBYTE)&dwLastHelp,            
                &size);
            if (status != ERROR_SUCCESS) 
            {
                delete g_PObject[i]->PSM;
                g_PObject[i]->PSM = NULL;
                g_PObject[i]->active = FALSE;
                RegCloseKey(hKeyDriverPerf);
                continue;
            }
            
            dwNumCounters = (dwLastCounter - dwFirstCounter) / 2;
            
            RegCloseKey(hKeyDriverPerf);
            
            if (!g_PObject[i]->PSM->initialize(
                dwNumCounters, 
                dwFirstCounter, 
                dwFirstHelp))
            {
                delete g_PObject[i]->PSM;
                g_PObject[i]->PSM = NULL;
                g_PObject[i]->active = FALSE;
                continue;
            } 
                
            for (DWORD j = 0; j < g_PObject[i]->dwNumDefaultCounterTypes; j++)
            {
                g_PObject[i]->PSM->setDefaultCounterType(
                    g_PObject[i]->defaultCounterTypes[j].dwIndex,
                    g_PObject[i]->defaultCounterTypes[j].dwDefaultType);
            }
            
            (void)g_PObject[i]->PSM->OpenSharedMemory(
                    g_PObject[i]->lpcszPassportPerfBlock, FALSE);
            
            g_PObject[i]->active = TRUE;
		}
		
	}
	dwOpenCount++;

	return ERROR_SUCCESS;
}

//
// rotate amoung objects and skip uninstalled objects
//
void ObjectRotate(DWORD *pi)
{
	if (NUM_PERFMON_OBJECTS == 1) 
	{
		return;
	}
	
	if (NUM_PERFMON_OBJECTS == 2) 
	{
		if (g_PObject[!(*pi)]->active) 
		{
			*pi = !(*pi);
		}
		return;
	}
	
	DWORD oldI = *pi;
	
	DWORD dwMod = NUM_PERFMON_OBJECTS; 
	
    do 
	{
        *pi = (*pi + 1) % dwMod;
   	} 
	while ((*pi != oldI) && (!g_PObject[*pi]->active));
	
	return;
}


//-------------------------------------------------------------
//
// CollectPassportPerformanceData
//
// Arguments:
//		IN       LPWSTR   lpValueName
//			  pointer to a wide character string passed by registry.
//		IN OUT   LPVOID   *lppData
//         IN: pointer to the address of the buffer to receive the completed 
//            PerfDataBlock and subordinate structures. This routine will
//            append its data to the buffer starting at the point referenced
//            by *lppData.
//         OUT: points to the first byte after the data structure added by this
//            routine. This routine updated the value at lppdata after appending
//            its data.   
//		IN OUT   LPDWORD  lpcbTotalBytes
//         IN: the address of the DWORD that tells the size in bytes of the 
//            buffer referenced by the lppData argument
//         OUT: the number of bytes added by this routine is written to the 
//            DWORD pointed to by this argument   
//      IN OUT   LPDWORD  NumObjectTypes
//         IN: the address of the DWORD to receive the number of objects added 
//            by this routine 
//         OUT: the number of objects added by this routine is written to the 
//            DWORD pointed to by this argument
//
// Return Value:
//      ERROR_MORE_DATA if buffer passed is too small to hold data
//         any error conditions encountered are reported to the event log if
//         event logging is enabled.
//      ERROR_SUCCESS  if success or any other error. Errors, however are
//         also reported to the event log.
//
//-------------------------------------------------------------
DWORD APIENTRY CollectPassportPerformanceData(
											  IN		LPWSTR	lpValueName,
											  IN OUT	LPVOID	*lppData,
											  IN OUT	LPDWORD lpcbTotalBytes,
											  IN OUT	LPDWORD lpNumObjectTypes)
{

	//DebugBreak();
	DWORD rv = ERROR_SUCCESS,
		  dwQueryType = 0;
	static DWORD i = 0;

    //
    // This is an exported routine. We need to verify the input parameters
    //

    if ((lpcbTotalBytes == NULL) || (lpNumObjectTypes == NULL)) {

        //
        //  Are we allowed to return this error code?
        //

        return ERROR_INVALID_PARAMETER;

    }


	if (dwOpenCount  <= 0 || !g_PObject[i] || !g_PObject[i]->active)
	{
		*lpcbTotalBytes = (DWORD) 0;
		*lpNumObjectTypes = (DWORD) 0;
		ObjectRotate(&i);
		return ERROR_SUCCESS; // yes, this is a successful exit
	}
	
	_ASSERT(g_PObject[i]->PSM);

	if (!g_PObject[i]->PSM->checkQuery(lpValueName))
	{
		*lpcbTotalBytes = (DWORD) 0;
		*lpNumObjectTypes = (DWORD) 0;
		ObjectRotate(&i);
		return ERROR_SUCCESS;
	}
	
	(void)g_PObject[i]->PSM->OpenSharedMemory(
		g_PObject[i]->lpcszPassportPerfBlock, FALSE);

	if (*lpcbTotalBytes < g_PObject[i]->PSM->spaceNeeded())
	{
		*lpcbTotalBytes = (DWORD) 0;
		*lpNumObjectTypes = (DWORD) 0;
		ObjectRotate(&i);
		return ERROR_MORE_DATA;
	}

	if (!g_PObject[i]->PSM->writeData(lppData, lpcbTotalBytes))
	{
		*lpcbTotalBytes = (DWORD) 0;
		*lpNumObjectTypes = (DWORD) 0;
		ObjectRotate(&i);
		return ERROR_SUCCESS;
	}

	*lpNumObjectTypes = 1;

	ObjectRotate(&i);
	return ERROR_SUCCESS;
}



//-------------------------------------------------------------
//
// ClosePassportPerformanceData
//
//-------------------------------------------------------------
DWORD APIENTRY ClosePassportPerformanceData()
{
	dwOpenCount--;
	if (dwOpenCount <= 0)
	{
		for (DWORD i = 0; i < NUM_PERFMON_OBJECTS; i++)
		{
			_ASSERT(g_PObject[i]);
			_ASSERT(g_PObject[i]->PSM);
			if (g_PObject[i]->active)
				g_PObject[i]->PSM->CloseSharedMemory();
			delete g_PObject[i]->PSM;
			g_PObject[i]->PSM = NULL;
		}
	}
 	return ERROR_SUCCESS;
}


//-------------------------------------------------------------
//
// DllUnregisterServer
//
//-------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    TCHAR   lpszBuffer[MAX_PATH];
    TCHAR   *pTmpBuffer;
    DWORD   dwFileNameLen;
    DWORD   dwBufLength;
    LONG	result = 0;
    // BUGBUG the counter ini file must be in the same directory as
    // the dll
    
    // note: this "unlodctr " MUST be added to the buffer first,
    // else UnloadPerfCounterTextStrings() fails.  WHY? Literally,
    // UnloadPerfCounterTextStrings first parameter is the Command 
    // Line of the unlodctr.exe application -- eeech!
    for (DWORD i = 0; i < NUM_PERFMON_OBJECTS; i++)
    {
        _ASSERT(g_PObject[i]);
    
        dwFileNameLen = lstrlen(g_PObject[i]->szPassportPerfIniFile);
        if ((dwFileNameLen + UNLOAD_NAME_LEN) > MAX_PATH - 2) 
        {
    
            //
            // 2 is for %s
            //
    
            pTmpBuffer = new TCHAR [dwFileNameLen + UNLOAD_NAME_LEN - 2];
            if (!pTmpBuffer) 
            {
    
                //
                //  Afraid of being break the caller. Just return E_UNEXPECTED as original codes dealing with error
                //  from UnloadPerfCounterTextStrings.
                //
    
                return E_UNEXPECTED;
    
            }
            dwBufLength = dwFileNameLen + UNLOAD_NAME_LEN - 2;
    
        } else {
    
            pTmpBuffer = lpszBuffer;
            dwBufLength = MAX_PATH;
    
        }
        
        wsprintf(pTmpBuffer, UNLOAD_NAME, g_PObject[i]->szPassportPerfIniFile);
        __try {
            result = UnloadPerfCounterTextStrings(pTmpBuffer,FALSE);
        } 
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            ;
        }
        
        if (result != ERROR_SUCCESS)
        {
            if (pTmpBuffer != lpszBuffer) 
            {
                delete [] pTmpBuffer;
            }
    
            return (E_UNEXPECTED);
        }
        
        dwFileNameLen = lstrlen(g_PObject[i]->szPassportName);
    
        if ((dwFileNameLen + NAME_KEY_LEN) > dwBufLength - 2)
        {
            if (pTmpBuffer != lpszBuffer) 
            {
                delete [] pTmpBuffer;
            }
    
            pTmpBuffer = new TCHAR [dwFileNameLen + NAME_KEY_LEN - 2];
            if (!pTmpBuffer) 
            {
    
                //
                //  Afraid of being break the caller. Just return E_UNEXPECTED as original codes dealing with error
                //  from UnloadPerfCounterTextStrings.
                //
    
                return E_UNEXPECTED;
    
            }
            dwBufLength = dwFileNameLen + NAME_KEY_LEN - 2;
        }
    
        wsprintf(pTmpBuffer, PASSPORT_NAME_KEY, g_PObject[i]->szPassportName);
    
        LONG regError = RegDeleteKey(HKEY_LOCAL_MACHINE,lpszBuffer);
        if (regError != ERROR_SUCCESS)
        {
            if (pTmpBuffer != lpszBuffer) 
            {
                delete [] pTmpBuffer;
            }
            return (E_UNEXPECTED);
        }
        
        //
        // If buffer is big enough for the above wsprintf(), it must be big enough for this one
        //
    
        wsprintf(&lpszBuffer[0],_T("SYSTEM\\CurrentControlSet\\Services\\%s"), 
            g_PObject[i]->szPassportName); 
        regError = RegDeleteKey(HKEY_LOCAL_MACHINE,lpszBuffer);
    
        if (pTmpBuffer != lpszBuffer) 
        {
            delete [] pTmpBuffer;
            pTmpBuffer = NULL;
        }
    
        if (regError != ERROR_SUCCESS)
        {
            return (E_UNEXPECTED);
        }
    }
    return (S_OK);
}


//-------------------------------------------------------------
//
// DllRegisterServer
//
//-------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    DWORD   dwAllocBufferLength=MAX_PATH;
    TCHAR   lpszBuffer[MAX_PATH];
    TCHAR   *tmpStr = NULL;
    HKEY	hkResult1; 					// address of handle of open key 
    HKEY	hkResult2; 					// address of handle of open key 
    HKEY	hkResult3; 					// address of handle of open key 
    DWORD	ulOptions=0;
    REGSAM	samDesired=KEY_ALL_ACCESS;
    DWORD	Reserved=0;
    DWORD	dwTypesSupported=7;	
    DWORD	dwCatagoryCount=1;	
    LONG	result = 0;
    DWORD   dwStrLen;
    
    (void) DllUnregisterServer();
    
    
    for (DWORD i = 0; i < NUM_PERFMON_OBJECTS; i++)
    {
        _ASSERT(g_PObject[i]);
        
        // Get DLL File Location
        // 1 is for \ not the NULL
    
        DWORD dwFileLen = lstrlen(g_PObject[i]->szPassportPerfDll)+1;
    
        dwStrLen = GetCurrentDirectory(MAX_PATH - dwFileLen, &lpszBuffer[0]);
        if (!dwStrLen) {
            goto Error;
        }
    
        if (dwStrLen > (MAX_PATH - dwFileLen)) {
    
            //
            // NULL is included in dwStrLen. 
            //
    
            dwStrLen += dwFileLen;
    
            tmpStr = new TCHAR [dwStrLen];
            if (!tmpStr) {
                goto Error;
            }
            dwAllocBufferLength = dwStrLen;
            dwStrLen = GetCurrentDirectory(dwAllocBufferLength, tmpStr);
            if (!dwStrLen) {
                goto Error;
            }
    
        } else {
            tmpStr = lpszBuffer;
        }
        
        _tcscat(tmpStr, _T("\\"));
        _tcscat(tmpStr, g_PObject[i]->szPassportPerfDll);
        
        // perfmon Registry Settings
        
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            _T("SYSTEM\\CurrentControlSet\\Services"),
            ulOptions,samDesired,&hkResult1)!=ERROR_SUCCESS)
            goto Error;
        
        if (RegCreateKey(hkResult1,g_PObject[i]->szPassportName,
            &hkResult2)!=ERROR_SUCCESS)
        {
            RegCloseKey(hkResult1);
            goto Error;
        }
        
        if (RegCreateKey(hkResult2,_T("Performance"),&hkResult3)!=ERROR_SUCCESS)
        {
            RegCloseKey(hkResult1);
            RegCloseKey(hkResult2);
            goto Error;
        }
        
        if (RegSetValueEx(hkResult3,_T("Library"),
            Reserved,REG_EXPAND_SZ,
            (UCHAR*)tmpStr,(dwFileLen+dwStrLen+1)* sizeof(TCHAR))!=ERROR_SUCCESS)
        {
            RegCloseKey(hkResult1);
            RegCloseKey(hkResult2);
            RegCloseKey(hkResult3);
            goto Error;
        }
        
        if (RegSetValueEx(hkResult3, _T("Open"),Reserved,
            REG_SZ,(UCHAR*)PASSPORT_PERF_OPEN,
            (_tcslen(PASSPORT_PERF_OPEN) + 1)* sizeof(TCHAR))!=ERROR_SUCCESS)
        {
            RegCloseKey(hkResult1);
            RegCloseKey(hkResult2);
            RegCloseKey(hkResult3);
            goto Error;
        }
        
        if (RegSetValueEx(hkResult3,_T("Collect"),Reserved,
            REG_SZ,(UCHAR*)PASSPORT_PERF_COLLECT,
            ((_tcslen(PASSPORT_PERF_COLLECT)+1)* sizeof(TCHAR)))!=ERROR_SUCCESS)
        {
            RegCloseKey(hkResult1);
            RegCloseKey(hkResult2);
            RegCloseKey(hkResult3);
            goto Error;
        }
        
        if (RegSetValueEx(hkResult3,_T("Close"),Reserved,
            REG_SZ,(CONST BYTE *)PASSPORT_PERF_CLOSE,
            ((_tcslen(PASSPORT_PERF_CLOSE)+1)* sizeof(TCHAR)))!=ERROR_SUCCESS)
        {
            RegCloseKey(hkResult1);
            RegCloseKey(hkResult2);
            RegCloseKey(hkResult3);
            goto Error;
        }
        
        RegCloseKey(hkResult1);
        RegCloseKey(hkResult2);
        RegCloseKey(hkResult3);
        //if (RegCloseKey(hkResult1)!=ERROR_SUCCESS)
        //	goto Error;
        
        //if (RegCloseKey(hkResult2)!=ERROR_SUCCESS)
        //	goto Error;
        
        //if (RegCloseKey(hkResult3)!=ERROR_SUCCESS)
        //	goto Error;
        
        // BUGBUG the counter ini file must be in the same directory as
        // the dll
        
        // note: this "lodctr " MUST be added to the buffer first,
        // else LoadPerfCounterTextStrings() fails.  WHY? Literally,
        // LoadPerfCounterTextStrings first parameter is the Command 
        // Line of the lodctr.exe application -- eeech!
    
        //
        // Both LOAD_NAME_LEN & INI_EXT_LEN include the NULL. So -1.
        //
        dwFileLen = lstrlen(g_PObject[i]->szPassportPerfIniFile) + LOAD_NAME_LEN + INI_EXT_LEN - 1;
        if (dwFileLen > dwAllocBufferLength) {
    
            //
            // Allocate memory
            //
    
            if (tmpStr != lpszBuffer) {
                delete [] tmpStr;
            }
    
            tmpStr = new TCHAR [dwFileLen];
            if (!tmpStr) {
                goto Error;
            }
    
        }
    
    
        _tcscpy(tmpStr, LOAD_NAME);
        _tcscat(tmpStr,g_PObject[i]->szPassportPerfIniFile);
        _tcscat(tmpStr, INI_EXT);
        __try {
            result = LoadPerfCounterTextStrings(lpszBuffer,FALSE);
        } 
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            ;
        }
    
        if (tmpStr != lpszBuffer) {
            delete [] tmpStr;
            tmpStr = NULL;
        }
        
        if (result != ERROR_SUCCESS)
        {
            goto Error;
        }
    }
    
    return(S_OK);

Error:
    if (tmpStr && (tmpStr != lpszBuffer) ) {
        delete [] tmpStr;
    }
	return(E_UNEXPECTED);
}



//-------------------------------------------------------------
//
//
//
//-------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\passportsharedmemory.cpp ===
#define _PassportExport_
#include "PassportExport.h"

#include "PassportSharedMemory.h"
#include <malloc.h>
#include <tchar.h>

#define PMUTEX_STRING _T("PASSPORTMUTEX")

//-------------------------------------------------------------
//
// PassportSharedMemory
//
//-------------------------------------------------------------
PassportSharedMemory::PassportSharedMemory()
{
	m_hShMem = 0;
	m_pbShMem = 0;
	m_bInited = 0;
	m_hMutex = 0;
	m_bUseMutex = FALSE;
}

//-------------------------------------------------------------
//
// ~PassportSharedMemory
//
//-------------------------------------------------------------
PassportSharedMemory::~PassportSharedMemory()
{
	CloseSharedMemory();
}


//-------------------------------------------------------------
//
// CreateSharedMemory
//
//-------------------------------------------------------------
BOOL PassportSharedMemory::CreateSharedMemory ( 
					const DWORD &dwMaximumSizeHigh, 
					const DWORD &dwMaximunSizeLow,
					LPCTSTR lpcName,
					BOOL	useMutex)
{
    BOOL fReturn  = FALSE;
    SID_IDENTIFIER_AUTHORITY siaWorld = SECURITY_NT_AUTHORITY;

    // local param need to be freed before exit
    SECURITY_DESCRIPTOR sd;
    PACL pACL = NULL;
    DWORD cbACL;
    SID *lpSID = NULL;
    LPSECURITY_ATTRIBUTES lpSA = NULL;

    // local param do not need to free
    TCHAR *pStr = NULL;

    if (!lpcName)
    {
        goto exit;
    }

    if (m_pbShMem != NULL && m_hShMem != NULL && m_bInited)
    {
        fReturn = TRUE;
        goto exit;
    }

    m_bUseMutex = useMutex;
	
    if (!AllocateAndInitializeSid(&siaWorld,                // Security, world authoity for ownership
                                  1,                        // 1 relative sub-authority
                                  SECURITY_AUTHENTICATED_USER_RID, // sub-authority, authenticated users
                                  0, 0, 0, 0, 0, 0, 0,      // unused sub-authority types
                                  (void**) &lpSID))         // ** to security ID struct
    {
        goto exit;
    }

    cbACL = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(lpSID);

    pACL = (PACL) LocalAlloc(LMEM_FIXED, cbACL);

    if (pACL == NULL)
    {
        goto exit;
    }

    if (!InitializeAcl(pACL, cbACL, ACL_REVISION))
    {
        goto exit;
    }

    //
    // Perfcounters may run under any account and may need to read from or
    // write to the shared memory section.  Give World read/write access.
    //

    if (!AddAccessAllowedAce(pACL, ACL_REVISION, GENERIC_READ | GENERIC_WRITE, lpSID))
    {
        goto exit;
    }

    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);

    SetSecurityDescriptorDacl(&sd, TRUE, pACL, FALSE);     // allow access to DACL
    SetSecurityDescriptorGroup(&sd, lpSID, FALSE);         // set group to World

    lpSA = new SECURITY_ATTRIBUTES;

    if( !lpSA )
    {
        goto exit;
    }

    lpSA->nLength = sizeof(SECURITY_ATTRIBUTES);
    lpSA->lpSecurityDescriptor = &sd;
    lpSA->bInheritHandle = TRUE;

    m_hShMem = CreateFileMapping((INVALID_HANDLE_VALUE),                      
                                 lpSA,
                                 PAGE_READWRITE,
                                 dwMaximumSizeHigh,
                                 dwMaximunSizeLow,
                                 lpcName);
	
    if( !m_hShMem )
    {
        goto exit;
    }

    m_pbShMem = (BYTE*) MapViewOfFile(m_hShMem, 
                                      FILE_MAP_ALL_ACCESS, 
                                      0, 0, 0 );

    if( !m_pbShMem )
    {
        goto exit;
    }

    if (useMutex)
    {
    
        pStr = new TCHAR [_tcslen(lpcName) + _tcslen(PMUTEX_STRING) + 1];
        if (NULL == pStr)
        {
            goto exit;
        }

        _tcscpy (pStr, lpcName);
        _tcscat (pStr, PMUTEX_STRING);
        m_hMutex = CreateMutex(lpSA,FALSE,pStr);
		
        delete [] pStr;

        if( !m_hMutex )
        {
            goto exit;
        }
    }
	
    // we are here because we are fully initialized :-)
    m_bInited = TRUE;
    fReturn = TRUE;

exit:

    // cleanup locally allocated heap
    if( lpSA )
    {
        delete lpSA;
    }

    if( lpSID )
    {
        FreeSid(lpSID);
    }

    if (pACL)
    {
        LocalFree(pACL);
    }

    // if we are not fully initialized, cleanup them
    if( !m_bInited )
    {
        CloseSharedMemory();
    }

    return fReturn;
}	



//-------------------------------------------------------------
//
// OpenSharedMemory
//
//-------------------------------------------------------------
BOOL PassportSharedMemory::OpenSharedMemory( LPCTSTR lpcName, BOOL useMutex )
{
	
	if (!lpcName)
		return FALSE;

	if (m_pbShMem != NULL && m_hShMem != NULL && m_bInited)
		return TRUE;

	m_bUseMutex = useMutex;

	m_hShMem = OpenFileMapping( FILE_MAP_READ, FALSE, lpcName );
	if( ! m_hShMem )
	{
		return FALSE;
	}

	m_pbShMem = (BYTE*) MapViewOfFile( m_hShMem, FILE_MAP_READ, 0, 0, 0 );
	if( ! m_pbShMem )
	{
		CloseHandle( m_hShMem );
		m_hShMem = 0;
		return FALSE;
	}

	if (useMutex)
	{
		TCHAR *pStr = new TCHAR [_tcslen(lpcName) + _tcslen(PMUTEX_STRING) + 1];
        
        if (pStr == NULL) 
        {

			CloseSharedMemory();
			return FALSE;

        }
		_tcscpy (pStr, lpcName);
		_tcscat (pStr,PMUTEX_STRING);
		m_hMutex = OpenMutex(SYNCHRONIZE ,FALSE, pStr);
        delete [] pStr;
		if( !m_hMutex )
		{
			CloseSharedMemory();
			return FALSE;
		}
	}

	m_bInited = TRUE;
	return TRUE;
}

//-------------------------------------------------------------
//
// CloseSharedMemory
//
//-------------------------------------------------------------
void PassportSharedMemory::CloseSharedMemory( void )
{
	if( m_pbShMem )
	{
		UnmapViewOfFile( (void*) m_pbShMem );
		m_pbShMem = 0;
	}
	
	if( m_hShMem )
	{
		CloseHandle( m_hShMem );
		m_hShMem = 0;
	}

	if( m_hMutex )
	{
		ReleaseMutex(m_hMutex);
		m_hMutex = 0;;
	}

    //
    // Reading from the above code, we should do the following.
    // On the other hand, we may be able to eliminate this member. No big role for this member.
    //

    if (m_bInited){
        m_bInited = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\passportperfinterface.cpp ===
// PassportPerfInterface.cpp: implementation of the PassportPerfInterface class.
//
//////////////////////////////////////////////////////////////////////

#define _PassportExport_
#include "PassportExport.h"

#include "PassportPerfInterface.h"
#include "PassportPerfMon.h"

//-------------------------------------------------------------
//
// CreatePassportPerfObject
//
//-------------------------------------------------------------
PassportPerfInterface *  CreatePassportPerformanceObject ( PassportPerfInterface::OBJECT_TYPE type )
{
	switch (type)
	{
	case PassportPerfInterface::PERFMON_TYPE:
		return ( PassportPerfInterface * ) new PassportPerfMon();
	default:
		return NULL;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\passportperfinterface.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportPerfInterface.h

    Abstract:

		Performance Monitor Class Definition

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

		- added Instance support 1-Oct-98
--*/

#if !defined (PASSPORTPERFINTERFACE_H)
#define PASSPORTPERFINTERFACE_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <windows.h>

class PassportPerfInterface 
{
public:
	inline PassportPerfInterface() {};
	inline virtual ~PassportPerfInterface () {};

	enum OBJECT_TYPE
	{
		PERFMON_TYPE	= 100,		// use Perfmon counter,
		SNMP_TYPE		= 101		// use SNMP Traps,
	};
	
	// -------------------------------------------------------------------
	/* Divide delta by delta time.  Display suffix: "/sec" */
		// PERF_COUNTER_COUNTER = 1000,
	/* Indicates the data is a counter  which should not be	*/
	/* time averaged on display (such as an error counter on a serial line)	*/
	/* Display as is.  No Display Suffix.*/
		// PERF_COUNTER_RAWCOUNT = 1001,
	/* A timer which, when divided by an average base, produces a time */
	/* in seconds which is the average time of some operation.  This */
	/* timer times total operations, and  the base is the number of opera- */
	/* tions.  Display Suffix: "sec" */
		// PERF_AVERAGE_TIMER 	= 1002,
	/*  This counter is used to display the difference from one sample */
	/*  to the next. The counter value is a constantly increasing number */
	/*  and the value displayed is the difference between the current */
	/*  value and the previous value. Negative numbers are not allowed	*/
	/*  which shouldn't be a problem as long as the counter value is */
	/*  increasing or unchanged. */
		// PERF_COUNTER_DELTA = 1003,
	/* unknown type	*/
		// PERF_COUNTER_UNDEFINED = 1004


	enum COUNTER_SAMPLING_TYPE
	{
		COUNTER_COUNTER = 1000,
		COUNTER_RAWCOUNT = 1001,
		AVERAGE_TIMER 	= 1002,
		COUNTER_DELTA = 1003,
		COUNTER_UNDEFINED = 1004
	};

	enum { MAX_COUNTERS = 128, MAX_INSTANCES = 64, MAX_INSTANCE_NAME = 32 };

	// object initialization
	virtual BOOL init ( LPCTSTR lpcPerfObjectName ) = 0;
	
	// get set counter type
	virtual BOOL setCounterType ( 
				const DWORD &dwType, 
				const PassportPerfInterface::COUNTER_SAMPLING_TYPE &counterSampleType) = 0; 
	virtual PassportPerfInterface::COUNTER_SAMPLING_TYPE getCounterType ( 
				const DWORD &dwType ) const = 0;

	// adding/subtracting an instance to this object 
	virtual BOOL addInstance ( LPCSTR lpszInstanceName ) = 0;
	virtual BOOL deleteInstance ( LPCSTR lpszInstanceName ) = 0;
	virtual BOOL instanceExists ( LPCSTR lpszInstanceName ) = 0;
	virtual BOOL hasInstances ( void ) = 0;
	virtual DWORD numInstances ( void ) = 0;

	// counters:  note if hasInstances() is TRUE, then you must 
	// give the instance name
	virtual BOOL incrementCounter ( 
				const DWORD &dwType, 
				LPCSTR lpszInstanceName = NULL ) = 0;
	virtual BOOL decrementCounter ( 
				const DWORD &dwType, 
				LPCSTR lpszInstanceName = NULL ) = 0;
	virtual BOOL setCounter ( 
				const DWORD &dwType, 
				const DWORD &dwValue, 
				LPCSTR lpszInstanceName = NULL )  = 0;
	virtual BOOL getCounterValue ( 
				DWORD &dwValue,
				const DWORD &dwType, 
				LPCSTR lpszInstanceName = NULL ) = 0;


};

// create and returns a pointer to the relevant implementation,
// NULL if none exists (FYI- extern "C" to stop name mangling)
extern "C" PassportPerfInterface * CreatePassportPerformanceObject( PassportPerfInterface::OBJECT_TYPE type );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\passportperfmon.cpp ===
// PassportPerfMon.cpp: implementation of the PassportPerfMon class.
//
//////////////////////////////////////////////////////////////////////

#define _PassportExport_
#include "PassportExport.h"

#include "PassportPerfMon.h"
#include "PassportPerf.h"

#include <crtdbg.h>

//-------------------------------------------------------------
//
// PassportPerfMon const
//
//-------------------------------------------------------------
PassportPerfMon::PassportPerfMon( ) : PassportSharedMemory()
{
	isInited = FALSE;
	dwNumInstances = 0;
}

//-------------------------------------------------------------
//
// ~PassportPerfMon
//
//-------------------------------------------------------------
PassportPerfMon::~PassportPerfMon()
{
}

//-------------------------------------------------------------
//
// init
//
//-------------------------------------------------------------
BOOL PassportPerfMon::init( LPCTSTR lpcPerfObjectName )
{

	if (isInited)
	{
		return FALSE;
	}
	
	_ASSERT( lpcPerfObjectName );

	InitializeCriticalSection(&mInitLock);
	EnterCriticalSection(&mInitLock);

	// File mapped memory layout
	// 1. MAX_COUNTERS of DWORD for the counter types
	// 2. if dwNumInstances == 0, then
	//	  (a) MAX_COUNTERS of DWORDS of the counter data
	//    else (dwNumInstances > 0)
	//	  (b) MAX_COUNTERS of INSTANCE_DATA structures each followed
	//        immediately by MAX_COUNTERS of DWORDS of the counter data
	DWORD dwSize = (
			(MAX_COUNTERS * sizeof(DWORD))		// for counter type
		  + (MAX_INSTANCES * 
			(sizeof(INSTANCE_DATA) + (MAX_COUNTERS * sizeof(DWORD))))
			); 
	
	if (!CreateSharedMemory(0, dwSize, lpcPerfObjectName, TRUE))
	{
		// raise information alert
		if (!OpenSharedMemory (lpcPerfObjectName, TRUE ))
		{
			LeaveCriticalSection(&mInitLock);
			return FALSE;
		}
	}

	// zero new memory
	memset((void *)m_pbShMem, 0, dwSize);

	// setup counter types to default, note that the counters
	// start at index 1 in SHM
	PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)m_pbShMem;
	_ASSERT(pCounterBlock);

    for (DWORD i = 0; i < MAX_COUNTERS; i++)
    {
        PDWORD pdwCounter = ((PDWORD) pCounterBlock) + i;
        _ASSERT(pdwCounter);
        *pdwCounter = (LONG)PERF_TYPE_ZERO;
    }
    isInited = TRUE;

	LeaveCriticalSection(&mInitLock);
	return isInited;
}

//-------------------------------------------------------------
//
// incrementCounter
//
//-------------------------------------------------------------
BOOL PassportPerfMon::incrementCounter ( const DWORD &dwType, LPCSTR lpszInstanceName  )
{
	if (!isInited)
	{
		return FALSE;
	}
	
	_ASSERT( (dwType >= 0) && (dwType < MAX_COUNTERS));
	_ASSERT(m_pbShMem);
	
	DWORD dwIndex = ((dwType == 0) ? 0 : (DWORD)(dwType/2));
	
	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);
	pb += MAX_COUNTERS * sizeof(DWORD);
	
	// if lpszInstanceName == NULL, select the first datablock after
	// the first INSTANCE_DATA, else iterate until we find the
	// right instance name
	// TBD insert thread locking
	for (DWORD i = 0; i < MAX_INSTANCES; i++)
	{
		INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
		_ASSERT(pInst);
		pb += sizeof(INSTANCE_DATA);

        //TODO** mikeguo -- tune up this lookup -- too expensive -- check the first character or something
		if (lpszInstanceName == NULL
			|| (pInst->active && strcmp(pInst->szInstanceName, lpszInstanceName) == 0)	)
		{
			
			PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)pb;
			_ASSERT(pCounterBlock);
			PDWORD pdwCounter = ((PDWORD) pCounterBlock) + dwIndex;
			_ASSERT(pdwCounter);

            InterlockedIncrement((long *)pdwCounter);
			return TRUE;
		}
		pb += (MAX_COUNTERS * sizeof(DWORD)); 
	}
	return FALSE;
}


//-------------------------------------------------------------
//
// decrementCounter
//
//-------------------------------------------------------------
BOOL PassportPerfMon::decrementCounter ( const DWORD &dwType, LPCSTR lpszInstanceName )
{
	if (!isInited)
	{
		return FALSE;
	}

	_ASSERT( (dwType >= 0) && (dwType < MAX_COUNTERS));	
	_ASSERT(m_pbShMem);

	DWORD dwIndex = ((dwType == 0) ? 0 : (DWORD)(dwType/2));

	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);
	pb += MAX_COUNTERS * sizeof(DWORD);
	
	// if lpszInstanceName == NULL, select the first datablock after
	// the first INSTANCE_DATA, else iterate until we find the
	// right instance name
	// TBD insert thread locking
	for (DWORD i = 0; i < MAX_INSTANCES; i++)
	{
		INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
		_ASSERT(pInst);
		pb += sizeof(INSTANCE_DATA);
		if (lpszInstanceName == NULL
			|| (pInst->active && strcmp(pInst->szInstanceName, lpszInstanceName) == 0)	)
		{
			PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)pb;
			_ASSERT(pCounterBlock);
			PDWORD pdwCounter = ((PDWORD) pCounterBlock) + dwIndex;
			_ASSERT(pdwCounter);

            InterlockedDecrement((long *)pdwCounter);

            return TRUE;

		}
		pb += (MAX_COUNTERS * sizeof(DWORD));
	}
	return FALSE;
}


//-------------------------------------------------------------
//
// setCounter
//
//-------------------------------------------------------------
BOOL PassportPerfMon::setCounter ( const DWORD &dwType,
										 const DWORD &dwValue, 
										 LPCSTR lpszInstanceName )
{
	if (!isInited)
	{
		return FALSE;
	}

	_ASSERT( (dwType >= 0) && (dwType < MAX_COUNTERS));	
	_ASSERT(m_pbShMem);

	DWORD dwIndex = ((dwType == 0) ? 0 : (DWORD)(dwType/2));

	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);
	pb += MAX_COUNTERS * sizeof(DWORD);
	
	// if lpszInstanceName == NULL, select the first datablock after
	// the first INSTANCE_DATA, else iterate until we find the
	// right instance name
	// TBD insert thread locking
	for (DWORD i = 0; i < MAX_INSTANCES; i++)
	{
		INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
		_ASSERT(pInst);
		pb += sizeof(INSTANCE_DATA);
		if (lpszInstanceName == NULL
			|| (pInst->active && strcmp(pInst->szInstanceName, lpszInstanceName) == 0)	)
		{
			
			PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)pb;
			_ASSERT(pCounterBlock);
			PDWORD pdwCounter = ((PDWORD) pCounterBlock) + dwIndex;
			_ASSERT(pdwCounter);

            InterlockedExchange((LPLONG) pdwCounter, (LONG)dwValue);
            return TRUE;

		}
		pb += (MAX_COUNTERS * sizeof(DWORD));
	}
	return FALSE;
}


//-------------------------------------------------------------
//
// 	getCounterValue
//
//-------------------------------------------------------------
BOOL PassportPerfMon::getCounterValue ( DWORD &dwValue, 
									   const DWORD &dwType, LPCSTR lpszInstanceName )
{
	if (!isInited)
	{
		dwValue = 0;
		return FALSE;
	}

	_ASSERT( (dwType >= 0) && (dwType < MAX_COUNTERS));	
	_ASSERT(m_pbShMem);

	DWORD dwIndex = ((dwType == 0) ? 0 : (DWORD)(dwType/2));

	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);
	pb += MAX_COUNTERS * sizeof(DWORD);
	
	// if lpszInstanceName == NULL, select the first datablock after
	// the first INSTANCE_DATA, else iterate until we find the
	// right instance name
	// TBD insert thread locking
	for (DWORD i = 0; i < MAX_INSTANCES; i++)
	{
		INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
		_ASSERT(pInst);
		pb += sizeof(INSTANCE_DATA);
		if (lpszInstanceName == NULL
			|| (pInst->active && strcmp(pInst->szInstanceName, lpszInstanceName) == 0)	)
		{
			PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)pb;
			_ASSERT(pCounterBlock);
			PDWORD pdwCounter = ((PDWORD) pCounterBlock) + dwIndex;
			_ASSERT(pdwCounter);

            //
            // The counter is aligned with DWORD. Simple read does not need
            // the sync operation here.
            //

            dwValue = (*pdwCounter);
            return TRUE;

		}
		pb += (MAX_COUNTERS * sizeof(DWORD));
	}
	return TRUE;
}

//-------------------------------------------------------------
//
// setCounterType	
//
//-------------------------------------------------------------
BOOL PassportPerfMon::setCounterType ( const DWORD &dwType, 
				const PassportPerfInterface::COUNTER_SAMPLING_TYPE &counterSampleType)
{
	if (!isInited)
	{
		return FALSE;
	}

	_ASSERT( (dwType >= 0) && (dwType < MAX_COUNTERS));	
	_ASSERT(m_pbShMem);
	
	DWORD dwIndex = ((dwType == 0) ? 0 : (DWORD)(dwType/2));
	DWORD dwPerfType = 0;
	
	switch ( counterSampleType )
	{
	case (PassportPerfInterface::COUNTER_COUNTER):
		dwPerfType = PERF_COUNTER_COUNTER;
		break;
	case (PassportPerfInterface::AVERAGE_TIMER):
		dwPerfType = PERF_AVERAGE_TIMER;
		break;
	case (PassportPerfInterface::COUNTER_DELTA):
		dwPerfType = PERF_COUNTER_DELTA;
		break;
	case (PassportPerfInterface::COUNTER_RAWCOUNT):
	case (PassportPerfInterface::COUNTER_UNDEFINED):
	default:
		dwPerfType = PERF_COUNTER_RAWCOUNT;
		break;
	}

	PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)m_pbShMem;
	_ASSERT(pCounterBlock);
	PDWORD pdwCounter = ((PDWORD) pCounterBlock) + (dwIndex-1);
	_ASSERT(pdwCounter);


    InterlockedExchange((LPLONG) pdwCounter, (LONG)dwPerfType);
		
	return FALSE;	
}

//-------------------------------------------------------------
//
// getCounterType	
//
//-------------------------------------------------------------
PassportPerfInterface::COUNTER_SAMPLING_TYPE PassportPerfMon::getCounterType(
				const DWORD &dwType ) const
{
	if (!isInited)
	{
		return PassportPerfInterface::COUNTER_UNDEFINED;
	}

	_ASSERT( (dwType >= 0) && (dwType < MAX_COUNTERS));	
	_ASSERT(m_pbShMem);
	
	DWORD dwIndex = ((dwType == 0) ? 0 : (DWORD)(dwType/2));
	DWORD dwPerfType = 0;

	PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)m_pbShMem;
	PDWORD pdwCounter = ((PDWORD) pCounterBlock) + (dwIndex-1);
	_ASSERT(pdwCounter);

    //
    //  Simple read does not need the sync op here
    //

    dwPerfType = (*pdwCounter);

	switch ( dwPerfType )
	{
	case (PERF_COUNTER_COUNTER):
		return PassportPerfInterface::COUNTER_COUNTER;
	case (PERF_AVERAGE_TIMER):
		return PassportPerfInterface::AVERAGE_TIMER;
	case (PERF_COUNTER_DELTA):
		return PassportPerfInterface::COUNTER_DELTA;
	case (PERF_COUNTER_RAWCOUNT):
		return PassportPerfInterface::COUNTER_RAWCOUNT;
	default:
		return PassportPerfInterface::COUNTER_UNDEFINED;
	}

}

//-------------------------------------------------------------
//
// addInstance	
//
//-------------------------------------------------------------
BOOL PassportPerfMon::addInstance( LPCSTR lpszInstanceName )
{
	if (!isInited || lpszInstanceName == NULL)
	{
		return FALSE;
	}

    if (strlen(lpszInstanceName) >= sizeof(INSTANCENAME)) {

        //
        // Why not TCHAR here?
        //

        return FALSE;

    }

	_ASSERT(m_pbShMem);
	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);

	pb += MAX_COUNTERS * sizeof(DWORD);

	
	DWORD dw = WaitForSingleObject(m_hMutex,INFINITE);
	if (dw == WAIT_OBJECT_0)
	{
		// find if the instance already exists, if so fail
		for (DWORD i = 0; i < MAX_INSTANCES; i++)
		{
			INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
			_ASSERT(pInst);
			if (pInst->active)
			{
				if (strcmp(pInst->szInstanceName, lpszInstanceName) == 0)
				{
					ReleaseMutex(m_hMutex);
					return FALSE;
				}
			}
            pb += sizeof(INSTANCE_DATA) + (MAX_COUNTERS * sizeof(DWORD));
        }
		
		// insert the instance in the first available slot
		pb = (BYTE*)m_pbShMem;
		_ASSERT(pb);
		pb += MAX_COUNTERS * sizeof(DWORD);	
		for (i = 0; i < MAX_INSTANCES; i++)
		{
			INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
			_ASSERT(pInst);
			if (!pInst->active)
			{
                strcpy(pInst->szInstanceName, lpszInstanceName);
                pInst->active = TRUE;
                InterlockedIncrement(&dwNumInstances);
                pb += sizeof(INSTANCE_DATA);
                memset(pb,0,(MAX_COUNTERS * sizeof(DWORD)));
                ReleaseMutex(m_hMutex);
                return TRUE;
			}
			pb += sizeof(INSTANCE_DATA) + (MAX_COUNTERS * sizeof(DWORD));
		}
		
		// didn't find it, fail
		ReleaseMutex(m_hMutex);
		return FALSE;
	}
	else
	{
		ReleaseMutex(m_hMutex);
		return FALSE;
	}



}


//-------------------------------------------------------------
//
// deleteInstance	
//
//-------------------------------------------------------------
BOOL PassportPerfMon::deleteInstance( LPCSTR lpszInstanceName )
{
	if (!isInited || lpszInstanceName == NULL)
	{
		return FALSE;
	}

	_ASSERT(m_pbShMem);
	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);

	pb += MAX_COUNTERS * sizeof(DWORD);
	
	DWORD dw = WaitForSingleObject(m_hMutex,INFINITE);
	if (dw == WAIT_OBJECT_0)
	{
		// find if the instance already exists, if so set it inactive
		for (DWORD i = 0; i < MAX_INSTANCES; i++)
		{
			INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
			_ASSERT(pInst);
			if (pInst->active && strcmp(pInst->szInstanceName, lpszInstanceName) == 0)
			{
				pInst->active = FALSE;
				InterlockedDecrement(&dwNumInstances);
				// zero the data
				pb += sizeof(INSTANCE_DATA);
				memset(pb,0,(MAX_COUNTERS * sizeof(DWORD)));
				ReleaseMutex(m_hMutex);
				return TRUE;
			}
			pb += sizeof(INSTANCE_DATA)+(MAX_COUNTERS * sizeof(DWORD));
		}
		
		// didn't find it, fail
		ReleaseMutex(m_hMutex);
		return FALSE;
	}
	else
	{
		ReleaseMutex(m_hMutex);
		return FALSE;
	}
}


//-------------------------------------------------------------
//
// hasInstances	
//
//-------------------------------------------------------------
BOOL PassportPerfMon::hasInstances( void ) 
{
	DWORD dwNum = (DWORD)InterlockedExchangeAdd(&dwNumInstances,0);
	if (dwNum > 0)
		return TRUE;
	else
		return FALSE;
}

//-------------------------------------------------------------
//
// 	numInstances
//
//-------------------------------------------------------------
DWORD PassportPerfMon::numInstances( void ) 
{
	DWORD rv = (DWORD)InterlockedExchangeAdd(&dwNumInstances,0);
	return rv;
}


//-------------------------------------------------------------
//
// instanceExists
//
//-------------------------------------------------------------
BOOL PassportPerfMon::instanceExists ( LPCSTR lpszInstanceName )
{
	
	if (!isInited || lpszInstanceName == NULL)
	{
		return FALSE;
	}

	_ASSERT(m_pbShMem);
	BYTE* pb = (BYTE*)m_pbShMem;
	_ASSERT(pb);

	DWORD dw = WaitForSingleObject(m_hMutex,INFINITE);
	if (dw == WAIT_OBJECT_0)
	{
		pb += MAX_COUNTERS * sizeof(DWORD);
		for (DWORD i = 0; i < MAX_INSTANCES; i++)
		{
			INSTANCE_DATA * pInst = (INSTANCE_DATA *)pb;
			_ASSERT(pInst);
			if (pInst->active && strcmp(pInst->szInstanceName, lpszInstanceName) == 0)
			{
				ReleaseMutex(m_hMutex);
				return TRUE;
			}
			pb += sizeof(INSTANCE_DATA) + (MAX_COUNTERS * sizeof(DWORD));
		}
		
		// didn't find it, fail
		ReleaseMutex(m_hMutex);
		return FALSE;
	}
	else
	{
		ReleaseMutex(m_hMutex);
		return FALSE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\passportperfmon.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportPerfMon.h

    Abstract:

		Performance Monitor Class Implementation

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

		- added Instance support 1-Oct-98
--*/

#if !defined(PASSPORTPERFMON_H)
#define PASSPORTPERFMON_H

#include <windows.h>
#include "PassportSharedMemory.h"
#include "PassportPerfInterface.h"

class PassportPerfMon : public PassportPerfInterface, public PassportSharedMemory  
{
public:
	PassportPerfMon();
	~PassportPerfMon ();

	BOOL init ( LPCTSTR lpcPerfObjectName );

	// get set counter type
	BOOL setCounterType ( const DWORD &dwType, 
				const PassportPerfInterface::COUNTER_SAMPLING_TYPE &counterSampleType); 
	PassportPerfInterface::COUNTER_SAMPLING_TYPE getCounterType( 
				const DWORD &dwType  ) const;

	// adding/subtracting an instance to this object 
	BOOL addInstance ( LPCSTR lpszInstanceName );
	BOOL deleteInstance ( LPCSTR lpszInstanceName );
	BOOL instanceExists ( LPCSTR lpszInstanceName );
	BOOL hasInstances ( void );
	DWORD numInstances ( void );

	// counters:  note if hasInstances() is TRUE, then you must 
	// give the instance name
	BOOL incrementCounter ( const DWORD &dwType, LPCSTR lpszInstanceName = NULL );
	BOOL decrementCounter ( const DWORD &dwType, LPCSTR lpszInstanceName = NULL );
	BOOL setCounter ( 
				const DWORD &dwType, 
				const DWORD &dwValue, 
				LPCSTR lpszInstanceName = NULL );
	BOOL getCounterValue ( 
				DWORD &dwValue,
				const DWORD &dwType,
				LPCSTR lpszInstanceName = NULL );

private:
	BOOL isInited;
	LONG dwNumInstances;
	CRITICAL_SECTION mInitLock;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\passportperf.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportPerf.h

    Abstract:

		Perormance Objects Definition

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

		- added multi-object support 1-Oct-98
--*/

#if !defined(PASSPORTPERF_H)
#define PASSPORTPERF_H

#include <windows.h>
#include <winperf.h>
#include <string.h>
#include <tchar.h>
#include "PerfSharedMemory.h"

//
//  Function Prototypes//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.//
PM_OPEN_PROC		OpenPassportPerformanceData;
PM_COLLECT_PROC		CollectPassportPerformanceData;
PM_CLOSE_PROC		ClosePassportPerformanceData;

//
// defs
//
#define PASSPORT_PERF_KEY		"SYSTEM\\CurrentControlSet\\Services\\" 
const TCHAR PASSPORT_PERF_OPEN[] = _T("OpenPassportPerformanceData");
const TCHAR PASSPORT_PERF_COLLECT[] = _T("CollectPassportPerformanceData");
const TCHAR PASSPORT_PERF_CLOSE[] = _T("ClosePassportPerformanceData");

// these two should be the same as in PassportPerfInterface's
// MAX_INSTANCE_NAME and MAX_COUNTERS
#define MAX_INSTANCE_NAME_LENGTH 32
#define MAX_NUMBER_COUNTERS		128

typedef CHAR INSTANCENAME[MAX_INSTANCE_NAME_LENGTH];
struct INSTANCE_DATA
{
	BOOL						active;
	INSTANCENAME				szInstanceName;
};

typedef struct _PassportDefaultCounterType 
{
	DWORD	dwIndex;
	DWORD	dwDefaultType;
} PassportDefaultCounterType;

#define PASSPORT_NAME_SIZE		512
#define MAX_PASSPORT_OBJECTS	10

typedef struct _PassportObjectData
{
	TCHAR		szPassportName[PASSPORT_NAME_SIZE];
	const TCHAR	*lpcszPassportPerfBlock;
	TCHAR		szPassportPerfDll[PASSPORT_NAME_SIZE];
	TCHAR		szPassportPerfIniFile[PASSPORT_NAME_SIZE];
	BOOL		active;
	DWORD		dwNumDefaultCounterTypes;
	PassportDefaultCounterType	defaultCounterTypes[MAX_NUMBER_COUNTERS];
	PerfSharedMemory *PSM;
} PassportObjectData;


#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\passportsharedmemory.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportSharedMemory.h

    Abstract:

		Shared Memory class

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

--*/
#if !defined(PASSPORTSHAREDMEMORY_H)
#define PASSPORTSHAREDMEMORY_H

#include <windows.h>

class PassportExport PassportSharedMemory
{
public:
	PassportSharedMemory();
	virtual ~PassportSharedMemory();

	BOOL CreateSharedMemory ( 
					const DWORD &dwMaximumSizeHigh, 
					const DWORD &dwMaximunSizeLow,
					LPCTSTR lpcName,
					BOOL	useMutex = TRUE);

	BOOL OpenSharedMemory( LPCTSTR lpcName,
					BOOL	useMutex = TRUE);
	
	void CloseSharedMemory( void );

protected:
	
	// handle and pointer for the shared memory
	HANDLE						m_hShMem;
	PBYTE						m_pbShMem;
	BOOL						m_bInited;
	HANDLE						m_hMutex;
	BOOL						m_bUseMutex;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\perfutils.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PerfUtils.h

    Abstract:

		Perfmon utils

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

--*/

#if !defined(AFX_PERFUTILS_H__968D9AF5_3EBF_11D2_9F35_00C04F8E7AED__INCLUDED_)
#define AFX_PERFUTILS_H__968D9AF5_3EBF_11D2_9F35_00C04F8E7AED__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3


#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

BOOL IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
);

DWORD GetQueryType (IN LPWSTR lpValue);

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\pmcounters\msppcntr.h ===
//
//  testcounters.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values fo the device they belong to, 
//  in order to determine the  absolute location of the counter and 
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the 
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define PMCOUNTERS_PERF_OBJ			0

#define PM_REQUESTS_SEC             2
#define PM_REQUESTS_TOTAL           4
#define PM_AUTHSUCCESS_SEC          6
#define PM_AUTHSUCCESS_TOTAL        8
#define PM_AUTHFAILURE_SEC          10
#define PM_AUTHFAILURE_TOTAL        12
#define PM_FORCEDSIGNIN_SEC         14
#define PM_FORCEDSIGNIN_TOTAL       16
#define PM_PROFILEUPDATES_SEC       18
#define PM_PROFILEUPDATES_TOTAL     20
#define PM_INVALIDREQUESTS_SEC      22
#define PM_INVALIDREQUESTS_TOTAL    24
#define PM_PROFILECOMMITS_SEC       26
#define PM_PROFILECOMMITS_TOTAL     28
#define PM_VALIDPROFILEREQ_SEC      30
#define PM_VALIDPROFILEREQ_TOTAL    32
#define PM_NEWCOOKIES_SEC           34
#define PM_NEWCOOKIES_TOTAL         36
#define PM_VALIDREQUESTS_SEC        38
#define PM_VALIDREQUESTS_TOTAL      40
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\perfsharedmemory.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PerfSharedMemory.h

    Abstract:

		Class to hold per-object perfmon specific functions

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

--*/

#if !defined(AFX_PERFSHAREDMEMORY_H)
#define AFX_PERFSHAREDMEMORY_H

#include "PassportSharedMemory.h"
#include "WinPerf.h"
#include "PassportPerfInterface.h"

class PassportExport PerfSharedMemory : public PassportSharedMemory  
{
public:
	PerfSharedMemory();
	virtual ~PerfSharedMemory();

	BOOL initialize( const DWORD &dwNumCounters, 
					 const DWORD &dwFirstCounter, 
					 const DWORD &dwFirstHelp);

    VOID setDefaultCounterType (
					 const DWORD dwIndex,
					 const DWORD dwType );

	BOOL checkQuery ( const LPWSTR lpValueName );

	ULONG spaceNeeded ( void );

	BOOL writeData ( LPVOID	*lppData,
					 LPDWORD lpNumObjectTypes );

private:
	DWORD						m_dwNumCounters;
	PERF_OBJECT_TYPE			m_Object;	
	PERF_COUNTER_DEFINITION		m_Counter[PassportPerfInterface::MAX_COUNTERS];	// array of counter defintions

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\perfsharedmemory.cpp ===
#define _PassportExport_
#include "PassportExport.h"

#include "PerfSharedMemory.h"
#include "PerfUtils.h"
#include "PassportPerf.h"
#include "PassportPerfInterface.h"


#include <crtdbg.h>

//-------------------------------------------------------------
//
// PerfSharedMemory
//
//-------------------------------------------------------------
PerfSharedMemory::PerfSharedMemory() : PassportSharedMemory()
{
    m_dwNumCounters = 0;
}


//-------------------------------------------------------------
//
// PerfSharedMemory
//
//-------------------------------------------------------------

PerfSharedMemory::~PerfSharedMemory()
{

}


//-------------------------------------------------------------
//
// initialize
//
//-------------------------------------------------------------
BOOL PerfSharedMemory::initialize(
                        const DWORD &dwNumCounters,
                        const DWORD &dwFirstCounter,
                        const DWORD &dwFirstHelp)
{
    
    if ( dwNumCounters <= 0 || dwNumCounters >= PassportPerfInterface::MAX_COUNTERS)
        return FALSE;

    m_dwNumCounters = dwNumCounters;


    // 2. initialize the PERF_OBJECT_TYPE
    m_Object.NumInstances = PassportPerfInterface::MAX_INSTANCES;
    m_Object.TotalByteLength = 0;
    m_Object.DefinitionLength = sizeof(PERF_OBJECT_TYPE)
                                + (dwNumCounters * sizeof(PERF_COUNTER_DEFINITION));
    m_Object.HeaderLength = sizeof(PERF_OBJECT_TYPE);
    m_Object.ObjectNameTitleIndex = dwFirstCounter;
    m_Object.ObjectNameTitle = 0;
    m_Object.ObjectHelpTitleIndex = dwFirstHelp;
    m_Object.ObjectHelpTitle = 0;
    m_Object.DetailLevel = PERF_DETAIL_NOVICE;
    m_Object.NumCounters = dwNumCounters;
    m_Object.DefaultCounter = 0;
    m_Object.CodePage = 0;

    // 3. initialize each counter
    for (DWORD i = 0; i < dwNumCounters; i++)
    {
      m_Counter[i].ByteLength = sizeof(PERF_COUNTER_DEFINITION);
      m_Counter[i].CounterNameTitleIndex = dwFirstCounter + ((i+1) * 2);
      m_Counter[i].CounterNameTitle = 0;
      m_Counter[i].CounterHelpTitleIndex = dwFirstHelp + ((i+1) * 2);
      m_Counter[i].CounterHelpTitle = 0;
      m_Counter[i].DefaultScale = 0;
      m_Counter[i].DetailLevel = PERF_DETAIL_NOVICE;
      m_Counter[i].CounterType = PERF_COUNTER_RAWCOUNT; // PERF_COUNTER_COUNTER;
      m_Counter[i].CounterSize = sizeof(DWORD);
      m_Counter[i].CounterOffset = sizeof(PERF_COUNTER_BLOCK) + (i * sizeof(DWORD));
    }

    return TRUE;
}



//-------------------------------------------------------------
//
// setDefaultCounterType
//
//-------------------------------------------------------------
VOID PerfSharedMemory::setDefaultCounterType (
                     const DWORD dwIndex,
                     const DWORD dwType )
{
    _ASSERT( (dwIndex >= 0) && (dwIndex < PassportPerfInterface::MAX_COUNTERS));

    // indexes start at one in SHM, but in this object they start at 0
    DWORD dwRealIndex = ((dwIndex == 0) ? 0 : (DWORD)(dwIndex/2)-1);
    m_Counter[dwRealIndex].CounterType = dwType;
    return;
}


//-------------------------------------------------------------
//
// checkQuery
//
//-------------------------------------------------------------
BOOL PerfSharedMemory::checkQuery ( const LPWSTR lpValueName )
{
    DWORD dwQueryType = 0;

    dwQueryType = GetQueryType (lpValueName);   
    if (dwQueryType == QUERY_FOREIGN)
    {
        // this routine does not service requests for data from
        // Non-NT computers     
        return FALSE;   
    }

    if (dwQueryType == QUERY_ITEMS)
    {
        if ( !(IsNumberInUnicodeList (m_Object.ObjectNameTitleIndex, lpValueName)))
        {
            
            // request received for data object not provided by this routine
            return FALSE;
        }   
    }
    
    return TRUE;
}


//-------------------------------------------------------------
//
// spaceNeeded
//
//-------------------------------------------------------------
ULONG PerfSharedMemory::spaceNeeded ( void )
{
    DWORD dwTotalInstanceLength = 0;
    m_Object.NumInstances = 0;

    // --------------------------------
    //  count the instances
    if (m_pbShMem != NULL)
    {
        BYTE* pShm = (BYTE *)m_pbShMem;
        if (pShm != NULL)
        {   
            pShm += PassportPerfInterface::MAX_COUNTERS * sizeof(DWORD);
            
            if (!m_bUseMutex
                || WaitForSingleObject(m_hMutex,INFINITE) == WAIT_OBJECT_0)
            {
                for (DWORD i = 0; i < PassportPerfInterface::MAX_INSTANCES; i++)
                {
                    INSTANCE_DATA * pInst = (INSTANCE_DATA *)pShm;
                    _ASSERT(pInst);
                    if (pInst->active)
                    {
                        m_Object.NumInstances++;
                        dwTotalInstanceLength += (strlen(pInst->szInstanceName)+1) * sizeof(WCHAR);
                    }
                    pShm += sizeof(INSTANCE_DATA) +
                        (PassportPerfInterface::MAX_COUNTERS * sizeof(DWORD));
                }
                if (m_bUseMutex)
                    ReleaseMutex(m_hMutex);
            }
            else
            {
                //
                // The return value is ULONG not FALSE.
                // Is 0 correct here? At least same value as the old FALSE.
                //

                ReleaseMutex(m_hMutex);
                return 0;
            }
            
        }
    }
    
    // --------------------------------
    //  calculate the ByteLength in the Object structure
    if (m_Object.NumInstances == 0)
    {
        m_Object.NumInstances = PERF_NO_INSTANCES;
        m_Object.TotalByteLength = sizeof(PERF_OBJECT_TYPE)
                                + (m_dwNumCounters * sizeof(PERF_COUNTER_DEFINITION))
                                + sizeof(PERF_COUNTER_BLOCK)
                                + (m_dwNumCounters * sizeof(DWORD));
    }
    else
    {
        m_Object.TotalByteLength = sizeof(PERF_OBJECT_TYPE)
                                + (m_dwNumCounters * sizeof(PERF_COUNTER_DEFINITION))
                                + (m_Object.NumInstances *
                                                (sizeof(PERF_INSTANCE_DEFINITION) +
                                                 // note: INSTANCENAME is next in the SHM
                                                 sizeof(PERF_COUNTER_BLOCK) +
                                                 (m_dwNumCounters * sizeof(DWORD)) ))
                                + dwTotalInstanceLength;

    }

    //  align on 8 bytes boundary ...
    if (m_Object.TotalByteLength & 7)
    {
        m_Object.TotalByteLength += 8;
        m_Object.TotalByteLength &= ~7;
    }

    return m_Object.TotalByteLength;
}

//-------------------------------------------------------------
//
// writeData
//
//-------------------------------------------------------------
BOOL PerfSharedMemory::writeData (
                                  LPVOID    *lppData,
                                  LPDWORD lpcbTotalBytes )
{
    BYTE*               pb = NULL;
    DWORD               dwBytes = 0;
    
    // --------------------------------
    // 1. find the active number of instances
    //    (may have been done already)
    if (m_Object.TotalByteLength == 0)
        spaceNeeded();
    
    pb = (BYTE*) *lppData;
    
    // --------------------------------
    // 2. copy the Object structure
    CopyMemory( pb, &m_Object, sizeof(PERF_OBJECT_TYPE) );
    pb += sizeof(PERF_OBJECT_TYPE);
    dwBytes += sizeof(PERF_OBJECT_TYPE);
    
    if (!m_bUseMutex
        || WaitForSingleObject(m_hMutex,INFINITE) == WAIT_OBJECT_0)
    {
        // --------------------------------
        // 3. read the counter types from SHM
        if ( m_pbShMem != NULL )
        {
            DWORD dwPerfType = 0;
            BYTE * pShm = (BYTE*)m_pbShMem;
            _ASSERT(pShm);
            
            for (DWORD j = 0; j < m_dwNumCounters; j++)
            {
                PDWORD pdwCounter = ((PDWORD) pShm) + j;
                _ASSERT(pdwCounter);
                // only reset the counter if it has a defined value
                // or if it has changed
                if (*pdwCounter != PERF_TYPE_ZERO
                    && m_Counter[j].CounterType != *pdwCounter)
                    m_Counter[j].CounterType = (*pdwCounter);
            }
            
        }
        // --------------------------------
        // 4. copy the counters
        for (DWORD i = 0; i < m_dwNumCounters; i++)
        {
            CopyMemory( pb, &(m_Counter[i]),sizeof(PERF_COUNTER_DEFINITION));
            pb += sizeof(PERF_COUNTER_DEFINITION);
            dwBytes += sizeof(PERF_COUNTER_DEFINITION);
        }
        
        // --------------------------------
        // 5. if SHM if null, then just dump out all
        //    zeroes for the counters
        if ( m_pbShMem == NULL )
        {
            // copy the number of counters in the counter block
            PERF_COUNTER_BLOCK counterBlock;
            counterBlock.ByteLength = sizeof(PERF_COUNTER_BLOCK) +
                (m_dwNumCounters * sizeof(DWORD));
            CopyMemory( pb, &counterBlock, sizeof(PERF_COUNTER_BLOCK));
            pb += sizeof(PERF_COUNTER_BLOCK);
            dwBytes += sizeof(PERF_COUNTER_BLOCK);
            for (DWORD j = 1; j <= m_dwNumCounters; j++)
            {
                DWORD val = 0;
                CopyMemory( pb, &val, sizeof(DWORD));
                pb += sizeof(DWORD);
                dwBytes += sizeof(DWORD);
            }
        }
        // --------------------------------
        // 6. if object has no instances, then read just the first
        //    section of data,
        else if (m_Object.NumInstances == PERF_NO_INSTANCES)
        {
            _ASSERT(m_pbShMem);
            BYTE * pShm = (BYTE*)m_pbShMem;
            _ASSERT(pShm);
            pShm += (PassportPerfInterface::MAX_COUNTERS * sizeof(DWORD));
            pShm += sizeof(INSTANCE_DATA);
            _ASSERT(pShm);
            // copy the number of counters in the counter block
            PERF_COUNTER_BLOCK counterBlock;
            counterBlock.ByteLength = sizeof(PERF_COUNTER_BLOCK) +
                (m_dwNumCounters * sizeof(DWORD));
            CopyMemory( pb, &counterBlock, sizeof(PERF_COUNTER_BLOCK));
            pb += sizeof(PERF_COUNTER_BLOCK);
            dwBytes += sizeof(PERF_COUNTER_BLOCK);
            
            PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)pShm;
            _ASSERT(pCounterBlock);
            
            for (DWORD j = 1; j <= m_dwNumCounters; j++)
            {
                PDWORD pdwCounter = ((PDWORD) pCounterBlock) + j;
                _ASSERT(pdwCounter);
                DWORD val = *pdwCounter;
                CopyMemory( pb, &val, sizeof(DWORD));
                pb += sizeof(DWORD);
                dwBytes += sizeof(DWORD);
            }
            
        }
        // --------------------------------
        // 7. get and write all instance data
        else
        {
            _ASSERT(m_pbShMem);
            BYTE * pShm = (BYTE*)m_pbShMem;
            _ASSERT(pShm);
            pShm += (PassportPerfInterface::MAX_COUNTERS * sizeof(DWORD));
            DWORD dwInstanceIndex = 0;
            
            for (i = 0; i < (DWORD)m_Object.NumInstances; i++)
            {
                PERF_INSTANCE_DEFINITION instDef;
                PERF_COUNTER_BLOCK perfCounterBlock;
                BOOL gotInstance = FALSE;
                INSTANCE_DATA * pInst = NULL;
                WCHAR   wszName[MAX_PATH];
                
                // 7a. get the instance name from the next active instance
                //     in SHM
                for (DWORD i = dwInstanceIndex;
                i < PassportPerfInterface::MAX_INSTANCES && !gotInstance;
                i++)
                {
                    pInst = (INSTANCE_DATA *)pShm;
                    _ASSERT(pInst);
                    pShm += sizeof(INSTANCE_DATA);
                    if (pInst->active)
                    {
                        dwInstanceIndex = i + 1;
                        gotInstance = TRUE;
                        
                    }
                    else
                    {
                        pShm += (PassportPerfInterface::MAX_COUNTERS * sizeof(DWORD));
                    }
                }
                
                if (!gotInstance || pInst == NULL)
                    return FALSE;
                
                // 7b. create the instace Definition and
                //     copy it (also get the instance name)
                instDef.ParentObjectTitleIndex = 0;//m_Object.ObjectNameTitleIndex + 2*i;
                instDef.ParentObjectInstance = 0; // ????
                instDef.UniqueID = PERF_NO_UNIQUE_ID;
                instDef.NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
                //  Build UNICODE instance name
                if (!MultiByteToWideChar( CP_ACP,
                    MB_PRECOMPOSED,
                    pInst->szInstanceName,
                    strlen(pInst->szInstanceName)+1,
                    wszName,
                    MAX_PATH))
                {
                    wszName[0] = 0;
                }
                instDef.NameLength = (lstrlenW( wszName ) + 1) * sizeof(WCHAR);
                instDef.ByteLength = sizeof(PERF_INSTANCE_DEFINITION)
                    + instDef.NameLength;
                CopyMemory( pb, &instDef, sizeof(PERF_INSTANCE_DEFINITION) );
                pb += sizeof(PERF_INSTANCE_DEFINITION);
                dwBytes += sizeof(PERF_INSTANCE_DEFINITION);
                
                // 7c. copy the instance name
                CopyMemory(pb, wszName, instDef.NameLength);
                pb += instDef.NameLength;
                dwBytes += instDef.NameLength;
                
                // 7d. copy the counterblock
                perfCounterBlock.ByteLength = sizeof(PERF_COUNTER_BLOCK)
                    + (m_dwNumCounters * sizeof(DWORD));
                CopyMemory( pb, &perfCounterBlock, sizeof(PERF_COUNTER_BLOCK));
                pb += sizeof(PERF_COUNTER_BLOCK);
                dwBytes += sizeof(PERF_COUNTER_BLOCK);
                
                // 7e. copy the DWORDs themselves
                PPERF_COUNTER_BLOCK pCounterBlock = (PPERF_COUNTER_BLOCK)pShm;
                DWORD val = 0;
                for (DWORD j = 1; j <= m_dwNumCounters; j++)
                {
                    if (m_pbShMem != NULL)
                    {
                        PDWORD pdwCounter = ((PDWORD) pCounterBlock) + j;
                        val = *pdwCounter;
                    }
                    CopyMemory( pb, &val, sizeof(DWORD));
                    pb += sizeof(DWORD);
                    dwBytes += sizeof(DWORD);
                }
                pShm += (PassportPerfInterface::MAX_COUNTERS * sizeof(DWORD));
            } // end for ( i = ...)
        } // end else (instances exist)
        
        if (m_bUseMutex)
            ReleaseMutex(m_hMutex);
    }
    else
    {
        ReleaseMutex(m_hMutex);
        return FALSE;
    }
    
    //
    //  8 byte alignment
    while (dwBytes%8 != 0)
    {
        (dwBytes)++;
        pb++;
    }

    *lppData = (void*) pb;//++pb;
    *lpcbTotalBytes = dwBytes;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\perfutils.cpp ===
#include <windows.h>
#include <string.h>
#include <winperf.h>
#include "PerfUtils.h"


WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";


//-------------------------------------------------------------
//
//	helper functions pinched from MSDN 
//
//-------------------------------------------------------------
 BOOL IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;
    
    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then 
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;
            
            case DELIMITER:
                // a delimter is either the delimiter character or the 
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }
    return FALSE;
}   // IsNumberInUnicodeList

DWORD GetQueryType (IN LPWSTR lpValue)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly, 
    // then it must be an item list
    
    return QUERY_ITEMS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\pmcounters\passportperfdefs.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportPerfDefs.h

    Abstract:

		Shared Memory segment name definitions

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

		- added multi-object support 1-Oct-98
--*/
#if !defined(PASSPORTPERFDEFS_H)
#define PASSPORTPERFDEFS_H


const TCHAR PASSPORT_PERF_BLOCK[] = _T("PMCountersFileBlock");
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\perflibrary\pmcounters\passportperfobjects.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        PassportPerfObjects.h

    Abstract:

		Perormace Objects Definition

    Author:

		Christopher Bergh (cbergh) 10-Sept-1988

    Revision History:

		- added multi-object support 1-Oct-98
		- added default counter types 22-Oct-98
--*/
#if !defined(PASSPORTPERFOBJECTS_H)
#define PASSPORTPERFOBJECTS_H

#include "PassportPerfDefs.h"

#include "msppcntr.h"


// -------------------------------------------------------------------
// counter types
// 1. PERF_COUNTER_COUNTER = 1000:
    /* Divide delta by delta time.  Display suffix: "/sec" */
// 2. PERF_COUNTER_RAWCOUNT = 1001:        
    /* Indicates the data is a counter  which should not be */
    /* time averaged on display (such as an error counter on a serial line) */
    /* Display as is.  No Display Suffix.*/
// 3. PERF_AVERAGE_TIMER   = 1002:        
    /* A timer which, when divided by an average base, produces a time */
    /* in seconds which is the average time of some operation.  This */
    /* timer times total operations, and  the base is the number of opera- */
    /* tions.  Display Suffix: "sec" */
// 4. PERF_COUNTER_DELTA = 1003,        
    /*  This counter is used to display the difference from one sample */
    /*  to the next. The counter value is a constantly increasing number */
    /*  and the value displayed is the difference between the current */
    /*  value and the previous value. Negative numbers are not allowed  */
    /*  which shouldn't be a problem as long as the counter value is */
    /*  increasing or unchanged. */
//
// Note: PERF_COUNTER_RAWCOUNT is the default counter type
//     To add another counter type increment the number of counters and
//     add the counter type according to the pattern:
//      {
//          { <countername1>, <Counter Type> },
//          { <countername2}, <Counter Type> }
//      }
// -------------------------------------------------------------------

// create objects
PassportObjectData PMCountersObject = {	
	TEXT("msppcntr"),		// object name
	PASSPORT_PERF_BLOCK,		// const string, name of MemoryMapped File
	TEXT("msppcntr.dll"),	// dll name
	TEXT("msppcntr"),		// ini file name
	FALSE,						// must be FALSE
	20, 							// number of default counter types
	{ 							// default counter types
	{PM_REQUESTS_SEC,PERF_COUNTER_COUNTER}, 
	{PM_REQUESTS_TOTAL,PERF_COUNTER_RAWCOUNT}, 
	{PM_AUTHSUCCESS_SEC,PERF_COUNTER_COUNTER}, 
	{PM_AUTHSUCCESS_TOTAL,PERF_COUNTER_RAWCOUNT}, 
	{PM_AUTHFAILURE_SEC,PERF_COUNTER_COUNTER}, 
	{PM_AUTHFAILURE_TOTAL,PERF_COUNTER_RAWCOUNT}, 
	{PM_FORCEDSIGNIN_SEC,PERF_COUNTER_COUNTER}, 
	{PM_FORCEDSIGNIN_TOTAL,PERF_COUNTER_RAWCOUNT}, 
	{PM_PROFILEUPDATES_SEC,PERF_COUNTER_COUNTER}, 
	{PM_PROFILEUPDATES_TOTAL,PERF_COUNTER_RAWCOUNT}, 
	{PM_INVALIDREQUESTS_SEC,PERF_COUNTER_COUNTER}, 
	{PM_INVALIDREQUESTS_TOTAL,PERF_COUNTER_RAWCOUNT},
	{PM_PROFILECOMMITS_SEC,PERF_COUNTER_COUNTER},
	{PM_PROFILECOMMITS_TOTAL,PERF_COUNTER_RAWCOUNT},
	{PM_VALIDPROFILEREQ_SEC,PERF_COUNTER_COUNTER},
	{PM_VALIDPROFILEREQ_TOTAL,PERF_COUNTER_RAWCOUNT},
	{PM_NEWCOOKIES_SEC,PERF_COUNTER_COUNTER},
	{PM_NEWCOOKIES_TOTAL,PERF_COUNTER_RAWCOUNT},
	{PM_VALIDREQUESTS_SEC,PERF_COUNTER_COUNTER}, 
	{PM_VALIDREQUESTS_TOTAL,PERF_COUNTER_RAWCOUNT}
	},			
	NULL,						// must be null
};


// add objects to global object array
PassportObjectData *g_PObject[] = {
	&PMCountersObject
};

#define NUM_PERFMON_OBJECTS (sizeof(g_PObject) / sizeof(g_PObject[0]))


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\schema\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__70EC6ECF_9549_11D2_95DE_00C04F8E7A70__INCLUDED_)
#define AFX_STDAFX_H__70EC6ECF_9549_11D2_95DE_00C04F8E7A70__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#include <tchar.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__70EC6ECF_9549_11D2_95DE_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\schema\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	schema.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\schema\profileschema.cpp ===
/*++

  Copyright (c) 1998 Microsoft Corporation

    Module Name:

      ProfileSchema.cpp

    Abstract:

      Implementation of profile schema lookup

    Usage:

    Author:

      Max Metral (mmetral) 15-Dec-1998

    Revision History:

      15-Dec-1998 mmetral

        Created.

--*/

#include "stdafx.h"
#include "ProfileSchema.h"
#include "BstrDebug.h"
#include <winsock2.h> // u_short, u_long, ntohs, ntohl

CProfileSchema::CProfileSchema()
: m_isOk(FALSE), m_szReason(L"Uninitialized"),
  m_numAtts(0), m_atts(NULL), m_sizes(NULL), m_refs(0),
  m_readOnly(NULL), m_indexes("ProfileSchema",LK_DFLT_MAXLOAD,LK_SMALL_TABLESIZE,0),
  m_maskPos(-1)
{
}

CProfileSchema::~CProfileSchema()
{
  if (m_atts != NULL)
    delete[] m_atts;
  if (m_sizes != NULL)
    delete[] m_sizes;
  if (m_readOnly != NULL)
    delete[] m_readOnly;

  if (m_indexes.Size() > 0)
    {
      LK_RETCODE lkrc;
      const RAWBSTR2INT& htConst = m_indexes;
      RAWBSTR2INT::CConstIterator itconst;
      for (lkrc = htConst.InitializeIterator(&itconst) ;
       lkrc == LK_SUCCESS ;
       lkrc = htConst.IncrementIterator(&itconst))
    {
      FREE_BSTR(itconst.Key());
    }
      htConst.CloseIterator(&itconst);
      m_indexes.Clear();
    }
}

BOOL CProfileSchema::Read(MSXML::IXMLElementPtr &root)
{
  BOOL bResult = FALSE;
  int cAtts = 0, i;
  MSXML::IXMLElementCollectionPtr atts;
  MSXML::IXMLElementPtr pElt;
  VARIANT iAtts;

  // Type identifiers
  _bstr_t btText(L"text"), btChar(L"char"), btByte(L"byte");
  _bstr_t btWord(L"word"), btLong(L"long"), btDate(L"date");;
  _bstr_t name(L"name"), type(L"type"), size(L"size"), acc(L"access");

  try
  {
    // Ok, now iterate over attributes
    atts = root->children;
    cAtts = atts->length;

    if (cAtts <= 0)
    {
      _com_issue_error(E_FAIL);
    }

    if (m_atts)
    {
        delete[] m_atts;
        m_atts = NULL;
    }
    if (m_sizes)
    {
        delete[] m_sizes;
        m_sizes = NULL;
    }
    if (m_readOnly)
    {
        delete[] m_readOnly;
        m_readOnly = NULL;
    }
    if (m_indexes.Size() == 0)
      {
    LK_RETCODE lkrc;
    const RAWBSTR2INT& htConst = m_indexes;
    RAWBSTR2INT::CConstIterator itconst;
    for (lkrc = htConst.InitializeIterator(&itconst) ;
         lkrc == LK_SUCCESS ;
         lkrc = htConst.IncrementIterator(&itconst))
      {
        FREE_BSTR(itconst.Key());
      }
    htConst.CloseIterator(&itconst);
    m_indexes.Clear();
      }

    m_atts = new AttrType[cAtts];
    m_sizes = new short[cAtts];
    m_readOnly = new BYTE[cAtts];
    m_numAtts = cAtts;

    VariantInit(&iAtts);
    iAtts.vt = VT_I4;

    for (iAtts.lVal = 0; iAtts.lVal < cAtts; iAtts.lVal++)
    {
      i = iAtts.lVal;
      m_readOnly[i] = 0;

      pElt = atts->item(iAtts);
      _bstr_t aType = pElt->getAttribute(type);
      _bstr_t aName = pElt->getAttribute(name);
      _bstr_t aAccess = pElt->getAttribute(acc);

      if (aAccess.length() > 0 && !_wcsicmp(aAccess, L"ro"))
    {
      m_readOnly[i] = 1;
    }

    //  [DARRENAN]  Don't add empty names to the list.  This is so we can deprecate the use
    //  of certain attributes w/o removing their position in the schema.  First example
    //  of this is inetaccess.
    if(aName.length() != 0)
    {
        BSTR aNameCopy = ALLOC_BSTR(aName);
        if (!aNameCopy)
            _com_issue_error(E_OUTOFMEMORY);

        RAWBSTR2INT::ValueType *pMapVal = new RAWBSTR2INT::ValueType(aNameCopy, i);
        if (!pMapVal || LK_SUCCESS != m_indexes.InsertRecord(pMapVal))
            _com_issue_error(E_FAIL);
    }

      if (aType == btText)
      {
        m_atts[i] = tText;
        m_sizes[i]= -1;
      }
      else if (aType == btChar)
      {
        m_atts[i] = tChar;
        m_sizes[i]= _wtoi(_bstr_t(pElt->getAttribute(size)))*8;
      }
      else if (aType == btByte)
      {
        m_atts[i] = tByte;
        m_sizes[i]= 8;
      }
      else if (aType == btWord)
      {
        m_atts[i] = tWord;
        m_sizes[i]= 16;
      }
      else if (aType == btLong)
      {
        m_atts[i] = tLong;
        m_sizes[i] = 32;
      }
      else if (aType == btDate)
      {
        m_atts[i] = tDate;
        m_sizes[i] = 32;
      }
      else
        _com_issue_error(E_FAIL);
    }
    bResult = TRUE;

    }

    catch (_com_error &e)
    {
        //
        // PASSPORTLOG is empty. Do nothing here.
        //

        if (m_atts)
        {
            delete[] m_atts;
            m_atts = NULL;
        }
        if (m_sizes)
        {
            delete[] m_sizes;
            m_sizes = NULL;
        }
        if (m_readOnly)
        {
            delete[] m_readOnly;
            m_readOnly = NULL;
        }
        bResult = m_isOk = FALSE;
    }

    return bResult;
}

BOOL CProfileSchema::ReadFromArray(UINT numAttributes, LPTSTR names[], AttrType types[], short sizes[], BYTE readOnly[])
{
    BOOL bAbnormal = FALSE;

    if (m_atts)
    {
        delete[] m_atts;
        m_atts = NULL;
    }
    if (m_sizes)
    {
        delete[] m_sizes;
        m_sizes = NULL;
    }
    if (m_readOnly)
    {
        delete[] m_readOnly;
        m_readOnly = NULL;
    }

    if (m_indexes.Size() == 0)
    {
      LK_RETCODE lkrc;
      const RAWBSTR2INT& htConst = m_indexes;
      RAWBSTR2INT::CConstIterator itconst;
      for (lkrc = htConst.InitializeIterator(&itconst) ;
       lkrc == LK_SUCCESS ;
       lkrc = htConst.IncrementIterator(&itconst))
      {
        FREE_BSTR(itconst.Key());
      }
      htConst.CloseIterator(&itconst);
      m_indexes.Clear();
    }

    if (!numAttributes) {
        return FALSE;
    }

    m_numAtts = numAttributes;
    m_atts = new AttrType[m_numAtts];
    m_sizes = new short[m_numAtts];
    m_readOnly = new BYTE[m_numAtts];

    if (!m_atts || !m_sizes || !m_readOnly) {

        if (m_atts)
        {
            delete[] m_atts;
            m_atts = NULL;
        }
        if (m_sizes)
        {
            delete[] m_sizes;
            m_sizes = NULL;
        }
        if (m_readOnly)
        {
            delete[] m_readOnly;
            m_readOnly = NULL;
        }
        return FALSE;
    }
    try{
        for (UINT i = 0; i < m_numAtts; i++)
        {
            BSTR copy = ALLOC_BSTR((LPCWSTR) names[i]);
            if (!copy){
                bAbnormal = TRUE;
            }
            RAWBSTR2INT::ValueType *pMapVal = new RAWBSTR2INT::ValueType(copy, i);
            if (!pMapVal || m_indexes.InsertRecord(pMapVal) != LK_SUCCESS)
            {
                bAbnormal = TRUE;
            }
            m_atts[i] = types[i];
            // BUGBUG we shouldn't copy directly if it's a type we KNOW the size of
            // should be a switch here
            m_sizes[i] = sizes[i];
            if (readOnly)
                m_readOnly[i] = readOnly[i];
            else
                m_readOnly[i] = 0;
        }
    }
    catch (...)
    {
        //
        // We could get exception if names[i] and etc. is invalid.
        // Maybe, I am too cautious. Index server shows this routine is only
        // called in InitAuthSchema() and InitSecureSchema(). This extra cautious 
        // step might not be too bad for passport code :-)
        //

        if (m_atts)
        {
            delete[] m_atts;
            m_atts = NULL;
        }
        if (m_sizes)
        {
            delete[] m_sizes;
            m_sizes = NULL;
        }
        if (m_readOnly)
        {
            delete[] m_readOnly;
            m_readOnly = NULL;
        }
        bAbnormal = TRUE;
    }

    if (!bAbnormal) {
        m_isOk = true;
    }

    return !bAbnormal;
}

int CProfileSchema::GetBitSize(UINT index) const
{
  if (index > m_numAtts)
    return 0;

  return m_sizes[index];
}

int CProfileSchema::GetByteSize(UINT index) const
{
  if (index > m_numAtts)
    return 0;

  if (m_sizes[index] != -1)
    return m_sizes[index]/8;
  else
    return -1;
}

CProfileSchema::AttrType CProfileSchema::GetType(UINT index) const
{
  if (index > m_numAtts)
    return AttrType::tInvalid;
  return m_atts[index];
}

BOOL CProfileSchema::IsReadOnly(UINT index) const
{
  if (index > m_numAtts)
    return TRUE;
  return m_readOnly[index] != 0;
}

int CProfileSchema::GetIndexByName(BSTR name) const
{
    const RAWBSTR2INT& htConst = m_indexes;
    const RAWBSTR2INT::ValueType *pOut = NULL;

    if (LK_SUCCESS == m_indexes.FindKey(name, &pOut) && pOut != NULL)
    {
        int o = pOut->m_v;
        m_indexes.AddRefRecord(pOut, -1);
        return o;
    }
    else
        return -1;
}

BSTR CProfileSchema::GetNameByIndex(int index) const
{
  LK_RETCODE lkrc;
  const RAWBSTR2INT& htConst = m_indexes;
  RAWBSTR2INT::CConstIterator it;

  for (lkrc = htConst.InitializeIterator(&it) ;
       lkrc == LK_SUCCESS ;
       lkrc = htConst.IncrementIterator(&it))
    {
      if (it.Record()->m_v == index)
    {
      BSTR r = it.Key();
      htConst.CloseIterator(&it);
      return r;
    }
    }
  htConst.CloseIterator(&it);
  return NULL;
}

HRESULT CProfileSchema::parseProfile(LPSTR raw, UINT size, UINT *positions, UINT *bitFlagPositions, DWORD* pdwAttris)
{
    // Read the raw blob according to the schema, and output the positions of
    // each element
    UINT i, spot = 0, curBits = 0, thisSize;

    // they have to be good memory
    if (IsBadWritePtr(positions, m_numAtts * sizeof(UINT))) return E_INVALIDARG;
    if (IsBadWritePtr(bitFlagPositions, m_numAtts * sizeof(UINT))) return E_INVALIDARG;
    if (!pdwAttris) return E_INVALIDARG;

    // initialize the arrays
    for (i = 0; i < m_numAtts; i++)
    {
      *(positions + i) = INVALID_POS;   // position of -1 is not defined
      *(bitFlagPositions + i) = 0;     // bit flag position of 0, is to start from begining
    }

    // number of attributes - init 0
    *pdwAttris = 0;

    for (i = 0; i < m_numAtts && spot < size; i++)
    {
        //
        //  increment attrib cnt moved at the end. Added a check
        //  that the new attrib size fits in the buf len
        //
        positions[i] = spot;
        thisSize = GetByteSize(i);

        if (thisSize && curBits)
        {
            // Make sure the padding lines up on a boundary
            if ((curBits + m_sizes[i])%8)
            {
                // Something wrong, can't align on non-byte boundaries
                return E_INVALIDARG;
            }
            spot += ((curBits+m_sizes[i])/8);
        }

        UINT iRemain = size - spot; // # of byte left to parse
        
        if (thisSize == 0xFFFFFFFF) // String
        {
            if(iRemain < sizeof(u_short)) return E_INVALIDARG;

            iRemain -= sizeof(u_short);

            //
            // due to IA64 alignment faults this memcpy needs to be performed
            //
            u_short sz;

            memcpy((PBYTE)&sz, raw+spot, sizeof(sz));

            sz = ntohs(sz);

            if(iRemain < sz)  return E_INVALIDARG;
            spot += sizeof(u_short)+sz;
        }
        else if (thisSize != 0)
        {
            if(iRemain < thisSize)  return E_INVALIDARG;
            spot += thisSize;  // Simple, just a fixed length
        }
        else // Bit field
        {
            curBits += m_sizes[i];
            // If this is a pad, this field is irrelevant anyway,
            // otherwise, it's one bit long
            bitFlagPositions[i] = curBits;
            while (curBits >= 8)
            {
                spot ++;
                curBits -= 8;
            }
        }
        if (spot <= size)
            (*pdwAttris)++;
    }

    if (i == 0)
        return S_FALSE;
    else
        return S_OK;
}

CProfileSchema* CProfileSchema::AddRef()
{
  InterlockedIncrement(&m_refs);
  return this;
}

void CProfileSchema::Release()
{
  InterlockedDecrement(&m_refs);
  if (m_refs == 0)
    delete this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\tools\passportassert.hpp ===
#ifndef PASSPORTASSERT_HPP
#define PASSPORTASSERT_HPP

#include <stdlib.h>
#include <iostream>
using namespace std;

inline void PassportAssert(bool assertion)
{
	if (!assertion)
	{
		cout << "ASSERT FALIED" << endl;
		abort();
	}
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\tools\passportevent.hpp ===
#ifndef __PASSPORTEVENT_HPP
#define __PASSPORTEVENT_HPP

class PassportEvent
{
public:

    PassportEvent(BOOL bManualReset = TRUE, BOOL bInitialState = FALSE)
    {
        m_hEvent = CreateEvent(NULL, bManualReset, bInitialState, NULL);
    }

    ~PassportEvent()
    {
        CloseHandle(m_hEvent);
    }

    BOOL Pulse()    {return PulseEvent(m_hEvent);}
    BOOL Set()      {return SetEvent(m_hEvent);}
    BOOL Reset()    {return ResetEvent(m_hEvent);}

    operator HANDLE() {return m_hEvent;}

private:

    HANDLE m_hEvent;
};

#endif // __PASSPORTEVENT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\schema\ticketschema.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation
  
    Module Name:
    
      ticketSchema.cpp
      
    Abstract:
        
      Implementation of ticket schema lookup
          
    Usage:
            
    Author:
              
      Wei Jiang(weijiang) 15-Jan-2001
                
    Revision History:
      15-Jan-2001 weijiang         Created.
                      
--*/

#include "stdafx.h"
#include "ticketschema.h"
#include "BstrDebug.h"
#include <winsock2.h> // u_short, u_long, ntohs, ntohl
#include <crtdbg.h>
#include <pmerrorcodes.h>
#include <time.h>
// #include <pmalerts.h>

CTicketSchema::CTicketSchema()
: m_isOk(FALSE), m_szReason(L"Uninitialized"),
  m_numAtts(0), m_attsDef(NULL), m_version(0)
{
}

CTicketSchema::~CTicketSchema()
{
  if (m_attsDef != NULL)
    delete[] m_attsDef;
}

BOOL CTicketSchema::ReadSchema(MSXML::IXMLElementPtr &root)
{
   BOOL bResult = FALSE;
   LPTSTR r=NULL; // The current error, if it happens
   int cAtts = 0;
   MSXML::IXMLElementCollectionPtr atts;
   MSXML::IXMLElementPtr pElt;
   VARIANT iAtts;

   // Type identifiers
 
   try
   {    
      // Ok, now iterate over attributes
      atts = root->children;
      cAtts = atts->length;
    
      if (cAtts <= 0)
      {
         _com_issue_error(E_FAIL);
      }
    
      if (m_attsDef)
      {
          delete[] m_attsDef;

          //
          // Paranoid
          //

          m_attsDef = NULL;
      }
    
      m_attsDef = new TicketFieldDef[cAtts];
      if (NULL == m_attsDef)
      {
          m_isOk = FALSE;
          bResult = FALSE;
          goto Cleanup;
      }

      // get name and version info
      m_name = root->getAttribute(ATTRNAME_NAME);
      _bstr_t aVersion = root->getAttribute(ATTRNAME_VERSION);

      if(aVersion.length() != 0)
         m_version = (short)_wtol(aVersion);
      else
         m_version = 0; // invalid
    
      VariantInit(&iAtts);
      iAtts.vt = VT_I4;

      for (iAtts.lVal = 0; iAtts.lVal < cAtts; iAtts.lVal++)
      {
         pElt = atts->item(iAtts);
         m_attsDef[iAtts.lVal].name = pElt->getAttribute(ATTRNAME_NAME);
         _bstr_t aType = pElt->getAttribute(ATTRNAME_TYPE);
         _bstr_t aFlags = pElt->getAttribute(ATTRNAME_FLAGS);

         // find out the type information
         m_attsDef[iAtts.lVal].type = tInvalid;
         if(aType.length() != 0)
         {
            for(int i = 0; i < (sizeof(TicketTypeNameMap) / sizeof(CTicketTypeNameMap)); ++i)
            {
               if(_wcsicmp(aType, TicketTypeNameMap[i].name) == 0)
               {
                  m_attsDef[iAtts.lVal].type = TicketTypeNameMap[i].type;
                  break;
               }
            }
         }

         // flags      
         if(aFlags.length() != 0)
            m_attsDef[iAtts.lVal].flags = _wtol(aFlags);
         else
            m_attsDef[iAtts.lVal].flags = 0;
      }

      m_numAtts = iAtts.lVal;
      bResult = m_isOk = TRUE;
    
   }
    catch (_com_error &e)
    {     
        if (m_attsDef)
        {
           delete[] m_attsDef;
        
           //
           // Paranoid
           //
        
           m_attsDef = NULL;
        }
        bResult = m_isOk = FALSE;
    }
Cleanup:
    return bResult;
}


HRESULT CTicketSchema::parseTicket(LPCSTR raw, UINT size, CTicketPropertyBag& bag)
{
   DWORD          cParsed = 0;
   HRESULT        hr = S_OK;
   LPBYTE         dataToParse = (LPBYTE)raw;
   UINT           cDataToParse = size;

   //
   // Make sure the data passed in is good.
   // maskF.Parse doesn't validate the parameter.
   //

   if (IsBadReadPtr(raw, size)) return E_INVALIDARG;

   // then the schema version #
   if(cDataToParse > 2)  // enough  for version
   {
      unsigned short * p = (unsigned short *)(dataToParse);

      if (m_version < VALID_SCHEMA_VERSION_MIN || m_version > VALID_SCHEMA_VERSION_MAX)
         return S_FALSE;   // not able to process with this version of ppm
         
      dataToParse += 2;
      cDataToParse -= 2;
   }
   
   // then the maskK
   CTicketFieldMasks maskF;
   hr = maskF.Parse(dataToParse, cDataToParse, &cParsed);

   if(hr != S_OK)
      return hr;

   // pointer advances
   dataToParse += cParsed;
   cDataToParse -= cParsed;
   
   USHORT*     pIndexes = maskF.GetIndexes();
   DWORD       type = 0;
   DWORD       flags = 0;
   DWORD       fSize = 0;
   variant_t   value;
   u_short     slen;
   u_long      llen;

   USHORT   index = MASK_INDEX_INVALID;
   // then the data
   // get items that enabled by the schema
   while((index = *pIndexes) != MASK_INDEX_INVALID && cDataToParse > 0)
   {
      TicketProperty prop;
      // if index is out of schema range
      if (index >= m_numAtts) break;

      // fill-in the offset of the property
      prop.offset = dataToParse - (LPBYTE)raw; 

      // type 
      type = m_attsDef[index].type;

      fSize = TicketTypeSizes[type];
      switch (type)
      {
      case tText:
        {
            //
            // due to IA64 alignment faults this memcpy needs to be performed
            //
            memcpy((PBYTE)&slen, dataToParse, sizeof(slen));
            slen = ntohs(slen);
            value.vt = VT_BSTR;
            if (slen == 0)
            {
                value.bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(L"", 0);
            }
            else
            {
                int wlen = MultiByteToWideChar(CP_UTF8, 0,
                                            (LPCSTR)dataToParse+sizeof(u_short),
                                            slen, NULL, 0);
                if (!wlen) {

                    //
                    // BUGBUG:
                    // What should we do here? free all the previously allocated memory?
                    // The original code was not doing that. See case default below. Keep
                    // the data parsed so far? That seems the original logic. This needs to
                    // further looked at.
                    //

                    return HRESULT_FROM_WIN32(GetLastError());


                }
                value.bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(NULL, wlen);
                if (!MultiByteToWideChar(
                        CP_UTF8, 
                        0,
                        (LPCSTR)dataToParse+sizeof(u_short),
                        slen, 
                        value.bstrVal, 
                        wlen))
                {
                    FREE_BSTR(value.bstrVal);
                    return HRESULT_FROM_WIN32(GetLastError());
                }
                value.bstrVal[wlen] = L'\0';
            }

            dataToParse += slen + sizeof(u_short);
            cDataToParse -= slen + sizeof(u_short);
         }
         break;
         
      case tChar:
         _ASSERTE(0);  // NEED MORE THOUGHT -- IF unicode makes more sense
/*         
         {
            int wlen = MultiByteToWideChar(CP_UTF8, 0,
                                            raw+m_pos[index],
                                            m_schema->GetByteSize(index), NULL, 0);
            pVal->vt = VT_BSTR;
            pVal->bstrVal = ALLOC_AND_GIVEAWAY_BSTR_LEN(NULL, wlen);
            MultiByteToWideChar(CP_UTF8, 0,
                                raw+m_pos[index],
                                m_schema->GetByteSize(index), pVal->bstrVal, wlen);
            pVal->bstrVal[wlen] = L'\0';
         }
*/
         break;
      case tByte:
         value.vt = VT_I2;
         value.iVal = *(BYTE*)(dataToParse);
         break;
      case tWord:
         value.vt = VT_I2;
         //
         // due to IA64 alignment faults this memcpy needs to be performed
         //
         memcpy((PBYTE)slen, dataToParse, sizeof(slen));
         value.iVal = ntohs(slen);
         break;
      case tLong:
         value.vt = VT_I4;
         //
         // due to IA64 alignment faults this memcpy needs to be performed
         //
         memcpy((PBYTE)&llen, dataToParse, sizeof(llen));
         value.lVal = ntohl(llen);
         break;
      case tDate:
         value.vt = VT_DATE;
         //
         // due to IA64 alignment faults this memcpy needs to be performed
         //
         memcpy((PBYTE)&llen, dataToParse, sizeof(llen));
         llen = ntohl(llen);
         VarDateFromI4(llen, &(value.date));
         break;
      default:
         return PP_E_BAD_DATA_FORMAT;
      }

      // now with name, flags, value, type, we can put it into property bag
      // name, flags, value
      prop.flags = m_attsDef[index].flags;
      prop.type = type;
      prop.value.Attach(value.Detach());
      bag.PutProperty(m_attsDef[index].name, prop);


      // for text data, the pointer was already adjusted
      if (fSize  != SIZE_TEXT)
      {
         dataToParse += fSize;
         cDataToParse -= fSize;
      }   

      ++pIndexes;
   }
   
   return S_OK;
}

//
//
// Ticket property bag
//
CTicketPropertyBag::CTicketPropertyBag()
{

}

CTicketPropertyBag::~CTicketPropertyBag()
{
}

HRESULT CTicketPropertyBag::GetProperty(LPCWSTR  name, TicketProperty& prop)
{
   HRESULT  hr = S_OK;

   if(!name || (!*name))
      return E_INVALIDARG;
   
   TicketPropertyMap::iterator i;

   i = m_props.find(name);

   if(i!= m_props.end())
      prop = i->second;
   else
      hr = S_FALSE;
    

   return hr;
}

HRESULT CTicketPropertyBag::PutProperty(LPCWSTR  name, const TicketProperty& prop)
{
   HRESULT  hr = S_OK;

   if(!name || (!*name))
      return E_INVALIDARG;
   try{
      m_props[name] = prop;
   }
   catch (...)
   {
      hr = E_OUTOFMEMORY;
   }
   return hr;
}

//
//
// class CTicketFieldMasks
//
inline HRESULT CTicketFieldMasks::Parse(PBYTE masks, ULONG size, ULONG* pcParsed) throw()
{
    _ASSERT(pcParsed && masks);
    // 16 bits as a unit of masks

    *pcParsed = 0;
    if (!masks || size < 2) return E_INVALIDARG;
    // validate the masks
    PBYTE p = masks;
    ULONG    totalMasks = 15;
    BOOL fContinue = FALSE;
    u_short  mask;
    *pcParsed += 2;

    // find out size
    //
    // due to IA64 alignment faults this memcpy needs to be performed
    //
    memcpy((PBYTE)&mask, p, sizeof(u_short));
    p += 2;
    fContinue = MORE_MASKUNIT(ntohs(mask));
    while(fContinue) //the folling short is mask unit
    {
        totalMasks += 15;
        // insufficient data in buffer
        if (*pcParsed + 2 > size)  return E_INVALIDARG;

        *pcParsed += 2;

        //
        // due to IA64 alignment faults this memcpy needs to be performed
        //
        memcpy((PBYTE)&mask, p, sizeof(u_short));
        p += 2;
        fContinue = MORE_MASKUNIT(ntohs(mask));
    }

    if(m_fieldIndexes) delete[] m_fieldIndexes;
    m_fieldIndexes = new unsigned short[totalMasks];  // max number of mask bits
    if (NULL == m_fieldIndexes)
    {
        return E_OUTOFMEMORY;
    }

    for ( unsigned int i = 0; i < totalMasks; ++i)
    {
        m_fieldIndexes[i] = MASK_INDEX_INVALID;
    }

    p = masks;
    unsigned short      index = 0;
    totalMasks = 0; 
    // fill in the mask
    do
    {
        //
        // due to IA64 alignment faults this memcpy needs to be performed
        //
        memcpy((PBYTE)&mask, p, sizeof(u_short));
        p += 2;
        mask = ntohs(mask);
	    //// find the bits
        if (mask & 0x7fff)   // any 1s
        {
            unsigned short j = 0x0001;
            while( j != 0x8000 )
            {
                if(j & mask)
                    m_fieldIndexes[totalMasks++] = index;
                ++index;
                j <<= 1;
            }
        }
        else
            index += 15;
    } while(MORE_MASKUNIT(mask)); //the folling short is mask unit


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\tools\passportguard.hpp ===
#ifndef PASSPORTGUARD_HPP
#define PASSPORTGUARD_HPP

template <class Lock>
class PassportGuard
{
public:
	PassportGuard(Lock& lock)
		:mLock(lock)
	{
		mLock.acquire();
	}

	~PassportGuard()
	{
		mLock.release();
	}
private:
	Lock& mLock;
};

#endif //!PASSPORTGUARD_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\tools\passportlock.hpp ===
#ifndef PASSPORTLOCK_HPP
#define PASSPORTLOCK_HPP

#include <windows.h>
#include <winbase.h>

class PassportLock
{
public:
	PassportLock(DWORD dwSpinCount = 4000);

	void acquire();

	void release();

	~PassportLock();
private:
	CRITICAL_SECTION mLock;
};

class PassportLockGlobal
{
public:
	PassportLockGlobal(CRITICAL_SECTION &critSec)
	    : mLock(critSec)
	{
	    EnterCriticalSection(&mLock);
	}

	~PassportLockGlobal()
	{
    	LeaveCriticalSection(&mLock);
	}
private:
	CRITICAL_SECTION &mLock;
};

#endif // !PASSPORTLOCK_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\tools\passportexport.h ===
// PassportExport.h: 
//
//////////////////////////////////////////////////////////////////////

#if !defined(PASSPORTEXPORT_H)
#define PASSPORTEXPORT_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#if !defined(_PassportExport_)
#define PassportExport __declspec(dllimport)
#else
#define PassportExport __declspec(dllexport)
#endif

#endif // !defined(PASSPORTEXPORT_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\tools\passportfile.hpp ===
//---------------------------------------------------------------------------------------
//
//   @doc
// 
//   @module passportfile.hpp | Passport smart class to wrap FILE*
//    
//   Author: stevefu
//   
//   Date: 05/28/2000 
//
//  Copyright <cp> 1999-2000 Microsoft Corporation.  All Rights Reserved.
//
//---------------------------------------------------------------------------------------

#ifndef PASSPORTFILE_HPP
#define PASSPORTFILE_HPP

#pragma once

#include <stdio.h>
#include <tchar.h>

class PassportFile
{
private:
	FILE* m_hFile;

public:
	PassportFile() : m_hFile(NULL) { }

	~PassportFile() 
	{ 
	 	if ( m_hFile != NULL) fclose(m_hFile); 
	}

	BOOL Open( const TCHAR* filename, const TCHAR* mode)
	{
		m_hFile = _tfopen(filename, mode);
		return ( NULL != m_hFile );
	}

	void Close()
	{	
		ATLASSERT(m_hFile != NULL);
		fclose(m_hFile);
	}

	// return length,   -1 if error or eof
	int ReadLine(TCHAR* string, int n)
	{
		ATLASSERT(m_hFile != NULL);
		int len = -1;
		if ( _fgetts(string, n, m_hFile) )
		{
			len = _tcslen(string);
			// trim the new line
			if ( len > 0 && string[len-1] == TEXT('\n') )
			{
				string[len-1] = TEXT('\0');
				len--;
			}
		}
		return len;
	}
	
	inline operator FILE*() { return m_hFile; }
	
};

#endif // PASSPORTFILE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\tools\passportlock.cpp ===
#include "PassportLock.hpp"

PassportLock::PassportLock(DWORD dwSpinCount)
{
   if(0 ==InitializeCriticalSectionAndSpinCount(&mLock, dwSpinCount))
   {
      throw(GetLastError());  // it's safe to throw, no issue about partial construction
   }
}

void PassportLock::acquire()
{
	EnterCriticalSection(&mLock);
}

void PassportLock::release()
{
	LeaveCriticalSection(&mLock);
}

PassportLock::~PassportLock()
{
	DeleteCriticalSection(&mLock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\tools\passportlockedinteger.hpp ===
#ifndef PASSPORTLOCKEDINTERGER_HPP
#define PASSPORTLOCKEDINTERGER_HPP

#include <windows.h>
#include <winbase.h>

// a thread safe integer class..
class PassportLockedInteger
{
public:
    PassportLockedInteger(LONG l = 0)
    {
        m_Long = l;
    }

    // returns the new value of the integer.
    LONG operator++()
    {
        return InterlockedIncrement(&m_Long);
    }

    // returns the new value of the integer.
    LONG operator--()
    {
        return InterlockedDecrement(&m_Long);
    }

    // returns the new value of the integer.
    LONG operator+=(LONG value)
    {
        return InterlockedExchangeAdd( &m_Long , value ) + value;
    }

    // returns the new value of the integer.
    LONG operator-=(LONG value)
    {
        return InterlockedExchangeAdd( &m_Long , -value ) - value;
    }

    // returns the current value of the integer.
    LONG value()
    {
        return m_Long;
    }
private:
    LONG m_Long;
};


// smart wrapper class for PassportLockedInteger
class CPassportLockedIntegerWrapper
{
public:
    // Constructor automatically does increment
    CPassportLockedIntegerWrapper(PassportLockedInteger *pLock)
    {
        m_pLock = pLock;
        if (m_pLock)
        {
            m_Value = ++(*m_pLock);
        }
        else
        {
            m_Value = 0;
        }
    }

    // Destructor automatically decrements
    ~CPassportLockedIntegerWrapper()
    {
        if (m_pLock)
        {
            --(*m_pLock);
        }
    }
    // returns the current value of the integer.
    LONG value()
    {
        return m_Value;
    }

private:
    PassportLockedInteger *m_pLock;
    LONG m_Value;       
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\tools\passportsystem.hpp ===
#ifndef PASSPORTSYSTEM_HPP
#define PASSPORTSYSTEM_HPP

#include <windows.h>

class PassportSystem
{
public:
	static long currentTimeInMillis()
	{
		return GetTickCount(); // BUG!! WILL OVERFLOW IN ~50 days
	}
};

#endif // !PASSPORTSYSTEM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\tools\passportthread.cpp ===
#include <process.h>

#include "PassportThread.hpp"
#include "PassportAssert.hpp"


static DWORD WINAPI threadRunner(void* lpvThreadParam)
{
    ((PassportThread*) lpvThreadParam)->run();
    return 0; // is this right/okay??
}


bool PassportThread::start()
{
//  mHandle = (HANDLE) _beginthreadex(NULL, 0, &threadRunner, (void*) this,
//                               0, &mThreadID);
    mHandle = CreateThread(NULL,
                           0,
                           threadRunner,
                           (void*)this,
                           0,
                           &mThreadID);
    if (mHandle == NULL)
        return false;
    else
        return true;
}


PassportThread::PassportThread()
:mThreadID(0), mHandle(NULL)
{
    //empty
}


DWORD PassportThread::threadID()
{
    return mThreadID;
}


PassportThread::~PassportThread()
{
    if (mHandle)
        CloseHandle(mHandle);
}

bool PassportThread::join(PassportThread* threads[], int size)
{
    HANDLE* handles = new HANDLE[size];

    if (handles == NULL)
    {
        return false;
    }

    for (int i = 0 ; i < size ; i++)
    {
        PassportAssert(threads[i] != NULL);
        handles[i] = threads[i]->mHandle;
    }

    bool success = (WaitForMultipleObjects(size, handles, TRUE, INFINITE) != WAIT_FAILED);
    delete[] handles;
    return success;
}


void PassportThread::sleep(long milliseconds)
{
    Sleep(milliseconds);
}


DWORD PassportThread::currentThreadID()
{
    return GetCurrentThreadId();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\utilities\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__2D93832A_D6E0_4D64_8855_9434DA399837__INCLUDED_)
#define AFX_STDAFX_H__2D93832A_D6E0_4D64_8855_9434DA399837__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <atlbase.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2D93832A_D6E0_4D64_8855_9434DA399837__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\binhex.h ===
// BinHex.h: interface for the CBinHex class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_BINHEX_H__1B7F2A63_8878_11D2_B4C8_00C04F9914AB__INCLUDED_)
#define AFX_BINHEX_H__1B7F2A63_8878_11D2_B4C8_00C04F9914AB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <wtypes.h>
#include <oleauto.h>

#define BBAD (BYTE)-1

class CBinHex  
{
public:

  CBinHex();

  // Prepend makes this a non-generic binhex, but oh well.
  // If it's 0, nothing is prepended
  static HRESULT ToBase64(LPVOID pv, UINT cbSize, char prepend, char ivecnpad[9], BSTR* pbstr); 
  static HRESULT ToBase64ASCII(LPVOID pv, UINT cbSize, char prepend, char ivecnpad[9], BSTR* pbstr); 
  
  HRESULT FromBase64(LPSTR lpStr, UINT cbSize, BSTR* pblob); 
  HRESULT FromWideBase64(BSTR bstr, BSTR* pblob); 
  
  HRESULT PartFromBase64(LPSTR lpStr, BYTE* output, ULONG *numOutBytes);
  HRESULT PartFromWideBase64(LPWSTR bStr, BYTE* output, ULONG *numOutBytes);

protected:
  BYTE m_decodeArray[256];
};

#endif // !defined(AFX_BINHEX_H__1B7F2A63_8878_11D2_B4C8_00C04F9914AB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\tools\passportthread.hpp ===
#ifndef PASSPORTTHREAD_HPP
#define PASSPORTTHREAD_HPP

#include <windows.h>
#include <winbase.h>

class PassportThread
{
public:
    PassportThread();

    // --------------------
    // the new thread will
    // execute this function
    virtual void run() = 0;

    // ---------------------
    // start a new thread and
    // that thread calls run
    bool start();

    virtual DWORD threadID();
    virtual HANDLE threadHandle()
    {
        return  mHandle;
    }

    virtual ~PassportThread();

    // ---------------------------------------
    // waits for all the given threads to stop.
    // NOTE: the current maximum number of
    // threads that can be joined is 64.
    static bool join(PassportThread* threads[], int size);

    // ---------------------------
    // cause the current thread
    // to sleep for the specified
    // number of milliseconds
    static void sleep(long milliseconds);

    // --------------------------------
    // returns the id of the current
    // thread
    static DWORD currentThreadID();

private:
    DWORD mThreadID;
    HANDLE mHandle;
};

#endif // !PASSPORTTHREAD_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\common\utilities\pptrace.cpp ===
///////////////////////////////////////////////////////////////////////////////
// pptrace.cpp
//
// ABSTRACT:
// The Event Tracing utility is built on top of the NT Event Tracer base services.
// The Event Tracer application programming interface (API) is a set of functions
// that developers can use to access and control all aspects of event tracing. Using
// the Event Tracer API, developers can manage event tracing sessions, generate event
// traces, and receive event traces. The Event Tracer API is divided into sections
// based on the functionality implemented:
// 
//	    Event Trace Controller
//	    Event Trace Provider
//	    Event Trace Consumer
//	
//	Event Trace Controller - implemented in pptracelog.exe
//	Event trace controllers start and stop event tracing sessions, manage buffer resources,
//  and obtain execution statistics for sessions. Session statistics include the number of
//  buffers used, the number of buffers delivered, the number of events and buffers lost,
//  and the size and location of the log file, if applicable.
//
//	Event Trace Provider - APIs used by all ISAPI/COM components are implemented in this file
//	The event trace provider section of the Event Tracer API is where event trace
//  providers and classes are registered with the Event Tracer, and event traces and
//  event trace instances are generated.  After registering to generate traces for one
//  or more classes of events, an event trace provider can be enabled or disabled for
//  an event tracing session. It is left to the provider to define its interpretation
//  of being enabled or disabled. In general, if a provider has been enabled, it will
//  generate event traces for the session to record, and while it is disabled, it will not.
//
//	Event Trace Consumer - implemented in pptracedmp.exe
//	Software that functions as an event trace consumer can select one or more event
//  tracing sessions as the source of its event traces. Consumers can receive event
//  traces stored in log files, or from sessions that deliver event traces in real-time.
//  When processing event traces, a consumer can specify starting and ending times, and
//  only events that occur in the specified time frame will be delivered to the consumer.
//  A consumer can request events from multiple event tracing sessions simultaneously,
//  and the Event Tracer will put the events into chronological order before delivering
//  them to the consumer.
 
// HISTORY:
// 05-15-01 - naiyij  created
//
///////////////////////////////////////////////////////////////////////////////


#include <stdafx.h>
#include <tchar.h>
#include <ole2.h>
#include <wmistr.h>
#include <evntrace.h>
#include <pptrace.h>
#include <ctype.h>

#define MAXIMUM_LOGGERS                  32
#define IsEqualGUID(rguid1, rguid2) (!memcmp(rguid1, rguid2, sizeof(GUID)))


GUID TransactionGuid = 
    {0xce5b1020, 0x8ea9, 0x11d0, 0xa4, 0xec, 0x00, 0xa0, 0xc9, 0x06, 0x29, 0x10};

TRACE_GUID_REGISTRATION TraceGuidReg[] =
{
    { (LPGUID)&TransactionGuid,
      NULL
    }
};

typedef struct _USER_MOF_EVENT {
    EVENT_TRACE_HEADER    Header;
    MOF_FIELD             mofData;
} USER_MOF_EVENT, *PUSER_MOF_EVENT;


TRACEHANDLE LoggerHandle;
TRACEHANDLE RegistrationHandle;

namespace PPTraceStatus {
	bool TraceOnFlag = false;
	UCHAR EnableLevel = 0;
	ULONG EnableFlags = 0;
}

// TRACEHANDLE is typedefed as ULONG64
ULONG64 GetTraceHandle()
    {
    return LoggerHandle;
    }

// TRACEHANDLE is typedefed as ULONG64
void SetTraceHandle(ULONG64 TraceHandle)
    {
    LoggerHandle = TraceHandle;
    }

///////////////////////////////////////////////////////////////////////////
// TraceString
// Genereate a Trace Event with the input string
// unicode version - for future use
///////////////////////////////////////////////////////////////////////////
ULONG TraceString(UCHAR Level, IN LPCWSTR wszBuf) 
{
	ULONG status;
    PMOF_FIELD          mofField;
    USER_MOF_EVENT      UserMofEvent;

    RtlZeroMemory(&UserMofEvent, sizeof(UserMofEvent));

 	UserMofEvent.Header.Class.Type = EVENT_TRACE_TYPE_INFO;
 	UserMofEvent.Header.Class.Level = Level;

    UserMofEvent.Header.Size  = sizeof(UserMofEvent);
    UserMofEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
    UserMofEvent.Header.Guid  = TransactionGuid;
    UserMofEvent.Header.Flags |= WNODE_FLAG_USE_MOF_PTR;

	mofField          = (PMOF_FIELD) & UserMofEvent.mofData;
	mofField->DataPtr = (ULONGLONG) (wszBuf);
	mofField->Length  = sizeof(WCHAR) * (wcslen(wszBuf) + 1);

	status = TraceEvent(LoggerHandle, (PEVENT_TRACE_HEADER) & UserMofEvent);

	return status;
}

///////////////////////////////////////////////////////////////////////////
// TraceString
// Genereate a Trace Event with the input string
// ansi version - used currently
///////////////////////////////////////////////////////////////////////////
ULONG TraceString(UCHAR Level, IN LPCSTR szBuf) 
{
	ULONG status;
    PMOF_FIELD          mofField;
    USER_MOF_EVENT      UserMofEvent;

    RtlZeroMemory(&UserMofEvent, sizeof(UserMofEvent));

 	UserMofEvent.Header.Class.Type = EVENT_TRACE_TYPE_INFO;
 	UserMofEvent.Header.Class.Level = Level;

    UserMofEvent.Header.Size  = sizeof(UserMofEvent);
    UserMofEvent.Header.Flags = WNODE_FLAG_TRACED_GUID;
    UserMofEvent.Header.Guid  = TransactionGuid;
    UserMofEvent.Header.Flags |= WNODE_FLAG_USE_MOF_PTR;

	mofField          = (PMOF_FIELD) & UserMofEvent.mofData;
	mofField->DataPtr = (ULONGLONG) (szBuf);
	mofField->Length  = sizeof(CHAR) * (strlen(szBuf) + 1);

	status = TraceEvent(LoggerHandle, (PEVENT_TRACE_HEADER) & UserMofEvent);

	return status;
}

//---------------------------------------------------------------------------------------
//
//	@func	Calls TracePrint to print a string that is potentially longer than MAXSTR
//	
//	@rdesc	does not return any value
//
//---------------------------------------------------------------------------------------
VOID
TracePrintString(
    UCHAR  Level,			//@parm log if current logging level is at least this
    LPCSTR szFileAndLine, 	//@parm ignored
    LPCSTR szContext,		//@parm	which function is this called from
    LPCSTR szBuf		   //@parm the string itself
)
{
	ATLASSERT(szContext);
	
    TraceString(Level, szContext);
    TraceString(Level, szBuf);
}

///////////////////////////////////////////////////////////////////////////
// TracePrintBlob
// Generate a trace event with input binary blob
///////////////////////////////////////////////////////////////////////////
#define TOHEX(h) ((h)>=10 ? 'a' +(h)-10 : '0'+(h))

VOID
TracePrintBlob(
    UCHAR  Level,
    LPCSTR szFileAndLine,
    LPCSTR szDesc,
    LPBYTE binBlob,
    DWORD  cSize,
    BOOL   bUnderscore)	//defaults to FALSE
{
   //  no data generated for the following two cases
   if (!PPTraceStatus::TraceOnFlag || Level > PPTraceStatus::EnableLevel)
      return;

   _ASSERT(szFileAndLine && szDesc);
   _ASSERT(*szFileAndLine && *szDesc);
   _ASSERT(binBlob && !IsBadReadPtr(binBlob, cSize));

   char* pBuf = NULL;
   char* pAscii = NULL;

   // the buffer to hold the hex version of the blob and other stuff + NULL + @
   pBuf = new char [strlen(szFileAndLine) + cSize * 2 + 2];
   pAscii = new char [cSize * (bUnderscore ? 2 : 1)+ 1];

   if (!pBuf || !pAscii)
   {
      TraceString(Level, "not enough memory for this trace");
   }
   else
   {
      char* pNext = pBuf;
      char* pNextAscii = pAscii;
      
      BYTE     cValue;
      BYTE     cHalf;

      // convert the blob to hex chars
      for (DWORD i = 0; i < cSize; ++i)
      {
         cValue = *binBlob++;

         cHalf = cValue >> 4;
         *pNext++ = TOHEX(cHalf);
         
         cHalf = cValue & 0x0f;
         *pNext++ = TOHEX(cHalf);

         if (isprint(cValue))
         {
         	*pNextAscii++ = cValue;
         	if (bUnderscore)
	         	*pNextAscii++ = '_';
         }
         else
       	 {
         	*pNextAscii++ = '?';
         	if (bUnderscore)
	         	*pNextAscii++ = '?';
       	}
      }

      *pNext++ = '@';
      
      CHAR* pStr = strrchr(szFileAndLine, '\\');
      if(pStr)
      {
         strcpy(pNext, ++pStr);
         pNext += strlen(pStr);
      }

      *pNext = '\0';
      *pNextAscii = '\0';
    
      TraceString(Level, szDesc);
      TraceString(Level, pAscii);
      TraceString(Level, pBuf);
   }

   if (pBuf)
      delete [] pBuf;
   if (pAscii)
      delete [] pAscii;
}


///////////////////////////////////////////////////////////////////////////
// TracePrint
// Generate a trace event with input data
///////////////////////////////////////////////////////////////////////////
VOID
TracePrint(
    UCHAR  Level,
	LPCSTR szFileAndLine,
    LPCSTR ParameterList OPTIONAL,
    ...
)
{
	//  no data generated for the following two cases
    if (!PPTraceStatus::TraceOnFlag || Level > PPTraceStatus::EnableLevel)
		return;

    CHAR buf[MAXSTR];
	int len = 0;
    
    if (ARGUMENT_PRESENT(ParameterList)) {
            va_list parms;
            va_start(parms, ParameterList);
            len = _vsnprintf(buf, MAXSTR-1, (CHAR*)ParameterList, parms);
 			if (len < 0) len = MAXSTR - 1;
            va_end(parms);
    }

	if (len < (MAXSTR - 1))
	{
		CHAR* pStr = strrchr(szFileAndLine, '\\');
		if (pStr)
		{
			pStr++;
			_snprintf(buf+len, MAXSTR-len-1, "@%s", pStr);
		}
	}
    
    TraceString(Level, buf);
}

///////////////////////////////////////////////////////////////////////////
// CTraceFuncVoid
// Generate trace events for void functions
///////////////////////////////////////////////////////////////////////////
CTraceFuncVoid::CTraceFuncVoid(UCHAR Level, LPCSTR szFileAndLine, LPCSTR szFuncName, LPCSTR ParameterList, ...) : m_Level(Level)
	{
		//  no data generated for the following two cases
		if (!PPTraceStatus::TraceOnFlag || m_Level > PPTraceStatus::EnableLevel)
			return;

		strncpy(m_szFuncName, szFuncName, MAXNAME-1);

		CHAR buf[MAXSTR];
    
		int len = _snprintf(buf, MAXSTR-1, "+%s(", m_szFuncName);
		int count = 0;
		if (ARGUMENT_PRESENT(ParameterList)) {
				va_list parms;
				va_start(parms, ParameterList);
				count = _vsnprintf(buf+len, MAXSTR-len-1, (CHAR*)ParameterList, parms);
				len = (count > 0) ? len + count : MAXSTR - 1;
				va_end(parms);
		}
		if (len < (MAXSTR - 1))
		{
			CHAR* pStr = strrchr(szFileAndLine, '\\');
			if (pStr)
			{
				pStr++; //remove '\'
				_snprintf(buf+len, MAXSTR-len-1, ")@%s", pStr);
			}
		}

		TraceString(m_Level, buf); 
	};

CTraceFuncVoid::~CTraceFuncVoid()
	{
		//  no data generated for the following two cases
		if (!PPTraceStatus::TraceOnFlag || m_Level > PPTraceStatus::EnableLevel)
			return;
		
		std::ostringstream ost;
		ost << "-" << m_szFuncName << "()";  
		TraceString(m_Level, ost.str().c_str()); 
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\bstrdebug.h ===
#ifndef _BSTRDEBUG_H
#define _BSTRDEBUG_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// BSTR debugging.  
// GIVEAWAY is used when someone else will free it
// TAKEOVER is used when you get one you should be freeing


#define ALLOC_BSTR(x)                         SysAllocString(x)
#define ALLOC_BSTR_LEN(x,y)                   SysAllocStringLen(x,y)
#define ALLOC_BSTR_BYTE_LEN(x,y)              SysAllocStringByteLen(x,y)
#define ALLOC_AND_GIVEAWAY_BSTR(x)            SysAllocString(x)
#define ALLOC_AND_GIVEAWAY_BSTR_LEN(x,y)      SysAllocStringLen(x,y)
#define ALLOC_AND_GIVEAWAY_BSTR_BYTE_LEN(x,y) SysAllocStringByteLen(x,y)
#define GIVEAWAY_BSTR(x)             
#define TAKEOVER_BSTR(x)
#define FREE_BSTR(x)                          SysFreeString(x)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\bstrhash.h ===
// Helper funcs for string maps

#ifndef _BSTRHASH_INC
#define _BSTRHASH_INC

#pragma warning( disable : 4786 )

#include <map>
using namespace std;

#include "lkrhash.h"

template <class _Key, class _Val>
class CLKWrap
{
 public:
  _Key m_k;
  _Val m_v;
  mutable LONG m_cRefs;
  
  CLKWrap(_Key k, _Val v, char* id = "CLKWrap") : m_k(k), m_v(v), m_cRefs(0) 
    {
    }
  ~CLKWrap()
    {
    }
};

template <class _Val>
class CRawCIBstrHash
  : public CTypedHashTable<CRawCIBstrHash<_Val>, const CLKWrap<BSTR,_Val>, BSTR>
{
 public:
  typedef CLKWrap<BSTR,_Val> ValueType;

  CRawCIBstrHash(LPCSTR name) :
    CTypedHashTable<CRawCIBstrHash, const CLKWrap<BSTR,_Val>, BSTR>(name)
    {}

  CRawCIBstrHash(LPCSTR name, double maxload, DWORD initsize, DWORD num_subtbls) :
    CTypedHashTable<CRawCIBstrHash, const CLKWrap<BSTR,_Val>, BSTR>(name,maxload,initsize,num_subtbls)
    {}

  static BSTR ExtractKey(const CLKWrap<BSTR,_Val> *pEntry)
    { return pEntry->m_k; }
  static DWORD CalcKeyHash(BSTR pstrKey)
    { return HashStringNoCase(pstrKey); }
  static bool EqualKeys(BSTR x, BSTR y)
    {
      if (x == NULL)
	{
	  return (y==NULL ? TRUE : FALSE);
	}
      if (!y) return FALSE;

      return (_wcsicmp(x,y) == 0); 
    }
  
    static void AddRefRecord(const CLKWrap<BSTR,_Val>* pTest, int nIncr)
    {
        IRTLTRACE(_TEXT("AddRef(%p, %s) %d, cRefs == %d\n"),
                  pTest, pTest->m_k, nIncr, pTest->m_cRefs);

        if (nIncr == +1)
        {
            // or, perhaps, pIFoo->AddRef() (watch out for marshalling)
            // or ++pTest->m_cRefs (single-threaded only)
            InterlockedIncrement(&pTest->m_cRefs);
        }
        else if (nIncr == -1)
        {
            // or, perhaps, pIFoo->Release() or --pTest->m_cRefs;
            LONG l = InterlockedDecrement(&pTest->m_cRefs);

            // For some hashtables, it may also make sense to add the following
            if (l == 0) delete pTest;
            // but that would typically only apply when InsertRecord was
            // used thus
            //      lkrc = ht.InsertRecord(new CTest(foo, bar));
        }
        else
            IRTLASSERT(0);
    }

};

// For normal built in types as keys
template <class _Key,class _Val>
class CGenericHash
  : public CTypedHashTable<CGenericHash<_Key,_Val>, const CLKWrap<_Key,_Val>, _Key>
{
 public:
  typedef CLKWrap<_Key,_Val> ValueType;
  
  CGenericHash(LPCSTR name) :
    CTypedHashTable<CGenericHash, const ValueType, _Key>(name)
    {}
  
  CGenericHash(LPCSTR name, double maxload, DWORD initsize, DWORD num_subtbls) :
    CTypedHashTable<CGenericHash, const ValueType, _Key>(name,maxload,initsize,num_subtbls)
    {}
 
  static _Key ExtractKey(const CLKWrap<_Key,_Val> *pEntry)
    { return pEntry->m_k; }
  static DWORD CalcKeyHash(_Key psKey)
    { return Hash(psKey); }
  static bool EqualKeys(_Key x, _Key y)
    { return (x==y); }

    static void AddRefRecord(const CLKWrap<_Key,_Val>* pTest, int nIncr)
    {
        IRTLTRACE(_TEXT("AddRef(%p, %s) %d, cRefs == %d\n"),
                  pTest, pTest->m_k, nIncr, pTest->m_cRefs);

        if (nIncr == +1)
        {
            // or, perhaps, pIFoo->AddRef() (watch out for marshalling)
            // or ++pTest->m_cRefs (single-threaded only)
            InterlockedIncrement(&pTest->m_cRefs);
        }
        else if (nIncr == -1)
        {
            // or, perhaps, pIFoo->Release() or --pTest->m_cRefs;
            LONG l = InterlockedDecrement(&pTest->m_cRefs);

            // For some hashtables, it may also make sense to add the following
            if (l == 0) delete pTest;
            // but that would typically only apply when InsertRecord was
            // used thus
            //      lkrc = ht.InsertRecord(new CTest(foo, bar));
        }
        else
            IRTLASSERT(0);
    }
};

#include <map>
using namespace std;

class RawBstrLT
{
 public:
  bool operator()(const BSTR& x, const BSTR& y) const
  {
    return (_wcsicmp(x,y) < 0);
  }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\cocrypt.h ===
// CoCrypt.h: interface for the CCoCrypt class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_COCRYPT_H__41651BFB_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED_)
#define AFX_COCRYPT_H__41651BFB_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED_

const BYTE g_kMK[] = 
{
    0x38, 0x12, 0x87, 0x12, 0x00, 0xA1, 0xE9, 0x44,
    0x45, 0x92, 0x55, 0x08, 0x23, 0x55, 0x99, 0x04,
    0x14, 0x66, 0x29, 0x91, 0x06, 0xB8, 0x33, 0x0F
};


#include "BinHex.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef UNIX
#include <des.h>
#else
#include <des.h>
#include <tripldes.h>
#include <modes.h>
#endif

class CCoCrypt  
{
public:
  static int getKeyVersion(BSTR encrypted);
  static int getKeyVersion(BYTE *encrypted);
  CCoCrypt();
  virtual ~CCoCrypt();
  
  BOOL Decrypt(LPWSTR rawData,
               UINT dataSize, 
               BSTR *ppUnencrypted);
  BOOL Encrypt(int keyVersion, 
               LPSTR rawData,
               UINT dataSize,
               BSTR *ppEncrypted);

  void setKeyMaterial(BSTR newVal);
  unsigned char *getKeyMaterial(DWORD *pdwLen);
  void setWideMaterial(BSTR kvalue);
  BSTR getWideMaterial();

protected:
  BOOL CCoCrypt::encrypt(char ivec[9],
					   int cbPadding,
					   int keyVersion, 
			           LPSTR rawData,
					   UINT cbData,
			           BSTR *ppEncrypted);

  static CBinHex m_binhex;

  BOOL m_ok;

  unsigned char m_keyMaterial[24];
  _bstr_t       m_bstrWideMaterial;

#ifdef UNIX

  des_key_schedule ks1, ks2, ks3;

#else

  DES3TABLE ks;

#endif

};

#endif // !defined(AFX_COCRYPT_H__41651BFB_A5C8_11D2_95DF_00C04F8E7A70__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\keycrypto.h ===
// KeyManager.h: interface for the CKeyManagerHash class.
//
//////////////////////////////////////////////////////////////////////
#if !defined(_KEYCRYPTO_H)
#define _KEYCRYPTO_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Wincrypt.h"

/*
  typedef BYTE RAWKEY[24];
  typedef BYTE ENCKEY[56];
*/


class CKeyCrypto  
{
 public:
// ==
// NOTE: 
// when change the following strings, the ENCKEY_SIZE may be affected
//
  const static UINT  RAWKEY_SIZE = 24;

  CKeyCrypto();
  virtual ~CKeyCrypto(){};

  HRESULT encryptKey(DATA_BLOB* input, DATA_BLOB* output);
  HRESULT decryptKey(DATA_BLOB* input, DATA_BLOB* output);
  BOOL IsFromThis(PBYTE pData, ULONG cb);
  
 protected:
  DATA_BLOB    m_EntropyBlob;
};

#endif // !defined(_KEYCRYPTO_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\keyver.h ===
/**********************************************************************/
/**                       Microsoft Passport                         **/
/**                Copyright(c) Microsoft Corporation, 1999 - 2001   **/
/**********************************************************************/

/*
    keyver.h
       defines functions deal with key versions 


    FILE HISTORY:

*/
#ifndef __KEYVER_H_
#define __KEYVER_H_

#include "resource.h"       // main symbols

// Key version for admin interface
const int KEY_VERSION_MIN = 1;
const int KEY_VERSION_MAX = 35;


// return 0: invalid range, otherwize, returns ['0' - '9', 'A' - 'Z']
inline char KeyVerI2C(int i)
{
   if (i >= KEY_VERSION_MIN && i <= 9)  return (i + '0');
   if (i > 9 && i <= KEY_VERSION_MAX)  return (i - 10  + 'A');

   return 0;
      
};

// return -1: invalid char, return [KEY_VERSION_MIN, KEY_VERSION_MAX]
inline int KeyVerC2I(char c)
{
   if (c > '0' && c <= '9') return (c - '0');
   if (c >= 'A' && c <='Z') return (c - 'A' + 10);

   return -1;
   /* lower case is not being used as key version
   if islower(c) return (c - 'A' + 10);
   */
   
};

inline int KeyVerC2I(WCHAR c)
{
   // only ASCII is valid
   if (c & 0xff00)   return -1;

   return (KeyVerC2I((char)c));
};



#endif // KEYVER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\digest.h ===
/*++

    Copyright (c) 1998 Microsoft Corporation

    Module Name:

        CDigestAuth.h

    Abstract:

        This class performs digest authentication MD5 calculations.

    Author:

        Darren L. Anderson (darrenan) 5-Aug-1998

    Revision History:

        5-Aug-1998 darrenan

            Created.

--*/

#ifndef __DIGESTAUTH_H
#define __DIGESTAUTH_H

#include <windows.h>

#define DIGESTBUF_LEN  33

enum DIGEST_AUTH_NAMES
{
    DIGEST_AUTH_USERNAME=0,
    DIGEST_AUTH_REALM,
    DIGEST_AUTH_NONCE,
    DIGEST_AUTH_URI,
    DIGEST_AUTH_RESPONSE,
    DIGEST_AUTH_DIGEST,
    DIGEST_AUTH_ALGORITHM,
    DIGEST_AUTH_OPAQUE,
    DIGEST_AUTH_CNONCE,
    DIGEST_AUTH_QOP,
    DIGEST_AUTH_NC,
    DIGEST_AUTH_LAST
};

#ifdef __cplusplus
extern "C" {
#endif

VOID WINAPI
ToHex(
    LPBYTE pSrc,
    UINT   cSrc,
    LPSTR  pDst
    );
    
HRESULT WINAPI
DigestFromCreds(
    IN  LPCSTR  pszAlgorithm,
    IN  LPCSTR  pszUsername,
    IN  LPCSTR  pszRealm,
    IN  LPCSTR  pszPassword,
    IN  LPCSTR  pszNonce,
    IN  LPCSTR  pszNonceCount,
    IN  LPCSTR  pszCNonce,
    IN  LPCSTR  pszQOP,
    IN  LPCSTR  pszMethod,
    IN  LPCSTR  pszURI,
    IN  LPCSTR  pszEntityDigest,
    OUT LPSTR   pszSessionKey,
    OUT LPSTR   pszResult
    );

HRESULT WINAPI
DigestFromKey(
    IN  LPCSTR  pszAlgorithm,
    IN  LPCSTR  pszSessionKey,
    IN  LPCSTR  pszNonce,
    IN  LPCSTR  pszNonceCount,
    IN  LPCSTR  pszCNonce,
    IN  LPCSTR  pszQOP,
    IN  LPCSTR  pszMethod,
    IN  LPCSTR  pszURI,
    IN  LPCSTR  pszEntityDigest,
    OUT LPSTR   pszResult
    );


// Base64EncodeA and Base64EncodeW is provided for backward
// compatibility with the existing code only. 
HRESULT WINAPI
Base64EncodeA(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPSTR           pszDst
    );

HRESULT WINAPI
Base64EncodeW(               
    const LPBYTE    pSrc,
    ULONG           ulSrcSize,
    LPWSTR          pszDst
    );

/*
HRESULT WINAPI
Base64DecodeA(
    LPCSTR      pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst
    );

HRESULT WINAPI
Base64DecodeW(
    LPCWSTR     pszSrc,
    ULONG       ulSrcSize,
    LPBYTE      pDst
    );
*/

/////////////////////////////////////////////////////////////////////////////////////

typedef unsigned char Byte;
typedef long SInt32;
typedef unsigned long UInt32;
typedef unsigned char Boolean;

void WINAPI 
Base64_DecodeBytes(                         // base-64 encode a series of blocks
                const char *pSource,        // the source (can be the same as the destination)
                char *pTerminate,           // the source termination characters
                Byte *rDest,                // the destination (can be the same as the source)
                SInt32 *rDestSize);         // the number of dest bytes

void WINAPI
UU_DecodeBytes(                             // uu decode a series of blocks
                const char *pSource,        // the source (can be the same as the destination)
                char *pTerminate,           // the source termination characters
                Byte *rDest,                // the destination (can be the same as the source)
                SInt32 *rSize);             // the number of source bytes

void WINAPI
MSUU_DecodeBytes(                           // ms uu decode a series of blocks
                const char *pSource,        // the source (can be the same as the destination)
                char *pTerminate,           // the source termination characters
                Byte *rDest,                // the destination (can be the same as the source)
                SInt32 *rSize);             // the number of source bytes

void WINAPI
SixBit_DecodeBytes(                         // six bit decode a series of blocks
                const char *pSource,        // the source (can be the same as the destination)
                char *pTerminate,           // the source termination characters
                const Byte *pFromTable,     // conversion table
                Byte *rDest,                // the destination (can be the same as the source)
                SInt32 *rSize);             // the number of source bytes

void WINAPI
Base64_DecodeStream(                        // base-64 decode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const char *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // meaningless (for Base64_EncodeStream() compatibility)
                Byte *rDest,                // the destination
                SInt32 *rDestSize);         // returns the destination size

void WINAPI
UU_DecodeStream(                            // uu decode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const char *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // meaningless (for Base64_EncodeStream() compatibility)
                Byte *rDest,                // the destination
                SInt32 *rDestSize);         // returns the destination size

void WINAPI
MSUU_DecodeStream(                          // ms uu decode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const char *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // meaningless (for Base64_EncodeStream() compatibility)
                Byte *rDest,                // the destination
                SInt32 *rDestSize);         // returns the destination size

void WINAPI
SixBit_DecodeStream(                        // six bit decode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const char *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // meaningless (for Base64_EncodeStream() compatibility)
                const Byte *pFromTable,     // conversion table
                Byte *rDest,                // the destination
                SInt32 *rDestSize);         // returns the destination size

void WINAPI
Base64_EncodeStream(                        // base-64 encode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const Byte *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // terminate the stream
                char *rDest,                // the destination
                SInt32 *rDestSize);         // the destination size

void WINAPI
UU_EncodeStream(                            // uu encode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const Byte *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // terminate the stream
                char *rDest,                // the destination
                SInt32 *rDestSize);         // the destination size

void WINAPI
MSUU_EncodeStream(                          // ms uu encode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const Byte *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // terminate the stream
                char *rDest,                // the destination
                SInt32 *rDestSize);         // the destination size

void WINAPI
SixBit_EncodeStream(                        // six bit encode a stream of bytes
                Byte *pRemainder,           // the remainder from a previous encode (returns any new remainder)
                SInt32 *pRemainderSize,     // the size of the remainder (returns new new remainder size)
                const Byte *pSource,        // the source
                SInt32 pSourceSize,         // the source size
                Boolean pTerminate,         // terminate the stream
                const char *pToTable,       // conversion table
                char *rDest,                // the destination
                SInt32 *rDestSize);         // the destination size


void WINAPI
Base64_EncodeBytes(                         // base-64 encode a series of whole blocks
                const Byte *pSource,        // the source (can be the same as the destination)
                SInt32 pSourceSize,         // the number of source bytes
                char *rDest,                // the destination (can be the same as the source)
                SInt32 *rDesteSize);        // returns the dest size

void WINAPI
UU_EncodeBytes(                             // uu encode a series of whole blocks
                const Byte *pSource,        // the source (can be the same as the destination)
                SInt32 pSourceSize,         // the number of source bytes
                char *rDest,                // the destination (can be the same as the source)
                SInt32 *rDesteSize);        // returns the dest size

void WINAPI
MSUU_EncodeBytes(                           // ms uu encode a series of whole blocks
                const Byte *pSource,        // the source (can be the same as the destination)
                SInt32 pSourceSize,         // the number of source bytes
                char *rDest,                // the destination (can be the same as the source)
                SInt32 *rDesteSize);        // returns the dest size

void WINAPI
SixBit_EncodeBytes(                         // six bit encode a series of whole blocks
                const Byte *pSource,        // the source (can be the same as the destination)
                SInt32 pSourceSize,         // the number of source bytes
                const char *pToTable,       // conversion table
                char *rDest,                // the destination (can be the same as the source)
                SInt32 *rDesteSize);        // returns the dest size

extern const char cToBase64[66];
extern const Byte cFromBase64[257];
extern const char cToUU[66];
extern const Byte cFromUU[257];
extern const char cToMSUU[66];
extern const Byte cFromMSUU[257];

/////////////////////////////////////////////////////////////////////////////////////

HRESULT WINAPI 
GenerateNonce(BYTE *pSrcStr, 
              long lSrcSize, 
              BYTE *pDestStr, 
              long *plDestSize);


HRESULT WINAPI 
CheckNonce(BYTE* pNonce,
           long lSrcSize,
           long lTimeoutWindow = 300, // default to 5 minutes
           long lCurTime = 0);



#if defined(UNICODE) || defined(_UNICODE)
#define Base64Encode Base64EncodeW
//#define Base64Decode Base64DecodeW
#else
#define Base64Encode Base64EncodeA
//#define Base64Decode Base64DecodeA
#endif

BOOL
ParseAuthorizationHeader(
    LPSTR pszHeader, 
    LPSTR pValueTable[DIGEST_AUTH_LAST]
    );

#ifdef __cplusplus
}
#endif

#endif // __DIGESTAUTH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\irtldbg.h ===
/*++

   Copyright    (c)    1998-2002    Microsoft Corporation

   Module  Name :
       irtldbg.h

   Abstract:
       Some simple debugging macros that look and behave a lot like their
       namesakes in MFC.  These macros should work in both C and C++ and do
       something useful with almost any Win32 compiler.

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __IRTLDBG_H__
#define __IRTLDBG_H__

#ifndef __IRTLMISC_H__
# include <irtlmisc.h>
#endif

/* Ensure that MessageBoxes can popup */
# define IRTLDBG_RUNNING_AS_SERVICE 1

#include <tchar.h>


// Compile-time (not run-time) assertion. Code will not compile if
// expr is false. Note: there is no non-debug version of this; we
// want this for all builds. The compiler optimizes the code away.
template <bool> struct static_checker;
template <> struct static_checker<true> {};  // specialize only for `true'
#define STATIC_ASSERT(expr) static_checker< (expr) >()


# ifndef _AFX
  /* Assure compatiblity with MFC */

# ifdef _DEBUG
#  define IRTLDEBUG
# endif

# ifdef IRTLDEBUG
#  ifndef USE_DEBUG_CRTS
    /* IIS (and NT) do not ship msvcrtD.dll, per the VC license,
     * so we can't use the assertion code from <crtdbg.h>.  Use similar
     * macros from <pudebug.h> instead. */
#   include <pudebug.h>

    /* workaround for /W4 warnings about 'constant expressions' */
#   define IRTLASSERT(f)                                    \
    ((void) ((f) || (PuDbgAssertFailed(DBG_CONTEXT, #f), 0) ))

#  elif defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
    /* Use the new debugging tools in Visual C++ 4.x */
#   include <crtdbg.h>
    /* _ASSERTE will give a more meaningful message, but the string takes
     * space.  Use _ASSERT if this is an issue. */
#   define IRTLASSERT(f) _ASSERTE(f)
#  else
#   include <assert.h>
#   define IRTLASSERT(f) assert(f)
#  endif

#  define IRTLVERIFY(f)               IRTLASSERT(f)
#  ifndef DEBUG_ONLY
#   define DEBUG_ONLY(f)              (f)
#  endif
#  define IRTLTRACE                   IrtlTrace
#  define IRTLTRACE0(psz)             IrtlTrace(_T("%s"), _T(psz))
#  define IRTLTRACE1(psz, p1)         IrtlTrace(_T(psz), p1)
#  define IRTLTRACE2(psz, p1, p2)     IrtlTrace(_T(psz), p1, p2)
#  define IRTLTRACE3(psz, p1, p2, p3) IrtlTrace(_T(psz), p1, p2, p3)
#  define IRTLTRACE4(psz, p1, p2, p3, p4) \
                                      IrtlTrace(_T(psz), p1, p2, p3, p4)
#  define IRTLTRACE5(psz, p1, p2, p3, p4, p5) \
                                      IrtlTrace(_T(psz), p1, p2, p3, p4, p5)
#  define ASSERT_VALID(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->AssertValid();} while (0)
#  define DUMP(pObj)  \
     do {IRTLASSERT((pObj) != NULL); (pObj)->Dump();} while (0)

# else /* !IRTLDEBUG */

  /* These macros should all compile away to nothing */
#  define IRTLASSERT(f)           ((void)0)
#  define IRTLVERIFY(f)           ((void)(f))
#  ifndef DEBUG_ONLY
#   define DEBUG_ONLY(f)          ((void)0)
#  endif
#  define IRTLTRACE               1 ? (void)0 : IrtlTrace
#  define IRTLTRACE0(psz)         1 ? (void)0 : IrtlTrace
#  define IRTLTRACE1(psz, p1)     1 ? (void)0 : IrtlTrace
#  define IRTLTRACE2(psz, p1, p2) 1 ? (void)0 : IrtlTrace
#  define IRTLTRACE3(psz, p1, p2, p3)         1 ? (void)0 : IrtlTrace
#  define IRTLTRACE4(psz, p1, p2, p3, p4)     1 ? (void)0 : IrtlTrace
#  define IRTLTRACE5(psz, p1, p2, p3, p4, p5) 1 ? (void)0 : IrtlTrace
#  define ASSERT_VALID(pObj)      ((void)0)
#  define DUMP(pObj)              ((void)0)

# endif /* !IRTLDEBUG */


# define ASSERT_POINTER(p, type) \
    IRTLASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

# define ASSERT_NULL_OR_POINTER(p, type) \
    IRTLASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_STRING(s) \
    IRTLASSERT(((s) != NULL)  &&  IsValidString((s), -1))

#define ASSERT_NULL_OR_STRING(s) \
    IRTLASSERT(((s) == NULL)  ||  IsValidString((s), -1))


/* Declarations for non-Windows apps */

# ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
# endif /* _WINDEF_ */

# ifndef TRUE
#  define FALSE  0
#  define TRUE   1
# endif


# ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

}

# else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
IRTL_DLLEXP BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
IRTL_DLLEXP BOOL IsValidString(LPCTSTR ptsz, int nLength);

# endif /* !__cplusplus */

#else
# define IRTLASSERT(f) _ASSERTE(f)

#endif /* !_AFX */


/* Writes trace messages to debug stream */
extern
#ifdef __cplusplus
"C"
#endif /* !__cplusplus */
IRTL_DLLEXP
void __cdecl
IrtlTrace(
    LPCTSTR pszFormat,
    ...);


#ifdef IRTLDEBUG
# define IRTL_DEBUG_INIT()            IrtlDebugInit()
# define IRTL_DEBUG_TERM()            IrtlDebugTerm()
#else /* !IRTLDEBUG */
# define IRTL_DEBUG_INIT()            ((void)0)
# define IRTL_DEBUG_TERM()            ((void)0)
#endif /* !IRTLDEBUG */


#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/* should be called from main(), WinMain(), or DllMain() */
IRTL_DLLEXP void
IrtlDebugInit();

IRTL_DLLEXP void
IrtlDebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __IRTLDBG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\irtlmisc.h ===
/*++

   Copyright    (c)    1998-2002    Microsoft Corporation

   Module  Name :
       irtlmisc.h

   Abstract:
       Declares miscellaneous functions and classes in IisRtl.DLL

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/


#ifndef __IRTLMISC_H__
#define __IRTLMISC_H__

#include <windows.h>

//--------------------------------------------------------------------
// These declarations are needed to export the template classes from
// IisRtl.DLL and import them into other modules.

#ifndef IRTL_DLLEXP
# ifdef DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllexport)
#  ifdef IMPLEMENTATION_EXPORT
#   define IRTL_EXPIMP
#  else
#   undef  IRTL_EXPIMP
#  endif 
# else // !DLL_IMPLEMENTATION
#  define IRTL_DLLEXP __declspec(dllimport)
#  define IRTL_EXPIMP extern
# endif // !DLL_IMPLEMENTATION 
#endif // !IRTL_DLLEXP



//--------------------------------------------------------------------
// Miscellaneous functions

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


// how many CPUs on this machine?
inline int NumProcessors()
{
    static int s_nCPUs = 0;
    
    if (s_nCPUs == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nCPUs = si.dwNumberOfProcessors;
    }
    return s_nCPUs;
}


// Type of processor, 386, 486, etc
inline int ProcessorType()
{
    static int s_nProcessorType = 0;
    
    if (s_nProcessorType == 0)
    {
        SYSTEM_INFO si;
        GetSystemInfo(&si);
        s_nProcessorType = si.dwProcessorType;
    }
    return s_nProcessorType;
}


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __IRTLMISC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\locks.h ===
/*++

   Copyright    (c)    1998-2002    Microsoft Corporation

   Module  Name :
       locks.h

   Abstract:
       A collection of locks for multithreaded access to data structures

   Author:
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:

--*/

#ifndef __LOCKS_H__
#define __LOCKS_H__

//--------------------------------------------------------------------
// File: locks.h
//
// A collection of different implementations of read/write locks that all
// share the same interface.  This allows different locks to be plugged
// into C++ templates as parameters.
//
// The implementations are:
//      CSmallSpinLock      lightweight critical section
//      CSpinLock           variant of CSmallSpinLock
//      CFakeLock           do-nothing class; useful as a template parameter
//      CCritSec            Win32 CRITICAL_SECTION
//   Multi-Reader/Single-Writer locks:
//      CReaderWriterLock   MRSW lock from Neel Jain
//      CReaderWriterLock2  smaller implementation of CReaderWriterLock
//      CReaderWriterLock3  CReaderWriterLock2 with recursive WriteLock
//
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> can used as
// exception-safe wrappers.
//
// TODO:
// * Add per-class lock-contention statistics
// * Add a timeout feature to Try{Read,Write}Lock
// * Add some way of tracking all the owners of a multi-reader lock
//--------------------------------------------------------------------



#ifndef __IRTLDBG_H__
# include <irtldbg.h>
#endif


enum LOCK_LOCKTYPE {
    LOCK_SMALLSPINLOCK = 1,
    LOCK_SPINLOCK,
    LOCK_FAKELOCK,
    LOCK_CRITSEC,
    LOCK_READERWRITERLOCK,
    LOCK_READERWRITERLOCK2,
    LOCK_READERWRITERLOCK3,
};


// Forward declarations
class IRTL_DLLEXP CSmallSpinLock;
class IRTL_DLLEXP CSpinLock;
class IRTL_DLLEXP CFakeLock;
class IRTL_DLLEXP CCritSec;
class IRTL_DLLEXP CReaderWriterLock;
class IRTL_DLLEXP CReaderWriterLock2;
class IRTL_DLLEXP CReaderWriterLock3;



#if defined(_MSC_VER)  &&  (_MSC_VER >= 1200)
// __forceinline keyword new to VC6
# define LOCK_FORCEINLINE __forceinline
#else
# define LOCK_FORCEINLINE inline
#endif

#ifdef _M_IX86
// The compiler will warn that the assembly language versions of the
// Lock_Atomic* functions don't return a value. Actually, they do: in EAX.
# pragma warning(disable: 4035)
#endif

// Workarounds for certain useful interlocked operations that are not
// available on Windows 95. Note: the CMPXCHG and XADD instructions were
// introduced in the 80486. If you still need to run on a 386 (unlikely in
// 2000), you'll need to use something else.

LOCK_FORCEINLINE
LONG
Lock_AtomicIncrement(
    IN OUT PLONG plAddend)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddend
             mov        eax,    1
        lock xadd       [ecx],  eax
             inc        eax                 // correct result
    }
#else
    return InterlockedIncrement(plAddend);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicDecrement(
    IN OUT PLONG plAddend)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddend
             mov        eax,    -1
        lock xadd       [ecx],  eax
             dec        eax                 // correct result
    }
#else
    return InterlockedDecrement(plAddend);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        edx,    lNew
             mov        eax,    [ecx]
    LAEloop:
        lock cmpxchg    [ecx],  edx
             jnz        LAEloop
    }
#else
    return InterlockedExchange(plAddr, lNew);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicCompareExchange(
    IN OUT PLONG plAddr,
    IN LONG      lNew,
    IN LONG      lCurrent)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        edx,    lNew
             mov        eax,    lCurrent
        lock cmpxchg    [ecx],  edx
    }
#else
    return InterlockedCompareExchange(plAddr, lNew, lCurrent);
#endif
}

LOCK_FORCEINLINE
LONG
Lock_AtomicExchangeAdd(
    IN OUT LPLONG plAddr,
    IN LONG       lValue)
{
#ifdef _M_IX86
    __asm
    {
             mov        ecx,    plAddr
             mov        eax,    lValue
        lock xadd       [ecx],  eax
    }
#else
    return InterlockedExchangeAdd(plAddr, lValue);
#endif
}



#ifdef _M_IX86
# pragma warning(default: 4035)
// Makes tight loops a little more cache friendly and reduces power
// consumption. Needed on Willamette processors.
# define Lock_Yield()    _asm { rep nop }
#else
# define Lock_Yield()    ((void) 0)
#endif



//--------------------------------------------------------------------
// Spin count values.
enum LOCK_SPINS {
    LOCK_MAXIMUM_SPINS =      10000,    // maximum allowable spin count
    LOCK_DEFAULT_SPINS =       4000,    // default spin count
    LOCK_MINIMUM_SPINS =        100,    // minimum allowable spin count
    LOCK_USE_DEFAULT_SPINS = 0xFFFF,    // use class default spin count
    LOCK_DONT_SPIN =              0,    // don't spin at all
};


// Boilerplate code for the per-class default spincount and spinfactor

#define LOCK_DEFAULT_SPIN_IMPLEMENTATION()                                  \
protected:                                                                  \
    /* per-class variables */                                               \
    static   WORD   sm_wDefaultSpinCount;   /* global default spin count */   \
    static   double sm_dblDfltSpinAdjFctr;  /* global spin adjustment factor*/\
                                                                            \
public:                                                                     \
    /* Set the default spin count for all locks */                          \
    static void SetDefaultSpinCount(WORD wSpins)                            \
    {                                                                       \
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)                               \
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)                    \
                   || (LOCK_MINIMUM_SPINS <= wSpins                         \
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));                  \
                                                                            \
        if ((LOCK_MINIMUM_SPINS <= wSpins  &&  wSpins <= LOCK_MAXIMUM_SPINS)\
                || (wSpins == LOCK_DONT_SPIN))                              \
            sm_wDefaultSpinCount = wSpins;                                  \
        else if (wSpins == LOCK_USE_DEFAULT_SPINS)                          \
            sm_wDefaultSpinCount = LOCK_DEFAULT_SPINS;                      \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static WORD GetDefaultSpinCount()                                       \
    {                                                                       \
        return sm_wDefaultSpinCount;                                        \
    }                                                                       \
                                                                            \
    /* Set the adjustment factor for the spincount, used in each iteration */\
    /* of countdown-and-sleep by the backoff algorithm. */                  \
    static void SetDefaultSpinAdjustmentFactor(double dblAdjFactor)         \
    {                                                                       \
        IRTLASSERT(0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0);          \
        if (0.1 <= dblAdjFactor  &&  dblAdjFactor <= 10.0)                  \
            sm_dblDfltSpinAdjFctr = dblAdjFactor;                           \
    }                                                                       \
                                                                            \
    /* Return the default spin count for all locks */                       \
    static double GetDefaultSpinAdjustmentFactor()                          \
    {                                                                       \
        return sm_dblDfltSpinAdjFctr;                                       \
    }                                                                       \



//--------------------------------------------------------------------
// Various Lock Traits

// Is the lock a simple mutex or a multi-reader/single-writer lock?
enum LOCK_RW_MUTEX {
    LOCK_MUTEX = 1,         // mutexes allow only one thread to hold the lock
    LOCK_MRSW,              // multi-reader, single-writer
};


// Can the lock be recursively acquired?
enum LOCK_RECURSION {
    LOCK_RECURSIVE = 1,     // Write and Read locks can be recursively acquired
    LOCK_READ_RECURSIVE,    // Read locks can be reacquired, but not Write
    LOCK_NON_RECURSIVE,     // Will deadlock if attempt to acquire recursively
};


// Does the lock Sleep in a loop or block on a kernel synch object handle?
// May (or may not) spin first before sleeping/blocking.
enum LOCK_WAIT_TYPE {
    LOCK_WAIT_SLEEP = 1,    // Calls Sleep() in a loop
    LOCK_WAIT_HANDLE,       // Blocks on a kernel mutex, semaphore, or event
};


// When the lock is taken, how are the waiters dequeued?
enum LOCK_QUEUE_TYPE {
    LOCK_QUEUE_FIFO = 1,    // First in, first out.  Fair.
    LOCK_QUEUE_LIFO,        // Unfair but CPU cache friendly
    LOCK_QUEUE_KERNEL,      // Determined by vagaries of scheduler
};


// Can the lock's spincount be set on a per-lock basis, or is it only
// possible to modify the default spincount for all the locks in this class?
enum LOCK_PERLOCK_SPIN {
    LOCK_NO_SPIN = 1,       // The locks do not spin at all
    LOCK_CLASS_SPIN,        // Can set class-wide spincount, not individual
    LOCK_INDIVIDUAL_SPIN,   // Can set a spincount on an individual lock
};


//--------------------------------------------------------------------
// CLockBase: bundle the above attributes

template < LOCK_LOCKTYPE     locktype,
           LOCK_RW_MUTEX     mutextype,
           LOCK_RECURSION    recursiontype,
           LOCK_WAIT_TYPE    waittype,
           LOCK_QUEUE_TYPE   queuetype,
           LOCK_PERLOCK_SPIN spintype
         >
class CLockBase
{
public:
    static LOCK_LOCKTYPE     LockType()     {return locktype;}
    static LOCK_RW_MUTEX     MutexType()    {return mutextype;}
    static LOCK_RECURSION    Recursion()    {return recursiontype;}
    static LOCK_WAIT_TYPE    WaitType()     {return waittype;}
    static LOCK_QUEUE_TYPE   QueueType()    {return queuetype;}
    static LOCK_PERLOCK_SPIN PerLockSpin()  {return spintype;}
};



// Lock instrumentation causes all sorts of interesting statistics about
// lock contention, etc., to be gathered, but makes locks considerably fatter
// and somewhat slower.  Turned off by default.

// #define LOCK_INSTRUMENTATION 1

#ifdef LOCK_INSTRUMENTATION

// We generally don't want to instrument CSmallSpinLock in addition
// to CSpinLock1, as it makes a CSpinLock1 huge.

// #define LOCK_SMALL_SPIN_INSTRUMENTATION 1

//--------------------------------------------------------------------
// CLockStatistics: statistics for an individual lock

class IRTL_DLLEXP CLockStatistics
{
public:
    enum {
        L_NAMELEN = 8,
    };
    
    double   m_nContentions;     // #times this lock was already locked
    double   m_nSleeps;          // Total #Sleep()s needed
    double   m_nContentionSpins; // Total iterations this lock spun
    double   m_nAverageSpins;    // Average spins each contention needed
    double   m_nReadLocks;       // Number of times lock acquired for reading
    double   m_nWriteLocks;      // Number of times lock acquired for writing
    TCHAR    m_tszName[L_NAMELEN];// Name of this lock

    CLockStatistics()
        : m_nContentions(0),
          m_nSleeps(0),
          m_nContentionSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {
        m_tszName[0] = _TEXT('\0');
    }
};



//--------------------------------------------------------------------
// CGlobalLockStatistics: statistics for all the known locks

class IRTL_DLLEXP CGlobalLockStatistics
{
public:
    LONG     m_cTotalLocks;     // Total number of locks created
    LONG     m_cContendedLocks; // Total number of contended locks
    LONG     m_nSleeps;         // Total #Sleep()s needed by all locks
    LONGLONG m_cTotalSpins;     // Total iterations all locks spun
    double   m_nAverageSpins;   // Average spins needed for each contended lock
    LONG     m_nReadLocks;      // Total ReadLocks
    LONG     m_nWriteLocks;     // Total WriteLocks

    CGlobalLockStatistics()
        : m_cTotalLocks(0),
          m_cContendedLocks(0),
          m_nSleeps(0),
          m_cTotalSpins(0),
          m_nAverageSpins(0),
          m_nReadLocks(0),
          m_nWriteLocks(0)
    {}
};

# define LOCK_INSTRUMENTATION_DECL() \
private:                                                                    \
    volatile LONG   m_nContentionSpins; /* #iterations this lock spun */    \
    volatile WORD   m_nContentions;     /* #times lock was already locked */\
    volatile WORD   m_nSleeps;          /* #Sleep()s needed */              \
    volatile WORD   m_nReadLocks;       /* #ReadLocks */                    \
    volatile WORD   m_nWriteLocks;      /* #WriteLocks */                   \
    TCHAR           m_tszName[CLockStatistics::L_NAMELEN]; /* Name of lock */\
                                                                            \
    static   LONG   sm_cTotalLocks;     /* Total number of locks created */ \
    static   LONG   sm_cContendedLocks; /* Total number of contended locks */\
    static   LONG   sm_nSleeps;         /* Total #Sleep()s by all locks */  \
    static LONGLONG sm_cTotalSpins;     /* Total iterations all locks spun */\
    static   LONG   sm_nReadLocks;      /* Total ReadLocks */               \
    static   LONG   sm_nWriteLocks;     /* Total WriteLocks */              \
                                                                            \
public:                                                                     \
    const TCHAR* Name() const       {return m_tszName;}                     \
                                                                            \
    CLockStatistics                 Statistics() const;                     \
    static CGlobalLockStatistics    GlobalStatistics();                     \
    static void                     ResetGlobalStatistics();                \
private:                                                                    \


// Add this to constructors

# define LOCK_INSTRUMENTATION_INIT(ptszName)        \
    m_nContentionSpins = 0;                         \
    m_nContentions = 0;                             \
    m_nSleeps = 0;                                  \
    m_nReadLocks = 0;                               \
    m_nWriteLocks = 0;                              \
    ++sm_cTotalLocks;                               \
    if (ptszName == NULL)                           \
        m_tszName[0] = _TEXT('\0');                 \
    else                                            \
        _tcsncpy(m_tszName, ptszName, sizeof(m_tszName)/sizeof(TCHAR))

// Note: we are not using Interlocked operations for the shared
// statistical counters.  We'll lose perfect accuracy, but we'll
// gain by reduced bus synchronization traffic.

# define LOCK_READLOCK_INSTRUMENTATION()    \
      { ++m_nReadLocks;                     \
        ++sm_nReadLocks; }

# define LOCK_WRITELOCK_INSTRUMENTATION()   \
      { ++m_nWriteLocks;                    \
        ++sm_nWriteLocks; }

#else // !LOCK_INSTRUMENTATION

# define LOCK_INSTRUMENTATION_DECL()
# define LOCK_READLOCK_INSTRUMENTATION()    ((void) 0)
# define LOCK_WRITELOCK_INSTRUMENTATION()   ((void) 0)

#endif // !LOCK_INSTRUMENTATION



//--------------------------------------------------------------------
// CAutoReadLock<Lock> and CAutoWriteLock<Lock> provide exception-safe
// acquisition and release of the other locks defined below

template <class _Lock>
class CAutoReadLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoReadLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }
    ~CAutoReadLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.ReadLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_Lock.ReadUnlock();
            m_fLocked = false;
        }
    }
};



template <class _Lock>
class CAutoWriteLock
{
private:
    bool    m_fLocked;
    _Lock&  m_Lock;

public:
    CAutoWriteLock(
        _Lock& rLock,
        bool   fLockNow = true)
        : m_fLocked(false), m_Lock(rLock)
    {
        if (fLockNow)
            Lock();
    }

    ~CAutoWriteLock()
    {
        Unlock();
    }
    
    void Lock()
    {
        // disallow recursive acquisition of the lock through this wrapper
        if (!m_fLocked)
        {
            m_fLocked = true;
            m_Lock.WriteLock();
        }
    }
    
    void Unlock()
    {
        if (m_fLocked)
        {
            m_fLocked = false;
            m_Lock.WriteUnlock();
        }
    }
};




//--------------------------------------------------------------------
// A spinlock is a sort of lightweight critical section.  Its main
// advantage over a true Win32 CRITICAL_SECTION is that it occupies 4 bytes
// instead of 24 (+ another 32 bytes for the RTL_CRITICAL_SECTION_DEBUG data),
// which is important when we have many thousands of locks
// and we're trying to be L1 cache-conscious.  A CRITICAL_SECTION also
// contains a HANDLE to a semaphore, although this is not initialized until
// the first time that the CRITICAL_SECTION blocks.
//
// On a multiprocessor machine, a spinlock tries to acquire the lock.  If
// it fails, it sits in a tight loop, testing the lock and decrementing a
// counter.  If the counter reaches zero, it does a Sleep(0), yielding the
// processor to another thread.  When control returns to the thread, the
// lock is probably free.  If not, the loop starts again and it is
// terminated only when the lock is acquired.  The theory is that it is
// less costly to spin in a busy loop for a short time rather than
// immediately yielding the processor, forcing an expensive context switch
// that requires the old thread's state (registers, etc) be saved, the new
// thread's state be reloaded, and the L1 and L2 caches be left full of
// stale data.
//
// You can tune the spin count (global only: per-lock spin counts are 
// disabled) and the backoff algorithm (the factor by which the spin
// count is multiplied after each Sleep).
//
// On a 1P machine, the loop is pointless---this thread has control,
// hence no other thread can possibly release the lock while this thread
// is looping---so the processor is yielded immediately.
//
// The kernel uses spinlocks internally and spinlocks were also added to
// CRITICAL_SECTIONs in NT 4.0 sp3.  In the CRITICAL_SECTION implementation,
// however, the counter counts down only once and waits on a semaphore
// thereafter (i.e., the same blocking behavior that it exhibits without
// the spinlock).
//
// A disadvantage of a user-level spinlock such as this is that if the
// thread that owns the spinlock blocks for any reason (or is preempted by
// the scheduler), all the other threads will continue to spin on the
// spinlock, wasting CPU, until the owning thread completes its wait and
// releases the lock.  (The kernel spinlocks, however, are smart enough to
// switch to another runnable thread instead of wasting time spinning.)
// The backoff algorithm decreases the spin count on each iteration in an
// attempt to minimize this effect.  The best policy---and this is true for
// all locks---is to hold the lock for as short as time as possible.
//
// Note: unlike a CRITICAL_SECTION, a CSmallSpinLock cannot be recursively
// acquired; i.e., if you acquire a spinlock and then attempt to acquire it
// again *on the same thread* (perhaps from a different function), the
// thread will hang forever.  Use CSpinLock instead, which is safe though a
// little slower than a CSmallSpinLock.  If you own all the code
// that is bracketed by Lock() and Unlock() (e.g., no callbacks or passing
// back of locked data structures to callers) and know for certain that it
// will not attempt to reacquire the lock, you can use CSmallSpinLock.
//
// See also http://muralik/work/performance/spinlocks.htm and John Vert's
// MSDN article, "Writing Scalable Applications for Windows NT".
//
// The original implementation is due to PALarson.

class IRTL_DLLEXP CSmallSpinLock :
    public CLockBase<LOCK_SMALLSPINLOCK, LOCK_MUTEX,
                       LOCK_NON_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lTid;              // The lock state variable

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
    LOCK_INSTRUMENTATION_DECL();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        return (LONG) (dwTid);
    }

private:
    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = _CurrentThreadId();

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }

public:

#ifndef LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_SMALL_SPIN_INSTRUMENTATION

    CSmallSpinLock(
        const TCHAR* ptszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CSmallSpinLock()
    {
        IRTLASSERT(m_lTid == 0);
    }
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        // Optimize for the common case by helping the processor's branch
        // prediction algorithm.
        if (_TryLock())
            return;

        _LockSpin();
    }

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        if (_TryLock())
            return;

        _LockSpin();
    }

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

#ifdef LOCK_SMALL_SPIN_INSTRUMENTATION
        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();
#endif // LOCK_SMALL_SPIN_INSTRUMENTATION

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    // Assumes caller owned the lock.
    inline void WriteUnlock()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    // Assumes caller owned the lock.
    inline void ReadUnlock()
    {
        WriteUnlock();
    }

    // Is the lock already locked for writing by this thread?
    bool IsWriteLocked() const
    {
        return (m_lTid == _CurrentThreadId());
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return IsWriteLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return (m_lTid == 0);
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return IsWriteUnlocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }

    // Set the spin count for this lock.
    // Returns true if successfully set the per-lock spincount, false otherwise
    bool SetSpinCount(WORD wSpins)
    {
        UNREFERENCED_PARAMETER(wSpins);
        IRTLASSERT((wSpins == LOCK_DONT_SPIN)
                   || (wSpins == LOCK_USE_DEFAULT_SPINS)
                   || (LOCK_MINIMUM_SPINS <= wSpins
                       &&  wSpins <= LOCK_MAXIMUM_SPINS));

        return false;
    }

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CSmallSpinLock");}
}; // CSmallSpinLock




//--------------------------------------------------------------------
// CSpinLock is a spinlock that doesn't deadlock if recursively acquired.
// This version occupies only 4 bytes.  Uses 28 bits for the thread id.

class IRTL_DLLEXP CSpinLock :
    public CLockBase<LOCK_SPINLOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    // a union for convenience
    volatile LONG m_lTid;

    enum {
        THREAD_SHIFT = 0,
        THREAD_BITS  = 28,
        OWNER_SHIFT  = THREAD_BITS,
        OWNER_BITS   = 4,
        THREAD_MASK  = ((1 << THREAD_BITS) - 1) << THREAD_SHIFT,
        OWNER_INCR   = 1 << THREAD_BITS,
        OWNER_MASK   = ((1 << OWNER_BITS) - 1) << OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    LOCK_FORCEINLINE static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        // Thread ID 0 is used by the System Idle Process (Process ID 0).
        // We use a thread-id of zero to indicate that the lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != 0
                   && ((dwTid <= THREAD_MASK) || (dwTid > ~THREAD_MASK)));
        return (LONG) (dwTid & THREAD_MASK);
    }

    // Attempt to acquire the lock without blocking
    LOCK_FORCEINLINE bool _TryLock()
    {
        if (m_lTid == 0)
        {
            LONG l = _CurrentThreadId() | OWNER_INCR;

            return (Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lTid), l,0)
                    == 0);
        }
        else
            return false;
    }


    // Acquire the lock, recursively if need be
    void _Lock()
    {
        // Do we own the lock already?  Just bump the count.
        if ((m_lTid & THREAD_MASK) == _CurrentThreadId())
        {
            // owner count isn't maxed out?
            IRTLASSERT((m_lTid & OWNER_MASK) != OWNER_MASK);

            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid),
                                m_lTid + OWNER_INCR);
        }

        // Some other thread owns the lock.  We'll have to spin :-(.
        else
            _LockSpin();

        IRTLASSERT((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());
    }


    // Release the lock
    LOCK_FORCEINLINE void _Unlock()
    {
        IRTLASSERT((m_lTid & OWNER_MASK) > 0
                   &&  (m_lTid & THREAD_MASK) == _CurrentThreadId());

        LONG l = m_lTid - OWNER_INCR; 

        // Last owner?  Release completely, if so
        if ((l & OWNER_MASK) == 0)
            l = 0;

        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), l);
    }


    // Return true if the lock is owned by this thread
    bool _IsLocked() const
    {
        bool fLocked = ((m_lTid & THREAD_MASK) == _CurrentThreadId());

        IRTLASSERT(!fLocked || ((m_lTid & OWNER_MASK) > 0
                               && (m_lTid & THREAD_MASK)==_CurrentThreadId()));

        return fLocked;
    }


    // Does all the spinning (and instrumentation) if the lock is contended.
    void _LockSpin();

public:

#ifndef LOCK_INSTRUMENTATION

    CSpinLock()
        : m_lTid(0)
    {}

#else // LOCK_INSTRUMENTATION

    CSpinLock(
        const TCHAR* ptszName)
        : m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }

#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CSpinLock()
    {
        IRTLASSERT(m_lTid == 0);
    }
#endif // IRTLDEBUG

    // Acquire an exclusive lock for writing.  Blocks until acquired.
    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }
    

    // Acquire a (possibly shared) lock for reading.  Blocks until acquired.
    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Is the lock unowned?
        if (_TryLock())
            return; // got the lock
        
        _Lock();
    }

    // See the description under CReaderWriterLock3::ReadOrWriteLock
    inline bool ReadOrWriteLock()
    {
        ReadLock();
        return true;
    } 

    // Try to acquire an exclusive lock for writing.  Returns true
    // if successful.  Non-blocking.
    inline bool TryWriteLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_WRITELOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Try to acquire a (possibly shared) lock for reading.  Returns true
    // if successful.  Non-blocking.
    inline bool TryReadLock()
    {
        bool fAcquired = _TryLock();

        if (fAcquired)
            LOCK_READLOCK_INSTRUMENTATION();

        return fAcquired;
    }

    // Unlock the lock after a successful call to {,Try}WriteLock().
    inline void WriteUnlock()
    {
        _Unlock();
    }

    // Unlock the lock after a successful call to {,Try}ReadLock().
    inline void ReadUnlock()
    {
        _Unlock();
    }

    // Unlock the lock after a call to ReadOrWriteLock().
    inline void ReadOrWriteUnlock(bool)
    {
        ReadUnlock();
    } 

    // Is the lock already locked for writing?
    bool IsWriteLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock already locked for reading?
    bool IsReadLocked() const
    {
        return _IsLocked();
    }
    
    // Is the lock unlocked for writing?
    bool IsWriteUnlocked() const
    {
        return !IsWriteLocked();
    }
    
    // Is the lock unlocked for reading?
    bool IsReadUnlocked() const
    {
        return !IsReadLocked();
    }
    
    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Set the spin count for this lock.
    bool SetSpinCount(WORD)             {return false;}

    // Return the spin count for this lock.
    WORD GetSpinCount() const
    {
        return sm_wDefaultSpinCount;
    }
    
    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CSpinLock");}
}; // CSpinLock




//--------------------------------------------------------------------
// A dummy class, primarily useful as a template parameter

class IRTL_DLLEXP CFakeLock :
    public CLockBase<LOCK_FAKELOCK, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_FIFO,
                       LOCK_NO_SPIN
                      >
{
private:
    LOCK_INSTRUMENTATION_DECL();

public:
    CFakeLock()                     {} 
#ifdef LOCK_INSTRUMENTATION
    CFakeLock(const char*)          {}
#endif // LOCK_INSTRUMENTATION
    ~CFakeLock()                    {} 
    void WriteLock()                {} 
    void ReadLock()                 {} 
    bool ReadOrWriteLock()          {return true;} 
    bool TryWriteLock()             {return true;} 
    bool TryReadLock()              {return true;} 
    void WriteUnlock()              {}
    void ReadUnlock()               {}
    void ReadOrWriteUnlock(bool)    {}
    bool IsWriteLocked() const      {return true;} 
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}
    bool IsReadUnlocked() const     {return true;}
    void ConvertSharedToExclusive() {}
    void ConvertExclusiveToShared() {}
    bool SetSpinCount(WORD)         {return false;}
    WORD GetSpinCount() const       {return LOCK_DONT_SPIN;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CFakeLock");}
}; // CFakeLock




//--------------------------------------------------------------------
// A Win32 CRITICAL_SECTION

class IRTL_DLLEXP CCritSec :
    public CLockBase<LOCK_CRITSEC, LOCK_MUTEX,
                       LOCK_RECURSIVE, LOCK_WAIT_HANDLE, LOCK_QUEUE_KERNEL,
                       LOCK_INDIVIDUAL_SPIN
                      >
{
private:
    CRITICAL_SECTION m_cs;

    LOCK_INSTRUMENTATION_DECL();

public:
    CCritSec()
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#ifdef LOCK_INSTRUMENTATION
    CCritSec(const char*)
    {
        InitializeCriticalSection(&m_cs);
        SetSpinCount(sm_wDefaultSpinCount);
    }
#endif // LOCK_INSTRUMENTATION
    ~CCritSec()         { DeleteCriticalSection(&m_cs); }

    void WriteLock()    { EnterCriticalSection(&m_cs); }
    void ReadLock()     { WriteLock(); }
    bool ReadOrWriteLock() { ReadLock(); return true; } 
    bool TryWriteLock();
    bool TryReadLock()  { return TryWriteLock(); }
    void WriteUnlock()  { LeaveCriticalSection(&m_cs); }
    void ReadUnlock()   { WriteUnlock(); }
    void ReadOrWriteUnlock(bool) { ReadUnlock(); } 

    bool IsWriteLocked() const      {return true;}  // TODO: fix this
    bool IsReadLocked() const       {return IsWriteLocked();}
    bool IsWriteUnlocked() const    {return true;}  // TODO: fix this
    bool IsReadUnlocked() const     {return true;}  // TODO: fix this

    // Convert a reader lock to a writer lock
    void ConvertSharedToExclusive()
    {
        // no-op
    }

    // Convert a writer lock to a reader lock
    void ConvertExclusiveToShared()
    {
        // no-op
    }
    
    // Wrapper for ::SetCriticalSectionSpinCount which was introduced
    // in NT 4.0 sp3 and hence is not available on all platforms
    static DWORD SetSpinCount(LPCRITICAL_SECTION pcs,
                              DWORD dwSpinCount=LOCK_DEFAULT_SPINS);

    bool SetSpinCount(WORD wSpins)
    {SetSpinCount(&m_cs, wSpins); return true;}
    
    WORD GetSpinCount() const       { return sm_wDefaultSpinCount; }    // TODO

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()  {return _TEXT("CCritSec");}
}; // CCritSec




//--------------------------------------------------------------------
// CReaderWriterlock is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. Use CReaderWriterLock3.

class IRTL_DLLEXP CReaderWriterLock :
    public CLockBase<LOCK_READERWRITERLOCK, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile  LONG  m_nState;   // > 0 => that many readers
    volatile  LONG  m_cWaiting; // number of would-be writers

    LOCK_INSTRUMENTATION_DECL();

private:
    enum {
        SL_FREE = 0,
        SL_EXCLUSIVE = -1,
    };

    void _LockSpin(bool fWrite);
    void _WriteLockSpin() { _LockSpin(true); }
    void _ReadLockSpin()  { _LockSpin(false); }

    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent == Lock_AtomicCompareExchange(
                                 const_cast<LONG*>(&m_nState), lNew, lCurrent);
    }

    LOCK_FORCEINLINE bool _TryWriteLock()
    {
        return (m_nState == SL_FREE  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE));
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG nCurrState = m_nState;
                
        // Give writers priority
        return (nCurrState != SL_EXCLUSIVE  &&  m_cWaiting == 0
                &&  _CmpExch(nCurrState + 1, nCurrState));
    }

public:
    CReaderWriterLock()
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
    }

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock(
        const TCHAR* ptszName)
        : m_nState(SL_FREE),
          m_cWaiting(0)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock()
    {
        IRTLASSERT(m_nState == SL_FREE  &&  m_cWaiting == 0);
    }
#endif // IRTLDEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Add ourselves to the queue of waiting writers
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));
        
        if (_TryWriteLock())
            return;

        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    inline bool TryWriteLock()
    {
        // Add ourselves to the queue of waiting writers
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));

        if (_TryWriteLock())
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
        return false;    
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE);
        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
    }

    inline void ReadUnlock()
    {
        Lock_AtomicDecrement(const_cast<LONG*>(&m_nState));
    }

    bool IsWriteLocked() const      {return m_nState == SL_EXCLUSIVE;}
    bool IsReadLocked() const       {return m_nState > SL_FREE;}
    bool IsWriteUnlocked() const    {return m_nState != SL_EXCLUSIVE;}
    bool IsReadUnlocked() const     {return m_nState <= SL_FREE;}

    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());
        Lock_AtomicIncrement(const_cast<LONG*>(&m_cWaiting));

        // single reader?
        if (m_nState == SL_FREE + 1  &&  _CmpExch(SL_EXCLUSIVE, SL_FREE + 1))
            return;

        // release the reader lock and spin
        Lock_AtomicDecrement(const_cast<LONG*>(&m_nState));
        _WriteLockSpin();

        IRTLASSERT(IsWriteLocked());
    }

    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());
        Lock_AtomicExchange(const_cast<LONG*>(&m_nState), SL_FREE + 1);
        Lock_AtomicDecrement(const_cast<LONG*>(&m_cWaiting));
        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD)             {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock");}
}; // CReaderWriterLock



//--------------------------------------------------------------------
// CReaderWriterlock2 is a multi-reader, single-writer spinlock due to NJain,
// which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. The difference between this and CReaderWriterLock is
// that all the state is packed into a single LONG, instead of two LONGs.

class IRTL_DLLEXP CReaderWriterLock2 :
    public CLockBase<LOCK_READERWRITERLOCK2, LOCK_MRSW,
                       LOCK_READ_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;

    // LoWord is state. ==0 => free; >0 => readers; ==0xFFFF => 1 writer.
    // HiWord is count of writers, W.
    //      If LoWord==0xFFFF => W-1 waiters, 1 writer;
    //      otherwise W waiters.
    enum {
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    void _LockSpin(bool fWrite);
    void _WriteLockSpin();
    void _ReadLockSpin()  { _LockSpin(false); }

    
    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent ==Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lRW),
                                                     lNew, lCurrent);
    }

    LOCK_FORCEINLINE bool _TryWriteLock(
        LONG nIncr)
    {
        LONG l = m_lRW;
        // Grab exclusive access to the lock if it's free.  Works even
        // if there are other writers queued up.
        return ((l & SL_STATE_MASK) == SL_FREE
                &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l));
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        LONG l = m_lRW;
                
        // Give writers priority
        return ((l & SL_WRITERS_MASK) == 0
                &&  _CmpExch(l + SL_READER_INCR, l));
    }

public:
    CReaderWriterLock2()
        : m_lRW(SL_FREE)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock2(
        const TCHAR* ptszName)
        : m_lRW(SL_FREE)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock2()
    {
        IRTLASSERT(m_lRW == SL_FREE);
    }
#endif // IRTLDEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;
        
        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;
        
        _ReadLockSpin();
    } 

    inline bool TryWriteLock()
    {
        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        IRTLASSERT(IsWriteLocked());
        for (LONG l = m_lRW;
                    // decrement waiter count, clear loword to SL_FREE
             !_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l);
             l = m_lRW)
        {
            IRTLASSERT(IsWriteLocked());
            Lock_Yield();
        }
    }

    inline void ReadUnlock()
    {
        IRTLASSERT(IsReadLocked());
        for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
        {
            IRTLASSERT(IsReadLocked());
            Lock_Yield();
        }
    }

    bool IsWriteLocked() const
    {return (m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE;}

    bool IsReadLocked() const
    {return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;}

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());

        // single reader?
        if (m_lRW != SL_ONE_READER  ||  !_CmpExch(SL_ONE_WRITER,SL_ONE_READER))
        {
            // no, multiple readers
            ReadUnlock();
            _WriteLockSpin();
        }

        IRTLASSERT(IsWriteLocked());
    }

    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());
        for (LONG l = m_lRW;
             !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR,
                         l);
            l = m_lRW)
        {
            IRTLASSERT(IsWriteLocked());
            Lock_Yield();
        }

        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD)             {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock2");}
}; // CReaderWriterLock2



//--------------------------------------------------------------------
// CReaderWriterLock3 is a multi-reader, single-writer spinlock due
// to NJain, which in turn is derived from an exclusive spinlock by DmitryR.
// Gives priority to writers.  Cannot be acquired recursively.
// No error checking. Much like CReaderWriterLock2, except that the WriteLock
// can be acquired recursively.

class IRTL_DLLEXP CReaderWriterLock3 :
    public CLockBase<LOCK_READERWRITERLOCK3, LOCK_MRSW,
                       LOCK_RECURSIVE, LOCK_WAIT_SLEEP, LOCK_QUEUE_KERNEL,
                       LOCK_CLASS_SPIN
                      >
{
private:
    volatile LONG m_lRW;    // Reader-Writer state
    volatile LONG m_lTid;   // Owning Thread ID + recursion count

    // m_lRW:
    //  LoWord is state. =0 => free; >0 => readers; ==0xFFFF => 1 writer
    //  HiWord is count of writers. If LoWord==0xFFFF => N-1 waiters, 1 writer;
    //      otherwise N waiters.
    // m_lTid:
    //  If readers, then 0; if a write lock, then thread id + recursion count

    enum {
        // m_lRW
        SL_FREE =         0x00000000,
        SL_STATE_MASK =   0x0000FFFF,
        SL_STATE_SHIFT =           0,
        SL_WAITING_MASK = 0xFFFF0000,   // waiting writers
        SL_WAITING_SHIFT =        16,
        SL_READER_INCR =  0x00000001,
        SL_READER_MASK =  0x00007FFF,
        SL_EXCLUSIVE =    0x0000FFFF,   // one writer
        SL_WRITER_INCR =  0x00010000,
        SL_ONE_WRITER =   SL_EXCLUSIVE | SL_WRITER_INCR,
        SL_ONE_READER =  (SL_FREE + 1),
        SL_WRITERS_MASK = ~SL_READER_MASK,

        // m_lTid
        SL_THREAD_SHIFT = 0,
        SL_THREAD_BITS  = 28,
        SL_OWNER_SHIFT  = SL_THREAD_BITS,
        SL_OWNER_BITS   = 4,
        SL_THREAD_MASK  = ((1 << SL_THREAD_BITS) - 1) << SL_THREAD_SHIFT,
        SL_OWNER_INCR   = 1 << SL_THREAD_BITS,
        SL_OWNER_MASK   = ((1 << SL_OWNER_BITS) - 1) << SL_OWNER_SHIFT,
    };

    LOCK_INSTRUMENTATION_DECL();

private:
    enum SPIN_TYPE {
        SPIN_WRITE = 1,
        SPIN_READ,
        SPIN_READ_RECURSIVE,
    };

    void _LockSpin(SPIN_TYPE st);
    void _WriteLockSpin();
    void _ReadLockSpin(SPIN_TYPE st)  { _LockSpin(st); }

    
    // _CmpExch is equivalent to
    //      LONG lTemp = m_lRW;
    //      if (lTemp == lCurrent)  m_lRW = lNew;
    //      return lCurrent == lTemp;
    // except it's one atomic instruction.  Using this gives us the basis of
    // a protocol because the update only succeeds when we knew exactly what
    // used to be in m_lRW.  If some other thread slips in and modifies m_lRW
    // before we do, the update will fail.  In other words, it's transactional.
    LOCK_FORCEINLINE bool _CmpExch(LONG lNew, LONG lCurrent)
    {
        return lCurrent==Lock_AtomicCompareExchange(const_cast<LONG*>(&m_lRW),
                                                    lNew, lCurrent);
    }

    // Get the current thread ID.  Assumes that it can fit into 28 bits,
    // which is fairly safe as NT recycles thread IDs and failing to fit into
    // 28 bits would mean that more than 268,435,456 threads were currently
    // active.  This is improbable in the extreme as NT runs out of
    // resources if there are more than a few thousands threads in
    // existence and the overhead of context swapping becomes unbearable.
    inline static LONG _CurrentThreadId()
    {
        DWORD dwTid = ::GetCurrentThreadId();
        // Thread ID 0 is used by the System Idle Process (Process ID 0).
        // We use a thread-id of zero to indicate lock is unowned.
        // NT uses +ve thread ids, Win9x uses -ve ids
        IRTLASSERT(dwTid != 0
                  && ((dwTid <= SL_THREAD_MASK) || (dwTid > ~SL_THREAD_MASK)));
        return (LONG) (dwTid & SL_THREAD_MASK);
    }

    LOCK_FORCEINLINE bool _TryWriteLock(
        LONG nIncr)
    {
        // The common case: the writelock has no owner
        if (m_lTid == 0)
        {
            // IRTLASSERT((m_lRW & SL_STATE_MASK) != SL_EXCLUSIVE);
            LONG l = m_lRW;
            // Grab exclusive access to the lock if it's free.  Works even
            // if there are other writers queued up.
            if ((l & SL_STATE_MASK) == SL_FREE
                &&  _CmpExch((l + nIncr) | SL_EXCLUSIVE, l))
            {
                l = Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 
                                        _CurrentThreadId() | SL_OWNER_INCR);
                IRTLASSERT(l == 0);
                return true;
            }
        }

        return _TryWriteLock2();
    }

    // split into a separate function to make _TryWriteLock more inlineable
    bool _TryWriteLock2()
    {
        if ((m_lTid & SL_THREAD_MASK) == _CurrentThreadId())
        {
            IRTLASSERT((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE);
            IRTLASSERT((m_lTid & SL_OWNER_MASK) != SL_OWNER_MASK);

            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid),
                                m_lTid + SL_OWNER_INCR);
            return true;
        }

        return false;
    }

    LOCK_FORCEINLINE bool _TryReadLock()
    {
        // Give writers priority
        LONG l = m_lRW;
        bool fLocked = (((l & SL_WRITERS_MASK) == 0)
                        &&  _CmpExch(l + SL_READER_INCR, l));
        IRTLASSERT(!fLocked  ||  m_lTid == 0);
        return fLocked;
    }

    LOCK_FORCEINLINE bool _TryReadLockRecursive()
    {
        // Do *not* give writers priority. If the inner call attempts
        // to reacquire the read lock while another thread is waiting on
        // the write lock, we would deadlock if we waited for the queue
        // of writers to empty: the writer(s) can't acquire the lock
        // exclusively, as this thread holds a readlock. The inner call
        // typically releases the lock very quickly, so there is no
        // danger of writer starvation.
        LONG l = m_lRW;
        bool fLocked = (((l & SL_STATE_MASK) != SL_EXCLUSIVE)
                        &&  _CmpExch(l + SL_READER_INCR, l));
        IRTLASSERT(!fLocked  ||  m_lTid == 0);
        return fLocked;
    }

public:
    CReaderWriterLock3()
        : m_lRW(SL_FREE),
          m_lTid(0)
    {}

#ifdef LOCK_INSTRUMENTATION
    CReaderWriterLock3(
        const TCHAR* ptszName)
        : m_lRW(SL_FREE),
          m_lTid(0)
    {
        LOCK_INSTRUMENTATION_INIT(ptszName);
    }
#endif // LOCK_INSTRUMENTATION

#ifdef IRTLDEBUG
    ~CReaderWriterLock3()
    {
        IRTLASSERT(m_lRW == SL_FREE  &&  m_lTid == 0);
    }
#endif // IRTLDEBUG

    inline void WriteLock()
    {
        LOCK_WRITELOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryWriteLock(SL_WRITER_INCR))
            return;
        
        _WriteLockSpin();
    } 

    inline void ReadLock()
    {
        LOCK_READLOCK_INSTRUMENTATION();

        // Optimize for the common case
        if (_TryReadLock())
            return;
        
        _ReadLockSpin(SPIN_READ);
    } 

    // If already locked, recursively acquires another lock of the same
    // kind (read or write). Otherwise, just acquires a read lock.
    // Needed for cases like this.
    //      pTable->WriteLock();
    //      if (!pTable->FindKey(&SomeKey))
    //          InsertRecord(&Whatever);
    //      pTable->WriteUnlock();
    // where FindKey looks like
    //  Table::FindKey(pKey) {
    //      ReadOrWriteLock();
    //      // find pKey if present in table
    //      ReadOrWriteUnlock();
    //  }
    // and InsertRecord looks like
    //  Table::InsertRecord(pRecord) {
    //      WriteLock();
    //      // insert pRecord into table
    //      WriteUnlock();
    //  }
    // If FindKey called ReadLock while the thread already had done a
    // WriteLock, the thread would deadlock.
    
    inline bool ReadOrWriteLock()
    {
        if (IsWriteLocked())
        {
            WriteLock();
            return false;   // => not read locked
        }
        else
        {
            LOCK_READLOCK_INSTRUMENTATION();

            if (!_TryReadLockRecursive())
                _ReadLockSpin(SPIN_READ_RECURSIVE);
            
            return true;   // => is read locked
        }
    } 

    inline bool TryWriteLock()
    {
        if (_TryWriteLock(SL_WRITER_INCR))
        {
            LOCK_WRITELOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline bool TryReadLock()
    {
        if (_TryReadLock())
        {
            LOCK_READLOCK_INSTRUMENTATION();
            return true;
        }

        return false;
    }

    inline void WriteUnlock()
    {
        IRTLASSERT(IsWriteLocked());
        LONG lNew = m_lTid - SL_OWNER_INCR; 

        // Last owner?  Release completely, if so
        if ((lNew & SL_OWNER_MASK) == 0)
            lNew = 0;

        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), lNew);

        if (lNew == 0)
        {
            LONG l;
            do 
            {
                Lock_Yield();
                l = m_lRW;
                // decrement waiter count, clear loword to SL_FREE
            }
            while (!_CmpExch((l - SL_WRITER_INCR) & ~SL_STATE_MASK, l));
        }
    }

    inline void ReadUnlock()
    {
        IRTLASSERT(IsReadLocked());
        for (LONG l = m_lRW;  !_CmpExch(l - SL_READER_INCR, l);  l = m_lRW)
        {
            IRTLASSERT(IsReadLocked());
            Lock_Yield();
        }
    }

    inline void ReadOrWriteUnlock(bool fIsReadLocked)
    {
        if (fIsReadLocked)
            ReadUnlock();
        else
            WriteUnlock();
    } 

    // Does current thread hold a write lock?
    bool IsWriteLocked() const
    {
        // bool fLocked = ((m_lTid & SL_THREAD_MASK) == _CurrentThreadId());
        bool fLocked = ((m_lTid ^ GetCurrentThreadId()) & SL_THREAD_MASK) == 0;
        IRTLASSERT(!fLocked  || (((m_lRW & SL_STATE_MASK) == SL_EXCLUSIVE)
                                 &&  ((m_lTid & SL_OWNER_MASK) > 0)));
        return fLocked;
    }

    bool IsReadLocked() const
    {return (m_lRW & SL_READER_MASK) >= SL_READER_INCR ;}

    bool IsWriteUnlocked() const
    {return !IsWriteLocked();}

    bool IsReadUnlocked() const
    {return !IsReadLocked();}

    // Note: if there's more than one reader, then there's a window where
    // another thread can acquire and release a writelock before this routine
    // returns.
    void ConvertSharedToExclusive()
    {
        IRTLASSERT(IsReadLocked());

        // single reader?
        if (m_lRW == SL_ONE_READER  &&  _CmpExch(SL_ONE_WRITER, SL_ONE_READER))
        {
            Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 
                                _CurrentThreadId() | SL_OWNER_INCR);
        }
        else
        {
            // no, multiple readers
            ReadUnlock();
            _WriteLockSpin();
        }

        IRTLASSERT(IsWriteLocked());
    }

    // There is no such window when converting from a writelock to a readlock
    void ConvertExclusiveToShared()
    {
        IRTLASSERT(IsWriteLocked());

        // assume writelock is not held recursively
        IRTLASSERT((m_lTid & SL_OWNER_MASK) == SL_OWNER_INCR);
        Lock_AtomicExchange(const_cast<LONG*>(&m_lTid), 0);

        for (LONG l = m_lRW;
             !_CmpExch(((l-SL_WRITER_INCR) & SL_WAITING_MASK) | SL_READER_INCR,
                        l);
             l = m_lRW)
        {
            Lock_Yield();
        }

        IRTLASSERT(IsReadLocked());
    }

    bool SetSpinCount(WORD)             {return false;}
    WORD GetSpinCount() const           {return sm_wDefaultSpinCount;}

    LOCK_DEFAULT_SPIN_IMPLEMENTATION();

    static const TCHAR*   ClassName()    {return _TEXT("CReaderWriterLock3");}
}; // CReaderWriterLock3


#endif // __LOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\passport\include\lkrhash.h ===
/*++

   Copyright    (c) 1998-2002    Microsoft Corporation

   Module  Name :
       LKRhash.h

   Abstract:
       Declares LKRhash: a fast, scalable, cache- and MP-friendly hash table

   Author:
       Paul (Per-Ake) Larson, palarson@microsoft.com, July 1997
       Murali R. Krishnan    (MuraliK)
       George V. Reilly      (GeorgeRe)     06-Jan-1998

   Environment:
       Win32 - User Mode

   Project:
       Internet Information Server RunTime Library

   Revision History:
       10/01/1998 - Change name from LKhash to LKRhash

--*/


#define LKR_STL_ITERATORS 1
// #define LKR_DEPRECATED_ITERATORS
#define LKR_APPLY_IF
#undef  LKR_COUNTDOWN

#ifndef LKR_TABLE_LOCK
# define LKR_TABLE_LOCK  CReaderWriterLock3 
#endif // !LKR_TABLE_LOCK

#ifndef LKR_BUCKET_LOCK
# ifdef LKR_DEPRECATED_ITERATORS
#  define LKR_BUCKET_LOCK CReaderWriterLock3 
# else // !LKR_DEPRECATED_ITERATORS
#  define LKR_BUCKET_LOCK CSmallSpinLock
# endif // !LKR_DEPRECATED_ITERATORS
#endif // !LKR_BUCKET_LOCK


#ifndef __LKRHASH_H__
#define __LKRHASH_H__

//=====================================================================
//  The class CLKRLinearHashTable defined in this file provides dynamic hash
//  tables, i.e. tables that grow and shrink dynamically with
//  the number of records in the table.
//  The basic method used is linear hashing, as explained in:
//
//    P.-A. Larson, Dynamic Hash Tables, Comm. of the ACM, 31, 4 (1988)
//
//  This version has the following characteristics:
//  - It is thread-safe and uses spin locks for synchronization.
//  - It was designed to support very high rates of concurrent
//    operations (inserts/deletes/lookups).  It achieves this by
//    (a) partitioning a CLKRHashTable into a collection of
//        CLKRLinearHashTables to reduce contention on the global table lock.
//    (b) minimizing the hold time on a table lock, preferring to lock
//        down a bucket chain instead.
//  - The design is L1 cache-conscious.  See CNodeClump.
//  - It is designed for sets varying in size from a dozen
//    elements to several million.
//
//  Main classes:
//    CLKRLinearHashTable: thread-safe linear hash table
//    CLKRHashTable:       collection of CLKRLinearHashTables
//    CTypedHashTable:     typesafe wrapper for CLKRHashTable
//
//
//  Paul Larson, palarson@microsoft.com, July 1997
//   Original implementation with input from Murali R. Krishnan,
//   muralik@microsoft.com.
//
//  George V. Reilly, georgere@microsoft.com, Dec 1997-Jan 1998
//   Massive cleanup and rewrite.  Added templates.
//=====================================================================


// 1) Linear Hashing
// ------------------
//
// Linear hash tables grow and shrink dynamically with the number of
// records in the table.  The growth or shrinkage is smooth: logically,
// one bucket at a time but physically in larger increments
// (64 buckets).  An insertion (deletion) may cause an expansion
// (contraction) of the table.  This causes relocation of a small number
// of records (at most one bucket worth).  All operations (insert,
// delete, lookup) take constant expected time, regardless of the
// current size or the growth of the table.
//
// 2) LKR extensions to Linear hash table
// --------------------------------------
//
// Larson-Krishnan-Reilly extensions to Linear hash tables for multiprocessor
// scalability and improved cache performance.
//
// Traditional implementations of linear hash tables use one global lock
// to prevent interference between concurrent operations
// (insert/delete/lookup) on the table.  The single lock easily becomes
// the bottleneck in SMP scenarios when multiple threads are used.
//
// Traditionally, a (hash) bucket is implemented as a chain of
// single-item nodes.  Every operation results in chasing down a chain
// looking for an item. However, pointer chasing is very slow on modern
// systems because almost every jump results in a cache miss. L2 (or L3)
// cache misses are very expensive in missed CPU cycles and the cost is
// increasing (going to 100s of cycles in the future).
//
// LKR extensions offer
//    1) Partitioning (by hashing) of records among multiple subtables.
//       Each subtable has locks but there is no global lock.  Each
//       subtable receives a much lower rate of operations, resulting in
//       fewer conflicts.
//
//    2) Improved cache locality by grouping keys and their hash values
//       into contigous chunks that fit exactly into one (or a few)
//       cache lines.
//
// Specifically the implementation that exists here achieves this using
// the following techniques.
//
// Class CLKRHashTable is the top-level data structure that dynamically
// creates m_cSubTables linear hash tables. The CLKRLinearHashTables act as
// the subtables to which items and accesses are fanned out. A good
// hash function multiplexes requests uniformly to various subtables,
// thus minimizing traffic to any single subtable. The implemenation
// uses a home-grown version of bounded spinlocks, that is, a thread
// does not spin on a lock indefinitely, instead yielding after a
// predetermined number of loops.
//
// Each CLKRLinearHashTable consists of a CDirEntry pointing to segments
// each holding m_dwSegSize CBuckets. Each CBucket in turn consists of a
// chain of CNodeClumps.  Each CNodeClump contains a group of
// NODES_PER_CLUMP hash values (aka hash keys or signatures) and
// pointers to the associated data items.  Keeping the signatures
// together increases the cache locality in scans for lookup.
//
// Traditionally, people store a link-list element right inside the
// object that is hashed and use this link-list for the chaining of data
// blocks.  However, keeping just the pointers to the data object and
// not chaining through them limits the need for bringing in the data
// object to the cache.  We need to access the data object only if the
// hash values match. This limits the cache-thrashing behaviour
// exhibited by conventional implementations.  It has the additional
// benefit that the objects themselves do not need to be modified
// in order to be collected in the hash table (i.e., it's non-invasive).


//--------------------------------------------------------------------
// TODO
// * Provide support for multiple, identical keys. Needed for EqualRange,
//   hash_multiset, and hash_multimap.
// * Provide implementations of the STL collection classes: hash_map,
//   hash_set, hash_multimap, and hash_multiset.
// * Make exception-safe.
// * Use auto_ptrs.
// * Add some kind of auto object for readlocking or writelocking a table,
//   so that the table automatically gets unlocked by auto-obj's destructor.
// * Provide a C API wrapper
// * Port to kernel mode (will require different locks, at the very least)
// * Port to managed code (Chris Tracy has started on this)
// * Typedef hash signatures (currently DWORDs)
// * Make available as a static library as well as a DLL
//--------------------------------------------------------------------



#ifndef __IRTLDBG_H__
# include <irtldbg.h>
#endif

#ifndef __LSTENTRY_H__
# include <lstentry.h>
#endif

#ifndef __HASHFN_H__
# include <hashfn.h>
#endif

#include <limits.h>


#ifdef LKR_STL_ITERATORS

// needed for std::forward_iterator_tag, etc
# include <iterator>

// The iterators have very verbose tracing. Don't want it on all the time
// in debug builds.
# if defined(IRTLDEBUG)  &&  (LKR_STL_ITERATORS >= 2)
#  define LKR_ITER_TRACE  IrtlTrace
# else // !defined(IRTLDEBUG)  ||  LKR_STL_ITERATORS < 2
#  define LKR_ITER_TRACE  1 ? (void)0 : IrtlTrace
# endif // !defined(IRTLDEBUG)  ||  LKR_STL_ITERATORS < 2

#endif // LKR_STL_ITERATORS


// Used to initialize and destroy custom allocators
extern "C" bool LKRHashTableInit();
extern "C" void LKRHashTableUninit();

#define __LKRHASH_NO_NAMESPACE__
#define LKR_DEPRECATED_ITERATORS


#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__


enum LK_TABLESIZE {
    LK_SMALL_TABLESIZE=  1,     // < 200 elements
    LK_MEDIUM_TABLESIZE= 2,     // 200...10,000 elements
    LK_LARGE_TABLESIZE=  3,     // 10,000+ elements
};


// Default values for the hashtable constructors
enum {
#ifndef _WIN64
    LK_DFLT_MAXLOAD=     6, // Default upperbound on average chain length.
#else // _WIN64
    LK_DFLT_MAXLOAD=     4, // 64-byte nodes => NODES_PER_CLUMP = 4
#endif // _WIN64
    LK_DFLT_INITSIZE=LK_MEDIUM_TABLESIZE, // Default initial size of hash table
    LK_DFLT_NUM_SUBTBLS= 0, // Use a heuristic to choose #subtables
};


// obsolete build fix hack
// enum {
//     DFLT_LK_MAXLOAD=     LK_DFLT_MAXLOAD,
//     DFLT_LK_INITSIZE=    LK_DFLT_INITSIZE,
//     DFLT_LK_NUM_SUBTBLS= LK_DFLT_NUM_SUBTBLS,
// };


//--------------------------------------------------------------------
// forward declarations

class IRTL_DLLEXP CLKRLinearHashTable;

class IRTL_DLLEXP CLKRHashTable;

template <class _Der, class _Rcd, class _Ky, class _HT
#ifdef LKR_DEPRECATED_ITERATORS
          , class _Iter
#endif // LKR_DEPRECATED_ITERATORS
          >
class CTypedHashTable;


//--------------------------------------------------------------------
// Possible return codes from public member functions of
// CLKRLinearHashTable, CLKRHashTable, and CTypedHashTable

enum LK_RETCODE {
    // severe errors < 0
    LK_UNUSABLE = -99,  // Table corrupted: all bets are off
    LK_ALLOC_FAIL,      // ran out of memory
    LK_BAD_ITERATOR,    // invalid iterator; e.g., points to another table
    LK_BAD_RECORD,      // invalid record; e.g., NULL for InsertRecord
    LK_BAD_PARAMETERS,  // invalid parameters; e.g., NULL fnptrs to ctor
    LK_NOT_INITIALIZED, // LKRHashTableInit was not called

    LK_SUCCESS = 0,     // everything's okay
    LK_KEY_EXISTS,      // key already present for InsertRecord(no-overwrite)
    LK_NO_SUCH_KEY,     // key not found
    LK_NO_MORE_ELEMENTS,// iterator exhausted
};

#define LK_SUCCEEDED(lkrc)  ((lkrc) >= LK_SUCCESS)


#ifdef LKR_APPLY_IF

//--------------------------------------------------------------------
// Return codes from PFnRecordPred.

enum LK_PREDICATE {
    LKP_ABORT = 1,           // Stop walking the table immediately
    LKP_NO_ACTION = 2,       // No action, just keep walking
    LKP_PERFORM = 3,         // Perform action and continue walking
    LKP_PERFORM_STOP = 4,    // Perform action, then stop
    LKP_DELETE = 5,          // Delete record and keep walking
    LKP_DELETE_STOP = 6,     // Delete record, then stop
};


//--------------------------------------------------------------------
// Return codes from PFnRecordAction.

enum LK_ACTION {
    LKA_ABORT = 1,          // Stop walking the table immediately
    LKA_FAILED = 2,         // Action failed; continue walking the table
    LKA_SUCCEEDED = 3,      // Action succeeded; continue walking the table
};

#endif // LKR_APPLY_IF

#if defined(LKR_DEPRECATED_ITERATORS) || defined(LKR_APPLY_IF)
//--------------------------------------------------------------------
// Parameter to Apply and ApplyIf.

enum LK_LOCKTYPE {
    LKL_READLOCK = 1,       // Lock the table for reading (for constness)
    LKL_WRITELOCK = 2,      // Lock the table for writing
};

#endif // LKR_DEPRECATED_ITERATORS || LKR_APPLY_IF



//--------------------------------------------------------------------
// Global table lock code.  This is only used to measure how much of a
// slowdown having a global lock on the CLKRHashTable causes.  It is
// *never* used in production code.


// #define LKRHASH_GLOBAL_LOCK CCritSec

#ifdef LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()         \
    typedef LKRHASH_GLOBAL_LOCK GlobalLock;  \
    mutable GlobalLock m_lkGlobal;

# define LKRHASH_GLOBAL_READ_LOCK()     m_lkGlobal.ReadLock()
# define LKRHASH_GLOBAL_WRITE_LOCK()    m_lkGlobal.WriteLock()
# define LKRHASH_GLOBAL_READ_UNLOCK()   m_lkGlobal.ReadUnlock()
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  m_lkGlobal.WriteUnlock()

#else // !LKRHASH_GLOBAL_LOCK

# define LKRHASH_GLOBAL_LOCK_DECLARATIONS()

// These ones will be optimized away by the compiler
# define LKRHASH_GLOBAL_READ_LOCK()     ((void)0)
# define LKRHASH_GLOBAL_WRITE_LOCK()    ((void)0)
# define LKRHASH_GLOBAL_READ_UNLOCK()   ((void)0)
# define LKRHASH_GLOBAL_WRITE_UNLOCK()  ((void)0)

#endif // !LKRHASH_GLOBAL_LOCK



//--------------------------------------------------------------------
// Statistical information returned by GetStatistics
//--------------------------------------------------------------------

#ifdef LOCK_INSTRUMENTATION

class IRTL_DLLEXP CAveragedLockStats : public CLockStatistics
{
public:
    int m_nItems;

    CAveragedLockStats()
        : m_nItems(1)
    {}
};

#endif // LOCK_INSTRUMENTATION



class IRTL_DLLEXP CLKRHashTableStats
{
public:
    int      RecordCount;           // number of records in the table
    int      TableSize;             // table size in number of slots
    int      DirectorySize;         // number of entries in directory
    int      LongestChain;          // longest hash chain in the table
    int      EmptySlots;            // number of unused hash slots
    double   SplitFactor;           // fraction of buckets split
    double   AvgSearchLength;       // average length of a successful search
    double   ExpSearchLength;       // theoretically expected length
    double   AvgUSearchLength;      // average length of an unsuccessful search
    double   ExpUSearchLength;      // theoretically expected length
    int      NodeClumpSize;         // number of slots in a node clump
    int      CBucketSize;           // sizeof(CBucket)

#ifdef LOCK_INSTRUMENTATION
    CAveragedLockStats      m_alsTable;  // stats for table lock
    CAveragedLockStats      m_alsBucketsAvg; // avg of stats for bucket locks
    CGlobalLockStatistics   m_gls;      // global statistics for all locks
#endif // LOCK_INSTRUMENTATION

    enum {
        MAX_BUCKETS = 40,
    };

    // histogram of bucket lengths
    LONG    m_aBucketLenHistogram[MAX_BUCKETS];

    CLKRHashTableStats()
        : RecordCount(0),
          TableSize(0),
          DirectorySize(0),
          LongestChain(0),
          EmptySlots(0),
          SplitFactor(0.0),
          AvgSearchLength(0.0),
          ExpSearchLength(0.0),
          AvgUSearchLength(0.0),
          ExpUSearchLength(0.0),
          NodeClumpSize(1),
          CBucketSize(0)
    {
        for (int i = MAX_BUCKETS;  --i >= 0;  )
            m_aBucketLenHistogram[i] = 0;
    }

    static const LONG*
    BucketSizes()
    {
        static const LONG  s_aBucketSizes[MAX_BUCKETS] = {
                   1,    2,    3,    4,    5,    6,    7,      8,        9,
            10,   11,   12,   13,   14,   15,   16,   17,     18,       19,
            20,   21,   22,   23,   24,   25,   30,   40,     50,       60,
            70,   80,   90,  100,  200,  500, 1000,10000, 100000, LONG_MAX,
        };

        return s_aBucketSizes;
    }

    static LONG
    BucketSize(
        LONG nBucketIndex)
    {
        IRTLASSERT(0 <= nBucketIndex  &&  nBucketIndex < MAX_BUCKETS);
        return BucketSizes()[nBucketIndex];
    }

    static LONG
    BucketIndex(
        LONG nBucketLength)
    {
        const LONG* palBucketSizes = BucketSizes();
        LONG i = 0;
        while (palBucketSizes[i] < nBucketLength)
            ++i;
        if (i == MAX_BUCKETS  ||  palBucketSizes[i] > nBucketLength)
            --i;
        IRTLASSERT(0 <= i  &&  i < MAX_BUCKETS);
        return i;
    }
};



// Use types defined in recent versions of the Platform SDK in basetsd.h.
#ifndef _W64
typedef DWORD DWORD_PTR;   // integral type big enough to hold a pointer
#endif

//--------------------------------------------------------------------
// CLKRLinearHashTable deals with void* records.  These typedefs
// provide prototypes for functions that manipulate instances of
// those records.  CTypedHashTable and CStringTestHashTable (below) show a
// way to encapsulate these in typesafe wrappers.
//--------------------------------------------------------------------

// Given a record, return its key.  Assumes that the key is embedded in
// the record, or at least somehow derivable from the record.  For
// completely unrelated keys & values, a wrapper class should use
// something like STL's pair<key,value> template to aggregate them
// into a record.
typedef const DWORD_PTR (WINAPI *PFnExtractKey)  (const void* pvRecord);

// Given a key, return its hash signature.  The hashing functions in
// hashfn.h (or something that builds upon them) are suggested.
typedef DWORD       (WINAPI *PFnCalcKeyHash) (const DWORD_PTR pnKey);

// Compare two keys for equality; e.g., _stricmp, memcmp, operator==
typedef bool        (WINAPI *PFnEqualKeys)   (const DWORD_PTR pnKey1,
                                              const DWORD_PTR pnKey2);

// Increment the reference count of a record before returning it from
// FindKey.  It's necessary to do it in FindKey itself while the bucket
// is still locked, rather than one of the wrappers, to avoid race
// conditions.  Similarly, the reference count is incremented in
// InsertRecord and decremented in DeleteKey.  Finally, if an old record
// is overwritten in InsertRecord, its reference count is decremented.
//
// It's up to you to decrement the reference count when you're finished
// with it after retrieving it via FindKey and to determine the
// semantics of what this means.  The hashtable itself has no notion of
// reference counts; this is merely to help with the lifetime management
// of the record objects.
typedef void        (WINAPI *PFnAddRefRecord)(const void* pvRecord, int nIncr);

#ifdef LKR_APPLY_IF
// ApplyIf() and DeleteIf(): Does the record match the predicate?
typedef LK_PREDICATE (WINAPI *PFnRecordPred) (const void* pvRecord,
                                              void* pvState);

// Apply() et al: Perform action on record.
typedef LK_ACTION   (WINAPI *PFnRecordAction)(const void* pvRecord,
                                              void* pvState);
#endif // LKR_APPLY_IF


#ifndef __LKRHASH_NO_NAMESPACE__
}
#endif // !__LKRHASH_NO_NAMESPACE__



//--------------------------------------------------------------------
// Custom memory allocators
//--------------------------------------------------------------------


#ifndef LKR_NO_ALLOCATORS
// # define LKRHASH_ACACHE 1
// # define LKRHASH_MANODEL 1
// # define LKRHASH_MADEL 1
// # define LKRHASH_ROCKALL_FAST 1

// # define LKRHASH_MEM_DEFAULT_ALIGN 32
#endif // !LKR_NO_ALLOCATORS

#ifndef LKRHASH_MEM_DEFAULT_ALIGN
# define LKRHASH_MEM_DEFAULT_ALIGN 8
#endif // !LKRHASH_MEM_DEFAULT_ALIGN

#if defined(LKRHASH_ACACHE)

# include <acache.hxx>
  typedef ALLOC_CACHE_HANDLER  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    const ALLOC_CACHE_CONFIGURATION acc = { 1, N, sizeof(C) };  \
    C::sm_palloc = new ALLOC_CACHE_HANDLER("LKRhash:" #C, &acc);

#elif defined(LKRHASH_ROCKALL_FAST)

# include <FastHeap.hpp>

class FastHeap : public FAST_HEAP
{
public:
    FastHeap(
        SIZE_T cb)
        : m_cb(cb)
    {}

    LPVOID Alloc()
    { return New(m_cb, NULL, false); }

    BOOL   Free(LPVOID pvMem)
    { return Delete(pvMem); }

    SIZE_T m_cb;
};

  typedef FastHeap  CLKRhashAllocator;
# define LKRHASH_ALLOCATOR_NEW(C, N)                            \
    C::sm_palloc = new FastHeap(sizeof(C));

#else // no custom allocator

# undef LKRHASH_ALLOCATOR_NEW

#endif // no custom allocator



#ifdef LKRHASH_ALLOCATOR_NEW

// placed inline in the declaration of class C
# define LKRHASH_ALLOCATOR_DEFINITIONS(C)                       \
    protected:                                                  \
        static CLKRhashAllocator* sm_palloc;                    \
        friend bool  LKRHashTableInit();                        \
        friend void  LKRHashTableUninit();                      \
        friend class CLKRLinearHashTable;                       \
    public:                                                     \
        static void*  operator new(size_t s)                    \
        {                                                       \
            UNREFERENCED_PARAMETER(s);                          \
            IRTLASSERT(s == sizeof(C));                         \
            IRTLASSERT(sm_palloc != NULL);                      \
            return sm_palloc->Alloc();                          \
        }                                                       \
        static void   operator delete(void* pv)                 \
        {                                                       \
            IRTLASSERT(pv != NULL);                             \
            IRTLASSERT(sm_palloc != NULL);                      \
            sm_palloc->Free(pv);                                \
        }                                                       \
        static bool init(void)                                  \
        {                                                       \
            IRTLASSERT(sm_palloc == NULL);                      \
            LKRHASH_ALLOCATOR_NEW(C, 1);                        \
            return (sm_palloc != NULL);                         \
        }                                                       \
        static void uninit(void)                                \
        {                                                       \
            if (sm_palloc != NULL)                              \
            {                                                   \
                delete sm_palloc;                               \
                sm_palloc = NULL;                               \
            }                                                   \
        }


// used in LKRHashTableInit()
# define LKRHASH_ALLOCATOR_INIT(C, N, f)                        \
    {                                                           \
        if (f)                                                  \
        {                                                       \
            f = C::init();                                      \
        }                                                       \
    }


// used in LKRHashTableUninit()
# define LKRHASH_ALLOCATOR_UNINIT(C)                            \
    {                                                           \
        C::uninit();                                            \
    }


#else // !LKRHASH_ALLOCATOR_NEW

# define LKRHASH_ALLOCATOR_DEFINITIONS(C)
# define LKRHASH_ALLOCATOR_INIT(C, N, f)
# define LKRHASH_ALLOCATOR_UNINIT(C)

#endif // !LKRHASH_ALLOCATOR_NEW



#ifndef __LKRHASH_NO_NAMESPACE__
namespace LKRhash {
#endif // !__LKRHASH_NO_NAMESPACE__

// Class for nodes on a bucket chain.  Instead of a node containing
// one (signature, record-pointer, next-tuple-pointer) tuple, it
// contains _N_ such tuples.  (N-1 next-tuple-pointers are omitted.)
// This improves locality of reference greatly; i.e., it's L1
// cache-friendly.  It also reduces memory fragmentation and memory
// allocator overhead.  It does complicate the chain traversal code
// slightly, admittedly.
//
// This theory is beautiful.  In practice, however, CNodeClumps
// are *not* perfectly aligned on 32-byte boundaries by the memory
// allocators.  Experimental results indicate that we get a 2-3%
// speed improvement by using 32-byte-aligned blocks, but this must
// be considered against the average of 16 bytes wasted per block.

class CNodeClump
{
public:
    // Record slots per chunk - set so a chunk matches (one or
    // two) cache lines.  3 ==> 32 bytes, 7 ==> 64 bytes
    // Note: the default max load factor is 6.0, which implies that
    // there will seldom be more than one node clump in a chain.
    enum {
        BUCKET_BYTE_SIZE = 64,
        BUCKET_OVERHEAD  = sizeof(LKR_BUCKET_LOCK) + sizeof(CNodeClump*),
        NODE_SIZE        = sizeof(const void*) + sizeof(DWORD),
        NODES_PER_CLUMP  = (BUCKET_BYTE_SIZE - BUCKET_OVERHEAD) / NODE_SIZE
    };

    enum {
        // See if countdown loops are faster than countup loops for
        // traversing a CNodeClump. In practice, countup loops are faster.
#ifndef LKR_COUNTDOWN
        NODE_BEGIN = 0,
        NODE_END   = NODES_PER_CLUMP,
        NODE_STEP  = +1,
        // for (int x = 0;  x < NODES_PER_CLUMP;  ++x) ...
#else // LKR_COUNTDOWN
        NODE_BEGIN = NODES_PER_CLUMP-1,
        NODE_END   = -1,
        NODE_STEP  = -1,
        // for (int x = NODES_PER_CLUMP;  --x >= 0;  ) ...
#endif // LKR_COUNTDOWN
    };

    enum {
        // No number in 0..2^31-1 maps to this number after it has been
        // scrambled by HashFn::HashRandomizeBits
        HASH_INVALID_SIGNATURE = 31678523,
    };

    DWORD  m_dwKeySigs[NODES_PER_CLUMP]; // hash values computed from keys
    CNodeClump* m_pncNext;               // next node clump on the chain
    const void* m_pvNode[NODES_PER_CLUMP];// pointers to records

    CNodeClump()
    {
        Clear();
    }

    void
    Clear()
    { 
        m_pncNext = NULL;  // no dangling pointers
        for (int i = NODES_PER_CLUMP;  --i >= 0; )
        {
            m_dwKeySigs[i] = HASH_INVALID_SIGNATURE;
            m_pvNode[i] = NULL;
        }
    }

    bool
    InvalidSignature(
        int i) const
    {
        IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
        return (m_dwKeySigs[i] == HASH_INVALID_SIGNATURE);
    }

    bool
    IsEmptyNode(
        int i) const
    {
        IRTLASSERT(0 <= i  &&  i < NODES_PER_CLUMP);
        return (m_pvNode[i] == NULL);
    }

    bool
    IsEmptyAndInvalid(
        int i) const
    {
        return IsEmptyNode(i) && InvalidSignature(i);
    }

    bool
    IsEmptySlot(
        int i) const
    {
        return InvalidSignature(i);
    }

    bool
    IsLastClump() const
    {
        return (m_pncNext == NULL);
    }

#ifdef IRTLDEBUG
    // Don't want overhead of calls to dtor in retail build
    ~CNodeClump()
    {
        IRTLASSERT(IsLastClump());  // no dangling pointers
        for (int i = NODES_PER_CLUMP;  --i >= 0;  )
            IRTLASSERT(InvalidSignature(i)  &&  IsEmptyNode(i));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CNodeClump);
}; // class CNodeClump



// Class for bucket chains of the hash table.  Note that the first
// nodeclump is actually included in the bucket and not dynamically
// allocated, which increases space requirements slightly but does
// improve performance.
class CBucket
{
private:
    typedef LKR_BUCKET_LOCK BucketLock;
    mutable BucketLock m_Lock;       // lock protecting this bucket

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cBuckets;

    static const TCHAR*
    _LockName()
    {
        LONG l = ++sm_cBuckets;
        // possible race condition but we don't care, as this is never
        // used in production code
        static TCHAR s_tszName[CLockStatistics::L_NAMELEN];
        wsprintf(s_tszName, _TEXT("B%06x"), 0xFFFFFF & l);
        return s_tszName;
    }
#endif // LOCK_INSTRUMENTATION

public:
    CNodeClump    m_ncFirst;    // first CNodeClump of this bucket

#if defined(LOCK_INSTRUMENTATION) || defined(IRTLDEBUG)
    CBucket()
#ifdef LOCK_INSTRUMENTATION
        : m_Lock(_LockName())
#endif // LOCK_INSTRUMENTATION
    {
#ifdef IRTLDEBUG
        LOCK_LOCKTYPE lt = BucketLock::LockType();
        if (lt == LOCK_SPINLOCK  ||  lt == LOCK_FAKELOCK)
            IRTLASSERT(sizeof(*this) <= 64);
#endif IRTLDEBUG
    }
#endif // LOCK_INSTRUMENTATION || IRTLDEBUG

    void  WriteLock()           { m_Lock.WriteLock(); }
    void  ReadLock() const      { m_Lock.ReadLock(); }
    void  WriteUnlock() const   { m_Lock.WriteUnlock();   }
    void  ReadUnlock() const    { m_Lock.ReadUnlock();   }
    bool  IsWriteLocked() const { return m_Lock.IsWriteLocked(); }
    bool  IsReadLocked() const  { return m_Lock.IsReadLocked(); }
    bool  IsWriteUnlocked() const { return m_Lock.IsWriteUnlocked(); }
    bool  IsReadUnlocked() const  { return m_Lock.IsReadUnlocked(); }
    void  SetSpinCount(WORD wSpins) { m_Lock.SetSpinCount(wSpins); }
    WORD  GetSpinCount() const  { return m_Lock.GetSpinCount(); }
#ifdef LOCK_INSTRUMENTATION
    CLockStatistics LockStats() const {return m_Lock.Statistics();}
#endif // LOCK_INSTRUMENTATION
}; // class CBucket



// The hash table space is divided into fixed-size segments (arrays of
// CBuckets) and physically grows/shrinks one segment at a time.
//
// We provide small, medium, and large segments to better tune the
// overall memory requirements of the hash table according to the
// expected usage of an instance.

class CSegment
{
public:
    CBucket m_bktSlots[1];

    // See note at m_bktSlots2 in CSmallSegment below
    CBucket& Slot(DWORD i)
    { return m_bktSlots[i]; }
}; // class CSegment


// Small-sized segments contain 2^3 = 8 buckets => ~0.5Kb
class CSmallSegment : public CSegment
{
public:
    // Maximum table size equals MAX_DIRSIZE * SEGSIZE buckets.
    enum {
        SEGBITS  =            3,// number of bits extracted from a hash
                                // address for offset within a segment
        SEGSIZE  = (1<<SEGBITS),// segment size
        SEGMASK  = (SEGSIZE-1), // mask used for extracting offset bit
        INITSIZE = 1 * SEGSIZE, // #segments to allocate initially
    };

    // Hack: assumes immediately after CSegment::m_bktSlots, with no
    // padding. The STATIC_ASSERT in _AllocateSegment should cause a
    // compile-time error if this assumption is false.
    CBucket m_bktSlots2[SEGSIZE-1];

public:
    DWORD Bits() const      { return SEGBITS; }
    DWORD Size() const      { return SEGSIZE; }
    DWORD Mask() const      { return SEGMASK; }
    DWORD InitSize() const  { return INITSIZE;}

#ifdef IRTLDEBUG
    CSmallSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CSmallSegment);
}; // class CSmallSegment


// Medium-sized segments contain 2^6 = 64 buckets => ~4Kb
class CMediumSegment : public CSegment
{
public:
    enum {
        SEGBITS  =            6,
        SEGSIZE  = (1<<SEGBITS),
        SEGMASK  = (SEGSIZE-1),
        INITSIZE = 2 * SEGSIZE,
    };

    CBucket m_bktSlots2[SEGSIZE-1];

public:
    DWORD Bits() const      { return SEGBITS; }
    DWORD Size() const      { return SEGSIZE; }
    DWORD Mask() const      { return SEGMASK; }
    DWORD InitSize() const  { return INITSIZE;}

#ifdef IRTLDEBUG
    CMediumSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CMediumSegment);
}; // class CMediumSegment


// Large-sized segments contain 2^9 = 512 buckets => ~32Kb
class CLargeSegment : public CSegment
{
public:
    enum {
        SEGBITS  =            9,
        SEGSIZE  = (1<<SEGBITS),
        SEGMASK  = (SEGSIZE-1),
        INITSIZE = 4 * SEGSIZE,
    };

    CBucket m_bktSlots2[SEGSIZE-1];

public:
    DWORD Bits() const      { return SEGBITS; }
    DWORD Size() const      { return SEGSIZE; }
    DWORD Mask() const      { return SEGMASK; }
    DWORD InitSize() const  { return INITSIZE;}

#ifdef IRTLDEBUG
    CLargeSegment()
    {
        IRTLASSERT(&Slot(1) == m_bktSlots2);
        IRTLASSERT(((DWORD_PTR)this & (LKRHASH_MEM_DEFAULT_ALIGN-1)) == 0);
        IRTLASSERT(sizeof(*this) == SEGSIZE * sizeof(CBucket));
    }
#endif // IRTLDEBUG

    LKRHASH_ALLOCATOR_DEFINITIONS(CLargeSegment);
}; // class CLargeSegment



// A directory keeps track of the segments comprising the hash table.
// The directory is just a variable-sized array of pointers to
// segments (CDirEntrys).
class CDirEntry
{
public:
    // MIN_DIRSIZE and MAX_DIRSIZE can be changed independently
    // of anything else.  Should be powers of two.
    enum {
        MIN_DIRSIZE =  (1<<3),   // minimum directory size
        MAX_DIRSIZE = (1<<20),   // maximum directory size
    };

    CSegment* m_pseg;

    CDirEntry()
        : m_pseg(NULL)
    {}

    ~CDirEntry()
    { delete m_pseg; }
}; // class CDirEntry



#ifdef LKR_STL_ITERATORS

class IRTL_DLLEXP CLKRLinearHashTable_Iterator;
class IRTL_DLLEXP CLKRHashTable_Iterator;


class IRTL_DLLEXP CLKRLinearHashTable_Iterator
{
    friend class CLKRLinearHashTable;
    friend class CLKRHashTable;
    friend class CLKRHashTable_Iterator;

protected:
    CLKRLinearHashTable* m_plht;        // which linear hash table?
    CNodeClump*          m_pnc;         // a CNodeClump in bucket
    DWORD                m_dwBucketAddr;// bucket index
    short                m_iNode;       // offset within m_pnc

    enum {
        NODES_PER_CLUMP = CNodeClump::NODES_PER_CLUMP,
        NODE_BEGIN      = CNodeClump::NODE_BEGIN,
        NODE_END        = CNodeClump::NODE_END,
        NODE_STEP       = CNodeClump::NODE_STEP,
    };

    CLKRLinearHashTable_Iterator(
        CLKRLinearHashTable* plht,
        CNodeClump*          pnc,
        DWORD                dwBucketAddr,
        short                iNode)
        : m_plht(plht),
          m_pnc(pnc),
          m_dwBucketAddr(dwBucketAddr),
          m_iNode(iNode)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::prot ctor, this=%p, plht=%p, ")
                       _TEXT("pnc=%p, ba=%d, in=%d\n"),
                       this, plht, pnc, dwBucketAddr, iNode);
    }

    inline void _AddRef(
        int nIncr) const;

    bool _Increment(
        bool fDecrementOldValue=true);

public:
    CLKRLinearHashTable_Iterator()
        : m_plht(NULL),
          m_pnc(NULL),
          m_dwBucketAddr(0),
          m_iNode(0)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::default ctor, this=%p\n"), this);
    }

    CLKRLinearHashTable_Iterator(
        const CLKRLinearHashTable_Iterator& rhs)
        : m_plht(rhs.m_plht),
          m_pnc(rhs.m_pnc),
          m_dwBucketAddr(rhs.m_dwBucketAddr),
          m_iNode(rhs.m_iNode)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::copy ctor, this=%p, rhs=%p\n"),
                       this, &rhs);
        _AddRef(+1);
    }

    CLKRLinearHashTable_Iterator& operator=(
        const CLKRLinearHashTable_Iterator& rhs)
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator=, this=%p, rhs=%p\n"),
                       this, &rhs);
        rhs._AddRef(+1);
        this->_AddRef(-1);

        m_plht =         rhs.m_plht;
        m_pnc =          rhs.m_pnc;
        m_dwBucketAddr = rhs.m_dwBucketAddr;
        m_iNode =        rhs.m_iNode;

        return *this;
    }

    ~CLKRLinearHashTable_Iterator()
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::dtor, this=%p, plht=%p\n"),
                       this, m_plht);
        _AddRef(-1);
    }

    bool Increment()
    {
        return IsValid()  ? _Increment()  :  false;

    }

    bool IsValid() const
    {
        bool fValid = (m_plht != NULL  &&  m_pnc != NULL
                       &&  0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP);
        if (fValid)
            fValid = (m_pnc->m_pvNode[m_iNode] != NULL);
        IRTLASSERT(fValid);
        return fValid;
    }

    const void* Record() const
    {
        IRTLASSERT(IsValid());
        return m_pnc->m_pvNode[m_iNode];
    }

    inline const DWORD_PTR Key() const;

    bool operator==(
        const CLKRLinearHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator==, this=%p, rhs=%p\n"),
                       this, &rhs);
        // m_pnc and m_iNode uniquely identify an iterator
        bool fEQ = ((m_pnc == rhs.m_pnc)    // most unique field
                    &&  (m_iNode == rhs.m_iNode));
        IRTLASSERT(!fEQ || ((m_plht == rhs.m_plht)
                            &&  (m_dwBucketAddr == rhs.m_dwBucketAddr)));
        return fEQ;
    }

    bool operator!=(
        const CLKRLinearHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::operator!=, this=%p, rhs=%p\n"),
                       this, &rhs);
        bool fNE = ((m_pnc != rhs.m_pnc)
                    ||  (m_iNode != rhs.m_iNode));
        //// IRTLASSERT(fNE == !this->operator==(rhs));
        return fNE;
    }
}; // class CLKRLinearHashTable_Iterator



class IRTL_DLLEXP CLKRHashTable_Iterator
{
    friend class CLKRHashTable;

protected:
    // order important to minimize size
    CLKRHashTable*                  m_pht;      // which hash table?
    CLKRLinearHashTable_Iterator    m_subiter;  // iterator into subtable
    short                           m_ist;      // index of subtable

    CLKRHashTable_Iterator(
        CLKRHashTable* pht,
        short          ist)
        : m_pht(pht),
          m_subiter(CLKRLinearHashTable_Iterator()), // zero
          m_ist(ist)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::prot ctor, this=%p, pht=%p, ist=%d\n"),
                       this, pht, ist);
    }

    bool _Increment(
        bool fDecrementOldValue=true);

public:
    CLKRHashTable_Iterator()
        : m_pht(NULL),
          m_subiter(CLKRLinearHashTable_Iterator()), // zero
          m_ist(0)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::default ctor, this=%p\n"), this);
    }

#ifdef IRTLDEBUG
    // Compiler does a perfectly adequate job of synthesizing these methods.
    CLKRHashTable_Iterator(
        const CLKRHashTable_Iterator& rhs)
        : m_pht(rhs.m_pht),
          m_subiter(rhs.m_subiter),
          m_ist(rhs.m_ist)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::copy ctor, this=%p, rhs=%p\n"),
                       this, &rhs);
    }

    CLKRHashTable_Iterator& operator=(
        const CLKRHashTable_Iterator& rhs)
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator=, this=%p, rhs=%p\n"),
                       this, &rhs);

        m_ist     = rhs.m_ist;
        m_subiter = rhs.m_subiter;
        m_pht     = rhs.m_pht;

        return *this;
    }

    ~CLKRHashTable_Iterator()
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::dtor, this=%p, pht=%p\n"), this, m_pht);
    }
#endif // IRTLDEBUG

    bool Increment()
    {
        return IsValid()  ? _Increment()  :  false;
    }

    bool IsValid() const
    {
        bool fValid = (m_pht != NULL  &&  m_ist >= 0);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_plht != NULL);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_pnc != NULL);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (0 <= m_subiter.m_iNode);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (m_subiter.m_iNode < CNodeClump::NODES_PER_CLUMP);
        IRTLASSERT(fValid);

        if (fValid)
            fValid = (m_subiter.m_pnc->m_pvNode[m_subiter.m_iNode] != NULL);
        IRTLASSERT(fValid);
        return fValid;
    }

    const void* Record() const
    {
        IRTLASSERT(IsValid());
        return m_subiter.Record();
    }

    const DWORD_PTR Key() const
    {
        IRTLASSERT(IsValid());
        return m_subiter.Key();
    }

    bool operator==(
        const CLKRHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator==, this=%p, rhs=%p\n"),
                       this, &rhs);
        // m_pnc and m_iNode uniquely identify an iterator
        bool fEQ = ((m_subiter.m_pnc
                            == rhs.m_subiter.m_pnc)     // most unique field
                    &&  (m_subiter.m_iNode == rhs.m_subiter.m_iNode));
        IRTLASSERT(!fEQ
                   || ((m_ist == rhs.m_ist)
                       &&  (m_pht == rhs.m_pht)
                       &&  (m_subiter.m_plht == rhs.m_subiter.m_plht)
                       &&  (m_subiter.m_dwBucketAddr
                                == rhs.m_subiter.m_dwBucketAddr)));
        return fEQ;
    }

    bool operator!=(
        const CLKRHashTable_Iterator& rhs) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::operator!=, this=%p, rhs=%p\n"),
                       this, &rhs);
        bool fNE = ((m_subiter.m_pnc != rhs.m_subiter.m_pnc)
                    ||  (m_subiter.m_iNode != rhs.m_subiter.m_iNode));
        //// IRTLASSERT(fNE == !this->operator==(rhs));
        return fNE;
    }
}; // class CLKRHashTable_Iterator

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// CLKRLinearHashTable
//
// A thread-safe linear hash table.
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRLinearHashTable
{
public:
    typedef LKR_TABLE_LOCK  TableLock;
    typedef LKR_BUCKET_LOCK BucketLock;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRLinearHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_STL_ITERATORS
    friend class CLKRLinearHashTable_Iterator;
    typedef CLKRLinearHashTable_Iterator Iterator;
#endif // LKR_STL_ITERATORS

private:
    friend class CNodeClump;
    friend class CLKRHashTable;

#ifdef LKRHASH_ALLOCATOR_NEW
    friend bool LKRHashTableInit();
    friend void LKRHashTableUninit();
#endif // LKRHASH_ALLOCATOR_NEW

#ifdef LKRHASH_INSTRUMENTATION
    // TODO
#endif // LKRHASH_INSTRUMENTATION


public:

    // aliases for convenience
    enum {
        NODES_PER_CLUMP        = CNodeClump::NODES_PER_CLUMP,
        MIN_DIRSIZE            = CDirEntry::MIN_DIRSIZE,
        MAX_DIRSIZE            = CDirEntry::MAX_DIRSIZE,
        NAME_SIZE              = 16,
        NODE_BEGIN             = CNodeClump::NODE_BEGIN,
        NODE_END               = CNodeClump::NODE_END,
        NODE_STEP              = CNodeClump::NODE_STEP,
        HASH_INVALID_SIGNATURE = CNodeClump::HASH_INVALID_SIGNATURE,
    };


private:

    //
    // Miscellaneous helper functions
    //

    // Convert a hash signature to a bucket address
    inline DWORD _BucketAddress(DWORD dwSignature) const
    {
        DWORD dwBktAddr = _H0(dwSignature);
        // Has this bucket been split already?
        if (dwBktAddr < m_iExpansionIdx)
            dwBktAddr = _H1(dwSignature);
        IRTLASSERT(dwBktAddr < m_cActiveBuckets);
        IRTLASSERT(dwBktAddr < (m_cDirSegs << m_dwSegBits));
        return dwBktAddr;
    }

    // See the Linear Hashing paper
    static DWORD _H0(DWORD dwSignature, DWORD dwBktAddrMask)
    { return dwSignature & dwBktAddrMask; }

    DWORD        _H0(DWORD dwSignature) const
    { return _H0(dwSignature, m_dwBktAddrMask0); }

    // See the Linear Hashing paper.  Preserves one bit more than _H0.
    static DWORD _H1(DWORD dwSignature, DWORD dwBktAddrMask)
    { return dwSignature & ((dwBktAddrMask << 1) | 1); }

    DWORD        _H1(DWORD dwSignature) const
    { return _H0(dwSignature, m_dwBktAddrMask1); }

    // In which segment within the directory does the bucketaddress lie?
    // (Return type must be lvalue so that it can be assigned to.)
    CSegment*&   _Segment(DWORD dwBucketAddr) const
    {
        const DWORD iSeg = dwBucketAddr >> m_dwSegBits;
        IRTLASSERT(m_paDirSegs != NULL  &&  iSeg < m_cDirSegs);
        return m_paDirSegs[iSeg].m_pseg;
    }

    // Offset within the segment of the bucketaddress
    DWORD        _SegIndex(DWORD dwBucketAddr) const
    { return (dwBucketAddr & m_dwSegMask); }

    // Convert a bucketaddress to a CBucket*
    inline CBucket* _Bucket(DWORD dwBucketAddr) const
    {
        IRTLASSERT(dwBucketAddr < m_cActiveBuckets);
        CSegment* const pseg = _Segment(dwBucketAddr);
        IRTLASSERT(pseg != NULL);
        return &(pseg->Slot(_SegIndex(dwBucketAddr)));
    }

    // Extract the key from a record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
        return (*m_pfnExtractKey)(pvRecord);
    }

    // Hash the key
    DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const
    {
        // Note pnKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
        // We forcibly scramble the result to help ensure a better distribution
#ifndef __HASHFN_NO_NAMESPACE__
        dwHash = HashFn::HashRandomizeBits(dwHash);
#else // !__HASHFN_NO_NAMESPACE__
        dwHash = ::HashRandomizeBits(dwHash);
#endif // !__HASHFN_NO_NAMESPACE__
        IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
        return dwHash;
    }

    // Compare two keys for equality
    bool       _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2) const
    {
        IRTLASSERT(m_pfnEqualKeys != NULL);
        return (*m_pfnEqualKeys)(pnKey1, pnKey2);
    }

    // AddRef or Release a record.
    void         _AddRefRecord(const void* pvRecord, int nIncr) const
    {
        IRTLASSERT(pvRecord != NULL  &&  (nIncr == -1  ||  nIncr == +1));
        IRTLASSERT(m_pfnAddRefRecord != NULL);
        (*m_pfnAddRefRecord)(pvRecord, nIncr);
    }

    // Find a bucket, given its signature.
    CBucket*     _FindBucket(DWORD dwSignature, bool fLockForWrite) const;

    // Used by _FindKey so that the thread won't deadlock if the user has
    // already explicitly called table->WriteLock().
    bool _ReadOrWriteLock() const
    { return m_Lock.ReadOrWriteLock(); }

    void _ReadOrWriteUnlock(bool fReadLocked) const
    { m_Lock.ReadOrWriteUnlock(fReadLocked); }

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static CDirEntry* const
    _AllocateSegmentDirectory(
        size_t n);

    bool
    _FreeSegmentDirectory();

    static CNodeClump* const
    _AllocateNodeClump();

    static bool
    _FreeNodeClump(
        CNodeClump* pnc);

    CSegment* const
    _AllocateSegment() const;

    bool
    _FreeSegment(
        CSegment* pseg) const;

#ifdef LOCK_INSTRUMENTATION
    static LONG sm_cTables;

    static const TCHAR*
    _LockName()
    {
        LONG l = ++sm_cTables;
        // possible race condition but we don't care, as this is never
        // used in production code
        static TCHAR s_tszName[CLockStatistics::L_NAMELEN];
        wsprintf(s_tszName, _TEXT("LH%05x"), 0xFFFFF & l);
        return s_tszName;
    }

    // Statistics for the table lock
    CLockStatistics _LockStats() const
    { return m_Lock.Statistics(); }
#endif // LOCK_INSTRUMENTATION

private:

    // Fields are ordered so as to minimize number of cache lines touched

    DWORD         m_dwSignature;    // debugging: id & corruption check
    CHAR          m_szName[NAME_SIZE];  // an identifier for debugging
    mutable LK_RETCODE m_lkrcState; // Internal state of table
    mutable TableLock m_Lock;       // Lock on entire linear hash table

    // type-specific function pointers
    PFnExtractKey   m_pfnExtractKey;    // Extract key from record
    PFnCalcKeyHash  m_pfnCalcKeyHash;   // Calculate hash signature of key
    PFnEqualKeys    m_pfnEqualKeys;     // Compare two keys
    PFnAddRefRecord m_pfnAddRefRecord;  // AddRef a record

    LK_TABLESIZE  m_lkts;           // "size" of table: small, medium, or large
    DWORD         m_dwSegBits;      // C{Small,Medium,Large}Segment::SEGBITS
    DWORD         m_dwSegSize;      // C{Small,Medium,Large}Segment::SEGSIZE
    DWORD         m_dwSegMask;      // C{Small,Medium,Large}Segment::SEGMASK
    double        m_MaxLoad;        // max load factor (average chain length)

    DWORD         m_dwBktAddrMask0; // mask used for address calculation
    DWORD         m_dwBktAddrMask1; // used in _H1 calculation
    DWORD         m_iExpansionIdx;  // address of next bucket to be expanded
    CDirEntry*    m_paDirSegs;      // directory of table segments
    DWORD         m_nLevel;         // number of table doublings performed
    DWORD         m_cDirSegs;       // segment directory size: varies between
                                    // MIN_DIRSIZE and MAX_DIRSIZE
    DWORD         m_cRecords;       // number of records in the table
    DWORD         m_cActiveBuckets; // number of buckets in use (table size)

    WORD          m_wBucketLockSpins;// default spin count for bucket locks

    const BYTE    m_nTableLockType; // for debugging: LOCK_SPINLOCK, etc
    const BYTE    m_nBucketLockType;// for debugging: LOCK_SPINLOCK, etc
    const CLKRHashTable* const m_phtParent;// Owning table. NULL => standalone

    const bool    m_fMultiKeys;     // Allow multiple identical keys?

#ifndef LKR_NO_GLOBAL_LIST
    static CLockedDoubleList sm_llGlobalList;// All active CLKRLinearHashTables
    CListEntry    m_leGlobalList;
#endif // !LKR_NO_GLOBAL_LIST

    void        _InsertThisIntoGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        // Only add standalone CLKRLinearHashTables to global list.
        // CLKRHashTables have their own global list.
        if (m_phtParent == NULL)
            sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    void        _RemoveThisFromGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        if (m_phtParent == NULL)
            sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    // Non-trivial implementation functions
    LK_RETCODE   _InsertRecord(const void* pvRecord, DWORD dwSignature,
                               bool fOverwrite
#ifdef LKR_STL_ITERATORS
                             , Iterator* piterResult=NULL
#endif // LKR_STL_ITERATORS
                               );
    LK_RETCODE   _DeleteKey(const DWORD_PTR pnKey, DWORD dwSignature);
    LK_RETCODE   _DeleteRecord(const void* pvRecord, DWORD dwSignature);
    bool         _DeleteNode(CBucket* pbkt, CNodeClump*& rpnc,
                             CNodeClump*& rpncPrev, int& riNode);
    LK_RETCODE   _FindKey(const DWORD_PTR pnKey, DWORD dwSignature,
                          const void** ppvRecord
#ifdef LKR_STL_ITERATORS
                        , Iterator* piterResult=NULL
#endif // LKR_STL_ITERATORS
                          ) const;
    LK_RETCODE   _FindRecord(const void* pvRecord, DWORD dwSignature) const;

    // returns count of errors in compacted state => 0 is good
    int          _IsNodeCompact(CBucket* const pbkt) const;


#ifdef LKR_APPLY_IF
    // Predicate functions
    static LK_PREDICATE WINAPI
    _PredTrue(const void* /*pvRecord*/, void* /*pvState*/)
    { return LKP_PERFORM; }

    DWORD        _Apply(PFnRecordAction pfnAction, void* pvState,
                        LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _ApplyIf(PFnRecordPred   pfnPredicate,
                          PFnRecordAction pfnAction, void* pvState,
                          LK_LOCKTYPE lkl, LK_PREDICATE& rlkp);
    DWORD        _DeleteIf(PFnRecordPred pfnPredicate, void* pvState,
                           LK_PREDICATE& rlkp);
#endif // LKR_APPLY_IF

    void         _Clear(bool fShrinkDirectory);
    LK_RETCODE   _SetSegVars(LK_TABLESIZE lkts, DWORD cInitialBuckets);
    LK_RETCODE   _Expand();
    LK_RETCODE   _Contract();
    LK_RETCODE   _SplitRecordSet(CNodeClump* pncOldTarget,
                                 CNodeClump* pncNewTarget,
                                 DWORD       iExpansionIdx,
                                 DWORD       dwBktAddrMask,
                                 DWORD       dwNewBkt,
                                 CNodeClump* pncFreeList);
    LK_RETCODE   _MergeRecordSets(CBucket*    pbktNewTarget,
                                  CNodeClump* pncOldList,
                                  CNodeClump* pncFreeList);

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // TODO: implement these properly; they could be useful.

    CLKRLinearHashTable(const CLKRLinearHashTable&);
    CLKRLinearHashTable& operator=(const CLKRLinearHashTable&);

private:
    // This ctor is used by CLKRHashTable
    CLKRLinearHashTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double          maxload,        // Upperbound on average chain length
        DWORD           initsize,       // Initial size of hash table.
        CLKRHashTable*  phtParent,      // Owning table.
        bool            fMultiKeys      // Allow multiple identical keys?
        );

    LK_RETCODE
    _Initialize(
        PFnExtractKey   pfnExtractKey,
        PFnCalcKeyHash  pfnCalcKeyHash,
        PFnEqualKeys    pfnEqualKeys,
        PFnAddRefRecord pfnAddRefRecord,
        LPCSTR          pszName,
        double          maxload,
        DWORD           initsize);

public:
    CLKRLinearHashTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double   maxload=LK_DFLT_MAXLOAD,// Upperbound on average chain length
        DWORD    initsize=LK_DFLT_INITSIZE, // Initial size of hash table.
        DWORD    num_subtbls=LK_DFLT_NUM_SUBTBLS, // for signature compatiblity
                                                  // with CLKRHashTable
        bool            fMultiKeys=false  // Allow multiple identical keys?
        );

    ~CLKRLinearHashTable();

    static const TCHAR* ClassName()
    {return _TEXT("CLKRLinearHashTable");}

    int                NumSubTables() const  {return 1;}

    bool               MultiKeys() const
    {
        return false;
        // return m_fMultiKeys;     // TODO: implement
    }

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);

    // Insert a new record into hash table.
    // Returns LK_SUCCESS if all OK, LK_KEY_EXISTS if same key already
    // exists (unless fOverwrite), LK_ALLOC_FAIL if out of space,
    // or LK_BAD_RECORD for a bad record.
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;

        return _InsertRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)),
                             fOverwrite);
    }

    // Delete record with the given key.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey)
    {
        if (!IsUsable())
            return m_lkrcState;

        return _DeleteKey(pnKey, _CalcKeyHash(pnKey));
    }

    // Delete a record from the table, if present.
    // Returns LK_SUCCESS if all OK, or LK_NO_SUCH_KEY if not found
    LK_RETCODE     DeleteRecord(const void* pvRecord)
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;

        return _DeleteRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }

    // Find record with given key.
    // Returns:  LK_SUCCESS, if record found (record is returned in *ppvRecord)
    //           LK_BAD_RECORD, if ppvRecord is invalid
    //           LK_NO_SUCH_KEY, if no record with given key value was found
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is AddRef'd.  You must decrement the reference
    // count when you are finished with the record (if you're implementing
    // refcounting semantics).
    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;

        if (ppvRecord == NULL)
            return LK_BAD_RECORD;

        return _FindKey(pnKey, _CalcKeyHash(pnKey), ppvRecord);
    }

    // Sees if the record is contained in the table
    // Returns:  LK_SUCCESS, if record found
    //           LK_BAD_RECORD, if pvRecord is invalid
    //           LK_NO_SUCH_KEY, if record is not in the table
    //           LK_UNUSABLE, if hash table not in usable state
    // Note: the record is *not* AddRef'd.
    LK_RETCODE     FindRecord(const void* pvRecord) const
    {
        if (!IsUsable())
            return m_lkrcState;

        if (pvRecord == NULL)
            return LK_BAD_RECORD;

        return _FindRecord(pvRecord, _CalcKeyHash(_ExtractKey(pvRecord)));
    }


#ifdef LKR_APPLY_IF
    // Walk the hash table, applying pfnAction to all records.
    // Locks the whole table for the duration with either a (possibly
    // shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Walk the hash table, applying pfnAction to any records that match
    // pfnPredicate.  Locks the whole table for the duration with either
    // a (possibly shared) readlock or a writelock, according to lkl.
    // Loop is aborted if pfnAction returns LKA_ABORT.
    // Returns the number of successful applications.
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);

    // Delete any records that match pfnPredicate.
    // Locks the table for the duration with a writelock.
    // Returns the number of deletions.
    //
    // Do *not* walk the hash table by hand with an iterator and call
    // DeleteKey.  The iterator will end up pointing to garbage.
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);
#endif // LKR_APPLY_IF


    // Check table for consistency.  Returns 0 if okay, or the number of
    // errors otherwise.
    int            CheckTable() const;

    // Remove all data from the table
    void           Clear()
    {
        WriteLock();
        _Clear(true);
        WriteUnlock();
    }

    // Number of elements in the table
    DWORD          Size() const
    { return m_cRecords; }

    // Maximum possible number of elements in the table
    DWORD          MaxSize() const
    { return static_cast<DWORD>(m_MaxLoad * MAX_DIRSIZE * m_dwSegSize); }

    // Get hash table statistics
    CLKRHashTableStats GetStatistics() const;

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }

    // Is the hash table consistent and correct?
    bool           IsValid() const
    {
        STATIC_ASSERT(((MIN_DIRSIZE & (MIN_DIRSIZE-1)) == 0)  // == (1 << N)
                      &&  ((1 << 3) <= MIN_DIRSIZE)
                      &&  (MIN_DIRSIZE < MAX_DIRSIZE)
                      &&  ((MAX_DIRSIZE & (MAX_DIRSIZE-1)) == 0)
                      &&  (MAX_DIRSIZE <= (1 << 30)));

        bool f = (m_lkrcState == LK_SUCCESS     // serious internal failure?
                  &&  m_paDirSegs != NULL
                  &&  MIN_DIRSIZE <= m_cDirSegs  &&  m_cDirSegs <= MAX_DIRSIZE
                  &&  (m_cDirSegs & (m_cDirSegs-1)) == 0
                  &&  m_pfnExtractKey != NULL
                  &&  m_pfnCalcKeyHash != NULL
                  &&  m_pfnEqualKeys != NULL
                  &&  m_pfnAddRefRecord != NULL
                  &&  m_cActiveBuckets > 0
                  &&  ValidSignature()
                  );
        if (!f)
            m_lkrcState = LK_UNUSABLE;
        return f;
    }

    // Set the spin count on the table lock
    void        SetTableLockSpinCount(WORD wSpins)
    { m_Lock.SetSpinCount(wSpins); }

    // Get the spin count on the table lock
    WORD        GetTableLockSpinCount() const
    { return m_Lock.GetSpinCount(); }

    // Set/Get the spin count on the bucket locks
    void        SetBucketLockSpinCount(WORD wSpins);
    WORD        GetBucketLockSpinCount() const;

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('L' << 16) | ('H' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('L' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}


    //
    // Lock manipulators
    //

    // Lock the table (exclusively) for writing
    void        WriteLock()
    { m_Lock.WriteLock(); }

    // Lock the table (possibly shared) for reading
    void        ReadLock() const
    { m_Lock.ReadLock(); }

    // Unlock the table for writing
    void        WriteUnlock() const
    { m_Lock.WriteUnlock(); }

    // Unlock the table for reading
    void        ReadUnlock() const
    { m_Lock.ReadUnlock(); }

    // Is the table already locked for writing?
    bool        IsWriteLocked() const
    { return m_Lock.IsWriteLocked(); }

    // Is the table already locked for reading?
    bool        IsReadLocked() const
    { return m_Lock.IsReadLocked(); }

    // Is the table unlocked for writing?
    bool        IsWriteUnlocked() const
    { return m_Lock.IsWriteUnlocked(); }

    // Is the table unlocked for reading?
    bool        IsReadUnlocked() const
    { return m_Lock.IsReadUnlocked(); }

    // Convert the read lock to a write lock
    void  ConvertSharedToExclusive() const
    { m_Lock.ConvertSharedToExclusive(); }

    // Convert the write lock to a read lock
    void  ConvertExclusiveToShared() const
    { m_Lock.ConvertExclusiveToShared(); }

    // LKRHASH_ALLOCATOR_DEFINITIONS(CLKRLinearHashTable);


#ifdef LKR_DEPRECATED_ITERATORS

public:

    // Iterators can be used to walk the table.  To ensure a consistent
    // view of the data, the iterator locks the whole table.  This can
    // have a negative effect upon performance, because no other thread
    // can do anything with the table.  Use with care.
    //
    // You should not use an iterator to walk the table, calling DeleteKey,
    // as the iterator will end up pointing to garbage.
    //
    // Use Apply, ApplyIf, or DeleteIf instead of iterators to safely
    // walk the tree. Or use the STL-style iterators.
    //
    // Note that iterators acquire a reference to the record pointed to
    // and release that reference as soon as the iterator is incremented.
    // In other words, this code is safe:
    //     lkrc = ht.IncrementIterator(&iter);
    //     // assume lkrc == LK_SUCCESS for the sake of this example
    //     CMyHashTable::Record* pRec = iter.Record();
    //     Foo(pRec);  // uses pRec but doesn't hang on to it
    //     lkrc = ht.IncrementIterator(&iter);
    //
    // But this code is not safe because pRec is used out of the scope of
    // the iterator that provided it:
    //     lkrc = ht.IncrementIterator(&iter);
    //     CMyHashTable::Record* pRec = iter.Record();
    //     // Broken code: Should have called ht.AddRefRecord(pRec, +1) here
    //     lkrc = ht.IncrementIterator(&iter);
    //     Foo(pRec);   // Unsafe: because no longer have a valid reference
    //
    // If the record has no reference-counting semantics, then you can
    // ignore the above remarks about scope.


    class CIterator
    {
    protected:
        friend class CLKRLinearHashTable;

        CLKRLinearHashTable* m_plht;        // which linear hash table?
        DWORD               m_dwBucketAddr; // bucket index
        CNodeClump*         m_pnc;          // a CNodeClump in bucket
        int                 m_iNode;        // offset within m_pnc
        LK_LOCKTYPE         m_lkl;          // readlock or writelock?

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // Must provide (bad) implementation because we export instantiations.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : m_plht(NULL),
              m_dwBucketAddr(0),
              m_pnc(NULL),
              m_iNode(-1),
              m_lkl(lkl)
        {}

        // Return the record associated with this iterator
        const void* Record() const
        {
            IRTLASSERT(IsValid());

            return ((m_pnc != NULL
                        &&  m_iNode >= 0
                        &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    ?  m_pnc->m_pvNode[m_iNode]
                    :  NULL);
        }

        // Return the key associated with this iterator
        const DWORD_PTR Key() const
        {
            IRTLASSERT(m_plht != NULL);
            const void* pRec = Record();
            return ((pRec != NULL  &&  m_plht != NULL)
                    ?  m_plht->_ExtractKey(pRec)
                    :  NULL);
        }

        bool IsValid() const
        {
            return ((m_plht != NULL)
                    &&  (m_pnc != NULL)
                    &&  (0 <= m_iNode
                         &&  m_iNode < CLKRLinearHashTable::NODES_PER_CLUMP)
                    &&  (!m_pnc->IsEmptyNode(m_iNode)));
        }

        // Delete the record that the iterator points to.  Does an implicit
        // IncrementIterator after deletion.
        LK_RETCODE     DeleteRecord();

        // Change the record that the iterator points to.  The new record
        // must have the same key as the old one.
        LK_RETCODE     ChangeRecord(const void* pNewRec);
    }; // class CIterator


    // Const iterators for readonly access.  You must use these with
    // const CLKRLinearHashTables.
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    }; // class CConstIterator


private:
    // The public APIs lock the table.  The private ones, which are used
    // directly by CLKRHashTable, don't.
    LK_RETCODE     _InitializeIterator(CIterator* piter);
    LK_RETCODE     _CloseIterator(CIterator* piter);

public:
    // Initialize the iterator to point to the first item in the hash table
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        if (piter == NULL  ||  piter->m_plht != NULL)
            return LK_BAD_ITERATOR;

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteLock();
        else
            ReadLock();

        return _InitializeIterator(piter);
    }

    // The const iterator version
    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        ReadLock();
        return const_cast<CLKRLinearHashTable*>(this)
                    ->_InitializeIterator(static_cast<CIterator*>(piter));
    }

    // Move the iterator on to the next item in the table.
    // Returns LK_SUCCESS, LK_NO_MORE_ELEMENTS, or LK_BAD_ITERATOR.
    LK_RETCODE     IncrementIterator(CIterator* piter);

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRLinearHashTable*>(this)
                    ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    // Close the iterator.
    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        if (piter == NULL  ||  piter->m_plht != this)
            return LK_BAD_ITERATOR;
        _CloseIterator(piter);

        if (piter->m_lkl == LKL_WRITELOCK)
            WriteUnlock();
        else
            ReadUnlock();

        return LK_SUCCESS;
    };

    // Close the CConstIterator
    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_plht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_plht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        const_cast<CLKRLinearHashTable*>(this)
             ->_CloseIterator(static_cast<CIterator*>(piter));

        ReadUnlock();
        return LK_SUCCESS;
    };

#endif // LKR_DEPRECATED_ITERATORS


#ifdef LKR_STL_ITERATORS

private:
    bool _Erase(Iterator& riter, DWORD dwSignature);
    bool _Find(DWORD_PTR pnKey, DWORD dwSignature, Iterator& riterResult);

    bool _IsValidIterator(const Iterator& riter) const
    {
        LKR_ITER_TRACE(_TEXT("  LKLH:_IsValidIterator(%p)\n"), &riter);
        bool fValid = ((riter.m_plht == this)
                       &&  (riter.m_dwBucketAddr < m_cActiveBuckets)
                       &&  riter.IsValid());
        IRTLASSERT(fValid);
        return fValid;
    }

public:
    // Return iterator pointing to first item in table
    Iterator
    Begin();

    // Return a one-past-the-end iterator. Always empty.
    Iterator
    End()
    {
        LKR_ITER_TRACE(_TEXT("  LKLH::End\n"));
        return Iterator();
    }

    // Insert a record
    // Returns `true' if successful; iterResult points to that record
    // Returns `false' otherwise; iterResult == End()
    bool
    Insert(
        /* in */  const void* pvRecord,
        /* out */ Iterator&   riterResult,
        /* in */  bool        fOverwrite=false);

    // Erase the record pointed to by the iterator; adjust the iterator
    // to point to the next record. Returns `true' if successful.
    bool
    Erase(
        /* in,out */ Iterator& riter);

    // Erase the records in the range [riterFirst, riterLast).
    // Returns `true' if successful.
    bool
    Erase(
        /*in*/ Iterator& riterFirst,
        /*in*/ Iterator& riterLast);

    // Find the (first) record that has its key == pnKey.
    // If successful, returns `true' and iterator points to (first) record.
    // If fails, returns `false' and iterator == End()
    bool
    Find(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterResult);

    // Find the range of records that have their keys == pnKey.
    // If successful, returns `true', iterFirst points to first record,
    //     and iterLast points to one-beyond-the last such record.
    // If fails, returns `false' and both iterators == End().
    // Primarily useful when m_fMultiKey == true
    bool
    EqualRange(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterFirst,     // inclusive
        /* out */ Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS

}; // class CLKRLinearHashTable



#ifdef LKR_STL_ITERATORS

// These functions have to be defined after CLKRLinearHashTable

inline void
CLKRLinearHashTable_Iterator::_AddRef(
    int nIncr) const
{
    // TODO: should iterator call _AddRefRecord at all
    if (m_plht != NULL  &&  m_iNode != NODE_BEGIN - NODE_STEP)
    {
        IRTLASSERT((0 <= m_iNode  &&  m_iNode < NODES_PER_CLUMP)
                   &&  (unsigned) m_iNode < NODES_PER_CLUMP
                   &&  m_pnc != NULL
                   &&  (nIncr == -1 ||  nIncr == +1));
        const void* pvRecord = m_pnc->m_pvNode[m_iNode];
        IRTLASSERT(pvRecord != NULL);
        LKR_ITER_TRACE(_TEXT("  LKLH::AddRef, this=%p, Rec=%p\n"),
                       this, pvRecord);
        m_plht->_AddRefRecord(pvRecord, nIncr);
    }
} // CLKRLinearHashTable_Iterator::_AddRef


inline const DWORD_PTR
CLKRLinearHashTable_Iterator::Key() const
{
    IRTLASSERT(IsValid());
    return m_plht->_ExtractKey(m_pnc->m_pvNode[m_iNode]);
} // CLKRLinearHashTable_Iterator::Key

#endif // LKR_STL_ITERATORS



//--------------------------------------------------------------------
// CLKRHashTable
//
// To improve concurrency, a hash table is divided into a number of
// (independent) subtables. Each subtable is a linear hash table. The
// number of subtables is defined when the table is created and remains
// fixed thereafter. Records are assigned to subtables based on their
// hashed key.
//
// For small or low-contention hashtables, you can bypass this
// thin wrapper and use CLKRLinearHashTable directly.  The methods are
// documented in the declarations for CLKRHashTable (above).
//--------------------------------------------------------------------

class IRTL_DLLEXP CLKRHashTable
{
private:
    typedef CLKRLinearHashTable SubTable;

public:
    typedef SubTable::TableLock  TableLock;
    typedef SubTable::BucketLock BucketLock;

#ifdef LKR_DEPRECATED_ITERATORS
    class CIterator;
    friend class CLKRHashTable::CIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_STL_ITERATORS
    friend class CLKRHashTable_Iterator;
    typedef CLKRHashTable_Iterator Iterator;
#endif // LKR_STL_ITERATORS

    friend class CLKRLinearHashTable;

    // aliases for convenience
    enum {
        NAME_SIZE = SubTable::NAME_SIZE,
        HASH_INVALID_SIGNATURE = SubTable::HASH_INVALID_SIGNATURE,
        NODES_PER_CLUMP = SubTable::NODES_PER_CLUMP,
    };

    enum {
        MAX_SUBTABLES = 64,
    };

private:
    // Hash table parameters
    DWORD          m_dwSignature;   // debugging: id & corruption check
    CHAR           m_szName[NAME_SIZE]; // an identifier for debugging
    DWORD          m_cSubTables;    // number of subtables
    SubTable**     m_palhtDir;      // array of subtables

    // type-specific function pointers
    PFnExtractKey  m_pfnExtractKey;
    PFnCalcKeyHash m_pfnCalcKeyHash;
    mutable LK_RETCODE m_lkrcState;     // Internal state of table
    int            m_nSubTableMask;

#ifndef LKR_NO_GLOBAL_LIST
    static CLockedDoubleList sm_llGlobalList; // All active CLKRHashTables
    CListEntry     m_leGlobalList;
#endif // !LKR_NO_GLOBAL_LIST

    void
    _InsertThisIntoGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        sm_llGlobalList.InsertHead(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    void
    _RemoveThisFromGlobalList()
    {
#ifndef LKR_NO_GLOBAL_LIST
        sm_llGlobalList.RemoveEntry(&m_leGlobalList);
#endif // !LKR_NO_GLOBAL_LIST
    }

    LKRHASH_GLOBAL_LOCK_DECLARATIONS();

    // Private copy ctor and op= to prevent compiler synthesizing them.
    // TODO: implement these properly; they could be useful.
    CLKRHashTable(const CLKRHashTable&);
    CLKRHashTable& operator=(const CLKRHashTable&);


    // Extract the key from the record
    const DWORD_PTR  _ExtractKey(const void* pvRecord) const
    {
        IRTLASSERT(pvRecord != NULL);
        IRTLASSERT(m_pfnExtractKey != NULL);
        return (*m_pfnExtractKey)(pvRecord);
    }

    // Hash the key
    DWORD        _CalcKeyHash(const DWORD_PTR pnKey) const
    {
        // Note pnKey==0 is acceptable, as the real key type could be an int
        IRTLASSERT(m_pfnCalcKeyHash != NULL);
        DWORD dwHash = (*m_pfnCalcKeyHash)(pnKey);
        // We forcibly scramble the result to help ensure a better distribution
#ifndef __HASHFN_NO_NAMESPACE__
        dwHash = HashFn::HashRandomizeBits(dwHash);
#else // !__HASHFN_NO_NAMESPACE__
        dwHash = ::HashRandomizeBits(dwHash);
#endif // !__HASHFN_NO_NAMESPACE__
        IRTLASSERT(dwHash != HASH_INVALID_SIGNATURE);
        return dwHash;
    }

    // Use the key's hash signature to multiplex into a subtable
    SubTable*    _SubTable(DWORD dwSignature) const;

    // Find the index of pst within the subtable array
    int          _SubTableIndex(SubTable* pst) const;

    // Memory allocation wrappers to allow us to simulate allocation
    // failures during testing
    static SubTable** const
    _AllocateSubTableArray(
        size_t n);

    static bool
    _FreeSubTableArray(
        SubTable** palht);

    static SubTable* const
    _AllocateSubTable(
        LPCSTR          pszName,        // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double          maxload,        // Upperbound on average chain length
        DWORD           initsize,       // Initial size of hash table.
        CLKRHashTable*  phtParent,      // Owning table.
        bool            fMultiKeys      // Allow multiple identical keys?
    );

    static bool
    _FreeSubTable(
        SubTable* plht);


public:
    CLKRHashTable(
        LPCSTR   pszName,               // An identifier for debugging
        PFnExtractKey   pfnExtractKey,  // Extract key from record
        PFnCalcKeyHash  pfnCalcKeyHash, // Calculate hash signature of key
        PFnEqualKeys    pfnEqualKeys,   // Compare two keys
        PFnAddRefRecord pfnAddRefRecord,// AddRef in FindKey, etc
        double    maxload=LK_DFLT_MAXLOAD,      // bound on avg chain length
        DWORD     initsize=LK_DFLT_INITSIZE,    // Initial size of hash table.
        DWORD     num_subtbls=LK_DFLT_NUM_SUBTBLS, // #subordinate hash tables.
        bool            fMultiKeys=false  // Allow multiple identical keys?
        );

    ~CLKRHashTable();

    static const TCHAR* ClassName()
    {return _TEXT("CLKRHashTable");}

    int                NumSubTables() const  {return m_cSubTables;}

    bool               MultiKeys() const;

    static LK_TABLESIZE NumSubTables(DWORD& rinitsize, DWORD& rnum_subtbls);


    // Thin wrappers for the corresponding methods in CLKRLinearHashTable
    LK_RETCODE     InsertRecord(const void* pvRecord, bool fOverwrite=false);
    LK_RETCODE     DeleteKey(const DWORD_PTR pnKey);
    LK_RETCODE     DeleteRecord(const void* pvRecord);
    LK_RETCODE     FindKey(const DWORD_PTR pnKey,
                           const void** ppvRecord) const;
    LK_RETCODE     FindRecord(const void* pvRecord) const;

#ifdef LKR_APPLY_IF
    DWORD          Apply(PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          ApplyIf(PFnRecordPred   pfnPredicate,
                           PFnRecordAction pfnAction,
                           void*           pvState=NULL,
                           LK_LOCKTYPE     lkl=LKL_READLOCK);
    DWORD          DeleteIf(PFnRecordPred pfnPredicate,
                            void*         pvState=NULL);
#endif // LKR_APPLY_IF

    void           Clear();
    int            CheckTable() const;
    DWORD          Size() const;
    DWORD          MaxSize() const;
    CLKRHashTableStats GetStatistics() const;
    bool           IsValid() const;

    void           SetTableLockSpinCount(WORD wSpins);
    WORD           GetTableLockSpinCount() const;
    void           SetBucketLockSpinCount(WORD wSpins);
    WORD           GetBucketLockSpinCount() const;

    enum {
        SIGNATURE =      (('L') | ('K' << 8) | ('H' << 16) | ('T' << 24)),
        SIGNATURE_FREE = (('L') | ('K' << 8) | ('H' << 16) | ('x' << 24)),
    };

    bool
    ValidSignature() const
    { return m_dwSignature == SIGNATURE;}

    // Is the hash table usable?
    bool           IsUsable() const
    { return (m_lkrcState == LK_SUCCESS); }

    void        WriteLock();
    void        ReadLock() const;
    void        WriteUnlock() const;
    void        ReadUnlock() const;
    bool        IsWriteLocked() const;
    bool        IsReadLocked() const;
    bool        IsWriteUnlocked() const;
    bool        IsReadUnlocked() const;
    void        ConvertSharedToExclusive() const;
    void        ConvertExclusiveToShared() const;


    // LKRHASH_ALLOCATOR_DEFINITIONS(CLKRHashTable);

#ifdef LKR_DEPRECATED_ITERATORS

public:

    typedef SubTable::CIterator CLHTIterator;

    class CIterator : public CLHTIterator
    {
    protected:
        friend class CLKRHashTable;

        CLKRHashTable*  m_pht;  // which hash table?
        int             m_ist;  // which subtable

    private:
        // Private copy ctor and op= to prevent compiler synthesizing them.
        // TODO: implement these properly; they could be useful.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : CLHTIterator(lkl),
              m_pht(NULL),
              m_ist(-1)
        {}

        const void* Record() const
        {
            IRTLASSERT(IsValid());

            // This is a hack to work around a compiler bug.  Calling
            // CLHTIterator::Record calls this function recursively until
            // the stack overflows.
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Record();
        }

        const DWORD_PTR Key() const
        {
            IRTLASSERT(IsValid());
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return pBase->Key();
        }

        bool IsValid() const
        {
            const CLHTIterator* pBase = static_cast<const CLHTIterator*>(this);
            return (m_pht != NULL  &&  m_ist >= 0  &&  pBase->IsValid());
        }
    };

    // Const iterators for readonly access
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter);
    LK_RETCODE     IncrementIterator(CIterator* piter);
    LK_RETCODE     CloseIterator(CIterator* piter);

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == NULL);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != NULL
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        IRTLASSERT(piter != NULL  &&  piter->m_pht == this);
        IRTLASSERT(piter->m_lkl != LKL_WRITELOCK);

        if (piter == NULL  ||  piter->m_pht != this
            ||  piter->m_lkl == LKL_WRITELOCK)
            return LK_BAD_ITERATOR;

        return const_cast<CLKRHashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    };

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

private:
    bool _IsValidIterator(const Iterator& riter) const
    {
        LKR_ITER_TRACE(_TEXT(" LKHT:_IsValidIterator(%p)\n"), &riter);
        bool fValid = (riter.m_pht == this);
        IRTLASSERT(fValid);
        fValid = fValid  &&  (0 <= riter.m_ist
                              &&  riter.m_ist < (int) m_cSubTables);
        IRTLASSERT(fValid);
        IRTLASSERT(_SubTableIndex(riter.m_subiter.m_plht) == riter.m_ist);
        fValid = fValid  &&  riter.IsValid();
        IRTLASSERT(fValid);
        return fValid;
    }


public:
    Iterator
    Begin();

    Iterator
    End()
    {
        LKR_ITER_TRACE(_TEXT(" LKHT::End\n"));
        return Iterator();
    }

    bool
    Insert(
        /* in */  const void* pvRecord,
        /* out */ Iterator&   riterResult,
        /* in */  bool        fOverwrite=false);

    bool
    Erase(
        /* in,out */ Iterator& riter);

    bool
    Erase(
        /*in*/ Iterator& riterFirst,
        /*in*/ Iterator& riterLast);

    bool
    Find(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterResult);

    bool
    EqualRange(
        /* in */  DWORD_PTR pnKey,
        /* out */ Iterator& riterFirst,     // inclusive
        /* out */ Iterator& riterLast);     // exclusive

#endif // LKR_STL_ITERATORS

}; // class CLKRHashTable



//--------------------------------------------------------------------
// A typesafe wrapper for CLKRHashTable (or CLKRLinearHashTable).
//
// * _Derived must derive from CTypedHashTable and provide certain member
//   functions.  It's needed for various downcasting operations.  See
//   CStringTestHashTable and CNumberTestHashTable below.
// * _Record is the type of the record.  C{Linear}HashTable will store
//   pointers to _Record.
// * _Key is the type of the key.  _Key is used directly; i.e., it is
//   not assumed to be a pointer type.  C{Linear}HashTable assumes that
//   the key is stored in the associated record.  See the comments
//   at the declaration of PFnExtractKey for more details.
//
// (optional parameters):
// * _BaseHashTable is the base hash table: CLKRHashTable or
///   CLKRLinearHashTable
// * _BaseIterator is the iterator type, _BaseHashTable::CIterator
//
// CTypedHashTable could derive directly from CLKRLinearHashTable, if you
// don't need the extra overhead of CLKRHashTable (which is quite low).
//
// You may need to add the following line to your code to disable
// warning messages about truncating extremly long identifiers.
//   #pragma warning (disable : 4786)
//--------------------------------------------------------------------


template < class _Derived, class _Record, class _Key,
           class _BaseHashTable=CLKRHashTable
#ifdef LKR_DEPRECATED_ITERATORS
         , class _BaseIterator=_BaseHashTable::CIterator
#endif // LKR_DEPRECATED_ITERATORS
         >
class CTypedHashTable : public _BaseHashTable
{
public:
    // convenient aliases
    typedef _Derived        Derived;
    typedef _Record         Record;
    typedef _Key            Key;
    typedef _BaseHashTable  BaseHashTable;

    typedef CTypedHashTable<_Derived, _Record, _Key, _BaseHashTable
#ifdef LKR_DEPRECATED_ITERATORS
                            , _BaseIterator
#endif // LKR_DEPRECATED_ITERATORS
                            > HashTable;
#ifdef LKR_DEPRECATED_ITERATORS
    typedef _BaseIterator   BaseIterator;
#endif // LKR_DEPRECATED_ITERATORS

#ifdef LKR_APPLY_IF
    // ApplyIf() and DeleteIf(): Does the record match the predicate?
    // Note: takes a Record*, not a const Record*.  You can modify the
    // record in Pred() or Action(), if you like, but if you do, you
    // should use LKL_WRITELOCK to lock the table. Do NOT modify the key,
    // unless you're going to remove the record from the table.
    typedef LK_PREDICATE (WINAPI *PFnRecordPred) (Record* pRec, void* pvState);

    // Apply() et al: Perform action on record.
    typedef LK_ACTION   (WINAPI *PFnRecordAction)(Record* pRec, void* pvState);
#endif // LKR_APPLY_IF

private:

    // Wrappers for the typesafe methods exposed by the derived class

    static const DWORD_PTR WINAPI
    _ExtractKey(const void* pvRecord)
    {
        const _Record* pRec = static_cast<const _Record*>(pvRecord);
        const _Key   key = static_cast<const _Key>(_Derived::ExtractKey(pRec));
        // I would prefer to use reinterpret_cast here and in _CalcKeyHash
        // and _CompareKeys, but the stupid Win64 compiler thinks it knows
        // better than I do.
        return (const DWORD_PTR) key;
    }

    static DWORD WINAPI
    _CalcKeyHash(const DWORD_PTR pnKey)
    {
        const _Key key = (const _Key) (DWORD_PTR) pnKey;
        return _Derived::CalcKeyHash(key);
    }

    static bool WINAPI
    _EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2)
    {
        const _Key key1 = (const _Key) (DWORD_PTR) pnKey1;
        const _Key key2 = (const _Key) (DWORD_PTR) pnKey2;
        return _Derived::EqualKeys(key1, key2);
    }

    static void WINAPI
    _AddRefRecord(const void* pvRecord, int nIncr)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        _Derived::AddRefRecord(pRec, nIncr);
    }


#ifdef LKR_APPLY_IF
    // Typesafe wrappers for Apply, ApplyIf, and DeleteIf.

    class CState
    {
    public:
        PFnRecordPred   m_pfnPred;
        PFnRecordAction m_pfnAction;
        void*           m_pvState;

        CState(
            PFnRecordPred   pfnPred,
            PFnRecordAction pfnAction,
            void*           pvState)
            : m_pfnPred(pfnPred), m_pfnAction(pfnAction), m_pvState(pvState)
        {}
    };

    static LK_PREDICATE WINAPI
    _Pred(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnPred)(pRec, pState->m_pvState);
    }

    static LK_ACTION WINAPI
    _Action(const void* pvRecord, void* pvState)
    {
        _Record* pRec = static_cast<_Record*>(const_cast<void*>(pvRecord));
        CState*  pState = static_cast<CState*>(pvState);

        return (*pState->m_pfnAction)(pRec, pState->m_pvState);
    }
#endif // LKR_APPLY_IF

public:
    CTypedHashTable(
        LPCSTR pszName,                       // An identifier for debugging
        double maxload=LK_DFLT_MAXLOAD,       // Upperbound on avg chain len
        DWORD  initsize=LK_DFLT_INITSIZE,     // Initial size of table: S/M/L
        DWORD  num_subtbls=LK_DFLT_NUM_SUBTBLS,// #subordinate hash tables.
        bool   fMultiKeys=false               // Allow multiple identical keys?
        )
        : _BaseHashTable(pszName, _ExtractKey, _CalcKeyHash, _EqualKeys,
                            _AddRefRecord, maxload, initsize, num_subtbls,
                            fMultiKeys)
    {
        // Ensure that _Key is no bigger than a pointer. Because we
        // support both numeric and pointer keys, the various casts
        // in the member functions unfortunately silently truncate if
        // _Key is an unacceptable numeric type, such as __int64 on x86.
        STATIC_ASSERT(sizeof(_Key) <= sizeof(DWORD_PTR));
    }

    LK_RETCODE   InsertRecord(const _Record* pRec, bool fOverwrite=false)
    { return _BaseHashTable::InsertRecord(pRec, fOverwrite); }

    LK_RETCODE   DeleteKey(const _Key key)
    {
        DWORD_PTR pnKey = (DWORD_PTR) key;
        return _BaseHashTable::DeleteKey(pnKey);
    }

    LK_RETCODE   DeleteRecord(const _Record* pRec)
    { return _BaseHashTable::DeleteRecord(pRec);}

    // Note: returns a _Record**, not a const Record**.  Note that you
    // can use a const type for the template parameter to ensure constness.
    LK_RETCODE   FindKey(const _Key key, _Record** ppRec) const
    {
        if (ppRec == NULL)
            return LK_BAD_RECORD;
        *ppRec = NULL;
        const void* pvRec = NULL;
        DWORD_PTR pnKey = (DWORD_PTR) key;
        LK_RETCODE lkrc = _BaseHashTable::FindKey(pnKey, &pvRec);
        *ppRec = static_cast<_Record*>(const_cast<void*>(pvRec));
        return lkrc;
    }

    LK_RETCODE   FindRecord(const _Record* pRec) const
    { return _BaseHashTable::FindRecord(pRec);}


    // Other C{Linear}HashTable methods can be exposed without change


#ifdef LKR_APPLY_IF

public:

    // Typesafe wrappers for Apply et al

    DWORD        Apply(PFnRecordAction pfnAction,
                       void*           pvState=NULL,
                       LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnAction != NULL);
        if (pfnAction == NULL)
            return 0;

        CState   state(NULL, pfnAction, pvState);
        return   _BaseHashTable::Apply(_Action, &state, lkl);
    }

    DWORD        ApplyIf(PFnRecordPred   pfnPredicate,
                         PFnRecordAction pfnAction,
                         void*           pvState=NULL,
                         LK_LOCKTYPE     lkl=LKL_READLOCK)
    {
        IRTLASSERT(pfnPredicate != NULL  &&  pfnAction != NULL);
        if (pfnPredicate == NULL  ||  pfnAction == NULL)
            return 0;

        CState   state(pfnPredicate, pfnAction, pvState);
        return   _BaseHashTable::ApplyIf(_Pred, _Action, &state, lkl);
    }

    DWORD        DeleteIf(PFnRecordPred pfnPredicate, void* pvState=NULL)
    {
        IRTLASSERT(pfnPredicate != NULL);
        if (pfnPredicate == NULL)
            return 0;

        CState   state(pfnPredicate, NULL, pvState);
        return   _BaseHashTable::DeleteIf(_Pred, &state);
    }
#endif // LKR_APPLY_IF



#ifdef LKR_DEPRECATED_ITERATORS
    // Typesafe wrappers for iterators


    class CIterator : public _BaseIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CIterator(const CIterator&);
        CIterator& operator=(const CIterator&);

    public:
        CIterator(
            LK_LOCKTYPE lkl=LKL_WRITELOCK)
            : _BaseIterator(lkl)
        {}

        _Record*  Record() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Record*>(const_cast<void*>(
                        pBase->Record()));
        }

        _Key      Key() const
        {
            const _BaseIterator* pBase = static_cast<const _BaseIterator*>(this);
            return reinterpret_cast<_Key>(reinterpret_cast<void*>(pBase->Key()));
        }
    };

    // readonly iterator
    class CConstIterator : public CIterator
    {
    private:
        // Private, unimplemented copy ctor and op= to prevent
        // compiler synthesizing them.
        CConstIterator(const CConstIterator&);
        CConstIterator& operator=(const CConstIterator&);

    public:
        CConstIterator()
            : CIterator(LKL_READLOCK)
        {}

        const _Record*  Record() const
        {
            return CIterator::Record();
        }

        const _Key      Key() const
        {
            return CIterator::Key();
        }
    };


public:
    LK_RETCODE     InitializeIterator(CIterator* piter)
    {
        return _BaseHashTable::InitializeIterator(piter);
    }

    LK_RETCODE     IncrementIterator(CIterator* piter)
    {
        return _BaseHashTable::IncrementIterator(piter);
    }

    LK_RETCODE     CloseIterator(CIterator* piter)
    {
        return _BaseHashTable::CloseIterator(piter);
    }

    LK_RETCODE     InitializeIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->InitializeIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     IncrementIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->IncrementIterator(static_cast<CIterator*>(piter));
    }

    LK_RETCODE     CloseIterator(CConstIterator* piter) const
    {
        return const_cast<HashTable*>(this)
                ->CloseIterator(static_cast<CIterator*>(piter));
    }

#endif // LKR_DEPRECATED_ITERATORS



#ifdef LKR_STL_ITERATORS

    // TODO: const_iterator

public:

    class iterator
    {
        friend class CTypedHashTable<_Derived, _Record, _Key,
                                     _BaseHashTable
 #ifdef LKR_DEPRECATED_ITERATORS
                                     , _BaseIterator
 #endif // LKR_DEPRECATED_ITERATORS
        >;

    protected:
        typename _BaseHashTable::Iterator            m_iter;

        iterator(
            const typename _BaseHashTable::Iterator& rhs)
            : m_iter(rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::prot ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

    public:
        typedef std::forward_iterator_tag   iterator_category;
        typedef _Record                     value_type;
        typedef ptrdiff_t                   difference_type;
        typedef size_t                      size_type;
        typedef value_type&                 reference;
        typedef value_type*                 pointer;

        iterator()
            : m_iter()
        {
            LKR_ITER_TRACE(_TEXT("Typed::default ctor, this=%p\n"), this);
        }

        iterator(
            const iterator& rhs)
            : m_iter(rhs.m_iter)
        {
            LKR_ITER_TRACE(_TEXT("Typed::copy ctor, this=%p, rhs=%p\n"),
                           this, &rhs);
        }

        iterator& operator=(
            const iterator& rhs)
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator=, this=%p, rhs=%p\n"),
                           this, &rhs);
            m_iter = rhs.m_iter;
            return *this;
        }

        ~iterator()
        {
            LKR_ITER_TRACE(_TEXT("Typed::dtor, this=%p\n"), this);
        }

        pointer   operator->() const
        {
            return (reinterpret_cast<_Record*>(
                        const_cast<void*>(m_iter.Record())));
        }

        reference operator*() const
        {
            return * (operator->());
        }

        // pre-increment
        iterator& operator++()
        {
            LKR_ITER_TRACE(_TEXT("Typed::pre-increment, this=%p\n"), this);
            m_iter.Increment();
            return *this;
        }

        // post-increment
        iterator  operator++(int)
        {
            LKR_ITER_TRACE(_TEXT("Typed::post-increment, this=%p\n"), this);
            iterator iterPrev = *this;
            m_iter.Increment();
            return iterPrev;
        }

        bool operator==(
            const iterator& rhs) const
        {
            LKR_ITER_TRACE(_TEXT("Typed::operator==, this=%p, rhs=%p\n"),
                          